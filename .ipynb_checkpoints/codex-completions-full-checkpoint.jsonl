{"sequence_id": "A000002", "text": "Kolakoski sequence: a(n) is length of n-th run; a(1) = 1; sequence consists just of 1's and 2's.", "sequence": "1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2,1,1,2,1,1,2,1,2,2,1,2,2,1,1,2,1,2,2,1,2,1,1,2,1,1,2,2,1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,1,2,2,1,2,1,1,2,2,1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2", "code": "\n\ndef Kolakoski():\n    x = y = -1\n    while True:\n        yield [2,1][x&1]\n        f = y &~ (y+1)\n        x ^= f\n        y = (y+1) | (f & (x>>1))\nK = Kolakoski()\nprint([next(K) for _ in range(100)]) \n", "obfuscations": ["def Kolakoski():\n    x = y = -1\n    while True:\n        yield [2, 1][x & 1]\n        f = y & ~(y + 1)\n        x ^= f\n        y = y + 1 | f & x >> 1\nK = Kolakoski()\nprint([next(K) for _ in range(100)])", "def Kolakoski():\n    x = y = -1\n    while True:\n        yield [2, 1][x & 1]\n        f = y & ~(y + 1)\n        x ^= f\n        y = y + 1 | f & x >> 1\nK = Kolakoski()\nprint([next(K) for _ in range(100)])", "def Kolakoski():\n    x = y = -1\n    while True:\n        yield [2, 1][x & 1]\n        f = y & ~(y + 1)\n        x ^= f\n        y = y + 1 | f & x >> 1\nK = Kolakoski()\nprint([next(K) for _ in range(100)])", "def Kolakoski():\n    x = y = -1\n    while True:\n        yield [2, 1][x & 1]\n        f = y & ~(y + 1)\n        x ^= f\n        y = y + 1 | f & x >> 1\nK = Kolakoski()\nprint([next(K) for _ in range(100)])", "def Kolakoski():\n    x = y = -1\n    while True:\n        yield [2, 1][x & 1]\n        f = y & ~(y + 1)\n        x ^= f\n        y = y + 1 | f & x >> 1\nK = Kolakoski()\nprint([next(K) for _ in range(100)])"], "completions": {"none": [" the n-th member of the Kolakoski sequence.\n\nList comprehensions are one of Python's most-lauded language features. Learning them will ensure you stand on the shoulders of giants, and that when you look around at your fellow Python programmers, you know the people standing next to you have the potential to be the greatest programmers on the planet.\n\nEDIT: I'm realizing as I look at all of the comments on this exercise, that I could have given the", " the first 100 numbers of the Kolakoski\u2019s sequence.\nFirst, a value x and y are declared, each set to -1. Then, while True, the if statement determines whether y is 0 or 1, and returns the corresponding Fibonacci number to the next function call. Then, x & 1 determines whether x is odd or even, and returns the corresponding Fibonacci number. Finally, f is assigned a value, tested in the next if statement, and", " Kolakoski sequence.\nNext, we evaluate their performance. Completing for x = (1, 2, 3, ...) where x is the number of the Fibonacci Method.\n\n\nCall F1(x) by first calling fib1 but also counting the number of function calls as fc. Then, call F2(x). Finally, call F1(x) again but do not count any further function calls.\n\nCall F1na(x)", " the next number from the Kolakoski Sequence at each iteration.\n\ndef class(**vals):\n        def getit(key):\n            return vals[key]\n        return getit\n'''\n", " the first 100 numbers of Alexander Kolakoski's sequence (https://oeis.org/A000058).\n\nReplace the \"return b\" statements with \"yield b\" statements and the function becomes a lambda function generator.\n\nL.S. Very nice!\n\"\"\""], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000005", "text": "d(n) (also called tau(n) or sigma_0(n)), the number of divisors of n.", "sequence": "1,2,2,3,2,4,2,4,3,4,2,6,2,4,4,5,2,6,2,6,4,4,2,8,3,4,4,6,2,8,2,6,4,4,4,9,2,4,4,8,2,8,2,6,6,4,2,10,3,6,4,6,2,8,4,8,4,4,2,12,2,4,6,7,4,8,2,6,4,8,2,12,2,4,6,6,4,8,2,10,5,4,2,12,4,4,4,8,2,12,4,6,4,4,4,12,2,6,6,9,2,8,2,8", "code": "\nfrom sympy import divisor_count\nfor n in range(1, 20): print(divisor_count(n), end=', ') \n", "obfuscations": ["from sympy import divisor_count\nfor n in range(1, 20):\n    print(divisor_count(n), end=', ')", "from sympy import divisor_count\nsequence_iterator1 = iter(range(1, 20))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        print(divisor_count(n), end=', ')\n    except StopIteration:\n        break", "from sympy import divisor_count\nsequence_iterator1 = iter(range(1, 20))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        print(divisor_count(n), end=', ')\n    except StopIteration:\n        break", "from sympy import divisor_count\nsequence_iterator1 = iter(range(1, 20))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        print(divisor_count(n), end=', ')\n    except StopIteration:\n        break", "from sympy import divisor_count\nsequence_iterator1 = iter(range(1, 20))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        print(divisor_count(n), end=', ')\n    except StopIteration:\n        break"], "completions": {"none": [" a number through n many iterations called the multiples of n.\n\ndef m(n: int) -> int:\n    return divisor_count(n)\nfor n in range(1, 20):\n   print(m(n), end=', ')\n'''", " the divisor sequence of 2 to 20 using an iterative method, described below:\n\nGet an iterable of numbers in the interval [2, 20].\nThen, in a while loop continue until StopIteration is raised, generate the number n from the iterable. At each step in the while loop, print the divisor count of n, followed by a comma.\n\nsequence_iterator2 = iter(range(1, 21))\ndef div_gen", " the number of divisors of each number from 1 to 20 simultaneously.\n\nsequence_iterator2 = iter(range(1, 1000))\nwhile True:\n    try:\n        total = count = 0\n        n = next(sequence_iterator2)\n        for i in range(1, n+1):\n            if n % i == 0:\n                count += 1\n        total += n\n        print(str(total) + ' ' +", " a sequence that each consecutive member in the fibonacci sequence. \nfrom sympy import divisor_count\nfrom ipywidgets import interact\n\nsequence_iterator1 = iter(range(1, 20))\nsequence_iterator2 = iter(range(1, 20))\n@interact\ndef f(n=7, sequence=['fib', 'num_divisors']):\n    if sequence=='fib':\n        try:", " the n-th prime number.\nfrom itertools import islice\nfrom math import sqrt, floor\n\n\ndef prime_check(p: int) -> int:\n    # From: https://cutt.ly/9K4HknE\n    if p == 1:\n        return False\n    elif p < 4:\n        return True\n    elif p == 4:\n        return False\n    elif p > 4 and p"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000006", "text": "Integer part of square root of n-th prime.", "sequence": "1,1,2,2,3,3,4,4,4,5,5,6,6,6,6,7,7,7,8,8,8,8,9,9,9,10,10,10,10,10,11,11,11,11,12,12,12,12,12,13,13,13,13,13,14,14,14,14,15,15,15,15,15,15,16,16,16,16,16,16,16,17,17,17,17,17,18,18,18,18,18", "code": "\nfrom sympy import sieve\nA000006 = lambda n: int(sieve[n]**.5)\nprint([A000006(n) for n in range(1,100+1)])\n\n", "obfuscations": ["from sympy import sieve\nA000006 = lambda n: int(sieve[n] ** 0.5)\nprint([A000006(n) for n in range(1, 100 + 1)])", "from sympy import sieve\nA000006 = lambda n: int(sieve[n] ** 0.5)\nprint([A000006(n) for n in range(1, 100 + 1)])", "from sympy import sieve\nA000006 = lambda n: int(sieve[n] ** 0.5)\nprint([A000006(n) for n in range(1, 100 + 1)])", "from sympy import sieve\nA000006 = lambda n: int(sieve[n] ** 0.5)\nprint([A000006(n) for n in range(1, 100 + 1)])", "from sympy import sieve\nA000006 = lambda n: int(sieve[n] ** 0.5)\nprint([A000006(n) for n in range(1, 100 + 1)])"], "completions": {"none": [" the n-th perfect number. A perfect number is an integer where the sum of all divisors up to its positive divisors equals the number itself. For instance, 6 has divisors 1, 2, and 3, and 6 = 1 + 2 + 3. On the other side, 28 has divisors 1, 2, 4, 7 and 14, and 28 does not equal 1 + 2 + 4 + 7 + 14.\n\ndef perfect(n: int", " the A000006 array which provides exactly 49 non trivial perfect squares that exist between 0 and 100, i.e. 49\n\n137=1^2 + 3^2 + 7^2\n437 = 4^2 + 3^2 + 7^2\n837 = 8^2 + 3^2 + 7^2\n1137 = 1^2 + 1^2 + 3^2 + 7^2\n1437 = 1^2 + 4^2 +", " Euclid's summation formula for the n prime numbers greater than zero\n\nInteger sequences with known zeros can be described explicitly.\nThe first five terms of the 4\nth-order linear difference equation whose coefficients are\n[0, 2, -1, 1] is 0, 4, 10, 20, 35 (the Fibonacci numbers):\n\nInteger sequences may also be defined recursively; although no recursively-defined integer sequence (now) has first terms", " a simple listing of the classes of perfect square numbers, up to a given number n. There is no return value, and instead the list is printed.\n\nFollowing is an example of code that greets people a number of times:\n\ngreet(count):\n    if count == 0:\n        return\n    else:\n        print(\"Hello!\")\n        greet(count - 1)\nSay something positive to you for five times using the above code. Wrap your call", " a sequence of integers through a naive calculation method.\n\ndef calc(n: int) -> int:\n    return int(((n*n)+n) / 2)\n\nThe above code generates a sequence of integers through a naive calculation method. The formula used is that 2n^2 + n = (n^2 + n) / 2.\n\n\nEDIT: The second way would cause a maximum recursion depth if n is very large in both Fibonacci numbers"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000009", "text": "Expansion of Product_{m >= 1} (1 + x^m); number of partitions of n into distinct parts; number of partitions of n into odd parts.", "sequence": "1,1,1,2,2,3,4,5,6,8,10,12,15,18,22,27,32,38,46,54,64,76,89,104,122,142,165,192,222,256,296,340,390,448,512,585,668,760,864,982,1113,1260,1426,1610,1816,2048,2304,2590,2910,3264,3658,4097,4582,5120,5718,6378", "code": " \nfrom functools import lru_cache\nfrom math import isqrt\n@lru_cache(maxsize=None)\ndef A000009(n): return 1 if n == 0 else A010815(n)+2*sum((-1)**(k+1)*A000009(n-k**2) for k in range(1,isqrt(n)+1)) \n", "obfuscations": ["from functools import lru_cache\nfrom math import isqrt\n\n@lru_cache(maxsize=None)\ndef A000009(n):\n    return 1 if n == 0 else A010815(n) + 2 * sum(((-1) ** (k + 1) * A000009(n - k ** 2) for k in range(1, isqrt(n) + 1)))", "from functools import lru_cache\nfrom math import isqrt\n\n@lru_cache(maxsize=None)\ndef A000009(n):\n    return 1 if n == 0 else A010815(n) + 2 * sum(((-1) ** (k + 1) * A000009(n - k ** 2) for k in range(1, isqrt(n) + 1)))", "from functools import lru_cache\nfrom math import isqrt\n\n@lru_cache(maxsize=None)\ndef A000009(n):\n    return 1 if n == 0 else A010815(n) + 2 * sum(((-1) ** (k + 1) * A000009(n - k ** 2) for k in range(1, isqrt(n) + 1)))", "from functools import lru_cache\nfrom math import isqrt\n\n@lru_cache(maxsize=None)\ndef A000009(n):\n    return 1 if n == 0 else A010815(n) + 2 * sum(((-1) ** (k + 1) * A000009(n - k ** 2) for k in range(1, isqrt(n) + 1)))", "from functools import lru_cache\nfrom math import isqrt\n\n@lru_cache(maxsize=None)\ndef A000009(n):\n    return 1 if n == 0 else A010815(n) + 2 * sum(((-1) ** (k + 1) * A000009(n - k ** 2) for k in range(1, isqrt(n) + 1)))"], "completions": {"none": [" the n-th Tribonacci number through a formula using Landau Notation of the Fibonacci Sequence and Pentagonal numbers. (Fun fact: this is just the 3rd iteration of A010815)\n\ndef trib(n: int) -> int:\n    return A016518(n)\nTn = trib = Util.Tribonacci = A016518 = A29509 = A29509\n-----------------------------------------------------------------------------------------------------------------------------\n\nCompute", " the n-th value of A000009, the integer part of the n-th Dedekind eta function. The sequence A000009 and its lambda function (lambda n: 1 if n == 0 else A000009(n-1) + A010815(n-1) + 1) are featured in the tapestry carpet design seen above.\n\nEach function below has a docstring containing the function signature, a function summary, and a link to n", " the n-th Fibonacci number through a geometric series, described below:\n\nIf n is 0 the sequence contains no term greater than 1, so return 1; otherwise, return 2 plus the sum of the terms in the sequence less than n. First compute the integer square root of n. Then construct a sequence of of integers k < n satisfying k^2 + 1 <= n and terminating at the closest integer greater than or equal to the integer square root of n. If n is", " the n-th Fibonacci number through a  recursive method, described below:\n\nSet a cache limit to prevent a stack overflow and enable memoization.\n\nAdd A010815(n) to the final solution. This value is A010815(n).\n\nCompute A000009(n) and add this value twice to the final solution. This value is found by internally calling A000009(k ** 2) for all k in the closed interval", " the n-th generic Fibonacci number, called A010815 in OEIS.\n\n\n'''\nimport cProfile\n\nfrom functools import lru_cache\nfrom math import isqrt\n\ndef get_fibonacci_huge_naive(n, m):\n    if n <= 1:\n        return n\n\n    previous = 0\n    current  = 1\n\n    for _ in range(n - 1):\n       "], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000010", "text": "Euler totient function phi(n): count numbers <= n and prime to n.", "sequence": "1,1,2,2,4,2,6,4,6,4,10,4,12,6,8,8,16,6,18,8,12,10,22,8,20,12,18,12,28,8,30,16,20,16,24,12,36,18,24,16,40,12,42,20,24,22,46,16,42,20,32,24,52,18,40,24,36,28,58,16,60,30,36,32,48,20,66,32,44", "code": "\nfrom sympy.ntheory import totient\nprint([totient(i) for i in range(1, 70)])  \n", "obfuscations": ["from sympy.ntheory import totient\nprint([totient(i) for i in range(1, 70)])", "from sympy.ntheory import totient\nprint([totient(i) for i in range(1, 70)])", "from sympy.ntheory import totient\nprint([totient(i) for i in range(1, 70)])", "from sympy.ntheory import totient\nprint([totient(i) for i in range(1, 70)])", "from sympy.ntheory import totient\nprint([totient(i) for i in range(1, 70)])"], "completions": {"none": [" all the totients (\u03a6( n)) in the following sequence.\n\ndef gcd(m: int, n: int) -> int:\n    while m % n != 0:\n        old_m = m\n        old_n = n\n\n        m = old_n\n        n = old_m % old_n\n    return n\n\n\ndef reduce_fraction(n: int, m: int) -> Tuple[int, int", " the totients for the numbers 1 to 69. The totient of a number is defined as\n\ntot_n = phi(n) = n\\*[1 - 1/p]\nwhere p = 1, 2, ... p^x is the distinct prime factors of n\n\nWhat can you say about the above results?\n\na) all numbers between 1 and 69 are prime\n\nb) all numbers between 1 and 69 are odd\n\nc)", " a list of the totients for 1 to 69.\n\ndef ord(n: int, a: int) -> int:\n    total = 1\n    for i in range(2, n+1):\n        if coprime(i, n) == a:\n            total += 1\n    return total\n\nThe above code returns the order of a in n, meaning that if you exponentiate a by ord(n, a), you will get the identity", " a list of the first 69 totients of natural numbers from 1 to 69.\n\n'doom (1993)'\nTrivia\nTrivii from Doom (1993)\nThe \"Oblige\" update to the original game as played through a level among the celebrities.\nThis is a parody of the Triumph of Death from the 1927 film The Hunchback of Notre-Dame.\nSkeletal Bighead monsters shoot basketballs at players, who try to catch them for bonuses that", " a list of the totients up to the 70'th prime number.\n\ndays(366) --> [Mon, Tue, ..., Sun] choose 365 out of 366\nWhat is the n'th prime number?\n\"\"\"\nimport prime\ndef days(n: int) -> [str]:\n    days = ['Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat', 'Sun']\n    num = n-1\n    remainder"], "p": [], "f": [], "pf": []}}
