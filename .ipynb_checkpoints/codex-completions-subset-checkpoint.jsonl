{"sequence_id": "A000006", "text": "Integer part of square root of n-th prime.", "sequence": "1,1,2,2,3,3,4,4,4,5,5,6,6,6,6,7,7,7,8,8,8,8,9,9,9,10,10,10,10,10,11,11,11,11,12,12,12,12,12,13,13,13,13,13,14,14,14,14,15,15,15,15,15,15,16,16,16,16,16,16,16,17,17,17,17,17,18,18,18,18,18", "code": "\nfrom sympy import sieve\nA000006 = lambda n: int(sieve[n]**.5)\nprint([A000006(n) for n in range(1,100+1)])\n\n", "obfuscations": ["from sympy import sieve\nA000006 = lambda n: int(sieve[n] ** 0.5)\nprint([A000006(n) for n in range(1, 100 + 1)])", "from sympy import sieve\nA000006 = lambda n: int(sieve[n] ** 0.5)\nprint([A000006(n) for n in range(1, 100 + 1)])", "from sympy import sieve\nA000006 = lambda n: int(sieve[n] ** 0.5)\nprint([A000006(n) for n in range(1, 100 + 1)])", "from sympy import sieve\nA000006 = lambda n: int(sieve[n] ** 0.5)\nprint([A000006(n) for n in range(1, 100 + 1)])", "from sympy import sieve\nA000006 = lambda n: int(sieve[n] ** 0.5)\nprint([A000006(n) for n in range(1, 100 + 1)])"], "completions": {"none": [" the sequence of integer [Totient function](https://en.wikipedia.org/wiki/Totient_function) of all positive integers.\n\ne = [0] * 10000\nfor i in range(2, 10000):\n    if e[i] == 0:\n        j = i * 2\n        while j < 10000:\n            e[j] = i\n            j += i\n\nprint(e[:10])\n\nprint([", " the first 100 square roots of prime numbers.\n\"\"\"\n\n\ndef merge(l1: list, l2: list) -> list:\n    \"\"\"Merges two lists in a single, non-descending order.\n    \n    >>> merge([1], [2])\n    [1, 2]\n    \n    >>> merge([1, 2], [1, 2])\n    [1, 1, 2, 2]\n    \"\"\"\n    merged = []", " the n-th Fibonacci number through the sieve of Eratosthenes, described below:\n\nInitialize a list of integers from 0 to N-1, where N is the input. Then, remove all multiples of 2 and fewer than N/24. Then, remove all multiples of 5 and more than N/24. Once it is complete, return the list at index n-1.\n\n[2, 3, 5]\n[2,", " the first 25 Fibonacci numbers.\n\nRecall the following solution to p070, which counts the total number of positive integers x < n such that x is squarefree, while only counting integers of the form x = m(2m+1).\n\ndef sf(n: int) -> int:\n    '''Counts the number of squarefree numbers in [0,n]'''\n    # x will represent the nth Fibonacci number\n", " the nth perfect number.\n\nA180139 = lambda n: n**2 - n + 41\nprint([A180139(n) for n in range(1, 100 + 1)])\nThe above code generates the nth Klein Bottle.\n\nA030272 = lambda n: sum(filter(lambda r: n % r == 0, range(1, n + 1)))\nprint([A030272(n) for n in range("], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000045", "text": "Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.", "sequence": "0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155", "code": " \ndef fib():\n    \"\"\" Generates the Fibonacci numbers, starting with 0 \"\"\"\n    x, y = 0, 1\n    while 1:\n        yield x\n        x, y = y, x+y\nf = fib()\na = [next(f) for _ in range(100)]\ndef A000045(n):\n    \"\"\" Returns Fibonacci number with index n, offset 0 \"\"\"\n    return a[n]\ndef A000045_list(N):\n    \"\"\" Returns a list of the first n Fibonacci numbers \"\"\"\n    return a[:N]\n", "obfuscations": ["def fib():\n    \"\"\" Generates the Fibonacci numbers, starting with 0 \"\"\"\n    (x, y) = (0, 1)\n    while 1:\n        yield x\n        (x, y) = (y, x + y)\nf = fib()\na = [next(f) for _ in range(100)]\n\ndef A000045(n):\n    \"\"\" Returns Fibonacci number with index n, offset 0 \"\"\"\n    return a[n]\n\ndef A000045_list(N):\n    \"\"\" Returns a list of the first n Fibonacci numbers \"\"\"\n    return a[:N]", "def fib():\n    \"\"\" Generates the Fibonacci numbers, starting with 0 \"\"\"\n    (x, y) = (0, 1)\n    while 1:\n        yield x\n        (x, y) = (y, x + y)\nf = fib()\na = [next(f) for _ in range(100)]\n\ndef A000045(n):\n    \"\"\" Returns Fibonacci number with index n, offset 0 \"\"\"\n    return a[n]\n\ndef A000045_list(N):\n    \"\"\" Returns a list of the first n Fibonacci numbers \"\"\"\n    return a[:N]", "def fib():\n    \"\"\" Generates the Fibonacci numbers, starting with 0 \"\"\"\n    (x, y) = (0, 1)\n    while 1:\n        yield x\n        (x, y) = (y, x + y)\nf = fib()\na = [next(f) for _ in range(100)]\n\ndef A000045(n):\n    \"\"\" Returns Fibonacci number with index n, offset 0 \"\"\"\n    return a[n]\n\ndef A000045_list(N):\n    \"\"\" Returns a list of the first n Fibonacci numbers \"\"\"\n    return a[:N]", "def fib():\n    \"\"\" Generates the Fibonacci numbers, starting with 0 \"\"\"\n    (x, y) = (0, 1)\n    while 1:\n        yield x\n        (x, y) = (y, x + y)\nf = fib()\na = {*()}\nfor _ in range(100):a.append(next(f))\n\ndef A000045(n):\n    \"\"\" Returns Fibonacci number with index n, offset 0 \"\"\"\n    return a[n]\n\ndef A000045_list(N):\n    \"\"\" Returns a list of the first n Fibonacci numbers \"\"\"\n    return a[:N]", "def fib():\n    \"\"\" Generates the Fibonacci numbers, starting with 0 \"\"\"\n    (x, y) = (0, 1)\n    while 1:\n        yield x\n        (x, y) = (y, x + y)\nf = fib()\na = {*()}\nfor _ in range(100):a.append(next(f))\n\ndef A000045(n):\n    \"\"\" Returns Fibonacci number with index n, offset 0 \"\"\"\n    return a[n]\n\ndef A000045_list(N):\n    \"\"\" Returns a list of the first n Fibonacci numbers \"\"\"\n    return a[:N]"], "completions": {"none": [" the first 100 Fibonacci numbers through the use of a generator. To execute the code, type the following in the PySpark interpreter:\n\n>>> from task4 import *\n\n>>> a[98]\n>>> A000045(98)\n147\n147\n\n5.3\nThe above algorithms:\n\ndef fib2(n: int) -> int:\n    if n == 0 or n == 1:\n        return n\n    else:\n       ", " both Fibonacci-number sequences entirely within Python, from scratch, without any implementation details from the outside.\n'''", " the first 100 Fibonacci numbers, and it serves as an example for using a list comprehension to generate a fibonacci sequence.\n\nOur \"test run\" of the above code yields the following result:\n\n$ python3 FibonacciGenerators.py\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181", " the first n Fibonacci numbers in a list and a dictionary, respectively. The dictionary is shown below:\n\n{}\n\n", " the Fibonacci numbers recursively. We implement a class, Fibo, to store the index n and Fibonacci number F(n), recursively generated by the function A000045 in another module.\n\nclass Fibo:\n    def __init__(self, n):\n        self.n = n\n    \n    def __repr__(self):\n        return '[{0.n}]: {0.val}'.format(self"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000045", "text": "Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.", "sequence": "0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155", "code": " \nfrom gmpy2 import fib\nfor n in range(100): print(str(n) + \" \" + str(fib(n)))  \n", "obfuscations": ["from gmpy2 import fib\nfor n in range(100):\n    print(str(n) + ' ' + str(fib(n)))", "from gmpy2 import fib\nsequence_iterator1 = iter(range(100))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        print(str(n) + ' ' + str(fib(n)))\n    except StopIteration:\n        break", "from gmpy2 import fib\nsequence_iterator1 = iter(range(100))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        print(str(n) + ' ' + str(fib(n)))\n    except StopIteration:\n        break", "from gmpy2 import fib\nsequence_iterator1 = iter(range(100))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        print(str(n) + ' ' + str(fib(n)))\n    except StopIteration:\n        break", "from gmpy2 import fib\nsequence_iterator1 = iter(range(100))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        print(str(n) + ' ' + str(fib(n)))\n    except StopIteration:\n        break"], "completions": {"none": [" the first 100 Fibonacci numbers through the gmpy2.fib helper method, which generates Fibonacci numbers up to and including the n-th Fibonacci number.\n\"\"\"\n\ndef fib(n: int) -> int:\n    a, b = 0, 1\n    while n:\n        a, b = b, a+b\n        n -= 1\n    return a\n\nfor n in range(1, 1001):\n   ", " the entire Fibonacci sequence up to its 100th term using each of your functions. The code will break when the loop hits a Fibonacci number that exceeds the maximum value that can be stored with a 64-bit floating point variable, whose range runs from (1 - e) where e = 2.9 to (1 + e) where e = 1.7, and so the maximum number stored using a 64-bit variable is 2^(64) - 1.\n\n", " a sequence of Fibonacci numbers in order (0, 1, 1, 2, 3... n) to use them in comparing the results of running fib1 and fib2. Pretty neat!\n\"\"\"", " the first 100 numbers of the Fibonacci sequence using a generator. Each iteration takes O(1) time. In total, we need 100 steps to retrieve the first 100 Fibonacci numbers, which takes O(1) time.\n\nfrom math import sqrt\nsequence_iterator2 = iter(range(100))\nwhile True:\n    try:\n        n = next(sequence_iterator2)\n        print(str(n) + ' ' + str(", " the first 100 Fibonacci numbers by iterating through a sequence of integers, where the sequence is range(100) in this case. Since calls to next() would raise a StopIteration exception if the sequence is consumed, a try/except block is used to handle the exception and allow the loop to continue.\n\nFibonacci numbers are not so easily computed using threads. However, they can be computed using a background thread and the lock mechanism on a single processor. Because Fib"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000058", "text": "Sylvester's sequence: a(n+1) = a(n)^2 - a(n) + 1, with a(0) = 2.", "sequence": "2,3,7,43,1807,3263443,10650056950807,113423713055421844361000443,12864938683278671740537145998360961546653259485195807", "code": "\nA000058 = [2]\nfor n in range(1, 10):\n    A000058.append(A000058[n-1]*(A000058[n-1]-1)+1)\n\n", "obfuscations": ["A000058 = [2]\nfor n in range(1, 10):\n    A000058.append(A000058[n - 1] * (A000058[n - 1] - 1) + 1)", "A000058 = [2]\nsequence_iterator1 = iter(range(1, 10))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        A000058.append(A000058[n - 1] * (A000058[n - 1] - 1) + 1)\n    except StopIteration:\n        break", "A000058 = [2]\nsequence_iterator1 = iter(range(1, 10))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        A000058.append(A000058[n - 1] * (A000058[n - 1] - 1) + 1)\n    except StopIteration:\n        break", "A000058 = [2]\nsequence_iterator1 = iter(range(1, 10))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        A000058.append(A000058[n - 1] * (A000058[n - 1] - 1) + 1)\n    except StopIteration:\n        break", "A000058 = [2]\nsequence_iterator1 = iter(range(1, 10))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        A000058.append(A000058[n - 1] * (A000058[n - 1] - 1) + 1)\n    except StopIteration:\n        break"], "completions": {"none": [" the sequence of numbers describing the n-th Fibonacci number of Tree Ordinal.\n\ndef fib3(n: int) -> int:\n    return A000058[n - 1]\n\nThe above function uses the previously generated sequence to index the appropriate number.\n\nInput Format\n\nThe first line contains T, the number of test cases.\n\nThe T subsequent lines of test cases each contain a single integer n.\n\nConstraints\n\n1", " the sequence denoted A000058 fast, as shown at https://oeis.org/A000058. The slow method of generating any even Fibonacci number involves generating the first half of the Fibonacci sequence using the iterative method, calling this function to generate the second half, and then multiplying each element of these two halves together to generate the original full Fibonacci sequence. Of course, this will be very inefficient beyond n=40 or so.\n\nFirst, you", " the sequence of the n-th Fibonacci number.\n\nA000225 = [3]\nsequence_iterator2 = iter(range(1, 13))\nwhile True:\n    try:\n        sum_, n = next(sequence_iterator2), next(sequence_iterator2)\n        A000225.append(2 * A000225[n - 1] + 1 + A001157[n - 1] + sum_)\n   ", " the first 10-1 = 9 Fibonacci sequence entries modulo 60, i.e., the entries in the sequence 1, 1, 2, 5, 17, 19, 43, 75, and 121 modulo 60 = 1, in that order. The variable n is iteratively assigned the value of i + 1, where i is the iteration number. Then, it is determined whether this particular i is <= 9, with A000058[n - 1] being the (n", " the sequence A000058, shown below:\nA000058 = [1, 2, 5, 16, 61, 270, ...]\n\ndef sequence2():\n    n = 1\n    while n >= 1 and n <= 10:\n        n = n + 1\n        yield A000058[n - 1]\nsequence_iterator2 = iter(sequence2())\nwhile True:\n    try:\n        print(next(sequence_iterator2))\n"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000059", "text": "Numbers n such that (2n)^4 + 1 is prime.", "sequence": "1,2,3,8,10,12,14,17,23,24,27,28,37,40,41,44,45,53,59,66,70,71,77,80,82,87,90,97,99,102,105,110,114,119,121,124,127,133,136,138,139,144,148,156,160,164,167,170,176,182,187,207,215,218,221,233,236,238,244,246", "code": "\nfrom sympy import isprime\nprint([n for n in range(10**3) if isprime(16*n**4+1)])\n\n", "obfuscations": ["from sympy import isprime\nprint([n for n in range(10 ** 3) if isprime(16 * n ** 4 + 1)])", "from sympy import isprime\nprint([n for n in range(10 ** 3) if isprime(16 * n ** 4 + 1)])", "from sympy import isprime\nprint([n for n in range(10 ** 3) if isprime(16 * n ** 4 + 1)])", "from sympy import isprime\nprint([n for n in range(10 ** 3) if isprime(16 * n ** 4 + 1)])", "from sympy import isprime\nprint([n for n in range(10 ** 3) if isprime(16 * n ** 4 + 1)])"], "completions": {"none": [" all integers below 1000 that can be expressed as 16n^4 + 1 where n > 0 and is prime.\n\nimport sys\nsys.stdout = open('foo.txt', 'w')\nprint('good day!')\nThe above code writes \"good day!\" to the local directory under the file name foo.txt.\n\ndef x(num: int) -> str:\n    if num % 2 == 0:\n        return 'fuz'\n   ", " the locations of prime numbers below 10000.\n\nd = {}  # dictionaries are replaced by d\n\nfor i in range(10):\n    for j in range(3):\n        d[(i, j)] = i * j\n\nThe above code populates a dictionary to capture data using the (i,j) keys, where i is an accepted state and j is a transition.\n\nOR\n\n{((i, j) : i * j", " a list of the first 1000 prime numbers multiplied by the 4th power of n plus 1.", " a list of all integers under 1,000 that satisfy the condition for Fermat pseudoprimes, i.e. for integer n = 16 * n ** 4 + 1 must be prime (or n = 16 * n ** 4 - 1 where the converse statement for Fermat pseudoprimes still holds). It is a list comprehension, written as follows.\n\n[expressions for variables in objects if conditional expressions]\nIn this particular example, it consists of a list of", " all Fibonacci numbers such that the number is prime\n\ndef gcd(a: int, b: int) -> int:\n\nThe above code defines a function that finds the greatest common denominator between two numbers a and b.\n\nimport fractions\ndef gcd1(a: int, b: int) -> int:\n    return fractions.gcd(a,b)\n\nThe above function uses the fractions library's greatest common denominator function to calculate"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000073", "text": "Tribonacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) for n >= 3 with a(0) = a(1) = 0 and a(2) = 1.", "sequence": "0,0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,66012,121415,223317,410744,755476,1389537,2555757,4700770,8646064,15902591,29249425,53798080,98950096,181997601,334745777,615693474,1132436852", "code": "\ndef a(n, adict={0:0, 1:0, 2:1}):\n    if n in adict:\n        return adict[n]\n    adict[n]=a(n-1)+a(n-2)+a(n-3)\n    return adict[n] \n", "obfuscations": ["def a(n, adict={0: 0, 1: 0, 2: 1}):\n    if n in adict:\n        return adict[n]\n    adict[n] = a(n - 1) + a(n - 2) + a(n - 3)\n    return adict[n]", "def a(n, adict={0: 0, 1: 0, 2: 1}):\n    if n in adict:\n        return adict[n]\n    adict[n] = a(n - 1) + a(n - 2) + a(n - 3)\n    return adict[n]", "def a(n, adict={0: 0, 1: 0, 2: 1}):\n    if n in adict:\n        return adict[n]\n    adict[n] = a(n - 1) + a(n - 2) + a(n - 3)\n    return adict[n]", "def a(n, adict={0: 0, 1: 0, 2: 1}):\n    if n in adict:\n        return adict[n]\n    adict[n] = a(n - 1) + a(n - 2) + a(n - 3)\n    return adict[n]", "def a(n, adict={0: 0, 1: 0, 2: 1}):\n    if n in adict:\n        return adict[n]\n    adict[n] = a(n - 1) + a(n - 2) + a(n - 3)\n    return adict[n]"], "completions": {"none": [" the n-th Fibonacci number through memoization. In particular, using dictionaries and memoization, it generates a helper dictionary, adict, and returns adict[n].\n\"\"\"\n\nmemo = {0:0, 1:1}\n\ndef fib3(n):\n    if n not in memo:\n        memo[n] = fib3(n-1) + fib3(n-2)\n    return memo[n]\n\n", " the n-th Fibonacci number based on their number of occurances. For example, the second Fibonacci number is \"0, 1\" so counts as two numbers. On the other hand, the third Fibonacci number is \"0, 1, 1\" so counts as three numbers.\n\nRanking\n\nFibonacci numbers\n5\n\n\n\"\"\"", " the n-th Fibonacci number through a dictionary method,\ndescribed below:\n\nBy defining the base case explicitly by index and add these to a dictinoary to store previous values, instead of using the Identity Matrix n + n, n + n - 1, n + n - 2, we can store values in a dictionary tracking the current n and n - 1 and n - 2, instead of recalculating smaller numbers over and over.\n\nfunc BinarySearch(n", " Fibonacci numbers in the n-th Index in the fastest way possible without checking.\n\"\"\"\n\n\ndef fib(n: int) -> int:\n    if n == 0 or n == 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n\ndef a(n, adict={0: 0, 1: 0, 2: 1}):\n    if n in adict:\n        return adict[", " the n-th Fibonacci number through an iterative method in O(1), described below:\n\nSet an adict dictionary with key-values 0: 0, 1: 0, 2: 1. Fill with values for fib(0) and fib(1) and fib(2). Then, with an i initialized at n - 1, check to see if n is in adict. If not, take the first n - 1 elements in adict and add the last"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000078", "text": "Tetranacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) + a(n-4) for n >= 4 with a(0) = a(1) = a(2) = 0 and a(3) = 1.", "sequence": "0,0,0,1,1,2,4,8,15,29,56,108,208,401,773,1490,2872,5536,10671,20569,39648,76424,147312,283953,547337,1055026,2033628,3919944,7555935,14564533,28074040,54114452,104308960,201061985,387559437,747044834,1439975216,2775641472", "code": "\nA000078 = [0,0,0,1]\nfor n in range(4, 100):\n    A000078.append(A000078[n-1]+A000078[n-2]+A000078[n-3]+A000078[n-4])\n\n", "obfuscations": ["A000078 = [0, 0, 0, 1]\nfor n in range(4, 100):\n    A000078.append(A000078[n - 1] + A000078[n - 2] + A000078[n - 3] + A000078[n - 4])", "A000078 = [0, 0, 0, 1]\nsequence_iterator1 = iter(range(4, 100))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        A000078.append(A000078[n - 1] + A000078[n - 2] + A000078[n - 3] + A000078[n - 4])\n    except StopIteration:\n        break", "A000078 = [0, 0, 0, 1]\nsequence_iterator1 = iter(range(4, 100))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        A000078.append(A000078[n - 1] + A000078[n - 2] + A000078[n - 3] + A000078[n - 4])\n    except StopIteration:\n        break", "A000078 = [0, 0, 0, 1]\nsequence_iterator1 = iter(range(4, 100))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        A000078.append(A000078[n - 1] + A000078[n - 2] + A000078[n - 3] + A000078[n - 4])\n    except StopIteration:\n        break", "A000078 = [0, 0, 0, 1]\nsequence_iterator1 = iter(range(4, 100))\nwhile True:\n    try:\n        n = next(sequence_iterator1)\n        A000078.append(A000078[n - 1] + A000078[n - 2] + A000078[n - 3] + A000078[n - 4])\n    except StopIteration:\n        break"], "completions": {"none": [" 0, 0, 0, 1, 1, 2, 4, 13, etc.\n\"\"\"\n\n\n\"\"\"\nDynamic Programming\n\nMemoization\nMemoization is the tried-and-true technique of storing solutions to previously solved subproblems in order to avoid solving the same subproblem repeatedly. Here is an example:\n\"\"\"\n\n\n@lru_cache(maxsize=None)\ndef fib3(n: int) -> int:\n    if n <", " the first 100 terms of the Fibonacci sequence through a dynamic programming method, described below:\n\nSet initial values for the first 4 Fibonacci numbers. Start an iterator for range(4, 100). Try to generate the next Fibonacci number. If a StopIteration exception is generated, break the loop.\n\"\"\"\n\nclass Solution:\n    def Fibonacci(self, n):\n        A = [0,0,0,1]\n        for", " all Fibonacci numbers less than 100 via a built-in Python library.\n'''\nANALYSIS:\nIf I understand the problem, it is to use both iterative and recursive methods to generate Fibonacci numbers less than n.\n\nfib1, iterative:\nRuntime: O(n)\nSpace: O(1)\n\nfib2, recursive:\nRuntime: O(2^n): Simplifying, the algorithm runs fib2", " the first 100 Fibonacci numbers through the mathematical formula A000078.\n\nn !\nThe n factorial; n factorial = n * (n - 1) * (n - 2) * (n - 3) * ... * 2 * 1.\n\nn is an index (number).\nThe factorial of 0 is 1, the factorial of a positive integer n is n.\n\nmemoryview\nappears in Python 3. See Memory views.\n", " a list A000078 of the first 100 Fibonacci number.\n\ncomplex(real=0.0, imag=0.0) -> complex(real)\n\n    Returns a complex number equal to real + imag*1j. The real and imaginary parts must be strings or floating point numbers and the number must be a valid complex number.\n\ndef foo(s_name: str, i_age: int = 42) -> bool:\n    return True\n\n"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000079", "text": "Powers of 2: a(n) = 2^n.", "sequence": "1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592", "code": "\ndef a(n): return 2**n\nprint([a(n) for n in range(34)]) \n", "obfuscations": ["def a(n):\n    return 2 ** n\nprint([a(n) for n in range(34)])", "def a(n):\n    return 2 ** n\nprint([a(n) for n in range(34)])", "def a(n):\n    return 2 ** n\nprint([a(n) for n in range(34)])", "def a(n):\n    return 2 ** n\nprint([a(n) for n in range(34)])", "def a(n):\n    return 2 ** n\nprint([a(n) for n in range(34)])"], "completions": {"none": [" a list of floating point approximation solutions for 2 exponentiated at the powers of n.\n\nn print(sum([int(i) for i in list(str(2**1000))]))\nThe above code sums the integers of a large number 2**1000 where 2**1000 is of the form 2^(10^3) and is defined here as 1000 groups of digits. I define each group of digits to be the set of numbers {0, 1, 2,3", " a list of the first 34 powers of 2.\n\ndef generator(n):\n    for i in range(n):\n        yield 2 ** i\nprint(list(generator(34)))\nThe above code generates a list of the first 34 powers of 2, but uses a generator expression instead of a list comprehension.\n\ndef find_max(n):\n    return big_max\n# equivalent if written in Python 3:\n# def find_max(n", " a sequence of powers of two. Such a sequence of numbers is known as a geometric progression since each number of the sequence, in this case an \"an\", is a factor of the product of the two preceeding numbers. Write code to determine whether or not the following sequence is a geometric numpre of numbers.\n\n[1, 4, 16, 64, 256, 1024, 4096, 16384, 65536, 262144, 1048576, 4194304, 16", " the power set of a set in linear fashion. In other words, it generates an EnumeratedSets data structure of all possible subsets of a set and returns the subset which contains both elements 2 and 32. \n\ndef a(n):\n    k = 1\n    while (2 ** k < n):\n        k += 1\n        return n == 2 ** k\nprint([a(n)])\nThe above code generates the power set of a set in", " and prints a list of 34 powers of 2.\n\ndef b(n):\n    assert type(n) == int and n >= -1000 and n <= 1000\n    if n < 0:\n        return -1 * (abs(a(n) - 1)) + 2\n    else:\n        return (a(n) - 1) / 2\nprint([b(n) for n in range(-1000, 1001)])\nThe above code generates"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000118", "text": "Number of ways of writing n as a sum of 4 squares; also theta series of lattice Z^4.", "sequence": "1,8,24,32,24,48,96,64,24,104,144,96,96,112,192,192,24,144,312,160,144,256,288,192,96,248,336,320,192,240,576,256,24,384,432,384,312,304,480,448,144,336,768,352,288,624,576,384,96,456,744,576,336,432,960,576,192", "code": "\nfrom sympy import divisors\ndef a(n): return 1 if n==0 else 8*sum(d for d in divisors(n) if d%4 != 0)\nprint([a(n) for n in range(57)]) \n", "obfuscations": ["from sympy import divisors\n\ndef a(n):\n    return 1 if n == 0 else 8 * sum((d for d in divisors(n) if d % 4 != 0))\nprint([a(n) for n in range(57)])", "from sympy import divisors\n\ndef a(n):\n    return 1 if n == 0 else 8 * sum((d for d in divisors(n) if d % 4 != 0))\nprint([a(n) for n in range(57)])", "from sympy import divisors\n\ndef a(n):\n    return 1 if n == 0 else 8 * sum((d for d in divisors(n) if d % 4 != 0))\nprint([a(n) for n in range(57)])", "from sympy import divisors\n\ndef a(n):\n    return 1 if n == 0 else 8 * sum((d for d in divisors(n) if d % 4 != 0))\nprint([a(n) for n in range(57)])", "from sympy import divisors\n\ndef a(n):\n    return 1 if n == 0 else 8 * sum((d for d in divisors(n) if d % 4 != 0))\nprint([a(n) for n in range(57)])"], "completions": {"none": [" a random walk of length n  3. The cell below prompts the user for the necessary values, and calculates the first 20 terms in the walk.\n\nfrom math import floor\nfrom random import randint\n\ndef simulate_die_throw(n):\n    walk = [3]\n\n    for i in range(n):\n        walk.append((2 * walk[i] + randint(0, 1)) % 7)\n        walk.sort()\n\n   ", " the number of integers up to some value n that have a digit sum equal to it.\n\nimport math\nfrom functools import lru_cache\n\n@lru_cache\ndef b(n):\n    if n == 1:\n        return 2\n    elif n == 2:\n        return 5\n    elif n % 2 == 1 and all(n % x != 0 for x in range(3, int(math.sqrt(n", " the numbers a(n), which has a closed form defined by a(n) = 1 if n == 0 else 8 * sum((d for d in divisors(n) if d % 4 != 0). Such formulas, that output integers corresponding to digits in a number-theoretic sequence, are very common in interviews for coding positions at tech companies: for more information but to simply note that this form of formula is common, see http://mathworld.wolfram.com", " the action a for each integer n.\n\"\"\"\ndef memo(s: str) -> tuple:\n    \"\"\"Converts a string of the format '1a2b3c' to a string of the format 'abcabcabcabc'\"\n\n    Args:\n        s: a string of digits each >= 0 and <= 9 followed by one and only one letter, where the letters are in alphabetical order.\n\n    Returns:\n        a string of the format 'abc", " the 24-open numbers with the TCLayout family of rules. First, a function to calculate the even factor sum of an integer is declared. Then a generator for all 24-open numbers with the specified rule family is declared.\ndef sum_even_factor(n):\n    return sum(x for x in factors(n) if x % 2 == 0)\n\ndef open24(n):\n    if n == 0:\n        yield 0\n    else"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000142", "text": "Factorial numbers: n! = 1*2*3*4*...*n (order of symmetric group S_n, number of permutations of n letters).", "sequence": "1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,121645100408832000,2432902008176640000,51090942171709440000,1124000727777607680000", "code": "\nfor i in range(1, 1000):\n    y = i\n    for j in range(1, i):\n       y *= i - j\n    print(y, \"\\n\")\n", "obfuscations": ["for i in range(1, 1000):\n    y = i\n    for j in range(1, i):\n        y *= i - j\n    print(y, '\\n')", "sequence_iterator2 = iter(range(1, 1000))\nwhile True:\n    try:\n        i = next(sequence_iterator2)\n        y = i\n        sequence_iterator1 = iter(range(1, i))\n        while True:\n            try:\n                j = next(sequence_iterator1)\n                y *= i - j\n            except StopIteration:\n                break\n        print(y, '\\n')\n    except StopIteration:\n        break", "sequence_iterator2 = iter(range(1, 1000))\nwhile True:\n    try:\n        i = next(sequence_iterator2)\n        y = i\n        sequence_iterator1 = iter(range(1, i))\n        while True:\n            try:\n                j = next(sequence_iterator1)\n                y *= i - j\n            except StopIteration:\n                break\n        print(y, '\\n')\n    except StopIteration:\n        break", "sequence_iterator2 = iter(range(1, 1000))\nwhile True:\n    try:\n        i = next(sequence_iterator2)\n        y = i\n        sequence_iterator1 = iter(range(1, i))\n        while True:\n            try:\n                j = next(sequence_iterator1)\n                y *= i - j\n            except StopIteration:\n                break\n        print(y, '\\n')\n    except StopIteration:\n        break", "sequence_iterator2 = iter(range(1, 1000))\nwhile True:\n    try:\n        i = next(sequence_iterator2)\n        y = i\n        sequence_iterator1 = iter(range(1, i))\n        while True:\n            try:\n                j = next(sequence_iterator1)\n                y *= i - j\n            except StopIteration:\n                break\n        print(y, '\\n')\n    except StopIteration:\n        break"], "completions": {"none": [" all of the possible permutations of a sequence ranging from [1,2,3,..., i]. It does so through two for loops. The outer for loop controls which sequence we are operating on and the inner for loop handles the index of the elements in that given sequence. The key fact here is the number of iterations, which ramps up very quickly and approaches the total number of permutations available very quickly. As a result, certain values of i generate permutations so large that they take an", " all the integer divisors of a number.\n\ndivisors(n: int) -> list[int]:\n\nfor d in range(1, n+1):\n    yield d if n % d == 0 else\n*/\n\nfunction fib(n: int) -> int:\n    a: int = 0\n    b: int = 1\n    for i in range(n):\n        a: int = b\n        b: int = a", " a sequence of Fibonacci guesses, described below:\n\nCreate sequence_iterator2 as an iterator that iterates over a range of numbers to generate a sequence of Romberg tie-breaking numbers.\n\nCreate i, a temporary variable to hold the value of sequence_iterator2.\n\nWhile i is greater than 1, generate a sequence_iterator1 as an iterator to iterate over a range of numbers to calculate the term (i-1)'st of the Fibonacci", " the number of possible ways to arrange n items into a set of m ordered boxes.\n\nFor example, we can use the above code to calculate the number of ways to order 3 distinct objects into 2 distinct sets of ordered boxes as follows:\n\n    sequence_iterator2 = iter(range(1, 4))\n    while True:\n         try:\n            i = next(sequence_iterator2)\n            y = i\n            sequence_iterator1 = iter(range(", " a m-bit approximation of the n-th Fibonacci number by dividing the even Fibonacci numbers by the odd Fibonacci numbers; i.e.:\n\nsequence1 = 6 # F(10)\nsequence2 = 8 # F(11)\nbob = test(sequence1, sequence2) # Prints 255\ntest(10, 11)\nThe above code functions by testing whether the n'th number can be represented as a sum of m distinct"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000142", "text": "Factorial numbers: n! = 1*2*3*4*...*n (order of symmetric group S_n, number of permutations of n letters).", "sequence": "1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,121645100408832000,2432902008176640000,51090942171709440000,1124000727777607680000", "code": "\nimport math\nfor i in range(1, 1000):\n    math.factorial(i)\n    print(\"\")\n\n", "obfuscations": ["import math\nfor i in range(1, 1000):\n    math.factorial(i)\n    print('')", "import math\nsequence_iterator1 = iter(range(1, 1000))\nwhile True:\n    try:\n        i = next(sequence_iterator1)\n        math.factorial(i)\n        print('')\n    except StopIteration:\n        break", "import math\nsequence_iterator1 = iter(range(1, 1000))\nwhile True:\n    try:\n        i = next(sequence_iterator1)\n        math.factorial(i)\n        print('')\n    except StopIteration:\n        break", "import math\nsequence_iterator1 = iter(range(1, 1000))\nwhile True:\n    try:\n        i = next(sequence_iterator1)\n        math.factorial(i)\n        print('')\n    except StopIteration:\n        break", "import math\nsequence_iterator1 = iter(range(1, 1000))\nwhile True:\n    try:\n        i = next(sequence_iterator1)\n        math.factorial(i)\n        print('')\n    except StopIteration:\n        break"], "completions": {"none": [" the factorials of every integer from 1 to 1000, with the exception of 0, which returns a value error since the factorial of 0 is infinite.\n\ndef fact(n: int) -> int:\n    p = 1\n    for i in range(1, n+1):\n        p = p*i\n    return p\n\n\n'fact' iterates from 1 to n, multiplying the previous answer by the element of the sequence. At each iteration,", " an Iterator for all numbers up to some predetermined limit (presumably a large one) using the iter function. Then, a while loop begins, in which i is the (next) number of the Iterator, and i! is the factorial of i. We then print next(sequence_iterator1), because this is the same as i. We do this until a StopIteration error occurs, which happens when there are no more numbers in the Iterable.\n\nThe code", " a sequence of Fibonacci numbers. Control enters the try block after a call to iter, but the while loop continues to iterate the sequence iterator until a call to next raises a StopIteration exception.\n\nsequence_iterator2 = iter(range(1, 1000))\nwhile True:\n    try:\n        i = next(sequence_iterator2)\n        print(fib1(i) or fib2(i), end=' ')\n    except Stop", " the factorial of every positive integer less than 1000, then stops.\n\nimport itertools\nsequence_iterator1 = iter(range(1, 1000))\nsequence_iterator2 = itertools.takewhile(lambda x: x <= 9, sequence_iterator1)\nsummed_iterator = itertools.accumulate(sequence_iterator2)\nfor element in summed_iterator:\n    print('')\n    # print(element)\n", " all the n! of all n's less than 1000 using an iterative computing method.\n\ndef sequence_generator(k: int) -> iter('int'):\n    while True:\n        yield k\n        k +=1\ni = 0\nsequence_iterator2 = sequence_generator(i)\nwhile True:\n    try:\n        i = next(sequence_iterator2)\n        recursive_cal(0,i)\n        print("], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000203", "text": "a(n) = sigma(n), the sum of the divisors of n. Also called sigma_1(n).", "sequence": "1,3,4,7,6,12,8,15,13,18,12,28,14,24,24,31,18,39,20,42,32,36,24,60,31,42,40,56,30,72,32,63,48,54,48,91,38,60,56,90,42,96,44,84,78,72,48,124,57,93,72,98,54,120,72,120,80,90,60,168,62,96,104,127,84,144,68,126,96,144", "code": "\nfrom sympy import divisor_sigma\ndef a(n): return divisor_sigma(n, 1)\nprint([a(n) for n in range(1, 71)]) \n", "obfuscations": ["from sympy import divisor_sigma\n\ndef a(n):\n    return divisor_sigma(n, 1)\nprint([a(n) for n in range(1, 71)])", "from sympy import divisor_sigma\n\ndef a(n):\n    return divisor_sigma(n, 1)\nprint([a(n) for n in range(1, 71)])", "from sympy import divisor_sigma\n\ndef a(n):\n    return divisor_sigma(n, 1)\nprint([a(n) for n in range(1, 71)])", "from sympy import divisor_sigma\n\ndef a(n):\n    return divisor_sigma(n, 1)\nprint([a(n) for n in range(1, 71)])", "from sympy import divisor_sigma\n\ndef a(n):\n    return divisor_sigma(n, 1)\nprint([a(n) for n in range(1, 71)])"], "completions": {"none": [" a sequence of summations of divisors, with n providing the index of the entry in the sequence. From the pattern in the sequence, we can easily deduce the first few values of the sequence. The N-th number in this sequence is denoted by a(n):\nsum_{i=1}^{n}p_i, where p_1 = 1 and p_n = n for n >= 1 and p_n = 1 for n = 0. For", " the sequence of outputs for references that were provided by the hint\n\"\"\"\n\n# Your solution from above\ndef euler(n):\n    \"\"\"\n    Enumerating Oriented Gene Orders\n\n    A signed permutation of length n is some ordering of the positive integers {1,2,\u2026,n}\n    in which each integer is then provided with either a positive or negative sign\n    (for the sake of simplicity, we omit the positive sign). For example,", " a list of all the divisors of n from n=1 to n=70.\n\ndef sumRegex(n: int) -> str:\n\"\"\"", " a list of however many primes there are between 1 and 70. However, I noticed that for the n's in question, the values are not proper. Apparantly, there are 66 primes between 1 and 70. If a n value is even, there are actually 2 less primes than the original list of values.\n\nimport numpy as np\n\na = [0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1", " a list of the partial values of the Mobius function applied to natural numbers between 1 and 70.\n\nimport numpy as np\n\ndef b(x, i):\n    if np.random.rand() <= x:\n        return i\n    return None\n\ndef c(x):\n    answer = []\n    for i in range(1, 1001):\n        result = b(x, i)\n        if result is not None:\n           "], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000213", "text": "Tribonacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) with a(0)=a(1)=a(2)=1.", "sequence": "1,1,1,3,5,9,17,31,57,105,193,355,653,1201,2209,4063,7473,13745,25281,46499,85525,157305,289329,532159,978793,1800281,3311233,6090307,11201821,20603361,37895489,69700671,128199521,235795681,433695873,797691075,1467182629", "code": "\nalst = [1, 1, 1]\n[alst.append(alst[n-1] + alst[n-2] + alst[n-3]) for n in range(3, 37)]\nprint(alst) \n", "obfuscations": ["alst = [1, 1, 1]\n[alst.append(alst[n - 1] + alst[n - 2] + alst[n - 3]) for n in range(3, 37)]\nprint(alst)", "alst = [1, 1, 1]\n[alst.append(alst[n - 1] + alst[n - 2] + alst[n - 3]) for n in range(3, 37)]\nprint(alst)", "alst = [1, 1, 1]\n[alst.append(alst[n - 1] + alst[n - 2] + alst[n - 3]) for n in range(3, 37)]\nprint(alst)", "alst = [1, 1, 1]\n[alst.append(alst[n - 1] + alst[n - 2] + alst[n - 3]) for n in range(3, 37)]\nprint(alst)", "alst = [1, 1, 1]\nlist((alst.append(alst[n - 1] + alst[n - 2] + alst[n - 3]) for n in range(3, 37)))\nprint(alst)"], "completions": {"none": [" all populated Fibonacci numbers.\n\n#1\ndef fib(n):\n    a = 0\n    b = 1\n    if n == 0:\n        return a\n    elif n < 3:\n        return b\n    else:\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return (a + b)\n\n#2\ndef fib(", " a list containing the 37 first Fibonacci numbers\n\n\n\"\"\"\n\ndef fib(n: int) -> int:\n    \"\"\"Calculates the n-th Fibonacci number iteratively\n\n    Args:\n        n (int): n-th Fibonacci number to be calculated\n\n    Returns:\n        int: the n-th Fibonacci number\n    \"\"\"\n    a, b = 0, 1\n    for _ in range(n):\n", " a list of the first 36 Fibonacci numbers. alst[0] is equal to 0, and as such, is the first item of the list, while alst[1] = alst[2] = 1 and so the rest of the list is filled in iteratively.\n\"\"\"\n\nimport math\n\ndef fib1(n: int) -> int:\n    a, b = 0, 1\n    for i in range(n):\n        a", " the 37-th output through a list comprehension.\n\nOutput:\n[1, 1, 1, 3, 5, 9, 17, 31, 57, 105, 193, 355, 653, 1201, 2189, 3905, 7103, 13065, 26201, 48977, \n97993, 194833, 390787, 755755, 1540153, 3030303, 5681265, 11070287, 22150", " a list composed of the first 37 Fibonacci numbers.\n\nThe above pattern of using lists to store numbers can also be used to store characters. A list with one character, [\u2018a\u2019], can be combined with a second string to produce the word \u2018aggie\u2019. As the list grows with more characters, an ordered longer word could be formed.\n\nAdditionally, other data types can be used to store characters and strings. As indicated earlier, a list"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000265", "text": "Remove all factors of 2 from n; or largest odd divisor of n; or odd part of n.", "sequence": "1,1,3,1,5,3,7,1,9,5,11,3,13,7,15,1,17,9,19,5,21,11,23,3,25,13,27,7,29,15,31,1,33,17,35,9,37,19,39,5,41,21,43,11,45,23,47,3,49,25,51,13,53,27,55,7,57,29,59,15,61,31,63,1,65,33,67,17,69,35,71,9,73,37,75,19,77", "code": " \nfrom sympy import divisors\ndef a(n):\n    return max(i for i in divisors(n) if i % 2)\n[a(n) for n in range(1, 101)]\n", "obfuscations": ["from sympy import divisors\n\ndef a(n):\n    return max((i for i in divisors(n) if i % 2))\n[a(n) for n in range(1, 101)]", "from sympy import divisors\n\ndef a(n):\n    return max((i for i in divisors(n) if i % 2))\n[a(n) for n in range(1, 101)]", "from sympy import divisors\n\ndef a(n):\n    return max((i for i in divisors(n) if i % 2))\n[a(n) for n in range(1, 101)]", "from sympy import divisors\n\ndef a(n):\n    return max((i for i in divisors(n) if i % 2))\n[a(n) for n in range(1, 101)]", "from sympy import divisors\n\ndef a(n):\n    return max((i for i in divisors(n) if i % 2))\nlist((a(n) for n in range(1, 101)))"], "completions": {"none": [" all the interesting a(n)'s as calculated by the above formula, 1 through hundred.\n\n#1\ndef b(n, a_s = [a(i) for i in range(1, 101)], l=1):\n    if n+1 in a_s:\n        return b(n+1, a_s, l+1)\n    else:\n        return l, n+1\n\nGiven some list a_s", " a list of the max of the divisors of n if they are both even.\n\n\"\"\"\ndef a1(n: int) -> int:\n    return max(i for i in divisor(n) if i % 2 == 0)\n\ndef a2(n: int) -> int:\n    max = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n", " all of the abundant numbers below 100.\n\ndef non_abundant_sums(n):\n    sa = [False] * (n+1)\n    for i in range(2, n//2+1):\n        for j in range(i*2, n, i):\n            sa[j] = True\n    return sa\n\nThis code generates a list of booleans representing which numbers below n are the sum of two different abundant", " a list of the largest even divisor of each integer between 1 and 100.\nThis problem is done using the sympy package, a Python library for symbolic mathematics.\n\nSee this link for documentation:\n    https://docs.sympy.org/latest/index.html\n\n\"\"\"\n\nfrom typing import List, Any\nfrom math import ceil, sqrt\n\n# Design a procedure that generates, recursively, all powers of 2: 2^", " the amount of even divisors for the first 100 positive integers.\n\ndef a(n):\n    return max((i for i in xrange(1, n+1) if n % i == 0 and i % 2 == 0))\n\nThe above code generates the amount of even divisors for all positive integers up to and including the n term provided.\n\ndef is_prime(n):\n     if n == 2: return True\n     i ="], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000265", "text": "Remove all factors of 2 from n; or largest odd divisor of n; or odd part of n.", "sequence": "1,1,3,1,5,3,7,1,9,5,11,3,13,7,15,1,17,9,19,5,21,11,23,3,25,13,27,7,29,15,31,1,33,17,35,9,37,19,39,5,41,21,43,11,45,23,47,3,49,25,51,13,53,27,55,7,57,29,59,15,61,31,63,1,65,33,67,17,69,35,71,9,73,37,75,19,77", "code": "\nfrom __future__ import division\ndef A000265(n):\n    while not n % 2:\n        n //= 2\n    return n \n", "obfuscations": ["from __future__ import division\n\ndef A000265(n):\n    while not n % 2:\n        n //= 2\n    return n", "from __future__ import division\n\ndef A000265(n):\n    while not n % 2:\n        n //= 2\n    return n", "from __future__ import division\n\ndef A000265(n):\n    while not n % 2:\n        n //= 2\n    return n", "from __future__ import division\n\ndef A000265(n):\n    while not n % 2:\n        n //= 2\n    return n", "from __future__ import division\n\ndef A000265(n):\n    while not n % 2:\n        n //= 2\n    return n"], "completions": {"none": [" the running total of the prime factorisations of consecutive numbers starting at 2. For example, A000265(2) is 2, as 2 = 2 (2-factors), A000265(3) is 3, as 3 = 3 (3-factors), A000265(4) is 4, as 4 = 2^2 (2-factors), A000265(5) is 5, as 5 = 5 (5-factors), A000265(", " the odd numbers\n\nRecommended Approach: The recommended approach is to first develop the correct recursive algorithm, then verify its correctness by analyzing the expected time complexity. The algorithm below is correct. After verifying that the algorithm resolves all edge cases correctly, it will be ready for implementation, and subsequent verification through testing.\n\nAlgorithm: The below algorithm computes the n-th Fibonacci number in Constant time (O(1)), as all operations are constant time and do not depend on n.", " the odd numbers.\n\ndef A000040(n):\n    while n > 1 and n % 2:\n        n //= 2\n    return n\nThe above code generates the powers of two.\n", " the sequence A000265(n) with A_0 = 1 as defined in OEIS:\n\nOne of the first Fibonnaci numbers.\n\n  * a[0] = 1  a[0] provides the seed value for the sequence\n  * a[n] = (a[n-1] + a[n-2]) / 2  for n-th number in the sequence\n\"\"\"\n\n\ndef F(n):\n\n    if n", " the odd numbers.\n\nGive your answer using common separated-justification: one line of code for each answer.\nFor even more fun, try to write the base-case of the recursion yourself, instead \nof using fib(). Here are some ideas:\nVerify that a and b are actually integers.\nThe maximum index of Fibonacci numbers is ~50, i.e. - fib(53) will almost certainly \nstart to overflow so check beforehand."], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000378", "text": "Sums of three squares: numbers of the form x^2 + y^2 + z^2.", "sequence": "0,1,2,3,4,5,6,8,9,10,11,12,13,14,16,17,18,19,20,21,22,24,25,26,27,29,30,32,33,34,35,36,37,38,40,41,42,43,44,45,46,48,49,50,51,52,53,54,56,57,58,59,61,62,64,65,66,67,68,69,70,72,73,74,75,76,77,78,80,81,82,83", "code": "\ndef valuation(n, b):\n    v = 0\n    while n > 1 and n%b == 0: n //= b; v += 1\n    return v\ndef ok(n): return n//4**valuation(n, 4)%8 != 7\nprint(list(filter(ok, range(84)))) \n", "obfuscations": ["def valuation(n, b):\n    v = 0\n    while n > 1 and n % b == 0:\n        n //= b\n        v += 1\n    return v\n\ndef ok(n):\n    return n // 4 ** valuation(n, 4) % 8 != 7\nprint(list([list_element for list_element in range(84) if ok(list_element)]))", "def valuation(n, b):\n    v = 0\n    while n > 1 and n % b == 0:\n        n //= b\n        v += 1\n    return v\n\ndef ok(n):\n    return n // 4 ** valuation(n, 4) % 8 != 7\nprint(list([list_element for list_element in range(84) if ok(list_element)]))", "def valuation(n, b):\n    v = 0\n    while n > 1 and n % b == 0:\n        n //= b\n        v += 1\n    return v\n\ndef ok(n):\n    return n // 4 ** valuation(n, 4) % 8 != 7\nprint(list([list_element for list_element in range(84) if ok(list_element)]))", "def valuation(n, b):\n    v = 0\n    while n > 1 and n % b == 0:\n        n //= b\n        v += 1\n    return v\n\ndef ok(n):\n    return n // 4 ** valuation(n, 4) % 8 != 7\nprint(list([list_element for list_element in range(84) if ok(list_element)]))", "def valuation(n, b):\n    v = 0\n    while n > 1 and n % b == 0:\n        n //= b\n        v += 1\n    return v\n\ndef ok(n):\n    return n // 4 ** valuation(n, 4) % 8 != 7\nprint(list([list_element for list_element in range(84) if ok(list_element)]))"], "completions": {"none": [" a list of integers less than to check which are not perfect squares, as well as odd.\n\nimport math # import the math module (helps with approximation)\n\ndef is_integer(n):\n    # get power of ten greater than n\n    power_of_ten = math.floor(math.log10(n))\n    \n    # n occurs only once in 10^power_of_ten\n    if 10 ** power_of_ten == n", " all numbers less than 84 which do not have a 7 as the remainder when divided by 64.\n\n\n>>> print(list([list_element for list_element in range(84) if ok(list_element)]))\n[[1], [2], [3], [4], [5], [7], [8], [9], [10], [16], [20], [23], [24], [32],\n [40], [52], [56], [", " a list of positive integers less than or\nequal to 84 that satisfy the condition described below:\n\nReturn a list of those positive integers less than or equal to \"n\"\nfor which the following condition holds: The base-8 value of\nthat integer is not congruent to 7 modulo 8.\nThat is, take every n such that ok(n) is True, and return a list of\nthose n's as a sublist of [0, ..., 84", " a list of boring numbers. A boring number is any integer n for which for k in [10, 1000]\n\nvalsqrt(k, n) mod 4 == 3\n   n^(k-1) // n mod k == n^(k-2) // n mod k\n\nHere is a detailed explanation:\n\nn^(k-1) // n mod k is roughly the same as saying \".times do |i| n = n ** k", " the following table:\n            \n0 1\n2 4\n8 18\n16 58\n32 162\n40 256\n64 444\n80 518\n96 620\nPython 5    \nprint([list_element for list_element in range(84) if ok(list_element)])\n[8, 16, 32, 64]\n\ndef fib3(n: int) -> int:\n    a, b = 0, 1\n    for i in range("], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000408", "text": "Numbers that are the sum of three nonzero squares.", "sequence": "3,6,9,11,12,14,17,18,19,21,22,24,26,27,29,30,33,34,35,36,38,41,42,43,44,45,46,48,49,50,51,53,54,56,57,59,61,62,65,66,67,68,69,70,72,73,74,75,76,77,78,81,82,83,84,86,88,89,90,91,93,94,96,97,98,99,101,102,104", "code": "\ndef aupto(lim):\n  squares = [k*k for k in range(1, int(lim**.5)+2) if k*k <= lim]\n  sum2sqs = set(a+b for i, a in enumerate(squares) for b in squares[i:])\n  sum3sqs = set(a+b for a in sum2sqs for b in squares)\n  return sorted(set(range(lim+1)) & sum3sqs)\nprint(aupto(104)) \n", "obfuscations": ["def aupto(lim):\n    squares = [k * k for k in range(1, int(lim ** 0.5) + 2) if k * k <= lim]\n    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))\n    sum3sqs = set((a + b for a in sum2sqs for b in squares))\n    return sorted(set(range(lim + 1)) & sum3sqs)\nprint(aupto(104))", "def aupto(lim):\n    squares = [k * k for k in range(1, int(lim ** 0.5) + 2) if k * k <= lim]\n    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))\n    sum3sqs = set((a + b for a in sum2sqs for b in squares))\n    return sorted(set(range(lim + 1)) & sum3sqs)\nprint(aupto(104))", "def aupto(lim):\n    squares = [k * k for k in range(1, int(lim ** 0.5) + 2) if k * k <= lim]\n    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))\n    sum3sqs = set((a + b for a in sum2sqs for b in squares))\n    return sorted(set(range(lim + 1)) & sum3sqs)\nprint(aupto(104))", "def aupto(lim):\n    squares = {*()}\n    for k in range(1, int(lim ** 0.5) + 2):\n        if k * k <= lim:squares.append(k * k)\n    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))\n    sum3sqs = set((a + b for a in sum2sqs for b in squares))\n    return sorted(set(range(lim + 1)) & sum3sqs)\nprint(aupto(104))", "def aupto(lim):\n    squares = {*()}\n    for k in range(1, int(lim ** 0.5) + 2):\n        if k * k <= lim:squares.append(k * k)\n    sum2sqs = {a + b for (i, a) in enumerate(squares) for b in squares[i:]}\n    sum3sqs = {a + b for a in sum2sqs for b in squares}\n    return sorted(set(range(lim + 1)) & sum3sqs)\nprint(aupto(104))"], "completions": {"none": [" all numbers less than 104 which have each term in a magical word as the sum of some subset of terms. Two terms in a series must have an arithmetic progression  in order for this to be a subsequence. For example:\n\n2, 3, 5, 8, 11, ... (this is the fibonacci series). This is an arithmetic progression.\n\n1, 2, 4, 7, ... This is not an arithmetic progression.\n\nThe code finds those numbers by", " all squares that can be expressed as the sum of two squares between 1 and 104.\n\ndef iterate(f, x):\n    yield x\n    for i in iterate(f, f(x)): yield i\n\ndef flatten(node, level = 0):\n    indent = \" \" * 2 * level\n    if len(node) == 1: print(indent, node)\n    else:\n        print(indent, node)", " all triangular numbers up to an upper bound limit.\n\ndef min_operation(exp: str) -> int:\n    pass\n\nThe above code computes an expression.\n\nhax_table48_math_hardware = pd.read_csv(\"../hax_table48_math_hardware.csv\", sep=',', header=0, index_col=1, usecols=[1,8])\nhax_table48_", " all Fibonacci numbers strictly less than n.\n\nThe above code, called a Ulam Sequence, sums all Fibonacci numbers up to, and including, the greatest Fibonacci number that is a sqrt(n) + 1 (for some integer n <= 46).\n\nIf all occurrences of a in an array A sum to c, then all c's in an array A will sum to a.\n\nThis is why all c's in the Ulam Sequence sum", " all the integer numbers that are sum-up square no greater than 104, and returns that list, in increasing order.\n\nSome geometric factors\n\nIn mathematics, there are various useful concepts. Among these are geometric factors, which are factors of polynomials that are products of the coordinate vectors of the factor's domain.\n\nGeometric factors are an important class of functions that appear in areas ranging from mechanics to statistics. Many of the geometric factors may be expressed using the exponential function"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000414", "text": "Numbers that are the sum of 4 nonzero squares.", "sequence": "4,7,10,12,13,15,16,18,19,20,21,22,23,25,26,27,28,30,31,33,34,35,36,37,38,39,40,42,43,44,45,46,47,48,49,50,51,52,53,54,55,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81", "code": "\nlimit = 10026 \nfrom functools import lru_cache\nnzs = [k*k for k in range(1, int(limit**.5)+2) if k*k + 3 <= limit]\nnzss = set(nzs)\n@lru_cache(maxsize=None)\ndef ok(n, m): return n in nzss if m == 1 else any(ok(n-s, m-1) for s in nzs)\nprint([n for n in range(4, limit+1) if ok(n, 4)]) \n", "obfuscations": ["limit = 10026\nfrom functools import lru_cache\nnzs = [k * k for k in range(1, int(limit ** 0.5) + 2) if k * k + 3 <= limit]\nnzss = set(nzs)\n\n@lru_cache(maxsize=None)\ndef ok(n, m):\n    return n in nzss if m == 1 else any((ok(n - s, m - 1) for s in nzs))\nprint([n for n in range(4, limit + 1) if ok(n, 4)])", "limit = 10026\nfrom functools import lru_cache\nnzs = [k * k for k in range(1, int(limit ** 0.5) + 2) if k * k + 3 <= limit]\nnzss = set(nzs)\n\n@lru_cache(maxsize=None)\ndef ok(n, m):\n    return n in nzss if m == 1 else any((ok(n - s, m - 1) for s in nzs))\nprint([n for n in range(4, limit + 1) if ok(n, 4)])", "limit = 10026\nfrom functools import lru_cache\nnzs = [k * k for k in range(1, int(limit ** 0.5) + 2) if k * k + 3 <= limit]\nnzss = set(nzs)\n\n@lru_cache(maxsize=None)\ndef ok(n, m):\n    return n in nzss if m == 1 else any((ok(n - s, m - 1) for s in nzs))\nprint([n for n in range(4, limit + 1) if ok(n, 4)])", "limit = 10026\nfrom functools import lru_cache\nnzs = {*()}\nfor k in range(1, int(limit ** 0.5) + 2):\n    if k * k + 3 <= limit:nzs.append(k * k)\nnzss = set(nzs)\n\n@lru_cache(maxsize=None)\ndef ok(n, m):\n    return n in nzss if m == 1 else any((ok(n - s, m - 1) for s in nzs))\nprint([n for n in range(4, limit + 1) if ok(n, 4)])", "limit = 10026\nfrom functools import lru_cache\nnzs = {*()}\nfor k in range(1, int(limit ** 0.5) + 2):\n    if k * k + 3 <= limit:nzs.append(k * k)\nnzss = set(nzs)\n\n@lru_cache(maxsize=None)\ndef ok(n, m):\n    return n in nzss if m == 1 else any((ok(n - s, m - 1) for s in nzs))\nprint([n for n in range(4, limit + 1) if ok(n, 4)])"], "completions": {"none": [" a list of all the numbers below a specified limit that are divisble by at least four distinct primes. Note that using a \u2264 b \u2264 c \u2264 d \u2264 \u2026 \u2264 k \u2264 limit as the search space seems to not yield perfect results. Instead, it seems that the maximum limit for this problem is a little lesser than what was initially intended.\n\n'''", " a set of all square numbers less than or equal to 10026. Then, using functools.lru_cache, it generates a function that will use those square numbers to determine if the n-th Fibonacci number is square-free.\n\ndef is_square(n):\n    return n > 0 and (n ** 0.5).is_integer()\n\ndef is_square_free(n, nzss):\n    if n < 0", " all perfect squares satisfying the following inequality: 4^2 + 4^0 < n <= 4^2 + 4^1.\n\ndef ok(n):\n    c, r = divmod(B - n * n, 4)\n    return not r and (k*k + c) ** 0.5 % 1 == 0\n\n# with list\nprint(sum(A <= sum(F[m][n] for n in range(k)) < B", " squares that lead to the first Fibonacci numbers.The above code uses a relatively complex process to assert whether a number is possible using the above test.\n\nSquare numbers that are divisible by Fibonacci numbers are impossible for n \u2265 43 because:\n- If a square number is divisible by 43, then its square root is a Fibonacci number.\n- 43 is the largest Fibonacci number below 43**2.\n\nIn the same way, 25 is the", " a set of perfect squares less than limit by including s in nzs if s + 3 <= limit and then creating an empty set nzss, which is iteratively appended with all n-square less than limit according to the most recently added perfect number n in nzs (if n is the n-square).\n\nKnowing that F k means F (k-1) + F (k-2), we define findAllSquares(n) = f = {"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000419", "text": "Numbers that are the sum of 3 but no fewer nonzero squares.", "sequence": "3,6,11,12,14,19,21,22,24,27,30,33,35,38,42,43,44,46,48,51,54,56,57,59,62,66,67,69,70,75,76,77,78,83,84,86,88,91,93,94,96,99,102,105,107,108,110,114,115,118,120,123,126,129,131,132,133,134,138,139,140,141,142", "code": "\ndef aupto(lim):\n  squares = [k*k for k in range(1, int(lim**.5)+2) if k*k <= lim]\n  sum2sqs = set(a+b for i, a in enumerate(squares) for b in squares[i:])\n  sum3sqs = set(a+b for a in sum2sqs for b in squares)\n  return sorted(set(range(lim+1)) & (sum3sqs - sum2sqs - set(squares)))\nprint(aupto(142)) \n", "obfuscations": ["def aupto(lim):\n    squares = [k * k for k in range(1, int(lim ** 0.5) + 2) if k * k <= lim]\n    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))\n    sum3sqs = set((a + b for a in sum2sqs for b in squares))\n    return sorted(set(range(lim + 1)) & sum3sqs - sum2sqs - set(squares))\nprint(aupto(142))", "def aupto(lim):\n    squares = [k * k for k in range(1, int(lim ** 0.5) + 2) if k * k <= lim]\n    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))\n    sum3sqs = set((a + b for a in sum2sqs for b in squares))\n    return sorted(set(range(lim + 1)) & sum3sqs - sum2sqs - set(squares))\nprint(aupto(142))", "def aupto(lim):\n    squares = [k * k for k in range(1, int(lim ** 0.5) + 2) if k * k <= lim]\n    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))\n    sum3sqs = set((a + b for a in sum2sqs for b in squares))\n    return sorted(set(range(lim + 1)) & sum3sqs - sum2sqs - set(squares))\nprint(aupto(142))", "def aupto(lim):\n    squares = {*()}\n    for k in range(1, int(lim ** 0.5) + 2):\n        if k * k <= lim:squares.append(k * k)\n    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))\n    sum3sqs = set((a + b for a in sum2sqs for b in squares))\n    return sorted(set(range(lim + 1)) & sum3sqs - sum2sqs - set(squares))\nprint(aupto(142))", "def aupto(lim):\n    squares = {*()}\n    for k in range(1, int(lim ** 0.5) + 2):\n        if k * k <= lim:squares.append(k * k)\n    sum2sqs = {a + b for (i, a) in enumerate(squares) for b in squares[i:]}\n    sum3sqs = {a + b for a in sum2sqs for b in squares}\n    return sorted(set(range(lim + 1)) & sum3sqs - sum2sqs - set(squares))\nprint(aupto(142))"], "completions": {"none": [" the first number that is needed to form a sequence of a, b, c such that a\u00b2 + b\u00b2 = c\u00b2\nThe sequence generators are the numbers [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...], i.e. the Fibonacci numbers and the square numbers. The numbers are used in pairs that form the total sum.\n\nCode based on what I learned from Nando Quintana's implementation of", " all Pythagorean triples less than a given limit - we use square roots here as it simplifies things.\n\nsquares = [k * k for k in range(1, int(lim ** 0.5) + 2) if k * k <= lim]\nsum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))\nsum3sqs = set((a + b", " a list of the first 42 distinct numbers not produced by the formula a + b + c = 1000 where a <= b <= c. The first rectangle that produces such a result is 652 * 682 = 44104.\n\ndef pascal(depth):\n    delta = [0] + [1] * depth\n    out = [delta]\n    while out[-1][1] != 0:\n        mat = [1]\n        while not len(", " all the abundant numbers which are less than 143\n(The LIMIT is adopted from: https://www.topcoder.com/community/data-science/data-science-tutorials/the-art-of-problem-solving/)\n\"\"\"", " all Pythagorean Triples having a sum less than or equal to input limit 'a'.\n\nRandomness through time is simulated through Python's time module.\n\nFor each value of k, three solutions are generated, and their respective runtimes are logged. The runtime is calculated as the number of seconds between the creation of the Python interpreter object, and the end of the program.\n\nThe final code to generate all the solutions is:\n\n```py\nimport solution\n"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000468", "text": "Powers of ten written in base 8.", "sequence": "1,12,144,1750,23420,303240,3641100,46113200,575360400,7346545000,112402762000,1351035564000,16432451210000,221411634520000,2657142036440000,34327724461500000,434157115760200000,5432127413542400000,67405553164731000000,1053071060221172000000", "code": "\ndef a(n): return int(oct(10**n)[2:])\nprint([a(n) for n in range(20)]) \n", "obfuscations": ["def a(n):\n    return int(oct(10 ** n)[2:])\nprint([a(n) for n in range(20)])", "def a(n):\n    return int(oct(10 ** n)[2:])\nprint([a(n) for n in range(20)])", "def a(n):\n    return int(oct(10 ** n)[2:])\nprint([a(n) for n in range(20)])", "def a(n):\n    return int(oct(10 ** n)[2:])\nprint([a(n) for n in range(20)])", "def a(n):\n    return int(oct(10 ** n)[2:])\nprint([a(n) for n in range(20)])"], "completions": {"none": [" the 20 first numbers in the octal counting system.\n\nWhat is the sum of the 20 first numbers in the octal counting system?\n\nBonus\n\nThe sum of the first 20 numbers in a counting system is given by the formula: $$\\frac{(a+1)^{n+1}-(a+1)}{a-1}$$\nDecimal:\nAnswer: 892371480\nBonus decimal:\n\nOctal:\nAnswer: 79", " 10 ** n for any given integer n.\n\noct() is a built-in String function that converts an integer to its octal representation as a string. For example, the octal representation of 10 is 1010.\n\nIn a for loop for range(20), simply print the resulting equation, showing the following results from a(n) for n in ranges of 0-19:\n\n10\n1010\n101000\n10100000\n1010000000\n101000000000", " a list of integers with digit 8s for the number 10 ** n, for n in the range [0, 20). Here it is described how this code works:\n\nFor each integer in the range 0 <= n < 20, convert 10 ** n to octal with str(oct(...)). Return each string as a list of characters by str[2:], then convert all strings with int(x, 8). Finally, assign each integer generated to the list.\n\n10", " a list from 0 to 19 by first converting each item to its corresponding binary, removing any leading '0b1', and then likewise converting them to decimal for each item in the list.\n\nn, a\n\n![canonical laboratory image](https://lh3.googleusercontent.com/dgm1dlHkDz0IB41I0NVW20dlHrTmT31T2OkhRkLj8Qru7Ai", " and prints the starting values of a Lucas Numbers recurrence\n\nLucas number seeds and their Lucas(\"Lucas(1)\") values:\n\nseed a = 2\nvalue a = u_1 = 1\nseed b = 1\nvalue b = u_2 = 2\n\nThe formula for calculating a Lucas number:\n\nu_n = u_(n-1) + u_(n-2)\n\ndef lucas(seed_a: int, seed"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000538", "text": "Sum of fourth powers: 0^4 + 1^4 + ... + n^4.", "sequence": "0,1,17,98,354,979,2275,4676,8772,15333,25333,39974,60710,89271,127687,178312,243848,327369,432345,562666,722666,917147,1151403,1431244,1763020,2153645,2610621,3142062,3756718,4463999,5273999,6197520,7246096,8432017,9768353", "code": "\nA000538_list, m = [0], [24, -36, 14, -1, 0, 0]\nfor _ in range(10**2):\n    for i in range(5):\n        m[i+1] += m[i]\n    A000538_list.append(m[-1]) \n", "obfuscations": ["(A000538_list, m) = ([0], [24, -36, 14, -1, 0, 0])\nfor _ in range(10 ** 2):\n    for i in range(5):\n        m[i + 1] += m[i]\n    A000538_list.append(m[-1])", "(A000538_list, m) = ([0], [24, -36, 14, -1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(5))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000538_list.append(m[-1])\n    except StopIteration:\n        break", "(A000538_list, m) = ([0], [24, -36, 14, -1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(5))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000538_list.append(m[-1])\n    except StopIteration:\n        break", "(A000538_list, m) = ([0], [24, -36, 14, -1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(5))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000538_list.append(m[-1])\n    except StopIteration:\n        break", "(A000538_list, m) = ([0], [24, -36, 14, -1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(5))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000538_list.append(m[-1])\n    except StopIteration:\n        break"], "completions": {"none": [" and caches A000538 with a compact WikiPedia solution. Upon being implemented in main.py, A000538 calculates the n-th Lucas number as a Fibonacci number. From there, Lucas_number calls fib2 for the n-th Fibonacci numbers.\n\nLucas_number(n: int) -> int:\n\nCollect the n-th Lucas number. (A000213)\n\ndef Lucas_number(n: int) -> int:", " A000538, the list of Fibonacci numbers where each entry is 3 greater than the previous entry it than the previous entry, described below:\n\nAccording to the Fibonacci sequence, the 6th Fibonacci number is 8, the 8th Fibonacci number is 21, the 11th Fibonacci number is 34, and so on. Thus, by adding 3 to each Fibonacci number, the list of incrrements achieved by recursively applying the", " A000538, known as the \"Fibonacci numbers\"; the last line of code initializes the Fibonacci sequence:\n\nTEST_CODE_Lorenzo_Rojas\nluca = [iter(range(5))] * 2\nprint([list(x) for x in luca])\nluca2 = [(iter(range(i)), iter(range(i))) for i in range(5, 2,-1)]\nprint", " the sequence as defined by A000538.\n'''", " the Fibonacci sequence through a list + generator method. It is equivalent to the following much less efficient code.\n\nF = []\nfor (l1, l2) in zip([[y for y in [0]*i] for i in range(5)], [[y for y in [0]*i] for i in range(6)]):\n    for n in range(len(l1) - 1):\n        l2[n +"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000539", "text": "Sum of 5th powers: 0^5 + 1^5 + 2^5 + ... + n^5.", "sequence": "0,1,33,276,1300,4425,12201,29008,61776,120825,220825,381876,630708,1002001,1539825,2299200,3347776,4767633,6657201,9133300,12333300,16417401,21571033,28007376,35970000,45735625,57617001,71965908,89176276,109687425,133987425", "code": "\nA000539_list, m = [0], [120, -240, 150, -30, 1, 0, 0]\nfor _ in range(10**2):\n    for i in range(6):\n        m[i+1] += m[i]\n    A000539_list.append(m[-1]) \n", "obfuscations": ["(A000539_list, m) = ([0], [120, -240, 150, -30, 1, 0, 0])\nfor _ in range(10 ** 2):\n    for i in range(6):\n        m[i + 1] += m[i]\n    A000539_list.append(m[-1])", "(A000539_list, m) = ([0], [120, -240, 150, -30, 1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(6))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000539_list.append(m[-1])\n    except StopIteration:\n        break", "(A000539_list, m) = ([0], [120, -240, 150, -30, 1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(6))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000539_list.append(m[-1])\n    except StopIteration:\n        break", "(A000539_list, m) = ([0], [120, -240, 150, -30, 1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(6))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000539_list.append(m[-1])\n    except StopIteration:\n        break", "(A000539_list, m) = ([0], [120, -240, 150, -30, 1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(6))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000539_list.append(m[-1])\n    except StopIteration:\n        break"], "completions": {"none": [" A000539, which is the offset-addition sequence for the Fibonacci numbers.\n\n'''\n\n\ndef A000045(n): return 120 * pow(2, n, 1500000) - 240 * pow(2, n - 1, 1500000)\n\n\ndef A000078(n): return sum(A000045(i) for i in range(n))\n\n\ndef A000539(n): return 539-963", " the A000539 sequence to give Fibonacci-style numbers and is a generalisation of the function fib2().\n\ndef fib3(n: int) -> int:\n    (a, b) = (0, 1)\n    while n > 0:\n        (a, b) = (b, a+b)\n        n -= 1\n    return b\n\n\n\"\"\"\n\n\"\"\"\nTo prove the above claim, consider an algorithm where you", " A000539, a Least Integer RE for the n-th Fibonacci number. The contents of A000539 can be found in the file A000539.py.\n\nA000359 = current_A000359 = []\nA000589 = current_A000589 = []\nA000255 = 80\nsequence_iterator = iter(range(A000255))\nwhile True:\n    try:\n        _ = next(sequence_", " A000539, an array of the first 10**2 Fibonacci numbers.\n\n    const A000539_list = [0, 120, -240, 150, -30, 1, 0, 0]\n    sequence_iterator2 = A000539_list.iterate()\n    for i in Naturals:\n        sequence_iterator1 = iter(range(6))\n        while True:\n            try:\n                j = next", " a sequence similar to the Fibonacci numbers, documented below:\n\nA000539(n) = (1,-1,...,1,-1)[n]\nA000539(n) = fib(2*n+3) - 2*fib(2*n+2)\nm(1) = fib(n) * fib(n) + 1\nm(2) = fib(n)^2 + 2 fib(n) ="], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000540", "text": "Sum of 6th powers: 0^6 + 1^6 + 2^6 + ... + n^6.", "sequence": "0,1,65,794,4890,20515,67171,184820,446964,978405,1978405,3749966,6735950,11562759,19092295,30482920,47260136,71397705,105409929,152455810,216455810,302221931,415601835,563637724,754740700,998881325,1307797101,1695217590", "code": "\nA000540_list, m = [0], [720, -1800, 1560, -540, 62, -1, 0, 0]\nfor _ in range(10**2):\n    for i in range(7):\n        m[i+1] += m[i]\n    A000540_list.append(m[-1]) \n", "obfuscations": ["(A000540_list, m) = ([0], [720, -1800, 1560, -540, 62, -1, 0, 0])\nfor _ in range(10 ** 2):\n    for i in range(7):\n        m[i + 1] += m[i]\n    A000540_list.append(m[-1])", "(A000540_list, m) = ([0], [720, -1800, 1560, -540, 62, -1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(7))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000540_list.append(m[-1])\n    except StopIteration:\n        break", "(A000540_list, m) = ([0], [720, -1800, 1560, -540, 62, -1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(7))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000540_list.append(m[-1])\n    except StopIteration:\n        break", "(A000540_list, m) = ([0], [720, -1800, 1560, -540, 62, -1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(7))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000540_list.append(m[-1])\n    except StopIteration:\n        break", "(A000540_list, m) = ([0], [720, -1800, 1560, -540, 62, -1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(7))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000540_list.append(m[-1])\n    except StopIteration:\n        break"], "completions": {"none": [" the first 10,000 values of the Fibonacci sequence and creates a list from this. These values are use to generate the index or N'th value of the Fibonacci sequence for any n less than 10,000.\n\n@lru_cache(maxsize = None)\ndef fib_memoization(n: int) -> int:\n\nThe above code declares a memoized function used to generate the N'th Fibonacci number by the use of", " the first 10 numbers of the Fibonacci sequence.\")", " the first 10F elements of the Fibonacci sequence.\n\nThe code has many comments and also requires a ton of explanations. So let us leave out these debugging parts and directly use their working Fibonacci sequence generator which are documented as lists with 7 elements by Fibonacci designation below:\n\nprint(fib1(10 ** 2), end=\"\\n\\n\")\nprint(fib2(10 ** 2))\n\"\"\"\n\n\n######################################################\n#", " the Fibonacci sequence through a \"Global Array Exploitation\" method, described below:\n\nInitiate an empty list which will be filled with Fibonacci numbers. Then, in a loop for 100 iterations, generate the ...\n\nInitiate a m global value which has a list of 6 numbers as its values, but where the last elements of the list are filled with 0.\n\"for i in range(7):\", loop 7 times, alter the m values", " the n-th Fibonacci number for n <= 1000. First it computes the array \"m\" containing the first seven Fibonacci numbers. Then, it loops from 0 to 1000, inclusively, adding each term of sequence \"m\" to the sum of its 2 previous terms, saving the results in the list \"A000540_list\".\n'''\nA000540_list, m = ([0], [720, -1800, 1560, -540,"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000541", "text": "Sum of 7th powers: 1^7 + 2^7 + ... + n^7.", "sequence": "0,1,129,2316,18700,96825,376761,1200304,3297456,8080425,18080425,37567596,73399404,136147921,241561425,412420800,680856256,1091194929,1703414961,2597286700,3877286700,5678375241,8172733129,11577558576,16164030000,22267545625", "code": "\nA000541_list, m = [0], [5040, -15120, 16800, -8400, 1806, -126, 1, 0, 0]\nfor _ in range(10**2):\n    for i in range(8):\n        m[i+1] += m[i]\n    A000541_list.append(m[-1]) \n", "obfuscations": ["(A000541_list, m) = ([0], [5040, -15120, 16800, -8400, 1806, -126, 1, 0, 0])\nfor _ in range(10 ** 2):\n    for i in range(8):\n        m[i + 1] += m[i]\n    A000541_list.append(m[-1])", "(A000541_list, m) = ([0], [5040, -15120, 16800, -8400, 1806, -126, 1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(8))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000541_list.append(m[-1])\n    except StopIteration:\n        break", "(A000541_list, m) = ([0], [5040, -15120, 16800, -8400, 1806, -126, 1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(8))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000541_list.append(m[-1])\n    except StopIteration:\n        break", "(A000541_list, m) = ([0], [5040, -15120, 16800, -8400, 1806, -126, 1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(8))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000541_list.append(m[-1])\n    except StopIteration:\n        break", "(A000541_list, m) = ([0], [5040, -15120, 16800, -8400, 1806, -126, 1, 0, 0])\nsequence_iterator2 = iter(range(10 ** 2))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(8))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000541_list.append(m[-1])\n    except StopIteration:\n        break"], "completions": {"none": [" the 50th onwards (n > 50) Fibonacci numbers using the look-and-say sequence.\n\ndef fibonacci_gen(n: int) -> int:\n    if n < 2:\n        return n\n    yield 0\n    yield 1\n    a, b = 0, 1\n    for _ in range(n-2):\n        a, b = b, a + b\n        yield b\n\nThe above code uses a generator", " the first 10 entries in the Fibonacci sequence. The code is an AoC native solution to the problem, so it's optimized for its AoC-yness. However, the correctness of the code is ensured to be correct though checks of the output at the aforementioned wikipedia boilerplate:        \n\nhttps://oeis.org/A006577\n\nprograms_list = []\nprograms_list.append(\"\"\"\ndef fib():\n    f = [", " a firs-order formula for the \"Online Encyclopedia of Integer Sequences.\"\n\nn=num\nnth=A000541_list[num]\n\nn is the n-th Fibonacci number you would like to compute and it has a 0 offset.\n\nGeneral note: Program assumes that the nth Fibonacci number you would like to compute is in the sequence and that more primes are appended.\n\nAuthor and use case\n--------------------\n", " the first n terms of the sequence A000541 defined by:\n\nm[0] = 5040,\nm[i] = -15120 + 2 \\[1]m[i-1],\nm[i+1] = 3 \\[2]m[i] \\[1]m[i-1],\nm[2n] = -30240,\nm[2n+1] = 0,\nm[i] =", " a computational sequence seeded with the Fibonacci numbers.\n\ndef sequence1(n: int) -> int:\n    return A000541_list[n]\n\nThe above code generates the first n numbers of the computational sequence above.\n\"\"\"\n\nif __name__ == \"__main__\":\n    print(main())"], "p": [], "f": [], "pf": []}}
{"sequence_id": "A000542", "text": "Sum of 8th powers: 1^8 + 2^8 + ... + n^8.", "sequence": "0,1,257,6818,72354,462979,2142595,7907396,24684612,67731333,167731333,382090214,812071910,1627802631,3103591687,5666482312,9961449608,16937207049,27957167625,44940730666,70540730666,108363590027,163239463563,241550448844", "code": "\nA000542_list, m = [0], [40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0]\nfor _ in range(24):\n    for i in range(9):\n        m[i+1] += m[i]\n    A000542_list.append(m[-1])\nprint(A000542_list) \n", "obfuscations": ["(A000542_list, m) = ([0], [40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0])\nfor _ in range(24):\n    for i in range(9):\n        m[i + 1] += m[i]\n    A000542_list.append(m[-1])\nprint(A000542_list)", "(A000542_list, m) = ([0], [40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0])\nsequence_iterator2 = iter(range(24))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(9))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000542_list.append(m[-1])\n    except StopIteration:\n        break\nprint(A000542_list)", "(A000542_list, m) = ([0], [40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0])\nsequence_iterator2 = iter(range(24))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(9))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000542_list.append(m[-1])\n    except StopIteration:\n        break\nprint(A000542_list)", "(A000542_list, m) = ([0], [40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0])\nsequence_iterator2 = iter(range(24))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(9))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000542_list.append(m[-1])\n    except StopIteration:\n        break\nprint(A000542_list)", "(A000542_list, m) = ([0], [40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0])\nsequence_iterator2 = iter(range(24))\nwhile True:\n    try:\n        _ = next(sequence_iterator2)\n        sequence_iterator1 = iter(range(9))\n        while True:\n            try:\n                i = next(sequence_iterator1)\n                m[i + 1] += m[i]\n            except StopIteration:\n                break\n        A000542_list.append(m[-1])\n    except StopIteration:\n        break\nprint(A000542_list)"], "completions": {"none": [" the first 25 values in the A000542-sequence for the Fibonacci numbers, where the sequence is:\n0, 40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0, 0, 0, 0, 0, 0,\n0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0.\nAs can be observed, A", " the n-th term from a list of the first 24 Fibonacci numbers by adding the last 8 numbers of the previous set to the current set.\n\nIn total, just over 3 minutes and 56 seconds have elapsed since I wrote the code around 2014, a relative speed at which a computer can run that same code incredibly fast.\n\nTotal time elapsed: 00:03:56.00\n\"\"\"", " the first 24 elements of A000542. The omitted code is for generating the entire sequence, so as to generate the first 10,000 elements for the problem. Due to being inefficient (to implemenent), a sublist of 10,000 elements is used.\n\nA000542 = A000542_list\n\"\"\"\n########################################################################################################################\n\"\"\"Console Output of A009182_sequence.py\n\nSee below.\n\"\"\"\n################################################################################################", " the terms of the A000542-sequence for the Stirling Numbers of the First Kind, which counts the \"paths\" along a sequence of n-1-illuminated elements where the number 100 lands. The above code also works for the A000079-sequence and the A000215-sequence (generates the first 9-odd numbers).\nOn the language side, this code is much more readable than the given iterative methods, both due to increased auto-string", " A000542, which contains the iterative sequence needed to generate a given Fibonacci number. For example, fortytwo = A000542_list[40], so fortytwo = A000542_list[40] = A000542_list[40-1] + A000542_list[40-2]. See Alternation for my provisional code to generate the sequence. The code below is the final code that generates sequentially the sequence of Fib"], "p": [], "f": [], "pf": []}}
