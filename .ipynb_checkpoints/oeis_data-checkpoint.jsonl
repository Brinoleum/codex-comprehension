{"sequence_id": "Sequence number", "text": "Sequence name", "sequence": "Sequence", "code": "Python code"}
{"sequence_id": "A000002", "text": "Kolakoski sequence: a(n) is length of n-th run; a(1) = 1; sequence consists just of 1's and 2's.", "sequence": "1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2,1,1,2,1,1,2,1,2,2,1,2,2,1,1,2,1,2,2,1,2,1,1,2,1,1,2,2,1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,1,2,2,1,2,1,1,2,2,1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2", "code": "\n\ndef Kolakoski():\n    x = y = -1\n    while True:\n        yield [2,1][x&1]\n        f = y &~ (y+1)\n        x ^= f\n        y = (y+1) | (f & (x>>1))\nK = Kolakoski()\nprint([next(K) for _ in range(100)]) \n"}
{"sequence_id": "A000005", "text": "d(n) (also called tau(n) or sigma_0(n)), the number of divisors of n.", "sequence": "1,2,2,3,2,4,2,4,3,4,2,6,2,4,4,5,2,6,2,6,4,4,2,8,3,4,4,6,2,8,2,6,4,4,4,9,2,4,4,8,2,8,2,6,6,4,2,10,3,6,4,6,2,8,4,8,4,4,2,12,2,4,6,7,4,8,2,6,4,8,2,12,2,4,6,6,4,8,2,10,5,4,2,12,4,4,4,8,2,12,4,6,4,4,4,12,2,6,6,9,2,8,2,8", "code": "\nfrom sympy import divisor_count\nfor n in range(1, 20): print(divisor_count(n), end=', ') \n"}
{"sequence_id": "A000006", "text": "Integer part of square root of n-th prime.", "sequence": "1,1,2,2,3,3,4,4,4,5,5,6,6,6,6,7,7,7,8,8,8,8,9,9,9,10,10,10,10,10,11,11,11,11,12,12,12,12,12,13,13,13,13,13,14,14,14,14,15,15,15,15,15,15,16,16,16,16,16,16,16,17,17,17,17,17,18,18,18,18,18", "code": "\nfrom sympy import sieve\nA000006 = lambda n: int(sieve[n]**.5)\nprint([A000006(n) for n in range(1,100+1)])\n\n"}
{"sequence_id": "A000009", "text": "Expansion of Product_{m >= 1} (1 + x^m); number of partitions of n into distinct parts; number of partitions of n into odd parts.", "sequence": "1,1,1,2,2,3,4,5,6,8,10,12,15,18,22,27,32,38,46,54,64,76,89,104,122,142,165,192,222,256,296,340,390,448,512,585,668,760,864,982,1113,1260,1426,1610,1816,2048,2304,2590,2910,3264,3658,4097,4582,5120,5718,6378", "code": " \nfrom functools import lru_cache\nfrom math import isqrt\n@lru_cache(maxsize=None)\ndef A000009(n): return 1 if n == 0 else A010815(n)+2*sum((-1)**(k+1)*A000009(n-k**2) for k in range(1,isqrt(n)+1)) \n"}
{"sequence_id": "A000010", "text": "Euler totient function phi(n): count numbers <= n and prime to n.", "sequence": "1,1,2,2,4,2,6,4,6,4,10,4,12,6,8,8,16,6,18,8,12,10,22,8,20,12,18,12,28,8,30,16,20,16,24,12,36,18,24,16,40,12,42,20,24,22,46,16,42,20,32,24,52,18,40,24,36,28,58,16,60,30,36,32,48,20,66,32,44", "code": "\nfrom sympy.ntheory import totient\nprint([totient(i) for i in range(1, 70)])  \n"}
{"sequence_id": "A000013", "text": "Definition (1): Number of n-bead binary necklaces with beads of 2 colors where the colors may be swapped but turning over is not allowed.", "sequence": "1,1,2,2,4,4,8,10,20,30,56,94,180,316,596,1096,2068,3856,7316,13798,26272,49940,95420,182362,349716,671092,1290872,2485534,4794088,9256396,17896832,34636834,67110932,130150588,252648992,490853416", "code": "\nfrom sympy import divisors, totient\ndef a(n): return 1 if n<1 else sum([totient(2*d)*2**(n/d) for d in divisors(n)])/(2*n) \n"}
{"sequence_id": "A000026", "text": "Mosaic numbers or multiplicative projection of n: if n = Product (p_j^k_j) then a(n) = Product (p_j * k_j).", "sequence": "1,2,3,4,5,6,7,6,6,10,11,12,13,14,15,8,17,12,19,20,21,22,23,18,10,26,9,28,29,30,31,10,33,34,35,24,37,38,39,30,41,42,43,44,30,46,47,24,14,20,51,52,53,18,55,42,57,58,59,60,61,62,42,12,65,66,67,68,69,70,71,36", "code": "\nfrom math import prod\nfrom sympy import factorint\ndef a(n): f = factorint(n); return prod(p*f[p] for p in f)\nprint([a(n) for n in range(1, 73)]) \n"}
{"sequence_id": "A000029", "text": "Number of necklaces with n beads of 2 colors, allowing turning over (these are also called bracelets).", "sequence": "1,2,3,4,6,8,13,18,30,46,78,126,224,380,687,1224,2250,4112,7685,14310,27012,50964,96909,184410,352698,675188,1296858,2493726,4806078,9272780,17920860,34669602,67159050,130216124,252745368,490984488", "code": "\nfrom sympy import divisors, totient\ndef a(n):\n    return 1 if n<1 else ((2**(n//2+1) if n%2 else 3*2**(n//2-1)) + sum(totient(n//d)*2**d for d in divisors(n))//n)//2\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A000041", "text": "a(n) is the number of partitions of n (the partition numbers).", "sequence": "1,1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627,792,1002,1255,1575,1958,2436,3010,3718,4565,5604,6842,8349,10143,12310,14883,17977,21637,26015,31185,37338,44583,53174,63261,75175,89134,105558,124754,147273,173525", "code": "\nfrom sympy.ntheory import npartitions\nprint([npartitions(i) for i in range(101)])  \n"}
{"sequence_id": "A000042", "text": "Unary representation of natural numbers.", "sequence": "1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,11111111111,111111111111,1111111111111,11111111111111,111111111111111,1111111111111111,11111111111111111,111111111111111111,1111111111111111111,11111111111111111111", "code": " def a(n): return int(\"1\"*n) \n"}
{"sequence_id": "A000043", "text": "Mersenne exponents: primes p such that 2^p - 1 is prime. Then 2^p - 1 is called a Mersenne prime.", "sequence": "2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279,2203,2281,3217,4253,4423,9689,9941,11213,19937,21701,23209,44497,86243,110503,132049,216091,756839,859433,1257787,1398269,2976221,3021377,6972593,13466917,20996011,24036583,25964951,30402457,32582657,37156667,42643801,43112609", "code": "\nfrom sympy import isprime, prime\nfor n in range(1,100):\n    if isprime(2**prime(n)-1):\n        print(prime(n), end=', ') \n"}
{"sequence_id": "A000045", "text": "Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.", "sequence": "0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155", "code": " \ndef fib():\n    \"\"\" Generates the Fibonacci numbers, starting with 0 \"\"\"\n    x, y = 0, 1\n    while 1:\n        yield x\n        x, y = y, x+y\nf = fib()\na = [next(f) for _ in range(100)]\ndef A000045(n):\n    \"\"\" Returns Fibonacci number with index n, offset 0 \"\"\"\n    return a[n]\ndef A000045_list(N):\n    \"\"\" Returns a list of the first n Fibonacci numbers \"\"\"\n    return a[:N]\n"}
{"sequence_id": "A000045", "text": "Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.", "sequence": "0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155", "code": " \nfrom gmpy2 import fib\nfor n in range(100): print(str(n) + \" \" + str(fib(n)))  \n"}
{"sequence_id": "A000048", "text": "Number of n-bead necklaces with beads of 2 colors and primitive period n, when turning over is not allowed but the two colors can be interchanged.", "sequence": "1,1,1,1,2,3,5,9,16,28,51,93,170,315,585,1091,2048,3855,7280,13797,26214,49929,95325,182361,349520,671088,1290555,2485504,4793490,9256395,17895679,34636833,67108864,130150493,252645135,490853403,954437120,1857283155", "code": "\nfrom sympy import divisors, mobius\ndef a(n): return 1 if n<1 else sum(mobius(d)*2**(n//d) for d in divisors(n) if d%2)//(2*n) \n"}
{"sequence_id": "A000052", "text": "1-digit numbers arranged in alphabetical order, then the 2-digit numbers arranged in alphabetical order, then the 3-digit numbers, etc.", "sequence": "8,5,4,9,1,7,6,3,2,0,18,80,88,85,84,89,81,87,86,83,82,11,15,50,58,55,54,59,51,57,56,53,52,40,48,45,44,49,41,47,46,43,42,14,19,90,98,95,94,99,91,97,96,93,92,17,70,78,75,74,79,71,77,76,73,72", "code": "\nfrom num2words import num2words\ndef n2w(n):\n  return num2words(n).replace(\" and\", \"\").replace(\",\", \"\").replace(\" \", \"\")\ndef agen(maxdigits):\n  for d in range(1, maxdigits+1):\n    yield from sorted(range(10**(d-1)-(d==1), 10**d), key=lambda x: n2w(x))\nprint([an for an in agen(2)]) \n"}
{"sequence_id": "A000058", "text": "Sylvester's sequence: a(n+1) = a(n)^2 - a(n) + 1, with a(0) = 2.", "sequence": "2,3,7,43,1807,3263443,10650056950807,113423713055421844361000443,12864938683278671740537145998360961546653259485195807", "code": "\nA000058 = [2]\nfor n in range(1, 10):\n    A000058.append(A000058[n-1]*(A000058[n-1]-1)+1)\n\n"}
{"sequence_id": "A000059", "text": "Numbers n such that (2n)^4 + 1 is prime.", "sequence": "1,2,3,8,10,12,14,17,23,24,27,28,37,40,41,44,45,53,59,66,70,71,77,80,82,87,90,97,99,102,105,110,114,119,121,124,127,133,136,138,139,144,148,156,160,164,167,170,176,182,187,207,215,218,221,233,236,238,244,246", "code": "\nfrom sympy import isprime\nprint([n for n in range(10**3) if isprime(16*n**4+1)])\n\n"}
{"sequence_id": "A000061", "text": "Generalized tangent numbers d(n,1).", "sequence": "1,1,2,4,4,6,8,8,12,14,14,16,20,20,24,32,24,30,38,32,40,46,40,48,60,50,54,64,60,68,80,64,72,92,76,96,100,82,104,112,96,108,126,112,120,148,112,128,168,130,156,160,140,162,184,160,168,198,170,192,220,168,192", "code": " \n"}
{"sequence_id": "A000069", "text": "Odious numbers: numbers with an odd number of 1's in their binary expansion.", "sequence": "1,2,4,7,8,11,13,14,16,19,21,22,25,26,28,31,32,35,37,38,41,42,44,47,49,50,52,55,56,59,61,62,64,67,69,70,73,74,76,79,81,82,84,87,88,91,93,94,97,98,100,103,104,107,109,110,112,115,117,118,121,122,124,127,128", "code": "\n[n for n in range(1, 201) if bin(n)[2:].count(\"1\") % 2] \n"}
{"sequence_id": "A000073", "text": "Tribonacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) for n >= 3 with a(0) = a(1) = 0 and a(2) = 1.", "sequence": "0,0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,66012,121415,223317,410744,755476,1389537,2555757,4700770,8646064,15902591,29249425,53798080,98950096,181997601,334745777,615693474,1132436852", "code": "\ndef a(n, adict={0:0, 1:0, 2:1}):\n    if n in adict:\n        return adict[n]\n    adict[n]=a(n-1)+a(n-2)+a(n-3)\n    return adict[n] \n"}
{"sequence_id": "A000075", "text": "Number of positive integers <= 2^n of form 2 x^2 + 3 y^2.", "sequence": "0,1,2,4,7,14,23,42,76,139,258,482,907,1717,3269,6257,12020,23171,44762,86683,168233,327053,636837,1241723,2424228,4738426,9271299,18157441,35591647,69820626,137068908,269270450,529312241,1041093048,2048825748,4034059456", "code": "\nimport math\ndef A000075(n):\n    return len(set([2*x**2+3*y**2 for x in range(1+int(math.floor(2**((n-1)/2)))) for y in range(1+int(math.floor(math.sqrt((2**n-2*x**2)/3)))) if 0 < 2*x**2+3*y**2 <= 2**n]))\n\n"}
{"sequence_id": "A000078", "text": "Tetranacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) + a(n-4) for n >= 4 with a(0) = a(1) = a(2) = 0 and a(3) = 1.", "sequence": "0,0,0,1,1,2,4,8,15,29,56,108,208,401,773,1490,2872,5536,10671,20569,39648,76424,147312,283953,547337,1055026,2033628,3919944,7555935,14564533,28074040,54114452,104308960,201061985,387559437,747044834,1439975216,2775641472", "code": "\nA000078 = [0,0,0,1]\nfor n in range(4, 100):\n    A000078.append(A000078[n-1]+A000078[n-2]+A000078[n-3]+A000078[n-4])\n\n"}
{"sequence_id": "A000079", "text": "Powers of 2: a(n) = 2^n.", "sequence": "1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592", "code": "\ndef a(n): return 2**n\nprint([a(n) for n in range(34)]) \n"}
{"sequence_id": "A000108", "text": "Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!).", "sequence": "1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190,6564120420,24466267020,91482563640,343059613650,1289904147324,4861946401452,18367353072152,69533550916004,263747951750360,1002242216651368,3814986502092304", "code": "\nfrom gmpy2 import divexact\nA000108 = [1, 1]\nfor n in range(1, 10**3):\n    A000108.append(divexact(A000108[-1]*(4*n+2),(n+2))) \n"}
{"sequence_id": "A000110", "text": "Bell or exponential numbers: number of ways to partition a set of n labeled elements.", "sequence": "1,1,2,5,15,52,203,877,4140,21147,115975,678570,4213597,27644437,190899322,1382958545,10480142147,82864869804,682076806159,5832742205057,51724158235372,474869816156751,4506715738447323,44152005855084346,445958869294805289,4638590332229999353,49631246523618756274", "code": " \n\ndef A000110_list(m):\n    A = [0 for i in range(m)]\n    A[0] = 1\n    R = [1, 1]\n    for n in range(1, m):\n        A[n] = A[0]\n        for k in range(n, 0, -1):\n            A[k-1] += A[k]\n        R.append(A[0])\n    return R\nA000110_list(40) \n"}
{"sequence_id": "A000110", "text": "Bell or exponential numbers: number of ways to partition a set of n labeled elements.", "sequence": "1,1,2,5,15,52,203,877,4140,21147,115975,678570,4213597,27644437,190899322,1382958545,10480142147,82864869804,682076806159,5832742205057,51724158235372,474869816156751,4506715738447323,44152005855084346,445958869294805289,4638590332229999353,49631246523618756274", "code": "\n\nfrom itertools import accumulate\nA000110, blist, b = [1,1], [1], 1\nfor _ in range(20):\n    blist = list(accumulate([b]+blist))\n    b = blist[-1]\n    A000110.append(b) \n"}
{"sequence_id": "A000111", "text": "Euler or up/down numbers: e.g.f. sec(x) + tan(x). Also for n >= 2, half the number of alternating permutations on n letters (A001250).", "sequence": "1,1,1,2,5,16,61,272,1385,7936,50521,353792,2702765,22368256,199360981,1903757312,19391512145,209865342976,2404879675441,29088885112832,370371188237525,4951498053124096,69348874393137901,1015423886506852352,15514534163557086905,246921480190207983616,4087072509293123892361", "code": "\n\nfrom itertools import accumulate\nA000111_list, blist = [1,1], [1]\nfor n in range(10**2):\n    blist = list(reversed(list(accumulate(reversed(blist))))) + [0] if n % 2 else [0]+list(accumulate(blist))\n    A000111_list.append(sum(blist)) \n"}
{"sequence_id": "A000111", "text": "Euler or up/down numbers: e.g.f. sec(x) + tan(x). Also for n >= 2, half the number of alternating permutations on n letters (A001250).", "sequence": "1,1,1,2,5,16,61,272,1385,7936,50521,353792,2702765,22368256,199360981,1903757312,19391512145,209865342976,2404879675441,29088885112832,370371188237525,4951498053124096,69348874393137901,1015423886506852352,15514534163557086905,246921480190207983616,4087072509293123892361", "code": "\nfrom mpmath import *\nmp.dps = 150\nl = chop(taylor(lambda x: sec(x) + tan(x), 0, 26))\n[int(fac(i) * li) for i, li in enumerate(l)]  \n"}
{"sequence_id": "A000118", "text": "Number of ways of writing n as a sum of 4 squares; also theta series of lattice Z^4.", "sequence": "1,8,24,32,24,48,96,64,24,104,144,96,96,112,192,192,24,144,312,160,144,256,288,192,96,248,336,320,192,240,576,256,24,384,432,384,312,304,480,448,144,336,768,352,288,624,576,384,96,456,744,576,336,432,960,576,192", "code": "\nfrom sympy import divisors\ndef a(n): return 1 if n==0 else 8*sum(d for d in divisors(n) if d%4 != 0)\nprint([a(n) for n in range(57)]) \n"}
{"sequence_id": "A000120", "text": "1's-counting sequence: number of 1's in binary expansion of n (or the binary weight of n).", "sequence": "0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3", "code": " def A000120(n): return bin(n).count('1') \n"}
{"sequence_id": "A000124", "text": "Central polygonal numbers (the Lazy Caterer's sequence): n(n+1)/2 + 1; or, maximal number of pieces formed when slicing a pancake with n cuts.", "sequence": "1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,277,301,326,352,379,407,436,466,497,529,562,596,631,667,704,742,781,821,862,904,947,991,1036,1082,1129,1177,1226,1276,1327,1379", "code": "\ndef a(n): return n*(n+1)//2 + 1\nprint([a(n) for n in range(53)]) \n"}
{"sequence_id": "A000126", "text": "A nonlinear binomial sum.", "sequence": "1,2,4,8,15,27,47,80,134,222,365,597,973,1582,2568,4164,6747,10927,17691,28636,46346,75002,121369,196393,317785,514202,832012,1346240,2178279,3524547,5702855,9227432,14930318,24157782,39088133,63245949", "code": "\ndef seq(n):\n    if n < 0:\n        return 1\n    a, b = 1, 1\n    for i in range(n + 1):\n        a, b = b, a + b + i\n    return a\n[seq(i) for i in range(n)] \n"}
{"sequence_id": "A000127", "text": "Maximal number of regions obtained by joining n points around a circle by straight lines. Also number of regions in 4-space formed by n-1 hyperplanes.", "sequence": "1,2,4,8,16,31,57,99,163,256,386,562,794,1093,1471,1941,2517,3214,4048,5036,6196,7547,9109,10903,12951,15276,17902,20854,24158,27841,31931,36457,41449,46938,52956,59536,66712,74519,82993,92171,102091,112792,124314,136698", "code": "\ndef A000127(n): return n*(n*(n*(n - 6) + 23) - 18)//24 + 1 \n"}
{"sequence_id": "A000139", "text": "a(n) = 2*(3*n)!/((2*n+1)!*((n+1)!)).", "sequence": "2,1,2,6,22,91,408,1938,9614,49335,260130,1402440,7702632,42975796,243035536,1390594458,8038677054,46892282815,275750636070,1633292229030,9737153323590,58392041019795,352044769046880,2132866978427640", "code": "\nfrom sympy import binomial\ndef A000139(n): return (binomial(3*n, n)*2)//((n+1)*(2*n+1))\n"}
{"sequence_id": "A000139", "text": "a(n) = 2*(3*n)!/((2*n+1)!*((n+1)!)).", "sequence": "2,1,2,6,22,91,408,1938,9614,49335,260130,1402440,7702632,42975796,243035536,1390594458,8038677054,46892282815,275750636070,1633292229030,9737153323590,58392041019795,352044769046880,2132866978427640", "code": "\nA000139_list = [2]\nfor n in range(1,30):\n    A000139_list.append(3*(3*n-2)*(3*n-1)*A000139_list[-1]//(2*n+2)//(2*n+1)) \n"}
{"sequence_id": "A000142", "text": "Factorial numbers: n! = 1*2*3*4*...*n (order of symmetric group S_n, number of permutations of n letters).", "sequence": "1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,121645100408832000,2432902008176640000,51090942171709440000,1124000727777607680000", "code": "\nfor i in range(1, 1000):\n    y = i\n    for j in range(1, i):\n       y *= i - j\n    print(y, \"\\n\")\n"}
{"sequence_id": "A000142", "text": "Factorial numbers: n! = 1*2*3*4*...*n (order of symmetric group S_n, number of permutations of n letters).", "sequence": "1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,121645100408832000,2432902008176640000,51090942171709440000,1124000727777607680000", "code": "\nimport math\nfor i in range(1, 1000):\n    math.factorial(i)\n    print(\"\")\n\n"}
{"sequence_id": "A000149", "text": "a(n) = floor(e^n).", "sequence": "1,2,7,20,54,148,403,1096,2980,8103,22026,59874,162754,442413,1202604,3269017,8886110,24154952,65659969,178482300,485165195,1318815734,3584912846,9744803446,26489122129,72004899337,195729609428,532048240601,1446257064291", "code": "\nfrom sympy import floor, E\ndef a(n):  return floor(E**n)\nprint([a(n) for n in range(29)]) \n"}
{"sequence_id": "A000164", "text": "Number of partitions of n into 3 squares (allowing part zero).", "sequence": "1,1,1,1,1,1,1,0,1,2,1,1,1,1,1,0,1,2,2,1,1,1,1,0,1,2,2,2,0,2,1,0,1,2,2,1,2,1,2,0,1,3,1,1,1,2,1,0,1,2,3,2,1,2,3,0,1,2,1,2,0,2,2,0,1,3,3,1,2,2,1,0,2,2,3,2,1,2,1,0,1,4,2,2,1,2,3,0,1,4,3,1,0,1,2,0,1,2,3,3,2,4,2,0,2", "code": " import collections; a = collections.Counter(i*i + j*j + k*k for i in range(100) for j in range(i+1) for k in range(j+1)) \n"}
{"sequence_id": "A000166", "text": "Subfactorial or rencontres numbers, or derangements: number of permutations of n elements with no fixed points.", "sequence": "1,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,32071101049,481066515734,7697064251745,130850092279664,2355301661033953,44750731559645106,895014631192902121,18795307255050944540,413496759611120779881,9510425471055777937262", "code": " See Hobson link.\n"}
{"sequence_id": "A000166", "text": "Subfactorial or rencontres numbers, or derangements: number of permutations of n elements with no fixed points.", "sequence": "1,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,32071101049,481066515734,7697064251745,130850092279664,2355301661033953,44750731559645106,895014631192902121,18795307255050944540,413496759611120779881,9510425471055777937262", "code": "\nA000166_list, m, x = [], 1, 1\nfor n in range(10*2):\n    x, m = x*n + m, -m\n    A000166_list.append(x) \n"}
{"sequence_id": "A000169", "text": "Number of labeled rooted trees with n nodes: n^(n-1).", "sequence": "1,2,9,64,625,7776,117649,2097152,43046721,1000000000,25937424601,743008370688,23298085122481,793714773254144,29192926025390625,1152921504606846976,48661191875666868481,2185911559738696531968,104127350297911241532841,5242880000000000000000000", "code": "\ndef a(n): return n**(n-1)\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A000178", "text": "Superfactorials: product of first n factorials.", "sequence": "1,1,2,12,288,34560,24883200,125411328000,5056584744960000,1834933472251084800000,6658606584104736522240000000,265790267296391946810949632000000000,127313963299399416749559771247411200000000000", "code": "\nA000178_list, n, m = [1], 1,1\nfor i in range(1,100):\n    m *= i\n    n *= m\n    A000178_list.append(n) \n"}
{"sequence_id": "A000182", "text": "Tangent (or \"Zag\") numbers: e.g.f. tan(x), also (up to signs) e.g.f. tanh(x).", "sequence": "1,2,16,272,7936,353792,22368256,1903757312,209865342976,29088885112832,4951498053124096,1015423886506852352,246921480190207983616,70251601603943959887872,23119184187809597841473536", "code": " \n\ndef A000182_list(n):\n    T = [0 for i in range(1, n+2)]\n    T[1] = 1\n    for k in range(2, n+1):\n        T[k] = (k-1)*T[k-1]\n    for k in range(2, n+1):\n        for j in range(k, n+1):\n            T[j] = (j-k)*T[j-1]+(j-k+2)*T[j]\n    return T\nprint(A000182_list(100)) \n"}
{"sequence_id": "A000188", "text": "(1) Number of solutions to x^2 == 0 (mod n). (2) Also square root of largest square dividing n. (3) Also max_{ d divides n } gcd(d, n/d).", "sequence": "1,1,1,2,1,1,1,2,3,1,1,2,1,1,1,4,1,3,1,2,1,1,1,2,5,1,3,2,1,1,1,4,1,1,1,6,1,1,1,2,1,1,1,2,3,1,1,4,7,5,1,2,1,3,1,2,1,1,1,2,1,1,3,8,1,1,1,2,1,1,1,6,1,1,5,2,1,1,1,4,9,1,1,2,1,1,1,2,1,3", "code": "\nfrom sympy.ntheory.factor_ import core\nfrom sympy import integer_nthroot\ndef A000188(n): return integer_nthroot(n//core(n),2)[0] \n"}
{"sequence_id": "A000196", "text": "Integer part of square root of n. Or, number of positive squares <= n. Or, n appears 2n+1 times.", "sequence": "0,1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,10,10", "code": "\n\ndef A000196(n):\n  if n < 0:\n    raise ValueError('only defined for nonnegative n')\n  if n == 0:\n    return 0\n  a, b = divmod(n.bit_length(), 2)\n  j = 2**(a+b)\n  while True:\n    k = (j + n//j)//2\n    if k >= j:\n      return j\n    j = k\nprint([A000196(n)for n in range(102)])\n\n"}
{"sequence_id": "A000201", "text": "Lower Wythoff sequence (a Beatty sequence): a(n) = floor(n*phi), where phi = (1+sqrt(5))/2 = A001622.", "sequence": "1,3,4,6,8,9,11,12,14,16,17,19,21,22,24,25,27,29,30,32,33,35,37,38,40,42,43,45,46,48,50,51,53,55,56,58,59,61,63,64,66,67,69,71,72,74,76,77,79,80,82,84,85,87,88,90,92,93,95,97,98,100,101,103,105,106,108,110", "code": "\ndef aupton(terms):\n  alst, aset = [None, 1], {1}\n  for n in range(1, terms):\n    an = alst[n] + (1 if n not in aset else 2)\n    alst.append(an); aset.add(an)\n  return alst[1:]\nprint(aupton(68)) \n"}
{"sequence_id": "A000203", "text": "a(n) = sigma(n), the sum of the divisors of n. Also called sigma_1(n).", "sequence": "1,3,4,7,6,12,8,15,13,18,12,28,14,24,24,31,18,39,20,42,32,36,24,60,31,42,40,56,30,72,32,63,48,54,48,91,38,60,56,90,42,96,44,84,78,72,48,124,57,93,72,98,54,120,72,120,80,90,60,168,62,96,104,127,84,144,68,126,96,144", "code": "\nfrom sympy import divisor_sigma\ndef a(n): return divisor_sigma(n, 1)\nprint([a(n) for n in range(1, 71)]) \n"}
{"sequence_id": "A000213", "text": "Tribonacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) with a(0)=a(1)=a(2)=1.", "sequence": "1,1,1,3,5,9,17,31,57,105,193,355,653,1201,2209,4063,7473,13745,25281,46499,85525,157305,289329,532159,978793,1800281,3311233,6090307,11201821,20603361,37895489,69700671,128199521,235795681,433695873,797691075,1467182629", "code": "\nalst = [1, 1, 1]\n[alst.append(alst[n-1] + alst[n-2] + alst[n-3]) for n in range(3, 37)]\nprint(alst) \n"}
{"sequence_id": "A000215", "text": "Fermat numbers: a(n) = 2^(2^n) + 1.", "sequence": "3,5,17,257,65537,4294967297,18446744073709551617,340282366920938463463374607431768211457,115792089237316195423570985008687907853269984665640564039457584007913129639937", "code": "\ndef a(n): return 2**(2**n) + 1\nprint([a(n) for n in range(9)]) \n"}
{"sequence_id": "A000217", "text": "Triangular numbers: a(n) = binomial(n+1,2) = n*(n+1)/2 = 0 + 1 + 2 + ... + n.", "sequence": "0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276,300,325,351,378,406,435,465,496,528,561,595,630,666,703,741,780,820,861,903,946,990,1035,1081,1128,1176,1225,1275,1326,1378,1431", "code": " for n in range(0,60): print(n*(n+1)/2, end=', ') \n(Python 3) \n\n\n\ndef aList():\n    x, y = 1, 1\n    yield 0\n    while True:\n        yield x\n        x, y = x + y + 1, y + 1\nA000217 = aList()\nprint([next(A000217) for i in range(54)]) \n"}
{"sequence_id": "A000219", "text": "Number of planar partitions (or plane partitions) of n.", "sequence": "1,1,3,6,13,24,48,86,160,282,500,859,1479,2485,4167,6879,11297,18334,29601,47330,75278,118794,186475,290783,451194,696033,1068745,1632658,2483234,3759612,5668963,8512309,12733429,18974973,28175955,41691046,61484961,90379784,132441995,193487501,281846923", "code": "\nfrom sympy import cacheit\nfrom sympy.ntheory import divisor_sigma\n@cacheit\ndef A000219(n):\n    if n <= 1:\n        return 1\n    return sum(A000219(n - k) * divisor_sigma(k, 2) for k in range(1, n + 1)) // n\nprint([A000219(n) for n in range(20)])\n\n"}
{"sequence_id": "A000240", "text": "Rencontres numbers: number of permutations of [n] with exactly one fixed point.", "sequence": "1,0,3,8,45,264,1855,14832,133497,1334960,14684571,176214840,2290792933,32071101048,481066515735,7697064251744,130850092279665,2355301661033952,44750731559645107,895014631192902120,18795307255050944541,413496759611120779880", "code": "\na = 0\nfor i in range(1, 51):\n    a = (a - (-1)**i)*i\n    print(a, end=',') \n"}
{"sequence_id": "A000259", "text": "Number of certain rooted planar maps.", "sequence": "1,3,13,63,326,1761,9808,55895,324301,1908878,11369744,68395917,414927215,2535523154,15592255913,96419104103,599176447614,3739845108057,23435007764606,147374772979438,929790132901804,5883377105975922,37328490926964481,237427707464042693", "code": "\nfrom sympy import binomial, fibonacci\ndef a(n): return sum((-1)**(k - 1)*binomial(3*n, n - k)*k//n*fibonacci(k - 2) for k in range(1, n + 1))\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A000265", "text": "Remove all factors of 2 from n; or largest odd divisor of n; or odd part of n.", "sequence": "1,1,3,1,5,3,7,1,9,5,11,3,13,7,15,1,17,9,19,5,21,11,23,3,25,13,27,7,29,15,31,1,33,17,35,9,37,19,39,5,41,21,43,11,45,23,47,3,49,25,51,13,53,27,55,7,57,29,59,15,61,31,63,1,65,33,67,17,69,35,71,9,73,37,75,19,77", "code": " \nfrom sympy import divisors\ndef a(n):\n    return max(i for i in divisors(n) if i % 2)\n[a(n) for n in range(1, 101)]\n"}
{"sequence_id": "A000265", "text": "Remove all factors of 2 from n; or largest odd divisor of n; or odd part of n.", "sequence": "1,1,3,1,5,3,7,1,9,5,11,3,13,7,15,1,17,9,19,5,21,11,23,3,25,13,27,7,29,15,31,1,33,17,35,9,37,19,39,5,41,21,43,11,45,23,47,3,49,25,51,13,53,27,55,7,57,29,59,15,61,31,63,1,65,33,67,17,69,35,71,9,73,37,75,19,77", "code": "\nfrom __future__ import division\ndef A000265(n):\n    while not n % 2:\n        n //= 2\n    return n \n"}
{"sequence_id": "A000302", "text": "Powers of 4: a(n) = 4^n.", "sequence": "1,4,16,64,256,1024,4096,16384,65536,262144,1048576,4194304,16777216,67108864,268435456,1073741824,4294967296,17179869184,68719476736,274877906944,1099511627776,4398046511104,17592186044416,70368744177664,281474976710656", "code": " print([4**n for n in range(25)]) \n"}
{"sequence_id": "A000321", "text": "H_n(-1/2), where H_n(x) is Hermite polynomial of degree n.", "sequence": "1,-1,-1,5,1,-41,31,461,-895,-6481,22591,107029,-604031,-1964665,17669471,37341149,-567425279,-627491489,19919950975,2669742629,-759627879679,652838174519,31251532771999,-59976412450835,-1377594095061119,4256461892701199,64623242860354751", "code": "\nfrom sympy import hermite\ndef a(n): return hermite(n, -1/2) \n"}
{"sequence_id": "A000330", "text": "Square pyramidal numbers: a(n) = 0^2 + 1^2 + 2^2 + ... + n^2 = n*(n+1)*(2*n+1)/6.", "sequence": "0,1,5,14,30,55,91,140,204,285,385,506,650,819,1015,1240,1496,1785,2109,2470,2870,3311,3795,4324,4900,5525,6201,6930,7714,8555,9455,10416,11440,12529,13685,14910,16206,17575,19019,20540,22140,23821,25585,27434,29370", "code": " a=lambda n: (n*(n+1)*(2*n+1))//6 \n"}
{"sequence_id": "A000337", "text": "a(n) = (n-1)*2^n + 1.", "sequence": "0,1,5,17,49,129,321,769,1793,4097,9217,20481,45057,98305,212993,458753,983041,2097153,4456449,9437185,19922945,41943041,88080385,184549377,385875969,805306369,1677721601,3489660929,7247757313", "code": " a=lambda n:((n-1)<<(n))+1 \n"}
{"sequence_id": "A000367", "text": "Numerators of Bernoulli numbers B_2n.", "sequence": "1,1,-1,1,-1,5,-691,7,-3617,43867,-174611,854513,-236364091,8553103,-23749461029,8615841276005,-7709321041217,2577687858367,-26315271553053477373,2929993913841559,-261082718496449122051", "code": " \n\nfrom fractions import Fraction\ndef A000367_list(n):  \n    T = [0 for i in range(1, n+2)]\n    T[0] = 1; T[1] = 1\n    for k in range(2, n+1):\n        T[k] = (k-1)*T[k-1]\n    for k in range(2, n+1):\n        for j in range(k, n+1):\n            T[j] = (j-k)*T[j-1]+(j-k+2)*T[j]\n    a = 0; b = 6; s = 1\n    for k in range(1, n+1):\n        T[k] = s*Fraction(T[k]*k, b).numerator\n        h = b; b = 20*b - 64*a; a = h; s = -s\n    return T\nprint(A000367_list(100)) \n"}
{"sequence_id": "A000375", "text": "Topswops (1): start by shuffling n cards labeled 1..n. If top card is m, reverse order of top m cards, then repeat. a(n) is the maximal number of steps before top card is 1.", "sequence": "0,1,2,4,7,10,16,22,30,38,51,65,80,101,113,139,159,191,221", "code": "\nfrom itertools import permutations as P\ndef ts(d, var=1): \n  s, m = 0, d[0]\n  while m != 1:\n    d = (d[:m])[::-1] + d[m:]\n    s, m = s+1, d[0]\n  if var==2: return s*(list(d)==sorted(d))\n  return s\ndef a(n):\n  return max(ts(d) for d in P(range(1, n+1)))\nprint([a(n) for n in range(1, 11)]) \n"}
{"sequence_id": "A000376", "text": "Topswops (2): start by shuffling n cards labeled 1..n. If top card is m, reverse order of top m cards. Repeat until 1 gets to top, then stop. Suppose the whole deck is now sorted (if not, discard this case). a(n) is the maximal number of steps before 1 got to the top.", "sequence": "0,1,2,4,7,10,16,22,30,38,51,63,80,101,112,130,159,191,207,231", "code": "\ndef a(n): \n  return max(ts(d, var=2) for d in P(range(1, n+1)))\nprint([a(n) for n in range(1, 11)]) \n"}
{"sequence_id": "A000378", "text": "Sums of three squares: numbers of the form x^2 + y^2 + z^2.", "sequence": "0,1,2,3,4,5,6,8,9,10,11,12,13,14,16,17,18,19,20,21,22,24,25,26,27,29,30,32,33,34,35,36,37,38,40,41,42,43,44,45,46,48,49,50,51,52,53,54,56,57,58,59,61,62,64,65,66,67,68,69,70,72,73,74,75,76,77,78,80,81,82,83", "code": "\ndef valuation(n, b):\n    v = 0\n    while n > 1 and n%b == 0: n //= b; v += 1\n    return v\ndef ok(n): return n//4**valuation(n, 4)%8 != 7\nprint(list(filter(ok, range(84)))) \n"}
{"sequence_id": "A000387", "text": "Rencontres numbers: number of permutations of [n] with exactly two fixed points.", "sequence": "0,0,1,0,6,20,135,924,7420,66744,667485,7342280,88107426,1145396460,16035550531,240533257860,3848532125880,65425046139824,1177650830516985,22375365779822544,447507315596451070,9397653627525472260,206748379805560389951", "code": "\nA145221_list, m, x = [], 1, 0\nfor n in range(201):\n    x, m = x*n + m*(n*(n-1)//2), -m\n    A145221_list.append(x) \n"}
{"sequence_id": "A000408", "text": "Numbers that are the sum of three nonzero squares.", "sequence": "3,6,9,11,12,14,17,18,19,21,22,24,26,27,29,30,33,34,35,36,38,41,42,43,44,45,46,48,49,50,51,53,54,56,57,59,61,62,65,66,67,68,69,70,72,73,74,75,76,77,78,81,82,83,84,86,88,89,90,91,93,94,96,97,98,99,101,102,104", "code": "\ndef aupto(lim):\n  squares = [k*k for k in range(1, int(lim**.5)+2) if k*k <= lim]\n  sum2sqs = set(a+b for i, a in enumerate(squares) for b in squares[i:])\n  sum3sqs = set(a+b for a in sum2sqs for b in squares)\n  return sorted(set(range(lim+1)) & sum3sqs)\nprint(aupto(104)) \n"}
{"sequence_id": "A000414", "text": "Numbers that are the sum of 4 nonzero squares.", "sequence": "4,7,10,12,13,15,16,18,19,20,21,22,23,25,26,27,28,30,31,33,34,35,36,37,38,39,40,42,43,44,45,46,47,48,49,50,51,52,53,54,55,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81", "code": "\nlimit = 10026 \nfrom functools import lru_cache\nnzs = [k*k for k in range(1, int(limit**.5)+2) if k*k + 3 <= limit]\nnzss = set(nzs)\n@lru_cache(maxsize=None)\ndef ok(n, m): return n in nzss if m == 1 else any(ok(n-s, m-1) for s in nzs)\nprint([n for n in range(4, limit+1) if ok(n, 4)]) \n"}
{"sequence_id": "A000419", "text": "Numbers that are the sum of 3 but no fewer nonzero squares.", "sequence": "3,6,11,12,14,19,21,22,24,27,30,33,35,38,42,43,44,46,48,51,54,56,57,59,62,66,67,69,70,75,76,77,78,83,84,86,88,91,93,94,96,99,102,105,107,108,110,114,115,118,120,123,126,129,131,132,133,134,138,139,140,141,142", "code": "\ndef aupto(lim):\n  squares = [k*k for k in range(1, int(lim**.5)+2) if k*k <= lim]\n  sum2sqs = set(a+b for i, a in enumerate(squares) for b in squares[i:])\n  sum3sqs = set(a+b for a in sum2sqs for b in squares)\n  return sorted(set(range(lim+1)) & (sum3sqs - sum2sqs - set(squares)))\nprint(aupto(142)) \n"}
{"sequence_id": "A000439", "text": "Powers of rooted tree enumerator.", "sequence": "9,30,69,133,230,369,560,814,1143,1560,2079,2715,3484,4403,5490,6764,8245,9954,11913,14145,16674,19525,22724,26298,30275,34684,39555,44919,50808,57255,64294,71960,80289,89318,99085,109629,120990,133209,146328,160390,175439,191520,208679", "code": "\ndef a(n): return (n**4 + 18*n**3 + 83*n**2 + 114*n)//24\nprint([a(n) for n in range(1, 44)]) \n"}
{"sequence_id": "A000449", "text": "Rencontres numbers: number of permutations of [n] with exactly 3 fixed points.", "sequence": "1,0,10,40,315,2464,22260,222480,2447445,29369120,381798846,5345183480,80177752655,1282844041920,21808348713320,392550276838944,7458455259940905,149169105198816960,3132551209175157490,68916126601853463240", "code": "\nA000449_list, m, x = [], 1, 0\nfor n in range(3,21):\n    x, m = x*n + m*(n*(n-1)*(n-2)//6), -m\n    A000449_list.append(x) \n"}
{"sequence_id": "A000461", "text": "Concatenate n n times.", "sequence": "1,22,333,4444,55555,666666,7777777,88888888,999999999,10101010101010101010,1111111111111111111111,121212121212121212121212,13131313131313131313131313,1414141414141414141414141414,151515151515151515151515151515,16161616161616161616161616161616", "code": "\ndef a(n): return int(str(n)*n)\nprint([a(n) for n in range(1, 17)]) \n"}
{"sequence_id": "A000468", "text": "Powers of ten written in base 8.", "sequence": "1,12,144,1750,23420,303240,3641100,46113200,575360400,7346545000,112402762000,1351035564000,16432451210000,221411634520000,2657142036440000,34327724461500000,434157115760200000,5432127413542400000,67405553164731000000,1053071060221172000000", "code": "\ndef a(n): return int(oct(10**n)[2:])\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A000475", "text": "Rencontres numbers: number of permutations of [n] with exactly 4 fixed points.", "sequence": "1,0,15,70,630,5544,55650,611820,7342335,95449640,1336295961,20044438050,320711010620,5452087178160,98137569209940,1864613814984984,37292276299704525,783137802293789040,17229031650463366195,396267727960657413630", "code": "\nfrom sympy import binomial\nA000475_list, m, x = [], 1, 0\nfor n in range(4,100):\n    x, m = x*n + m*binomial(n,4), -m\n    A000475_list.append(x) \n"}
{"sequence_id": "A000478", "text": "Number of ways of placing n labeled balls into 3 indistinguishable boxes with at least 2 balls in each box.", "sequence": "15,105,490,1918,6825,22935,74316,235092,731731,2252341,6879678,20900922,63259533,190957923,575363776,1731333808,5205011031,15638101281,46962537810,140988276150,423174543025,1269959836015,3810785476980,11434235478348,34306598748315,102927849307725", "code": " \ndef A000478():\n    a = 15; n = 7; z = 4; s = 15;\n    while True:\n        yield a\n        z = 2*z; s += n*(z-2) + 3; a = 3*a + s; n += 1\na = A000478(); print([next(a) for _ in range(6, 32)]) \n"}
{"sequence_id": "A000523", "text": "a(n) = floor(log_2(n)).", "sequence": "0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6", "code": "\ndef A000523(n):\n    return len(bin(n))-3 \n"}
{"sequence_id": "A000538", "text": "Sum of fourth powers: 0^4 + 1^4 + ... + n^4.", "sequence": "0,1,17,98,354,979,2275,4676,8772,15333,25333,39974,60710,89271,127687,178312,243848,327369,432345,562666,722666,917147,1151403,1431244,1763020,2153645,2610621,3142062,3756718,4463999,5273999,6197520,7246096,8432017,9768353", "code": "\nA000538_list, m = [0], [24, -36, 14, -1, 0, 0]\nfor _ in range(10**2):\n    for i in range(5):\n        m[i+1] += m[i]\n    A000538_list.append(m[-1]) \n"}
{"sequence_id": "A000539", "text": "Sum of 5th powers: 0^5 + 1^5 + 2^5 + ... + n^5.", "sequence": "0,1,33,276,1300,4425,12201,29008,61776,120825,220825,381876,630708,1002001,1539825,2299200,3347776,4767633,6657201,9133300,12333300,16417401,21571033,28007376,35970000,45735625,57617001,71965908,89176276,109687425,133987425", "code": "\nA000539_list, m = [0], [120, -240, 150, -30, 1, 0, 0]\nfor _ in range(10**2):\n    for i in range(6):\n        m[i+1] += m[i]\n    A000539_list.append(m[-1]) \n"}
{"sequence_id": "A000540", "text": "Sum of 6th powers: 0^6 + 1^6 + 2^6 + ... + n^6.", "sequence": "0,1,65,794,4890,20515,67171,184820,446964,978405,1978405,3749966,6735950,11562759,19092295,30482920,47260136,71397705,105409929,152455810,216455810,302221931,415601835,563637724,754740700,998881325,1307797101,1695217590", "code": "\nA000540_list, m = [0], [720, -1800, 1560, -540, 62, -1, 0, 0]\nfor _ in range(10**2):\n    for i in range(7):\n        m[i+1] += m[i]\n    A000540_list.append(m[-1]) \n"}
{"sequence_id": "A000541", "text": "Sum of 7th powers: 1^7 + 2^7 + ... + n^7.", "sequence": "0,1,129,2316,18700,96825,376761,1200304,3297456,8080425,18080425,37567596,73399404,136147921,241561425,412420800,680856256,1091194929,1703414961,2597286700,3877286700,5678375241,8172733129,11577558576,16164030000,22267545625", "code": "\nA000541_list, m = [0], [5040, -15120, 16800, -8400, 1806, -126, 1, 0, 0]\nfor _ in range(10**2):\n    for i in range(8):\n        m[i+1] += m[i]\n    A000541_list.append(m[-1]) \n"}
{"sequence_id": "A000542", "text": "Sum of 8th powers: 1^8 + 2^8 + ... + n^8.", "sequence": "0,1,257,6818,72354,462979,2142595,7907396,24684612,67731333,167731333,382090214,812071910,1627802631,3103591687,5666482312,9961449608,16937207049,27957167625,44940730666,70540730666,108363590027,163239463563,241550448844", "code": "\nA000542_list, m = [0], [40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0]\nfor _ in range(24):\n    for i in range(9):\n        m[i+1] += m[i]\n    A000542_list.append(m[-1])\nprint(A000542_list) \n"}
{"sequence_id": "A000578", "text": "The cubes: a(n) = n^3.", "sequence": "0,1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832,6859,8000,9261,10648,12167,13824,15625,17576,19683,21952,24389,27000,29791,32768,35937,39304,42875,46656,50653,54872,59319,64000", "code": "\nA000578_list, m = [], [6, -6, 1, 0]\nfor _ in range(10**2):\n    A000578_list.append(m[-1])\n    for i in range(3):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A000579", "text": "Figurate numbers or binomial coefficients C(n,6).", "sequence": "0,0,0,0,0,0,1,7,28,84,210,462,924,1716,3003,5005,8008,12376,18564,27132,38760,54264,74613,100947,134596,177100,230230,296010,376740,475020,593775,736281,906192,1107568,1344904,1623160,1947792,2324784,2760681,3262623", "code": "\nA000579_list, m = [], [1, -5, 10, -10, 5, -1, 0]\nfor _ in range(10**2):\n    A000579_list.append(m[-1])\n    for i in range(6):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A000586", "text": "Number of partitions of n into distinct primes.", "sequence": "1,0,1,1,0,2,0,2,1,1,2,1,2,2,2,2,3,2,4,3,4,4,4,5,5,5,6,5,6,7,6,9,7,9,9,9,11,11,11,13,12,14,15,15,17,16,18,19,20,21,23,22,25,26,27,30,29,32,32,35,37,39,40,42,44,45,50,50,53,55,57,61,64,67,70,71,76,78,83,87,89,93,96", "code": "\nfrom sympy import isprime, primerange\nfrom functools import cache\n@cache\ndef a(n, k=None):\n    if k == None: k = n\n    if n < 1: return int(n == 0)\n    return sum(a(n-p, p-1) for p in primerange(1, k+1))\nprint([a(n) for n in range(83)]) \n"}
{"sequence_id": "A000587", "text": "Rao Uppuluri-Carpenter numbers (or complementary Bell numbers): e.g.f. = exp(1 - exp(x)).", "sequence": "1,-1,0,1,1,-2,-9,-9,50,267,413,-2180,-17731,-50533,110176,1966797,9938669,8638718,-278475061,-2540956509,-9816860358,27172288399,725503033401,5592543175252,15823587507881,-168392610536153,-2848115497132448,-20819319685262839", "code": " \n\ndef A000587_list(n):\n    A = [0 for i in range(n)]\n    A[n-1] = 1\n    R = [1]\n    for j in range(0, n):\n        A[n-1-j] = -A[n-1]\n        for k in range(n-j, n):\n            A[k] += A[k-1]\n        R.append(A[n-1])\n    return R\n\n"}
{"sequence_id": "A000587", "text": "Rao Uppuluri-Carpenter numbers (or complementary Bell numbers): e.g.f. = exp(1 - exp(x)).", "sequence": "1,-1,0,1,1,-2,-9,-9,50,267,413,-2180,-17731,-50533,110176,1966797,9938669,8638718,-278475061,-2540956509,-9816860358,27172288399,725503033401,5592543175252,15823587507881,-168392610536153,-2848115497132448,-20819319685262839", "code": "\n\nfrom itertools import accumulate\nA000587, blist, b = [1,-1], [1], -1\nfor _ in range(30):\n    blist = list(accumulate([b]+blist))\n    b = -blist[-1]\n    A000587.append(b) \n"}
{"sequence_id": "A000593", "text": "Sum of odd divisors of n.", "sequence": "1,1,4,1,6,4,8,1,13,6,12,4,14,8,24,1,18,13,20,6,32,12,24,4,31,14,40,8,30,24,32,1,48,18,48,13,38,20,56,6,42,32,44,12,78,24,48,4,57,31,72,14,54,40,72,8,80,30,60,24,62,32,104,1,84,48,68,18,96,48,72,13,74,38,124", "code": "\nfrom math import prod\nfrom sympy import factorint\ndef A000593(n): return prod((p**(e+1)-1)//(p-1) for p, e in factorint(n).items() if p > 2) \n"}
{"sequence_id": "A000606", "text": "Number of nonnegative solutions to x^2 + y^2 + z^2 <= n.", "sequence": "1,4,7,8,11,17,20,20,23,29,35,38,39,45,51,51,54,63,69,72,78,84,87,87,90,99,111,115,115,127,133,133,136,142,151,157,163,169,178,178,184,199,205,208,211,223,229,229,230,239,254,260,266,278,290,290,296", "code": "\nfor n in range(99):\n  k = 0\n  for x in range(99):\n    s = x*x\n    if s > n: break\n    for y in range(99):\n        sy = s + y*y\n        if sy > n: break\n        for z in range(99):\n            sz = sy + z*z\n            if sz > n: break\n            k += 1\n  print(str(k), end=',')\n\n"}
{"sequence_id": "A000607", "text": "Number of partitions of n into prime parts.", "sequence": "1,0,1,1,1,2,2,3,3,4,5,6,7,9,10,12,14,17,19,23,26,30,35,40,46,52,60,67,77,87,98,111,124,140,157,175,197,219,244,272,302,336,372,413,456,504,557,614,677,744,819,899,987,1083,1186,1298,1420,1552,1695,1850,2018,2198,2394,2605,2833,3079,3344", "code": "\nfrom sympy import primefactors\nl = [1, 0]\nfor n in range(2, 101):\n    l.append(sum(sum(primefactors(k)) * l[n - k] for k in range(1, n + 1)) / n)\nl  \n"}
{"sequence_id": "A000668", "text": "Mersenne primes (primes of the form 2^n - 1).", "sequence": "3,7,31,127,8191,131071,524287,2147483647,2305843009213693951,618970019642690137449562111,162259276829213363391578010288127,170141183460469231731687303715884105727", "code": "\nfrom sympy import isprime, primerange\nprint([2**n-1 for n in primerange(1, 1001) if isprime(2**n-1)]) \n"}
{"sequence_id": "A000695", "text": "Moser-de Bruijn sequence: sums of distinct powers of 4.", "sequence": "0,1,4,5,16,17,20,21,64,65,68,69,80,81,84,85,256,257,260,261,272,273,276,277,320,321,324,325,336,337,340,341,1024,1025,1028,1029,1040,1041,1044,1045,1088,1089,1092,1093,1104,1105,1108,1109,1280,1281,1284,1285", "code": "\ndef a(n):\n    n = bin(n)[2:]\n    x = len(n)\n    return sum(int(n[i]) * 4**(x - 1 - i) for i in range(x))\n[a(n) for n in range(101)] \n"}
{"sequence_id": "A000698", "text": "A problem of configurations: a(0) = 1; for n>0, a(n) = (2n-1)!! - Sum_{k=1..n-1} (2k-1)!! a(n-k). Also the number of shellings of an n-cube, divided by 2^n n!.", "sequence": "1,1,2,10,74,706,8162,110410,1708394,29752066,576037442,12277827850,285764591114,7213364729026,196316804255522,5731249477826890,178676789473121834,5925085744543837186,208256802758892355202,7734158085942678174730", "code": "\nfrom sympy import factorial2, cacheit\n@cacheit\ndef a(n): return 1 if n == 0 else factorial2(2*n - 1) - sum(factorial2(2*k - 1)*a(n - k) for k in range(1, n))\n[a(n) for n in range(51)]  \n"}
{"sequence_id": "A000699", "text": "Number of irreducible chord diagrams with 2n nodes.", "sequence": "1,1,1,4,27,248,2830,38232,593859,10401712,202601898,4342263000,101551822350,2573779506192,70282204726396,2057490936366320,64291032462761955,2136017303903513184,75197869250518812754,2796475872605709079512,109549714522464120960474,4509302910783496963256400,194584224274515194731540740", "code": "\ndef A000699_list(n):\n    list = [1, 1] + [0] * (n - 1)\n    for i in range(2, n + 1):\n        list[i] = (i - 1) * sum(list[j] * list[i - j] for j in range(1, i))\n    return list\nprint(A000699_list(22)) \n"}
{"sequence_id": "A000700", "text": "Expansion of Product_{k>=0} (1 + x^(2k+1)); number of partitions of n into distinct odd parts; number of self-conjugate partitions; number of symmetric Ferrers graphs with n nodes.", "sequence": "1,1,0,1,1,1,1,1,2,2,2,2,3,3,3,4,5,5,5,6,7,8,8,9,11,12,12,14,16,17,18,20,23,25,26,29,33,35,37,41,46,49,52,57,63,68,72,78,87,93,98,107,117,125,133,144,157,168,178,192,209,223,236,255,276,294,312,335,361,385", "code": "\nfrom math import prod\nfrom sympy import factorint\ndef A000700(n): return 1 if n== 0 else sum((-1)**(k+1)*A000700(n-k)*prod((p**(e+1)-1)//(p-1) for p, e in factorint(k).items() if p > 2) for k in range(1,n+1))//n \n"}
{"sequence_id": "A000708", "text": "a(n) = E(n+1) - 2*E(n), where E(i) is the Euler number A000111(i).", "sequence": "-1,-1,0,1,6,29,150,841,5166,34649,252750,1995181,16962726,154624469,1505035350,15583997521,171082318686,1985148989489,24279125761950,312193418011861,4210755676649046,59445878286889709,876726137720576550", "code": "\nfrom mpmath import polylog, j, mp\nmp.dps=20\ndef a(n): return -1 if n==0 else int(2*abs(polylog(-n - 1, j)) - 4*abs(polylog(-n, j)))\nprint([a(n) for n in range(23)])  \n"}
{"sequence_id": "A000720", "text": "pi(n), the number of primes <= n. Sometimes called PrimePi(n) to distinguish it from the number 3.14159...", "sequence": "0,1,2,2,3,3,4,4,4,4,5,5,6,6,6,6,7,7,8,8,8,8,9,9,9,9,9,9,10,10,11,11,11,11,11,11,12,12,12,12,13,13,14,14,14,14,15,15,15,15,15,15,16,16,16,16,16,16,17,17,18,18,18,18,18,18,19,19,19,19,20,20,21,21,21,21,21,21", "code": "\nfrom sympy import primepi\nfor n in range(1,100): print(primepi(n), end=', ') \n"}
{"sequence_id": "A000740", "text": "Number of 2n-bead balanced binary necklaces of fundamental period 2n, equivalent to reversed complement; also Dirichlet convolution of b_n=2^(n-1) with mu(n); also number of components of Mandelbrot set corresponding to Julia sets with an attractive n-cycle.", "sequence": "1,1,3,6,15,27,63,120,252,495,1023,2010,4095,8127,16365,32640,65535,130788,262143,523770,1048509,2096127,4194303,8386440,16777200,33550335,67108608,134209530,268435455,536854005,1073741823,2147450880", "code": "\nfrom sympy import mobius, divisors\ndef a(n): return sum([mobius(n / d) * 2**(d - 1) for d in divisors(n)])\n[a(n) for n in range(1, 101)]  \n"}
{"sequence_id": "A000790", "text": "Primary pretenders: least composite c such that n^c == n (mod c).", "sequence": "4,4,341,6,4,4,6,6,4,4,6,10,4,4,14,6,4,4,6,6,4,4,6,22,4,4,9,6,4,4,6,6,4,4,6,9,4,4,38,6,4,4,6,6,4,4,6,46,4,4,10,6,4,4,6,6,4,4,6,15,4,4,9,6,4,4,6,6,4,4,6,9,4,4,15,6,4,4,6,6,4,4,6,21,4,4,10,6,4", "code": "\nfrom sympy import isprime\ndef A000790(n):\n    c = 4\n    while pow(n,c,c) != (n % c) or isprime(c):\n        c += 1\n    return c \n"}
{"sequence_id": "A000796", "text": "Decimal expansion of Pi (or digits of Pi).", "sequence": "3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1,9,7,1,6,9,3,9,9,3,7,5,1,0,5,8,2,0,9,7,4,9,4,4,5,9,2,3,0,7,8,1,6,4,0,6,2,8,6,2,0,8,9,9,8,6,2,8,0,3,4,8,2,5,3,4,2,1,1,7,0,6,7,9,8,2,1,4", "code": " from sympy import pi, N; print(N(pi, 1000)) \n"}
{"sequence_id": "A000799", "text": "a(n) = floor(2^n / n).", "sequence": "2,2,2,4,6,10,18,32,56,102,186,341,630,1170,2184,4096,7710,14563,27594,52428,99864,190650,364722,699050,1342177,2581110,4971026,9586980,18512790,35791394,69273666,134217728,260301048,505290270,981706810,1908874353", "code": " for n in range(1, 40): print(int(2**n / n), end=\", \") \n"}
{"sequence_id": "A000807", "text": "Quadratic invariants.", "sequence": "1,2,14,182,3614,99302,3554894,159175382,8654995454,558786468422,42086200603694,3645412584724022,358877175474325214,39758874175808713382,4915216680878167372814,673139563824188490513302,101475126400695241802946494,16744618803625299734467026182", "code": "\nfrom sympy import binomial, bell\ndef a(n): return sum(binomial(2*n, k)*(-1)**k*bell(k)*bell(2*n - k) for k in range(2*n  + 1))\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A000837", "text": "Number of partitions of n into relatively prime parts. Also aperiodic partitions.", "sequence": "1,1,1,2,3,6,7,14,17,27,34,55,63,100,119,167,209,296,347,489,582,775,945,1254,1481,1951,2334,2980,3580,4564,5386,6841,8118,10085,12012,14862,17526,21636,25524,31082,36694,44582,52255,63260,74170,88931,104302", "code": "\nfrom sympy import npartitions, mobius, divisors\ndef a(n): return 1 if n==0 else sum(mobius(n//d)*npartitions(d) for d in divisors(n)) \n"}
{"sequence_id": "A000928", "text": "Irregular primes: primes p such that at least one of the numerators of the Bernoulli numbers B_2, B_4, ..., B_{p-3} (A000367) is divisible by p.", "sequence": "37,59,67,101,103,131,149,157,233,257,263,271,283,293,307,311,347,353,379,389,401,409,421,433,461,463,467,491,523,541,547,557,577,587,593,607,613,617,619,631,647,653,659,673,677,683,691,727,751,757,761,773,797,809,811,821,827,839,877,881,887,929,953,971,1061", "code": "\nfrom sympy import bernoulli, primerange\ndef ok(n):\n    k = 1\n    while 2*k <= n - 3 and bernoulli(2*k).numerator() % n:\n        k+=1\n    return 2*k <= n - 3\nprint([n for n in primerange(2, 1101) if ok(n)]) \n"}
{"sequence_id": "A000958", "text": "Number of ordered rooted trees with n edges having root of odd degree.", "sequence": "1,1,3,8,24,75,243,808,2742,9458,33062,116868,417022,1500159,5434563,19808976,72596742,267343374,988779258,3671302176,13679542632,51134644014,191703766638,720629997168,2715610275804,10256844598900,38822029694628,147229736485868", "code": "\nfrom itertools import accumulate\ndef A000958_list(size):\n    if size < 1: return []\n    L, accu = [], [1]\n    for n in range(size-1):\n        accu = list(accumulate(accu+[-accu[-1]]))\n        L.append(accu[n])\n    return L\nprint(A000958_list(29)) \n"}
{"sequence_id": "A000959", "text": "Lucky numbers.", "sequence": "1,3,7,9,13,15,21,25,31,33,37,43,49,51,63,67,69,73,75,79,87,93,99,105,111,115,127,129,133,135,141,151,159,163,169,171,189,193,195,201,205,211,219,223,231,235,237,241,259,261,267,273,283,285,289,297,303", "code": "\ndef lucky(n):\n    L = list(range(1, n + 1, 2))\n    j = 1\n    Lj = 2\n    while j <= len(L) - 1 and L[j] <= len(L):\n        L = [Li for i, Li in enumerate(L) if (i + 1) % L[j]]\n        j += 1\n    return L\n\n"}
{"sequence_id": "A000960", "text": "Flavius Josephus's sieve: Start with the natural numbers; at the k-th sieving step, remove every (k+1)-st term of the sequence remaining after the (k-1)-st sieving step; iterate.", "sequence": "1,3,7,13,19,27,39,49,63,79,91,109,133,147,181,207,223,253,289,307,349,387,399,459,481,529,567,613,649,709,763,807,843,927,949,1009,1093,1111,1189,1261,1321,1359,1471,1483,1579,1693,1719,1807,1899,1933,2023", "code": "\ndef flavius(n):\n    L = list(range(1,n+1));j=2\n    while j <= len(L):\n        L = [L[i] for i in range(len(L)) if (i+1)%j]\n        j+=1\n    return L\nflavius(100)\n\n"}
{"sequence_id": "A000961", "text": "Powers of primes. Alternatively, 1 and the prime powers (p^k, p prime, k >= 1).", "sequence": "1,2,3,4,5,7,8,9,11,13,16,17,19,23,25,27,29,31,32,37,41,43,47,49,53,59,61,64,67,71,73,79,81,83,89,97,101,103,107,109,113,121,125,127,128,131,137,139,149,151,157,163,167,169,173,179,181,191,193,197,199,211,223,227", "code": "\nfrom sympy import primerange\nA000961_list = [1]\nfor p in primerange(1, m):\n    pe = p\n    while pe < m:\n        A000961_list.append(pe)\n        pe *= p\nA000961_list = sorted(A000961_list) \n"}
{"sequence_id": "A000968", "text": "Sum of odd Fermat coefficients rounded to nearest integer.", "sequence": "1,1,2,4,9,20,46,105,246,583,1393,3355,8133,19825,48554,119412,294761,729980,1813107,4515225,11271198,28196896,70679137,177487714,446446560,1124706145,2837445500,7167878628,18129622761,45907772900,116372614251", "code": "\nfrom sympy import binomial\ndef F(n,c): return binomial(2*n - c, c - 1)/c\nprint([int(round(sum([F(n, 2*r + 1) for r in range(n//2 + 1)]))) for n in range(1, 41)]) \n"}
{"sequence_id": "A000978", "text": "Wagstaff numbers: numbers k such that (2^k + 1)/3 is prime.", "sequence": "3,5,7,11,13,17,19,23,31,43,61,79,101,127,167,191,199,313,347,701,1709,2617,3539,5807,10501,10691,11279,12391,14479,42737,83339,95369,117239,127031,138937,141079,267017,269987,374321,986191,4031399", "code": "\nfrom gmpy2 import divexact\nfrom sympy import prime, isprime\nA000978 = [p for p in (prime(n) for n in range(2,10**2)) if isprime(divexact(2**p+1,3))] \n"}
{"sequence_id": "A000979", "text": "Wagstaff primes: primes of form (2^p + 1)/3.", "sequence": "3,11,43,683,2731,43691,174763,2796203,715827883,2932031007403,768614336404564651,201487636602438195784363,845100400152152934331135470251,56713727820156410577229101238628035243,62357403192785191176690552862561408838653121833643", "code": "\nfrom gmpy2 import divexact\nfrom sympy import prime, isprime\nA000979 = [p for p in (divexact(2**prime(n)+1,3) for n in range(2,10**2)) if isprime(p)] \n"}
{"sequence_id": "A000984", "text": "Central binomial coefficients: binomial(2*n,n) = (2*n)!/(n!)^2.", "sequence": "1,2,6,20,70,252,924,3432,12870,48620,184756,705432,2704156,10400600,40116600,155117520,601080390,2333606220,9075135300,35345263800,137846528820,538257874440,2104098963720,8233430727600,32247603683100,126410606437752,495918532948104,1946939425648112", "code": "\nfrom __future__ import division\nA000984_list, b = [1], 1\nfor n in range(10**3):\n    b = b*(4*n+2)//(n+1)\n    A000984_list.append(b) \n"}
{"sequence_id": "A001003", "text": "Schroeder's second problem (generalized parentheses); also called super-Catalan numbers or little Schroeder numbers.", "sequence": "1,1,3,11,45,197,903,4279,20793,103049,518859,2646723,13648869,71039373,372693519,1968801519,10463578353,55909013009,300159426963,1618362158587,8759309660445,47574827600981,259215937709463,1416461675464871", "code": " \n\ndef A001003_list(n):\n    a = [0 for i in range(n)]\n    a[0] = 1\n    for w in range(1, n):\n        s = 0\n        for j in range(1, w):\n            s += a[j]*a[w-j-1]\n        a[w] = a[w-1]+2*s\n    return a\n\n"}
{"sequence_id": "A001003", "text": "Schroeder's second problem (generalized parentheses); also called super-Catalan numbers or little Schroeder numbers.", "sequence": "1,1,3,11,45,197,903,4279,20793,103049,518859,2646723,13648869,71039373,372693519,1968801519,10463578353,55909013009,300159426963,1618362158587,8759309660445,47574827600981,259215937709463,1416461675464871", "code": "\nfrom gmpy2 import divexact\nA001003 = [1, 1]\nfor n in range(3,10**3):\n    A001003.append(divexact(A001003[-1]*(6*n-9)-(n-3)*A001003[-2],n))\n\n"}
{"sequence_id": "A001006", "text": "Motzkin numbers: number of ways of drawing any number of nonintersecting chords joining n (labeled) points on a circle.", "sequence": "1,1,2,4,9,21,51,127,323,835,2188,5798,15511,41835,113634,310572,853467,2356779,6536382,18199284,50852019,142547559,400763223,1129760415,3192727797,9043402501,25669818476,73007772802,208023278209,593742784829", "code": "\nfrom gmpy2 import divexact\nA001006 = [1, 1]\nfor n in range(2, 10**3):\n    A001006.append(divexact(A001006[-1]*(2*n+1)+(3*n-3)*A001006[-2],n+2))\n\n(Sage and Python)\ndef mot():\n    a, b, n = 0, 1, 1\n    while True:\n        yield b//n\n        n += 1\n        a, b = b, (3*(n-1)*n*a+(2*n-1)*n*b)//((n+1)*(n-1))\nA001006 = mot()\nprint([next(A001006) for n in range(30)]) \n"}
{"sequence_id": "A001008", "text": "Numerators of harmonic numbers H(n) = Sum_{i=1..n} 1/i.", "sequence": "1,3,11,25,137,49,363,761,7129,7381,83711,86021,1145993,1171733,1195757,2436559,42142223,14274301,275295799,55835135,18858053,19093197,444316699,1347822955,34052522467,34395742267,312536252003,315404588903,9227046511387", "code": "\nfrom sympy import Integer\n[sum(1/Integer(i) for i in range(1, n + 1)).numerator() for n in range(1, 31)]  \n"}
{"sequence_id": "A001013", "text": "Jordan-Polya numbers: products of factorial numbers A000142.", "sequence": "1,2,4,6,8,12,16,24,32,36,48,64,72,96,120,128,144,192,216,240,256,288,384,432,480,512,576,720,768,864,960,1024,1152,1296,1440,1536,1728,1920,2048,2304,2592,2880,3072,3456,3840,4096,4320,4608,5040,5184,5760", "code": "\ndef aupto(lim, mx=None):\n    if lim < 2: return [1]\n    v, t = [1], 1\n    if mx == None: mx = lim\n    for k in range(2, mx+1):\n        t *= k\n        if t > lim: break\n        v += [t*rest for rest in aupto(lim//t, t)]\n    return sorted(set(v))\nprint(aupto(5760)) \n"}
{"sequence_id": "A001023", "text": "Powers of 14.", "sequence": "1,14,196,2744,38416,537824,7529536,105413504,1475789056,20661046784,289254654976,4049565169664,56693912375296,793714773254144,11112006825558016,155568095557812224,2177953337809371136,30491346729331195904,426878854210636742656,5976303958948914397184,83668255425284801560576", "code": " print([14**n for n in range(21)]) \n"}
{"sequence_id": "A001025", "text": "Powers of 16: a(n) = 16^n.", "sequence": "1,16,256,4096,65536,1048576,16777216,268435456,4294967296,68719476736,1099511627776,17592186044416,281474976710656,4503599627370496,72057594037927936,1152921504606846976,18446744073709551616,295147905179352825856,4722366482869645213696,75557863725914323419136,1208925819614629174706176", "code": " print([16**n for n in range(20)]) \n"}
{"sequence_id": "A001037", "text": "Number of degree-n irreducible polynomials over GF(2); number of n-bead necklaces with beads of 2 colors when turning over is not allowed and with primitive period n; number of binary Lyndon words of length n.", "sequence": "1,2,1,2,3,6,9,18,30,56,99,186,335,630,1161,2182,4080,7710,14532,27594,52377,99858,190557,364722,698870,1342176,2580795,4971008,9586395,18512790,35790267,69273666,134215680,260300986,505286415,981706806,1908866960,3714566310,7233615333,14096302710,27487764474", "code": "\nfrom sympy import divisors, mobius\ndef a(n): return sum(mobius(d) * 2**(n//d) for d in divisors(n))/n if n>1 else n + 1 \n"}
{"sequence_id": "A001044", "text": "a(n) = (n!)^2.", "sequence": "1,1,4,36,576,14400,518400,25401600,1625702400,131681894400,13168189440000,1593350922240000,229442532802560000,38775788043632640000,7600054456551997440000,1710012252724199424000000,437763136697395052544000000,126513546505547170185216000000", "code": " import math\nfor n in range(0,20): print(math.factorial(n)**2, end=', ') \n"}
{"sequence_id": "A001045", "text": "Jacobsthal sequence (or Jacobsthal numbers): a(n) = a(n-1) + 2*a(n-2), with a(0) = 0, a(1) = 1; also a(n) = nearest integer to 2^n/3.", "sequence": "0,1,1,3,5,11,21,43,85,171,341,683,1365,2731,5461,10923,21845,43691,87381,174763,349525,699051,1398101,2796203,5592405,11184811,22369621,44739243,89478485,178956971,357913941,715827883,1431655765,2863311531,5726623061", "code": " \ndef A001045():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, b+2*a\nsequence = A001045()\n[next(sequence) for i in range(20)] \n"}
{"sequence_id": "A001047", "text": "a(n) = 3^n - 2^n.", "sequence": "0,1,5,19,65,211,665,2059,6305,19171,58025,175099,527345,1586131,4766585,14316139,42981185,129009091,387158345,1161737179,3485735825,10458256051,31376865305,94134790219,282412759265,847255055011,2541798719465,7625463267259,22876524019505", "code": " [3**n - 2**n for n in range(25)] \n"}
{"sequence_id": "A001055", "text": "The multiplicative partition function: number of ways of factoring n with all factors greater than 1 (a(1) = 1 by convention).", "sequence": "1,1,1,2,1,2,1,3,2,2,1,4,1,2,2,5,1,4,1,4,2,2,1,7,2,2,3,4,1,5,1,7,2,2,2,9,1,2,2,7,1,5,1,4,4,2,1,12,2,4,2,4,1,7,2,7,2,2,1,11,1,2,4,11,2,5,1,4,2,5,1,16,1,2,4,4,2,5,1,12,5,2,1,11,2,2,2,7,1,11,2,4,2,2,2,19,1,4,4,9,1,5,1", "code": "\nfrom sympy import divisors, isprime\ndef T(n, m):\n    if isprime(n): return 1 if n<=m else 0\n    A=filter(lambda d: d<=m, divisors(n)[1:-1])\n    s=sum(T(n//d, d) for d in A)\n    return s + 1 if n<=m else s\ndef a(n): return T(n, n)\nprint([a(n) for n in range(1, 106)]) \n"}
{"sequence_id": "A001101", "text": "Moran numbers: n such that (n / sum of digits of n) is prime.", "sequence": "18,21,27,42,45,63,84,111,114,117,133,152,153,156,171,190,195,198,201,207,209,222,228,247,261,266,285,333,370,372,399,402,407,423,444,465,481,511,516,518,531,555,558,592,603", "code": "\n\n\nimport csv\nwith open(\"primes1.txt\",\"r\") as f:\n....reader = csv.reader(f, delimiter=\" \")\n....primes = set([int(rows[1]) for rows in reader])\ni, n = 1, 1\nwith open(\"b001101.txt\",\"w\") as f:\n....while i <= 10000:\n........if n % sum(map(int, str(n))) == 0 and n/sum(map(int, str(n))) in primes:\n............f.write(\"{} {}\\n\".format(i, n))\n............i += 1\n........n += 1\n\n"}
{"sequence_id": "A001107", "text": "10-gonal (or decagonal) numbers: a(n) = n*(4*n-3).", "sequence": "0,1,10,27,52,85,126,175,232,297,370,451,540,637,742,855,976,1105,1242,1387,1540,1701,1870,2047,2232,2425,2626,2835,3052,3277,3510,3751,4000,4257,4522,4795,5076,5365,5662,5967,6280,6601,6930,7267,7612,7965,8326", "code": " a=lambda n: 4*n**2-3*n \ndef aList(): \n     x, y = 1, 1\n     yield 0\n     while True:\n         yield x\n         x, y = x + y + 8, y + 8\nA001107 = aList()\nprint([next(A001107) for i in range(49)]) \n"}
{"sequence_id": "A001114", "text": "Increasing blocks of digits of e.", "sequence": "2,7,18,28,182,845,904,5235,36028,74713,526624,977572,4709369,9959574,96696762,7724076630,35354759457,138217852516,642742746639,1932003059921,8174135966290,43572900334295,260595630738132,328627943490763,2338298807531952,5101901157383418", "code": "\nfrom sympy import E\ndef aupto(digit_limit):\n  alst, estr = [], str(E.n(digit_limit)).replace(\".\", \"\")\n  prevlen, prevstr, suffix = 0, \"\", estr\n  while len(suffix) > prevlen + 1:\n    if suffix[:prevlen] > prevstr: idx = prevlen\n    else: idx = prevlen + 1\n    while suffix[idx] == '0':\n      idx += 1\n      if idx > len(suffix): break \n    anstr, suffix = suffix[:idx], suffix[idx:]\n    prevstr, prevlen = anstr, len(anstr)\n    assert anstr[0] != '0'\n    alst.append(int(anstr))\n  return alst\nprint(aupto(220)) \n"}
{"sequence_id": "A001128", "text": "Reverse digits of previous term and multiply by previous term.", "sequence": "2,4,16,976,662704,269896807264,124883600543123110859968,108643488775144622666209173128243503963147630528", "code": " def a(n): return 2 if n<2 else a(n - 1) * int(str(a(n - 1))[::-1]) \n"}
{"sequence_id": "A001129", "text": "Iccanobif numbers: reverse digits of two previous terms and add.", "sequence": "0,1,1,2,3,5,8,13,39,124,514,836,1053,4139,12815,61135,104937,792517,1454698,9679838,17354310,9735140,1760750,986050,621360,113815,581437,1252496,7676706,13019288,94367798,178067380,173537220,106496242,265429972,522619163", "code": "\nA001129_list, r1, r2 = [0,1], 1, 0\nfor _ in range(10**2):\n    l, r2 = r1+r2, r1\n    r1 = int(str(l)[::-1])\n    A001129_list.append(l) \n"}
{"sequence_id": "A001147", "text": "Double factorial of odd numbers: a(n) = (2*n-1)!! = 1*3*5*...*(2*n-1).", "sequence": "1,1,3,15,105,945,10395,135135,2027025,34459425,654729075,13749310575,316234143225,7905853580625,213458046676875,6190283353629375,191898783962510625,6332659870762850625,221643095476699771875,8200794532637891559375", "code": "\nfrom sympy import factorial2\ndef a(n): return factorial2(2 * n - 1)\nprint([a(n) for n in range(101)])  \n"}
{"sequence_id": "A001157", "text": "sigma_2(n): sum of squares of divisors of n.", "sequence": "1,5,10,21,26,50,50,85,91,130,122,210,170,250,260,341,290,455,362,546,500,610,530,850,651,850,820,1050,842,1300,962,1365,1220,1450,1300,1911,1370,1810,1700,2210,1682,2500,1850,2562,2366,2650,2210,3410,2451,3255", "code": "\nfrom sympy import divisor_sigma\ndef a(n): return divisor_sigma(n, 2)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A001158", "text": "sigma_3(n): sum of cubes of divisors of n.", "sequence": "1,9,28,73,126,252,344,585,757,1134,1332,2044,2198,3096,3528,4681,4914,6813,6860,9198,9632,11988,12168,16380,15751,19782,20440,25112,24390,31752,29792,37449,37296,44226,43344,55261,50654,61740,61544,73710,68922,86688", "code": "\nfrom sympy import divisor_sigma\ndef a(n): return divisor_sigma(n, 3)\nprint([a(n) for n in range(1, 43)]) \n"}
{"sequence_id": "A001175", "text": "Pisano periods (or Pisano numbers): period of Fibonacci numbers mod n.", "sequence": "1,3,8,6,20,24,16,12,24,60,10,24,28,48,40,24,36,24,18,60,16,30,48,24,100,84,72,48,14,120,30,48,40,36,80,24,76,18,56,60,40,48,88,30,120,48,32,24,112,300,72,84,108,72,20,48,72,42,58,120,60,30,48,96,140,120,136", "code": "\nfrom functools import reduce\nfrom sympy import factorint, lcm\ndef A001175(n):\n    if n == 1:\n        return 1\n    f = factorint(n)\n    if len(f) > 1:\n        return reduce(lcm, (A001175(a**f[a]) for a in f))\n    else:\n        k,x = 1, [1,1]\n        while x != [0,1]:\n            k += 1\n            x = [x[1], (x[0]+x[1]) % n]\n        return k \n"}
{"sequence_id": "A001181", "text": "Number of Baxter permutations of length n (also called Baxter numbers).", "sequence": "1,1,2,6,22,92,422,2074,10754,58202,326240,1882960,11140560,67329992,414499438,2593341586,16458756586,105791986682,687782586844,4517543071924,29949238543316,200234184620736,1349097425104912,9154276618636016,62522506583844272", "code": "\nfrom sympy import binomial as C\ndef a(n): return sum([(C(n + 1, k - 1)*C(n + 1, k)*C(n + 1, k + 1))/(C(n + 1, 1) * C(n + 1, 2)) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A001196", "text": "Double-bitters: only even length runs in binary expansion.", "sequence": "0,3,12,15,48,51,60,63,192,195,204,207,240,243,252,255,768,771,780,783,816,819,828,831,960,963,972,975,1008,1011,1020,1023,3072,3075,3084,3087,3120,3123,3132,3135,3264,3267,3276,3279,3312", "code": "\ndef inA001196(n):\n    while n != 0:\n        if n%4 == 1 or n%4 == 2:\n            return 0\n        n = n//4\n    return 1\nn, a = 0, 0\nwhile n < 20:\n    if inA001196(a):\n        print(n,a)\n        n = n+1\n    a = a+1 \n"}
{"sequence_id": "A001196", "text": "Double-bitters: only even length runs in binary expansion.", "sequence": "0,3,12,15,48,51,60,63,192,195,204,207,240,243,252,255,768,771,780,783,816,819,828,831,960,963,972,975,1008,1011,1020,1023,3072,3075,3084,3087,3120,3123,3132,3135,3264,3267,3276,3279,3312", "code": "\nfrom itertools import groupby\ndef ok2lb(n):\n  if n == 0: return True  \n  return all(len(list(g))%2 == 0 for k, g in groupby(bin(n)[2:]))\nprint([i for i in range(3313) if ok2lb(i)]) \n"}
{"sequence_id": "A001220", "text": "Wieferich primes: primes p such that p^2 divides 2^(p-1) - 1.", "sequence": "1093,3511", "code": "\nfrom sympy import prime\nfrom gmpy2 import powmod\nA001220_list = [p for p in (prime(n) for n in range(1,10**7)) if powmod(2,p-1,p*p) == 1]\n\n"}
{"sequence_id": "A001221", "text": "Number of distinct primes dividing n (also called omega(n)).", "sequence": "0,1,1,1,1,2,1,1,1,2,1,2,1,2,2,1,1,2,1,2,2,2,1,2,1,2,1,2,1,3,1,1,2,2,2,2,1,2,2,2,1,3,1,2,2,2,1,2,1,2,2,2,1,2,2,2,2,2,1,3,1,2,2,1,2,3,1,2,2,3,1,2,1,2,2,2,2,3,1,2,1,2,1,3,2,2,2,2,1,3,2,2,2,2,2,2,1,2,2,2,1,3,1,2,3,2,1,2,1,3,2", "code": "\nfrom sympy.ntheory import primefactors\nprint([len(primefactors(n)) for n in range(1, 1001)])  \n"}
{"sequence_id": "A001254", "text": "Squares of Lucas numbers.", "sequence": "4,1,9,16,49,121,324,841,2209,5776,15129,39601,103684,271441,710649,1860496,4870849,12752041,33385284,87403801,228826129,599074576,1568397609,4106118241,10749957124,28143753121,73681302249,192900153616,505019158609,1322157322201,3461452808004,9062201101801,23725150497409", "code": "\nfrom sympy import lucas\ndef a(n):  return lucas(n)**2\nprint([a(n) for n in range(33)]) \n"}
{"sequence_id": "A001286", "text": "Lah numbers: (n-1)*n!/2.", "sequence": "1,6,36,240,1800,15120,141120,1451520,16329600,199584000,2634508800,37362124800,566658892800,9153720576000,156920924160000,2845499424768000,54420176498688000,1094805903679488000,23112569077678080000", "code": "\nfrom __future__ import division\nA001286_list = [1]\nfor n in range(2,100):\n    A001286_list.append(A001286_list[-1]*n*(n+1)//(n-1)) \n"}
{"sequence_id": "A001287", "text": "a(n) = binomial coefficient C(n,10).", "sequence": "1,11,66,286,1001,3003,8008,19448,43758,92378,184756,352716,646646,1144066,1961256,3268760,5311735,8436285,13123110,20030010,30045015,44352165,64512240,92561040,131128140,183579396,254186856,348330136,472733756,635745396", "code": "\nA001287_list, m = [], [1]*11\nfor _ in range(10**2):\n    A001287_list.append(m[-1])\n    for i in range(10):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A001316", "text": "Gould's sequence: a(n) = Sum_{k=0..n} (binomial(n,k) mod 2); number of odd entries in row n of Pascal's triangle (A007318); a(n) = 2^A000120(n).", "sequence": "1,2,2,4,2,4,4,8,2,4,4,8,4,8,8,16,2,4,4,8,4,8,8,16,4,8,8,16,8,16,16,32,2,4,4,8,4,8,8,16,4,8,8,16,8,16,16,32,4,8,8,16,8,16,16,32,8,16,16,32,16,32,32,64,2,4,4,8,4,8,8,16,4,8,8,16,8,16,16,32,4,8,8,16,8,16,16,32", "code": "\ndef A001316(n):\n    return 2**bin(n)[2:].count(\"1\") \n"}
{"sequence_id": "A001317", "text": "Sierpi\u0144ski's triangle (Pascal's triangle mod 2) converted to decimal.", "sequence": "1,3,5,15,17,51,85,255,257,771,1285,3855,4369,13107,21845,65535,65537,196611,327685,983055,1114129,3342387,5570645,16711935,16843009,50529027,84215045,252645135,286331153,858993459,1431655765,4294967295,4294967297,12884901891,21474836485,64424509455,73014444049,219043332147,365072220245,1095216660735,1103806595329,3311419785987", "code": "\nfrom sympy import binomial\ndef a(n): return sum([(binomial(n, i)%2)*2**i for i in range(n + 1)]) \n"}
{"sequence_id": "A001334", "text": "Number of n-step self-avoiding walks on hexagonal [ =triangular ] lattice.", "sequence": "1,6,30,138,618,2730,11946,51882,224130,964134,4133166,17668938,75355206,320734686,1362791250,5781765582,24497330322,103673967882,438296739594,1851231376374,7812439620678,32944292555934,138825972053046", "code": "\ndef add(L,x):\n    M=[y for y in L];M.append(x)\n    return(M)\nplus=lambda L,M : [x+y for x,y in zip(L,M)]\nmo=[[2,0],[-1,1],[-1, -1],[-2,0],[1,-1],[1, 1]]\ndef a(n,P=[[0, 0]]):\n    if n==0: return(1)\n    mv1 = [plus(P[-1],x) for x in mo]\n    mv2=[x for x in mv1 if x not in P]\n    if n==1: return(len(mv2))\n    else: return(sum(a(n-1,add(P,x)) for x in mv2))\n[a(n) for n in range(11)]\n\n"}
{"sequence_id": "A001359", "text": "Lesser of twin primes.", "sequence": "3,5,11,17,29,41,59,71,101,107,137,149,179,191,197,227,239,269,281,311,347,419,431,461,521,569,599,617,641,659,809,821,827,857,881,1019,1031,1049,1061,1091,1151,1229,1277,1289,1301,1319,1427,1451,1481,1487,1607", "code": "\nfrom sympy import primerange, isprime\nprint([n for n in primerange(1, 2001) if isprime(n + 2)]) \n"}
{"sequence_id": "A001370", "text": "Sum of digits of 2^n.", "sequence": "1,2,4,8,7,5,10,11,13,8,7,14,19,20,22,26,25,14,19,29,31,26,25,41,37,29,40,35,43,41,37,47,58,62,61,59,64,56,67,71,61,50,46,56,58,62,70,68,73,65,76,80,79,77,82,92,85,80,70,77", "code": " [sum(map(int, str(2**n))) for n in range(56)] \n"}
{"sequence_id": "A001371", "text": "Number of n-bead necklaces with beads of 2 colors and primitive period n, when turning over is allowed.", "sequence": "1,2,1,2,3,6,8,16,24,42,69,124,208,378,668,1214,2220,4110,7630,14308,26931,50944,96782,184408,352450,675180,1296477,2493680,4805388,9272778,17919558,34669600,67156800,130215996,252741255,490984464,954629662,1857545298", "code": "\nfrom sympy import divisors, totient, mobius\ndef a000029(n):\n    return 1 if n<1 else ((2**(n//2+1) if n%2 else 3*2**(n//2-1)) + sum(totient(n//d)*2**d for d in divisors(n))//n)//2\ndef a(n):\n    return 1 if n<1 else sum(mobius(d)*a000029(n//d) for d in divisors(n))\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A001411", "text": "Number of n-step self-avoiding walks on square lattice.", "sequence": "1,4,12,36,100,284,780,2172,5916,16268,44100,120292,324932,881500,2374444,6416596,17245332,46466676,124658732,335116620,897697164,2408806028,6444560484,17266613812,46146397316,123481354908,329712786220,881317491628", "code": "\ndef add(L,x):\n    M=[y for y in L];M.append(x)\n    return(M)\nplus=lambda L,M : [x+y for x,y in zip(L,M)]\nmo=[[1,0],[0,1],[-1,0],[0,-1]]\ndef a(n,P=[[0,0]]):\n    if n==0: return(1)\n    mv1=[plus(P[-1],x) for x in mo]\n    mv2=[x for x in mv1 if x not in P]\n    if n==1: return(len(mv2))\n    else: return(sum(a(n-1,add(P,x)) for x in mv2))\n[a(n) for n in range(11)]\n\n"}
{"sequence_id": "A001412", "text": "Number of n-step self-avoiding walks on cubic lattice.", "sequence": "1,6,30,150,726,3534,16926,81390,387966,1853886,8809878,41934150,198842742,943974510,4468911678,21175146054,100121875974,473730252102,2237723684094,10576033219614,49917327838734,235710090502158,1111781983442406,5245988215191414,24730180885580790,116618841700433358,549493796867100942,2589874864863200574,12198184788179866902,57466913094951837030,270569905525454674614", "code": "\ndef add(L,x):\n    M=[y for y in L];M.append(x)\n    return(M)\nplus=lambda L,M : [x+y for x,y in zip(L,M)]\nmo=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]]\ndef a(n,P=[[0,0,0]]):\n    if n==0: return(1)\n    mv1 = [plus(P[-1],x) for x in mo]\n    mv2=[x for x in mv1 if x not in P]\n    if n==1: return(len(mv2))\n    else: return(sum(a(n-1,add(P,x)) for x in mv2))\n[a(n) for n in range(8)]\n\n"}
{"sequence_id": "A001414", "text": "Integer log of n: sum of primes dividing n (with repetition). Also called sopfr(n).", "sequence": "0,2,3,4,5,5,7,6,6,7,11,7,13,9,8,8,17,8,19,9,10,13,23,9,10,15,9,11,29,10,31,10,14,19,12,10,37,21,16,11,41,12,43,15,11,25,47,11,14,12,20,17,53,11,16,13,22,31,59,12,61,33,13,12,18,16,67,21,26,14,71,12,73,39,13,23,18,18", "code": "\nfrom sympy import factorint\ndef A001414(n):\n    return sum(p*e for p,e in factorint(n).items()) \n"}
{"sequence_id": "A001462", "text": "Golomb's sequence: a(n) is the number of times n occurs, starting with a(1) = 1.", "sequence": "1,2,2,3,3,4,4,4,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,9,10,10,10,10,10,11,11,11,11,11,12,12,12,12,12,12,13,13,13,13,13,13,14,14,14,14,14,14,15,15,15,15,15,15,16,16,16,16,16,16,16,17,17,17,17,17,17,17,18,18,18,18,18,18,18,19", "code": "\na=[0, 1, 2, 2]\nfor n in range(3, 21):a+=[n for i in range(1, a[n] + 1)]\na[1:] \n"}
{"sequence_id": "A001511", "text": "The ruler function: 2^a(n) divides 2n. Or, a(n) = 2-adic valuation of 2n.", "sequence": "1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,7,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2,1,4,1", "code": "\ndef a(n): return bin(n)[2:][::-1].index(\"1\") + 1 \n"}
{"sequence_id": "A001511", "text": "The ruler function: 2^a(n) divides 2n. Or, a(n) = 2-adic valuation of 2n.", "sequence": "1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,7,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2,1,4,1", "code": " A001511 = lambda n: (n&-n).bit_length() \n"}
{"sequence_id": "A001523", "text": "Number of stacks, or planar partitions of n; also weakly unimodal compositions of n.", "sequence": "1,1,2,4,8,15,27,47,79,130,209,330,512,784,1183,1765,2604,3804,5504,7898,11240,15880,22277,31048,43003,59220,81098,110484,149769,202070,271404,362974,483439,641368,847681,1116325,1464999,1916184,2498258", "code": "\ndef b(n, i):\n    if i>n: return 0\n    if n%i==0: x=1\n    else: x=0\n    return x + sum([b(n - i*j, i + 1)*(j + 1) for j in range(n//i + 1)])\ndef a(n): return 1 if n==0 else b(n, 1) \n"}
{"sequence_id": "A001542", "text": "a(n) = 6*a(n-1) - a(n-2) for n > 1, a(0)=0 and a(1)=2.", "sequence": "0,2,12,70,408,2378,13860,80782,470832,2744210,15994428,93222358,543339720,3166815962,18457556052,107578520350,627013566048,3654502875938,21300003689580,124145519261542,723573111879672", "code": "\nl=[0, 2]\nfor n in range(2, 51): l+=[6*l[n - 1] - l[n - 2], ]\nprint(l) \n"}
{"sequence_id": "A001579", "text": "a(n) = 3^n + 5^n + 6^n.", "sequence": "3,14,70,368,2002,11144,63010,360248,2076802,12050504,70290850,411802328,2421454402,14282991464,84472462690,500716911608,2973740844802,17689728038024,105375041354530,628434388600088", "code": "\ndef a(n): return 3**n + 5**n + 6**n\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A001591", "text": "Pentanacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) + a(n-4) + a(n-5), a(0)=a(1)=a(2)=a(3)=0, a(4)=1.", "sequence": "0,0,0,0,1,1,2,4,8,16,31,61,120,236,464,912,1793,3525,6930,13624,26784,52656,103519,203513,400096,786568,1546352,3040048,5976577,11749641,23099186,45411804,89277256,175514464,345052351,678355061,1333610936,2621810068", "code": "\ndef pentanacci():\n    a, b, c, d, e = 0, 0, 0, 0, 1\n    while True:\n        yield a\n        a, b, c, d, e = b, c, d, e, a + b + c + d + e\nf = pentanacci()\nprint([next(f) for _ in range(100)]) \n"}
{"sequence_id": "A001597", "text": "Perfect powers: m^k where m > 0 and k >= 2.", "sequence": "1,4,8,9,16,25,27,32,36,49,64,81,100,121,125,128,144,169,196,216,225,243,256,289,324,343,361,400,441,484,512,529,576,625,676,729,784,841,900,961,1000,1024,1089,1156,1225,1296,1331,1369,1444,1521,1600,1681,1728,1764", "code": "\nfrom sympy import perfect_power\ndef ok(n): return n==1 or perfect_power(n)\nprint([m for m in range(1, 1765) if ok(m)]) \n"}
{"sequence_id": "A001599", "text": "Harmonic or Ore numbers: numbers n such that the harmonic mean of the divisors of n is an integer.", "sequence": "1,6,28,140,270,496,672,1638,2970,6200,8128,8190,18600,18620,27846,30240,32760,55860,105664,117800,167400,173600,237510,242060,332640,360360,539400,695520,726180,753480,950976,1089270,1421280,1539720", "code": "\nfrom sympy import divisor_sigma as sigma\ndef ok(n): return (n*sigma(n, 0))%sigma(n, 1) == 0\nprint([n for n in range(1, 10**4) if ok(n)]) \n"}
{"sequence_id": "A001602", "text": "Fibonacci entry points: a(n) = smallest m > 0 such that the n-th prime divides Fibonacci(m).", "sequence": "3,4,5,8,10,7,9,18,24,14,30,19,20,44,16,27,58,15,68,70,37,78,84,11,49,50,104,36,27,19,128,130,69,46,37,50,79,164,168,87,178,90,190,97,99,22,42,224,228,114,13,238,120,250,129,88,67,270,139,28,284,147,44,310", "code": "\nfrom sympy.ntheory.generate import prime\ndef A001602(n):\n    a, b, i, p = 0, 1, 1, prime(n)\n    while b % p:\n        a, b, i = b, (a+b) % p, i+1\n    return i \n"}
{"sequence_id": "A001608", "text": "Perrin sequence (or Ondrej Such sequence): a(n) = a(n-2) + a(n-3) with a(0) = 3, a(1) = 0, a(2) = 2.", "sequence": "3,0,2,3,2,5,5,7,10,12,17,22,29,39,51,68,90,119,158,209,277,367,486,644,853,1130,1497,1983,2627,3480,4610,6107,8090,10717,14197,18807,24914,33004,43721,57918,76725,101639,134643,178364,236282,313007", "code": "\nA001608_list, a, b, c = [3, 0, 2], 3, 0, 2\nfor _ in range(100):\n    a, b, c = b, c, a+b\n    A001608_list.append(c) \n"}
{"sequence_id": "A001622", "text": "Decimal expansion of golden ratio phi (or tau) = (1 + sqrt(5))/2.", "sequence": "1,6,1,8,0,3,3,9,8,8,7,4,9,8,9,4,8,4,8,2,0,4,5,8,6,8,3,4,3,6,5,6,3,8,1,1,7,7,2,0,3,0,9,1,7,9,8,0,5,7,6,2,8,6,2,1,3,5,4,4,8,6,2,2,7,0,5,2,6,0,4,6,2,8,1,8,9,0,2,4,4,9,7,0,7,2,0,7,2,0,4,1,8,9,3,9,1,1,3,7,4,8,4,7,5", "code": "\nfrom sympy import S\ndef alst(n): \n  return list(map(int, str(S.GoldenRatio.n(n+1)).replace(\".\", \"\")))[:-1]\nprint(alst(105)) \n"}
{"sequence_id": "A001651", "text": "Numbers not divisible by 3.", "sequence": "1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,28,29,31,32,34,35,37,38,40,41,43,44,46,47,49,50,52,53,55,56,58,59,61,62,64,65,67,68,70,71,73,74,76,77,79,80,82,83,85,86,88,89,91,92,94,95,97,98,100,101,103,104", "code": "\nprint([k for k in range(1, 105) if k%3]) \n"}
{"sequence_id": "A001654", "text": "Golden rectangle numbers: F(n)*F(n+1), where F(n) = A000045(n) (Fibonacci numbers).", "sequence": "0,1,2,6,15,40,104,273,714,1870,4895,12816,33552,87841,229970,602070,1576239,4126648,10803704,28284465,74049690,193864606,507544127,1328767776,3478759200,9107509825,23843770274,62423800998,163427632719", "code": "\nfrom sympy import fibonacci as F\ndef a(n): return F(n)*F(n + 1)\n[a(n) for n in range(101)] \n"}
{"sequence_id": "A001690", "text": "Non-Fibonacci numbers.", "sequence": "4,6,7,9,10,11,12,14,15,16,17,18,19,20,22,23,24,25,26,27,28,29,30,31,32,33,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78", "code": "\ndef f(n):\n    a=1\n    b=2\n    c=3\n    while n>0:\n        a=b\n        b=c\n        c=a+b\n        n-=(c-b-1)\n    n+=(c-b-1)\n    return (b+n)\nfor i in range(1,1001):\n    print(str(i)+\" \"+str(f(i))) \n"}
{"sequence_id": "A001694", "text": "Powerful numbers, definition (1): if a prime p divides n then p^2 must also divide n (also called squareful, square full, square-full or 2-powerful numbers).", "sequence": "1,4,8,9,16,25,27,32,36,49,64,72,81,100,108,121,125,128,144,169,196,200,216,225,243,256,288,289,324,343,361,392,400,432,441,484,500,512,529,576,625,648,675,676,729,784,800,841,864,900,961,968,972,1000", "code": "\nfrom sympy import factorint\nA001694 = [1]+[n for n in range(2,10**6) if min(factorint(n).values()) > 1]\n\n"}
{"sequence_id": "A001700", "text": "a(n) = binomial(2*n+1, n+1): number of ways to put n+1 indistinguishable balls into n+1 distinguishable boxes = number of (n+1)-st degree monomials in n+1 variables = number of monotone maps from 1..n+1 to 1..n+1.", "sequence": "1,3,10,35,126,462,1716,6435,24310,92378,352716,1352078,5200300,20058300,77558760,300540195,1166803110,4537567650,17672631900,68923264410,269128937220,1052049481860,4116715363800,16123801841550,63205303218876,247959266474052", "code": "\nfrom __future__ import division\nA001700_list, b = [], 1\nfor n in range(10**3):\n    A001700_list.append(b)\n    b = b*(4*n+6)//(n+2) \n"}
{"sequence_id": "A001703", "text": "Decimal concatenation of n, n+1, and n+2.", "sequence": "12,123,234,345,456,567,678,789,8910,91011,101112,111213,121314,131415,141516,151617,161718,171819,181920,192021,202122,212223,222324,232425,242526,252627,262728,272829,282930,293031,303132,313233,323334,333435,343536,353637,363738", "code": " for n in range(100): print(int(str(n)+str(n+1)+str(n+2))) \n"}
{"sequence_id": "A001704", "text": "a(n) = n concatenated with n + 1.", "sequence": "12,23,34,45,56,67,78,89,910,1011,1112,1213,1314,1415,1516,1617,1718,1819,1920,2021,2122,2223,2324,2425,2526,2627,2728,2829,2930,3031,3132,3233,3334,3435,3536,3637,3738,3839,3940,4041,4142,4243,4344,4445,4546", "code": " for n in range(1,100): print(str(n)+str(n+1)) \n"}
{"sequence_id": "A001772", "text": "Numbers k such that 11*2^k - 1 is prime.", "sequence": "2,26,50,54,126,134,246,354,362,950,1310,2498,6926,11826,31734,67850,74726,96150,374114,696438,743322,1044086,1104606,1261478", "code": "\nfrom sympy import isprime\ndef aupto(lim): return [k for k in range(1, lim+1) if isprime(11*2**k - 1)]\nprint(aupto(2500)) \n"}
{"sequence_id": "A001792", "text": "a(n) = (n+2)*2^(n-1).", "sequence": "1,3,8,20,48,112,256,576,1280,2816,6144,13312,28672,61440,131072,278528,589824,1245184,2621440,5505024,11534336,24117248,50331648,104857600,218103808,452984832,939524096,1946157056,4026531840,8321499136,17179869184,35433480192", "code": " for n in range(0,40): print(int((n+2)*2**(n-1)), end=' ') \n"}
{"sequence_id": "A001821", "text": "Central factorial numbers.", "sequence": "1,30,1023,44473,2475473,173721912,15088541896,1593719752240,201529405816816,30092049283982400,5242380158902146624,1054368810603158319360,242558905724502235934976,63305390270900389045395456,18607799824329123330114576384", "code": "\nfrom sympy.functions.combinatorial.numbers import stirling\ndef s(n, k): return stirling(n, k, kind=1)\ndef a(n): return s(n+4, 4)**2 - 2*s(n+4, 1)*s(n+4, 7) + 2*s(n+4, 2)*s(n+4, 6) - 2*s(n+4, 3)*s(n+4, 5)\nprint([a(n) for n in range(15)]) \n"}
{"sequence_id": "A001836", "text": "Numbers n such that phi(2n-1) < phi(2n), where phi is Euler's totient function A000010.", "sequence": "53,83,158,263,293,368,578,683,743,788,878,893,908,998,1073,1103,1208,1238,1268,1403,1418,1502,1523,1658,1733,1838,1943,1964,2048,2063,2153,2228,2243,2258,2363,2393,2423,2468,2558,2573,2633,2657,2678", "code": "\nfrom sympy import totient\ndef ok(n): return totient(2*n - 1) < totient(2*n) \n"}
{"sequence_id": "A001843", "text": "The coding-theoretic function A(n,4,4).", "sequence": "1,1,3,7,14,18,30,35,51,65,91,105,140,157,198,228,285,315,385,419,498,550,650,702,819,877,1005,1085,1240,1320,1496,1583,1773,1887,2109,2223,2470,2593,2856,3010,3311,3465,3795,3959,4308,4508,4900,5100,5525,5737", "code": "\n[((n-2)//2*(n-1)//3 - int(n%6 == 0)) * n // 4 for n in range(4, 50)]\n\n"}
{"sequence_id": "A001844", "text": "Centered square numbers: a(n) = 2*n*(n+1)+1. Sums of two consecutive squares. Also, consider all Pythagorean triples (X, Y, Z=Y+1) ordered by increasing Z; then sequence gives Z values.", "sequence": "1,5,13,25,41,61,85,113,145,181,221,265,313,365,421,481,545,613,685,761,841,925,1013,1105,1201,1301,1405,1513,1625,1741,1861,1985,2113,2245,2381,2521,2665,2813,2965,3121,3281,3445,3613,3785,3961,4141,4325,4513", "code": " print([2*n*(n+1)+1 for n in range(48)]) \n"}
{"sequence_id": "A001850", "text": "Central Delannoy numbers: a(n) = Sum_{k=0..n} C(n,k)*C(n+k,k).", "sequence": "1,3,13,63,321,1683,8989,48639,265729,1462563,8097453,45046719,251595969,1409933619,7923848253,44642381823,252055236609,1425834724419,8079317057869,45849429914943,260543813797441,1482376214227923,8443414161166173", "code": " \ndef f(a, b):\n    if a == 0 or b == 0:\n        return 1\n    return f(a, b - 1) + f(a - 1, b) + f(a - 1, b - 1)\n[f(n, n) for n in range(7)]\n"}
{"sequence_id": "A001850", "text": "Central Delannoy numbers: a(n) = Sum_{k=0..n} C(n,k)*C(n+k,k).", "sequence": "1,3,13,63,321,1683,8989,48639,265729,1462563,8097453,45046719,251595969,1409933619,7923848253,44642381823,252055236609,1425834724419,8079317057869,45849429914943,260543813797441,1482376214227923,8443414161166173", "code": "\nfrom gmpy2 import divexact\nA001850 = [1, 3]\nfor n in range(2,10**3):\n    A001850.append(divexact(A001850[-1]*(6*n-3)-(n-1)*A001850[-2],n))\n\n"}
{"sequence_id": "A001855", "text": "Sorting numbers: maximal number of comparisons for sorting n elements by binary insertion.", "sequence": "0,1,3,5,8,11,14,17,21,25,29,33,37,41,45,49,54,59,64,69,74,79,84,89,94,99,104,109,114,119,124,129,135,141,147,153,159,165,171,177,183,189,195,201,207,213,219,225,231,237,243,249,255,261,267,273,279,285", "code": "\ndef A001855(n):\n    s, i, z = 0, n-1, 1\n    while 0 <= i: s += i; i -= z; z += z\n    return s\nprint([A001855(n) for n in range(1, 59)]) \n"}
{"sequence_id": "A001906", "text": "F(2n) = bisection of Fibonacci sequence: a(n) = 3*a(n-1) - a(n-2).", "sequence": "0,1,3,8,21,55,144,377,987,2584,6765,17711,46368,121393,317811,832040,2178309,5702887,14930352,39088169,102334155,267914296,701408733,1836311903,4807526976,12586269025,32951280099,86267571272,225851433717,591286729879,1548008755920", "code": "\ndef a(n, adict={0:0, 1:1}):\n    if n in adict:\n        return adict[n]\n    adict[n]=3*a(n-1) - a(n-2)\n    return adict[n] \n"}
{"sequence_id": "A001917", "text": "(p-1)/x, where p = prime(n) and x = ord(2,p), the smallest positive integer such that 2^x == 1 mod p.", "sequence": "1,1,2,1,1,2,1,2,1,6,1,2,3,2,1,1,1,1,2,8,2,1,8,2,1,2,1,3,4,18,1,2,1,1,10,3,1,2,1,1,1,2,2,1,2,1,6,1,3,8,2,10,5,16,2,1,2,3,4,3,1,3,2,2,1,11,16,1,1,4,2,2,1,1,2,1,9,2,2,1,1,10,6,6,1,2,6,1,2,1,2,2,1,3,2,1,2,1,1,1,1,1,2", "code": "\nfrom sympy import prime, n_order\ndef A001917(n):\n    p = prime(n)\n    return 1 if n == 2 else (p-1)//n_order(2,p) \n"}
{"sequence_id": "A001951", "text": "A Beatty sequence: a(n) = floor(n*sqrt(2)).", "sequence": "0,1,2,4,5,7,8,9,11,12,14,15,16,18,19,21,22,24,25,26,28,29,31,32,33,35,36,38,39,41,42,43,45,46,48,49,50,52,53,55,56,57,59,60,62,63,65,66,67,69,70,72,73,74,76,77,79,80,82,83,84,86,87,89,90,91,93,94,96,97,98,100", "code": "\nfrom sympy import integer_nthroot\ndef A001951(n): return integer_nthroot(2*n**2,2)[0] \n"}
{"sequence_id": "A001952", "text": "A Beatty sequence: a(n) = floor(n*(2 + sqrt(2))).", "sequence": "3,6,10,13,17,20,23,27,30,34,37,40,44,47,51,54,58,61,64,68,71,75,78,81,85,88,92,95,99,102,105,109,112,116,119,122,126,129,133,136,139,143,146,150,153,157,160,163,167,170,174,177,180,184,187,191,194,198", "code": "\nfrom sympy import integer_nthroot\ndef A001952(n): return 2*n+integer_nthroot(2*n**2,2)[0] \n"}
{"sequence_id": "A001962", "text": "A Beatty sequence: floor(n * (sqrt(5) + 3)).", "sequence": "5,10,15,20,26,31,36,41,47,52,57,62,68,73,78,83,89,94,99,104,109,115,120,125,130,136,141,146,151,157,162,167,172,178,183,188,193,198,204,209,214,219,225,230,235,240,246,251,256,261,267,272,277,282,287", "code": "\nfrom sympy import integer_nthroot\ndef A001962(n): return 3*n+integer_nthroot(5*n**2,2)[0] \n"}
{"sequence_id": "A001969", "text": "Evil numbers: nonnegative integers with an even number of 1's in their binary expansion.", "sequence": "0,3,5,6,9,10,12,15,17,18,20,23,24,27,29,30,33,34,36,39,40,43,45,46,48,51,53,54,57,58,60,63,65,66,68,71,72,75,77,78,80,83,85,86,89,90,92,95,96,99,101,102,105,106,108,111,113,114,116,119,120,123,125,126,129", "code": "\ndef ok(n): return bin(n)[2:].count('1') % 2 == 0\nprint(list(filter(ok, range(130)))) \n"}
{"sequence_id": "A001970", "text": "Functional determinants; partitions of partitions; Euler transform applied twice to all 1's sequence.", "sequence": "1,1,3,6,14,27,58,111,223,424,817,1527,2870,5279,9710,17622,31877,57100,101887,180406,318106,557453,972796,1688797,2920123,5026410,8619551,14722230,25057499,42494975,71832114,121024876,203286806,340435588,568496753,946695386", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import npartitions, divisors\n@cacheit\ndef a(n): return 1 if n == 0 else sum([sum([d*npartitions(d) for d in divisors(j)])*a(n - j) for j in range(1, n + 1)]) / n\n[a(n) for n in range(51)]  \n"}
{"sequence_id": "A001974", "text": "Numbers that are the sum of 3 distinct squares, i.e., numbers of the form x^2 + y^2 + z^2 with 0 <= x < y < z.", "sequence": "5,10,13,14,17,20,21,25,26,29,30,34,35,37,38,40,41,42,45,46,49,50,52,53,54,56,58,59,61,62,65,66,68,69,70,73,74,75,77,78,80,81,82,83,84,85,86,89,90,91,93,94,97,98,100,101,104,105,106,107,109,110,113", "code": "\nfrom itertools import combinations\ndef aupto(lim):\n  s = filter(lambda x: x <= lim, (i*i for i in range(int(lim**.5)+2)))\n  s3 = set(filter(lambda x: x<=lim, (sum(c) for c in combinations(s, 3))))\n  return sorted(s3)\nprint(aupto(113)) \n"}
{"sequence_id": "A001988", "text": "Let p be the n-th odd prime. a(n) is the least prime congruent to 7 modulo 8 such that Legendre(-a(n), q) = -Legendre(-1, q) for all odd primes q <= p.", "sequence": "7,7,127,463,463,487,1423,33247,73327,118903,118903,118903,454183,773767,773767,773767,773767,86976583,125325127,132690343,788667223,788667223,1280222287,2430076903,10703135983,10703135983,10703135983", "code": "\nfrom sympy import legendre_symbol as L, primerange, prime, nextprime\ndef isok(p, oddpn):\n    for q in primerange(3, oddpn + 1):\n        if L(p, q)!=-L(-1, q): return 0\n    return 1\ndef a(n):\n    oddpn=prime(n + 1)\n    p=3\n    while True:\n        if p%8==7:\n            if isok(p, oddpn): return p\n        p=nextprime(p) \n"}
{"sequence_id": "A002034", "text": "Kempner numbers: smallest positive integer m such that n divides m!.", "sequence": "1,2,3,4,5,3,7,4,6,5,11,4,13,7,5,6,17,6,19,5,7,11,23,4,10,13,9,7,29,5,31,8,11,17,7,6,37,19,13,5,41,7,43,11,6,23,47,6,14,10,17,13,53,9,11,7,19,29,59,5,61,31,7,8,13,11,67,17,23,7,71,6,73,37,10,19,11,13,79,6,9,41,83,7", "code": "\nfrom sympy import factorial\ndef a(n):\n    m=1\n    while True:\n        if factorial(m)%n==0: return m\n        else: m+=1\n[a(n) for n in range(1, 101)] \n"}
{"sequence_id": "A002054", "text": "Binomial coefficient C(2n+1, n-1).", "sequence": "1,5,21,84,330,1287,5005,19448,75582,293930,1144066,4457400,17383860,67863915,265182525,1037158320,4059928950,15905368710,62359143990,244662670200,960566918220,3773655750150,14833897694226,58343356817424,229591913401900", "code": "\nfrom __future__ import division\nA002054_list, b = [], 1\nfor n in range(1,10**3):\n    A002054_list.append(b)\n    b = b*(2*n+2)*(2*n+3)//(n*(n+3)) \n"}
{"sequence_id": "A002088", "text": "Sum of totient function: a(n) = Sum_{k=1..n} phi(k), cf. A000010.", "sequence": "0,1,2,4,6,10,12,18,22,28,32,42,46,58,64,72,80,96,102,120,128,140,150,172,180,200,212,230,242,270,278,308,324,344,360,384,396,432,450,474,490,530,542,584,604,628,650,696,712,754,774,806,830,882,900,940,964", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A002088(n): \n    if n == 0:\n        return 0\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(2*A002088(k1)-1)\n        j, k1 = j2, n//j2\n    return (n*(n-1)-c+j)//2 \n"}
{"sequence_id": "A002109", "text": "Hyperfactorials: Product_{k = 1..n} k^k.", "sequence": "1,1,4,108,27648,86400000,4031078400000,3319766398771200000,55696437941726556979200000,21577941222941856209168026828800000,215779412229418562091680268288000000000000000,61564384586635053951550731889313964883968000000000000000", "code": "\nA002109 = [1]\nfor n in range(1, 10):\n    A002109.append(A002109[-1]*n**n) \n"}
{"sequence_id": "A002110", "text": "Primorial numbers (first definition): product of first n primes. Sometimes written prime(n)#.", "sequence": "1,2,6,30,210,2310,30030,510510,9699690,223092870,6469693230,200560490130,7420738134810,304250263527210,13082761331670030,614889782588491410,32589158477190044730,1922760350154212639070,117288381359406970983270,7858321551080267055879090", "code": "\nfrom sympy import primorial\ndef a(n): return 1 if n < 1 else primorial(n)\n[a(n) for n in range(51)]  \n"}
{"sequence_id": "A002113", "text": "Palindromes in base 10.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,141,151,161,171,181,191,202,212,222,232,242,252,262,272,282,292,303,313,323,333,343,353,363,373,383,393,404,414,424,434,444,454,464,474,484,494,505,515", "code": "\ndef A002113_list(nMax):\n  mlist=[]\n  for n in range(nMax+1):\n     mstr=str(n)\n     if mstr==mstr[::-1]:\n        mlist.append(n)\n  return(mlist)\n"}
{"sequence_id": "A002113", "text": "Palindromes in base 10.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,141,151,161,171,181,191,202,212,222,232,242,252,262,272,282,292,303,313,323,333,343,353,363,373,383,393,404,414,424,434,444,454,464,474,484,494,505,515", "code": "\nfrom itertools import chain\nA002113 = sorted(chain(map(lambda x:int(str(x)+str(x)[::-1]),range(1,10**3)),map(lambda x:int(str(x)+str(x)[-2::-1]), range(10**3)))) \n"}
{"sequence_id": "A002113", "text": "Palindromes in base 10.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,141,151,161,171,181,191,202,212,222,232,242,252,262,272,282,292,303,313,323,333,343,353,363,373,383,393,404,414,424,434,444,454,464,474,484,494,505,515", "code": "\nfrom itertools import chain, count\nA002113 = chain(k for k in count(0) if str(k) == str(k)[::-1])\nprint([next(A002113) for k in range(60)]) \n"}
{"sequence_id": "A002117", "text": "Decimal expansion of zeta(3) = Sum_{m >= 1} 1/m^3.", "sequence": "1,2,0,2,0,5,6,9,0,3,1,5,9,5,9,4,2,8,5,3,9,9,7,3,8,1,6,1,5,1,1,4,4,9,9,9,0,7,6,4,9,8,6,2,9,2,3,4,0,4,9,8,8,8,1,7,9,2,2,7,1,5,5,5,3,4,1,8,3,8,2,0,5,7,8,6,3,1,3,0,9,0,1,8,6,4,5,5,8,7,3,6,0,9,3,3,5,2,5,8,1,4,6,1,9,9,1,5", "code": "\nfrom mpmath import mp, apery\nmp.dps=109\nprint([int(z) for z in list(str(apery).replace('.', ''))[:-1]]) \n"}
{"sequence_id": "A002144", "text": "Pythagorean primes: primes of form 4*k + 1.", "sequence": "5,13,17,29,37,41,53,61,73,89,97,101,109,113,137,149,157,173,181,193,197,229,233,241,257,269,277,281,293,313,317,337,349,353,373,389,397,401,409,421,433,449,457,461,509,521,541,557,569,577,593,601,613,617", "code": "\nfrom sympy import prime\nA002144 = [n for n in (prime(x) for x in range(1,10**3)) if not (n-1) % 4]\n\n"}
{"sequence_id": "A002144", "text": "Pythagorean primes: primes of form 4*k + 1.", "sequence": "5,13,17,29,37,41,53,61,73,89,97,101,109,113,137,149,157,173,181,193,197,229,233,241,257,269,277,281,293,313,317,337,349,353,373,389,397,401,409,421,433,449,457,461,509,521,541,557,569,577,593,601,613,617", "code": "\nfrom sympy import isprime\nprint(list(filter(isprime, range(1, 618, 4)))) \n"}
{"sequence_id": "A002182", "text": "Highly composite numbers, definition (1): numbers n where d(n), the number of divisors of n (A000005), increases to a record.", "sequence": "1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160", "code": "\nfrom sympy import divisor_count\nA002182_list, r = [], 0\nfor i in range(1,10**4):\n    d = divisor_count(i)\n    if d > r:\n        r = d\n        A002182_list.append(i) \n"}
{"sequence_id": "A002210", "text": "Decimal expansion of Khintchine's constant.", "sequence": "2,6,8,5,4,5,2,0,0,1,0,6,5,3,0,6,4,4,5,3,0,9,7,1,4,8,3,5,4,8,1,7,9,5,6,9,3,8,2,0,3,8,2,2,9,3,9,9,4,4,6,2,9,5,3,0,5,1,1,5,2,3,4,5,5,5,7,2,1,8,8,5,9,5,3,7,1,5,2,0,0,2,8,0,1,1,4,1,1,7,4,9,3,1,8,4,7,6,9,7,9,9,5,1,5", "code": "\nfrom mpmath import mp, khinchin\nmp.dps = 106\nprint([int(k) for k in list(str(khinchin).replace('.', ''))[:-1]]) \n"}
{"sequence_id": "A002249", "text": "a(n) = a(n-1) - 2*a(n-2) with a(0) = 2, a(1) = 1.", "sequence": "2,1,-3,-5,1,11,9,-13,-31,-5,57,67,-47,-181,-87,275,449,-101,-999,-797,1201,2795,393,-5197,-5983,4411,16377,7555,-25199,-40309,10089,90707,70529,-110885,-251943,-30173,473713,534059,-413367,-1481485", "code": "\nfrom sympy import sqrt, re, I\ndef a(n): return 2*re(((1 + I*sqrt(7))/2)**n)\nprint([a(n) for n in range(40)]) \n"}
{"sequence_id": "A002262", "text": "Triangle read by rows: T(n,k), 0 <= k <= n, in which row n lists the first n+1 nonnegative integers.", "sequence": "0,0,1,0,1,2,0,1,2,3,0,1,2,3,4,0,1,2,3,4,5,0,1,2,3,4,5,6,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,10,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11,12,0,1,2,3,4,5,6,7,8,9,10,11,12,13", "code": "\nfor i in range(16):\n    for j in range(i):\n        print(j, end=\", \") \n"}
{"sequence_id": "A002293", "text": "Number of dissections of a polygon: binomial(4*n, n)/(3*n + 1).", "sequence": "1,1,4,22,140,969,7084,53820,420732,3362260,27343888,225568798,1882933364,15875338990,134993766600,1156393243320,9969937491420,86445222719724,753310723010608,6594154339031800,57956002331347120,511238042454541545", "code": "\nfrom __future__ import division\nA002293_list, x = [1], 1\nfor n in range(100):\n    x = x*4*(4*n+3)*(4*n+2)*(4*n+1)//((3*n+2)*(3*n+3)*(3*n+4))\n    A002293_list.append(x) \n"}
{"sequence_id": "A002312", "text": "Arc-cotangent reducible numbers or non-St\u00f8rmer numbers: largest prime factor of k^2 + 1 is less than 2*k.", "sequence": "3,7,8,13,17,18,21,30,31,32,38,41,43,46,47,50,55,57,68,70,72,73,75,76,83,91,93,98,99,100,105,111,112,117,119,122,123,128,129,132,133,142,144,155,157,162,172,173,174,177,182,183,185,187,189,191,192,193,200", "code": "\nfrom sympy import factorint\ndef ok(n): return max(factorint(n*n + 1)) < 2*n\nprint(list(filter(ok, range(1, 201)))) \n"}
{"sequence_id": "A002321", "text": "Mertens's function: Sum_{k=1..n} mu(k), where mu is the Moebius function A008683.", "sequence": "1,0,-1,-1,-2,-1,-2,-2,-2,-1,-2,-2,-3,-2,-1,-1,-2,-2,-3,-3,-2,-1,-2,-2,-2,-1,-1,-1,-2,-3,-4,-4,-3,-2,-1,-1,-2,-1,0,0,-1,-2,-3,-3,-3,-2,-3,-3,-3,-3,-2,-2,-3,-3,-2,-2,-1,0,-1,-1,-2,-1,-1,-1,0,-1,-2,-2,-1,-2,-3,-3,-4,-3,-3,-3,-2,-3,-4,-4,-4", "code": "\nfrom sympy import mobius\ndef M(n): return sum(mobius(k) for k in range(1,n + 1))\nprint([M(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A002321", "text": "Mertens's function: Sum_{k=1..n} mu(k), where mu is the Moebius function A008683.", "sequence": "1,0,-1,-1,-2,-1,-2,-2,-2,-1,-2,-2,-3,-2,-1,-1,-2,-2,-3,-3,-2,-1,-2,-2,-2,-1,-1,-1,-2,-3,-4,-4,-3,-2,-1,-1,-2,-1,0,0,-1,-2,-3,-3,-3,-2,-3,-3,-3,-3,-2,-2,-3,-3,-2,-2,-1,0,-1,-1,-2,-1,-1,-1,0,-1,-2,-2,-1,-2,-3,-3,-4,-3,-3,-3,-2,-3,-4,-4,-4", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A002321(n):\n    if n == 0:\n        return 0\n    c, j = n, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A002321(k1)\n        j, k1 = j2, n//j2\n    return j-c \n"}
{"sequence_id": "A002322", "text": "Reduced totient function psi(n): least k such that x^k == 1 (mod n) for all x prime to n; also known as the Carmichael lambda function (exponent of unit group mod n); also called the universal exponent of n.", "sequence": "1,1,2,2,4,2,6,2,6,4,10,2,12,6,4,4,16,6,18,4,6,10,22,2,20,12,18,6,28,4,30,8,10,16,12,6,36,18,12,4,40,6,42,10,12,22,46,4,42,20,16,12,52,18,20,6,18,28,58,4,60,30,6,16,12,10,66,16,22,12,70,6,72,36,20,18,30,12,78,4,54", "code": "\nfrom sympy import reduced_totient\ndef A002322(n): return reduced_totient(n) \n"}
{"sequence_id": "A002326", "text": "Multiplicative order of 2 mod 2n+1.", "sequence": "1,2,4,3,6,10,12,4,8,18,6,11,20,18,28,5,10,12,36,12,20,14,12,23,21,8,52,20,18,58,60,6,12,66,22,35,9,20,30,39,54,82,8,28,11,12,10,36,48,30,100,51,12,106,36,36,28,44,12,24,110,20,100,7,14,130,18,36,68,138,46,60,28", "code": "\nfrom sympy import n_order\n[n_order(2, 2*n+1) for n in range(73)] \n"}
{"sequence_id": "A002372", "text": "Goldbach conjecture: number of decompositions of 2n into ordered sums of two odd primes.", "sequence": "0,0,1,2,3,2,3,4,4,4,5,6,5,4,6,4,7,8,3,6,8,6,7,10,8,6,10,6,7,12,5,10,12,4,10,12,9,10,14,8,9,16,9,8,18,8,9,14,6,12,16,10,11,16,12,14,20,12,11,24,7,10,20,6,14,18,11,10,16,14,15,22,11,10,24,8,16,22,9,16,20,10", "code": "\nfrom sympy import isprime, primerange\ndef a(n): return sum([1 for p in primerange(3, 2*n-2) if isprime(2*n-p)])\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A002385", "text": "Palindromic primes: prime numbers whose decimal expansion is a palindrome.", "sequence": "2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181", "code": "\nfrom itertools import chain\nfrom sympy import isprime\nA002385 = sorted((n for n in chain((int(str(x)+str(x)[::-1]) for x in range(1,10**5)),(int(str(x)+str(x)[-2::-1]) for x in range(1,10**5))) if isprime(n))) \n"}
{"sequence_id": "A002407", "text": "Cuban primes: primes which are the difference of two consecutive cubes.", "sequence": "7,19,37,61,127,271,331,397,547,631,919,1657,1801,1951,2269,2437,2791,3169,3571,4219,4447,5167,5419,6211,7057,7351,8269,9241,10267,11719,12097,13267,13669,16651,19441,19927,22447,23497,24571,25117,26227,27361,33391", "code": "\nfrom sympy import isprime\ndef aupto(limit):\n    alst, k, d = [], 1, 7\n    while d <= limit:\n        if isprime(d): alst.append(d)\n        k += 1; d = 1+3*k*(k+1)\n    return alst\nprint(aupto(34000)) \n"}
{"sequence_id": "A002408", "text": "Expansion of 8-dimensional cusp form.", "sequence": "0,1,-8,28,-64,126,-224,344,-512,757,-1008,1332,-1792,2198,-2752,3528,-4096,4914,-6056,6860,-8064,9632,-10656,12168,-14336,15751,-17584,20440,-22016,24390,-28224,29792,-32768,37296,-39312,43344,-48448,50654,-54880,61544,-64512,68922", "code": "\nfrom sympy import divisors\ndef a(n): return 0 if n == 0 else -(-1)**n * sum([((n/d)%2) * d**3 for d in divisors(n)])\nprint([a(n) for n in range(101)])  \n"}
{"sequence_id": "A002419", "text": "4-dimensional figurate numbers: (6*n-2)*binomial(n+2,3)/4.", "sequence": "1,10,40,110,245,476,840,1380,2145,3190,4576,6370,8645,11480,14960,19176,24225,30210,37240,45430,54901,65780,78200,92300,108225,126126,146160,168490,193285,220720,250976,284240,320705,360570,404040,451326", "code": "\nA002419_list, m = [], [6, 1, 1, 1, 1]\nfor _ in range(10**2):\n    A002419_list.append(m[-1])\n    for i in range(4):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A002431", "text": "Numerators in Taylor series for cot x.", "sequence": "1,-1,-1,-2,-1,-2,-1382,-4,-3617,-87734,-349222,-310732,-472728182,-2631724,-13571120588,-13785346041608,-7709321041217,-303257395102,-52630543106106954746,-616840823966644,-522165436992898244102,-6080390575672283210764,-10121188937927645176372", "code": "\nfrom sympy import bernoulli, factorial\ndef a(n):\n    return ((-4)**(n+1)*bernoulli(2*n+2)/factorial(2*n+2)).numerator()\n[a(n) for n in range(-1, 25)] \n"}
{"sequence_id": "A002463", "text": "Coefficients of Legendre polynomials.", "sequence": "1,3,30,175,4410,29106,396396,2760615,156434850,1122854590,16291599324,119224885962,3515605611700,26077294372500,388924218927000,2913690606794775,350671234206006450,2647224022927695750,40095381399899017500,304513870316075169750", "code": "\nfrom sympy import binomial as C, lcm\ndef a_list(nn):\n    l = []\n    for n in range(1, nn + 1, 2):\n        lcmc = 1\n        for m in range(n//2 + 1):\n            lcmc = lcm(lcmc, (C(2*n - 2*m, n - m)*C(2*m, m)/4**n).denominator())\n        m = n//2\n        l.append(lcmc*C(2*n - 2*m, n - m)*C(2*m, m)//4**n)\n    return l \n"}
{"sequence_id": "A002487", "text": "Stern's diatomic series (or Stern-Brocot sequence): a(0) = 0, a(1) = 1; for n > 0: a(2*n) = a(n), a(2*n+1) = a(n) + a(n+1).", "sequence": "0,1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1,5,4,7,3,8,5,7,2,7,5,8,3,7,4,5,1,6,5,9,4,11,7,10,3,11,8,13,5,12,7,9,2,9,7,12,5,13,8,11,3,10,7,11,4,9,5,6,1,7,6,11,5,14,9,13,4,15,11,18,7,17,10,13,3,14,11,19,8,21,13,18,5,17,12,19", "code": " def a(n): return n if n<2 else a(n/2) if n%2==0 else a((n - 1)/2) + a((n + 1)/2) \n"}
{"sequence_id": "A002496", "text": "Primes of the form k^2 + 1.", "sequence": "2,5,17,37,101,197,257,401,577,677,1297,1601,2917,3137,4357,5477,7057,8101,8837,12101,13457,14401,15377,15877,16901,17957,21317,22501,24337,25601,28901,30977,32401,33857,41617,42437,44101,50177", "code": "\n\nfrom itertools import accumulate\nfrom sympy import isprime\nA002496_list = [n+1 for n in accumulate(range(10**5),lambda x,y:x+2*y-1) if isprime(n+1)] \n"}
{"sequence_id": "A002496", "text": "Primes of the form k^2 + 1.", "sequence": "2,5,17,37,101,197,257,401,577,677,1297,1601,2917,3137,4357,5477,7057,8101,8837,12101,13457,14401,15377,15877,16901,17957,21317,22501,24337,25601,28901,30977,32401,33857,41617,42437,44101,50177", "code": "\n\nfrom sympy import isprime\nA002496_list = list(filter(isprime, (n*n+1 for n in range(10**5)))) \n"}
{"sequence_id": "A002544", "text": "a(n) = binomial(2*n+1,n)*(n+1)^2.", "sequence": "1,12,90,560,3150,16632,84084,411840,1969110,9237800,42678636,194699232,878850700,3931426800,17450721000,76938289920,337206098790,1470171918600,6379820115900,27569305764000,118685861314020,509191949220240,2177742427450200,9287309860732800", "code": "\nfrom sympy import binomial\ndef a(n): return binomial(2*n + 1, n)*(n + 1)**2 \n"}
{"sequence_id": "A002557", "text": "Odd squarefree numbers with an even number of prime factors that have no prime factors greater than 31.", "sequence": "1,15,21,33,35,39,51,55,57,65,69,77,85,87,91,93,95,115,119,133,143,145,155,161,187,203,209,217,221,247,253,299,319,323,341,377,391,403,437,493,527,551,589,667,713,899,1155,1365,1785,1995,2145,2415,2805,3003", "code": " powerset = lambda lst: reduce(lambda result, x: result + [subset + [x] for subset in result], lst, [[]])\nproduct = lambda lst: reduce(lambda x, y: x*y, lst, 1)\nprimes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\nsequence = sorted(product(s) for s in powerset(primes) if len(s) % 2 == 0) \n"}
{"sequence_id": "A002708", "text": "a(n) = Fibonacci(n) mod n.", "sequence": "0,1,2,3,0,2,6,5,7,5,1,0,12,13,10,11,16,10,1,5,5,1,22,0,0,25,20,11,1,20,1,5,13,33,30,0,36,1,37,35,1,34,42,25,20,45,46,0,36,25,32,23,52,8,5,21,40,1,1,0,1,1,43,59,60,52,66,65,44,15,1,0,72,73,50,3,2,44,1,5,7,1,82,24", "code": "\nA002708_list, a, b, = [], 1, 1\nfor n in range(1,10**4+1):\n    A002708_list.append(a%n)\n    a, b = b, a+b \n"}
{"sequence_id": "A002779", "text": "Palindromic squares.", "sequence": "0,1,4,9,121,484,676,10201,12321,14641,40804,44944,69696,94249,698896,1002001,1234321,4008004,5221225,6948496,100020001,102030201,104060401,121242121,123454321,125686521,400080004,404090404,522808225", "code": "\nA002779_list = [int(s) for s in (str(m**2) for m in range(10**5)) if s == s[::-1]] \n"}
{"sequence_id": "A002796", "text": "Numbers that are divisible by each nonzero digit.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,15,20,22,24,30,33,36,40,44,48,50,55,60,66,70,77,80,88,90,99,100,101,102,104,105,110,111,112,115,120,122,124,126,128,132,135,140,144,150,155,162,168,175,184,200,202,204,208,210,212", "code": "\nA002796_list = []\nfor i in range(1,10**5):\n    for d in set(str(i)):\n        if d != '0' and i % int(d):\n            break\n    else:\n        A002796_list.append(i) \n"}
{"sequence_id": "A002808", "text": "The composite numbers: numbers n of the form x*y for x > 1 and y > 1.", "sequence": "4,6,8,9,10,12,14,15,16,18,20,21,22,24,25,26,27,28,30,32,33,34,35,36,38,39,40,42,44,45,46,48,49,50,51,52,54,55,56,57,58,60,62,63,64,65,66,68,69,70,72,74,75,76,77,78,80,81,82,84,85,86,87,88", "code": "\nfrom sympy import primepi\ndef A002808(n):\n    m, k = n, primepi(n) + 1 + n\n    while m != k:\n        m, k = k, primepi(k) + 1 + n\n    return m \n"}
{"sequence_id": "A002858", "text": "Ulam numbers: a(1) = 1; a(2) = 2; for n>2, a(n) = least number > a(n-1) which is a unique sum of two distinct earlier terms.", "sequence": "1,2,3,4,6,8,11,13,16,18,26,28,36,38,47,48,53,57,62,69,72,77,82,87,97,99,102,106,114,126,131,138,145,148,155,175,177,180,182,189,197,206,209,219,221,236,238,241,243,253,258,260,273,282,309,316,319,324,339", "code": "\ndef isUlam(n, h, u, r):\n    if h == 2: return False\n    hu = u[0]; hr = r[0]\n    if hr <= hu: return h == 1\n    if hr + hu > n: r = r[1:]\n    elif hr + hu < n: u = u[1:]\n    else: h += 1; r = r[1:]; u = u[1:]\n    return isUlam(n, h, u, r)\ndef UlamList(length):\n    u = [1, 2]; r = [2, 1]; n = 2\n    while len(u) < length:\n        n += 1\n        if isUlam(n, 0, u[:], r[:]):\n            u.append(n); r.insert(0, n)\n    return u\nprint(UlamList(59)) \n"}
{"sequence_id": "A002939", "text": "a(n) = 2*n*(2*n-1).", "sequence": "0,2,12,30,56,90,132,182,240,306,380,462,552,650,756,870,992,1122,1260,1406,1560,1722,1892,2070,2256,2450,2652,2862,3080,3306,3540,3782,4032,4290,4556,4830,5112,5402,5700,6006,6320,6642,6972,7310,7656,8010,8372", "code": " a=lambda n: 2*n*(2*n-1) \n"}
{"sequence_id": "A002981", "text": "Numbers k such that k! + 1 is prime.", "sequence": "0,1,2,3,11,27,37,41,73,77,116,154,320,340,399,427,872,1477,6380,26951,110059,150209", "code": "\nfrom sympy import factorial, isprime\nfor n in range(0,800):\n    if isprime(factorial(n)+1):\n        print(n, end=', ') \n"}
{"sequence_id": "A002982", "text": "Numbers n such that n! - 1 is prime.", "sequence": "3,4,6,7,12,14,30,32,33,38,94,166,324,379,469,546,974,1963,3507,3610,6917,21480,34790,94550,103040,147855,208003", "code": "\nfrom sympy import factorial, isprime\nA002982_list = [n for n in range(1,10**2) if isprime(factorial(n)-1)] \n"}
{"sequence_id": "A003010", "text": "A Lucas-Lehmer sequence: a(0) = 4; for n>0, a(n) = a(n-1)^2 - 2.", "sequence": "4,14,194,37634,1416317954,2005956546822746114,4023861667741036022825635656102100994,16191462721115671781777559070120513664958590125499158514329308740975788034", "code": "\nfrom itertools import accumulate\ndef f(anm1, _): return anm1**2 - 2\nprint(list(accumulate([4]*8, f))) \n"}
{"sequence_id": "A003053", "text": "Order of orthogonal group O(n, GF(2)).", "sequence": "1,2,6,48,720,23040,1451520,185794560,47377612800,24257337753600,24815256521932800,50821645356918374400,208114637736580743168000,1704875112338069448032256000,27930968965434591767112450048000,915241991059360703024740763172864000", "code": "\ndef size_binary_orthogonal_group(n):\n    k = n-1\n    if k%2==0:\n        m=k//2\n        p=2**(m**2)\n        for i in range(1,m+1):\n            p*=4**i-1\n    else:\n        m=(k+1)//2\n        p=2**(m**2)\n        for i in range(1,m):\n            p*=4**i-1\n    return p\n\nprint([size_binary_orthogonal_group(n) for n in range(1, 10)])\n\n"}
{"sequence_id": "A003098", "text": "Palindromic triangular numbers.", "sequence": "0,1,3,6,55,66,171,595,666,3003,5995,8778,15051,66066,617716,828828,1269621,1680861,3544453,5073705,5676765,6295926,35133153,61477416,178727871,1264114621,1634004361,5289009825,6172882716,13953435931", "code": "\nA003098_list = [m for m in (n*(n+1)//2 for n in range(10**5)) if str(m) == str(m)[::-1]] \n"}
{"sequence_id": "A003128", "text": "Number of driving-point impedances of an n-terminal network.", "sequence": "0,0,1,6,31,160,856,4802,28337,175896,1146931,7841108,56089804,418952508,3261082917,26403700954,221981169447,1934688328192,17454004213180,162765041827846,1566915224106221,15553364227949564,159004783733999787,1672432865100333916", "code": "\n\nfrom itertools import accumulate\nA003128_list, blist, a, b = [], [1], 1, 1\nfor _ in range(30):\n....blist = list(accumulate([b]+blist))\n....c = blist[-1]\n....A003128_list.append((c+a-3*b)//2)\n....a, b = b, c \n"}
{"sequence_id": "A003132", "text": "Sum of squares of digits of n.", "sequence": "0,1,4,9,16,25,36,49,64,81,1,2,5,10,17,26,37,50,65,82,4,5,8,13,20,29,40,53,68,85,9,10,13,18,25,34,45,58,73,90,16,17,20,25,32,41,52,65,80,97,25,26,29,34,41,50,61,74,89,106,36,37,40,45,52,61,72,85,100,117,49", "code": "\ndef A003132(n): return sum(int(d)**2 for d in str(n)) \n"}
{"sequence_id": "A003154", "text": "Centered 12-gonal numbers. Also star numbers: 6*n*(n-1) + 1.", "sequence": "1,13,37,73,121,181,253,337,433,541,661,793,937,1093,1261,1441,1633,1837,2053,2281,2521,2773,3037,3313,3601,3901,4213,4537,4873,5221,5581,5953,6337,6733,7141,7561,7993,8437,8893,9361,9841,10333,10837,11353,11881,12421", "code": "\nprint([6*n*(n-1)+1 for n in range(1, 47)]) \n"}
{"sequence_id": "A003185", "text": "a(n) = (4*n+1)(4*n+5).", "sequence": "5,45,117,221,357,525,725,957,1221,1517,1845,2205,2597,3021,3477,3965,4485,5037,5621,6237,6885,7565,8277,9021,9797,10605,11445,12317,13221,14157,15125,16125,17157,18221", "code": " a= lambda n: (4*n+1)*(4*n+5) \n"}
{"sequence_id": "A003188", "text": "Decimal equivalent of Gray code for n.", "sequence": "0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16,48,49,51,50,54,55,53,52,60,61,63,62,58,59,57,56,40,41,43,42,46,47,45,44,36,37,39,38,34,35,33,32,96,97,99,98,102,103,101", "code": "\ndef A003188(n):\n    return int(bin(n^(n/2))[2:],2) \n"}
{"sequence_id": "A003215", "text": "Hex (or centered hexagonal) numbers: 3*n*(n+1)+1 (crystal ball sequence for hexagonal lattice).", "sequence": "1,7,19,37,61,91,127,169,217,271,331,397,469,547,631,721,817,919,1027,1141,1261,1387,1519,1657,1801,1951,2107,2269,2437,2611,2791,2977,3169,3367,3571,3781,3997,4219,4447,4681,4921,5167,5419,5677,5941,6211,6487,6769", "code": " [3*n*(n+1)+1 for n in range(47)] \n"}
{"sequence_id": "A003221", "text": "Number of even permutations of length n with no fixed points.", "sequence": "1,0,0,2,3,24,130,930,7413,66752,667476,7342290,88107415,1145396472,16035550518,240533257874,3848532125865,65425046139840,1177650830516968,22375365779822562,447507315596451051,9397653627525472280,206748379805560389930", "code": "\nfrom __future__ import division\nA003221_list, m, x = [], -1, 0\nfor n in range(10*2):\n....x, m = x*n + m*(n*(n-1)//2-1), -m\n....A003221_list.append(x) \n"}
{"sequence_id": "A003261", "text": "Woodall (or Riesel) numbers: n*2^n - 1.", "sequence": "1,7,23,63,159,383,895,2047,4607,10239,22527,49151,106495,229375,491519,1048575,2228223,4718591,9961471,20971519,44040191,92274687,192937983,402653183,838860799,1744830463,3623878655,7516192767", "code": " [n*2**n - 1 for n in range(1, 29)] \n"}
{"sequence_id": "A003278", "text": "Szekeres's sequence: a(n)-1 in ternary = n-1 in binary; also: a(1) = 1, a(2) = 2, and thereafter a(n) is smallest number k which avoids any 3-term arithmetic progression in a(1), a(2), ..., a(n-1), k.", "sequence": "1,2,4,5,10,11,13,14,28,29,31,32,37,38,40,41,82,83,85,86,91,92,94,95,109,110,112,113,118,119,121,122,244,245,247,248,253,254,256,257,271,272,274,275,280,281,283,284,325,326,328,329,334,335,337,338,352,353", "code": "\ndef A003278(n):\n    return int(format(n-1,'b'),3)+1 \n"}
{"sequence_id": "A003285", "text": "Period of continued fraction for square root of n (or 0 if n is a square).", "sequence": "0,1,2,0,1,2,4,2,0,1,2,2,5,4,2,0,1,2,6,2,6,6,4,2,0,1,2,4,5,2,8,4,4,4,2,0,1,2,2,2,3,2,10,8,6,12,4,2,0,1,2,6,5,6,4,2,6,7,6,4,11,4,2,0,1,2,10,2,8,6,8,2,7,5,4,12,6,4,4,2,0,1,2,2,5,10,2,6,5,2,8,8,10,16,4,4,11,4,2,0,1,2,12", "code": "\nfrom sympy.ntheory.continued_fraction import continued_fraction_periodic\ndef a(n):\n    cfp = continued_fraction_periodic(0, 1, d=n)\n    return 0 if len(cfp) == 1 else len(cfp[1])\nprint([a(n) for n in range(1, 104)]) \n"}
{"sequence_id": "A003312", "text": "a(1) = 3; for n>0, a(n+1) = a(n) + floor((a(n)-1)/2).", "sequence": "3,4,5,7,10,14,20,29,43,64,95,142,212,317,475,712,1067,1600,2399,3598,5396,8093,12139,18208,27311,40966,61448,92171,138256,207383,311074,466610,699914,1049870,1574804,2362205,3543307,5314960,7972439,11958658,17937986,26906978", "code": "\nl=[0, 3]\nfor n in range(2, 101):\n    l.append(l[n - 1] + (l[n - 1] - 1)//2)\nprint(l[1:]) \n"}
{"sequence_id": "A003314", "text": "Binary entropy function: a(1)=0; for n > 1, a(n) = n + min { a(k)+a(n-k) : 1 <= k <= n-1 }.", "sequence": "0,2,5,8,12,16,20,24,29,34,39,44,49,54,59,64,70,76,82,88,94,100,106,112,118,124,130,136,142,148,154,160,167,174,181,188,195,202,209,216,223,230,237,244,251,258,265,272,279,286,293,300,307,314,321,328,335", "code": "\ndef A003314(n):\n    return n*int(math.log(4*n,2))-2**int(math.log(2*n,2)) \n"}
{"sequence_id": "A003314", "text": "Binary entropy function: a(1)=0; for n > 1, a(n) = n + min { a(k)+a(n-k) : 1 <= k <= n-1 }.", "sequence": "0,2,5,8,12,16,20,24,29,34,39,44,49,54,59,64,70,76,82,88,94,100,106,112,118,124,130,136,142,148,154,160,167,174,181,188,195,202,209,216,223,230,237,244,251,258,265,272,279,286,293,300,307,314,321,328,335", "code": "\ndef A003314(n):\n    s, i, z = n-1, n-1, 1\n    while 0 <= i: s += i; i -= z; z += z\n    return s\nprint([A003314(n) for n in range(1, 58)]) \n"}
{"sequence_id": "A003318", "text": "a(n + 1) = 1 + a( floor(n/1) ) + a( floor(n/2) ) + ... + a( floor(n/n) ).", "sequence": "1,2,4,7,12,18,28,39,55,74,100,127,167,208,261,322,399,477,581,686,820,967,1142,1318,1545,1778,2053,2347,2697,3048,3486,3925,4441,4986,5610,6250,7024,7799,8680,9604,10673,11743,13008,14274,15718,17239,18937,20636", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A003318(n):\n    if n == 0:\n        return 1\n    c, j = n+1, 1\n    k1 = (n-1)//j\n    while k1 > 1:\n        j2 = (n-1)//k1 + 1\n        c += (j2-j)*A003318(k1)\n        j, k1 = j2, (n-1)//j2\n    return c-j \n"}
{"sequence_id": "A003325", "text": "Numbers that are the sum of 2 positive cubes.", "sequence": "2,9,16,28,35,54,65,72,91,126,128,133,152,189,217,224,243,250,280,341,344,351,370,407,432,468,513,520,539,559,576,637,686,728,730,737,756,793,854,855,945,1001,1008,1024,1027,1064,1072,1125,1216,1241,1332,1339,1343", "code": "\nfrom sympy import integer_nthroot\ndef aupto(lim):\n  cubes = [i*i*i for i in range(1, integer_nthroot(lim-1, 3)[0] + 1)]\n  sum_cubes = sorted([a+b for i, a in enumerate(cubes) for b in cubes[i:]])\n  return [s for s in sum_cubes if s <= lim]\nprint(aupto(1343)) \n"}
{"sequence_id": "A003328", "text": "Numbers that are the sum of 5 positive cubes.", "sequence": "5,12,19,26,31,33,38,40,45,52,57,59,64,68,71,75,78,82,83,89,90,94,96,97,101,108,109,115,116,120,127,129,131,134,135,136,138,143,145,146,150,152,153,155,157,162,164,169,171,172,176,181,183,188,190,192,194,195,199", "code": "\nfrom collections import Counter\nfrom itertools import combinations_with_replacement as combs_w_rep\ndef aupto(lim):\n  s = filter(lambda x: x<=lim, (i**3 for i in range(1, int(lim**(1/3))+2)))\n  s2 = filter(lambda x: x<=lim, (sum(c) for c in combs_w_rep(s, 5)))\n  s2counts = Counter(s2)\n  return sorted(k for k in s2counts)\nprint(aupto(200)) \n"}
{"sequence_id": "A003329", "text": "Numbers that are the sum of 6 positive cubes.", "sequence": "6,13,20,27,32,34,39,41,46,48,53,58,60,65,67,69,72,76,79,83,84,86,90,91,95,97,98,102,104,105,109,110,116,117,121,123,124,128,130,132,135,136,137,139,142,143,144,146,147,151,153,154,156,158,160,161,162,163,165,170", "code": "\nfrom collections import Counter\nfrom itertools import combinations_with_replacement as multi_combs\ndef aupto(lim):\n  c = filter(lambda x: x<=lim, (i**3 for i in range(1, int(lim**(1/3))+2)))\n  s = filter(lambda x: x<=lim, (sum(mc) for mc in multi_combs(c, 6)))\n  counts = Counter(s)\n  return sorted(k for k in counts)\nprint(aupto(170)) \n"}
{"sequence_id": "A003331", "text": "Numbers that are the sum of 8 positive cubes.", "sequence": "8,15,22,29,34,36,41,43,48,50,55,57,60,62,64,67,69,71,74,76,78,81,83,85,86,88,92,93,95,97,99,100,102,104,106,107,111,112,113,114,118,119,120,121,123,125,126,130,132,133,134,137,138,139,140,141,144,145,146,148,149", "code": "\nfrom itertools import combinations_with_replacement as mc\ndef aupto(lim):\n    cbs = (i**3 for i in range(1, int((lim-7)**(1/3))+2))\n    return sorted(set(k for k in (sum(c) for c in mc(cbs, 8)) if k <= lim))\nprint(aupto(150)) \n"}
{"sequence_id": "A003336", "text": "Numbers that are the sum of 2 positive 4th powers.", "sequence": "2,17,32,82,97,162,257,272,337,512,626,641,706,881,1250,1297,1312,1377,1552,1921,2402,2417,2482,2592,2657,3026,3697,4097,4112,4177,4352,4721,4802,5392,6497,6562,6577,6642,6817,7186,7857,8192,8962,10001,10016,10081,10256,10625", "code": "\ndef aupto(lim):\n  p1 = set(i**4 for i in range(1, int(lim**.25)+2) if i**4 <= lim)\n  p2 = set(a+b for a in p1 for b in p1 if a+b <= lim)\n  return sorted(p2)\nprint(aupto(10625)) \n"}
{"sequence_id": "A003337", "text": "Numbers n which are the sum of 3 nonzero 4th powers.", "sequence": "3,18,33,48,83,98,113,163,178,243,258,273,288,338,353,418,513,528,593,627,642,657,707,722,768,787,882,897,962,1137,1251,1266,1298,1313,1328,1331,1378,1393,1458,1506,1553,1568,1633,1808,1875,1922,1937,2002,2177", "code": "\ndef aupto(lim):\n  p1 = set(i**4 for i in range(1, int(lim**.25)+2) if i**4 <= lim)\n  p2 = set(a+b for a in p1 for b in p1 if a+b <= lim)\n  p3 = set(apb+c for apb in p2 for c in p1 if apb+c <= lim)\n  return sorted(p3)\nprint(aupto(2400)) \n"}
{"sequence_id": "A003338", "text": "Numbers that are the sum of 4 nonzero 4th powers.", "sequence": "4,19,34,49,64,84,99,114,129,164,179,194,244,259,274,289,304,324,339,354,369,419,434,499,514,529,544,594,609,628,643,658,673,674,708,723,738,769,784,788,803,849,868,883,898,913,963,978,1024,1043,1138,1153,1218", "code": "\nlimit = 1218\nfrom functools import lru_cache\nqd = [k**4 for k in range(1, int(limit**.25)+2) if k**4 + 3 <= limit]\nqds = set(qd)\n@lru_cache(maxsize=None)\ndef findsums(n, m):\n  if m == 1: return {(n, )} if n in qds else set()\n  return set(tuple(sorted(t+(q,))) for q in qds for t in findsums(n-q, m-1))\nprint([n for n in range(4, limit+1) if len(findsums(n, 4)) >= 1]) \n"}
{"sequence_id": "A003339", "text": "Numbers that are the sum of 5 positive 4th powers.", "sequence": "5,20,35,50,65,80,85,100,115,130,145,165,180,195,210,245,260,275,290,305,320,325,340,355,370,385,405,420,435,450,500,515,530,545,560,580,595,610,625,629,644,659,674,675,689,690,709,724,739,754,755,770,785,789,800", "code": "\nfrom itertools import combinations_with_replacement as combs_with_rep\ndef aupto(limit):\n  qd = [k**4 for k in range(1, int(limit**.25)+2) if k**4 + 4 <= limit]\n  ss = set(sum(c) for c in combs_with_rep(qd, 5))\n  return sorted(s for s in ss if s <= limit)\nprint(aupto(800)) \n"}
{"sequence_id": "A003340", "text": "Numbers that are the sum of 6 positive 4th powers.", "sequence": "6,21,36,51,66,81,86,96,101,116,131,146,161,166,181,196,211,226,246,261,276,291,306,321,326,336,341,356,371,386,401,406,421,436,451,466,486,501,516,531,546,561,576,581,596,611,626,630,641,645,660,661,675,676,690", "code": "\nfrom itertools import combinations_with_replacement as combs_with_rep\ndef aupto(limit):\n    qd = [k**4 for k in range(1, int(limit**.25)+2) if k**4 + 5 <= limit]\n    ss = set(sum(c) for c in combs_with_rep(qd, 6))\n    return sorted(s for s in ss if s <= limit)\nprint(aupto(700)) \n"}
{"sequence_id": "A003341", "text": "Numbers that are the sum of 7 positive 4th powers.", "sequence": "7,22,37,52,67,82,87,97,102,112,117,132,147,162,167,177,182,197,212,227,242,247,262,277,292,307,322,327,337,342,352,357,372,387,402,407,417,422,437,452,467,482,487,502,517,532,547,562,567,577,582,592,597,612,627", "code": "\nfrom itertools import combinations_with_replacement as mc\ndef aupto(limit):\n    qd = [k**4 for k in range(1, int(limit**.25)+2) if k**4 + 6 <= limit]\n    ss = set(sum(c) for c in mc(qd, 7))\n    return sorted(s for s in ss if s <= limit)\nprint(aupto(630)) \n"}
{"sequence_id": "A003342", "text": "Numbers that are the sum of 8 positive 4th powers.", "sequence": "8,23,38,53,68,83,88,98,103,113,118,128,133,148,163,168,178,183,193,198,213,228,243,248,258,263,278,293,308,323,328,338,343,353,358,368,373,388,403,408,418,423,433,438,453,468,483,488,498,503,518,533,548,563,568", "code": "\nfrom itertools import combinations_with_replacement as mc\nfrom sympy import integer_nthroot\ndef iroot4(n): return integer_nthroot(n, 4)[0]\ndef aupto(lim):\n    pows4 = set(i**4 for i in range(1, iroot4(lim)+1) if i**4 <= lim)\n    return sorted(t for t in set(sum(c) for c in mc(pows4, 8)) if t <= lim)\nprint(aupto(568)) \n"}
{"sequence_id": "A003344", "text": "Numbers that are the sum of 10 positive 4th powers.", "sequence": "10,25,40,55,70,85,90,100,105,115,120,130,135,145,150,160,165,170,180,185,195,200,210,215,225,230,245,250,260,265,275,280,290,295,310,325,330,340,345,355,360,370,375,385,390,400,405,410,420,425,435,440,450,455,465", "code": "\nfrom itertools import count, takewhile, combinations_with_replacement as mc\ndef aupto(limit):\n    pows4 = list(takewhile(lambda x: x <= limit, (i**4 for i in count(1))))\n    sum10 = set(sum(c) for c in mc(pows4, 10) if sum(c) <= limit)\n    return sorted(sum10)\nprint(aupto(465)) \n"}
{"sequence_id": "A003401", "text": "Numbers of edges of regular polygons constructible with ruler (or, more precisely, an unmarked straightedge) and compass.", "sequence": "1,2,3,4,5,6,8,10,12,15,16,17,20,24,30,32,34,40,48,51,60,64,68,80,85,96,102,120,128,136,160,170,192,204,240,255,256,257,272,320,340,384,408,480,510,512,514,544,640,680,768,771,816,960,1020,1024,1028,1088,1280,1285", "code": "\nfrom sympy import totient\nA003401_list = [n for n in range(1,10**4) if format(totient(n),'b').count('1') == 1]\n\n"}
{"sequence_id": "A003415", "text": "a(n) = n' = arithmetic derivative of n: a(0) = a(1) = 0, a(prime) = 1, a(mn) = m*a(n) + n*a(m).", "sequence": "0,0,1,1,4,1,5,1,12,6,7,1,16,1,9,8,32,1,21,1,24,10,13,1,44,10,15,27,32,1,31,1,80,14,19,12,60,1,21,16,68,1,41,1,48,39,25,1,112,14,45,20,56,1,81,16,92,22,31,1,92,1,33,51,192,18,61,1,72,26,59,1,156,1,39,55,80,18,71", "code": "\nfrom sympy import factorint\ndef A003415(n):\n    return sum([int(n*e/p) for p,e in factorint(n).items()]) if n > 1 else 0\n\n"}
{"sequence_id": "A003418", "text": "Least common multiple (or LCM) of {1, 2, ..., n} for n >= 1, a(0) = 1.", "sequence": "1,1,2,6,12,60,60,420,840,2520,2520,27720,27720,360360,360360,360360,720720,12252240,12252240,232792560,232792560,232792560,232792560,5354228880,5354228880,26771144400,26771144400,80313433200,80313433200,2329089562800,2329089562800", "code": "\nfrom functools import reduce\nfrom operator import mul\nfrom sympy import sieve\ndef integerlog(n,b): \n    kmin, kmax = 0,1\n    while b**kmax <= n:\n        kmax *= 2\n    while True:\n        kmid = (kmax+kmin)//2\n        if b**kmid > n:\n            kmax = kmid\n        else:\n            kmin = kmid\n        if kmax-kmin <= 1:\n            break\n    return kmin\ndef A003418(n):\n    return reduce(mul,(p**integerlog(n,p) for p in sieve.primerange(1,n+1)),1) \n"}
{"sequence_id": "A003418", "text": "Least common multiple (or LCM) of {1, 2, ..., n} for n >= 1, a(0) = 1.", "sequence": "1,1,2,6,12,60,60,420,840,2520,2520,27720,27720,360360,360360,360360,720720,12252240,12252240,232792560,232792560,232792560,232792560,5354228880,5354228880,26771144400,26771144400,80313433200,80313433200,2329089562800,2329089562800", "code": " \nfrom math import gcd\nfrom itertools import accumulate\ndef lcm(a, b): return a * b // gcd(a, b)\ndef aupton(nn): return [1] + list(accumulate(range(1, nn+1), lcm))\nprint(aupton(30)) \n"}
{"sequence_id": "A003504", "text": "a(0)=a(1)=1; thereafter a(n+1) = sum(a(k)^2,k=0..n)/n (a(n) is not always integral!).", "sequence": "1,1,2,3,5,10,28,154,3520,1551880,267593772160,7160642690122633501504,4661345794146064133843098964919305264116096,1810678717716933442325741630275004084414865420898591223522682022447438928019172629856", "code": "\na=2; L=[1,1,a]; n=15\nfor k in range(1,n-1):\n....a=a*(a+k)//(k+1)\n....L.append(a)\nL \n"}
{"sequence_id": "A003512", "text": "A Beatty sequence: floor(n*(sqrt(3) + 2)).", "sequence": "3,7,11,14,18,22,26,29,33,37,41,44,48,52,55,59,63,67,70,74,78,82,85,89,93,97,100,104,108,111,115,119,123,126,130,134,138,141,145,149,153,156,160,164,167,171,175,179,182,186", "code": "\nfrom gmpy2 import isqrt\ndef A003512(n):\n    return 2*n + int(isqrt(3*n**2))  \n"}
{"sequence_id": "A003533", "text": "Divisors of 2^25 - 1.", "sequence": "1,31,601,1801,18631,55831,1082401,33554431", "code": "\nfrom sympy import divisors\nprint(divisors(2**25 - 1)) \n"}
{"sequence_id": "A003557", "text": "n divided by largest squarefree divisor of n; if n = Product p(k)^e(k) then a(n) = Product p(k)^(e(k)-1), with a(1) = 1.", "sequence": "1,1,1,2,1,1,1,4,3,1,1,2,1,1,1,8,1,3,1,2,1,1,1,4,5,1,9,2,1,1,1,16,1,1,1,6,1,1,1,4,1,1,1,2,3,1,1,8,7,5,1,2,1,9,1,4,1,1,1,2,1,1,3,32,1,1,1,2,1,1,1,12,1,1,5,2,1,1,1,8,27,1,1,2,1,1,1,4,1,3,1,2,1,1,1,16,1,7", "code": "\nfrom sympy.ntheory.factor_ import core\nfrom sympy import divisors\ndef a(n): return n / max(i for i in divisors(n) if core(i) == i)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A003592", "text": "Numbers of the form 2^i*5^j with i, j >= 0.", "sequence": "1,2,4,5,8,10,16,20,25,32,40,50,64,80,100,125,128,160,200,250,256,320,400,500,512,625,640,800,1000,1024,1250,1280,1600,2000,2048,2500,2560,3125,3200,4000,4096,5000,5120,6250,6400,8000,8192,10000", "code": "\n\nfrom heapq import heappush, heappop\ndef A003592():\n    pq = [1]\n    seen = set(pq)\n    while True:\n        value = heappop(pq)\n        yield value\n        seen.remove(value)\n        for x in 2*value, 5*value:\n            if x not in seen:\n                heappush(pq, x)\n                seen.add(x)\nsequence = A003592()\nA003592_list = [next(sequence) for _ in range(100)]\n"}
{"sequence_id": "A003601", "text": "Numbers n such that the average of the divisors of n is an integer: sigma_0(n) divides sigma_1(n). Alternatively, tau(n) (A000005(n)) divides sigma(n) (A000203(n)).", "sequence": "1,3,5,6,7,11,13,14,15,17,19,20,21,22,23,27,29,30,31,33,35,37,38,39,41,42,43,44,45,46,47,49,51,53,54,55,56,57,59,60,61,62,65,66,67,68,69,70,71,73,77,78,79,83,85,86,87,89,91,92,93,94,95,96,97,99,101,102,103,105", "code": "\nfrom sympy import divisors, divisor_count\n[n for n in range(1,10**5) if not sum(divisors(n)) % divisor_count(n)] \n"}
{"sequence_id": "A003602", "text": "Kimberling's paraphrases: if n = (2k-1)*2^m then a(n) = k.", "sequence": "1,1,2,1,3,2,4,1,5,3,6,2,7,4,8,1,9,5,10,3,11,6,12,2,13,7,14,4,15,8,16,1,17,9,18,5,19,10,20,3,21,11,22,6,23,12,24,2,25,13,26,7,27,14,28,4,29,15,30,8,31,16,32,1,33,17,34,9,35,18,36,5,37,19,38,10,39,20,40,3,41,21,42", "code": "\nimport math\ndef a(n): return (n/2**int(math.log(n - (n & n - 1), 2)) + 1)/2 \n"}
{"sequence_id": "A003617", "text": "Smallest n-digit prime.", "sequence": "2,11,101,1009,10007,100003,1000003,10000019,100000007,1000000007,10000000019,100000000003,1000000000039,10000000000037,100000000000031,1000000000000037,10000000000000061,100000000000000003,1000000000000000003,10000000000000000051", "code": "\nfrom sympy import nextprime\nprint([nextprime(10**(n-1)) for n in range(1, 21)]) \n"}
{"sequence_id": "A003618", "text": "Largest n-digit prime.", "sequence": "7,97,997,9973,99991,999983,9999991,99999989,999999937,9999999967,99999999977,999999999989,9999999999971,99999999999973,999999999999989,9999999999999937,99999999999999997,999999999999999989,9999999999999999961,99999999999999999989", "code": "\nfrom sympy import prevprime\nprint([prevprime(10**n) for n in range(1, 21)]) \n"}
{"sequence_id": "A003622", "text": "The Wythoff compound sequence AA: [n*phi^2] - 1, where phi = (1+sqrt(5))/2.", "sequence": "1,4,6,9,12,14,17,19,22,25,27,30,33,35,38,40,43,46,48,51,53,56,59,61,64,67,69,72,74,77,80,82,85,88,90,93,95,98,101,103,106,108,111,114,116,119,122,124,127,129,132,135,137,140,142,145,148,150,153,156,158,161,163,166", "code": "\nfrom sympy import floor\nfrom mpmath import phi\ndef a(n): return floor(n*phi**2) - 1 \n"}
{"sequence_id": "A003623", "text": "Wythoff AB-numbers: [[n*phi^2]*phi], where phi = (1+sqrt(5))/2.", "sequence": "3,8,11,16,21,24,29,32,37,42,45,50,55,58,63,66,71,76,79,84,87,92,97,100,105,110,113,118,121,126,131,134,139,144,147,152,155,160,165,168,173,176,181,186,189,194,199,202,207,210,215,220,223,228,231,236,241,244,249", "code": "\nfrom sympy import floor\nfrom mpmath import phi\ndef a(n): return floor(n*phi) + floor(n*phi**2) \n"}
{"sequence_id": "A003634", "text": "Smallest positive integer that is n times its digit sum, or 0 if no such number exists.", "sequence": "1,18,27,12,45,54,21,72,81,10,198,108,117,126,135,144,153,162,114,180,378,132,207,216,150,234,243,112,261,270,372,576,594,102,315,324,111,342,351,120,738,756,516,792,405,230,423,432,441,450,918,312,954,972", "code": "\ndef sd(n): return sum(map(int, str(n)))\ndef a(n):\n  m = 1\n  while m != n*sd(m): m += 1\n  return m\nprint([a(n) for n in range(1,62)]) \n"}
{"sequence_id": "A003668", "text": "a(n) is smallest number which is uniquely a(j)+a(k), j<k.", "sequence": "2,7,9,11,13,15,16,17,19,21,25,29,33,37,39,45,47,53,61,69,71,73,75,85,89,101,103,117,133,135,137,139,141,143,145,147,151,155,159,163,165,171,173,179,187,195,197,199,201,211,215,227,229,243,259,261,263,265,267,269", "code": "\ndef aupton(terms):\n  alst = [2, 7]\n  for n in range(2, terms):\n    sums = [alst[j]+alst[k] for j in range(n-1) for k in range(j+1, n)]\n    alst.append(min([s for s in sums if sums.count(s)==1 and s > alst[-1]]))\n  return alst\nprint(aupton(60)) \n"}
{"sequence_id": "A003680", "text": "Smallest number with 2n divisors.", "sequence": "2,6,12,24,48,60,192,120,180,240,3072,360,12288,960,720,840,196608,1260,786432,1680,2880,15360,12582912,2520,6480,61440,6300,6720,805306368,5040,3221225472,7560,46080,983040,25920,10080,206158430208,3932160,184320,15120", "code": "\nfrom sympy import divisors\ndef a(n):\n  m = 4*n - 2\n  while len(divisors(m)) != 2*n: m += 1\n  return m\nprint([a(n) for n in range(1, 19)]) \n"}
{"sequence_id": "A003684", "text": "Number of n-digit reversible primes (or emirps) with distinct digits.", "sequence": "4,8,22,84,402,1218,3572,8218,11804", "code": "\nfrom sympy import primerange, isprime\ndef A003684(n):\n    return len([p for p in primerange(10**(n-1),10**n)\n    if len(set(str(p))) == len(str(p)) and isprime(int(str(p)[::-1]))])\n\n"}
{"sequence_id": "A003689", "text": "Number of Hamiltonian paths in K_3 X P_n.", "sequence": "3,30,144,588,2160,7440,24576,78912,248448,771456,2371968,7241856,21998976,66586752,201025920,605781120,1823094144,5481472128,16470172032,49464779904,148508372352,445764192384,1337792747904", "code": "\n\nfrom graphillion import GraphSet\ndef make_CnXPk(n, k):\n    grids = []\n    for i in range(1, k + 1):\n        for j in range(1, n):\n            grids.append((i + (j - 1) * k, i + j * k))\n        grids.append((i + (n - 1) * k, i))\n    for i in range(1, k * n, k):\n        for j in range(1, k):\n            grids.append((i + j - 1, i + j))\n    return grids\ndef A(start, goal, n, k):\n    universe = make_CnXPk(n, k)\n    GraphSet.set_universe(universe)\n    paths = GraphSet.paths(start, goal, is_hamilton=True)\n    return paths.len()\ndef B(n, k):\n    m = k * n\n    s = 0\n    for i in range(1, m):\n        for j in range(i + 1, m + 1):\n            s += A(i, j, n, k)\n    return s\ndef A003689(n):\n    return B(3, n)\nprint([A003689(n) for n in range(1, 21)])  \n"}
{"sequence_id": "A003714", "text": "Fibbinary numbers: if n = F(i1) + F(i2) + ... + F(ik) is the Zeckendorf representation of n (i.e., write n in Fibonacci number system) then a(n) = 2^(i1 - 2) + 2^(i2 - 2) + ... + 2^(ik - 2). Also numbers whose binary representation contains no two adjacent 1's.", "sequence": "0,1,2,4,5,8,9,10,16,17,18,20,21,32,33,34,36,37,40,41,42,64,65,66,68,69,72,73,74,80,81,82,84,85,128,129,130,132,133,136,137,138,144,145,146,148,149,160,161,162,164,165,168,169,170,256,257,258,260", "code": "\nfor n in range(300):\n    if 2*n & n == 0:\n        print(n, end=\",\") \n"}
{"sequence_id": "A003714", "text": "Fibbinary numbers: if n = F(i1) + F(i2) + ... + F(ik) is the Zeckendorf representation of n (i.e., write n in Fibonacci number system) then a(n) = 2^(i1 - 2) + 2^(i2 - 2) + ... + 2^(ik - 2). Also numbers whose binary representation contains no two adjacent 1's.", "sequence": "0,1,2,4,5,8,9,10,16,17,18,20,21,32,33,34,36,37,40,41,42,64,65,66,68,69,72,73,74,80,81,82,84,85,128,129,130,132,133,136,137,138,144,145,146,148,149,160,161,162,164,165,168,169,170,256,257,258,260", "code": "\ndef A003714(n):\n    tlist, s = [1,2], 0\n    while tlist[-1]+tlist[-2] <= n:\n        tlist.append(tlist[-1]+tlist[-2])\n    for d in tlist[::-1]:\n        s *= 2\n        if d <= n:\n            s += 1\n            n -= d\n    return s \n"}
{"sequence_id": "A003714", "text": "Fibbinary numbers: if n = F(i1) + F(i2) + ... + F(ik) is the Zeckendorf representation of n (i.e., write n in Fibonacci number system) then a(n) = 2^(i1 - 2) + 2^(i2 - 2) + ... + 2^(ik - 2). Also numbers whose binary representation contains no two adjacent 1's.", "sequence": "0,1,2,4,5,8,9,10,16,17,18,20,21,32,33,34,36,37,40,41,42,64,65,66,68,69,72,73,74,80,81,82,84,85,128,129,130,132,133,136,137,138,144,145,146,148,149,160,161,162,164,165,168,169,170,256,257,258,260", "code": "\ndef fibbinary():\n    x = 0\n    while True:\n        yield x\n        y = ~(x >> 1)\n        x = (x - y) & y \n(C++)\n/* start with x=0, then repeatedly call x=next_fibrep(x): */\nulong next_fibrep(ulong x)\n{\n    // 2 examples:         //  ex. 1             //  ex.2\n    //                     // x == [*]0 010101   // x == [*]0 01010\n    ulong y = x | (x>>1);  // y == [*]? 011111   // y == [*]? 01111\n    ulong z = y + 1;       // z == [*]? 100000   // z == [*]? 10000\n    z = z & -z;            // z == [0]0 100000   // z == [0]0 10000\n    x ^= z;                // x == [*]0 110101   // x == [*]0 11010\n    x &= ~(z-1);           // x == [*]0 100000   // x == [*]0 10000\n    return x;\n}\n/* _Joerg Arndt_, Jun 22 2012 */\n"}
{"sequence_id": "A003754", "text": "Numbers with no adjacent 0's in binary expansion.", "sequence": "0,1,2,3,5,6,7,10,11,13,14,15,21,22,23,26,27,29,30,31,42,43,45,46,47,53,54,55,58,59,61,62,63,85,86,87,90,91,93,94,95,106,107,109,110,111,117,118,119,122,123,125,126,127,170,171,173,174,175,181", "code": "\ni=0\nwhile i<=500:\n    if \"00\" not in bin(i)[2:]:\n        print(str(i), end=',')\n    i+=1 \n"}
{"sequence_id": "A003817", "text": "a(0) = 0, a(n) = a(n-1) OR n.", "sequence": "0,1,3,3,7,7,7,7,15,15,15,15,15,15,15,15,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63", "code": "\ndef a(n): return 0 if n==0 else 1 + 2*a(int(n/2)) \n"}
{"sequence_id": "A003849", "text": "The infinite Fibonacci word (start with 0, apply 0->01, 1->0, take limit).", "sequence": "0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,1,0,0,1", "code": "\ndef fib(n):\n    \"\"\"Return the concatenation of A003849(0..F-1) where F is the smallest\n       Fibonacci number > n, so that the result contains a(n) at index n.\"\"\"\n    a, b = '10'\n    while len(b)<=n:\n        a, b = b, b + a\n    return b \n"}
{"sequence_id": "A003893", "text": "a(n) = Fibonacci(n) mod 10.", "sequence": "0,1,1,2,3,5,8,3,1,4,5,9,4,3,7,0,7,7,4,1,5,6,1,7,8,5,3,8,1,9,0,9,9,8,7,5,2,7,9,6,5,1,6,7,3,0,3,3,6,9,5,4,9,3,2,5,7,2,9,1,0,1,1,2,3,5,8,3,1,4,5,9,4,3,7,0,7,7,4,1,5,6,1,7,8,5,3,8,1,9,0,9,9,8,7,5,2,7,9,6,5,1,6,7,3", "code": "\nA003893_list, a, b, = [], 0, 1\nfor _ in range(10**3):\n    A003893_list.append(a)\n    a, b = b, (a+b) % 10 \n"}
{"sequence_id": "A003961", "text": "Completely multiplicative with a(prime(k)) = prime(k+1).", "sequence": "1,3,5,9,7,15,11,27,25,21,13,45,17,33,35,81,19,75,23,63,55,39,29,135,49,51,125,99,31,105,37,243,65,57,77,225,41,69,85,189,43,165,47,117,175,87,53,405,121,147,95,153,59,375,91,297,115,93,61,315,67,111,275,729,119", "code": "\nfrom sympy import factorint, prime, primepi, prod\ndef a(n):\n    f=factorint(n)\n    return 1 if n==1 else prod(prime(primepi(i) + 1)**f[i] for i in f)\n[a(n) for n in range(1, 11)] \n"}
{"sequence_id": "A003986", "text": "Table of x OR y, where (x,y) = (0,0), (0,1), (1,0), (0,2), (1,1), (2,0), ...", "sequence": "0,1,1,2,1,2,3,3,3,3,4,3,2,3,4,5,5,3,3,5,5,6,5,6,3,6,5,6,7,7,7,7,7,7,7,7,8,7,6,7,4,7,6,7,8,9,9,7,7,5,5,7,7,9,9,10,9,10,7,6,5,6,7,10,9,10,11,11,11,11,7,7,7,7,11,11,11,11,12,11,10,11,12,7,6,7,12,11,10,11,12,13,13,11", "code": "\nfor n in range(21):\n    print([k|(n - k) for k in range(n + 1)])\n\n"}
{"sequence_id": "A003987", "text": "Table of n XOR m (or Nim-sum of n and m) read by antidiagonals, i.e., with entries in the order (n,m) = (0,0), (0,1), (1,0), (0,2), (1,1), (2,0), ...", "sequence": "0,1,1,2,0,2,3,3,3,3,4,2,0,2,4,5,5,1,1,5,5,6,4,6,0,6,4,6,7,7,7,7,7,7,7,7,8,6,4,6,0,6,4,6,8,9,9,5,5,1,1,5,5,9,9,10,8,10,4,2,0,2,4,10,8,10,11,11,11,11,3,3,3,3,11,11,11,11,12,10,8,10,12,2,0,2,12,10,8,10,12,13,13,9,9", "code": "\nfor n in range(14):\n    print([k^(n - k) for k in range(n + 1)]) \n"}
{"sequence_id": "A004000", "text": "RATS: Reverse Add Then Sort the digits applied to previous term, starting with 1.", "sequence": "1,2,4,8,16,77,145,668,1345,6677,13444,55778,133345,666677,1333444,5567777,12333445,66666677,133333444,556667777,1233334444,5566667777,12333334444,55666667777,123333334444,556666667777,1233333334444,5566666667777,12333333334444", "code": "\nl = [0, 1]\nfor n in range(2, 51):\n    x = str(l[n - 1])\n    l.append(int(''.join(sorted(str(int(x) + int(x[::-1]))))))\nprint(l[1:]) \n"}
{"sequence_id": "A004001", "text": "Hofstadter-Conway $10000 sequence: a(n) = a(a(n-1)) + a(n-a(n-1)) with a(1) = a(2) = 1.", "sequence": "1,1,2,2,3,4,4,4,5,6,7,7,8,8,8,8,9,10,11,12,12,13,14,14,15,15,15,16,16,16,16,16,17,18,19,20,21,21,22,23,24,24,25,26,26,27,27,27,28,29,29,30,30,30,31,31,31,31,32,32,32,32,32,32,33,34,35,36,37,38,38,39,40,41,42", "code": "\ndef a004001(n):\n    A = {1: 1, 2: 1}\n    c = 1 \n    while n not in A.keys():\n        if c not in A.keys():\n            A[c] = A[A[c-1]] + A[c-A[c-1]]\n        c += 1\n    return A[n]\n\n"}
{"sequence_id": "A004009", "text": "Expansion of Eisenstein series E_4(q) (alternate convention E_2(q)); theta series of E_8 lattice.", "sequence": "1,240,2160,6720,17520,30240,60480,82560,140400,181680,272160,319680,490560,527520,743040,846720,1123440,1179360,1635120,1646400,2207520,2311680,2877120,2920320,3931200,3780240,4747680,4905600,6026880", "code": "\nfrom sympy import divisor_sigma\ndef a(n): return 1 if n == 0 else 240 * divisor_sigma(n, 3)\n[a(n) for n in range(51)]  \n"}
{"sequence_id": "A004011", "text": "Theta series of D_4 lattice; Fourier coefficients of Eisenstein series E_{gamma,2}.", "sequence": "1,24,24,96,24,144,96,192,24,312,144,288,96,336,192,576,24,432,312,480,144,768,288,576,96,744,336,960,192,720,576,768,24,1152,432,1152,312,912,480,1344,144,1008,768,1056,288,1872,576,1152,96,1368,744,1728,336", "code": "\nfrom sympy import divisors\ndef a(n): return 1 if n==0 else 24*sum(d for d in divisors(n) if d%2)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A004018", "text": "Theta series of square lattice (or number of ways of writing n as a sum of 2 squares). Often denoted by r(n) or r_2(n).", "sequence": "1,4,4,0,4,8,0,0,4,4,8,0,0,8,0,0,4,8,4,0,8,0,0,0,0,12,8,0,0,8,0,0,4,0,8,0,4,8,0,0,8,8,0,0,0,8,0,0,0,4,12,0,8,8,0,0,0,0,8,0,0,8,0,0,4,16,0,0,8,0,0,0,4,8,8,0,0,0,0,0,8,4,8,0,0,16,0,0,0,8,8,0,0,0,0,0,0,8,4,0,12,8", "code": "\nfrom sympy import factorint\ndef a(n):\n    if n == 0: return 1\n    an = 4\n    for pi, ei in factorint(n).items():\n       if pi%4 == 1: an *= ei+1\n       elif pi%4 == 3 and ei%2: return 0\n    return an\nprint([a(n) for n in range(102)]) \n"}
{"sequence_id": "A004050", "text": "Numbers of the form 2^j + 3^k, for j and k >= 0.", "sequence": "2,3,4,5,7,9,10,11,13,17,19,25,28,29,31,33,35,41,43,59,65,67,73,82,83,85,89,91,97,113,129,131,137,145,155,209,244,245,247,251,257,259,265,275,283,307,337,371,499,513,515,521,539,593,730,731,733,737,745,755", "code": "\ndef aupto(lim):\n    s, pow3 = set(), 1\n    while pow3 < lim:\n        for j in range((lim-pow3).bit_length()):\n            s.add(2**j + pow3)\n        pow3 *= 3\n    return sorted(set(s))\nprint(aupto(756)) \n"}
{"sequence_id": "A004086", "text": "Read n backwards (referred to as R(n) in many sequences).", "sequence": "0,1,2,3,4,5,6,7,8,9,1,11,21,31,41,51,61,71,81,91,2,12,22,32,42,52,62,72,82,92,3,13,23,33,43,53,63,73,83,93,4,14,24,34,44,54,64,74,84,94,5,15,25,35,45,55,65,75,85,95,6,16,26,36,46,56,66,76,86,96,7,17,27,37,47", "code": "\ndef A004086(n):\n    return int(str(n)[::-1]) \n"}
{"sequence_id": "A004094", "text": "Powers of 2 written backwards.", "sequence": "1,2,4,8,61,23,46,821,652,215,4201,8402,6904,2918,48361,86723,63556,270131,441262,882425,6758401,2517902,4034914,8068838,61277761,23445533,46880176,827712431,654534862,219078635,4281473701,8463847412", "code": "\ndef A004094(n):\n    return int(str(2**n)[::-1]) \n"}
{"sequence_id": "A004125", "text": "Sum of remainders of n mod k, for k = 1, 2, 3, ..., n.", "sequence": "0,0,1,1,4,3,8,8,12,13,22,17,28,31,36,36,51,47,64,61,70,77,98,85,103,112,125,124,151,138,167,167,184,197,218,198,233,248,269,258,297,284,325,328,339,358,403,374,414,420,449,454,505,492,529,520,553,578,635,586,645,672", "code": "\ndef a(n): return sum(n%k for k in range(1, n))\nprint([a(n) for n in range(1, 63)]) \n"}
{"sequence_id": "A004159", "text": "Sum of digits of n^2.", "sequence": "0,1,4,9,7,7,9,13,10,9,1,4,9,16,16,9,13,19,9,10,4,9,16,16,18,13,19,18,19,13,9,16,7,18,13,10,18,19,13,9,7,16,18,22,19,9,10,13,9,7,7,9,13,19,18,10,13,18,16,16,9,13,19,27,19,13,18,25,16,18,13,10,18,19,22,18,25,25,18,13", "code": "\ndef A004159(n):\n    return sum(int(d) for d in str(n*n)) \n"}
{"sequence_id": "A004167", "text": "Powers of 3 written backwards.", "sequence": "1,3,9,72,18,342,927,7812,1656,38691,94095,741771,144135,3234951,9692874,70984341,12764034,361041921,984024783,7641622611,1044876843,30235306401,90695018313,72887134149,184635924282,344906882748,9238285681452,7894847955267", "code": "\ndef A004167(n):\n    return int(str(3**n)[::-1]) \n"}
{"sequence_id": "A004185", "text": "Arrange digits of n in increasing order, then (for n>0) omit the zeros.", "sequence": "0,1,2,3,4,5,6,7,8,9,1,11,12,13,14,15,16,17,18,19,2,12,22,23,24,25,26,27,28,29,3,13,23,33,34,35,36,37,38,39,4,14,24,34,44,45,46,47,48,49,5,15,25,35,45,55,56,57,58,59,6,16,26,36,46,56,66,67,68,69,7,17,27,37,47", "code": "\ndef A004185(n):\n    return int(''.join(sorted(str(n))).replace('0','')) if n > 0 else 0 \n"}
{"sequence_id": "A004186", "text": "Arrange digits of n in decreasing order.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,11,21,31,41,51,61,71,81,91,20,21,22,32,42,52,62,72,82,92,30,31,32,33,43,53,63,73,83,93,40,41,42,43,44,54,64,74,84,94,50,51,52,53,54,55,65,75,85,95,60,61,62,63,64,65,66,76,86,96,70,71,72", "code": "\ndef a(n): return int(\"\".join(sorted(str(n), reverse=True)))\nprint([a(n) for n in range(73)]) \n"}
{"sequence_id": "A004198", "text": "Table of x AND y, where (x,y) = (0,0),(0,1),(1,0),(0,2),(1,1),(2,0),...", "sequence": "0,0,0,0,1,0,0,0,0,0,0,1,2,1,0,0,0,2,2,0,0,0,1,0,3,0,1,0,0,0,0,0,0,0,0,0,0,1,2,1,4,1,2,1,0,0,0,2,2,4,4,2,2,0,0,0,1,0,3,4,5,4,3,0,1,0,0,0,0,0,4,4,4,4,0,0,0,0,0,1,2,1,0,5,6,5,0,1,2,1,0,0,0,2,2,0,0,6,6,0,0,2,2,0,0,0,1,0", "code": "\nfor n in range(21):\n    print([k&(n - k) for k in range(n + 1)])\n\n"}
{"sequence_id": "A004215", "text": "Numbers that are the sum of 4 but no fewer nonzero squares.", "sequence": "7,15,23,28,31,39,47,55,60,63,71,79,87,92,95,103,111,112,119,124,127,135,143,151,156,159,167,175,183,188,191,199,207,215,220,223,231,239,240,247,252,255,263,271,279,284,287,295,303,311,316,319,327,335,343", "code": "\ndef valuation(n, b):\n    v = 0\n    while n > 1 and n%b == 0: n //= b; v += 1\n    return v\ndef ok(n): return n//4**valuation(n, 4)%8 == 7 \nprint(list(filter(ok, range(344)))) \n"}
{"sequence_id": "A004287", "text": "Least positive multiple of n written in base 7 using only 0 and 1.", "sequence": "0,1,11,111,11,101,111111,10,11,1011,101,10011,111111,1011,110,11001,1111,100111,1101111,111,1111,1110,11101,101011,111111,101,111001,1011,110,1111111,1011111,100111,11011,10011,100111,1010,1101111", "code": "\ndef A004287(n):\n    if n > 0:\n        for i in range(1,2**n):\n            s = bin(i)[2:]\n            if not int(s,7) % n:\n                return int(s)\n    return 0 \n"}
{"sequence_id": "A004288", "text": "Least positive multiple of n written in base 8 using only 0 and 1.", "sequence": "0,1,10,11,10,101,110,1111111,10,11,1010,10111,110,101,11111110,1111,100,10001,110,1001,1010,101011111,101110,101001,110,1011111,1010,1001,11111110,1010011,11110,11111,100,100001,100010,100111111,110", "code": "\ndef A004288(n):\n    if n > 0:\n        for i in range(1, 2**n):\n            s = bin(i)[2:]\n            if not int(s,8) % n:\n                return int(s)\n    return 0 \n"}
{"sequence_id": "A004290", "text": "Least positive multiple of n that when written in base 10 uses only 0's and 1's.", "sequence": "0,1,10,111,100,10,1110,1001,1000,111111111,10,11,11100,1001,10010,1110,10000,11101,1111111110,11001,100,10101,110,110101,111000,100,10010,1101111111,100100,1101101,1110,111011,100000,111111,111010", "code": " def A004290(n):\n    if n > 0:\n        for i in range(1,2**n):\n            x = int(bin(i)[2:])\n            if not x % n:\n                return x\n    return 0\n\n"}
{"sequence_id": "A004431", "text": "Numbers that are the sum of 2 distinct nonzero squares.", "sequence": "5,10,13,17,20,25,26,29,34,37,40,41,45,50,52,53,58,61,65,68,73,74,80,82,85,89,90,97,100,101,104,106,109,113,116,117,122,125,130,136,137,145,146,148,149,153,157,160,164,169,170,173,178,180,181,185,193,194,197", "code": "\ndef aupto(limit):\n  s = [i*i for i in range(1, int(limit**.5)+2) if i*i < limit]\n  s2 = set(a+b for i, a in enumerate(s) for b in s[i+1:] if a+b <= limit)\n  return sorted(s2)\nprint(aupto(197)) \n"}
{"sequence_id": "A004443", "text": "Nimsum n + 2.", "sequence": "2,3,0,1,6,7,4,5,10,11,8,9,14,15,12,13,18,19,16,17,22,23,20,21,26,27,24,25,30,31,28,29,34,35,32,33,38,39,36,37,42,43,40,41,46,47,44,45,50,51,48,49,54,55,52,53,58,59,56,57,62,63,60,61,66,67,64,65", "code": " for n in range(20): print(2^n) \n"}
{"sequence_id": "A004448", "text": "Nimsum n + 7.", "sequence": "7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8,23,22,21,20,19,18,17,16,31,30,29,28,27,26,25,24,39,38,37,36,35,34,33,32,47,46,45,44,43,42,41,40,55,54,53,52,51,50,49,48,63,62,61,60,59,58,57,56,71,70,69,68,67,66,65,64,79,78,77,76,75,74,73,72,87,86,85", "code": "\ndef a(n): return n^7\nprint([a(n) for n in range(83)]) \n"}
{"sequence_id": "A004488", "text": "Tersum n + n.", "sequence": "0,2,1,6,8,7,3,5,4,18,20,19,24,26,25,21,23,22,9,11,10,15,17,16,12,14,13,54,56,55,60,62,61,57,59,58,72,74,73,78,80,79,75,77,76,63,65,64,69,71,70,66,68,67,27,29,28,33,35,34,30,32,31,45,47,46,51", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a(n): return int(\"\".join([str((3 - i)%3) for i in digits(n, 3)[1:]]), 3) \n"}
{"sequence_id": "A004489", "text": "Table of tersums m + n (answers written in base 10).", "sequence": "0,1,1,2,2,2,3,0,0,3,4,4,1,4,4,5,5,5,5,5,5,6,3,3,6,3,3,6,7,7,4,7,7,4,7,7,8,8,8,8,8,8,8,8,8,9,6,6,0,6,6,0,6,6,9,10,10,7,1,1,7,1,1,7,10,10,11,11,11,2,2,2,2,2,2,11,11,11,12,9,9,12,0,0,3,0,0,12,9,9,12,13,13,10,13,13,1,4,4,1,13,13,10,13,13", "code": "\ndef T(n, m):\n  k, pow3 = 0, 1\n  while n + m > 0:\n    n, rn = divmod(n, 3)\n    m, rm = divmod(m, 3)\n    k, pow3 = k + pow3*((rn+rm)%3), pow3*3\n  return k\nprint([T(n, d-n) for d in range(14) for n in range(d+1)]) \n"}
{"sequence_id": "A004493", "text": "Tersum n + 4.", "sequence": "4,5,3,7,8,6,1,2,0,13,14,12,16,17,15,10,11,9,22,23,21,25,26,24,19,20,18,31,32,30,34,35,33,28,29,27,40,41,39,43,44,42,37,38,36,49,50,48,52,53,51,46,47,45,58,59,57,61", "code": "\ndef tersum(a, b):\n  c, pow3 = 0, 1\n  while a + b > 0:\n    a, ra = divmod(a, 3)\n    b, rb = divmod(b, 3)\n    c, pow3 = c + pow3*((ra+rb)%3), pow3*3\n  return c\ndef a(n): return tersum(n, 4)\nprint([a(n) for n in range(58)]) \n"}
{"sequence_id": "A004494", "text": "Tersum n + 5.", "sequence": "5,3,4,8,6,7,2,0,1,14,12,13,17,15,16,11,9,10,23,21,22,26,24,25,20,18,19,32,30,31,35,33,34,29,27,28,41,39,40,44,42,43,38,36,37,50,48,49,53,51,52,47,45,46,59,57,58,62,60,61,56,54,55,68,66,67,71,69", "code": " \ndef a(n): return T(n, 5)\nprint([a(n) for n in range(68)]) \n"}
{"sequence_id": "A004520", "text": "Generalized nim sum n + n in base 10.", "sequence": "0,2,4,6,8,0,2,4,6,8,20,22,24,26,28,20,22,24,26,28,40,42,44,46,48,40,42,44,46,48,60,62,64,66,68,60,62,64,66,68,80,82,84,86,88,80,82,84,86,88,0,2,4,6,8,0,2,4,6,8,20,22,24,26,28,20,22,24,26,28,40,42,44,46,48,40,42", "code": "\ndef A004520(n):\n    return int(''.join(str(2*int(d) % 10) for d in str(n))) \n"}
{"sequence_id": "A004709", "text": "Cubefree numbers: numbers that are not divisible by any cube > 1.", "sequence": "1,2,3,4,5,6,7,9,10,11,12,13,14,15,17,18,19,20,21,22,23,25,26,28,29,30,31,33,34,35,36,37,38,39,41,42,43,44,45,46,47,49,50,51,52,53,55,57,58,59,60,61,62,63,65,66,67,68,69,70,71,73,74,75,76,77,78,79,82,83,84,85", "code": "\nfrom sympy.ntheory.factor_ import core\ndef ok(n): return core(n, 3) == n\nprint(list(filter(ok, range(1, 86)))) \n"}
{"sequence_id": "A004718", "text": "The Danish composer Per N\u00f8rg\u00e5rd's \"infinity sequence\", invented in an attempt to unify in a perfect way repetition and variation: a(2n) = -a(n), a(2n+1) = a(n) + 1, a(0) = 0.", "sequence": "0,1,-1,2,1,0,-2,3,-1,2,0,1,2,-1,-3,4,1,0,-2,3,0,1,-1,2,-2,3,1,0,3,-2,-4,5,-1,2,0,1,2,-1,-3,4,0,1,-1,2,1,0,-2,3,2,-1,-3,4,-1,2,0,1,-3,4,2,-1,4,-3,-5,6,1,0,-2,3,0,1,-1,2,-2,3,1,0,3,-2,-4,5,0,1,-1,2,1,0", "code": " \nfrom functools import reduce\ndef f(s, b): return s + 1 if b == '1' else -s\ndef a(n): return reduce(f, [0] + list(bin(n)[2:]))\nprint([a(n) for n in range(86)]) \n"}
{"sequence_id": "A004718", "text": "The Danish composer Per N\u00f8rg\u00e5rd's \"infinity sequence\", invented in an attempt to unify in a perfect way repetition and variation: a(2n) = -a(n), a(2n+1) = a(n) + 1, a(0) = 0.", "sequence": "0,1,-1,2,1,0,-2,3,-1,2,0,1,2,-1,-3,4,1,0,-2,3,0,1,-1,2,-2,3,1,0,3,-2,-4,5,-1,2,0,1,2,-1,-3,4,0,1,-1,2,1,0,-2,3,2,-1,-3,4,-1,2,0,1,-3,4,2,-1,4,-3,-5,6,1,0,-2,3,0,1,-1,2,-2,3,1,0,3,-2,-4,5,0,1,-1,2,1,0", "code": " \nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef a(n): return 0 if n == 0 else (a((n-1)//2)+1 if n%2 else -a(n//2))\nprint([a(n) for n in range(86)]) \n"}
{"sequence_id": "A004720", "text": "Delete all digits '1' from the sequence of nonnegative integers.", "sequence": "0,2,3,4,5,6,7,8,9,0,2,3,4,5,6,7,8,9,20,2,22,23,24,25,26,27,28,29,30,3,32,33,34,35,36,37,38,39,40,4,42,43,44,45,46,47,48,49,50,5,52,53,54,55,56,57,58,59,60,6,62,63,64,65,66,67,68,69,70,7,72,73,74,75", "code": "\ndef A004720(n):\n    l = len(str(n-1))\n    m = (10**l-1)//9\n    k = n + l - 2 + int(n+l-1 >= m)\n    return 0 if k == m else int(str(k).replace('1','')) \n"}
{"sequence_id": "A004721", "text": "Delete all 2's from the sequence of nonnegative integers.", "sequence": "0,1,3,4,5,6,7,8,9,10,11,1,13,14,15,16,17,18,19,0,1,3,4,5,6,7,8,9,30,31,3,33,34,35,36,37,38,39,40,41,4,43,44,45,46,47,48,49,50,51,5,53,54,55,56,57,58,59,60,61,6,63,64,65,66,67,68,69,70,71,7,73,74,75", "code": "\ndef A004721(n):\n    l = len(str(n))\n    m = 2*(10**l-1)//9\n    k = n + l - int(n+l < m)\n    return 1 if k == m else int(str(k).replace('2','')) \n"}
{"sequence_id": "A004722", "text": "Delete all digits 3 from the terms of the sequence of nonnegative integers.", "sequence": "0,1,2,4,5,6,7,8,9,10,11,12,1,14,15,16,17,18,19,20,21,22,2,24,25,26,27,28,29,0,1,2,4,5,6,7,8,9,40,41,42,4,44,45,46,47,48,49,50,51,52,5,54,55,56,57,58,59,60,61,62,6,64,65,66,67,68,69,70,71,72,7,74,75,76", "code": "\ndef A004722(n):\n    l = len(str(n))\n    m = (10**l-1)//3\n    k = n + l - int(n+l < m)\n    return 2 if k == m else int(str(k).replace('3','')) \n"}
{"sequence_id": "A004723", "text": "Delete all 4's from the sequence of nonnegative integers.", "sequence": "0,1,2,3,5,6,7,8,9,10,11,12,13,1,15,16,17,18,19,20,21,22,23,2,25,26,27,28,29,30,31,32,33,3,35,36,37,38,39,0,1,2,3,5,6,7,8,9,50,51,52,53,5,55,56,57,58,59,60,61,62,63,6,65,66,67,68,69,70,71,72,73,7,75", "code": "\ndef A004723(n):\n    l = len(str(n))\n    m = 4*(10**l-1)//9\n    k = n + l - int(n+l < m)\n    return 3 if k == m else int(str(k).replace('4','')) \n"}
{"sequence_id": "A004724", "text": "Delete all 5's from the sequence of nonnegative integers.", "sequence": "0,1,2,3,4,6,7,8,9,10,11,12,13,14,1,16,17,18,19,20,21,22,23,24,2,26,27,28,29,30,31,32,33,34,3,36,37,38,39,40,41,42,43,44,4,46,47,48,49,0,1,2,3,4,6,7,8,9,60,61,62,63,64,6,66,67,68,69,70,71,72,73,74,7,76", "code": "\ndef A004724(n):\n    l = len(str(n))\n    m = 5*(10**l-1)//9\n    k = n + l - int(n+l < m)\n    return 4 if k == m else int(str(k).replace('5','')) \n"}
{"sequence_id": "A004725", "text": "Delete all 6's from the sequence of nonnegative integers.", "sequence": "0,1,2,3,4,5,7,8,9,10,11,12,13,14,15,1,17,18,19,20,21,22,23,24,25,2,27,28,29,30,31,32,33,34,35,3,37,38,39,40,41,42,43,44,45,4,47,48,49,50,51,52,53,54,55,5,57,58,59,0,1,2,3,4,5,7,8,9,70,71,72,73,74,75,7", "code": "\ndef A004725(n):\n    l = len(str(n))\n    m = 2*(10**l-1)//3\n    k = n + l - int(n+l < m)\n    return 5 if k == m else int(str(k).replace('6','')) \n"}
{"sequence_id": "A004726", "text": "Delete all 7's from the sequence of nonnegative integers.", "sequence": "0,1,2,3,4,5,6,8,9,10,11,12,13,14,15,16,1,18,19,20,21,22,23,24,25,26,2,28,29,30,31,32,33,34,35,36,3,38,39,40,41,42,43,44,45,46,4,48,49,50,51,52,53,54,55,56,5,58,59,60,61,62,63,64,65,66,6,68,69,0,1,2", "code": "\ndef A004726(n):\n    l = len(str(n))\n    m = 7*(10**l-1)//9\n    k = n + l - int(n+l < m)\n    return 6 if k == m else int(str(k).replace('7','')) \n"}
{"sequence_id": "A004727", "text": "Delete all 8's from the sequence of nonnegative integers.", "sequence": "0,1,2,3,4,5,6,7,9,10,11,12,13,14,15,16,17,1,19,20,21,22,23,24,25,26,27,2,29,30,31,32,33,34,35,36,37,3,39,40,41,42,43,44,45,46,47,4,49,50,51,52,53,54,55,56,57,5,59,60,61,62,63,64,65,66,67,6,69,70,71", "code": "\ndef A004727(n):\n    l = len(str(n))\n    m = 8*(10**l-1)//9\n    k = n + l - int(n+l < m)\n    return 7 if k == m else int(str(k).replace('8','')) \n"}
{"sequence_id": "A004728", "text": "Delete all 9's from the sequence of nonnegative integers.", "sequence": "0,1,2,3,4,5,6,7,8,10,11,12,13,14,15,16,17,18,1,20,21,22,23,24,25,26,27,28,2,30,31,32,33,34,35,36,37,38,3,40,41,42,43,44,45,46,47,48,4,50,51,52,53,54,55,56,57,58,5,60,61,62,63,64,65,66,67,68,6,70,71", "code": "\ndef A004728(n):\n    l = len(str(n))\n    m = 10**l-1\n    k = n + l - int(n+l < m)\n    return 8 if k == m else int(str(k).replace('9','')) \n"}
{"sequence_id": "A004730", "text": "Numerator of n!!/(n+1)!! (cf. A006882).", "sequence": "1,1,2,3,8,5,16,35,128,63,256,231,1024,429,2048,6435,32768,12155,65536,46189,262144,88179,524288,676039,4194304,1300075,8388608,5014575,33554432,9694845,67108864,300540195,2147483648,583401555,4294967296,2268783825", "code": "\nfrom sympy import gcd, factorial2\ndef A004730(n):\n    a, b = factorial2(n), factorial2(n+1)\n    return a//gcd(a,b) \n"}
{"sequence_id": "A004731", "text": "Denominator of n!!/(n+1)!! (cf. A006882).", "sequence": "1,1,1,2,3,8,15,16,35,128,315,256,693,1024,3003,2048,6435,32768,109395,65536,230945,262144,969969,524288,2028117,4194304,16900975,8388608,35102025,33554432,145422675,67108864", "code": "\nfrom sympy import gcd, factorial2\ndef A004731(n):\n    if n <= 1:\n        return 1\n    a, b = factorial2(n-2), factorial2(n-1)\n    return b//gcd(a,b) \n"}
{"sequence_id": "A004736", "text": "Triangle read by rows: row n lists the first n positive integers in decreasing order.", "sequence": "1,2,1,3,2,1,4,3,2,1,5,4,3,2,1,6,5,4,3,2,1,7,6,5,4,3,2,1,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,10,9,8,7,6,5,4,3,2,1,11,10,9,8,7,6,5,4,3,2,1,12,11,10,9,8,7,6,5,4,3,2,1,13,12,11,10,9,8,7,6,5,4,3,2,1,14,13,12,11,10,9", "code": "\ndef agen(rows):\n    for n in range(1, rows+1): yield from range(n, 0, -1)\nprint([an for an in agen(13)]) \n"}
{"sequence_id": "A004748", "text": "Binary expansion contains 101.", "sequence": "5,10,11,13,20,21,22,23,26,27,29,37,40,41,42,43,44,45,46,47,52,53,54,55,58,59,61,69,74,75,77,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,101,104,105,106,107,108,109,110,111,116,117,118,119,122", "code": "\ni=j=0\nwhile j<=100:\n    if \"101\" in bin(i)[2:]:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A004749", "text": "Numbers whose binary expansion contains the substring '110'.", "sequence": "6,12,13,14,22,24,25,26,27,28,29,30,38,44,45,46,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,70,76,77,78,86,88,89,90,91,92,93,94,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113", "code": "\ni=j=0\nwhile j<=500:\n    if \"110\" in bin(i)[2:]:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A004750", "text": "Numbers whose binary expansion contains the substring '011'.", "sequence": "11,19,22,23,27,35,38,39,43,44,45,46,47,51,54,55,59,67,70,71,75,76,77,78,79,83,86,87,88,89,90,91,92,93,94,95,99,102,103,107,108,109,110,111,115,118,119,123,131,134,135,139,140,141,142,143,147,150", "code": "\ni=j=0\nwhile j<=100:\n    if \"011\" in bin(i)[2:]:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A004751", "text": "Binary expansion contains 001.", "sequence": "9,17,18,19,25,33,34,35,36,37,38,39,41,49,50,51,57,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,81,82,83,89,97,98,99,100,101,102,103,105,113,114,115,121,129,130,131,132,133,134,135,136,137,138,139", "code": "\ni=j=0\nwhile j<=100:\n    if \"001\" in bin(i)[2:]:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A004752", "text": "Binary expansion contains 010.", "sequence": "10,18,20,21,26,34,36,37,40,41,42,43,50,52,53,58,66,68,69,72,73,74,75,80,81,82,83,84,85,86,87,90,98,100,101,104,105,106,107,114,116,117,122,130,132,133,136,137,138,139,144,145,146,147,148,149,150", "code": "\ni=j=0\nwhile j<=100:\n    if \"010\" in bin(i)[2:]:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A004755", "text": "Binary expansion starts 11.", "sequence": "3,6,7,12,13,14,15,24,25,26,27,28,29,30,31,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122", "code": "\nf = open('b004755.txt', 'w')\nlo = 3\nhi = 4\ni = 1\nwhile i<16384:\n    for x in range(lo,hi):\n        f.write(str(i)+\" \"+str(x)+\"\\n\")\n        i += 1\n    lo <<= 1\n    hi <<= 1\n\n"}
{"sequence_id": "A004767", "text": "a(n) = 4*n + 3.", "sequence": "3,7,11,15,19,23,27,31,35,39,43,47,51,55,59,63,67,71,75,79,83,87,91,95,99,103,107,111,115,119,123,127,131,135,139,143,147,151,155,159,163,167,171,175,179,183,187,191,195,199,203,207,211,215,219,223", "code": " for n in range(0,50): print(4*n+3, end=', ') \n"}
{"sequence_id": "A004768", "text": "Binary expansion ends 001.", "sequence": "9,17,25,33,41,49,57,65,73,81,89,97,105,113,121,129,137,145,153,161,169,177,185,193,201,209,217,225,233,241,249,257,265,273,281,289,297,305,313,321,329,337,345,353,361,369,377,385,393,401,409,417,425,433,441,449,457,465,473,481,489", "code": "\ndef a(n): return 8*n + 9\nprint([a(n) for n in range(61)]) \n"}
{"sequence_id": "A004922", "text": "Floor of n*phi^7, where phi is the golden ratio, A001622.", "sequence": "0,29,58,87,116,145,174,203,232,261,290,319,348,377,406,435,464,493,522,551,580,609,638,667,696,725,754,783,812,841,871,900,929,958,987,1016,1045,1074,1103,1132,1161,1190,1219,1248,1277,1306,1335,1364", "code": "\nfrom sympy import sqrt\nphi = (1 + sqrt(5))/2\nfor n in range(0,101): print(int(n*phi**7), end=', ') \n"}
{"sequence_id": "A005001", "text": "a(0) = 0; for n>0, a(n) = Sum_k={0..n-1} Bell(k), where the Bell numbers Bell(k) are given in A000110.", "sequence": "0,1,2,4,9,24,76,279,1156,5296,26443,142418,820988,5034585,32679022,223578344,1606536889,12086679036,94951548840,777028354999,6609770560056,58333928795428,533203744952179,5039919483399502,49191925338483848,495150794633289137", "code": "\n\nfrom itertools import accumulate\nA005001_list, blist, a, b = [0,1,2], [1], 2, 1\nfor _ in range(30):\n....blist = list(accumulate([b]+blist))\n....b = blist[-1]\n....a += b\n....A005001_list.append(a) \n"}
{"sequence_id": "A005046", "text": "Number of partitions of a 2n-set into even blocks.", "sequence": "1,1,4,31,379,6556,150349,4373461,156297964,6698486371,337789490599,19738202807236,1319703681935929,99896787342523081,8484301665702298804,802221679220975886631,83877585692383961052499,9640193854278691671399436,1211499609050804749310115589", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef a(n): return 1 if n==0 else sum(binomial(2*n - 1, 2*k - 1)*a(n - k) for k in range(1, n + 1))\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A005061", "text": "a(n) = 4^n - 3^n.", "sequence": "0,1,7,37,175,781,3367,14197,58975,242461,989527,4017157,16245775,65514541,263652487,1059392917,4251920575,17050729021,68332056247,273715645477,1096024843375,4387586157901,17560804984807", "code": "\ndef a(n): return 4**n - 3**n\nprint([a(n) for n in range(23)]) \n"}
{"sequence_id": "A005063", "text": "Sum of squares of primes dividing n.", "sequence": "0,4,9,4,25,13,49,4,9,29,121,13,169,53,34,4,289,13,361,29,58,125,529,13,25,173,9,53,841,38,961,4,130,293,74,13,1369,365,178,29,1681,62,1849,125,34,533,2209,13,49,29,298,173,2809,13,146,53,370,845,3481,38,3721", "code": "\nfrom sympy import primefactors\ndef a(n): return sum(p**2 for p in primefactors(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A005064", "text": "Sum of cubes of primes dividing n.", "sequence": "0,8,27,8,125,35,343,8,27,133,1331,35,2197,351,152,8,4913,35,6859,133,370,1339,12167,35,125,2205,27,351,24389,160,29791,8,1358,4921,468,35,50653,6867,2224,133,68921,378,79507,1339,152,12175,103823,35,343,133,4940,2205,148877,35,1456,351,6886,24397,205379,160", "code": "\nfrom sympy import primefactors\ndef a(n): return sum(p**3 for p in primefactors(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A005065", "text": "Sum of 4th powers of primes dividing n.", "sequence": "0,16,81,16,625,97,2401,16,81,641,14641,97,28561,2417,706,16,83521,97,130321,641,2482,14657,279841,97,625,28577,81,2417,707281,722,923521,16,14722,83537,3026,97,1874161,130337,28642,641,2825761,2498,3418801,14657,706,279857,4879681,97,2401,641,83602,28577,7890481,97", "code": "\nfrom sympy import primefactors\ndef a(n): return sum(p**4 for p in primefactors(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A005066", "text": "Sum of squares of odd primes dividing n.", "sequence": "0,0,9,0,25,9,49,0,9,25,121,9,169,49,34,0,289,9,361,25,58,121,529,9,25,169,9,49,841,34,961,0,130,289,74,9,1369,361,178,25,1681,58,1849,121,34,529,2209,9,49,25,298,169,2809,9,146,49,370,841,3481,34,3721,961,58,0,194,130,4489,289,538,74,5041,9,5329,1369", "code": "\nfrom sympy import primefactors\ndef a(n): return sum(p**2 for p in primefactors(n) if p % 2)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A005070", "text": "Sum of primes = 1 (mod 3) dividing n.", "sequence": "0,0,0,0,0,0,7,0,0,0,0,0,13,7,0,0,0,0,19,0,7,0,0,0,0,13,0,7,0,0,31,0,0,0,7,0,37,19,13,0,0,7,43,0,0,0,0,0,7,0,0,13,0,0,0,7,19,0,0,0,61,31,7,0,13,0,67,0,0,7,0,0,73,37,0,19,7,13,79,0,0,0,0,7,0,43,0,0,0,0,20,0,31,0,19,0,97,7,0,0,0,0,103,13,7,0,0,0,109,0,37", "code": "\nfrom sympy import factorint, primefactors\ndef a028234(n):\n    f = factorint(n)\n    m = min(f)\n    return 1 if n==1 else n/(m**f[m])\ndef a020639(n): return min(primefactors(n)) if n>1 else 1\ndef a(n): return 0 if n==1 else a(a028234(n)) + a020639(n)*(1*(a020639(n)%3==1)) \n"}
{"sequence_id": "A005090", "text": "Number of primes == 2 mod 3 dividing n.", "sequence": "0,1,0,1,1,1,0,1,0,2,1,1,0,1,1,1,1,1,0,2,0,2,1,1,1,1,0,1,1,2,0,1,1,2,1,1,0,1,0,2,1,1,0,2,1,2,1,1,0,2,1,1,1,1,2,1,0,2,1,2,0,1,0,1,1,2,0,2,1,2,1,1,0,1,1,1,1,1,0,2,0,2,1,1,2,1,1,2,1,2,0,2,0,2,1,1,0,1,1,2,1,2,0,1,1,2,1,1,0,3,0,1,1,1,2,2,0,2,1,2", "code": "\nfrom sympy import primefactors\ndef a(n): return sum(1 for p in primefactors(n) if p%3==2)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A005093", "text": "Sum of squares of Fibonacci numbers 1,2,3,5,... that divide n.", "sequence": "1,5,10,5,26,14,1,69,10,30,1,14,170,5,35,69,1,14,1,30,451,5,1,78,26,174,10,5,1,39,1,69,10,1161,26,14,1,5,179,94,1,455,1,5,35,5,1,78,1,30,10,174,1,14,3051,69,10,5,1,39", "code": "\nfrom sympy import divisors, fibonacci\nl = [fibonacci(n) for n in range(1, 21)]\ndef a(n):\n    return sum(i**2 for i in divisors(n) if i in l)\nprint([a(n) for n in range(1, 101)])  \n"}
{"sequence_id": "A005100", "text": "Deficient numbers: numbers k such that sigma(k) < 2k.", "sequence": "1,2,3,4,5,7,8,9,10,11,13,14,15,16,17,19,21,22,23,25,26,27,29,31,32,33,34,35,37,38,39,41,43,44,45,46,47,49,50,51,52,53,55,57,58,59,61,62,63,64,65,67,68,69,71,73,74,75,76,77,79,81,82,83,85,86", "code": "\nfrom sympy import divisors\ndef ok(n): return sum(divisors(n)) < 2*n\nprint(list(filter(ok, range(1, 87)))) \n"}
{"sequence_id": "A005101", "text": "Abundant numbers (sum of divisors of m exceeds 2m).", "sequence": "12,18,20,24,30,36,40,42,48,54,56,60,66,70,72,78,80,84,88,90,96,100,102,104,108,112,114,120,126,132,138,140,144,150,156,160,162,168,174,176,180,186,192,196,198,200,204,208,210,216,220,222,224,228,234,240,246,252,258,260,264,270", "code": "\nfrom sympy import divisors\ndef ok(n): return sum(divisors(n)) > 2*n\nprint(list(filter(ok, range(1, 271)))) \n"}
{"sequence_id": "A005117", "text": "Squarefree numbers: numbers that are not divisible by a square greater than 1.", "sequence": "1,2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30,31,33,34,35,37,38,39,41,42,43,46,47,51,53,55,57,58,59,61,62,65,66,67,69,70,71,73,74,77,78,79,82,83,85,86,87,89,91,93,94,95,97,101,102,103,105,106,107,109,110,111,113", "code": "\nfrom sympy.ntheory.factor_ import core\ndef ok(n): return core(n, 2) == n\nprint(list(filter(ok, range(1, 114)))) \n"}
{"sequence_id": "A005132", "text": "Recam\u00e1n's sequence (or Recaman's sequence): a(0) = 0; for n > 0, a(n) = a(n-1) - n if nonnegative and not already in the sequence, otherwise a(n) = a(n-1) + n.", "sequence": "0,1,3,6,2,7,13,20,12,21,11,22,10,23,9,24,8,25,43,62,42,63,41,18,42,17,43,16,44,15,45,14,46,79,113,78,114,77,39,78,38,79,37,80,36,81,35,82,34,83,33,84,32,85,31,86,30,87,29,88,28,89,27,90,26,91,157,224,156,225,155", "code": "\nl=[0]\nfor n in range(1, 101):\n    x=l[n - 1] - n\n    if x>0 and not x in l: l+=[x, ]\n    else: l+=[l[n - 1] + n]\nl \n(Python3)\ndef recaman(n):\n  seq = []\n  for i in range(n):\n    if(i == 0): x = 0\n    else: x = seq[i-1]-i\n    if(x>=0 and x not in seq): seq+=[x]\n    else: seq+=[seq[i-1]+i]\n  return seq\nprint(recaman(1000)) \n"}
{"sequence_id": "A005150", "text": "Look and Say sequence: describe the previous term! (method A - initial term is 1).", "sequence": "1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,13211311123113112211,11131221133112132113212221,3113112221232112111312211312113211,1321132132111213122112311311222113111221131221,11131221131211131231121113112221121321132132211331222113112211,311311222113111231131112132112311321322112111312211312111322212311322113212221", "code": "\ndef A005150(n):\n    p = \"1\"\n    seq = [1]\n    while (n > 1):\n        q = ''\n        idx = 0 \n        l = len(p) \n        while idx < l:\n            start = idx\n            idx = idx + 1\n            while idx < l and p[idx] == p[start]:\n                idx = idx + 1\n            q = q + str(idx-start) + p[start]\n        n, p = n - 1, q\n        seq.append(int(p))\n    return seq\n\n"}
{"sequence_id": "A005150", "text": "Look and Say sequence: describe the previous term! (method A - initial term is 1).", "sequence": "1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,13211311123113112211,11131221133112132113212221,3113112221232112111312211312113211,1321132132111213122112311311222113111221131221,11131221131211131231121113112221121321132132211331222113112211,311311222113111231131112132112311321322112111312211312111322212311322113212221", "code": "\ndef A005150(n):\n    seq = [1] + [None] * (n - 1) \n    def say(s):\n        acc = '' \n        while len(s) > 0:\n            i = 0\n            c = s[0] \n            while (i < len(s) and s[i] == c): \n                i += 1\n            acc += str(i) + c \n            if i == len(s):\n                break \n            else:\n                s = s[i:] \n        return acc\n    for i in range(1, n):\n        seq[i] = int(say(str(seq[i-1])))\n    return seq\n\n"}
{"sequence_id": "A005150", "text": "Look and Say sequence: describe the previous term! (method A - initial term is 1).", "sequence": "1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,13211311123113112211,11131221133112132113212221,3113112221232112111312211312113211,1321132132111213122112311311222113111221131221,11131221131211131231121113112221121321132132211331222113112211,311311222113111231131112132112311321322112111312211312111322212311322113212221", "code": "\n\ndef sign(n): return cmp(n, 0)\ndef say(a):\n    r = 0\n    p = 0\n    while a > 0:\n        c = 3 - sign((a % 100) % 11) - sign((a % 1000) % 111)\n        r += (10 * c + (a % 10)) * 10**(2*p)\n        a /= 10**c\n        p += 1\n    return r\na = 1\nfor i in range(1, 26):\n    print(i, a)\n    a = say(a)\n\n"}
{"sequence_id": "A005150", "text": "Look and Say sequence: describe the previous term! (method A - initial term is 1).", "sequence": "1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,13211311123113112211,11131221133112132113212221,3113112221232112111312211312113211,1321132132111213122112311311222113111221131221,11131221131211131231121113112221121321132132211331222113112211,311311222113111231131112132112311321322112111312211312111322212311322113212221", "code": "\nimport re\ndef lookandsay(limit, sequence = 1):\n    if limit > 1:\n        return lookandsay(limit-1, \"\".join([str(len(match.group()))+match.group()[0] for matchNum, match in enumerate(re.finditer(r\"(\\w)\\1*\", str(sequence)))]))\n    else:\n        return sequence\n\n\n"}
{"sequence_id": "A005150", "text": "Look and Say sequence: describe the previous term! (method A - initial term is 1).", "sequence": "1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,13211311123113112211,11131221133112132113212221,3113112221232112111312211312113211,1321132132111213122112311311222113111221131221,11131221131211131231121113112221121321132132211331222113112211,311311222113111231131112132112311321322112111312211312111322212311322113212221", "code": "\nimport itertools\nx = \"1\"\nfor i in range(20):\n    print(x)\n    x = ''.join(str(len(list(g)))+k for k,g in itertools.groupby(x))\n\n"}
{"sequence_id": "A005151", "text": "Summarize the previous term (digits in increasing order), starting with a(1) = 1.", "sequence": "1,11,21,1112,3112,211213,312213,212223,114213,31121314,41122314,31221324,21322314,21322314,21322314,21322314,21322314,21322314,21322314,21322314,21322314,21322314,21322314,21322314,21322314,21322314", "code": "\nfrom itertools import accumulate, groupby, repeat\ndef summarize(n, _):\n  return int(\"\".join(str(len(list(g)))+k for k, g in groupby(sorted(str(n)))))\ndef aupton(nn): return list(accumulate(repeat(1, nn+1), summarize))\nprint(aupton(25)) \n"}
{"sequence_id": "A005165", "text": "Alternating factorials: n! - (n-1)! + (n-2)! - ... 1!.", "sequence": "0,1,1,5,19,101,619,4421,35899,326981,3301819,36614981,442386619,5784634181,81393657019,1226280710981,19696509177019,335990918918981,6066382786809019,115578717622022981,2317323290554617019,48773618881154822981", "code": "\na = 0\nf = 1\nfor n in range(1, 33):\n    print(a, end=\",\")\n    f *= n\n    a = f - a\n\n"}
{"sequence_id": "A005171", "text": "Characteristic function of nonprimes: 0 if n is prime, else 1.", "sequence": "1,0,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1", "code": "\nfrom sympy import isprime\ndef a(n): return int(not isprime(n))\nprint([a(n) for n in range(1, 106)]) \n"}
{"sequence_id": "A005181", "text": "a(n) = ceiling(exp((n-1)/2)).", "sequence": "1,1,2,3,5,8,13,21,34,55,91,149,245,404,666,1097,1809,2981,4915,8104,13360,22027,36316,59875,98716,162755,268338,442414,729417,1202605,1982760,3269018,5389699,8886111,14650720,24154953,39824785,65659970,108254988,178482301", "code": "\nimport math\nfor n in range(99):\n    print(str(int(math.ceil(math.e**((n-1)*0.5)))), end=', ')\n\n"}
{"sequence_id": "A005185", "text": "Hofstadter Q-sequence: a(1) = a(2) = 1; a(n) = a(n-a(n-1)) + a(n-a(n-2)) for n > 2.", "sequence": "1,1,2,3,3,4,5,5,6,6,6,8,8,8,10,9,10,11,11,12,12,12,12,16,14,14,16,16,16,16,20,17,17,20,21,19,20,22,21,22,23,23,24,24,24,24,24,32,24,25,30,28,26,30,30,28,32,30,32,32,32,32,40,33,31,38,35,33,39,40,37,38,40,39", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef a(n):\n    if n < 3: return 1\n    return a(n - a(n-1)) + a(n - a(n-2))\nprint([a(n) for n in range(1, 75)]) \n"}
{"sequence_id": "A005186", "text": "a(n) is the number of integers m which take n steps to reach 1 in '3x+1' problem.", "sequence": "1,1,1,1,1,2,2,4,4,6,6,8,10,14,18,24,29,36,44,58,72,91,113,143,179,227,287,366,460,578,732,926,1174,1489,1879,2365,2988,3780,4788,6049,7628,9635,12190,15409,19452,24561,31025,39229,49580,62680,79255,100144", "code": "\ndef search(x,d,lst):\n    while d>0:\n        lst[d]+=1\n        if x%6==4 and x>4:\n            search(x//3,d-1,lst)\n        x*=2\n        d-=1\n    lst[d]+=1\ndef A005186_list(n_max):\n    lst=[0]*(n_max+1)\n    search(1,n_max,lst)\n    return lst[::-1]\n\n"}
{"sequence_id": "A005187", "text": "a(n) = a(floor(n/2)) + n; also denominators in expansion of 1/sqrt(1-x) are 2^a(n); also 2n - number of 1's in binary expansion of 2n.", "sequence": "0,1,3,4,7,8,10,11,15,16,18,19,22,23,25,26,31,32,34,35,38,39,41,42,46,47,49,50,53,54,56,57,63,64,66,67,70,71,73,74,78,79,81,82,85,86,88,89,94,95,97,98,101,102,104,105,109,110,112,113,116,117,119,120,127,128", "code": "\ndef A005187(n): return 2*n-bin(n).count('1') \n"}
{"sequence_id": "A005188", "text": "Armstrong (or pluperfect, or Plus Perfect, or narcissistic) numbers: m-digit positive numbers equal to sum of the m-th powers of their digits.", "sequence": "1,2,3,4,5,6,7,8,9,153,370,371,407,1634,8208,9474,54748,92727,93084,548834,1741725,4210818,9800817,9926315,24678050,24678051,88593477,146511208,472335975,534494836,912985153,4679307774,32164049650,32164049651", "code": "\nfrom itertools import combinations_with_replacement\nA005188_list = []\nfor k in range(1,10):\n    a = [i**k for i in range(10)]\n    for b in combinations_with_replacement(range(10),k):\n        x = sum(map(lambda y:a[y],b))\n        if x > 0 and tuple(int(d) for d in sorted(str(x))) == b:\n            A005188_list.append(x)\nA005188_list = sorted(A005188_list) \n"}
{"sequence_id": "A005237", "text": "Numbers n such that n and n+1 have the same number of divisors.", "sequence": "2,14,21,26,33,34,38,44,57,75,85,86,93,94,98,104,116,118,122,133,135,141,142,145,147,158,171,177,189,201,202,205,213,214,217,218,230,231,242,243,244,253,285,296,298,301,302,326,332,334,344,374,375,381,387", "code": "\nfrom sympy import divisor_count as tau\n[n for n in range(1,401) if tau(n) == tau(n+1)] \n"}
{"sequence_id": "A005318", "text": "Conway-Guy sequence: a(n + 1) = 2a(n) - a(n - floor( 1/2 + sqrt(2n) )).", "sequence": "0,1,2,4,7,13,24,44,84,161,309,594,1164,2284,4484,8807,17305,34301,68008,134852,267420,530356,1051905,2095003,4172701,8311101,16554194,32973536,65679652,130828948,261127540,521203175,1040311347,2076449993", "code": "\nfrom sympy import sqrt, floor\ndef a(n): return n if n<2 else 2*a(n - 1) - a(n - floor(sqrt(2)*sqrt(n - 1) + 1/2) - 1) \n"}
{"sequence_id": "A005349", "text": "Niven (or Harshad) numbers: numbers that are divisible by the sum of their digits.", "sequence": "1,2,3,4,5,6,7,8,9,10,12,18,20,21,24,27,30,36,40,42,45,48,50,54,60,63,70,72,80,81,84,90,100,102,108,110,111,112,114,117,120,126,132,133,135,140,144,150,152,153,156,162,171,180,190,192,195,198,200,201,204", "code": "\nA005349 = [n for n in range(1,10**6) if not n % sum([int(d) for d in str(n)])] \n"}
{"sequence_id": "A005351", "text": "Base -2 representation for n regarded as base 2, then evaluated.", "sequence": "0,1,6,7,4,5,26,27,24,25,30,31,28,29,18,19,16,17,22,23,20,21,106,107,104,105,110,111,108,109,98,99,96,97,102,103,100,101,122,123,120,121,126,127,124,125,114,115,112,113,118,119,116,117,74,75,72,73,78,79,76", "code": "\ndef A005351(n):\n    s, q = '', n\n    while q >= 2 or q < 0:\n        q, r = divmod(q, -2)\n        if r < 0:\n            q += 1\n            r += 2\n        s += str(r)\n    return int(str(q)+s[::-1],2) \n"}
{"sequence_id": "A005383", "text": "Numbers n such that both n and (n+1)/2 are primes.", "sequence": "3,5,13,37,61,73,157,193,277,313,397,421,457,541,613,661,673,733,757,877,997,1093,1153,1201,1213,1237,1321,1381,1453,1621,1657,1753,1873,1933,1993,2017,2137,2341,2473,2557,2593,2797,2857,2917,3061,3217,3253", "code": "\nfrom sympy import isprime\n[n for n in range(3, 5000) if isprime(n) and isprime((n + 1)/2)]\n\n"}
{"sequence_id": "A005384", "text": "Sophie Germain primes p: 2p+1 is also prime.", "sequence": "2,3,5,11,23,29,41,53,83,89,113,131,173,179,191,233,239,251,281,293,359,419,431,443,491,509,593,641,653,659,683,719,743,761,809,911,953,1013,1019,1031,1049,1103,1223,1229,1289,1409,1439,1451,1481,1499,1511,1559", "code": "\nfrom sympy import isprime, nextprime\ndef ok(p): return isprime(2*p+1)\ndef aupto(limit): \n  alst, p = [], 2\n  while p <= limit:\n    if ok(p): alst.append(p)\n    p = nextprime(p)\n  return alst\nprint(aupto(1559)) \n"}
{"sequence_id": "A005385", "text": "Safe primes p: (p-1)/2 is also prime.", "sequence": "5,7,11,23,47,59,83,107,167,179,227,263,347,359,383,467,479,503,563,587,719,839,863,887,983,1019,1187,1283,1307,1319,1367,1439,1487,1523,1619,1823,1907,2027,2039,2063,2099,2207,2447,2459,2579,2819,2879,2903,2963", "code": "\nfrom sympy import isprime, primerange\ndef aupto(limit):\n  alst = []\n  for p in primerange(1, limit+1):\n    if isprime((p-1)//2): alst.append(p)\n  return alst\nprint(aupto(2963)) \n"}
{"sequence_id": "A005408", "text": "The odd numbers: a(n) = 2*n + 1.", "sequence": "1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99,101,103,105,107,109,111,113,115,117,119,121,123,125,127,129,131", "code": " a=lambda n: 2*n+1 \n"}
{"sequence_id": "A005487", "text": "Starts 0, 4 and contains no 3-term arithmetic progression.", "sequence": "0,4,5,7,11,12,16,23,26,31,33,37,38,44,49,56,73,78,80,85,95,99,106,124,128,131,136,143,169,188,197,203,220,221,226,227,238,247,259,269,276,284,287,302,308,310,313,319,337,385,392,397,422,434,455,466,470", "code": "\nA005487_list = [0,4]\nfor i in range(101-2):\n    n, flag = A005487_list[-1]+1, False\n    while True:\n        for j in range(i+1,0,-1):\n            m = 2*A005487_list[j]-n\n            if m in A005487_list:\n                break\n            if m < A005487_list[0]:\n                flag = True\n                break\n        else:\n            A005487_list.append(n)\n            break\n        if flag:\n            A005487_list.append(n)\n            break\n        n += 1 \n"}
{"sequence_id": "A005493", "text": "2-Bell numbers: a(n) = number of partitions of [n+1] with a distinguished block.", "sequence": "1,3,10,37,151,674,3263,17007,94828,562595,3535027,23430840,163254885,1192059223,9097183602,72384727657,599211936355,5150665398898,45891416030315,423145657921379,4031845922290572,39645290116637023,401806863439720943,4192631462935194064", "code": "\n\nfrom itertools import accumulate\nA005493_list, blist, b = [], [1], 1\nfor _ in range(1001):\n    blist = list(accumulate([b]+blist))\n    b = blist[-1]\n    A005493_list.append(blist[-2])\n\n"}
{"sequence_id": "A005520", "text": "Smallest number of complexity n: smallest number requiring n 1's to build using + and *.", "sequence": "1,2,3,4,5,7,10,11,17,22,23,41,47,59,89,107,167,179,263,347,467,683,719,1223,1438,1439,2879,3767,4283,6299,10079,11807,15287,21599,33599,45197,56039,81647,98999,163259,203999,241883,371447,540539,590399,907199", "code": "\ndef aupton(nn):\n  alst, R = [1], {0: {1}} \n  for n in range(1, nn):\n    R[n]  = set(a+b for i in range(n//2+1) for a in R[i] for b in R[n-1-i])\n    R[n] |= set(a*b for i in range(n//2+1) for a in R[i] for b in R[n-1-i])\n    alst.append(min(R[n] - R[n-1]))\n  return alst\nprint(aupton(35)) \n"}
{"sequence_id": "A005528", "text": "St\u00f8rmer numbers or arc-cotangent irreducible numbers: numbers k such that the largest prime factor of k^2 + 1 is >= 2*k.", "sequence": "1,2,4,5,6,9,10,11,12,14,15,16,19,20,22,23,24,25,26,27,28,29,33,34,35,36,37,39,40,42,44,45,48,49,51,52,53,54,56,58,59,60,61,62,63,64,65,66,67,69,71,74,77,78,79,80,81,82,84,85,86,87,88,89,90,92,94,95,96", "code": "\nfrom sympy import factorint\ndef ok(n): return max(factorint(n*n + 1)) >= 2*n\nprint(list(filter(ok, range(1, 97)))) \n"}
{"sequence_id": "A005558", "text": "a(n) is the number of n-step walks on square lattice such that 0 <= y <= x at each step.", "sequence": "1,1,3,6,20,50,175,490,1764,5292,19404,60984,226512,736164,2760615,9202050,34763300,118195220,449141836,1551580888,5924217936,20734762776,79483257308,281248448936,1081724803600,3863302870000,14901311070000,53644719852000", "code": "\nfrom sympy import ceiling as c, binomial\ndef a(n):\n    return binomial(n + 1, c(n/2))*binomial(n, n//2) - binomial(n + 1, c((n - 1)/2))*binomial(n, (n - 1)//2)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A005589", "text": "Number of letters in the US English name of n, excluding spaces and hyphens.", "sequence": "4,3,3,5,4,4,3,5,5,4,3,6,6,8,8,7,7,9,8,8,6,9,9,11,10,10,9,11,11,10,6,9,9,11,10,10,9,11,11,10,5,8,8,10,9,9,8,10,10,9,5,8,8,10,9,9,8,10,10,9,5,8,8,10,9,9,8,10,10,9,7,10,10,12,11,11,10,12,12,11,6,9,9,11", "code": "\nfrom num2words import num2words\ndef a(n):\n    x = num2words(n).replace(' and ', '')\n    l = [chr(i) for i in range(97, 123)]\n    return sum(1 for i in x if i in l)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A005590", "text": "a(0) = 0, a(1) = 1, a(2n) = a(n), a(2n+1) = a(n+1) - a(n).", "sequence": "0,1,1,0,1,-1,0,1,1,-2,-1,1,0,1,1,0,1,-3,-2,1,-1,2,1,-1,0,1,1,0,1,-1,0,1,1,-4,-3,1,-2,3,1,-2,-1,3,2,-1,1,-2,-1,1,0,1,1,0,1,-1,0,1,1,-2,-1,1,0,1,1,0,1,-5,-4,1,-3,4,1,-3,-2,5,3,-2,1,-3,-2,1,-1,4,3,-1,2,-3,-1,2,1,-3,-2,1,-1,2,1,-1,0,1,1,0,1,-1,0,1,1", "code": "\nl=[0, 1]\nfor n in range(2, 101):\n    l.append(l[n//2] if n%2==0 else l[(n + 1)//2] - l[(n - 1)//2])\nprint(l) \n"}
{"sequence_id": "A005728", "text": "Number of fractions in Farey series of order n.", "sequence": "1,2,3,5,7,11,13,19,23,29,33,43,47,59,65,73,81,97,103,121,129,141,151,173,181,201,213,231,243,271,279,309,325,345,361,385,397,433,451,475,491,531,543,585,605,629,651,697,713,755,775,807,831,883,901,941,965", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A005728(n): \n    if n == 0:\n        return 1\n    c, j = -2, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(2*A005728(k1)-3)\n        j, k1 = j2, n//j2\n    return (n*(n-1)-c+j)//2 \n"}
{"sequence_id": "A005807", "text": "Sum of adjacent Catalan numbers.", "sequence": "2,3,7,19,56,174,561,1859,6292,21658,75582,266798,950912,3417340,12369285,45052515,165002460,607283490,2244901890,8331383610,31030387440,115948830660,434542177290,1632963760974,6151850548776", "code": "\nfrom __future__ import division\nA005807_list, b = [], 2\nfor n in range(10**3):\n    A005807_list.append(b)\n    b = b*(4*n+2)*(5*n+9)//((n+3)*(5*n+4)) \n"}
{"sequence_id": "A005811", "text": "Number of runs in binary expansion of n (n>0); number of 1's in Gray code for n.", "sequence": "0,1,2,1,2,3,2,1,2,3,4,3,2,3,2,1,2,3,4,3,4,5,4,3,2,3,4,3,2,3,2,1,2,3,4,3,4,5,4,3,4,5,6,5,4,5,4,3,2,3,4,3,4,5,4,3,2,3,4,3,2,3,2,1,2,3,4,3,4,5,4,3,4,5,6,5,4,5,4,3,4,5,6,5,6,7,6,5,4,5,6,5,4,5", "code": "\ndef a(n): return bin(n^(n>>1))[2:].count(\"1\") \n"}
{"sequence_id": "A005812", "text": "Weight of balanced ternary representation of n.", "sequence": "0,1,2,1,2,3,2,3,2,1,2,3,2,3,4,3,4,3,2,3,4,3,4,3,2,3,2,1,2,3,2,3,4,3,4,3,2,3,4,3,4,5,4,5,4,3,4,5,4,5,4,3,4,3,2,3,4,3,4,5,4,5,4,3,4,5,4,5,4,3,4,3,2,3,4,3,4,3,2,3,2,1,2,3,2,3,4,3,4,3,2,3,4,3,4,5,4,5,4,3,4,5,4,5,4,3", "code": "\ndef a(n):\n    s=0\n    x=0\n    while n>0:\n        x=n%3\n        n//=3\n        if x==2:\n            x=-1\n            n+=1\n        if x!=0: s+=1\n    return s\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A005823", "text": "Numbers whose ternary expansion contains no 1's.", "sequence": "0,2,6,8,18,20,24,26,54,56,60,62,72,74,78,80,162,164,168,170,180,182,186,188,216,218,222,224,234,236,240,242,486,488,492,494,504,506,510,512,540,542,546,548,558,560,564,566,648,650,654,656,666,668,672,674", "code": "\ndef A005823(n):\n     return 2*int(format(n-1,'b'),3) \n"}
{"sequence_id": "A005836", "text": "Numbers n whose base 3 representation contains no 2.", "sequence": "0,1,3,4,9,10,12,13,27,28,30,31,36,37,39,40,81,82,84,85,90,91,93,94,108,109,111,112,117,118,120,121,243,244,246,247,252,253,255,256,270,271,273,274,279,280,282,283,324,325,327,328,333,334,336,337,351,352", "code": "\ndef A005836(n):\n    return int(format(n-1,'b'),3) \n"}
{"sequence_id": "A005898", "text": "Centered cube numbers: n^3 + (n+1)^3.", "sequence": "1,9,35,91,189,341,559,855,1241,1729,2331,3059,3925,4941,6119,7471,9009,10745,12691,14859,17261,19909,22815,25991,29449,33201,37259,41635,46341,51389,56791,62559,68705,75241,82179,89531,97309,105525", "code": "\nA005898_list, m = [], [12, -6, 2, 1]\nfor _ in range(10**2):\n    A005898_list.append(m[-1])\n    for i in range(3):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A005900", "text": "Octahedral numbers: a(n) = n*(2*n^2 + 1)/3.", "sequence": "0,1,6,19,44,85,146,231,344,489,670,891,1156,1469,1834,2255,2736,3281,3894,4579,5340,6181,7106,8119,9224,10425,11726,13131,14644,16269,18010,19871,21856,23969,26214,28595,31116,33781,36594,39559,42680", "code": "\ndef a(n): return n*(2*n*n + 1)//3\nprint([a(n) for n in range(41)]) \n"}
{"sequence_id": "A005902", "text": "Centered icosahedral (or cuboctahedral) numbers, also crystal ball sequence for f.c.c. lattice.", "sequence": "1,13,55,147,309,561,923,1415,2057,2869,3871,5083,6525,8217,10179,12431,14993,17885,21127,24739,28741,33153,37995,43287,49049,55301,62063,69355,77197,85609,94611,104223,114465,125357,136919,149171,162133,175825,190267,205479", "code": "\ndef a(n): return (2*n+1)*(5*n**2+5*n+3)//3\nprint([a(n) for n in range(40)]) \n"}
{"sequence_id": "A005917", "text": "Rhombic dodecahedral numbers: a(n) = n^4 - (n - 1)^4.", "sequence": "1,15,65,175,369,671,1105,1695,2465,3439,4641,6095,7825,9855,12209,14911,17985,21455,25345,29679,34481,39775,45585,51935,58849,66351,74465,83215,92625,102719,113521,125055,137345,150415,164289,178991", "code": "\nA005917_list, m = [], [24, -12, 2, 1]\nfor _ in range(10**2):\n    A005917_list.append(m[-1])\n    for i in range(3):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A005938", "text": "Pseudoprimes to base 7.", "sequence": "6,25,325,561,703,817,1105,1825,2101,2353,2465,3277,4525,4825,6697,8321,10225,10585,10621,11041,11521,12025,13665,14089,16725,16806,18721,19345,20197,20417,20425,22945,25829,26419,29234,29341,29857,29891,30025,30811,33227", "code": "\nfrom sympy import isprime\ndef ok(n): return pow(7, n-1, n) == 1 and not isprime(n)\nprint(list(filter(ok, range(1, 34000)))) \n"}
{"sequence_id": "A005940", "text": "The Doudna sequence: write n-1 in binary; power of prime(k) in a(n) is # of 1's that are followed by k-1 0's.", "sequence": "1,2,3,4,5,6,9,8,7,10,15,12,25,18,27,16,11,14,21,20,35,30,45,24,49,50,75,36,125,54,81,32,13,22,33,28,55,42,63,40,77,70,105,60,175,90,135,48,121,98,147,100,245,150,225,72,343,250,375,108,625,162,243,64,17,26,39", "code": "\nfrom sympy import prime\nimport math\ndef A(n): return n - 2**int(math.floor(math.log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\nprint([b(n - 1) for n in range(1, 101)]) \n"}
{"sequence_id": "A006000", "text": "a(n) = (n+1)*(n^2+n+2)/2; g.f.: (1 + 2*x^2) / (1 - x)^4.", "sequence": "1,4,12,28,55,96,154,232,333,460,616,804,1027,1288,1590,1936,2329,2772,3268,3820,4431,5104,5842,6648,7525,8476,9504,10612,11803,13080,14446,15904,17457,19108,20860,22716,24679,26752,28938,31240,33661,36204,38872,41668,44595,47656,50854,54192", "code": "\ndef a(n):\n    return n + (n**3 - n**2)//2 \n"}
{"sequence_id": "A006012", "text": "a(0) = 1, a(1) = 2, a(n) = 4*a(n-1) - 2*a(n-2), n >= 2.", "sequence": "1,2,6,20,68,232,792,2704,9232,31520,107616,367424,1254464,4283008,14623104,49926400,170459392,581984768,1987020288,6784111616,23162405888,79081400320,270000789504,921840357376,3147359850496", "code": "\nl = [1, 2]\nfor n in range(2, 101): l.append(4 * l[n - 1] - 2 * l[n - 2])\nprint(l)  \n"}
{"sequence_id": "A006045", "text": "Sum of orders of all 2 X 2 matrices with entries mod n.", "sequence": "1,26,272,722,5270,5260,37358,18414,56216,95668,487714,99796,1304262,627046,593398,481982,7044222,931396,11570384,1602940,4037650,8694134,40220524,2069292,15855230,21686124,13215872,10948486,129952894,10451648", "code": " \nfrom itertools import product\ndef mmm2(A, B, modder): \n  return ((A[0]*B[0]+A[1]*B[2])%modder, (A[0]*B[1]+A[1]*B[3])%modder,\n          (A[2]*B[0]+A[3]*B[2])%modder, (A[2]*B[1]+A[3]*B[3])%modder)\ndef order(A, modder):\n  Ak, k = A, 1\n  while mmm2(Ak, Ak, modder) != Ak: Ak, k = mmm2(Ak, A, modder), k+1\n  return k\ndef a(n): return sum(order(A, n) for A in product(range(n), repeat=4))\nprint([a(n) for n in range(1, 12)]) \n"}
{"sequence_id": "A006047", "text": "Number of entries in n-th row of Pascal's triangle not divisible by 3.", "sequence": "1,2,3,2,4,6,3,6,9,2,4,6,4,8,12,6,12,18,3,6,9,6,12,18,9,18,27,2,4,6,4,8,12,6,12,18,4,8,12,8,16,24,12,24,36,6,12,18,12,24,36,18,36,54,3,6,9,6,12,18,9,18,27,6,12,18,12,24,36,18,36,54,9,18,27,18,36,54,27,54", "code": "\nfrom sympy.ntheory.factor_ import digits\nfrom sympy import prod\ndef a(n):\n    d=digits(n, 3)\n    return n + 1 if n<3 else prod(1 + d[i] for i in range(1, len(d)))\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A006068", "text": "a(n) is Gray-coded into n.", "sequence": "0,1,3,2,7,6,4,5,15,14,12,13,8,9,11,10,31,30,28,29,24,25,27,26,16,17,19,18,23,22,20,21,63,62,60,61,56,57,59,58,48,49,51,50,55,54,52,53,32,33,35,34,39,38,36,37,47,46,44,45,40,41,43,42,127,126,124,125,120,121", "code": "\ndef a(n):\n    s=1\n    while True:\n        ns=n>>s\n        if ns==0: break\n        n=n^ns\n        s<<=1\n    return n\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A006080", "text": "Number of rooted projective plane trees with n nodes.", "sequence": "1,1,2,4,9,21,56,155,469,1480,4882,16545,57384,202060,720526,2593494,9408469,34350507,126109784,465200333,1723346074,6408356210,23911272090,89495909409,335916761128,1264114452996,4768464309416,18027250459483,68291947831046,259200707489634", "code": "\nfrom sympy import binomial as C, totient, divisors\ndef a003239(n): return 1 if n<2 else sum([totient(n/d)*C(2*d, d) for d in divisors(n)])/(2*n)\ndef a(n): return 1 if n<2 else a003239(n)/2 + 2**(n - 2) \n"}
{"sequence_id": "A006093", "text": "a(n) = prime(n) - 1.", "sequence": "1,2,4,6,10,12,16,18,22,28,30,36,40,42,46,52,58,60,66,70,72,78,82,88,96,100,102,106,108,112,126,130,136,138,148,150,156,162,166,172,178,180,190,192,196,198,210,222,226,228,232,238,240,250,256,262,268,270", "code": "\nfrom sympy import prime\nfor n in range(1,100): print(prime(n)-1, end=', ') \n"}
{"sequence_id": "A006094", "text": "Products of 2 successive primes.", "sequence": "6,15,35,77,143,221,323,437,667,899,1147,1517,1763,2021,2491,3127,3599,4087,4757,5183,5767,6557,7387,8633,9797,10403,11021,11663,12317,14351,16637,17947,19043,20711,22499,23707,25591,27221,28891,30967,32399,34571,36863", "code": "\nfrom sympy import prime, primerange\ndef aupton(nn):\n    alst, prevp = [], 2\n    for p in primerange(3, prime(nn+1)+1): alst.append(prevp*p); prevp = p\n    return alst\nprint(aupton(43)) \n"}
{"sequence_id": "A006127", "text": "a(n) = 2^n + n.", "sequence": "1,3,6,11,20,37,70,135,264,521,1034,2059,4108,8205,16398,32783,65552,131089,262162,524307,1048596,2097173,4194326,8388631,16777240,33554457,67108890,134217755,268435484,536870941,1073741854,2147483679,4294967328,8589934625", "code": " print([2**n + n for n in range(34)]) \n"}
{"sequence_id": "A006128", "text": "Total number of parts in all partitions of n. Also, sum of largest parts of all partitions of n.", "sequence": "0,1,3,6,12,20,35,54,86,128,192,275,399,556,780,1068,1463,1965,2644,3498,4630,6052,7899,10206,13174,16851,21522,27294,34545,43453,54563,68135,84927,105366,130462,160876,198014,242812,297201,362587,441546,536104,649791,785437,947812,1140945,1371173,1644136,1968379,2351597,2805218,3339869,3970648,4712040,5584141,6606438,7805507,9207637", "code": "\nfrom sympy import divisor_count, npartitions\ndef a(n): return sum([divisor_count(m)*npartitions(n - m) for m in range(1, n + 1)]) \n"}
{"sequence_id": "A006129", "text": "a(0), a(1), a(2), ... satisfy Sum_{k=0..n} a(k)*binomial(n,k) = 2^binomial(n,2), for n >= 0.", "sequence": "1,0,1,4,41,768,27449,1887284,252522481,66376424160,34509011894545,35645504882731588,73356937912127722841,301275024444053951967648,2471655539737552842139838345,40527712706903544101000417059892,1328579255614092968399503598175745633", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef a(n): return 1 if n==0 else 2**binomial(n, 2) - sum(a(k)*binomial(n, k) for k in range(n))\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A006130", "text": "a(n) = a(n-1) + 3*a(n-2) for n > 1, a(0) = a(1) = 1.", "sequence": "1,1,4,7,19,40,97,217,508,1159,2683,6160,14209,32689,75316,173383,399331,919480,2117473,4875913,11228332,25856071,59541067,137109280,315732481,727060321,1674257764,3855438727,8878212019,20444528200", "code": "\nan = an1 = 1\nwhile an<10**5:\n   print(an)\n   an1 += an*3\n   an = an1 - an*3   \n"}
{"sequence_id": "A006131", "text": "a(n) = a(n-1) + 4*a(n-2), a(0) = a(1) = 1.", "sequence": "1,1,5,9,29,65,181,441,1165,2929,7589,19305,49661,126881,325525,833049,2135149,5467345,14007941,35877321,91909085,235418369,603054709,1544728185,3956947021,10135859761,25963647845,66507086889,170361678269", "code": "\ndef A006131_list(n):\n    list = [1, 1] + [0] * (n - 2)\n    for i in range(2, n):\n        list[i] = list[i - 1] + 4 * list[i - 2]\n    return list\nprint(A006131_list(29)) \n"}
{"sequence_id": "A006145", "text": "Ruth-Aaron numbers (1): sum of prime divisors of n = sum of prime divisors of n+1.", "sequence": "5,24,49,77,104,153,369,492,714,1682,2107,2299,2600,2783,5405,6556,6811,8855,9800,12726,13775,18655,21183,24024,24432,24880,25839,26642,35456,40081,43680,48203,48762,52554,61760,63665,64232,75140,79118,95709,106893,109939", "code": "\nfrom sympy import factorint\ndef aupton(terms):\n  alst, k, sopfk, sopfkp1 = [], 2, 2, 3\n  while len(alst) < terms:\n    if sopfkp1 == sopfk: alst.append(k)\n    k, sopfk, sopfkp1 = k+1, sopfkp1, sum(p for p in factorint(k+2))\n  return alst\nprint(aupton(42)) \n"}
{"sequence_id": "A006146", "text": "Sums of prime divisors of Ruth-Aaron numbers (A006145).", "sequence": "5,5,7,18,15,20,44,46,29,31,50,30,20,34,75,162,146,46,14,113,53,66,333,36,514,318,43,193,279,418,30,121,55,485,200,136,77,37,211,587,147,269,477,108,136,235,185,290,333,309,493,177,199,223,641,531,182,368", "code": "\nfrom sympy import primefactors\ndef aupton(terms):\n  alst, k, sopfk, sopfkp1 = [], 0, 0, 1\n  while len(alst) < terms:\n    k, sopfk, sopfkp1 = k+1, sopfkp1, sum(p for p in primefactors(k+1))\n    if sopfkp1 == sopfk: alst.append(sopfk)\n  return alst\nprint(aupton(58)) \n"}
{"sequence_id": "A006156", "text": "Number of ternary squarefree words of length n.", "sequence": "1,3,6,12,18,30,42,60,78,108,144,204,264,342,456,618,798,1044,1392,1830,2388,3180,4146,5418,7032,9198,11892,15486,20220,26424,34422,44862,58446,76122,99276,129516,168546,219516,285750,372204,484446,630666,821154", "code": "\ndef isf(s): \n    for l in range(1, len(s)//2 + 1):\n        if s[-2*l:-l] == s[-l:]: return False\n    return True\ndef aupton(nn, verbose=False):\n    alst, sfs = [1], set(\"0\")\n    for n in range(1, nn+1):\n        an = 3*len(sfs)\n        sfsnew = set(s+i for s in sfs for i in \"012\" if isf(s+i))\n        alst, sfs = alst+[an], sfsnew\n        if verbose: print(n, an)\n    return alst\nprint(aupton(40)) \n"}
{"sequence_id": "A006218", "text": "a(n) = Sum_{k=1..n} floor(n/k); also Sum_{k=1..n} d(k), where d = number of divisors (A000005); also number of solutions to x*y = z with 1 <= x,y,z <= n.", "sequence": "0,1,3,5,8,10,14,16,20,23,27,29,35,37,41,45,50,52,58,60,66,70,74,76,84,87,91,95,101,103,111,113,119,123,127,131,140,142,146,150,158,160,168,170,176,182,186,188,198,201,207,211,217,219,227,231,239,243,247,249", "code": "\nfrom sympy import integer_nthroot\ndef A006218(n): return 2*sum(n//k for k in range(1,integer_nthroot(n,2)[0]+1))-integer_nthroot(n,2)[0]**2 \n"}
{"sequence_id": "A006232", "text": "Numerators of Cauchy numbers of first type.", "sequence": "1,1,-1,1,-19,9,-863,1375,-33953,57281,-3250433,1891755,-13695779093,24466579093,-132282840127,240208245823,-111956703448001,4573423873125,-30342376302478019,56310194579604163", "code": " \nfrom fractions import gcd\naa,n,sden = [0,1],1,1\nwhile n < 20:\n    j,snom,sden,a = 1,0,(n+1)*sden,0\n    while j < len(aa):\n        snom,j = snom+aa[j]*(sden//(j+1)),j+1\n    nom,den = snom,sden\n    print(n,nom//gcd(nom,den))\n    aa,j = aa+[-aa[j-1]],j-1\n    while j > 0:\n        aa[j],j = n*aa[j]-aa[j-1],j-1\n    n = n+1 \n"}
{"sequence_id": "A006233", "text": "Denominators of Cauchy numbers of first type.", "sequence": "1,2,6,4,30,4,84,24,90,20,132,8,5460,840,360,48,1530,4,1596,168,1980,1320,8280,80,81900,6552,1512,112,3480,80,114576,7392,117810,7140,1260,8,3838380,5928,936,48,81180,440,1191960,55440,869400,38640,236880,224", "code": " \nfrom fractions import gcd\naa, n, sden = [0, 1], 1, 1\nprint(0, 1)\nwhile n < 20:\n    j, snom, sden, a = 1, 0, (n+1)*sden, 0\n    while j < len(aa):\n        snom, j = snom+aa[j]*(sden//(j+1)), j+1\n    nom, den = snom, sden\n    print(n,den//gcd(nom,den))\n    aa, j = aa+[-aa[j-1]], j-1\n    while j > 0:\n        aa[j], j = n*aa[j]-aa[j-1], j-1\n    n += 1 \n"}
{"sequence_id": "A006257", "text": "Josephus problem: a(2*n) = 2*a(n)-1, a(2*n+1) = 2*a(n)+1.", "sequence": "0,1,1,3,1,3,5,7,1,3,5,7,9,11,13,15,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29", "code": "\nimport math\ndef A006257(n):\n     return 0 if n==0 else 2*(n-2**int(math.log(n,2)))+1 \n(C\nstatic long cs_A006257(this long n) => n == 0 ? 0 : 1 + (1 + (n - 1).cs_A006257()) % n; // _Frank Hollstein_, Feb 24 2021\n"}
{"sequence_id": "A006261", "text": "a(n) = Sum_{k=0..5} C(n,k).", "sequence": "1,2,4,8,16,32,63,120,219,382,638,1024,1586,2380,3473,4944,6885,9402,12616,16664,21700,27896,35443,44552,55455,68406,83682,101584,122438,146596,174437,206368,242825,284274,331212,384168,443704", "code": "\nA006261_list, m = [], [1, -3, 4, -2, 1, 1]\nfor _ in range(10**2):\n    A006261_list.append(m[-1])\n    for i in range(5):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A006318", "text": "Large Schr\u00f6der numbers (or large Schroeder numbers, or big Schroeder numbers).", "sequence": "1,2,6,22,90,394,1806,8558,41586,206098,1037718,5293446,27297738,142078746,745387038,3937603038,20927156706,111818026018,600318853926,3236724317174,17518619320890,95149655201962,518431875418926,2832923350929742,15521467648875090", "code": "\nfrom gmpy2 import divexact\nA006318 = [1, 2]\nfor n in range(3,10**3):\n....A006318.append(divexact(A006318[-1]*(6*n-9)-(n-3)*A006318[-2],n))\n\n"}
{"sequence_id": "A006352", "text": "Coefficients in expansion of Eisenstein series E_2 (also called E_1 or G_2).", "sequence": "1,-24,-72,-96,-168,-144,-288,-192,-360,-312,-432,-288,-672,-336,-576,-576,-744,-432,-936,-480,-1008,-768,-864,-576,-1440,-744,-1008,-960,-1344,-720,-1728,-768,-1512,-1152,-1296,-1152,-2184,-912,-1440,-1344,-2160,-1008,-2304,-1056,-2016,-1872,-1728", "code": "\nfrom sympy import divisor_sigma\ndef a(n): return 1 if n == 0 else -24 * divisor_sigma(n)\n[a(n) for n in range(51)]  \n"}
{"sequence_id": "A006367", "text": "Number of binary vectors of length n+1 beginning with 0 and containing just 1 singleton.", "sequence": "1,0,2,2,5,8,15,26,46,80,139,240,413,708,1210,2062,3505,5944,10059,16990,28646,48220,81047,136032,228025,381768,638450,1066586,1780061,2968040,4944519,8230370,13689118,22751528,37786915,62716752,104028245", "code": "\nfrom sympy import fibonacci\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n): return 1 if n==0 else 0 if n==1 else a(n - 1) + a(n - 2) + fibonacci(n - 3)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A006368", "text": "The \"amusical permutation\" of the nonnegative numbers: a(2n)=3n, a(4n+1)=3n+1, a(4n-1)=3n-1.", "sequence": "0,1,3,2,6,4,9,5,12,7,15,8,18,10,21,11,24,13,27,14,30,16,33,17,36,19,39,20,42,22,45,23,48,25,51,26,54,28,57,29,60,31,63,32,66,34,69,35,72,37,75,38,78,40,81,41,84,43,87,44,90,46,93,47,96,49,99,50,102,52,105,53", "code": "\ndef a(n): return 0 if n == 0 else 3*n//2 if n%2 == 0 else (3*n+1)//4\nprint([a(n) for n in range(72)]) \n"}
{"sequence_id": "A006370", "text": "The Collatz or 3x+1 map: a(n) = n/2 if n is even, 3n + 1 if n is odd.", "sequence": "0,4,1,10,2,16,3,22,4,28,5,34,6,40,7,46,8,52,9,58,10,64,11,70,12,76,13,82,14,88,15,94,16,100,17,106,18,112,19,118,20,124,21,130,22,136,23,142,24,148,25,154,26,160,27,166,28,172,29,178,30,184,31,190,32,196,33", "code": "\ndef A006370(n):\n    q, r = divmod(n, 2)\n    return 3*n+1 if r else q \n"}
{"sequence_id": "A006450", "text": "Prime-indexed primes: primes with prime subscripts.", "sequence": "3,5,11,17,31,41,59,67,83,109,127,157,179,191,211,241,277,283,331,353,367,401,431,461,509,547,563,587,599,617,709,739,773,797,859,877,919,967,991,1031,1063,1087,1153,1171,1201,1217,1297,1409,1433,1447,1471", "code": "\nfrom sympy import prime\ndef a(n): return prime(prime(n))\nprint([a(n) for n in range(1, 52)]) \n"}
{"sequence_id": "A006450", "text": "Prime-indexed primes: primes with prime subscripts.", "sequence": "3,5,11,17,31,41,59,67,83,109,127,157,179,191,211,241,277,283,331,353,367,401,431,461,509,547,563,587,599,617,709,739,773,797,859,877,919,967,991,1031,1063,1087,1153,1171,1201,1217,1297,1409,1433,1447,1471", "code": " \nfrom sympy import nextprime, isprime\ndef aupton(terms):\n    alst, p, pi = [], 2, 1\n    while len(alst) < terms:\n        if isprime(pi): alst.append(p)\n        p, pi = nextprime(p), pi+1\n    return alst\nprint(aupton(10000)) \n"}
{"sequence_id": "A006456", "text": "Number of compositions (ordered partitions) of n into squares.", "sequence": "1,1,1,1,2,3,4,5,7,11,16,22,30,43,62,88,124,175,249,354,502,710,1006,1427,2024,2870,4068,5767,8176,11593,16436,23301,33033,46832,66398,94137,133462,189211,268252,380315,539192,764433,1083764,1536498,2178364", "code": "\nfrom gmpy2 import is_square\nclass Memoize:\n    def __init__(self, func):\n        self.func=func\n        self.cache={}\n    def __call__(self, arg):\n        if arg not in self.cache:\n            self.cache[arg] = self.func(arg)\n        return self.cache[arg]\n@Memoize\ndef a(n): return 1 if n==0 else sum([a(n - k) for k in range(1, n + 1) if is_square(k)])\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A006498", "text": "a(n) = a(n-1) + a(n-3) + a(n-4), a(0) = a(1) = a(2) = 1, a(3) = 2.", "sequence": "1,1,1,2,4,6,9,15,25,40,64,104,169,273,441,714,1156,1870,3025,4895,7921,12816,20736,33552,54289,87841,142129,229970,372100,602070,974169,1576239,2550409,4126648,6677056,10803704,17480761,28284465,45765225", "code": "\ndef a(n, adict={0:1, 1:1, 2:1, 3:2}):\n    if n in adict:\n        return adict[n]\n    adict[n]=a(n-1)+a(n-3)+a(n-4)\n    return adict[n] \n"}
{"sequence_id": "A006500", "text": "Restricted combinations.", "sequence": "1,2,4,8,12,18,27,45,75,125,200,320,512,832,1352,2197,3549,5733,9261,14994,24276,39304,63580,102850,166375,269225,435655,704969,1140624,1845504,2985984,4831488,7817616,12649337,20466953,33116057,53582633", "code": "\ndef a(n, adict={0:1, 1:2, 2:4, 3:8, 4:12, 5:18, 6:27, 7:45}):\n    if n in adict:\n        return adict[n]\n    adict[n]=a(n-1)+a(n-2)-a(n-3)+a(n-4)+a(n-5)+a(n-6)-a(n-7)-a(n-8)\n    return adict[n] \n"}
{"sequence_id": "A006509", "text": "Cald's sequence: a(n+1) = a(n) - prime(n) if that value is positive and new, otherwise a(n) + prime(n) if new, otherwise 0.", "sequence": "1,3,6,11,4,15,2,19,38,61,32,63,26,67,24,71,18,77,16,83,12,85,164,81,170,73,174,277,384,275,162,35,166,29,168,317,468,311,148,315,142,321,140,331,138,335,136,347,124,351,122,355,116,357,106,363,100,369,98,375,94,377,84,391,80,393,76,407,70,417,68,421,62,429,56,435,52,441,44,445,36,455,34,465,898,459,902,453,910,449,912,1379,900,413,904,405,908,399,920,397,938,1485,928,365,934,1505,2082,1495,2088,1489,888,281,894,1511,892,261,0,643,1290,637,1296,635,1308,631,1314,623,1324,615,1334,607,1340", "code": "\nfrom sympy import primerange, prime\ndef aupton(terms):\n  alst = [1]\n  for n, pn in enumerate(primerange(1, prime(terms)+1), start=1):\n    x, y = alst[-1] - pn, alst[-1] + pn\n    if x > 0 and x not in alst: alst.append(x)\n    elif y > 0 and y not in alst: alst.append(y)\n    else: alst.append(0)\n  return alst\nprint(aupton(130)) \n"}
{"sequence_id": "A006512", "text": "Greater of twin primes.", "sequence": "5,7,13,19,31,43,61,73,103,109,139,151,181,193,199,229,241,271,283,313,349,421,433,463,523,571,601,619,643,661,811,823,829,859,883,1021,1033,1051,1063,1093,1153,1231,1279,1291,1303,1321,1429,1453,1483,1489,1609", "code": "\nfrom sympy import primerange, isprime\nprint([n for n in primerange(1, 2001) if isprime(n - 2)]) \n"}
{"sequence_id": "A006516", "text": "a(n) = 2^(n-1)*(2^n - 1), n >= 0.", "sequence": "0,1,6,28,120,496,2016,8128,32640,130816,523776,2096128,8386560,33550336,134209536,536854528,2147450880,8589869056,34359607296,137438691328,549755289600,2199022206976,8796090925056,35184367894528", "code": " for n in range(0, 30): print(2**(n-1)*(2**n - 1), end=', ') \n"}
{"sequence_id": "A006521", "text": "Numbers n such that n divides 2^n + 1.", "sequence": "1,3,9,27,81,171,243,513,729,1539,2187,3249,4617,6561,9747,13203,13851,19683,29241,39609,41553,59049,61731,87723,97641,118827,124659,177147,185193,250857,263169,292923,354537,356481,373977,531441,555579,752571", "code": "\nA006521_list = [n for n in range(1,10**6) if pow(2,n,n) == n-1] \n"}
{"sequence_id": "A006533", "text": "Join n equal points around circle in all ways, count regions.", "sequence": "1,2,4,8,16,30,57,88,163,230,386,456,794,966,1471,1712,2517,2484,4048,4520,6196,6842,9109,9048,12951,14014,17902,19208,24158,21510,31931,33888,41449,43826,52956,52992,66712,70034,82993,86840,102091,97776,124314,129448,149986,155894,179447,179280", "code": "\ndef d(n,m): return not n % m\ndef A006533(n): return (1176*d(n,12)*n - 3744*d(n,120)*n + 1536*d(n,18)*n - d(n,2)*(5*n**3 - 42*n**2 + 40*n + 48) - 2304*d(n,210)*n + 912*d(n,24)*n - 1728*d(n,30)*n - 36*d(n,4)*n - 2400*d(n,42)*n - 4*d(n,6)*n*(53*n - 310) - 9120*d(n,60)*n - 3744*d(n,84)*n - 2304*d(n,90)*n + 2*n**4 - 12*n**3 + 46*n**2 - 36*n)//48 + 1 \n"}
{"sequence_id": "A006561", "text": "Number of intersections of diagonals in the interior of regular n-gon.", "sequence": "0,0,0,1,5,13,35,49,126,161,330,301,715,757,1365,1377,2380,1837,3876,3841,5985,5941,8855,7297,12650,12481,17550,17249,23751,16801,31465,30913,40920,40257,52360,46981,66045,64981,82251,80881,101270,84841,123410,121441", "code": "\ndef d(n,m): return not n % m\ndef A006561(n): return 0 if n == 2 else n*(42*d(n,12) - 144*d(n,120) + 60*d(n,18) - 96*d(n,210) + 35*d(n,24)- 38*d(n,30) - 82*d(n,42) - 330*d(n,60) - 144*d(n,84) - 96*d(n,90)) + (n**4 - 6*n**3 + 11*n**2 - 6*n -d(n,2)*(5*n**3 - 45*n**2 + 70*n - 24) - 36*d(n,4)*n - 4*d(n,6)*n*(45*n - 262))//24 \n"}
{"sequence_id": "A006567", "text": "Emirps (primes whose reversal is a different prime).", "sequence": "13,17,31,37,71,73,79,97,107,113,149,157,167,179,199,311,337,347,359,389,701,709,733,739,743,751,761,769,907,937,941,953,967,971,983,991,1009,1021,1031,1033,1061,1069,1091,1097,1103,1109,1151,1153,1181,1193,1201", "code": "\nfrom sympy import prime, isprime\nA006567 = [p for p in (prime(n) for n in range(1,10**6)) if str(p) != str(p)[::-1] and isprime(int(str(p)[::-1]))] \n"}
{"sequence_id": "A006567", "text": "Emirps (primes whose reversal is a different prime).", "sequence": "13,17,31,37,71,73,79,97,107,113,149,157,167,179,199,311,337,347,359,389,701,709,733,739,743,751,761,769,907,937,941,953,967,971,983,991,1009,1021,1031,1033,1061,1069,1091,1097,1103,1109,1151,1153,1181,1193,1201", "code": "\nfrom sympy import isprime, nextprime\ndef emirps(start=1, end=float('inf')): \n  p = nextprime(start-1)\n  while p <= end:\n    revp = int(str(p)[::-1])\n    if p != revp and isprime(revp): yield p\n    p = nextprime(p)\nprint(list(emirps(end=1201))) \n"}
{"sequence_id": "A006577", "text": "Number of halving and tripling steps to reach 1 in '3x+1' problem, or -1 if 1 is never reached.", "sequence": "0,1,7,2,5,8,16,3,19,6,14,9,9,17,17,4,12,20,20,7,7,15,15,10,23,10,111,18,18,18,106,5,26,13,13,21,21,21,34,8,109,8,29,16,16,16,104,11,24,24,24,11,11,112,112,19,32,19,32,19,19,107,107,6,27,27,27,14,14,14,102,22", "code": "\ndef a(n):\n    if n==1: return 0\n    x=0\n    while True:\n        if n%2==0: n//=2\n        else: n = 3*n + 1\n        x+=1\n        if n<2: break\n    return x\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A006590", "text": "a(n) = Sum_{k=1..n} ceiling(n/k).", "sequence": "1,3,6,9,13,16,21,24,29,33,38,41,48,51,56,61,67,70,77,80,87,92,97,100,109,113,118,123,130,133,142,145,152,157,162,167,177,180,185,190,199,202,211,214,221,228,233,236,247,251,258,263,270,273,282,287,296,301", "code": "\nfrom math import isqrt\ndef A006590(n): return (lambda m: n+2*sum((n-1)//k for k in range(1, m+1))-m*m)(isqrt(n-1)) \n"}
{"sequence_id": "A006666", "text": "Number of halving steps to reach 1 in '3x+1' problem, or -1 if this never happens.", "sequence": "0,1,5,2,4,6,11,3,13,5,10,7,7,12,12,4,9,14,14,6,6,11,11,8,16,8,70,13,13,13,67,5,18,10,10,15,15,15,23,7,69,7,20,12,12,12,66,9,17,17,17,9,9,71,71,14,22,14,22,14,14,68,68,6,19,19,19,11,11,11,65,16,73,16,11,16", "code": "\ndef a(n):\n    if n==1: return 0\n    x=0\n    while True:\n        if not n%2:\n            n//=2\n            x+=1\n        else: n = 3*n + 1\n        if n<2: break\n    return x\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A006667", "text": "Number of tripling steps to reach 1 in '3x+1' problem, or -1 if 1 is never reached.", "sequence": "0,0,2,0,1,2,5,0,6,1,4,2,2,5,5,0,3,6,6,1,1,4,4,2,7,2,41,5,5,5,39,0,8,3,3,6,6,6,11,1,40,1,9,4,4,4,38,2,7,7,7,2,2,41,41,5,10,5,10,5,5,39,39,0,8,8,8,3,3,3,37,6,42,6,3,6,6,11,11,1,6,40,40,1,1,9,9,4,9,4,33,4,4,38", "code": "\ndef a(n):\n    if n==1: return 0\n    x=0\n    while True:\n        if n%2==0: n/=2\n        else:\n            n = 3*n + 1\n            x+=1\n        if n<2: break\n    return x\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A006720", "text": "Somos-4 sequence: a(0)=a(1)=a(2)=a(3)=1; for n >= 4, a(n) = (a(n-1) * a(n-3) + a(n-2)^2) / a(n-4).", "sequence": "1,1,1,1,2,3,7,23,59,314,1529,8209,83313,620297,7869898,126742987,1687054711,47301104551,1123424582771,32606721084786,1662315215971057,61958046554226593,4257998884448335457,334806306946199122193,23385756731869683322514,3416372868727801226636179", "code": "\nfrom gmpy2 import divexact\nA006720 = [1, 1, 1, 1]\nfor n in range(4, 101):\n    A006720.append(divexact(A006720[n-1]*A006720[n-3]+A006720[n-2]**2,A006720[n-4]))\n\n"}
{"sequence_id": "A006721", "text": "Somos-5 sequence: a(n) = (a(n-1) * a(n-4) + a(n-2) * a(n-3)) / a(n-5), with a(0) = a(1) = a(2) = a(3) = a(4) = 1.", "sequence": "1,1,1,1,1,2,3,5,11,37,83,274,1217,6161,22833,165713,1249441,9434290,68570323,1013908933,11548470571,142844426789,2279343327171,57760865728994,979023970244321,23510036246274433,771025645214210753", "code": "\nfrom gmpy2 import divexact\nA006721 = [1,1,1,1,1]\nfor n in range(5,1001):\n....A006721.append(divexact(A006721[n-1]*A006721[n-4]+A006721[n-2]*A006721[n-3],A006721[n-5])) \n"}
{"sequence_id": "A006722", "text": "Somos-6 sequence: a(n) = (a(n-1) * a(n-5) + a(n-2) * a(n-4) + a(n-3)^2) / a(n-6), a(0) = ... = a(5) = 1.", "sequence": "1,1,1,1,1,1,3,5,9,23,75,421,1103,5047,41783,281527,2534423,14161887,232663909,3988834875,45788778247,805144998681,14980361322965,620933643034787,16379818848380849,369622905371172929,20278641689337631649,995586066665500470689", "code": "\nfrom gmpy2 import divexact\nA006722 = [1,1,1,1,1,1]\nfor n in range(6,101):\n....A006722.append(divexact(A006722[n-1]*A006722[n-5]+A006722[n-2]*A006722[n-4]+A006722[n-3]**2,A006722[n-6]))\n\n"}
{"sequence_id": "A006723", "text": "Somos-7 sequence: a(n) = (a(n-1) * a(n-6) + a(n-2) * a(n-5) + a(n-3) * a(n-4)) / a(n-7), a(0) = ... = a(6) = 1.", "sequence": "1,1,1,1,1,1,1,3,5,9,17,41,137,769,1925,7203,34081,227321,1737001,14736001,63232441,702617001,8873580481,122337693603,1705473647525,22511386506929,251582370867257,9254211194697641,215321535159114017", "code": "\nfrom gmpy2 import divexact\nA006723 = [1,1,1,1,1,1,1]\nfor n in range(7,101):\n....A006723.append(divexact(A006723[n-1]*A006723[n-6]+A006723[n-2]*A006723[n-5]+A006723[n-3]*A006723[n-4],A006723[n-7]))\n\n"}
{"sequence_id": "A006751", "text": "Describe the previous term! (method A - initial term is 2).", "sequence": "2,12,1112,3112,132112,1113122112,311311222112,13211321322112,1113122113121113222112,31131122211311123113322112,132113213221133112132123222112,11131221131211132221232112111312111213322112,31131122211311123113321112131221123113111231121123222112", "code": "\nl=[2]\nn=s=1\ny=''\nwhile n<21:\n    x=str(l[n - 1]) + ' '\n    for i in range(len(x) - 1):\n        if x[i]==x[i + 1]: s+=1\n        else:\n            y+=str(s)+str(x[i])\n            s=1\n    x=''\n    n+=1\n    l.append(int(y))\n    y=''\n    s=1\nprint(l) \n"}
{"sequence_id": "A006753", "text": "Smith (or joke) numbers: composite numbers n such that sum of digits of n = sum of digits of prime factors of n (counted with multiplicity).", "sequence": "4,22,27,58,85,94,121,166,202,265,274,319,346,355,378,382,391,438,454,483,517,526,535,562,576,588,627,634,636,645,648,654,663,666,690,706,728,729,762,778,825,852,861,895,913,915,922,958,985,1086,1111,1165,1219", "code": "\nfrom sympy import factorint\ndef sd(n): return sum(map(int, str(n)))\ndef ok(n):\n  f = factorint(n)\n  return sum(f[p] for p in f) > 1 and sd(n) == sum(sd(p)*f[p] for p in f)\nprint(list(filter(ok, range(1220)))) \n"}
{"sequence_id": "A006794", "text": "Primorial -1 primes: primes p such that -1 + product of primes up to p is prime.", "sequence": "3,5,11,13,41,89,317,337,991,1873,2053,2377,4093,4297,4583,6569,13033,15877,843301,1098133,3267113", "code": "\nfrom sympy import nextprime, isprime\nA006794_list, p, q = [], 2, 2\nwhile p < 10**5:\n    if isprime(q-1):\n        A006794_list.append(p)\n    p = nextprime(p)\n    q *= p \n"}
{"sequence_id": "A006874", "text": "Mu-atoms of period n on continent of Mandelbrot set.", "sequence": "1,1,2,3,4,6,6,9,10,12,10,22,12,18,24,27,16,38,18,44,36,30,22,78,36,36,50,66,28,104,30,81,60,48,72,158,36,54,72,156,40,156,42,110,152,66,46,270,78,140,96,132,52,230,120,234,108,84,58,456,60,90,228,243,144,260", "code": "\nfrom sympy import divisors, totient\nl=[0, 1]\nfor n in range(2, 101):\n    l.append(sum([totient(n//d)*l[d] for d in divisors(n)[:-1]]))\nprint(l[1:]) \n"}
{"sequence_id": "A006875", "text": "Non-seed mu-atoms of period n in Mandelbrot set.", "sequence": "0,1,2,3,4,7,6,12,12,23,10,51,12,75,50,144,16,324,18,561,156,1043,22,2340,80,4119,540,8307,28,17521,30,32928,2096,65567,366,135432,36,262179,8250,525348,40,1065093,42,2098263,33876,4194347,46,8456160,420,16779280", "code": "\nfrom sympy import divisors, totient, mobius\nl=[0, 0]\nfor n in range(2, 101):\n    l.append(sum(totient(n//d)*sum(mobius(d//c)*2**(c - 1) for c in divisors(d)) for d in divisors(n)[:-1]))\nprint(l[1:]) \n"}
{"sequence_id": "A006881", "text": "Squarefree semiprimes: Numbers that are the product of two distinct primes.", "sequence": "6,10,14,15,21,22,26,33,34,35,38,39,46,51,55,57,58,62,65,69,74,77,82,85,86,87,91,93,94,95,106,111,115,118,119,122,123,129,133,134,141,142,143,145,146,155,158,159,161,166,177,178,183,185,187,194,201,202,203,205", "code": "\nfrom sympy import factorint\ndef ok(n): f=factorint(n); return len(f) == 2 and sum(f[p] for p in f) == 2\nprint(list(filter(ok, range(1, 206)))) \n"}
{"sequence_id": "A006882", "text": "Double factorials n!!: a(n) = n*a(n-2) for n > 1, a(0) = a(1) = 1.", "sequence": "1,1,2,3,8,15,48,105,384,945,3840,10395,46080,135135,645120,2027025,10321920,34459425,185794560,654729075,3715891200,13749310575,81749606400,316234143225,1961990553600,7905853580625,51011754393600", "code": "\nfrom sympy import factorial2\ndef A006882(n): return factorial2(n) \n"}
{"sequence_id": "A006933", "text": "'Eban' numbers (the letter 'e' is banned!).", "sequence": "2,4,6,30,32,34,36,40,42,44,46,50,52,54,56,60,62,64,66,2000,2002,2004,2006,2030,2032,2034,2036,2040,2042,2044,2046,2050,2052,2054,2056,2060,2062,2064,2066,4000,4002,4004,4006,4030,4032,4034,4036,4040,4042,4044,4046,4050,4052,4054,4056,4060,4062,4064,4066,6000", "code": "\nfrom num2words import num2words\n[n for n in range(6001) if 'e' not in num2words(n)] \n"}
{"sequence_id": "A006938", "text": "Convert the last term from decimal to binary!", "sequence": "3,11,1011,1111110011,1000010001110100011000101111011", "code": "\ndef agen(an):\n  while True: yield an; an = int(bin(an)[2:])\ng = agen(3)\nprint([next(g) for i in range(5)]) \n"}
{"sequence_id": "A006942", "text": "Number of segments used to represent n on calculator display, variant 5: digits '6', '7' and '9' use 6, 3 and 6 segments, respectively.", "sequence": "6,2,5,5,4,5,6,3,7,6,8,4,7,7,6,7,8,5,9,8,11,7,10,10,9,10,11,8,12,11,11,7,10,10,9,10,11,8,12,11,10,6,9,9,8,9,10,7,11,10,11,7,10,10,9,10,11,8,12,11,12,8,11,11,10,11,12,9,13,12,9,5,8,8,7,8,9", "code": "\ndef a(n): return sum([6, 2, 5, 5, 4, 5, 6, 3, 7, 6][int(d)] for d in str(n))\nprint([a(n) for n in range(77)]) \n"}
{"sequence_id": "A006944", "text": "Number of letters in the n-th ordinal number (in American English).", "sequence": "5,6,5,6,5,5,7,6,5,5,8,7,10,10,9,9,11,10,10,9,11,12,11,12,11,11,13,12,11,9,11,12,11,12,11,11,13,12,11,8,10,11,10,11,10,10,12,11,10,8,10,11,10,11,10,10,12,11,10,8,10,11,10,11,10,10,12,11,10,10,12,13,12,13,12,12", "code": "\nfrom num2words import num2words\ndef a(n): return len(num2words(n, to='ordinal').replace(\" and\", \"\").replace(\"-\", \"\").replace(\" \", \"\"))\nprint([a(n) for n in range(1, 77)]) \n"}
{"sequence_id": "A006946", "text": "Independence number of De Bruijn graph of order n on two symbols.", "sequence": "1,2,3,7,13,28,55,114,227,466,931,1891,3781", "code": "\nimport networkx as nx\ndef deBruijn(n): return nx.MultiDiGraph(((0,0),(0,0))) if n==0 else nx.line_graph(deBruijn(n-1))\ndef A006946(n): return nx.graph_clique_number(nx.complement(nx.Graph(deBruijn(n)))) \n"}
{"sequence_id": "A006992", "text": "Bertrand primes: a(n) is largest prime < 2*a(n-1) for n > 1, with a(1) = 2.", "sequence": "2,3,5,7,13,23,43,83,163,317,631,1259,2503,5003,9973,19937,39869,79699,159389,318751,637499,1274989,2549951,5099893,10199767,20399531,40799041,81598067,163196129,326392249,652784471,1305568919,2611137817", "code": "\nfrom sympy import prevprime\nl = [2]\nfor i in range(1, 51):\n    l.append(prevprime(2 * l[i - 1]))\nprint(l) \n"}
{"sequence_id": "A007060", "text": "Number of ways n couples can sit in a row without any spouses next to each other.", "sequence": "1,0,8,240,13824,1263360,168422400,30865121280,7445355724800,2287168006717440,871804170613555200,403779880746418176000,223346806774106790297600,145427383048755178635264000", "code": "\nfrom sympy import binomial, subfactorial\ndef a(n): return sum([(-1)**(n - k)*binomial(n, k)*subfactorial(2*k) for k in range(n + 1)]) \n"}
{"sequence_id": "A007088", "text": "The binary numbers (or binary words, or binary vectors, or binary expansion of n): numbers written in base 2.", "sequence": "0,1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1101,1110,1111,10000,10001,10010,10011,10100,10101,10110,10111,11000,11001,11010,11011,11100,11101,11110,11111,100000,100001,100010,100011,100100,100101,100110,100111", "code": "\ndef a(n): return int(bin(n)[2:])\nprint([a(n) for n in range(40)]) \n"}
{"sequence_id": "A007094", "text": "Numbers in base 8.", "sequence": "0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17,20,21,22,23,24,25,26,27,30,31,32,33,34,35,36,37,40,41,42,43,44,45,46,47,50,51,52,53,54,55,56,57,60,61,62,63,64,65,66,67,70,71,72,73,74,75,76,77,100,101,102,103,104,105,106,107,110,111", "code": "\ndef a(n): return int(oct(n)[2:])\nprint([a(n) for n in range(74)]) \n"}
{"sequence_id": "A007095", "text": "Numbers in base 9.", "sequence": "0,1,2,3,4,5,6,7,8,10,11,12,13,14,15,16,17,18,20,21,22,23,24,25,26,27,28,30,31,32,33,34,35,36,37,38,40,41,42,43,44,45,46,47,48,50,51,52,53,54,55,56,57,58,60,61,62,63,64,65,66,67,68,70,71,72,73,74,75,76,77,78,80,81,82,83,84", "code": " \n"}
{"sequence_id": "A007123", "text": "Number of connected unit interval graphs with n nodes; also number of bracelets (turnover necklaces) with n black beads and n-1 white beads.", "sequence": "1,1,2,4,10,26,76,232,750,2494,8524,29624,104468,372308,1338936,4850640,17685270,64834550,238843660,883677784,3282152588,12233309868,45741634536,171530482864,644953425740,2430975800876", "code": "\nfrom sympy import catalan, binomial, floor\ndef a(n): return 1 if n==1 else (catalan(n - 1) + binomial(n - 1, floor((n - 1)/2)))/2 \n"}
{"sequence_id": "A007148", "text": "Number of self-complementary 2-colored bracelets (turnover necklaces) with 2n beads.", "sequence": "1,2,3,6,10,20,37,74,143,284,559,1114,2206,4394,8740,17418,34696,69194,137971,275280,549258,1096286,2188333,4369162,8724154,17422652,34797199,69505908,138845926,277383872,554189329,1107297290,2212558942", "code": "\nfrom sympy import divisors, totient\ndef a(n):\n    if n==1: return 1\n    return 2**(n - 2) + sum(totient(2*d)*2**(n//d) for d in divisors(n))//(4*n)\nprint([a(n) for n in range(1, 31)]) \n"}
{"sequence_id": "A007202", "text": "Crystal ball sequence for hexagonal close-packing.", "sequence": "1,13,57,153,323,587,967,1483,2157,3009,4061,5333,6847,8623,10683,13047,15737,18773,22177,25969,30171,34803,39887,45443,51493,58057,65157,72813,81047,89879,99331,109423,120177,131613,143753,156617", "code": "\ndef a(n): return round((7/8)*((n+1)**4-n**4))\nprint([a(n) for n in range(36)]) \n"}
{"sequence_id": "A007284", "text": "Horizontally symmetric numbers.", "sequence": "0,1,3,8,10,11,13,18,30,31,33,38,80,81,83,88,100,101,103,108,110,111,113,118,130,131,133,138,180,181,183,188,300,301,303,308,310,311,313,318,330,331,333,338,380,381,383,388,800,801,803,808,810,811,813,818", "code": "\nallowed = (\"0\", \"1\", \"3\", \"8\")\ndef a(n):\n    return all(x in allowed for x in str(n))\nprint([i for i in range(50000) if a(i)])\n\n"}
{"sequence_id": "A007306", "text": "Denominators of Farey tree fractions (i.e., the Stern-Brocot subtree in the range [0,1]).", "sequence": "1,1,2,3,3,4,5,5,4,5,7,8,7,7,8,7,5,6,9,11,10,11,13,12,9,9,12,13,11,10,11,9,6,7,11,14,13,15,18,17,13,14,19,21,18,17,19,16,11,11,16,19,17,18,21,19,14,13,17,18,15,13,14,11,7,8,13,17,16,19,23,22,17,19,26,29,25,24", "code": "\nfrom sympy import binomial\ndef a(n):\n    return 1 if n<1 else sum(binomial(n + k - 1, 2*k) % 2 for k in range(n + 1))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A007318", "text": "Pascal's triangle read by rows: C(n,k) = binomial(n,k) = n!/(k!*(n-k)!), 0 <= k <= n.", "sequence": "1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,1,5,10,10,5,1,1,6,15,20,15,6,1,1,7,21,35,35,21,7,1,1,8,28,56,70,56,28,8,1,1,9,36,84,126,126,84,36,9,1,1,10,45,120,210,252,210,120,45,10,1,1,11,55,165,330,462,462,330,165,55,11,1", "code": " \ndef C(n, k):\n    if k < 0 or k > n:\n        return 0\n    res = 1\n    for i in range(k):\n        res *= (n - i) // (i + 1)\n    return res\n\ndef C(n,k): from numpy import prod; return prod([(n-j)/(j+1) for j in range(k)])\ndef C(n,k): from functools import reduce; return reduce(lambda x,y: x*(n-y)//(1+y), range(k), 1) \n\n"}
{"sequence_id": "A007331", "text": "Fourier coefficients of E_{infinity,4}.", "sequence": "0,1,8,28,64,126,224,344,512,757,1008,1332,1792,2198,2752,3528,4096,4914,6056,6860,8064,9632,10656,12168,14336,15751,17584,20440,22016,24390,28224,29792,32768,37296,39312,43344,48448,50654,54880,61544,64512", "code": "\nfrom sympy import divisors\ndef a(n):\n    return 0 if n == 0 else sum(((n//d)%2)*d**3 for d in divisors(n))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A007347", "text": "Maximal Eulerian numbers of second kind.", "sequence": "1,1,2,8,58,444,4400,58140,785304,12440064,238904904,4642163952,101180433024,2549865473424,64728375139872,1797171220690560,56071264983487776,1758073054805500608,59321137058404865280,2206689692993315764416,82380712138316751438720", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef eulerian2(n, k): return 1 if k==0 else 0 if k==n else eulerian2(n - 1, k)*(k + 1) + eulerian2(n - 1, k - 1)*(2*n - k - 1)\ndef a(n): return max(eulerian2(n, k) for k in range(n+1))\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A007356", "text": "Apocalyptic powers: 2^n contains 666.", "sequence": "157,192,218,220,222,224,226,243,245,247,251,278,285,286,287,312,355,361,366,382,384,390,394,411,434,443,478,497,499,506,508,528,529,539,540,541,564,578,580,582,583,610,612,614,620,624,635,646,647,648,649,650", "code": "\nA007356_list = [k for k in range(1000) if '666' in str(2**k)] \n"}
{"sequence_id": "A007376", "text": "The almost-natural numbers: write n in base 10 and juxtapose digits.", "sequence": "0,1,2,3,4,5,6,7,8,9,1,0,1,1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,2,0,2,1,2,2,2,3,2,4,2,5,2,6,2,7,2,8,2,9,3,0,3,1,3,2,3,3,3,4,3,5,3,6,3,7,3,8,3,9,4,0,4,1,4,2,4,3,4,4,4,5,4,6,4,7,4,8,4,9,5,0,5,1,5,2,5,3,5,4,5,5,5,6,5,7", "code": " A007376_list = [int(d) for n in range(10**2) for d in str(n)] \n"}
{"sequence_id": "A007377", "text": "Numbers k such that the decimal expansion of 2^k contains no 0.", "sequence": "0,1,2,3,4,5,6,7,8,9,13,14,15,16,18,19,24,25,27,28,31,32,33,34,35,36,37,39,49,51,67,72,76,77,81,86", "code": "\ndef ok(n): return '0' not in str(2**n)\nprint(list(filter(ok, range(10**4)))) \n"}
{"sequence_id": "A007407", "text": "a(n) = denominator of Sum_{k=1..n} 1/k^2.", "sequence": "1,4,36,144,3600,3600,176400,705600,6350400,1270080,153679680,153679680,25971865920,25971865920,129859329600,519437318400,150117385017600,150117385017600,54192375991353600,10838475198270720,221193371393280", "code": "\nfrom fractions import Fraction\ndef A007407(n): return sum(Fraction(1,k**2) for k in range(1,n+1)).denominator \n"}
{"sequence_id": "A007440", "text": "Reversion of g.f. for Fibonacci numbers 1,1,2,3,5,...", "sequence": "1,-1,0,2,-3,-1,11,-15,-13,77,-86,-144,595,-495,-1520,4810,-2485,-15675,39560,-6290,-159105,324805,87075,-1592843,2616757,2136539,-15726114,20247800,32296693,-152909577,145139491,417959049,-1460704685,885536173,4997618808,-13658704994", "code": "\nA007440 = [0, 1, -1]\nfor n in range(3, 801):\n    A007440.append( (-(2*n-1)*A007440[-1]\n      - 5*(n-2)*A007440[-2])//(n+1) )\nfor n in range(1, 801):\n    print(n, A007440[n])  \n"}
{"sequence_id": "A007464", "text": "Shifts left under GCD-convolution with itself.", "sequence": "1,1,2,3,4,6,6,11,10,18,16,20,24,26,20,45,40,38,34,62,46,54,50,84,50,102,78,104,98,90,70,189,82,130,84,120,112,130,120,232,152,234,132,130,208,282,140,462,180,210,220,418,284,334,260,520,156,334,556", "code": "\nfrom fractions import gcd\nA007464_list = [1, 1]\nfor n in range(1,10**3):\n    A007464_list.append(sum(gcd(A007464_list[i],A007464_list[n-i]) for i in range(n+1)))\n\n"}
{"sequence_id": "A007467", "text": "Product of next n primes.", "sequence": "2,15,1001,215441,95041567,66238993967,63009974049301,87796770491685553,173955570033393401009,421385360593324054690769,1172248885422611971256631487,5253333091597988325086927419397,21476254926032216698855019795863013", "code": "\nfrom math import prod\nfrom sympy import prime\ndef a(n): return prod(prime(i) for i in range((n-1)*n//2+1, n*(n+1)//2+1))\nprint([a(n) for n in range(1, 14)]) \n"}
{"sequence_id": "A007468", "text": "Sum of next n primes.", "sequence": "2,8,31,88,199,384,659,1056,1601,2310,3185,4364,5693,7360,9287,11494,14189,17258,20517,24526,28967,33736,38917,45230,51797,59180,66831,75582,84463,95290,106255,117424,129945,143334,158167,173828,190013,207936,225707,245724", "code": "\nfrom sympy import nextprime\ndef aupton(terms):\n  alst, p = [], 2\n  for n in range(1, terms+1):\n    s = 0\n    for i in range(n):\n      s += p\n      p = nextprime(p)\n    alst.append(s)\n  return alst\nprint(aupton(40)) \n"}
{"sequence_id": "A007487", "text": "Sum of 9th powers.", "sequence": "0,1,513,20196,282340,2235465,12313161,52666768,186884496,574304985,1574304985,3932252676,9092033028,19696532401,40357579185,78800938560,147520415296,266108291793,464467582161,787155279940,1299155279940,2093435326521,3300704544313", "code": "\nA007487_list, m = [0], [362880, -1451520, 2328480, -1905120, 834120, -186480, 18150, -510, 1, 0, 0]\nfor _ in range(10**2):\n....for i in range(10):\n........m[i+1]+= m[i]\n....A007487_list.append(m[-1]) \n"}
{"sequence_id": "A007488", "text": "Primes whose reversal is a square.", "sequence": "61,163,487,691,1297,1861,4201,4441,4483,5209,5227,9049,9631,12391,14437,16141,16987,61483,63211,65707,65899,67057,69481,92767,94273,96979,106303,108061,123031,123373,125329,127291,129643,142771,146857,148249,165901", "code": "\nfrom gmpy2 import is_square\nfrom sympy import prime\nA007488 = [prime(n) for n in range(1,10**6) if is_square(int(str(prime(n))[::-1]))] \n"}
{"sequence_id": "A007497", "text": "a(1) = 2, a(n) = sigma(a(n-1)).", "sequence": "2,3,4,7,8,15,24,60,168,480,1512,4800,15748,28672,65528,122880,393192,1098240,4124736,15605760,50328576,149873152,371226240,1710858240,7926750720,33463001088,109760857440,384120963072,1468475386560,7157589626880,33151875434496", "code": "\nfrom itertools import accumulate, repeat \nfrom sympy import divisor_sigma\nA007497_list = list(accumulate(repeat(2,100), lambda x, _: divisor_sigma(x)))\n\n"}
{"sequence_id": "A007500", "text": "Primes whose reversal in base 10 is also prime (called \"palindromic primes\" by D. Wells, although that name usually refers to A002385). Also called reversible primes.", "sequence": "2,3,5,7,11,13,17,31,37,71,73,79,97,101,107,113,131,149,151,157,167,179,181,191,199,311,313,337,347,353,359,373,383,389,701,709,727,733,739,743,751,757,761,769,787,797,907,919,929,937,941,953,967,971,983,991,1009,1021", "code": "\nfrom sympy import prime, isprime\nA007500 = [prime(n) for n in range(1,10**6) if isprime(int(str(prime(n))[::-1]))] \n"}
{"sequence_id": "A007510", "text": "Single (or isolated or non-twin) primes: Primes p such that neither p-2 nor p+2 is prime.", "sequence": "2,23,37,47,53,67,79,83,89,97,113,127,131,157,163,167,173,211,223,233,251,257,263,277,293,307,317,331,337,353,359,367,373,379,383,389,397,401,409,439,443,449,457,467,479,487,491,499,503,509,541,547,557,563", "code": "\nfrom sympy import nextprime\ndef aupto(limit):\n  n, p, q = 1, 2, 3\n  alst, non_twins, twins = [], [2], [3]\n  while True:\n    p, q = q, nextprime(q)\n    if q - p == 2:\n      if p != twins[-1]: twins.append(p)\n      twins.append(q)\n    else:\n      if p != twins[-1]: non_twins.append(p)\n    if q > limit: return non_twins\nprint(aupto(563)) \n"}
{"sequence_id": "A007521", "text": "Primes of the form 8n + 5.", "sequence": "5,13,29,37,53,61,101,109,149,157,173,181,197,229,269,277,293,317,349,373,389,397,421,461,509,541,557,613,653,661,677,701,709,733,757,773,797,821,829,853,877,941,997,1013,1021,1061,1069,1093,1109,1117,1181,1213", "code": "\nfrom sympy import isprime\nprint(list(filter(isprime, range(5, 1214, 8)))) \n"}
{"sequence_id": "A007530", "text": "Prime quadruples: numbers k such that k, k+2, k+6, k+8 are all prime.", "sequence": "5,11,101,191,821,1481,1871,2081,3251,3461,5651,9431,13001,15641,15731,16061,18041,18911,19421,21011,22271,25301,31721,34841,43781,51341,55331,62981,67211,69491,72221,77261,79691,81041,82721,88811,97841,99131", "code": "\nfrom sympy import primerange\ndef aupto(limit):\n  p, q, r, alst = 2, 3, 5, []\n  for s in primerange(7, limit+9):\n    if p+2 == q and p+6 == r and p+8 == s: alst.append(p)\n    p, q, r = q, r, s\n  return alst\nprint(aupto(10**5)) \n"}
{"sequence_id": "A007532", "text": "Handsome numbers: sum of positive powers of its digits; a(n) = Sum_{i=1..k} d[i]^e[i] where d[1..k] are the decimal digits of a(n), e[i] > 0.", "sequence": "1,2,3,4,5,6,7,8,9,24,43,63,89,132,135,153,175,209,224,226,262,264,267,283,332,333,334,357,370,371,372,373,374,375,376,377,378,379,407,445,463,518,598,629,739,794,849,935,994,1034", "code": "\nfrom itertools import count, takewhile\ndef cands(n, d):\n    return takewhile(lambda x: x<=n, (d**i for i in count(1)))\ndef handsome(s, t):\n    if s == \"\":\n        return t == 0\n    if s[0] in \"01\":\n        return handsome(s[1:], t - int(s[0]))\n    return any(handsome(s[1:], t - p) for p in cands(t, int(s[0])))\ndef ok(n):\n    return n and handsome(str(n), n)\nprint(list(filter(ok, range(1035)))) \n"}
{"sequence_id": "A007540", "text": "Wilson primes: primes p such that (p-1)! == -1 (mod p^2).", "sequence": "5,13,563", "code": "\nfrom sympy import prime\nA007540_list = []\nfor n in range(1,10**4):\n    p, m = prime(n), 1\n    p2 = p*p\n    for i in range(2,p):\n        m = (m*i) % p2\n    if m == p2-1:\n        A007540_list.append(p) \n"}
{"sequence_id": "A007542", "text": "Successive integers produced by Conway's PRIMEGAME.", "sequence": "2,15,825,725,1925,2275,425,390,330,290,770,910,170,156,132,116,308,364,68,4,30,225,12375,10875,28875,25375,67375,79625,14875,13650,2550,2340,1980,1740,4620,4060,10780,12740,2380,2184,408,152", "code": "\nfrom fractions import Fraction\nnums = [17, 78, 19, 23, 29, 77, 95, 77,  1, 11, 13, 15, 1, 55] \ndens = [91, 85, 51, 38, 33, 29, 23, 19, 17, 13, 11,  2, 7,  1] \nPRIMEGAME = [Fraction(num, den) for num, den in zip(nums, dens)]\ndef succ(n, program):\n  for i in range(len(program)):\n    if (n*program[i]).denominator == 1: return (n*program[i]).numerator\ndef orbit(start, program, steps):\n  orb = [start]\n  for s in range(1, steps): orb.append(succ(orb[-1], program))\n  return orb\nprint(orbit(2, PRIMEGAME, steps=42)) \n"}
{"sequence_id": "A007569", "text": "Number of nodes in regular n-gon with all diagonals drawn.", "sequence": "1,2,3,5,10,19,42,57,135,171,341,313,728,771,1380,1393,2397,1855,3895,3861,6006,5963,8878,7321,12675,12507,17577,17277,23780,16831,31496,30945,40953,40291,52395,47017,66082,65019,82290,80921,101311,84883,123453,121485", "code": "\ndef d(n,m): return not n % m\ndef A007569(n): return 2 if n == 2 else n*(42*d(n,12) - 144*d(n,120) + 60*d(n,18) - 96*d(n,210) + 35*d(n,24)- 38*d(n,30) - 82*d(n,42) - 330*d(n,60) - 144*d(n,84) - 96*d(n,90)) + (n**4 - 6*n**3 + 11*n**2 + 18*n -d(n,2)*(5*n**3 - 45*n**2 + 70*n - 24) - 36*d(n,4)*n - 4*d(n,6)*n*(45*n - 262))//24 \n"}
{"sequence_id": "A007602", "text": "Numbers that are divisible by the product of their digits.", "sequence": "1,2,3,4,5,6,7,8,9,11,12,15,24,36,111,112,115,128,132,135,144,175,212,216,224,312,315,384,432,612,624,672,735,816,1111,1112,1113,1115,1116,1131,1176,1184,1197,1212,1296,1311,1332,1344,1416,1575,1715,2112,2144", "code": "\nfrom operator import mul\nfrom functools import reduce\nA007602 = [n for n in range(1,10**5) if not (str(n).count('0') or n % reduce(mul, (int(d) for d in str(n))))] \n"}
{"sequence_id": "A007605", "text": "Sum of digits of n-th prime.", "sequence": "2,3,5,7,2,4,8,10,5,11,4,10,5,7,11,8,14,7,13,8,10,16,11,17,16,2,4,8,10,5,10,5,11,13,14,7,13,10,14,11,17,10,11,13,17,19,4,7,11,13,8,14,7,8,14,11,17,10,16,11,13,14,10,5,7,11,7,13,14,16,11,17,16,13,19,14,20,19,5", "code": "\nfrom sympy import prime\ndef a(n): return sum(map(int, str(prime(n))))\nprint([a(n) for n in range(1, 80)]) \n"}
{"sequence_id": "A007608", "text": "Nonnegative integers in base -4.", "sequence": "0,1,2,3,130,131,132,133,120,121,122,123,110,111,112,113,100,101,102,103,230,231,232,233,220,221,222,223,210,211,212,213,200,201,202,203,330,331,332,333,320,321,322,323,310,311,312,313,300,301,302,303,13030", "code": "\ndef A007608(n):\n    s, q = '', n\n    while q >= 4 or q < 0:\n        q, r = divmod(q, -4)\n        if r < 0:\n            q += 1\n            r += 4\n        s += str(r)\n    return int(str(q)+s[::-1]) \n"}
{"sequence_id": "A007618", "text": "a(n) = a(n-1) + sum of digits of a(n-1), a(1) = 5.", "sequence": "5,10,11,13,17,25,32,37,47,58,71,79,95,109,119,130,134,142,149,163,173,184,197,214,221,226,236,247,260,268,284,298,317,328,341,349,365,379,398,418,431,439,455,469,488,508,521,529,545,559,578,598,620,628,644", "code": "\nfrom itertools import accumulate\ndef f(an, _): return an + sum(int(d) for d in str(an))\nprint(list(accumulate([5]*55, f))) \n"}
{"sequence_id": "A007623", "text": "Integers written in factorial base.", "sequence": "0,1,10,11,20,21,100,101,110,111,120,121,200,201,210,211,220,221,300,301,310,311,320,321,1000,1001,1010,1011,1020,1021,1100,1101,1110,1111,1120,1121,1200,1201,1210,1211,1220,1221,1300,1301,1310,1311,1320,1321,2000,2001,2010", "code": "\ndef a(n, p=2): return n if n<p else a(n//p, p+1)*10 + n%p\nprint([a(n - 1) for n in range(1, 201)]) \n"}
{"sequence_id": "A007629", "text": "Repfigit (REPetitive FIbonacci-like diGIT) numbers (or Keith numbers).", "sequence": "14,19,28,47,61,75,197,742,1104,1537,2208,2580,3684,4788,7385,7647,7909,31331,34285,34348,55604,62662,86935,93993,120284,129106,147640,156146,174680,183186,298320,355419,694280,925993,1084051,7913837,11436171,33445755,44121607", "code": "\nA007629_list = []\nfor n in range(10,10**9):\n    x = [int(d) for d in str(n)]\n    y = sum(x)\n    while y < n:\n        x, y = x[1:]+[y], 2*y-x[0]\n    if y == n:\n        A007629_list.append(n) \n"}
{"sequence_id": "A007632", "text": "Numbers that are palindromic in bases 2 and 10.", "sequence": "0,1,3,5,7,9,33,99,313,585,717,7447,9009,15351,32223,39993,53235,53835,73737,585585,1758571,1934391,1979791,3129213,5071705,5259525,5841485,13500531,719848917,910373019,939474939,1290880921,7451111547", "code": "\nfrom itertools import chain\nA007632_list = sorted([n for n in chain((int(str(x)+str(x)[::-1]) for x in range(1,10**6)),(int(str(x)+str(x)[-2::-1]) for x in range(10**6))) if bin(n)[2:] == bin(n)[:1:-1]]) \n"}
{"sequence_id": "A007633", "text": "Palindromic in bases 3 and 10.", "sequence": "0,1,2,4,8,121,151,212,242,484,656,757,29092,48884,74647,75457,76267,92929,93739,848848,1521251,2985892,4022204,4219124,4251524,4287824,5737375,7875787,7949497,27711772,83155138,112969211,123464321", "code": "\nfrom itertools import chain\nfrom gmpy2 import digits\nA007633_list = sorted([n for n in chain((int(str(x)+str(x)[::-1]) for x in range(1,10**6)),(int(str(x)+str(x)[-2::-1]) for x in range(10**6))) if digits(n,3) == digits(n,3)[::-1]]) \n"}
{"sequence_id": "A007635", "text": "Primes of form n^2 + n + 17.", "sequence": "17,19,23,29,37,47,59,73,89,107,127,149,173,199,227,257,359,397,479,523,569,617,719,773,829,887,947,1009,1277,1423,1499,1657,1823,1997,2087,2179,2273,2467,2879,3209,3323,3557,3677,3923,4049,4177,4987,5273", "code": "\nfrom sympy import isprime\nit = (n**2 + n + 17 for n in range(250))\nprint([p for p in it if isprime(p)]) \n"}
{"sequence_id": "A007678", "text": "Number of regions in regular n-gon with all diagonals drawn.", "sequence": "0,0,1,4,11,24,50,80,154,220,375,444,781,952,1456,1696,2500,2466,4029,4500,6175,6820,9086,9024,12926,13988,17875,19180,24129,21480,31900,33856,41416,43792,52921,52956,66675,69996,82954,86800,102050", "code": "\ndef d(n,m): return not n % m\ndef A007678(n): return (1176*d(n,12)*n - 3744*d(n,120)*n + 1536*d(n,18)*n - d(n,2)*(5*n**3 - 42*n**2 + 40*n + 48) - 2304*d(n,210)*n + 912*d(n,24)*n - 1728*d(n,30)*n - 36*d(n,4)*n - 2400*d(n,42)*n - 4*d(n,6)*n*(53*n - 310) - 9120*d(n,60)*n - 3744*d(n,84)*n - 2304*d(n,90)*n + 2*n**4 - 12*n**3 + 46*n**2 - 84*n)//48 + 1 \n"}
{"sequence_id": "A007687", "text": "Number of 4-colorings of cyclic group of order n.", "sequence": "3,10,21,44,83,218,271,692,865,2622,2813,9220,9735,35214,35911,135564,136899", "code": "\ndef colorings(n, zp):\n    result = 0\n    f = [0]*zp\n    for i in range(n**zp):\n        for j1 in range(zp):\n            for j2 in range(zp):\n                if (f[j1]+f[j2])%n == f[(j1+j2)%zp]:\n                    break\n            else:\n                continue\n            break\n        else:\n            result += 1\n        f[0] += 1\n        for j in range(zp-1):\n            if f[j] == n:\n                f[j] = 0\n                f[j+1] += 1\n    return result\nprint([colorings(4, k) for k in range(1, 12)])\n\n"}
{"sequence_id": "A007691", "text": "Multiply-perfect numbers: n divides sigma(n).", "sequence": "1,6,28,120,496,672,8128,30240,32760,523776,2178540,23569920,33550336,45532800,142990848,459818240,1379454720,1476304896,8589869056,14182439040,31998395520,43861478400,51001180160,66433720320,137438691328,153003540480,403031236608", "code": "\nfrom sympy import divisor_sigma as sigma\ndef ok(n): return sigma(n, 1)%n == 0\nprint([n for n in range(1, 10**4) if ok(n)]) \n"}
{"sequence_id": "A007703", "text": "Regular primes.", "sequence": "3,5,7,11,13,17,19,23,29,31,41,43,47,53,61,71,73,79,83,89,97,107,109,113,127,137,139,151,163,167,173,179,181,191,193,197,199,211,223,227,229,239,241,251,269,277,281,313,317,331,337,349,359,367,373,383,397,419,431", "code": "\nfrom sympy import prime, isprime, bernoulli\ndef ok(n):\n    for k in range(2, n - 2, 2):\n        if bernoulli(k).as_numer_denom()[0] % n == 0:\n            return 0\n    return isprime(n)\n[n for n in range(3, 501) if ok(n)] \n"}
{"sequence_id": "A007764", "text": "Number of nonintersecting (or self-avoiding) rook paths joining opposite corners of an n X n grid.", "sequence": "1,2,12,184,8512,1262816,575780564,789360053252,3266598486981642,41044208702632496804,1568758030464750013214100,182413291514248049241470885236,64528039343270018963357185158482118,69450664761521361664274701548907358996488", "code": "\n\nfrom graphillion import GraphSet\nimport graphillion.tutorial as tl\ndef A007764(n):\n    if n == 1: return 1\n    universe = tl.grid(n - 1, n - 1)\n    GraphSet.set_universe(universe)\n    start, goal = 1, n * n\n    paths = GraphSet.paths(start, goal)\n    return paths.len()\nprint([A007764(n) for n in range(1, 10)])  \n"}
{"sequence_id": "A007770", "text": "Happy numbers: numbers whose trajectory under iteration of sum of squares of digits map (see A003132) includes 1.", "sequence": "1,7,10,13,19,23,28,31,32,44,49,68,70,79,82,86,91,94,97,100,103,109,129,130,133,139,167,176,188,190,192,193,203,208,219,226,230,236,239,262,263,280,291,293,301,302,310,313,319,320,326,329,331,338", "code": "\ndef ssd(n): return sum(int(d)**2 for d in str(n))\ndef ok(n):\n  while n not in [1, 4]: n = ssd(n) \n  return n==1\ndef aupto(n): return [k for k in range(1, n+1) if ok(k)]\nprint(aupto(338)) \n"}
{"sequence_id": "A007774", "text": "Numbers that are divisible by exactly 2 different primes; numbers n with omega(n) = A001221(n) = 2.", "sequence": "6,10,12,14,15,18,20,21,22,24,26,28,33,34,35,36,38,39,40,44,45,46,48,50,51,52,54,55,56,57,58,62,63,65,68,69,72,74,75,76,77,80,82,85,86,87,88,91,92,93,94,95,96,98,99,100,104,106,108,111,112,115,116,117,118", "code": "\nfrom sympy import primefactors\nA007774_list = [n for n in range(1,10**5) if len(primefactors(n)) == 2] \n"}
{"sequence_id": "A007787", "text": "Number of nonintersecting rook paths joining opposite corners of 5 X n board.", "sequence": "1,16,125,976,8512,79384,752061,7110272,67005561,630588698,5933085772,55827318685,525343024814,4943673540576,46521924780255,437788749723725,4119750109152730,38768318191017931,364823700357765771,3433121323699285343", "code": "\n\nfrom graphillion import GraphSet\nimport graphillion.tutorial as tl\ndef A064298(n, k):\n    if n == 1 or k == 1: return 1\n    universe = tl.grid(n - 1, k - 1)\n    GraphSet.set_universe(universe)\n    start, goal = 1, k * n\n    paths = GraphSet.paths(start, goal)\n    return paths.len()\ndef A007787(n):\n    return A064298(n, 5)\nprint([A007787(n) for n in range(1, 20)])  \n"}
{"sequence_id": "A007809", "text": "Smallest prime with n distinct digits.", "sequence": "2,13,103,1039,10243,102359,1023467,10234589,102345689", "code": "\nfrom sympy import nextprime\ndef a(n):\n  p = nextprime(10**(n-1))\n  while len(set(str(p))) < n: p = nextprime(p)\n  return p\nfor n in range(1, 10):\n  print(a(n), end=\", \") \n"}
{"sequence_id": "A007814", "text": "Exponent of highest power of 2 dividing n, a.k.a. the binary carry sequence, the ruler sequence, or the 2-adic valuation of n.", "sequence": "0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0", "code": "\nimport math\ndef a(n): return int(math.log(n - (n & n - 1), 2)) \n"}
{"sequence_id": "A007852", "text": "Antichains in rooted plane trees on n nodes.", "sequence": "1,2,7,29,131,625,3099,15818,82595,439259,2371632,12967707,71669167,399751019,2247488837,12723799989,72474333715,415046380767,2388355096446,13803034008095,80082677184820,466263828731640,2723428895205210,15954063529603565,93711351580424391", "code": "\ndef a(n):\n   l = [0,1,2,7]\n   if n < 4:\n      return l[n]\n   for i in range(n-3):\n      l[i%4] = ( (-500*i+2000*i**3)*l[i%4]+(120-220*i-1380*i**2-920*i**3)*l[(i+1)%4]+(-1488-1626*i-387*i**2+21*i**3)*l[(i+2)%4]+(1088*i+1104+351*i**2+37*i**3)*l[(i+3)%4] ) / (+42*i**2+146*i+168+4*i**3)\n   return l[i%4]\n\n"}
{"sequence_id": "A007895", "text": "Number of terms in Zeckendorf representation of n (write n as a sum of non-consecutive distinct Fibonacci numbers).", "sequence": "0,1,1,1,2,1,2,2,1,2,2,2,3,1,2,2,2,3,2,3,3,1,2,2,2,3,2,3,3,2,3,3,3,4,1,2,2,2,3,2,3,3,2,3,3,3,4,2,3,3,3,4,3,4,4,1,2,2,2,3,2,3,3,2,3,3,3,4,2,3,3,3,4,3,4,4,2,3,3,3,4,3,4,4,3,4,4,4,5,1,2,2,2,3,2,3,3,2,3,3,3,4,2,3,3", "code": "\nfrom sympy import fibonacci\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return str(x).count(\"1\")\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A007908", "text": "Triangle of the gods: to get a(n), concatenate the decimal numbers 1,2,3,...,n.", "sequence": "1,12,123,1234,12345,123456,1234567,12345678,123456789,12345678910,1234567891011,123456789101112,12345678910111213,1234567891011121314,123456789101112131415,12345678910111213141516,1234567891011121314151617,123456789101112131415161718", "code": "\ndef a(n): return int(\"\".join(map(str, range(1, n+1))))\nprint([a(n) for n in range(1, 18)]) \n"}
{"sequence_id": "A007913", "text": "Squarefree part of n: a(n) is the smallest positive number m such that n/m is a square.", "sequence": "1,2,3,1,5,6,7,2,1,10,11,3,13,14,15,1,17,2,19,5,21,22,23,6,1,26,3,7,29,30,31,2,33,34,35,1,37,38,39,10,41,42,43,11,5,46,47,3,1,2,51,13,53,6,55,14,57,58,59,15,61,62,7,1,65,66,67,17,69,70,71,2,73,74,3,19,77", "code": "\nfrom sympy import factorint, prod\ndef A007913(n):\n    return prod(p for p, e in factorint(n).items() if e % 2)\n\n"}
{"sequence_id": "A007921", "text": "Numbers that are not the difference of two primes.", "sequence": "7,13,19,23,25,31,33,37,43,47,49,53,55,61,63,67,73,75,79,83,85,89,91,93,97,103,109,113,115,117,119,121,123,127,131,133,139,141,143,145,151,153,157,159,163,167,169,173,175,181,183,185,187,193", "code": "\nfrom sympy import isprime\nprint([n for n in range(1, 200) if n%2 and not isprime(n + 2)]) \n"}
{"sequence_id": "A007931", "text": "Numbers that contain only 1's and 2's. Nonempty binary strings of length n in lexicographic order.", "sequence": "1,2,11,12,21,22,111,112,121,122,211,212,221,222,1111,1112,1121,1122,1211,1212,1221,1222,2111,2112,2121,2122,2211,2212,2221,2222,11111,11112,11121,11122,11211,11212,11221,11222,12111,12112,12121,12122", "code": "\ndef a(n): return int(bin(n+1)[3:].replace('1', '2').replace('0', '1'))\nprint([a(n) for n in range(1, 45)]) \n"}
{"sequence_id": "A007937", "text": "Nonsquares such that some permutation of digits is a square.", "sequence": "10,18,40,46,52,61,63,90,94,106,108,112,136,148,160,163,180,184,205,211,234,243,250,252,259,265,279,295,297,298,306,316,342,360,406,409,414,418,423,432,448,460,478,481,487,490,502,520,522,526,562,567,592", "code": "\nfrom math import isqrt\nfrom sympy.utilities.iterables import multiset_permutations as mp\ndef sqr(n): return isqrt(n)**2 == n\ndef ok(n):\n    if sqr(n): return False\n    s = str(n)\n    return any(sqr(int(\"\".join(p))) for p in mp(s, len(s)))\nprint([k for k in range(600) if ok(k)]) \n"}
{"sequence_id": "A007947", "text": "Largest squarefree number dividing n: the squarefree kernel of n, rad(n), radical of n.", "sequence": "1,2,3,2,5,6,7,2,3,10,11,6,13,14,15,2,17,6,19,10,21,22,23,6,5,26,3,14,29,30,31,2,33,34,35,6,37,38,39,10,41,42,43,22,15,46,47,6,7,10,51,26,53,6,55,14,57,58,59,30,61,62,21,2,65,66,67,34,69,70,71,6,73,74,15,38,77,78", "code": "\nfrom sympy import primefactors, prod\ndef a(n): return 1 if n < 2 else prod(primefactors(n))\n[a(n) for n in range(1, 51)]  \n"}
{"sequence_id": "A007949", "text": "Greatest k such that 3^k divides n. Or, 3-adic valuation of n.", "sequence": "0,0,1,0,0,1,0,0,2,0,0,1,0,0,1,0,0,2,0,0,1,0,0,1,0,0,3,0,0,1,0,0,1,0,0,2,0,0,1,0,0,1,0,0,2,0,0,1,0,0,1,0,0,3,0,0,1,0,0,1,0,0,2,0,0,1,0,0,1,0,0,2,0,0,1,0,0,1,0,0,4,0,0,1,0,0,1,0,0,2,0,0,1,0,0,1,0,0,2,0,0,1,0,0,1", "code": "\ndef a(n):\n    k = 0\n    while n > 0 and n%3 == 0: n //= 3; k += 1\n    return k\nprint([a(n) for n in range(1, 106)]) \n"}
{"sequence_id": "A007953", "text": "Digital sum (i.e., sum of digits) of n; also called digsum(n).", "sequence": "0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7,8,9,10,11,12,13,14,6,7,8,9,10,11,12,13,14,15,7,8,9,10,11,12,13,14,15,16,8,9,10,11,12,13,14,15", "code": "\ndef A007953(n):\n    return sum(int(d) for d in str(n)) \n"}
{"sequence_id": "A007953", "text": "Digital sum (i.e., sum of digits) of n; also called digsum(n).", "sequence": "0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7,8,9,10,11,12,13,14,6,7,8,9,10,11,12,13,14,15,7,8,9,10,11,12,13,14,15,16,8,9,10,11,12,13,14,15", "code": "\ndef a(n): return sum(map(int, str(n))) \n"}
{"sequence_id": "A007955", "text": "Product of divisors of n.", "sequence": "1,2,3,8,5,36,7,64,27,100,11,1728,13,196,225,1024,17,5832,19,8000,441,484,23,331776,125,676,729,21952,29,810000,31,32768,1089,1156,1225,10077696,37,1444,1521,2560000,41,3111696,43,85184,91125,2116,47", "code": "\nfrom sympy import prod, divisors\nprint([prod(divisors(n)) for n in range(1, 51)]) \n"}
{"sequence_id": "A007958", "text": "Even numbers with at least one odd digit.", "sequence": "10,12,14,16,18,30,32,34,36,38,50,52,54,56,58,70,72,74,76,78,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162", "code": "\ndef ok(n): return n%2 == 0 and set(str(n)) & set(\"13579\") != set()\nprint(list(filter(ok, range(163)))) \n"}
{"sequence_id": "A008280", "text": "Boustrophedon version of triangle of Euler-Bernoulli or Entringer numbers read by rows.", "sequence": "1,0,1,1,1,0,0,1,2,2,5,5,4,2,0,0,5,10,14,16,16,61,61,56,46,32,16,0,0,61,122,178,224,256,272,272,1385,1385,1324,1202,1024,800,544,272,0,0,1385,2770,4094,5296,6320,7120,7664,7936,7936", "code": " \nfrom itertools import accumulate\nA008280_list = blist = [1]\nfor n in range(10):\n    blist = list(reversed(list(accumulate(reversed(blist))))) + [0] if n % 2 else [0]+list(accumulate(blist))\n    A008280_list.extend(blist)\nprint(A008280_list) \n"}
{"sequence_id": "A008281", "text": "Triangle of Euler-Bernoulli or Entringer numbers read by rows.", "sequence": "1,0,1,0,1,1,0,1,2,2,0,2,4,5,5,0,5,10,14,16,16,0,16,32,46,56,61,61,0,61,122,178,224,256,272,272,0,272,544,800,1024,1202,1324,1385,1385,0,1385,2770,4094,5296,6320,7120,7664,7936,7936", "code": "\n\nfrom itertools import accumulate\nA008281_list = blist = [1]\nfor _ in range(30):\n....blist = [0]+list(accumulate(reversed(blist)))\n....A008281_list.extend(blist) \n"}
{"sequence_id": "A008292", "text": "Triangle of Eulerian numbers T(n,k) (n >= 1, 1 <= k <= n) read by rows.", "sequence": "1,1,1,1,4,1,1,11,11,1,1,26,66,26,1,1,57,302,302,57,1,1,120,1191,2416,1191,120,1,1,247,4293,15619,15619,4293,247,1,1,502,14608,88234,156190,88234,14608,502,1,1,1013,47840,455192,1310354,1310354,455192,47840,1013,1", "code": "\nfrom sympy import binomial\ndef T(n, k): return sum([(-1)**j*(k - j)**n*binomial(n + 1, j) for j in range(k + 1)])\nfor n in range(1, 11): print([T(n, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A008349", "text": "Crystal ball sequence for E_8 lattice.", "sequence": "1,241,9361,131041,996001,5109841,20015281,64495681,179375041,444798001,1006201681,2111519521,4162485601,7783236241,13909734001,23903867521,39696408961,63963339121,100340378641,153680892001", "code": "\nA008349_list, m = [], [328320, -1071360, 1347840, -812160, 233280, -25920, 240, 0, 1]\nfor _ in range(10**2):\n    A008349_list.append(m[-1])\n    for i in range(8):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A008415", "text": "Coordination sequence for 7-dimensional cubic lattice.", "sequence": "1,14,98,462,1666,4942,12642,28814,59906,115598,209762,361550,596610,948430,1459810,2184462,3188738,4553486,6376034,8772302,11879042,15856206,20889442,27192718,35011074,44623502,56345954,70534478", "code": "\nR = []\nfor n in range(29):\n    r=4*n*n*(2*n*n +7)*(n*n +14)//45 +2-0**n\n    R.append(r)\nprint(R)\n\n"}
{"sequence_id": "A008470", "text": "At least 3 out of 10m+1, 10m+3, 10m+7, 10m+9 are primes.", "sequence": "1,4,7,10,13,19,22,31,43,46,61,64,82,85,88,103,106,109,130,142,145,148,160,166,169,178,187,199,208,238,268,271,316,325,346,367,376,391,400,409,415,421,451,472,478,493,523,541,544,547,550,565,574,586,670,682", "code": "\nfrom sympy import isprime\ndef ok(m): return sum(isprime(10*m+i) for i in [1, 3, 7, 9]) >= 3\nprint(list(filter(ok, range(700)))) \n"}
{"sequence_id": "A008475", "text": "If n = Product (p_j^k_j) then a(n) = Sum (p_j^k_j) (a(1) = 0 by convention).", "sequence": "0,2,3,4,5,5,7,8,9,7,11,7,13,9,8,16,17,11,19,9,10,13,23,11,25,15,27,11,29,10,31,32,14,19,12,13,37,21,16,13,41,12,43,15,14,25,47,19,49,27,20,17,53,29,16,15,22,31,59,12,61,33,16,64,18,16,67,21,26,14,71,17,73", "code": "\nfrom sympy import factorint\ndef a(n):\n    f=factorint(n)\n    return 0 if n==1 else sum([i**f[i] for i in f]) \n"}
{"sequence_id": "A008506", "text": "12-dimensional centered tetrahedral numbers.", "sequence": "1,14,105,560,2380,8568,27132,77520,203490,497420,1144066,2496144,5200300,10400599,20058286,37442055,67863355,119757470,206244507,347346468,573088920,927780270,1475840380,2309645534,3559971156,5409749996", "code": "\nA008506_list, m = [], [13, -65, 221, -494, 793, -923, 793, -494, 221, -65, 13, 0, 1]\nfor _ in range(10**2):\n    A008506_list.append(m[-1])\n    for i in range(12):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A008549", "text": "Number of ways of choosing at most n-1 items from a set of size 2*n+1.", "sequence": "0,1,6,29,130,562,2380,9949,41226,169766,695860,2842226,11576916,47050564,190876696,773201629,3128164186,12642301534,51046844836,205954642534,830382690556,3345997029244,13475470680616,54244942336114,218269673491780,877940640368572", "code": "\nimport math\ndef C(n,r):\n....f=math.factorial\n....return f(n)/f(r)/f(n-r)\ndef A008549(n):\n....return str((4**n)-C(2*n+1,n)) \n"}
{"sequence_id": "A008557", "text": "Repeatedly convert from decimal to octal.", "sequence": "8,10,12,14,16,20,24,30,36,44,54,66,102,146,222,336,520,1010,1762,3342,6416,14420,34124,102514,310162,1135622,4252006,20160546,114720042,665476452,4752456544,43321135540,502611010664,7240574662150,151272370273006", "code": "\ndef aupton(terms):\n    alst = [8]\n    for n in range(2, terms+1): alst.append(int(oct(alst[-1])[2:]))\n    return alst\nprint(aupton(35)) \n"}
{"sequence_id": "A008558", "text": "Repeatedly convert from decimal to octal.", "sequence": "9,11,13,15,17,21,25,31,37,45,55,67,103,147,223,337,521,1011,1763,3343,6417,14421,34125,102515,310163,1135623,4252007,20160547,114720043,665476453,4752456545,43321135541,502611010665,7240574662151,151272370273007", "code": "\ndef aupton(terms):\n    alst = [9]\n    for n in range(2, terms+1): alst.append(int(oct(alst[-1])[2:]))\n    return alst\nprint(aupton(35)) \n"}
{"sequence_id": "A008559", "text": "a(1)=2; thereafter, convert a(n-1) from base 10 to base 2 but regard the result as a base 10 number.", "sequence": "2,10,1010,1111110010,1000010001110100011000101111010", "code": "\nA008559_list = [2]\nfor _ in range(5):\n....A008559_list.append(int(bin(A008559_list[-1])[2:]))\n\n"}
{"sequence_id": "A008683", "text": "M\u00f6bius (or Moebius) function mu(n). mu(1) = 1; mu(n) = (-1)^k if n is the product of k different primes; otherwise mu(n) = 0.", "sequence": "1,-1,-1,0,-1,1,-1,0,0,1,-1,0,-1,1,1,0,-1,0,-1,0,1,1,-1,0,0,1,0,0,-1,-1,-1,0,1,1,1,0,-1,1,1,0,-1,-1,-1,0,0,1,-1,0,0,0,1,0,-1,0,1,0,1,1,-1,0,-1,1,0,0,1,-1,-1,0,1,-1,-1,0,-1,1,0,0,1,-1", "code": "\nfrom sympy import mobius\nprint([mobius(i) for i in range(1, 101)])  \n"}
{"sequence_id": "A008830", "text": "Discrete logarithm of n to the base 2 modulo 11.", "sequence": "0,1,8,2,4,9,7,3,6,5", "code": "\nfrom sympy.ntheory import discrete_log\ndef a(n): return discrete_log(11, n, 2)\nprint([a(n) for n in range(1, 11)]) \n"}
{"sequence_id": "A008831", "text": "Discrete logarithm of n to the base 2 modulo 13.", "sequence": "0,1,4,2,9,5,11,3,8,10,7,6", "code": "\nfrom sympy.ntheory import discrete_log\ndef a(n): return discrete_log(13, n, 2)\nprint([a(n) for n in range(1, 13)]) \n"}
{"sequence_id": "A008832", "text": "Discrete logarithm of n to the base 2 modulo 19.", "sequence": "0,1,13,2,16,14,6,3,8,17,12,15,5,7,11,4,10,9", "code": "\nfrom sympy.ntheory import discrete_log\ndef a(n): return discrete_log(19, n, 2)\nprint([a(n) for n in range(1, 19)]) \n"}
{"sequence_id": "A008849", "text": "Numbers n such that the sum of divisors of n^3 is a square.", "sequence": "1,7,751530,4730879,5260710,33116153,37200735,187062910,226141311,259109835,260405145,370049418,522409465,836308083,1105725765,1309440370,1343713507,1582989177,1609505430,1813768845,2590345926,3039492538,3656866255", "code": "\nfrom functools import reduce\nfrom operator import mul\nfrom sympy import factorint, integer_nthroot\nA008849_list, n = [], 1\nwhile n < 10**7:\n    fs = factorint(n)\n    if integer_nthroot(reduce(mul,((p**(3*fs[p]+1)-1)//(p-1) for p in fs),1),2)[1]:\n        A008849_list.append(n)\n    n += 1 \n"}
{"sequence_id": "A008863", "text": "a(n) = Sum_{k=0..10} C(n,k).", "sequence": "1,2,4,8,16,32,64,128,256,512,1024,2047,4083,8100,15914,30827,58651,109294,199140,354522,616666,1048576,1744436,2842226,4540386,7119516,10970272,16628809,24821333,36519556,53009102,75973189,107594213,150676186,208791332", "code": "\nA008863_list, m = [], [1, -8, 29, -62, 86, -80, 50, -20, 5, 0, 1]\nfor _ in range(10**2):\n    A008863_list.append(m[-1])\n    for i in range(10):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A008904", "text": "a(n) is the final nonzero digit of n!.", "sequence": "1,1,2,6,4,2,2,4,2,8,8,8,6,8,2,8,8,6,8,2,4,4,8,4,6,4,4,8,4,6,8,8,6,8,2,2,2,4,2,8,2,2,4,2,8,6,6,2,6,4,2,2,4,2,8,4,4,8,4,6,6,6,2,6,4,6,6,2,6,4,8,8,6,8,2,4,4,8,4,6,8,8,6,8,2,2,2,4,2,8,2,2,4,2,8,6,6,2,6", "code": "\ndef a(n):\n    if n <= 1: return 1\n    return 6*[1,1,2,6,4,4,4,8,4,6][n%10]*3**(n/5%4)*a(n/5)%10\n\n"}
{"sequence_id": "A008906", "text": "Number of digits in n! excluding final zeros.", "sequence": "1,1,1,1,2,2,2,3,4,5,5,6,7,8,9,10,11,12,13,15,15,16,18,19,20,20,21,23,24,25,26,27,29,30,32,33,34,36,37,39,39,41,43,44,46,47,48,50,52,53,53,55,56,58,60,61,62,64,66,68,68,70,72,74,76,76,78,80,82,84,85,86,88,90,92,92,94", "code": "\nfrom math import factorial\ndef A008906(n): return len(str(factorial(n)).rstrip('0')) \n"}
{"sequence_id": "A008908", "text": "(1 + number of halving and tripling steps to reach 1 in the Collatz (3x+1) problem), or -1 if 1 is never reached.", "sequence": "1,2,8,3,6,9,17,4,20,7,15,10,10,18,18,5,13,21,21,8,8,16,16,11,24,11,112,19,19,19,107,6,27,14,14,22,22,22,35,9,110,9,30,17,17,17,105,12,25,25,25,12,12,113,113,20,33,20,33,20,20,108,108,7,28,28,28,15,15,15,103", "code": "\ndef a(n):\n    if n==1: return 1\n    x=1\n    while True:\n        if n%2==0: n//=2\n        else: n = 3*n + 1\n        x+=1\n        if n<2: break\n    return x\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A009000", "text": "Ordered hypotenuse numbers (squares are sums of 2 distinct nonzero squares).", "sequence": "5,10,13,15,17,20,25,25,26,29,30,34,35,37,39,40,41,45,50,50,51,52,53,55,58,60,61,65,65,65,65,68,70,73,74,75,75,78,80,82,85,85,85,85,87,89,90,91,95,97,100,100,101,102,104,105,106,109,110,111,113,115,116,117,119,120", "code": "\nfrom math import isqrt\ndef aupto(limit):\n  s = [i*i for i in range(1, limit+1)]\n  s2 = sorted(a+b for i, a in enumerate(s) for b in s[i+1:])\n  return [isqrt(k) for k in s2 if k in s]\nprint(aupto(120)) \n"}
{"sequence_id": "A009195", "text": "a(n) = gcd(n, phi(n)).", "sequence": "1,1,1,2,1,2,1,4,3,2,1,4,1,2,1,8,1,6,1,4,3,2,1,8,5,2,9,4,1,2,1,16,1,2,1,12,1,2,3,8,1,6,1,4,3,2,1,16,7,10,1,4,1,18,5,8,3,2,1,4,1,2,9,32,1,2,1,4,1,2,1,24,1,2,5,4,1,6,1,16,27,2,1,12,1,2,1,8,1,6,1,4,3,2,1,32,1,14,3,20", "code": "\ndef a009195(n):\n    from math import gcd\n    phi = lambda x: len([i for i in range(x) if gcd(x,i) == 1])\n    return gcd(n, phi(n))\n\n"}
{"sequence_id": "A009421", "text": "Cubes, not ending in 0, formed by concatenating other cubes.", "sequence": "10648,27818127,1018108216,11728027648,27081081027,216108018001,216648648216,1001801080216,27008100810027,125112533753375,125180086413824,216010800180001,216064806480216,216270112515625,1000180010800216,1728648081003375,1812501158328125", "code": "\nfrom sympy import integer_nthroot\ndef iscube(n): return integer_nthroot(n, 3)[1]\ndef ok3(n, c):\n    if n%10 == 9 or (c == 1 and n%10 == 0): return False\n    if c > 1 and iscube(n): return True\n    d = str(n)\n    for i in range(1, len(d)):\n        if iscube(int(d[:i])) and ok3(int(d[i:]), c+1): return True\n    return False\nprint([r**3 for r in range(122000) if ok3(r**3, 1)]) \n"}
{"sequence_id": "A009843", "text": "E.g.f. x/cos(x) (odd powers only).", "sequence": "1,3,25,427,12465,555731,35135945,2990414715,329655706465,45692713833379,7777794952988025,1595024111042171723,387863354088927172625,110350957750914345093747,36315529600705266098580265,13687860690719716241164167451,5858139922124796551409938058945", "code": " \n\ndef A009843_list(n):\n    S = [0 for i in range(n+1)]\n    S[0] = 1\n    for k in range(1, n+1):\n        S[k] = k*S[k-1]\n    for k in range(1, n+1):\n        for j in range(k, n+1):\n            S[j] = (j-k)*S[j-1]+(j-k+1)*S[j]\n        S[k] = (2*k+1)*S[k]\n    return S\nprint(A009843_list(10)) \n"}
{"sequence_id": "A009964", "text": "Powers of 20.", "sequence": "1,20,400,8000,160000,3200000,64000000,1280000000,25600000000,512000000000,10240000000000,204800000000000,4096000000000000,81920000000000000,1638400000000000000,32768000000000000000", "code": " [20**n for n in range(21)] \n"}
{"sequence_id": "A009968", "text": "Powers of 24: a(n) = 24^n.", "sequence": "1,24,576,13824,331776,7962624,191102976,4586471424,110075314176,2641807540224,63403380965376,1521681143169024,36520347436056576,876488338465357824,21035720123168587776,504857282956046106624,12116574790945106558976,290797794982682557415424,6979147079584381377970176,167499529910025153071284224,4019988717840603673710821376", "code": " [24**n for n in range(21)] \n"}
{"sequence_id": "A009992", "text": "Powers of 48: a(n) = 48^n.", "sequence": "1,48,2304,110592,5308416,254803968,12230590464,587068342272,28179280429056,1352605460594688,64925062108545024,3116402981210161152,149587343098087735296,7180192468708211294208,344649238497994142121984,16543163447903718821855232", "code": " for n in range(0,20): print(48**n, end=', ') \n"}
{"sequence_id": "A009994", "text": "Numbers with digits in nondecreasing order.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,22,23,24,25,26,27,28,29,33,34,35,36,37,38,39,44,45,46,47,48,49,55,56,57,58,59,66,67,68,69,77,78,79,88,89,99,111,112,113,114,115,116,117,118,119,122", "code": "\nfrom itertools import combinations_with_replacement\ndef A009994generator():\n    yield 0\n    l = 1\n    while True:\n        for i in combinations_with_replacement('123456789',l):\n            yield int(''.join(i))\n        l += 1 \n"}
{"sequence_id": "A010057", "text": "a(n) = 1 if n is a cube, else 0.", "sequence": "1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom sympy import integer_nthroot\ndef A010057(n): return int(integer_nthroot(n,3)[1]) \n"}
{"sequence_id": "A010060", "text": "Thue-Morse sequence: let A_k denote the first 2^k terms; then A_0 = 0 and for k >= 0, A_{k+1} = A_k B_k, where B_k is obtained from A_k by interchanging 0's and 1's.", "sequence": "0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1", "code": "\nA010060_list = [0]\nfor _ in range(14):\n    A010060_list += [1-d for d in A010060_list] \n"}
{"sequence_id": "A010159", "text": "Continued fraction for sqrt(86).", "sequence": "9,3,1,1,1,8,1,1,1,3,18,3,1,1,1,8,1,1,1,3,18,3,1,1,1,8,1,1,1,3,18,3,1,1,1,8,1,1,1,3,18,3,1,1,1,8,1,1,1,3,18,3,1,1,1,8,1,1,1,3,18,3,1,1,1,8,1,1,1,3,18,3,1,1,1,8,1,1", "code": "\nfrom sympy import sqrt\nfrom sympy.ntheory.continued_fraction import continued_fraction_iterator\ndef aupton(terms):\n    gen = continued_fraction_iterator(sqrt(86))\n    return [next(gen) for i in range(terms)]\nprint(aupton(78)) \n"}
{"sequence_id": "A010171", "text": "Continued fraction for sqrt(103).", "sequence": "10,6,1,2,1,1,9,1,1,2,1,6,20,6,1,2,1,1,9,1,1,2,1,6,20,6,1,2,1,1,9,1,1,2,1,6,20,6,1,2,1,1,9,1,1,2,1,6,20,6,1,2,1,1,9,1,1,2,1,6,20,6,1,2,1,1,9,1,1,2,1,6,20,6,1,2,1,1,9,1,1,2,1,6,20", "code": "\nfrom sympy import sqrt\nfrom sympy.ntheory.continued_fraction import continued_fraction_iterator\ndef aupton(terms):\n    gen = continued_fraction_iterator(sqrt(103))\n    return [next(gen) for i in range(terms)]\nprint(aupton(85)) \n"}
{"sequence_id": "A010172", "text": "Continued fraction for sqrt(106).", "sequence": "10,3,2,1,1,1,1,2,3,20,3,2,1,1,1,1,2,3,20,3,2,1,1,1,1,2,3,20,3,2,1,1,1,1,2,3,20,3,2,1,1,1,1,2,3,20,3,2,1,1,1,1,2,3,20,3,2,1,1,1,1,2,3,20,3,2,1,1,1,1,2,3,20,3,2,1,1,1,1,2,3,20,3,2", "code": "\nfrom sympy import sqrt\nfrom sympy.ntheory.continued_fraction import continued_fraction_iterator\ndef aupton(terms):\n    gen = continued_fraction_iterator(sqrt(106))\n    return [next(gen) for i in range(terms)]\nprint(aupton(82)) \n"}
{"sequence_id": "A010173", "text": "Continued fraction for sqrt(107).", "sequence": "10,2,1,9,1,2,20,2,1,9,1,2,20,2,1,9,1,2,20,2,1,9,1,2,20,2,1,9,1,2,20,2,1,9,1,2,20,2,1,9,1,2,20,2,1,9,1,2,20,2,1,9,1,2,20,2,1,9,1,2,20,2,1,9,1,2,20,2,1,9,1,2,20,2,1", "code": "\nfrom sympy import sqrt\nfrom sympy.ntheory.continued_fraction import continued_fraction_iterator\ndef aupton(terms):\n    gen = continued_fraction_iterator(sqrt(107))\n    return [next(gen) for i in range(terms)]\nprint(aupton(82)) \n"}
{"sequence_id": "A010338", "text": "Numbers k such that the continued fraction for sqrt(k) has period 7.", "sequence": "58,73,202,250,274,314,349,425,538,761,1010,1073,1130,1301,1546,1745,1825,1898,2050,2173,2258,2330,2482,2581,2777,3161,3202,3554,3877,3890,4106,4133,4346,4586,4925,5162,5261,5273,5297,5305", "code": "\nfrom sympy import continued_fraction_periodic\nA010338_list = [n for n, s in ((i, continued_fraction_periodic(0,1,i)[-1]) for i in range(1,10**3)) if isinstance(s, list) and len(s) == 7] \n"}
{"sequence_id": "A010536", "text": "Decimal expansion of square root of 85.", "sequence": "9,2,1,9,5,4,4,4,5,7,2,9,2,8,8,7,3,1,0,0,0,2,2,7,4,2,8,1,7,6,2,7,9,3,1,5,7,2,4,6,8,0,5,0,4,8,7,2,2,4,6,4,0,0,8,0,0,7,7,5,2,2,0,5,4,4,2,6,7,1,0,2,6,8,0,1,8,7,5,4,6,0,7,6,7,8,9,4,0,9,0,7,9,3,2,8,0,5,6", "code": "\nfrom math import isqrt\ndef aupton(nn): return list(map(int, str(isqrt(85 * 10**(2*nn)))))[:nn]\nprint(aupton(100)) \n"}
{"sequence_id": "A010538", "text": "Decimal expansion of square root of 87.", "sequence": "9,3,2,7,3,7,9,0,5,3,0,8,8,8,1,5,0,4,5,5,5,4,4,7,5,5,4,2,3,2,0,5,5,6,9,8,3,2,7,6,2,4,0,6,9,4,1,9,1,6,5,4,6,7,1,0,5,6,1,9,7,2,9,8,4,4,6,7,8,4,5,4,8,8,0,7,2,4,9,6,7,8,4,1,4,2,2,0,5,6,2,9,1,1,8,8,2,0,1", "code": "\nfrom math import isqrt\ndef aupton(nn): return list(map(int, str(isqrt(87 * 10**(2*nn)))))[:nn]\nprint(aupton(100)) \n"}
{"sequence_id": "A010539", "text": "Decimal expansion of square root of 88.", "sequence": "9,3,8,0,8,3,1,5,1,9,6,4,6,8,5,9,1,0,9,1,3,1,2,6,0,2,2,7,0,8,8,9,3,2,5,6,1,1,7,6,4,5,6,7,0,6,8,2,3,4,7,4,3,0,7,2,1,1,4,0,3,7,8,2,0,3,4,0,4,9,2,6,5,5,0,6,4,7,9,4,4,2,9,6,4,2,3,1,1,9,2,1,2,3,0,8,6,2,7", "code": "\nfrom math import isqrt\ndef aupton(nn): return list(map(int, str(isqrt(88 * 10**(2*nn)))))[:nn]\nprint(aupton(100)) \n"}
{"sequence_id": "A010540", "text": "Decimal expansion of square root of 89.", "sequence": "9,4,3,3,9,8,1,1,3,2,0,5,6,6,0,3,8,1,1,3,2,0,6,6,0,3,7,7,6,2,2,6,4,0,7,1,6,9,8,3,6,2,2,6,3,3,4,1,5,1,2,1,3,2,0,6,6,2,9,8,1,4,4,8,9,8,0,0,2,2,9,0,9,5,8,5,1,1,8,0,5,8,5,4,1,0,2,6,9,8,6,8,9,0,3,8,4,1,0", "code": "\nfrom math import isqrt\ndef aupton(nn): return list(map(int, str(isqrt(89 * 10**(2*nn)))))[:nn]\nprint(aupton(100)) \n"}
{"sequence_id": "A010541", "text": "Decimal expansion of square root of 90.", "sequence": "9,4,8,6,8,3,2,9,8,0,5,0,5,1,3,7,9,9,5,9,9,6,6,8,0,6,3,3,2,9,8,1,5,5,6,0,1,1,5,8,6,6,5,4,1,7,9,7,5,6,5,0,4,8,0,5,7,2,5,1,4,5,5,8,3,7,7,7,8,3,3,1,5,9,1,7,7,1,4,6,6,4,0,3,2,7,4,4,3,2,5,1,3,7,9,0,0,8,8", "code": "\nfrom math import isqrt\ndef aupton(nn): return list(map(int, str(isqrt(90 * 10**(2*nn)))))[:nn]\nprint(aupton(100)) \n"}
{"sequence_id": "A010542", "text": "Decimal expansion of square root of 91.", "sequence": "9,5,3,9,3,9,2,0,1,4,1,6,9,4,5,6,4,9,1,5,2,6,2,1,5,8,6,0,2,3,2,2,6,5,4,0,2,5,4,6,2,3,4,2,5,2,5,0,5,4,5,7,5,3,9,0,8,1,5,1,8,5,2,9,1,0,3,6,2,5,5,2,3,0,5,6,5,0,7,2,1,8,2,7,7,8,2,1,7,6,4,4,9,1,2,2,0,6,9", "code": "\nfrom math import isqrt\ndef aupton(nn): return list(map(int, str(isqrt(91 * 10**(2*nn)))))[:nn]\nprint(aupton(100)) \n"}
{"sequence_id": "A010543", "text": "Decimal expansion of square root of 92.", "sequence": "9,5,9,1,6,6,3,0,4,6,6,2,5,4,3,9,0,8,3,1,9,4,8,7,6,1,2,8,3,2,5,3,8,7,8,3,9,9,9,3,4,1,4,0,8,3,8,0,8,2,5,8,6,9,2,9,7,0,6,1,8,2,2,8,8,9,6,5,1,4,4,7,1,8,1,4,9,2,8,1,6,4,9,8,4,3,8,2,8,9,2,8,7,3,8,3,7,7,2", "code": "\nfrom math import isqrt\ndef aupton(nn): return list(map(int, str(isqrt(92 * 10**(2*nn)))))[:nn]\nprint(aupton(100)) \n"}
{"sequence_id": "A010784", "text": "Numbers with distinct decimal digits.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,34,35,36,37,38,39,40,41,42,43,45,46,47,48,49,50,51,52,53,54,56,57,58,59,60,61,62,63,64,65,67,68,69,70,71,72,73,74,75,76,78,79,80,81,82,83,84,85,86,87,89,90,91,92,93,94,95,96,97,98,102,103,104,105,106,107,108,109,120", "code": "\nA010784_list = [n for n in range(10**6) if len(set(str(n))) == len(str(n))] \n"}
{"sequence_id": "A010815", "text": "From Euler's Pentagonal Theorem: coefficient of q^n in Product_{m>=1} (1 - q^m).", "sequence": "1,-1,-1,0,0,1,0,1,0,0,0,0,-1,0,0,-1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1", "code": "\nfrom math import isqrt\ndef A010815(n):\n    m = isqrt(24*n+1)\n    return 0 if m**2 != 24*n+1 else ((-1)**((m-1)//6) if m % 6 == 1 else (-1)**((m+1)//6)) \n"}
{"sequence_id": "A010888", "text": "Digital root of n (repeatedly add the digits of n until a single digit is reached).", "sequence": "0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5", "code": "\ndef A010888(n):\n    return 1 + (n - 1) % 9 \n"}
{"sequence_id": "A010892", "text": "Inverse of 6th cyclotomic polynomial. A period 6 sequence.", "sequence": "1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0", "code": "\ndef A010892(n): return [1,1,0,-1,-1,0][n%6] \n"}
{"sequence_id": "A010902", "text": "Pisot sequence E(14,23), a(n) = floor( a(n-1)^2/a(n-2)+1/2 ).", "sequence": "14,23,38,63,104,172,284,469,775,1281,2117,3499,5783,9558,15797,26109,43152,71320,117875,194819,321989,532170,879548,1453680,2402581,3970885,6562912,10846905,17927308,29629500,48970390,80936199,133767942,221086022,365401668", "code": "\na, b = 14, 23\nA010902_list = [a, b]\nfor i in range(1000):\n    c, d = divmod(b**2, a)\n    a, b = b, c + (0 if 2*d < a else 1)\n    A010902_list.append(b) \n"}
{"sequence_id": "A010944", "text": "Binomial coefficient C(28,n).", "sequence": "1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1", "code": "\nfrom sympy import binomial\ndef a(n): return binomial(28, n)\nprint([a(n) for n in range(29)]) \n"}
{"sequence_id": "A011001", "text": "Binomial coefficient C(n,48).", "sequence": "1,49,1225,20825,270725,2869685,25827165,202927725,1420494075,8996462475,52179482355,279871768995,1399358844975,6566222272575,29078984349975,122131734269895,488526937079580,1867897112363100,6848956078664700,24151581961607100", "code": "\nA011001_list, m = [], [1]*49\nfor _ in range(10**2):\n    A011001_list.append(m[-1])\n    for i in range(48):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A011371", "text": "a(n) = n minus (number of 1's in binary expansion of n). Also highest power of 2 dividing n!.", "sequence": "0,0,1,1,3,3,4,4,7,7,8,8,10,10,11,11,15,15,16,16,18,18,19,19,22,22,23,23,25,25,26,26,31,31,32,32,34,34,35,35,38,38,39,39,41,41,42,42,46,46,47,47,49,49,50,50,53,53,54,54,56,56,57,57,63,63,64,64,66,66,67,67,70", "code": " [n - bin(n)[2:].count(\"1\") for n in range(101)] \n"}
{"sequence_id": "A011531", "text": "Numbers that contain a digit 1 in their decimal representation.", "sequence": "1,10,11,12,13,14,15,16,17,18,19,21,31,41,51,61,71,81,91,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133", "code": "\ndef aupto(nn): return [m for m in range(1, nn+1) if '1' in str(m)]\nprint(aupto(133)) \n"}
{"sequence_id": "A011537", "text": "Numbers that contain at least one 7.", "sequence": "7,17,27,37,47,57,67,70,71,72,73,74,75,76,77,78,79,87,97,107,117,127,137,147,157,167,170,171,172,173,174,175,176,177,178,179,187,197,207,217,227,237,247,257,267,270,271,272,273,274,275,276,277,278,279,287", "code": "\ndef ok(n): return '7' in str(n)\nprint(list(filter(ok, range(290)))) \n"}
{"sequence_id": "A011538", "text": "Numbers that contain an 8.", "sequence": "8,18,28,38,48,58,68,78,80,81,82,83,84,85,86,87,88,89,98,108,118,128,138,148,158,168,178,180,181,182,183,184,185,186,187,188,189,198,208,218,228,238,248,258,268,278,280,281,282,283,284,285,286,287,288,289", "code": "\ndef ok(n): return '8' in str(n)\nprint(list(filter(ok, range(290)))) \n"}
{"sequence_id": "A011539", "text": "\"9ish numbers\": decimal representation contains at least one nine.", "sequence": "9,19,29,39,49,59,69,79,89,90,91,92,93,94,95,96,97,98,99,109,119,129,139,149,159,169,179,189,190,191,192,193,194,195,196,197,198,199,209,219,229,239,249,259,269,279,289,290,291,292,293,294,295,296,297,298", "code": "\ndef ok(n): return '9' in str(n)\nprint(list(filter(ok, range(299)))) \n"}
{"sequence_id": "A011540", "text": "Numbers that contain a digit 0.", "sequence": "0,10,20,30,40,50,60,70,80,90,100,101,102,103,104,105,106,107,108,109,110,120,130,140,150,160,170,180,190,200,201,202,203,204,205,206,207,208,209,210,220,230,240,250,260,270,280,290,300,301,302", "code": "\nA011540_list = [n for n in range(10**3) if '0' in str(n)] \n"}
{"sequence_id": "A011543", "text": "Decimal expansion of e truncated to n places.", "sequence": "2,27,271,2718,27182,271828,2718281,27182818,271828182,2718281828,27182818284,271828182845,2718281828459,27182818284590,271828182845904,2718281828459045,27182818284590452,271828182845904523,2718281828459045235,27182818284590452353,271828182845904523536", "code": "\nfrom sympy import E\ndef a(n): return int(E*10**n)\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A011549", "text": "Decimal expansion of sqrt(3) truncated to n places.", "sequence": "1,17,173,1732,17320,173205,1732050,17320508,173205080,1732050807,17320508075,173205080756,1732050807568,17320508075688,173205080756887,1732050807568877,17320508075688772,173205080756887729,1732050807568877293,17320508075688772935", "code": "\nfrom sympy import N, sqrt\ndef a(n): return int(N(sqrt(3), n+1)*10**n)\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A011557", "text": "Powers of 10: a(n) = 10^n.", "sequence": "1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000,100000000000,1000000000000,10000000000000,100000000000000,1000000000000000,10000000000000000,100000000000000000,1000000000000000000", "code": "\nprint([10**n for n in range(19)]) \n"}
{"sequence_id": "A011965", "text": "Second differences of Bell numbers.", "sequence": "1,2,7,27,114,523,2589,13744,77821,467767,2972432,19895813,139824045,1028804338,7905124379,63287544055,526827208698,4551453462543,40740750631417,377254241891064,3608700264369193,35613444194346451,362161573323083920,3790824599495473121", "code": "\n\nfrom itertools import accumulate\nA011965_list, blist, b = [1], [1, 2], 2\nfor _ in range(1000):\n....blist = list(accumulate([b]+blist))\n....b = blist[-1]\n....A011965_list.append(blist[-3])\n\n"}
{"sequence_id": "A011966", "text": "Third differences of Bell numbers.", "sequence": "1,5,20,87,409,2066,11155,64077,389946,2504665,16923381,119928232,888980293,6876320041,55382419676,463539664643,4024626253845,36189297168874,336513491259647,3231446022478129,32004743929977258,326548129128737469,3428663026172389201", "code": "\n\nfrom itertools import accumulate\nA011966_list, blist, b = [1], [2, 3, 5], 5\nfor _ in range(1000):\n....blist = list(accumulate([b]+blist))\n....b = blist[-1]\n....A011966_list.append(blist[-4]) \n"}
{"sequence_id": "A011967", "text": "4th differences of Bell numbers.", "sequence": "4,15,67,322,1657,9089,52922,325869,2114719,14418716,103004851,769052061,5987339748,48506099635,408157244967,3561086589202,32164670915029,300324194090773,2894932531218482,28773297907499129", "code": "\n\nfrom itertools import accumulate\nA011967_list, blist, b = [4], [5, 7, 10, 15], 15\nfor _ in range(250):\n....blist = list(accumulate([b]+blist))\n....b = blist[-1]\n....A011967_list.append(blist[-5]) \n"}
{"sequence_id": "A011968", "text": "Apply (1+Shift) to Bell numbers.", "sequence": "1,2,3,7,20,67,255,1080,5017,25287,137122,794545,4892167,31858034,218543759,1573857867,11863100692,93345011951,764941675963,6514819011216,57556900440429,526593974392123,4981585554604074,48658721593531669,490110875149889635", "code": "\n\nfrom itertools import accumulate\nA011968_list, blist, b = [1,2], [1], 1\nfor _ in range(10**2):\n....blist = list(accumulate([b]+blist))\n....A011968_list.append(b+blist[-1])\n....b = blist[-1] \n"}
{"sequence_id": "A011969", "text": "Apply (1+Shift)^2 to Bell numbers.", "sequence": "1,3,5,10,27,87,322,1335,6097,30304,162409,931667,5686712,36750201,250401793,1792401626,13436958559,105208112643,858286687914,7279760687179,64071719451645,584150874832552,5508179528996197", "code": "\n\nfrom itertools import accumulate\nA011969_list, blist, b, b2 = [1,3], [1], 1, 1\nfor _ in range(10**2):\n....blist = list(accumulate([b]+blist))\n....A011969_list.append(2*b+b2+blist[-1])\n....b2, b = b, blist[-1]\n\n"}
{"sequence_id": "A011970", "text": "Apply (1+Shift)^3 to Bell numbers.", "sequence": "1,4,8,15,37,114,409,1657,7432,36401,192713,1094076,6618379,42436913,287151994,2042803419,15229360185,118645071202,963494800557,8138047375093,71351480138824,648222594284197,6092330403828749", "code": "\n\nfrom itertools import accumulate\nA011970_list, blist, b, b2, b3 = [1,4,8], [1, 2], 2, 1, 1\nfor _ in range(498):\n....blist = list(accumulate([b]+blist))\n....A011970_list.append(3*(b+b2)+b3+blist[-1])\n....b3, b2, b = b2, b, blist[-1]\n\n"}
{"sequence_id": "A011971", "text": "Aitken's array: triangle of numbers {a(n,k), n >= 0, 0 <= k <= n} read by rows, defined by a(0,0)=1, a(n,0) = a(n-1,n-1), a(n,k) = a(n,k-1) + a(n-1,k-1).", "sequence": "1,1,2,2,3,5,5,7,10,15,15,20,27,37,52,52,67,87,114,151,203,203,255,322,409,523,674,877,877,1080,1335,1657,2066,2589,3263,4140,4140,5017,6097,7432,9089,11155,13744,17007,21147,21147,25287,30304,36401,43833,52922,64077,77821,94828,115975", "code": "\n\nfrom itertools import accumulate\nA011971 = blist = [1]\nfor _ in range(10**2):\n    b = blist[-1]\n    blist = list(accumulate([b]+blist))\n    A011971 += blist \n"}
{"sequence_id": "A011972", "text": "Sequence formed by reading rows of triangle defined in A011971.", "sequence": "1,2,3,5,7,10,15,20,27,37,52,67,87,114,151,203,255,322,409,523,674,877,1080,1335,1657,2066,2589,3263,4140,5017,6097,7432,9089,11155,13744,17007,21147,25287,30304,36401,43833,52922,64077,77821,94828", "code": "\n\nfrom itertools import accumulate\nA011972_list = blist = [1]\nfor _ in range(10**2):\n....b = blist[-1]\n....blist = list(accumulate([b]+blist))\n....A011972_list += blist[1:]\n\n"}
{"sequence_id": "A012781", "text": "Take every 5th term of Padovan sequence A000931, beginning with the second term.", "sequence": "0,1,4,16,65,265,1081,4410,17991,73396,299426,1221537,4983377,20330163,82938844,338356945,1380359512,5631308624,22973462017,93722435101,382349636061,1559831901918,6363483400447,25960439030624", "code": "\ndef a(n, adict={0:0, 1:1, 2:4}):\n    if n in adict:\n        return adict[n]\n    adict[n]=5*a(n-1) - 4*a(n-2) + a(n-3)\n    return adict[n] \n"}
{"sequence_id": "A013588", "text": "Smallest positive integer not the determinant of an n X n {0,1}-matrix.", "sequence": "2,2,3,4,6,10,19,41,103,269", "code": "\nfrom itertools import product\nfrom sympy import Matrix\ndef A013588(n):\n    s, k = set(Matrix(n,n,p).det() for p in product([0,1],repeat=n**2)), 1\n    while k in s:\n        k += 1\n    return k \n"}
{"sequence_id": "A013697", "text": "Second term in continued fraction for zeta(n).", "sequence": "1,4,12,27,57,119,245,497,1005,2023,4063,8149,16327,32692,65435,130938,261965,524050,1048259,2096730,4193742,8387859,16776218,33553102,67107091,134215364,268432305,536866711,1073736223,2147476180", "code": "\nfrom sympy import zeta\nprint([1//(zeta(n) - 1) for n in range(2, 32)]) \n"}
{"sequence_id": "A013708", "text": "a(n) = 3^(2n+1).", "sequence": "3,27,243,2187,19683,177147,1594323,14348907,129140163,1162261467,10460353203,94143178827,847288609443,7625597484987,68630377364883,617673396283947,5559060566555523,50031545098999707", "code": "\nprint([3**(2*n+1) for n in range(18)]) \n"}
{"sequence_id": "A013795", "text": "a(n) = 11^(4*n+3).", "sequence": "1331,19487171,285311670611,4177248169415651,61159090448414546291,895430243255237372246531,13109994191499930367061460371,191943424957750480504146841291811,2810243684806424785061213903353404851", "code": " def a(n): return 11**(4*n + 3) \n"}
{"sequence_id": "A013916", "text": "Numbers k such that the sum of the first k primes is prime.", "sequence": "1,2,4,6,12,14,60,64,96,100,102,108,114,122,124,130,132,146,152,158,162,178,192,198,204,206,208,214,216,296,308,326,328,330,332,334,342,350,356,358,426,446,458,460,464,480,484,488,512,530,536,548,568,620,630,676,680", "code": "\nfrom sympy import isprime, prime\ndef aupto(lim):\n  s = 0\n  for k in range(1, lim+1):\n    s += prime(k)\n    if isprime(s): print(k, end=\", \")\naupto(680) \n"}
{"sequence_id": "A013928", "text": "Number of (positive) squarefree numbers < n.", "sequence": "0,1,2,3,3,4,5,6,6,6,7,8,8,9,10,11,11,12,12,13,13,14,15,16,16,16,17,17,17,18,19,20,20,21,22,23,23,24,25,26,26,27,28,29,29,29,30,31,31,31,31,32,32,33,33,34,34,35,36,37,37,38,39,39,39,40,41,42,42,43,44,45,45,46,47,47", "code": "\nfrom sympy.ntheory.factor_  import core\ndef a(n): return sum ([1 for i in range(1, n) if core(i) == i]) \n"}
{"sequence_id": "A013929", "text": "Numbers that are not squarefree. Numbers that are divisible by a square greater than 1. The complement of A005117.", "sequence": "4,8,9,12,16,18,20,24,25,27,28,32,36,40,44,45,48,49,50,52,54,56,60,63,64,68,72,75,76,80,81,84,88,90,92,96,98,99,100,104,108,112,116,117,120,121,124,125,126,128,132,135,136,140,144,147,148,150,152,153,156,160", "code": "\nfrom sympy.ntheory.factor_ import core\ndef ok(n): return core(n, 2) != n\nprint(list(filter(ok, range(1, 161)))) \n"}
{"sequence_id": "A013939", "text": "Partial sums of sequence A001221 (number of distinct primes dividing n).", "sequence": "0,1,2,3,4,6,7,8,9,11,12,14,15,17,19,20,21,23,24,26,28,30,31,33,34,36,37,39,40,43,44,45,47,49,51,53,54,56,58,60,61,64,65,67,69,71,72,74,75,77,79,81,82,84,86,88,90,92,93,96,97,99,101,102,104,107,108,110,112", "code": "\nfrom sympy.ntheory import primefactors\nprint([sum(len(primefactors(k)) for k in range(1,n+1)) for n in range(1, 121)]) \n"}
{"sequence_id": "A014081", "text": "a(n) is the number of occurrences of '11' in binary expansion of n.", "sequence": "0,0,0,1,0,0,1,2,0,0,0,1,1,1,2,3,0,0,0,1,0,0,1,2,1,1,1,2,2,2,3,4,0,0,0,1,0,0,1,2,0,0,0,1,1,1,2,3,1,1,1,2,1,1,2,3,2,2,2,3,3,3,4,5,0,0,0,1,0,0,1,2,0,0,0,1,1,1,2,3,0,0,0,1,0,0,1,2,1,1,1,2,2,2,3,4,1,1,1,2,1,1,2,3,1", "code": "\ndef a(n): return sum([((n>>i)&3==3) for i in range(len(bin(n)[2:]) - 1)]) \n"}
{"sequence_id": "A014085", "text": "Number of primes between n^2 and (n+1)^2.", "sequence": "0,2,2,2,3,2,4,3,4,3,5,4,5,5,4,6,7,5,6,6,7,7,7,6,9,8,7,8,9,8,8,10,9,10,9,10,9,9,12,11,12,11,9,12,11,13,10,13,15,10,11,15,16,12,13,11,12,17,13,16,16,13,17,15,14,16,15,15,17,13,21,15,15,17,17,18,22,14,18,23,13", "code": "\nfrom sympy import primepi\ndef a(n): return primepi((n+1)**2) - primepi(n**2)\nprint([a(n) for n in range(81)]) \n"}
{"sequence_id": "A014092", "text": "Numbers that are not the sum of 2 primes.", "sequence": "1,2,3,11,17,23,27,29,35,37,41,47,51,53,57,59,65,67,71,77,79,83,87,89,93,95,97,101,107,113,117,119,121,123,125,127,131,135,137,143,145,147,149,155,157,161,163,167,171,173,177,179,185,187,189,191,197,203,205,207,209", "code": "\nfrom sympy import prime, isprime\ndef ok(n):\n    i=1\n    x=prime(i)\n    while x<n:\n        if isprime(n - x): return False\n        i+=1\n        x=prime(i)\n    return True\nprint([n for n in range(1, 301) if ok(n)]) \n"}
{"sequence_id": "A014127", "text": "Mirimanoff primes: primes p such that p^2 divides 3^(p-1) - 1.", "sequence": "11,1006003", "code": "\nfrom sympy import prime\nfrom gmpy2 import powmod\nA014127_list = [p for p in (prime(n) for n in range(1,10**7)) if powmod(3,p-1,p*p) == 1] \n"}
{"sequence_id": "A014137", "text": "Partial sums of Catalan numbers (A000108).", "sequence": "1,2,4,9,23,65,197,626,2056,6918,23714,82500,290512,1033412,3707852,13402697,48760367,178405157,656043857,2423307047,8987427467,33453694487,124936258127,467995871777,1757900019101,6619846420553,24987199492705,94520750408709,358268702159069", "code": "\nfrom __future__ import division\nA014137_list, b, s = [], 1, 0\nfor n in range(10**2):\n    s += b\n    A014137_list.append(s)\n    b = b*(4*n+2)//(n+2) \n"}
{"sequence_id": "A014138", "text": "Partial sums of (Catalan numbers starting 1, 2, 5, ...).", "sequence": "0,1,3,8,22,64,196,625,2055,6917,23713,82499,290511,1033411,3707851,13402696,48760366,178405156,656043856,2423307046,8987427466,33453694486,124936258126,467995871776,1757900019100", "code": "\nfrom __future__ import division\nA014138_list, b, s = [0], 1, 0\nfor n in range(1,10**2):\n    s += b\n    A014138_list.append(s)\n    b = b*(4*n+2)//(n+2) \n"}
{"sequence_id": "A014197", "text": "Number of numbers m with Euler phi(m) = n.", "sequence": "2,3,0,4,0,4,0,5,0,2,0,6,0,0,0,6,0,4,0,5,0,2,0,10,0,0,0,2,0,2,0,7,0,0,0,8,0,0,0,9,0,4,0,3,0,2,0,11,0,0,0,2,0,2,0,3,0,2,0,9,0,0,0,8,0,2,0,0,0,2,0,17,0,0,0,0,0,2,0,10,0,2,0,6,0,0,0,6,0,0,0,3", "code": "\nfrom sympy import totient, divisors, isprime, prod\ndef a(m):\n    if m == 1: return 2\n    if m % 2: return 0\n    X = (x + 1 for x in divisors(m))\n    nmax=m*prod(i/(i - 1) for i in X if isprime(i))\n    n=m\n    k=0\n    while n<=nmax:\n        if totient(n)==m:k+=1\n        n+=1\n    return k\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A014237", "text": "a(n) = (n-th prime) - (n-th nonprime).", "sequence": "1,-1,-1,-1,2,3,5,5,8,13,13,17,20,21,23,28,33,34,39,41,41,46,49,54,61,63,64,67,67,69,82,85,89,90,99,100,105,109,112,117,122,123,131,131,134,135,146,157,159,160,163,167,167,176,181,186,191,191,196", "code": "\nfrom sympy import prime, composite\ndef A014237(n):\n    return 1 if n == 1 else prime(n)-composite(n-1) \n"}
{"sequence_id": "A014311", "text": "Numbers with exactly 3 ones in binary expansion.", "sequence": "7,11,13,14,19,21,22,25,26,28,35,37,38,41,42,44,49,50,52,56,67,69,70,73,74,76,81,82,84,88,97,98,100,104,112,131,133,134,137,138,140,145,146,148,152,161,162,164,168,176,193,194,196,200,208,224,259,261,262,265,266,268,273,274,276,280,289,290,292,296,304", "code": "\nA014311_list = [2**a+2**b+2**c for a in range(2,6) for b in range(1,a) for c in range(b)] \n"}
{"sequence_id": "A014312", "text": "Numbers with exactly 4 ones in binary expansion.", "sequence": "15,23,27,29,30,39,43,45,46,51,53,54,57,58,60,71,75,77,78,83,85,86,89,90,92,99,101,102,105,106,108,113,114,116,120,135,139,141,142,147,149,150,153,154,156,163,165,166,169,170,172,177,178,180,184,195,197", "code": "\nA014312_list = [2**a+2**b+2**c+2**d for a in range(3,6) for b in range(2,a) for c in range(1,b) for d in range(c)] \n"}
{"sequence_id": "A014342", "text": "Convolution of primes with themselves.", "sequence": "4,12,29,58,111,188,305,462,679,968,1337,1806,2391,3104,3953,4978,6175,7568,9185,11030,13143,15516,18177,21150,24471,28152,32197,36678,41543,46828,52621,58874,65659,73000,80949,89462,98631,108396,118869,130102,142071", "code": "\nfrom numpy import convolve\nfrom sympy import prime, primerange\ndef aupton(terms):\n  p = list(primerange(2, prime(terms)+1))\n  return list(convolve(p, p))[:terms]\nprint(aupton(41)) \n"}
{"sequence_id": "A014417", "text": "Representation of n in base of Fibonacci numbers (the Zeckendorf representation of n). Also, binary words starting with 1 not containing 11, with the word 0 added.", "sequence": "0,1,10,100,101,1000,1001,1010,10000,10001,10010,10100,10101,100000,100001,100010,100100,100101,101000,101001,101010,1000000,1000001,1000010,1000100,1000101,1001000,1001001,1001010,1010000,1010001,1010010,1010100,1010101", "code": "\nfrom sympy import fibonacci\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A014418", "text": "Representation of n in base of Catalan numbers (a classic greedy version).", "sequence": "0,1,10,11,20,100,101,110,111,120,200,201,210,211,1000,1001,1010,1011,1020,1100,1101,1110,1111,1120,1200,1201,1210,1211,2000,2001,2010,2011,2020,2100,2101,2110,2111,2120,2200,2201,2210,2211,10000", "code": "\nfrom sympy import catalan\ndef a244160(n):\n    if n==0: return 0\n    i=1\n    while True:\n        if catalan(i)>n: break\n        else: i+=1\n    return i - 1\ndef a(n):\n    if n==0: return 0\n    x=a244160(n)\n    return 10**(x - 1) + a(n - catalan(x))\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A014549", "text": "Decimal expansion of 1 / M(1,sqrt(2)) (Gauss's constant).", "sequence": "8,3,4,6,2,6,8,4,1,6,7,4,0,7,3,1,8,6,2,8,1,4,2,9,7,3,2,7,9,9,0,4,6,8,0,8,9,9,3,9,9,3,0,1,3,4,9,0,3,4,7,0,0,2,4,4,9,8,2,7,3,7,0,1,0,3,6,8,1,9,9,2,7,0,9,5,2,6,4,1,1,8,6,9,6,9,1,1,6,0,3,5,1,2,7,5,3,2,4,1,2,9,0,6,7,8,5", "code": "\nfrom mpmath import mp, agm, sqrt\nmp.dps=105\nprint([int(z) for z in list(str(1/agm(sqrt(2)))[2:-1])]) \n"}
{"sequence_id": "A014577", "text": "The regular paper-folding sequence (or dragon curve sequence).", "sequence": "1,1,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,1,1,0,0,0,1,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,1,0,0,1,0,0,0,1,1,0,1,1,0,0,0,1,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,1,1,0,0,0,1,1,0,0,1,0,0,0,1,1,0", "code": "\ndef A014577(n):\n    s = bin(n+1)[2:]\n    m = len(s)\n    i = s[::-1].find('1')\n    return 1-int(s[m-i-2]) if m-i-2 >= 0 else 1 \n"}
{"sequence_id": "A014597", "text": "Numbers k such that k^2 is a sum of distinct factorials.", "sequence": "1,3,5,11,12,27,29,71,72,213,215,603,635,1917,1183893", "code": "\nfrom math import factorial, isqrt\nfrom itertools import chain, combinations\nfrom sympy.ntheory.primetest import is_square\nfac =[factorial(n) for n in range(1, 16)] \ndef powerset(s): \n  return chain.from_iterable(combinations(s, r) for r in range(1, len(s)+1))\ngen = (isqrt(sum(s)) for s in powerset(fac) if is_square(sum(s)))\nprint(sorted(set(gen))) \n"}
{"sequence_id": "A014612", "text": "Numbers that are the product of exactly three (not necessarily distinct) primes.", "sequence": "8,12,18,20,27,28,30,42,44,45,50,52,63,66,68,70,75,76,78,92,98,99,102,105,110,114,116,117,124,125,130,138,147,148,153,154,164,165,170,171,172,174,175,182,186,188,190,195,207,212,222,230,231,236,238,242,244", "code": "\nfrom sympy import factorint\ndef ok(n): f = factorint(n); return sum(f[p] for p in f) == 3\nprint(list(filter(ok, range(245)))) \n"}
{"sequence_id": "A014682", "text": "The Collatz or 3x+1 function: a(n) = n/2 if n is even, otherwise (3n+1)/2.", "sequence": "0,2,1,5,2,8,3,11,4,14,5,17,6,20,7,23,8,26,9,29,10,32,11,35,12,38,13,41,14,44,15,47,16,50,17,53,18,56,19,59,20,62,21,65,22,68,23,71,24,74,25,77,26,80,27,83,28,86,29,89,30,92,31,95,32,98,33,101,34,104", "code": "\ndef a(n): return n//2 if n%2==0 else (3*n + 1)//2\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A014707", "text": "a(4n)=0, a(4n+2)=1, a(2n+1)=a(n).", "sequence": "0,0,1,0,0,1,1,0,0,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0", "code": "\ndef A014707(n):\n    s = bin(n+1)[2:]\n    m = len(s)\n    i = s[::-1].find('1')\n    return int(s[m-i-2]) if m-i-2 >= 0 else 0 \n"}
{"sequence_id": "A014710", "text": "The regular paper-folding (or dragon curve) sequence.", "sequence": "2,2,1,2,2,1,1,2,2,2,1,1,2,1,1,2,2,2,1,2,2,1,1,1,2,2,1,1,2,1,1,2,2,2,1,2,2,1,1,2,2,2,1,1,2,1,1,1,2,2,1,2,2,1,1,1,2,2,1,1,2,1,1,2,2,2,1,2,2,1,1,2,2,2,1,1,2,1,1,2,2,2", "code": "\ndef A014710(n):\n    s = bin(n+1)[2:]\n    m = len(s)\n    i = s[::-1].find('1')\n    return 2-int(s[m-i-2]) if m-i-2 >= 0 else 2 \n"}
{"sequence_id": "A014847", "text": "Numbers k such that k-th Catalan number C(2k,k)/(k+1) is divisible by k.", "sequence": "1,2,6,15,20,28,42,45,66,77,88,91,104,110,126,140,153,156,170,187,190,204,209,210,220,228,231,238,240,266,276,299,308,312,315,322,325,330,345,368,378,414,420,429,435,440,442,450,459,460,464,468,476,483,493", "code": "\nfrom __future__ import division\nA014847_list, b = [], 1\nfor n in range(1,10**3):\n    if not b % n:\n        A014847_list.append(n)\n    b = b*(4*n+2)//(n+2) \n"}
{"sequence_id": "A014945", "text": "Numbers k such that k divides 4^k - 1.", "sequence": "1,3,9,21,27,63,81,147,171,189,243,441,513,567,657,729,903,1029,1197,1323,1539,1701,1971,2187,2667,2709,3087,3249,3591,3969,4599,4617,5103,5913,6321,6561,7077,7203,8001,8127,8379,9261,9747,10773,11907,12483", "code": "\nfor n in range(1,1000):\n    if (4**n-1) % n ==0:\n        print(n, end=', ') \n"}
{"sequence_id": "A014957", "text": "Positive integers k that divide 16^k - 1.", "sequence": "1,3,5,9,15,21,25,27,39,45,55,63,75,81,105,117,125,135,147,155,165,171,189,195,205,225,243,273,275,315,333,351,375,405,441,465,495,507,513,525,567,585,605,609,615,625,657,675,729,735,775,819,825,855,903", "code": "\nA014957_list = [n for n in range(1,10**6) if n == 1 or pow(16,n,n) == 1] \n"}
{"sequence_id": "A014963", "text": "Exponential of Mangoldt function M(n): a(n) = 1 unless n is a prime or prime power when a(n) = that prime.", "sequence": "1,2,3,2,5,1,7,2,3,1,11,1,13,1,1,2,17,1,19,1,1,1,23,1,5,1,3,1,29,1,31,2,1,1,1,1,37,1,1,1,41,1,43,1,1,1,47,1,7,1,1,1,53,1,1,1,1,1,59,1,61,1,1,2,1,1,67,1,1,1,71,1,73,1,1,1,1,1,79,1,3,1,83,1,1,1,1,1,89,1,1,1,1,1,1", "code": "\nfrom sympy import factorint\ndef A014963(n):\n    y = factorint(n)\n    return list(y.keys())[0] if len(y) == 1 else 1\n\n"}
{"sequence_id": "A014980", "text": "a(n+1) = floor(a(n)/2) * ceiling(a(n)/2), a(0) = 5.", "sequence": "5,6,9,20,100,2500,1562500,610351562500,93132257461547851562500,2168404344971008868014905601739883422851562500,1175494350822287507968736537222245677818665556772087521508751706278417259454727172851562500", "code": "\nfrom itertools import accumulate\ndef f(an, _): return (an//2)*((an+1)//2)\nprint(list(accumulate([5]*11, f))) \n"}
{"sequence_id": "A015097", "text": "Carlitz-Riordan q-Catalan numbers (recurrence version) for q=-2.", "sequence": "1,1,-1,-7,47,873,-26433,-1749159,220526159,56904690761,-29022490524961,-29777360924913095,60924625361199230575,249669263740090899509545,-2044791574538659983034398465,-33505955988983997787211823466215", "code": "\nl=[1]\nfor n in range(1, 21):\n    l.append(sum([(-2)**i*l[i]*l[n - 1 - i] for i in range(n)]))\nprint(l) \n"}
{"sequence_id": "A015459", "text": "q-Fibonacci numbers for q=2.", "sequence": "0,1,1,3,7,31,143,1135,10287,155567,2789039,82439343,2938415279,171774189743,12207523172527,1419381685547183,201427441344229551,46711726513354322095,13247460522448782176431,6135846878080826487812271", "code": "\ndef a():\n    a, b, p = 0, 1, 1\n    while True:\n        yield a\n        p, a, b = p + p, b, b + p * a\nA015463 = a()\nprint([next(A015463) for _ in range(20)]) \n"}
{"sequence_id": "A015518", "text": "a(n) = 2*a(n-1) + 3*a(n-2), with a(0)=0, a(1)=1.", "sequence": "0,1,2,7,20,61,182,547,1640,4921,14762,44287,132860,398581,1195742,3587227,10761680,32285041,96855122,290565367,871696100,2615088301,7845264902,23535794707,70607384120,211822152361,635466457082", "code": " for n in range(0, 20): print(int((3**n-(-1)**n)/4), end=', ') \n"}
{"sequence_id": "A015613", "text": "a(n) = Sum_{i=1..n} phi(i) * (ceiling(n/i) - floor(n/i)).", "sequence": "0,0,1,2,5,6,11,14,19,22,31,34,45,50,57,64,79,84,101,108,119,128,149,156,175,186,203,214,241,248,277,292,311,326,349,360,395,412,435,450,489,500,541,560,583,604,649,664,705,724,755,778,829,846,885,908,943", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A015613(n): \n    if n == 0:\n        return 0\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(2*(A015613(k1)+k1)-1)\n        j, k1 = j2, n//j2\n    return (n*(n-3)-c+j)//2 \n"}
{"sequence_id": "A015614", "text": "a(n) = -1 + Sum_{i=1..n} phi(i).", "sequence": "0,1,3,5,9,11,17,21,27,31,41,45,57,63,71,79,95,101,119,127,139,149,171,179,199,211,229,241,269,277,307,323,343,359,383,395,431,449,473,489,529,541,583,603,627,649,695,711,753,773,805,829,881,899,939,963", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A015614(n): \n    if n == 0:\n        return -1\n    c, j = 2, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(2*A015614(k1)+1)\n        j, k1 = j2, n//j2\n    return (n*(n-1)-c+j)//2 \n"}
{"sequence_id": "A015616", "text": "Number of triples (i,j,k) with 1 <= i < j < k <= n and gcd(i,j,k) = 1.", "sequence": "0,0,1,4,10,19,34,52,79,109,154,196,262,325,409,493,613,712,865,997,1171,1336,1567,1747,2017,2251,2548,2818,3196,3472,3907,4267,4717,5125,5665,6079,6709,7222,7858,8410,9190,9748,10609,11299,12127", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A015616(n):\n    if n <= 1:\n        return 0\n    c, j = n*(n-1)*(n-2)//6, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c -= (j2-j)*A015616(k1)\n        j, k1 = j2, n//j2\n    return c \n"}
{"sequence_id": "A015631", "text": "Number of ordered triples of integers from [ 1..n ] with no global factor.", "sequence": "1,3,8,15,29,42,69,95,134,172,237,287,377,452,552,652,804,915,1104,1252,1450,1635,1910,2106,2416,2674,3007,3301,3735,4027,4522,4914,5404,5844,6432,6870,7572,8121,8805,9389,10249,10831,11776,12506", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A015631(n):\n    if n == 0:\n        return 0\n    c, j = 1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A015631(k1)\n        j, k1 = j2, n//j2\n    return n*(n-1)*(n+4)//6-c+j \n"}
{"sequence_id": "A015634", "text": "Number of ordered quadruples of integers from [ 1..n ] with no global factor.", "sequence": "1,4,13,29,63,106,189,289,444,626,911,1203,1657,2130,2766,3462,4430,5359,6688,7992,9670,11405,13704,15840,18730,21548,25037,28521,33015,37067,42522,47690,53940,60108,67760,74748,83886,92433,102629,112469", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A015634(n):\n    if n == 0:\n        return 0\n    c, j = 1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A015634(k1)\n        j, k1 = j2, n//j2\n    return n*(n+1)*(n+2)*(n+3)//24-c+j-n \n"}
{"sequence_id": "A015650", "text": "Number of ordered 5-tuples of integers from [ 1..n ] with no global factor.", "sequence": "1,5,19,49,118,225,434,729,1209,1850,2850,4059,5878,8044,11020,14566,19410,24789,32103,40213,50615,62260,77209,93099,113504,135431,162341,191396,227355,264463,310838,359322,417212,478408,551944,626971", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A015650(n):\n    if n == 0:\n        return 0\n    c, j = n+1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A015650(k1)\n        j, k1 = j2, n//j2\n    return n*(n+1)*(n+2)*(n+3)*(n+4)//120-c+j \n"}
{"sequence_id": "A015942", "text": "Positive integers n such that n | (2^n + n/2 - 1).", "sequence": "6,18,42,54,126,162,294,342,378,486,882,1026,1134,1314,1458,1806,2058,2394,2646,3078,3402,3942,4374,5334,5418,6174,6498,7182,7938,9198,9234,10206,11826,12642,13122,14154,14406,16002,16254,16758", "code": "\nA015942_list = [n for n in range(2,10**6,2) if pow(2,n,n) == n//2+1] \n"}
{"sequence_id": "A015945", "text": "Positive integers n such that n | (2^n + n/2 + 1).", "sequence": "2,10,50,250,410,1250,2050,5050,6250,10250,16810,25250,31250,51250,84050,126250,156250,207050,256250,336610,405050,420250,510050,631250,689210,781250,1035250,1281250,1683050,1750250,2025250,2101250,2550250,3156250,3446050", "code": "\nA015945_list = [n for n in range(2,10**6,2) if pow(2,n,n) == n//2-1] \n"}
{"sequence_id": "A015950", "text": "Numbers k such that k | 4^k + 1.", "sequence": "1,5,25,125,205,625,1025,2525,3125,5125,8405,12625,15625,25625,42025,63125,78125,103525,128125,168305,202525,210125,255025,315625,344605,390625,517625,640625,841525,875125,1012625,1050625,1275125", "code": "\nA015950_list = [n for n in range(1,10**6) if pow(4,n,n) == n-1] \n"}
{"sequence_id": "A015951", "text": "Numbers k such that k | 5^k + 1.", "sequence": "1,2,3,9,21,26,27,63,81,147,189,243,338,441,567,609,729,903,1029,1323,1378,1701,1827,2187,2667,2709,3087,3969,4263,4394,4401,5103,5481,6321,6561,7203,8001,8127,9261,9429,11907,12789,13149,13203", "code": "\nfor n in range(1,10**5):\n    if pow(5,n,n)+1 == n: print(n, end=', ') \n"}
{"sequence_id": "A015977", "text": "Two iterations of Reverse and Add are needed to reach a palindrome.", "sequence": "5,6,7,8,9,19,28,37,39,46,48,49,55,57,58,64,66,67,73,75,76,82,84,85,91,93,94,109,119,129,139,149,150,151,152,153,154,159,160,161,162,163,169,170,171,172,173,179,189,208,218,219,228,229,238,239,248", "code": "\ndef ra(n): s = str(n); return int(s) + int(s[::-1])\ndef ispal(n): s = str(n); return s == s[::-1]\ndef aupto(limit):\n  alst = []\n  for k in range(limit+1):\n    k2 = ra(k)\n    if ispal(k2): continue\n    if ispal(ra(k2)): alst.append(k)\n  return alst\nprint(aupto(250)) \n"}
{"sequence_id": "A015999", "text": "a(n) = (tau(n^5) + 4)/5.", "sequence": "1,2,2,3,2,8,2,4,3,8,2,14,2,8,8,5,2,14,2,14,8,8,2,20,3,8,4,14,2,44,2,6,8,8,8,25,2,8,8,20,2,44,2,14,14,8,2,26,3,14,8,14,2,20,8,20,8,8,2,80,2,8,14,7,8,44,2,14,8,44,2,36,2,8,14,14,8,44,2,26,5,8,2,80,8,8", "code": "\nfrom sympy import divisor_count\ndef a(n): return (divisor_count(n**5) + 4)//5\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A016069", "text": "Numbers n such that n^2 contains exactly 2 different digits.", "sequence": "4,5,6,7,8,9,10,11,12,15,20,21,22,26,30,38,88,100,109,173,200,212,235,264,300,1000,2000,3000,3114,10000,20000,30000,81619,100000,200000,300000,1000000,2000000,3000000,10000000,20000000", "code": "\nfrom gmpy2 import is_square, isqrt\nfrom itertools import combinations, product\nA016069_list = []\nfor g in range(2,10):\n    n = 2**g-1\n    for x in combinations('0123456789',2):\n        for i,y in enumerate(product(x,repeat=g)):\n            if i > 0 and i < n and y[0] != '0':\n                z = int(''.join(y))\n                if is_square(z):\n                    A016069_list.append(int(isqrt(z)))\nA016069_list = sorted(A016069_list) \n"}
{"sequence_id": "A016070", "text": "Numbers n such that n^2 contains exactly 2 different digits, excluding 10^m, 2*10^m, 3*10^m.", "sequence": "4,5,6,7,8,9,11,12,15,21,22,26,38,88,109,173,212,235,264,3114,81619", "code": "\nfrom gmpy2 import is_square, isqrt\nfrom itertools import combinations, product\nA016070_list = []\nfor g in range(2,20):\n....n = 2**g-1\n....for x in combinations('0123456789',2):\n........if not x in [('0','1'), ('0','4'), ('0','9')]:\n............for i,y in enumerate(product(x,repeat=g)):\n................if i > 0 and i < n and y[0] != '0':\n....................z = int(''.join(y))\n....................if is_square(z):\n........................A016070_list.append(isqrt(z))\nA016070_list = sorted(A016070_list) \n"}
{"sequence_id": "A016115", "text": "Number of prime palindromes with n digits.", "sequence": "4,1,15,0,93,0,668,0,5172,0,42042,0,353701,0,3036643,0,27045226,0,239093865,0,2158090933,0,19742800564,0", "code": "\nfrom sympy import isprime\nfrom itertools import product\ndef pals(d, base=10): \n    digits = \"\".join(str(i) for i in range(base))\n    for p in product(digits, repeat=d//2):\n        if d > 1 and p[0] == \"0\": continue\n        left = \"\".join(p); right = left[::-1]\n        for mid in [[\"\"], digits][d%2]: yield int(left + mid + right)\ndef a(n): return int(n==2) if n%2 == 0 else sum(isprime(p) for p in pals(n))\nprint([a(n) for n in range(1, 13)]) \n"}
{"sequence_id": "A016755", "text": "Odd cubes: a(n) = (2*n + 1)^3.", "sequence": "1,27,125,343,729,1331,2197,3375,4913,6859,9261,12167,15625,19683,24389,29791,35937,42875,50653,59319,68921,79507,91125,103823,117649,132651,148877,166375,185193,205379,226981,250047,274625,300763,328509,357911,389017,421875", "code": "\ndef a(n): return (2*n+1)**3\nprint([a(n) for n in range(38)]) \n"}
{"sequence_id": "A016789", "text": "a(n) = 3*n + 2.", "sequence": "2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98,101,104,107,110,113,116,119,122,125,128,131,134,137,140,143,146,149,152,155,158,161,164,167,170,173,176,179", "code": " for n in range(0,100): print(3*n+2, end=', ') \n"}
{"sequence_id": "A016921", "text": "a(n) = 6*n + 1.", "sequence": "1,7,13,19,25,31,37,43,49,55,61,67,73,79,85,91,97,103,109,115,121,127,133,139,145,151,157,163,169,175,181,187,193,199,205,211,217,223,229,235,241,247,253,259,265,271,277,283,289,295,301,307,313,319,325,331", "code": " for n in range(0,10**5):print(6*n+1) \n"}
{"sequence_id": "A017298", "text": "a(n) = (10*n + 2)^6.", "sequence": "64,2985984,113379904,1073741824,5489031744,19770609664,56800235584,139314069504,304006671424,606355001344,1126162419264,1973822685184,3297303959104,5289852801024,8198418170944", "code": " for n in range(0, 25): print((10*n + 2)**6, end=\", \") \n"}
{"sequence_id": "A017313", "text": "a(n) = (10*n + 3)^9.", "sequence": "19683,10604499373,1801152661463,46411484401953,502592611936843,3299763591802133,15633814156853823,58871586708267913,186940255267540403,520411082988487293,1304773183829244583,3004041937984268273", "code": " for n in range(0, 15): print((10*n + 3)**9, end=\", \") \n"}
{"sequence_id": "A017509", "text": "a(n) = 11*n + 10.", "sequence": "10,21,32,43,54,65,76,87,98,109,120,131,142,153,164,175,186,197,208,219,230,241,252,263,274,285,296,307,318,329,340,351,362,373,384,395,406,417,428,439,450,461,472,483,494,505,516,527,538,549,560,571,582", "code": "\ndef a(n): return 11*n + 10\nprint([a(n) for n in range(53)]) \n"}
{"sequence_id": "A017533", "text": "a(n) = 12*n + 1.", "sequence": "1,13,25,37,49,61,73,85,97,109,121,133,145,157,169,181,193,205,217,229,241,253,265,277,289,301,313,325,337,349,361,373,385,397,409,421,433,445,457,469,481,493,505,517,529,541,553,565,577,589,601,613,625,637", "code": " def a(n): return 12*n + 1 \n"}
{"sequence_id": "A017647", "text": "(12n+10)^7.", "sequence": "10000000,2494357888,52523350144,435817657216,2207984167552,8235430000000,24928547056768,64847759419264,150363025899136,318547390056832,627485170000000,1164175380274048,2054210978157184", "code": "\ndef a017647(n):\n....return (12*n+10)**7\n\n"}
{"sequence_id": "A017713", "text": "Binomial coefficients C(n,49).", "sequence": "1,50,1275,22100,292825,3162510,28989675,231917400,1652411475,10648873950,62828356305,342700125300,1742058970275,8308281242850,37387265592825,159518999862720,648045936942300,2515943049305400", "code": "\nA017713_list, m = [], [1]*50\nfor _ in range(10**2):\n    A017713_list.append(m[-1])\n    for i in range(49):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A017714", "text": "Binomial coefficients C(n,50).", "sequence": "1,51,1326,23426,316251,3478761,32468436,264385836,1916797311,12565671261,75394027566,418094152866,2160153123141,10468434365991,47855699958816,207374699821536,855420636763836,3371363686069236,12736262814039336,46252743903616536", "code": "\nA017714_list, m = [], [1]*51\nfor _ in range(10**2):\n    A017714_list.append(m[-1])\n    for i in range(50):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A017764", "text": "a(n) = binomial coefficient C(n,100).", "sequence": "1,101,5151,176851,4598126,96560646,1705904746,26075972546,352025629371,4263421511271,46897636623981,473239787751081,4416904685676756,38393094575497956,312629484400483356,2396826047070372396,17376988841260199871,119594570260437846171", "code": "\nA017764_list, m = [], [1]*101\nfor _ in range(10**2):\n    A017764_list.append(m[-1])\n    for i in range(100):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A017981", "text": "Powers of cube root of 2 rounded up.", "sequence": "1,2,2,2,3,4,4,6,7,8,11,13,16,21,26,32,41,51,64,81,102,128,162,204,256,323,407,512,646,813,1024,1291,1626,2048,2581,3251,4096,5161,6502,8192,10322,13004,16384,20643,26008,32768,41286,52016,65536,82571,104032", "code": "\ndef icbrt(a):\n    sr = 1 << (int.bit_length(int(a)) >> 1)\n    while a < sr*sr*sr:  sr>>=1\n    b = sr>>1\n    while b:\n      s = sr+b\n      if a >= s*s*s:  sr = s\n      b>>=1\n    return sr\nfor n in range(100):  print(1+icbrt(2**n-1), end=\",\")\n\n"}
{"sequence_id": "A018142", "text": "Powers of fifth root of 10 rounded to nearest integer.", "sequence": "1,2,3,4,6,10,16,25,40,63,100,158,251,398,631,1000,1585,2512,3981,6310,10000,15849,25119,39811,63096,100000,158489,251189,398107,630957,1000000,1584893,2511886,3981072,6309573", "code": "\nfrom gmpy2 import iroot_rem\ndef A018142(n):\n    i,j = iroot_rem(10**n,5)\n    return int(i) + int(32*j >= 10*i*(4*i*(2*i*(i + 1) + 1) + 1) + 1) \n"}
{"sequence_id": "A018166", "text": "Powers of fifth root of 18 rounded to nearest integer.", "sequence": "1,2,3,6,10,18,32,57,102,182,324,578,1030,1835,3272,5832,10396,18532,33036,58889,104976,187130,333579,594639,1060005,1889568,3368349,6004426,10703505,19080095,34012224,60630274", "code": "\nfrom gmpy2 import iroot_rem\ndef A018166(n):\n    i,j = iroot_rem(18**n,5)\n    return int(i) + int(32*j >= 10*i*(4*i*(2*i*(i + 1) + 1) + 1) + 1) \n"}
{"sequence_id": "A018184", "text": "Powers of fifth root of 24 rounded to nearest integer.", "sequence": "1,2,4,7,13,24,45,86,162,305,576,1088,2054,3877,7321,13824,26102,49285,93059,175713,331776,626451,1182849,2233427,4217101,7962624,15034828,28388386,53602242,101210414,191102976", "code": "\nfrom gmpy2 import iroot_rem\ndef A018142(n):\n    i,j = iroot_rem(24**n,5)\n    return int(i) + int(32*j >= 10*i*(4*i*(2*i*(i + 1) + 1) + 1) + 1) \n"}
{"sequence_id": "A018788", "text": "Number of subsets of {1,...,n} containing an arithmetic progression of length 3.", "sequence": "0,0,0,1,3,9,24,63,150,343,746,1605,3391,7075,14624,30076,61385,124758,252618,510161,1027632,2066304,4148715,8322113,16680369,33413592,66904484,133923906,268009597,536257466,1072861536,2146225299,4293173040,8587388627", "code": "\n\nfrom itertools import combinations as comb\ndef containsap3(n):\n    ap3list=list()\n    for skip in range(1,(n+1)//2):\n        for start in range (1,n+1-2*skip):\n            ap3list.append(set({start,start+skip,start+2*skip}))\n    s=list()\n    for i in range(3,n+1):\n        for temptuple in comb(range(1,n+1),i):\n            tempset=set(temptuple)\n            for sub in ap3list:\n                if sub <= tempset:\n                    s.append(tempset)\n                    break\n    return s \n\ndef a(n):\n    return len(containsap3(n)) \n"}
{"sequence_id": "A018789", "text": "Number of subsets of { 1, ..., n } containing an arithmetic progression of length 4.", "sequence": "0,0,0,0,1,3,8,25,64,148,356,826,1863,4205,9246,19865,42935,90872,190561,399104,829883,1710609,3523315,7224223,14755538,30092167,61177910,124028647,251168840,507216174,1022829206,2061466047,4149639752", "code": "\n\ndef containsap4(n):\n.ap4list=list()\n.for skip in range(1,(n+2)//3):\n..for start in range (1,n+1-3*skip):\n.ap4list.append(set({start,start+skip,start+2*skip,start+3*skip}))\n.s=list()\n.for i in range(4,n+1):\n..for temptuple in comb(range(1,n+1),i):\n...tempset=set(temptuple)\n...for sub in ap4list:\n....if sub <= tempset:\n.....s.append(tempset)\n.....break\n.return s\n\ndef a(n):\n.return len(containsap4(n)) \n"}
{"sequence_id": "A018796", "text": "Smallest square that begins with n.", "sequence": "0,1,25,36,4,529,64,729,81,9,100,1156,121,1369,144,1521,16,1764,1849,196,2025,2116,225,2304,2401,25,2601,2704,289,2916,3025,3136,324,3364,3481,35344,36,3721,3844,3969,400,41209,4225,4356,441,45369,4624,4761,484,49", "code": "\nn = 1\nwhile n < 100:\n    for k in range(10**3):\n        if str(k**2).startswith(str(n)):\n            print(k**2,end=', ')\n            break\n    n += 1 \n"}
{"sequence_id": "A018796", "text": "Smallest square that begins with n.", "sequence": "0,1,25,36,4,529,64,729,81,9,100,1156,121,1369,144,1521,16,1764,1849,196,2025,2116,225,2304,2401,25,2601,2704,289,2916,3025,3136,324,3364,3481,35344,36,3721,3844,3969,400,41209,4225,4356,441,45369,4624,4761,484,49", "code": "\nfrom gmpy2 import isqrt\ndef A018796(n):\n    if n == 0:\n        return 0\n    else:\n        d, nd = 1, n\n        while True:\n            x = (isqrt(nd-1)+1)**2\n            if x < nd+d:\n                return int(x)\n            d *= 10\n            nd *= 10 \n"}
{"sequence_id": "A018797", "text": "Smallest cube that begins with n.", "sequence": "0,1,27,343,4096,512,64,729,8,9261,1000,110592,125,1331,140608,15625,166375,1728,185193,19683,205379,216,226981,238328,24389,250047,262144,27,287496,29791,300763,314432,32768,3375,343,35937,3652264,373248", "code": "\nfor n in range(1,10**3):\n..for k in range(10**3):\n....if str(k**3).startswith(str(n)):\n......print(k**3,end=', ')\n......break\n..n += 1 \n"}
{"sequence_id": "A018800", "text": "Smallest prime that begins with n.", "sequence": "11,2,3,41,5,61,7,83,97,101,11,127,13,149,151,163,17,181,19,2003,211,223,23,241,251,263,271,281,29,307,31,3203,331,347,353,367,37,383,397,401,41,421,43,443,457,461,47,487,491,503,5101,521,53,541,557,563,571,587,59", "code": "\nfrom sympy import isprime\ndef a(n):\n    if isprime(n): return n\n    pow10 = 10\n    while True:\n        t, maxt = n * pow10 + 1, (n+1) * pow10\n        while t < maxt:\n            if isprime(t): return t\n            t += 2\n        pow10 *= 10\nprint([a(n) for n in range(1, 60)]) \n"}
{"sequence_id": "A018804", "text": "Pillai's arithmetical function: Sum_{k=1..n} gcd(k, n).", "sequence": "1,3,5,8,9,15,13,20,21,27,21,40,25,39,45,48,33,63,37,72,65,63,45,100,65,75,81,104,57,135,61,112,105,99,117,168,73,111,125,180,81,195,85,168,189,135,93,240,133,195,165,200,105,243,189,260,185,171,117,360", "code": "\nfrom sympy.ntheory import totient, divisors\nprint([sum(n*totient(d)//d for d in divisors(n)) for n in range(1, 101)]) \n"}
{"sequence_id": "A018805", "text": "Number of elements in the set {(x,y): 1 <= x,y <= n, gcd(x,y)=1}.", "sequence": "1,3,7,11,19,23,35,43,55,63,83,91,115,127,143,159,191,203,239,255,279,299,343,359,399,423,459,483,539,555,615,647,687,719,767,791,863,899,947,979,1059,1083,1167,1207,1255,1299,1391,1423,1507,1547,1611,1659,1763", "code": "\nfrom sympy import sieve\ndef A018805(n): return 2*sum(t for t in sieve.totientrange(1,n+1)) - 1 \n"}
{"sequence_id": "A018805", "text": "Number of elements in the set {(x,y): 1 <= x,y <= n, gcd(x,y)=1}.", "sequence": "1,3,7,11,19,23,35,43,55,63,83,91,115,127,143,159,191,203,239,255,279,299,343,359,399,423,459,483,539,555,615,647,687,719,767,791,863,899,947,979,1059,1083,1167,1207,1255,1299,1391,1423,1507,1547,1611,1659,1763", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A018805(n): \n    if n == 0:\n        return 0\n    c, j = 1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A018805(k1)\n        j, k1 = j2, n//j2\n    return n*(n-1)-c+j \n"}
{"sequence_id": "A018837", "text": "Number of steps for knight to reach (n,0) on infinite chessboard.", "sequence": "0,3,2,3,2,3,4,5,4,5,6,7,6,7,8,9,8,9,10,11,10,11,12,13,12,13,14,15,14,15,16,17,16,17,18,19,18,19,20,21,20,21,22,23,22,23,24,25,24,25,26,27,26,27,28,29,28,29,30,31,30,31,32,33,32,33,34,35,34,35,36,37,36,37,38,39,38,39,40,41,40,41,42,43", "code": " def a(n): return 3 if n == 1 else (n + n % 4) // 2 \n"}
{"sequence_id": "A018852", "text": "a(n)^3 is smallest cube beginning with n.", "sequence": "0,1,3,7,16,8,4,9,2,21,10,48,5,11,52,25,55,12,57,27,59,6,61,62,29,63,64,3,66,31,67,68,32,15,7,33,154,72,73,34,16,161,35,76,164,77,36,78,169,17,37,8,174,81,38,82,178,83,18,39,182,85,184,86,4,87,188,189,19,191,89,193,9", "code": "\nfor n in range(1,10**3):\n    for k in range(10**3):\n        if str(k**3).startswith(str(n)):\n            print(k,end=', ')\n            break\n    n += 1 \n"}
{"sequence_id": "A018900", "text": "Sums of two distinct powers of 2.", "sequence": "3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072", "code": "\nprint([n for n in range(1, 3001) if bin(n)[2:].count(\"1\")==2]) \n"}
{"sequence_id": "A018900", "text": "Sums of two distinct powers of 2.", "sequence": "3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072", "code": "\nA018900_list = [2**a+2**b for a in range(1,10) for b in range(a)] \n"}
{"sequence_id": "A019278", "text": "Numbers n such that sigma(sigma(n)) = k*n for some k.", "sequence": "1,2,4,8,15,16,21,24,42,60,64,84,160,168,240,336,480,504,512,960,1023,1344,1536,4092,4096,10752,13824,16368,29127,32256,32736,47360,57120,58254,61440,65472,65536,86016,116508,217728,262144,331520,343976,466032,550095", "code": "\nfrom sympy.ntheory import divisor_sigma as D\nprint([i for i in range(1, 10000) if D(D(i, 1), 1)%i==0]) \n"}
{"sequence_id": "A019326", "text": "Cyclotomic polynomials at x=8.", "sequence": "8,7,9,73,65,4681,57,299593,4097,262657,3641,1227133513,4033,78536544841,233017,14709241,16777217,321685687669321,261633,20587884010836553,16519105,60247241209,954437177,84327972908386521673,16773121,1152956690052710401,61083979321", "code": "\nfrom sympy.polys.specialpolys import cyclotomic_poly\ndef a(n): return 8 if n == 0 else cyclotomic_poly(n, x=8)\nprint([a(n) for n in range(27)]) \n"}
{"sequence_id": "A019460", "text": "Add 1, multiply by 1, add 2, multiply by 2, etc., start with 2.", "sequence": "2,3,3,5,10,13,39,43,172,177,885,891,5346,5353,37471,37479,299832,299841,2698569,2698579,26985790,26985801,296843811,296843823,3562125876,3562125889,46307636557,46307636571,648306911994,648306912009,9724603680135,9724603680151,155593658882416", "code": "\nl=[2]\nfor n in range(1, 101):\n    l.append(l[n - 1] + ((n + 1)//2) if n%2 else l[n - 1]*(n//2))\nprint(l) \n"}
{"sequence_id": "A019519", "text": "Concatenate odd numbers.", "sequence": "1,13,135,1357,13579,1357911,135791113,13579111315,1357911131517,135791113151719,13579111315171921,1357911131517192123,135791113151719212325,13579111315171921232527,1357911131517192123252729,135791113151719212325272931", "code": "\ndef a(n): return int(\"\".join(map(str, range(1, 2*n, 2))))\nprint([a(n) for n in range(1, 18)]) \n"}
{"sequence_id": "A019521", "text": "Concatenate squares.", "sequence": "1,14,149,14916,1491625,149162536,14916253649,1491625364964,149162536496481,149162536496481100,149162536496481100121,149162536496481100121144,149162536496481100121144169,149162536496481100121144169196,149162536496481100121144169196225", "code": "\ndef a(n): return int(\"\".join(str(i*i) for i in range(1, n+1)))\nprint([a(n) for n in range(1, 16)]) \n"}
{"sequence_id": "A019546", "text": "Primes whose digits are primes.", "sequence": "2,3,5,7,23,37,53,73,223,227,233,257,277,337,353,373,523,557,577,727,733,757,773,2237,2273,2333,2357,2377,2557,2753,2777,3253,3257,3323,3373,3527,3533,3557,3727,3733,5227,5233,5237,5273,5323,5333,5527,5557", "code": "\nfrom itertools import product\nfrom sympy import isprime\nA019546_list = [2,3,5,7]+[p for p in (int(''.join(d)+e) for l in range(1,5) for d in product('2357',repeat=l) for e in '37') if isprime(p)] \n"}
{"sequence_id": "A019547", "text": "Squares which are a decimal concatenation of two or more squares.", "sequence": "49,100,144,169,361,400,441,900,1225,1369,1444,1600,1681,1936,2500,3249,3600,4225,4900,6400,8100,9025,9409,10000,10404,11025,11449,11664,12100,12544,14161,14400,14641,15625,16641,16900,19044,19600,22500,25600,28900", "code": "\nfrom math import isqrt\ndef issquare(n): return isqrt(n)**2 == n\ndef ok(n, c):\n    if n%10 in { 2, 3, 7, 8}: return False\n    if issquare(n) and c > 1: return True\n    d = str(n)\n    for i in range(1, len(d)):\n        if issquare(int(d[:i])) and ok(int(d[i:]), c+1): return True\n    return False\nprint([r*r for r in range(180) if ok(r*r, 1)]) \n"}
{"sequence_id": "A019565", "text": "The squarefree numbers ordered lexicographically by their prime factorization (with factors written in decreasing order). a(n) = Product_{k in I} prime(k+1), where I is the set of indices of nonzero binary digits in n = Sum_{k in I} 2^k.", "sequence": "1,2,3,6,5,10,15,30,7,14,21,42,35,70,105,210,11,22,33,66,55,110,165,330,77,154,231,462,385,770,1155,2310,13,26,39,78,65,130,195,390,91,182,273,546,455,910,1365,2730,143,286,429,858,715,1430,2145,4290", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import prime\ndef A019565(n):\n    return reduce(mul,(prime(i+1) for i,v in enumerate(bin(n)[:1:-1]) if v == '1')) if n > 0 else 1\n\n"}
{"sequence_id": "A019589", "text": "Number of nondecreasing sequences that are differences of two permutations of 1,2,...,n.", "sequence": "1,1,2,5,16,59,246,1105,5270,26231,135036,713898,3857113,21220020,118547774", "code": "\nimport itertools\ndef a019589(n):\n....s=set()\n....for p in itertools.permutations(range(n)):\n........s.add(tuple(sorted([k-p[k] for k in range(n)])))\n....return len(s)\n\n"}
{"sequence_id": "A019952", "text": "Decimal expansion of tangent of 54 degrees.", "sequence": "1,3,7,6,3,8,1,9,2,0,4,7,1,1,7,3,5,3,8,2,0,7,2,0,9,5,8,1,9,1,0,8,8,7,6,7,9,5,2,5,8,9,9,3,3,6,0,0,8,1,5,8,6,6,3,3,6,5,6,7,5,7,6,5,6,1,9,0,9,5,1,9,3,7,6,7,1,7,2,9,8,5,0,6,5,9,5,2,9,9,3,1,1,0,0,7,0,1,9", "code": "\nfrom sympy import sqrt\n[print(i, end=', ') for i in str(sqrt(1+2/sqrt(5)).n(110)) if i!='.'] \n"}
{"sequence_id": "A020330", "text": "Numbers whose base-2 representation is the juxtaposition of two identical strings.", "sequence": "3,10,15,36,45,54,63,136,153,170,187,204,221,238,255,528,561,594,627,660,693,726,759,792,825,858,891,924,957,990,1023,2080,2145,2210,2275,2340,2405,2470,2535,2600,2665,2730,2795,2860,2925,2990,3055,3120,3185,3250", "code": "\ndef a(n): return int(bin(n)[2:]*2, 2)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A020333", "text": "Numbers whose base-5 representation is the juxtaposition of two identical strings.", "sequence": "6,12,18,24,130,156,182,208,234,260,286,312,338,364,390,416,442,468,494,520,546,572,598,624,3150,3276,3402,3528,3654,3780,3906,4032,4158,4284,4410,4536,4662,4788,4914,5040,5166,5292,5418,5544,5670,5796,5922,6048", "code": "\nfrom itertools import count, product\ndef agen():\n    for d in count(1):\n        for first in \"1234\":\n            for p in product(\"01234\", repeat=d-1):\n                yield int((first+\"\".join(p))*2, 5)\ng = agen()\nprint([next(g) for n in range(1, 49)]) \n"}
{"sequence_id": "A020418", "text": "Numbers k such that the continued fraction for sqrt(k) has period 79.", "sequence": "1621,3001,3637,4153,5113,5653,7114,8026,9161,12538,12569,13261,14177,18058,19373,21625,25733,25981,26297,28277,28394,29674,30122,32201,32393,32861,33773,34801,35746,36137,36185,36257,36994,39049,39701,41429,43721", "code": "\nfrom sympy import continued_fraction_periodic\nA020418_list = [n for n, s in ((i, continued_fraction_periodic(0,1,i)[-1]) for i in range(1,10**5)) if isinstance(s, list) and len(s) == 79] \n"}
{"sequence_id": "A020430", "text": "Numbers k such that the continued fraction for sqrt(k) has period 91.", "sequence": "4057,8293,10589,11801,11969,12346,12349,12809,17665,17729,19661,19793,20017,20506,21706,21898,23753,26417,28909,29221,29453,31357,32237,32429,32693,34781,40538,41885,41957,43273,43565,45145,46786,47057,49477,52357", "code": "\nfrom sympy import continued_fraction_periodic\nA020430_list = [n for n, s in ((i, continued_fraction_periodic(0,1,i)[-1]) for i in range(1,10**5)) if isinstance(s, list) and len(s) == 91] \n"}
{"sequence_id": "A020449", "text": "Primes whose greatest digit is 1.", "sequence": "11,101,10111,101111,1011001,1100101,10010101,10011101,10100011,10101101,10110011,10111001,11000111,11100101,11110111,11111101,100100111,100111001,101001001,101001011,101100011,101101111,101111011,101111111", "code": "\nfrom sympy import isprime\nA020449_list = [n for n in (int(format(m,'b')) for m in range(1,2**10)) if isprime(n)] \n"}
{"sequence_id": "A020450", "text": "Primes that contain digits 1 and 2 only.", "sequence": "2,11,211,2111,2221,12211,21121,21211,21221,22111,111121,111211,112111,112121,1111211,1121221,1212121,1212221,1221221,2121121,2211211,2221111,11221211,12111221,12121121,12121211,12122111,12122221,12212111,12222121", "code": "\nfrom sympy import primerange\ndef checkd(a, c):\n    b =  set(int(i) for i in set(str(a)))\n    return b.issubset(c)\nfor n in primerange(2, 2000000):\n    if checkd(n, [1, 2]):\n        print(n)\n\n"}
{"sequence_id": "A020451", "text": "Primes that contain digits 1 and 3 only.", "sequence": "3,11,13,31,113,131,311,313,331,3313,3331,11113,11131,11311,13313,13331,31333,33113,33311,33331,113111,113131,131111,131113,131311,311111,313133,313331,313333,331333,333131,333331,1111333,1131113,1131131,1131133,1131331", "code": "\nfrom sympy import primerange\ndef checkd(a, c):\n    b =  set(int(i) for i in set(str(a)))\n    return b.issubset(c)\nfor n in primerange(2, 2000000):\n    if checkd(n, [1, 3]):\n        print(n)\n\n"}
{"sequence_id": "A020452", "text": "Primes that contain digits 1 and 4 only.", "sequence": "11,41,4111,4441,11411,14411,41141,41411,44111,1114111,1144141,1144441,1411141,1411411,1441411,1444111,1444411,1444441,4141441,4414411,4441111,4441441,11111141,11141111,11141441,11441141,11441411,14111441,14141411", "code": "\nfrom sympy import primerange\ndef checkd(a, c):\n    b =  set(int(i) for i in set(str(a)))\n    return b.issubset(c)\nfor n in primerange(2, 2000000):\n    if checkd(n, [1, 4]):\n        print(n)\n\n"}
{"sequence_id": "A020455", "text": "Primes that contain digits 1 and 7 only.", "sequence": "7,11,17,71,1117,1171,1777,7177,7717,11117,11171,11177,11717,11777,17117,71171,71711,71777,77171,77711,1111711,1111771,1117111,1117117,1117177,1171111,1171117,1171771,1177171,1177711,1177717,1711117,1717117,1771177,1771717", "code": "\nfrom sympy import isprime\ndef only17(n): return int(bin(n+1)[3:].replace('1', '7').replace('0', '1'))\ndef auptod(digs):\n  return list(filter(isprime, (only17(i) for i in range(1, 2**(digs+1)-1))))\nprint(auptod(8)) \n"}
{"sequence_id": "A020462", "text": "Primes that contain digits 3 and 5 only.", "sequence": "3,5,53,353,3533,5333,33353,33533,35353,35533,53353,55333,333533,353333,533353,535333,3335533,3353333,3353533,3355553,3533533,3553553,3555353,5333353,5333533,5353553,5533553,33335333,33555553,35535553,35553533", "code": "\nfrom gmpy2 import is_prime, mpz\nfrom itertools import product\nA020462_list = [int(''.join(x)) for n in range(1,10) for x in product('35',repeat=n) if is_prime(mpz(''.join(x)))] \n"}
{"sequence_id": "A020465", "text": "Primes that contain digits 4 and 7 only.", "sequence": "7,47,4447,7477,44777,47777,74747,77447,77477,77747,4444747,4447747,4747747,4774477,4774747,7444477,7447777,7474477,7477777,7747477,7774777,7777447,44447747,44747447,44747777,44774777,47447747,47774477,47774747", "code": "\nfrom sympy import isprime\nfrom itertools import count, takewhile\ndef A284971(n):\n  b = bin(n+1)[3:]\n  return int(\"\".join(b.replace(\"0\", \"4\").replace(\"1\", \"7\")))\ndef aupto(limit):\n  return list(filter(isprime, takewhile(lambda x: x <= limit, (A284971(n) for n in count(1)))))\nprint(aupto(47774747)) \n"}
{"sequence_id": "A020467", "text": "Primes that contain digits 5 and 7 only.", "sequence": "5,7,557,577,757,5557,7577,7757,57557,75557,75577,77557,555557,575557,575777,577757,757577,775757,775777,5555777,5557757,5575777,5577577,5755577,5775557,5777557,7575577,7577777,55555777,55575757,55755757,55757777,57557557", "code": "\nfrom sympy import isprime\nfrom sympy.utilities.iterables import multiset_permutations\ndef aupton(terms):\n  n, digits, alst = 0, 1, []\n  while len(alst) < terms:\n    mpstr = \"\".join(d*digits for d in \"57\")\n    for mp in multiset_permutations(mpstr, digits):\n      t = int(\"\".join(mp))\n      if isprime(t): alst.append(t)\n      if len(alst) == terms: break\n    else: digits += 1\n  return alst\nprint(aupton(33)) \n"}
{"sequence_id": "A020492", "text": "Balanced numbers: numbers n such that phi(n) (A000010) divides sigma(n) (A000203).", "sequence": "1,2,3,6,12,14,15,30,35,42,56,70,78,105,140,168,190,210,248,264,270,357,418,420,570,594,616,630,714,744,812,840,910,1045,1240,1254,1485,1672,1848,2090,2214,2376,2436,2580,2730,2970,3080,3135,3339,3596,3720,3828", "code": "\nfrom sympy import totient, divisor_sigma\nprint([n for n in range(1, 4001) if divisor_sigma(n)%totient(n)==0]) \n"}
{"sequence_id": "A020652", "text": "Numerators in canonical bijection from positive integers to positive rationals.", "sequence": "1,1,2,1,3,1,2,3,4,1,5,1,2,3,4,5,6,1,3,5,7,1,2,4,5,7,8,1,3,7,9,1,2,3,4,5,6,7,8,9,10,1,5,7,11,1,2,3,4,5,6,7,8,9,10,11,12,1,3,5,9,11,13,1,2,4,7,8,11,13,14,1,3,5,7,9,11,13,15,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,5", "code": "\nfrom sympy import totient, gcd\ndef a(n):\n    s=0\n    k=2\n    while s<n:\n        s+=totient(k)\n        k+=1\n    s-=totient(k - 1)\n    j=1\n    while s<n:\n        if gcd(j, k - 1)==1:\n            s+=1\n        j+=1\n    return j - 1\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A020653", "text": "Denominators in canonical bijection from positive integers to positive rationals.", "sequence": "1,2,1,3,1,4,3,2,1,5,1,6,5,4,3,2,1,7,5,3,1,8,7,5,4,2,1,9,7,3,1,10,9,8,7,6,5,4,3,2,1,11,7,5,1,12,11,10,9,8,7,6,5,4,3,2,1,13,11,9,5,3,1,14,13,11,8,7,4,2,1,15,13,11,9,7,5,3,1,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,17", "code": "\nfrom sympy import totient, gcd\ndef a(n):\n    s=0\n    k=2\n    while s<n:\n        s+=totient(k)\n        k+=1\n    s-=totient(k - 1)\n    j=1\n    while s<n:\n        if gcd(j, k - 1)==1: s+=1\n        j+=1\n    return k - j \n"}
{"sequence_id": "A020654", "text": "Lexicographically earliest infinite increasing sequence of nonnegative numbers containing no 5-term arithmetic progression.", "sequence": "0,1,2,3,5,6,7,8,10,11,12,13,15,16,17,18,25,26,27,28,30,31,32,33,35,36,37,38,40,41,42,43,50,51,52,53,55,56,57,58,60,61,62,63,65,66,67,68,75,76,77,78,80,81,82,83,85,86,87,88,90,91,92,93,125,126,127", "code": "\nfrom sympy.ntheory.factor_ import digits\nprint([n for n in range(201) if digits(n, 5)[1:].count(4)==0]) \n"}
{"sequence_id": "A020666", "text": "a(n)^n is the least n-th power containing every digit.", "sequence": "1023456789,32043,2326,763,309,159,56,104,49,36,25,15,25,17,17,15,16,7,5,6,6,5,11,9,14,5,5,5,5,9,5,8,11,4,4,6,5,7,3,5,4,4,6,4,3,6,3,3,4,4,5,4,3,6,4,4,3,4,4,3,3,3,3,3,3,4,3,2,3,2,3,3,3,3,4,3,3,3,2,3,4,2,3,2,3,3,2,2,2", "code": "\ndef a(n):\n    if n == 1: return 1023456789\n    an = 2\n    while not(len(set(str(an**n))) == 10): an += 1\n    return an\nprint([a(n) for n in range(1, 90)]) \n"}
{"sequence_id": "A020667", "text": "Least n-th power containing every digit.", "sequence": "1023456789,1026753849,12584301976,338920744561,2817036000549,16157819263041,1727094849536,13685690504052736,1628413597910449,3656158440062976,2384185791015625,129746337890625,1490116119384765625,168377826559400929,2862423051509815793", "code": "\ndef a(n):\n    if n == 1: return 1023456789\n    a020667n = 2\n    while not(len(set(str(a020667n**n))) == 10): a020667n += 1\n    return a020667n**n\nprint([a(n) for n in range(1, 16)]) \n"}
{"sequence_id": "A020956", "text": "Sum of [tau^(n-k)] for k from 1 to infinity.", "sequence": "1,2,4,8,14,25,42,71,117,193,315,514,835,1356,2198,3562,5768,9339,15116,24465,39591,64067,103669,167748,271429,439190,710632,1149836,1860482,3010333,4870830,7881179,12752025,20633221,33385263,54018502,87403783,141422304", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,100):\n    print(prev, end=\", \")\n    curr = prpr+prev + n//2\n    prpr = prev\n    prev = curr\n\n"}
{"sequence_id": "A020968", "text": "Expansion of 1/((1-7*x)*(1-8*x)*(1-11*x)).", "sequence": "1,26,455,6700,89661,1130766,13712035,161844800,1874156921,21406992706,242089527615,2717862993300,30349359729781,337562780465846,3743627395703195,41428143398876200,457728746687336241", "code": " def A020968(n): return (3*7**(n+2)-4*8**(n + 2)+11**(n+2))//12 \n"}
{"sequence_id": "A020969", "text": "Expansion of 1/((1-7*x)*(1-8*x)*(1-12*x)).", "sequence": "1,27,493,7611,107293,1432011,18457741,232505307,2883927805,35398400235,431393410669,5231599117563,63232056214237,762504498009099,9180490786688077,110414131486397979,1326988747136473789", "code": " def A020969(n): return (7**(n+2)-10*8**(n+1)+3*12**(n+1))/5 \n"}
{"sequence_id": "A020985", "text": "The Rudin-Shapiro or Golay-Rudin-Shapiro sequence (coefficients of the Shapiro polynomials).", "sequence": "1,1,1,-1,1,1,-1,1,1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,1,-1,-1,-1,1,1,1,-1,1,1,1,1,-1,1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,1,1,1,1,-1,-1,-1,1,-1,1", "code": "\ndef a014081(n): return sum([((n>>i)&3==3) for i in range(len(bin(n)[2:]) - 1)])\ndef a(n): return (-1)**a014081(n) \n"}
{"sequence_id": "A021907", "text": "Decimal expansion of 1/903.", "sequence": "0,0,1,1,0,7,4,1,9,7,1,2,0,7,0,8,7,4,8,6,1,5,7,2,5,3,5,9,9,1,1,4,0,6,4,2,3,0,3,4,3,3,0,0,1,1,0,7,4,1,9,7,1,2,0,7,0,8,7,4,8,6,1,5,7,2,5,3,5,9,9,1,1,4,0,6,4,2,3,0,3,4,3,3,0,0,1,1,0,7,4,1,9,7,1,2,0,7,0", "code": "\nb = 10\nwhile 1:\n    n = int(b/903)\n    print(n)\n    b = (b%903)*10\n\n"}
{"sequence_id": "A022004", "text": "Initial members of prime triples (p, p+2, p+6).", "sequence": "5,11,17,41,101,107,191,227,311,347,461,641,821,857,881,1091,1277,1301,1427,1481,1487,1607,1871,1997,2081,2237,2267,2657,2687,3251,3461,3527,3671,3917,4001,4127,4517,4637,4787,4931,4967,5231,5477", "code": "\nfrom sympy import primerange\ndef aupto(limit):\n  p, q, alst = 2, 3, []\n  for r in primerange(5, limit+7):\n    if p+2 == q and p+6 == r: alst.append(p)\n    p, q = q, r\n  return alst\nprint(aupto(5477)) \n"}
{"sequence_id": "A022006", "text": "Initial members p of prime quintuplets (p, p+2, p+6, p+8, p+12).", "sequence": "5,11,101,1481,16061,19421,21011,22271,43781,55331,144161,165701,166841,195731,201821,225341,247601,268811,326141,347981,361211,397751,465161,518801,536441,633461,633791,661091,768191,795791,829721,857951,876011,958541", "code": "\nfrom sympy import primerange\ndef aupto(limit):\n  p, q, r, s, alst = 2, 3, 5, 7, []\n  for t in primerange(11, limit+13):\n    if p+2 == q and p+6 == r and p+8 == s and p+12 == t: alst.append(p)\n    p, q, r, s = q, r, s, t\n  return alst\nprint(aupto(10**6)) \n"}
{"sequence_id": "A022172", "text": "Triangle of Gaussian binomial coefficients [ n,k ] for q = 8.", "sequence": "1,1,1,1,9,1,1,73,73,1,1,585,4745,585,1,1,4681,304265,304265,4681,1,1,37449,19477641,156087945,19477641,37449,1,1,299593,1246606473,79936505481,79936505481,1246606473,299593,1", "code": "\nfrom operator import mul\ndef a027878(n): return 1 if n==0 else reduce(mul, [8**i - 1 for i in range(1, n + 1)])\ndef T(n, m): return a027878(n)//(a027878(m)*a027878(n - m))\nfor n in range(11): print([T(n, m) for m in range(n + 1)]) \n"}
{"sequence_id": "A022173", "text": "Triangle of Gaussian binomial coefficients [ n,k ] for q = 9.", "sequence": "1,1,1,1,10,1,1,91,91,1,1,820,7462,820,1,1,7381,605242,605242,7381,1,1,66430,49031983,441826660,49031983,66430,1,1,597871,3971657053,322140667123,322140667123,3971657053", "code": "\nfrom operator import mul\ndef a027878(n): return 1 if n==0 else reduce(mul, [9**i - 1 for i in range(1, n + 1)])\ndef T(n, m): return a027878(n)/(a027878(m)*a027878(n - m))\nfor n in range(11): print([T(n, m) for m in range(n + 1)]) \n"}
{"sequence_id": "A022174", "text": "Triangle of Gaussian binomial coefficients [ n,k ] for q = 10.", "sequence": "1,1,1,1,11,1,1,111,111,1,1,1111,11211,1111,1,1,11111,1122211,1122211,11111,1,1,111111,112232211,1123333211,112232211,111111,1,1,1111111,11223332211,1123445443211,1123445443211", "code": "\nfrom operator import mul\ndef a027878(n): return 1 if n==0 else reduce(mul, [10**i - 1 for i in range(1, n + 1)])\ndef T(n, m): return a027878(n)/(a027878(m)*a027878(n - m))\nfor n in range(11): print([T(n, m) for m in range(n + 1)]) \n"}
{"sequence_id": "A022341", "text": "Odd Fibbinary numbers; also 4*Fibbinary(n) + 1.", "sequence": "1,5,9,17,21,33,37,41,65,69,73,81,85,129,133,137,145,149,161,165,169,257,261,265,273,277,289,293,297,321,325,329,337,341,513,517,521,529,533,545,549,553,577,581,585,593,597,641,645,649,657,661,673,677,681", "code": "\nfor n in range(1, 700, 2):\n    if n*2 & n == 0:\n        print(n, end=',')\n"}
{"sequence_id": "A022410", "text": "a(n) = a(n-1) + a(n-2) + 1 for n>1, a(0)=3, a(1)=11.", "sequence": "3,11,15,27,43,71,115,187,303,491,795,1287,2083,3371,5455,8827,14283,23111,37395,60507,97903,158411,256315,414727,671043,1085771,1756815,2842587,4599403,7441991,12041395,19483387,31524783,51008171,82532955,133541127", "code": "\nfrom sympy import lucas\ndef a(n): return 4 * lucas(n + 1) - 1\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A022470", "text": "Describe the previous term! (method B - initial term is 2).", "sequence": "2,21,2111,2113,211231,2112213111,211222113113,21122312311231,2112223111213112213111,21122331132111311222113113,211222321231211331122312311231,21122331211121311121123212223111213112213111,21122232112113211131132112213121112331132111311222113113", "code": "\nfrom itertools import accumulate, groupby, repeat\ndef summarize(n, _):\n  return int(\"\".join(k+str(len(list(g))) for k, g in groupby(str(n))))\ndef aupton(nn): return list(accumulate(repeat(2, nn), summarize))\nprint(aupton(13)) \n"}
{"sequence_id": "A022488", "text": "Describe previous term from the right (method B - initial term is 2).", "sequence": "2,21,1121,112112,21122112,2112221221,112211231221,1122113121122212,21112312211131122212,211123123113221131211321,112131122111311222311231211131211321,112131122111311321113121123123123113221231112112", "code": "\nfrom re import split\nA022488_list, l = [2], '2'\nfor _ in range(10):\n....l = ''.join(d[0]+str(len(d)) for d in split('(0+|1+|2+|3+|4+|5+|6+|7+|8+|9+)',l[::-1]) if d != '')\n....A022488_list.append(int(l)) \n"}
{"sequence_id": "A022488", "text": "Describe previous term from the right (method B - initial term is 2).", "sequence": "2,21,1121,112112,21122112,2112221221,112211231221,1122113121122212,21112312211131122212,211123123113221131211321,112131122111311222311231211131211321,112131122111311321113121123123123113221231112112", "code": "\nfrom itertools import accumulate, groupby, repeat\ndef summarize(n, _):\n  return int(\"\".join(k+str(len(list(g))) for k, g in groupby(str(n)[::-1])))\ndef aupton(nn): return list(accumulate(repeat(2, nn), summarize))\nprint(aupton(12)) \n"}
{"sequence_id": "A022510", "text": "Describe previous term from the right (method A - initial term is 6).", "sequence": "6,16,1611,211611,21162112,122112162112,122112161112212211,2122112231161112212211,21221122311621132221221112,12312211321321121621132221221112", "code": "\nfrom re import split\nA022510_list, l = [6], '6'\nfor _ in range(10):\n    l = ''.join(str(len(d))+d[0] for d in split('(0+|1+|2+|3+|4+|5+|6+|7+|8+|9+)',l[::-1]) if d)\n    A022510_list.append(int(l)) \n"}
{"sequence_id": "A022519", "text": "Describe previous term from the right (method B - initial term is 8).", "sequence": "8,81,1181,118112,21128112,211281211221,112212211181211221,1122122111811322112212,21112212223112811322112212,21112212223112812112312311221321", "code": "\nfrom itertools import groupby\nA022519_list = [8]\nfor _ in range(10):\n    A022519_list.append(int(''.join(str(k)+str(len(list(g))) for k, g in groupby(str(A022519_list[-1])[::-1])))) \n"}
{"sequence_id": "A022544", "text": "Numbers that are not the sum of 2 squares.", "sequence": "3,6,7,11,12,14,15,19,21,22,23,24,27,28,30,31,33,35,38,39,42,43,44,46,47,48,51,54,55,56,57,59,60,62,63,66,67,69,70,71,75,76,77,78,79,83,84,86,87,88,91,92,93,94,95,96,99,102,103,105,107,108,110,111,112,114,115,118,119,120,123,124,126,127,129,131,132,133,134,135,138,139,140,141,142,143,147,150,151,152,154,155,156,158,159,161,163,165,166,167,168,171,172,174,175,176,177,179,182,183,184,186,187,188,189,190,191,192,195,198,199", "code": "\ndef aupto(lim):\n  squares = [k*k for k in range(int(lim**.5)+2) if k*k <= lim]\n  sum2sqs = set(a+b for i, a in enumerate(squares) for b in squares[i:])\n  return sorted(set(range(lim+1)) - sum2sqs)\nprint(aupto(199)) \n"}
{"sequence_id": "A022553", "text": "Number of binary Lyndon words containing n letters of each type; periodic binary sequences of period 2n with n zeros and n ones in each period.", "sequence": "1,1,1,3,8,25,75,245,800,2700,9225,32065,112632,400023,1432613,5170575,18783360,68635477,252085716,930138521,3446158600,12815663595,47820414961,178987624513,671825020128,2528212128750,9536894664375,36054433807398,136583760011496", "code": "\nfrom sympy import mobius, binomial, divisors\ndef a(n):\n    return 1 if n == 0 else sum(mobius(n//d)*binomial(2*d, d) for d in divisors(n))//(2*n)\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A022559", "text": "Sum of exponents in prime-power factorization of n!.", "sequence": "0,0,1,2,4,5,7,8,11,13,15,16,19,20,22,24,28,29,32,33,36,38,40,41,45,47,49,52,55,56,59,60,65,67,69,71,75,76,78,80,84,85,88,89,92,95,97,98,103,105,108,110,113,114,118,120,124,126,128,129,133,134,136,139", "code": "\nfrom sympy import factorint as pf\ndef aupton(nn):\n    alst = [0]\n    for n in range(1, nn+1): alst.append(alst[-1] + sum(pf(n).values()))\n    return alst\nprint(aupton(63)) \n"}
{"sequence_id": "A022796", "text": "Place where n-th 1 occurs in A023134.", "sequence": "1,2,3,4,6,8,10,13,16,19,23,27,31,36,41,46,52,58,64,71,78,85,93,101,109,117,126,135,144,154,164,174,185,196,207,219,231,243,256,269,282,296,310,324,339,354,369,384,400,416,432,449,466,483,501,519", "code": "\nimport math\nfrom mpmath import *\nmp.dps = 100\nprint([n + sum([int(math.floor((n - k)/pi)) for k in range(1, n + 1)]) for n in range(1, 101)]) \n"}
{"sequence_id": "A022797", "text": "n-th prime + n-th nonprime.", "sequence": "3,7,11,15,20,23,29,33,38,45,49,57,62,65,71,78,85,88,95,101,105,112,117,124,133,139,142,147,151,157,172,177,185,188,199,202,209,217,222,229,236,239,251,255,260,263,276,289,295,298,303,311,315,326", "code": "\nfrom sympy import prime, composite\ndef A022797(n): return 3 if n == 1 else prime(n)+composite(n-1) \n"}
{"sequence_id": "A022825", "text": "a(n) = a([ n/2 ]) + a([ n/3 ]) + . . . + a([ n/n ]) for n > 1, a(1) = 1.", "sequence": "1,1,2,3,4,6,7,9,11,13,14,19,20,22,25,29,30,36,37,42,45,47,48,60,62,64,68,73,74,84,85,93,96,98,101,119,120,122,125,137,138,148,149,154,162,164,165,193,195,201,204,209,210,226,229,241,244,246,247,278,279", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A022825(n):\n    if n <= 1:\n        return n\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A022825(k1)\n        j, k1 = j2, n//j2\n    return c+n+1-j \n"}
{"sequence_id": "A022842", "text": "Beatty sequence for sqrt(8).", "sequence": "2,5,8,11,14,16,19,22,25,28,31,33,36,39,42,45,48,50,53,56,59,62,65,67,70,73,76,79,82,84,87,90,93,96,98,101,104,107,110,113,115,118,121,124,127,130,132,135,138,141,144,147,149,152,155,158,161,164", "code": "\nfrom sympy import integer_nthroot\ndef A022842(n): return integer_nthroot(8*n**2,2)[0] \n"}
{"sequence_id": "A022843", "text": "Beatty sequence for e: a(n) = floor(n*e).", "sequence": "0,2,5,8,10,13,16,19,21,24,27,29,32,35,38,40,43,46,48,51,54,57,59,62,65,67,70,73,76,78,81,84,86,89,92,95,97,100,103,106,108,111,114,116,119,122,125,127,130,133,135,138,141,144,146,149,152,154,157,160", "code": "\nimport math\nfrom mpmath import mp, e\nmp.dps = 100\nprint([int(math.floor(n*e)) for n in range(51)]) \n"}
{"sequence_id": "A022964", "text": "a(n) = 8-n.", "sequence": "8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51", "code": " print([8-n for n in range(60)]) \n"}
{"sequence_id": "A023002", "text": "Sum of 10th powers.", "sequence": "0,1,1025,60074,1108650,10874275,71340451,353815700,1427557524,4914341925,14914341925,40851766526,102769130750,240627622599,529882277575,1106532668200,2206044295976,4222038196425,7792505423049,13923571680850", "code": "\nA023002_list, m = [0], [3628800, -16329600, 30240000, -29635200, 16435440, -5103000, 818520, -55980, 1022, -1, 0 , 0]\nfor _ in range(20):\n    for i in range(11):\n        m[i+1]+= m[i]\n    A023002_list.append(m[-1])\nprint(A023002_list) \n"}
{"sequence_id": "A023022", "text": "Number of partitions of n into two relatively prime parts. After initial term, this is the \"half-totient\" function phi(n)/2 (A000010(n)/2).", "sequence": "1,1,1,2,1,3,2,3,2,5,2,6,3,4,4,8,3,9,4,6,5,11,4,10,6,9,6,14,4,15,8,10,8,12,6,18,9,12,8,20,6,21,10,12,11,23,8,21,10,16,12,26,9,20,12,18,14,29,8,30,15,18,16,24,10,33,16,22,12,35,12,36,18,20,18,30,12,39,16,27,20,41,12", "code": "\nfrom sympy.ntheory import totient\ndef a(n): return 1 if n<3 else totient(n)/2 \n"}
{"sequence_id": "A023086", "text": "Numbers k such that k and 2*k are anagrams.", "sequence": "0,125874,128574,142587,142857,258714,258741,285714,285741,412587,412857,425871,428571,1025874,1028574,1042587,1042857,1052874,1054287,1072854,1074285,1078524,1078542,1085274,1085427,1087254,1087425,1087524,1087542", "code": "\ndef ok(n): return sorted(str(n)) == sorted(str(2*n))\nprint(list(filter(ok, range(1087543)))) \n"}
{"sequence_id": "A023086", "text": "Numbers k such that k and 2*k are anagrams.", "sequence": "0,125874,128574,142587,142857,258714,258741,285714,285741,412587,412857,425871,428571,1025874,1028574,1042587,1042857,1052874,1054287,1072854,1074285,1078524,1078542,1085274,1085427,1087254,1087425,1087524,1087542", "code": " \ndef auptod(maxd):\n  return [0] + list(filter(ok, (n for d in range(2, maxd+1) for n in range(10**(d-1)-1, 5*10**(d-1), 9))))\nprint(auptod(7)) \n"}
{"sequence_id": "A023106", "text": "a(n) is a power of the sum of its digits.", "sequence": "0,1,2,3,4,5,6,7,8,9,81,512,2401,4913,5832,17576,19683,234256,390625,614656,1679616,17210368,34012224,52521875,60466176,205962976,612220032,8303765625,10460353203,24794911296,27512614111,52523350144,68719476736", "code": " import math\ndef is_valid(n): dsum = sum(map(int, str(n))); return dsum ** int(round(math.log(n, dsum))) == n if dsum > 1 else n < 2\n\n"}
{"sequence_id": "A023109", "text": "Smallest number that requires exactly n iterations of Reverse and Add to reach a palindrome.", "sequence": "0,10,19,59,69,166,79,188,193,1397,829,167,2069,1797,849,177,1496,739,1798,10777,6999,1297,869,187,89,10797,10853,10921,10971,13297,10548,13293,17793,20889,700269,106977,108933,80359,13697,10794,15891,1009227,1007619,1009246,1008628,600259,131996,70759,1007377,1001699,600279,141996,70269,10677,10833,10911", "code": "\ndef A023109(n):\n    if n > 0:\n        k = 0\n        while True:\n            m = k\n            for i in range(n):\n                if str(m) == str(m)[::-1]:\n                    break\n                m += int(str(m)[::-1])\n            else:\n                if str(m) == str(m)[::-1]:\n                    return k\n            k += 1\n    else:\n        return 0\n\n"}
{"sequence_id": "A023143", "text": "Numbers k such that prime(k) == 1 (mod k).", "sequence": "1,2,5,6,12,14,181,6459,6460,6466,100362,251712,251732,637236,10553504,10553505,10553547,10553827,10553851,10553852,69709709,69709724,69709728,69709869,69709961,69709962,179992920,179992922,179993170,465769815,465769819,465769840,3140421737,3140421744,3140421767,3140421892,3140421935", "code": "\ndef A023143(end):\n    primes=[2,3]\n    a023143_list=[1]\n    num=3\n    while len(primes)<=end:\n        num+=1\n        prime=False\n        length=len(primes)\n        for y in range(0,length):\n            if num % primes[y]!=0:\n                prime=True\n            else:\n                prime=False\n                break\n        if (prime):\n            primes.append(num)\n    for x in range(2, len(primes)):\n        if (primes[x-1]%(x))==1:\n            a023143_list.append(x)\n    return a023143_list\n\n"}
{"sequence_id": "A023143", "text": "Numbers k such that prime(k) == 1 (mod k).", "sequence": "1,2,5,6,12,14,181,6459,6460,6466,100362,251712,251732,637236,10553504,10553505,10553547,10553827,10553851,10553852,69709709,69709724,69709728,69709869,69709961,69709962,179992920,179992922,179993170,465769815,465769819,465769840,3140421737,3140421744,3140421767,3140421892,3140421935", "code": "\nfrom sympy import primerange\ndef A023143(end): return [n+1 for n, p in enumerate(primerange(2, end)) if (p-1) % (n-1) == 0] \n"}
{"sequence_id": "A023194", "text": "Numbers whose sum of divisors is prime.", "sequence": "2,4,9,16,25,64,289,729,1681,2401,3481,4096,5041,7921,10201,15625,17161,27889,28561,29929,65536,83521,85849,146689,262144,279841,458329,491401,531441,552049,579121,597529,683929,703921,707281,734449,829921,1190281", "code": "\nfrom sympy import isprime, divisor_sigma\nA023194_list = [2]+[n**2 for n in range(1,10**3) if isprime(divisor_sigma(n**2))] \n"}
{"sequence_id": "A023195", "text": "Prime numbers that are the sum of the divisors of some n.", "sequence": "3,7,13,31,127,307,1093,1723,2801,3541,5113,8011,8191,10303,17293,19531,28057,30103,30941,86143,88741,131071,147073,292561,459007,492103,524287,552793,579883,598303,684757,704761,732541,735307,797161,830833,1191373", "code": "\nfrom sympy import isprime, divisor_sigma\nA023195_list = sorted(set([3]+[n for n in (divisor_sigma(d**2) for d in range(1,10**4)) if isprime(n)])) \n"}
{"sequence_id": "A023273", "text": "Primes that remain prime through 3 iterations of function f(x) = 2x + 3.", "sequence": "2,5,47,67,97,137,197,277,307,607,617,1307,1427,2857,5717,6047,6217,6257,6997,9377,9787,9967,11197,12097,13297,13997,14347,16057,18757,18947,20887,21517,21587,21757,24197,26227,28097,28447,32117,33767,34367,35117", "code": "\nfrom sympy import prime, isprime\nA023273_list = [p for p in (prime(n) for n in range(1,10**2)) if isprime(2*p+3) and isprime(4*p+9) and isprime(8*p+21)] \n"}
{"sequence_id": "A023330", "text": "Primes that remain prime through 5 iterations of function f(x) = 2x + 1.", "sequence": "89,63419,127139,405269,810809,1069199,1122659,1178609,1333889,1598699,1806089,1958249,2164229,2245319,2329469,2606069,2848949,3241289,3339989,3784199,3962039,4088879,4328459,4444829,4658939,4664249,4894889,4897709,5132999", "code": "\nfrom sympy import prime, isprime\nA023330_list = [p for p in (prime(n) for n in range(1,10**5)) if all([isprime(2**m*(p+1)-1) for m in range(1,6)])] \n"}
{"sequence_id": "A023415", "text": "If any power of 2 ends with k 8's and 9's, they must be the first k elements of this sequence in reverse order.", "sequence": "8,8,8,9,8,9,9,8,9,8,9,8,8,9,9,8,9,8,9,9,9,8,8,8,8,9,8,8,8,8,9,9,9,9,8,9,8,8,9,9,8,8,9,9,8,9,8,8,9,8,9,8,9,8,8,8,8,8,8,9,9,9,9,8,9,8,8,8,9,9,8,8,9,8,8,9,9,8,8,9,9,9,8,9,9,9,9,9,9,8,8,9,8,8,9,9,9,9,9,9,8,8,8,9,9,8,8,8", "code": "\n\na,i=8,0; x=a\nwhile i < 200:\n     i+=1; print(x, end=',')\n     if a%2**(i+1) == 0: x=8\n     else: x=9\n     a+=x*10**i\n\n"}
{"sequence_id": "A023576", "text": "Greatest prime divisor of prime(n)+3.", "sequence": "5,3,2,5,7,2,5,11,13,2,17,5,11,23,5,7,31,2,7,37,19,41,43,23,5,13,53,11,7,29,13,67,7,71,19,11,5,83,17,11,13,23,97,7,5,101,107,113,23,29,59,11,61,127,13,19,17,137,7,71,13,37,31,157,79,5,167,17,7,11,89", "code": "\nfrom sympy import primefactors, prime\ndef a(n): return primefactors(prime(n) + 3)[-1]\nprint([a(n) for n in range(1, 72)]) \n"}
{"sequence_id": "A023580", "text": "Sum of distinct prime divisors of prime(n)+3.", "sequence": "5,5,2,7,9,2,7,13,15,2,19,7,13,25,7,9,33,2,14,39,21,43,45,25,7,15,55,18,9,31,20,69,14,73,21,20,7,85,24,13,22,25,99,9,7,103,109,115,30,31,61,13,63,129,20,28,19,139,14,73,26,39,38,159,81,7,169,24,14", "code": "\nfrom sympy import primefactors, prime\ndef a(n): return sum(primefactors(prime(n) + 3))\nprint([a(n) for n in range(1, 70)]) \n"}
{"sequence_id": "A023657", "text": "Convolution of (F(2), F(3), F(4), ...) and primes.", "sequence": "2,7,17,36,71,131,232,399,673,1124,1857,3049,4984,8117,13191,21408,34711,56239,91078,147455,238677,386284,625123,1011579,1636888,2648665,4285757,6934632,11220605,18155459,29376304,47532021,76908593,124440890,201349771", "code": "\nfrom sympy import prime, fibonacci\nprint([sum([fibonacci(k + 1) * prime(n - k + 1) for k in range(1, n + 1)]) for n in range(1, 101)]) \n"}
{"sequence_id": "A023804", "text": "Xenodromes: all digits in base 9 are different.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68,69,71,72,73,74,75", "code": "\nfrom itertools import permutations\nA023804_list = sorted(set(int(''.join(d),9) for k in range(1,10) for d in permutations('012345678',k))) \n"}
{"sequence_id": "A023890", "text": "Sum of the nonprime divisors of n.", "sequence": "1,1,1,5,1,7,1,13,10,11,1,23,1,15,16,29,1,34,1,35,22,23,1,55,26,27,37,47,1,62,1,61,34,35,36,86,1,39,40,83,1,84,1,71,70,47,1,119,50,86,52,83,1,115,56,111,58,59,1,158,1,63,94,125,66,128,1,107,70,130,1,190,1,75", "code": "\nfrom sympy import isprime\ndef A023890(n):\n    s=0\n    for i in range(1,n+1):\n        if n%i==0 and not isprime(i):\n            s+=i\n    return s \n"}
{"sequence_id": "A023900", "text": "Dirichlet inverse of Euler totient function (A000010).", "sequence": "1,-1,-2,-1,-4,2,-6,-1,-2,4,-10,2,-12,6,8,-1,-16,2,-18,4,12,10,-22,2,-4,12,-2,6,-28,-8,-30,-1,20,16,24,2,-36,18,24,4,-40,-12,-42,10,8,22,-46,2,-6,4,32,12,-52,2,40,6,36,28,-58,-8,-60,30,12,-1,48,-20,-66,16,44,-24,-70,2,-72,36,8,18,60,-24,-78,4,-2", "code": "\nfrom sympy import divisors, mobius\ndef a(n): return sum([d*mobius(d) for d in divisors(n)]) \n(Scheme, with memoization-macro definec) (definec (A023900 n) (if (= 1 n) 1 (* (- 1 (A020639 n)) (A023900 (A028234 n))))) ;; _Antti Karttunen_, Nov 28 2017\n"}
{"sequence_id": "A023969", "text": "a(n) = round(sqrt(n)) - floor(sqrt(n)).", "sequence": "0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0", "code": "\nfrom gmpy2 import isqrt_rem\ndef A023969(n):\n    i, j = isqrt_rem(n)\n    return int(4*(j-i) >= 1) \n"}
{"sequence_id": "A024167", "text": "a(n) = n!*(1 - 1/2 + 1/3 - ... + c/n), where c = (-1)^(n+1).", "sequence": "1,1,5,14,94,444,3828,25584,270576,2342880,29400480,312888960,4546558080,57424792320,948550176000,13869128448000,256697973504000,4264876094976000,87435019510272000,1627055289796608000,36601063093905408000,754132445894209536000", "code": "\ndef A():\n    a, b, n = 1, 1, 2\n    yield(a)\n    while True:\n        yield(a)\n        b, a = a, a + b * n * n\n        n += 1\na = A(); print([next(a) for _ in range(20)]) \n"}
{"sequence_id": "A024450", "text": "Sum of squares of the first n primes.", "sequence": "4,13,38,87,208,377,666,1027,1556,2397,3358,4727,6408,8257,10466,13275,16756,20477,24966,30007,35336,41577,48466,56387,65796,75997,86606,98055,109936,122705,138834,155995,174764,194085,216286,239087,263736,290305,318194", "code": "\nfrom sympy import prime, primerange\ndef a(n): return sum(p*p for p in primerange(1, prime(n)+1))\nprint([a(n) for n in range(1, 40)]) \n"}
{"sequence_id": "A024451", "text": "a(n) is the numerator of Sum_{i = 1..n} 1/prime(i).", "sequence": "0,1,5,31,247,2927,40361,716167,14117683,334406399,9920878441,314016924901,11819186711467,492007393304957,21460568175640361,1021729465586766997,54766551458687142251,3263815694539731437539,201015517717077830328949,13585328068403621603022853", "code": "\nfrom sympy import prime\nfrom fractions import Fraction\ndef a(n): return sum(Fraction(1, prime(k)) for k in range(1, n+1)).numerator\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A024502", "text": "a(n) = floor(C(2n,n)/2^n).", "sequence": "1,1,1,2,4,7,14,26,50,94,180,344,660,1269,2448,4733,9171,17804,34618,67415,131460,256661,501656,981501,1922106,3767329,7389761,14505829,28493592,56004648,110142474,216731966,426691058,840452084,1656184990", "code": "\nimport math\nfor n in range(55):  print(str(math.factorial(2*n)//(math.factorial(n)**2 * 2**n)), end=',')\n\n"}
{"sequence_id": "A024670", "text": "Numbers that are sums of 2 distinct positive cubes.", "sequence": "9,28,35,65,72,91,126,133,152,189,217,224,243,280,341,344,351,370,407,468,513,520,539,559,576,637,728,730,737,756,793,854,855,945,1001,1008,1027,1064,1072,1125,1216,1241,1332,1339,1343,1358,1395,1456,1512,1547,1674", "code": "\nfrom itertools import count, takewhile\ndef aupto(limit):\n    cbs = list(takewhile(lambda x: x <= limit, (i**3 for i in count(1))))\n    sms = set(c+d for i, c in enumerate(cbs) for d in cbs[i+1:])\n    return sorted(s for s in sms if s <= limit)\nprint(aupto(1674)) \n"}
{"sequence_id": "A024675", "text": "Average of two consecutive odd primes.", "sequence": "4,6,9,12,15,18,21,26,30,34,39,42,45,50,56,60,64,69,72,76,81,86,93,99,102,105,108,111,120,129,134,138,144,150,154,160,165,170,176,180,186,192,195,198,205,217,225,228,231,236,240,246,254,260,266,270,274,279,282,288,300", "code": "\nfrom sympy import prime\ndef a(n): return (prime(n + 1) + prime(n + 2)) // 2\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A024770", "text": "Right-truncatable primes: every prefix is prime.", "sequence": "2,3,5,7,23,29,31,37,53,59,71,73,79,233,239,293,311,313,317,373,379,593,599,719,733,739,797,2333,2339,2393,2399,2939,3119,3137,3733,3739,3793,3797,5939,7193,7331,7333,7393,23333,23339,23399,23993,29399,31193", "code": "\nfrom sympy import primerange\np = lambda x: list(primerange(x, x+10)); A024770 = p(0); i=0\nwhile i<len(A024770): A024770+=p(A024770[i]*10); i+=1 \n"}
{"sequence_id": "A024785", "text": "Left-truncatable primes: every suffix is prime and no digits are zero.", "sequence": "2,3,5,7,13,17,23,37,43,47,53,67,73,83,97,113,137,167,173,197,223,283,313,317,337,347,353,367,373,383,397,443,467,523,547,613,617,643,647,653,673,683,743,773,797,823,853,883,937,947,953,967,983,997,1223", "code": "\nfrom sympy import isprime\ndef alst():\n  primes, alst = [2, 3, 5, 7], []\n  while len(primes) > 0:\n    alst += sorted(primes)\n    candidates = set(int(d+str(p)) for p in primes for d in \"123456789\")\n    primes = [c for c in candidates if isprime(c)]\n  return alst\nprint(alst()) \n"}
{"sequence_id": "A025003", "text": "a(1) = 2; a(n+1) = a(n)-th nonprime, where nonprimes begin at 1.", "sequence": "2,4,8,14,22,33,48,66,90,120,156,202,256,322,400,494,604,734,888,1067,1272,1512,1790,2107,2472,2890,3364,3903,4515,5207,5990,6875,7868,8984,10238,11637,13207,14959,16909,19075,21483,24173,27149,30436,34080,38103", "code": "\nfrom sympy import prime, primepi\nn_last = 0\npi_last = 0\nct_max = -1\nfor n in range(1, 100001):\n    ct = 0\n    pi = pi_last + primepi(n) - primepi(n_last)\n    n_c = n\n    pi_c = pi\n    while n_c > 1:\n        nc -= pi_c\n        ct += 1\n        pi_c -= primepi(n_c + pi_c) - primepi(n_c)\n    if ct > ct_max:\n        print(n)\n        ct_max = ct\n    n_last = n\n    pi_last = pi \n"}
{"sequence_id": "A025192", "text": "a(0)=1; a(n) = 2*3^(n-1) for n >= 1.", "sequence": "1,2,6,18,54,162,486,1458,4374,13122,39366,118098,354294,1062882,3188646,9565938,28697814,86093442,258280326,774840978,2324522934,6973568802,20920706406,62762119218,188286357654,564859072962,1694577218886", "code": " [1]+[2*3**(n-1) for n in range(1,30)] \n"}
{"sequence_id": "A025281", "text": "a(n) = sopfr(n!), where sopfr = A001414  is the integer log.", "sequence": "0,0,2,5,9,14,19,26,32,38,45,56,63,76,85,93,101,118,126,145,154,164,177,200,209,219,234,243,254,283,293,324,334,348,367,379,389,426,447,463,474,515,527,570,585,596,621,668,679,693,705,725,742,795,806,822,835,857,888", "code": "\nfrom sympy import factorial, factorint\ndef A025281(n): return sum(p*e for p, e in factorint(factorial(n)).items()) \n"}
{"sequence_id": "A025302", "text": "Numbers that are the sum of 2 distinct nonzero squares in exactly 1 way.", "sequence": "5,10,13,17,20,25,26,29,34,37,40,41,45,50,52,53,58,61,68,73,74,80,82,89,90,97,100,101,104,106,109,113,116,117,122,136,137,146,148,149,153,157,160,164,169,173,178,180,181,193,194,197,200,202,208,212,218,225,226,229", "code": "\nfrom collections import Counter\nfrom itertools import combinations\ndef aupto(lim):\n  s = filter(lambda x: x <= lim, (i*i for i in range(1, int(lim**.5)+2)))\n  s2 = filter(lambda x: x <= lim, (sum(c) for c in combinations(s, 2)))\n  s2counts = Counter(s2)\n  return sorted(k for k in s2counts if k <= lim and s2counts[k] == 1)\nprint(aupto(229)) \n"}
{"sequence_id": "A025357", "text": "Numbers that are the sum of 4 nonzero squares in exactly 1 way.", "sequence": "4,7,10,12,13,15,16,18,19,20,21,22,23,25,26,27,30,33,35,38,40,44,46,48,51,53,59,62,64,65,72,80,88,89,101,104,120,152,160,176,184,192,248,256,288,320,352,416,480,608,640,704,736,768,992,1024,1152,1280,1408,1664", "code": " \nlimit = 1664\nfrom functools import lru_cache\nsq = [k*k for k in range(1, int(limit**.5)+2) if k*k + 3 <= limit]\nsqs = set(sq)\n@lru_cache(maxsize=None)\ndef findsums(n, m):\n  if m == 1: return {(n,)} if n in sqs else set()\n  return set(tuple(sorted(t+(s, ))) for s in sq for t in findsums(n-s, m-1))\nprint([n for n in range(4, limit+1) if len(findsums(n, 4)) == 1]) \n"}
{"sequence_id": "A025362", "text": "Numbers that are the sum of 4 nonzero squares in exactly 6 ways.", "sequence": "90,124,133,147,156,157,159,163,165,166,171,174,177,188,193,201,203,205,219,239,241,249,254,260,284,293,299,329,341,360,496,624,664,696,752,1016,1040,1136,1440,1984,2496,2656,2784,3008,4064,4160,4544,5760,7936", "code": "\nlimit = 8000\nfrom functools import lru_cache\nsq = [k**2 for k in range(1, int(limit**.5)+2) if k**2 + 3 <= limit]\nsqs = set(sq)\n@lru_cache(maxsize=None)\ndef findsums(n, m):\n  if m == 1: return {(n, )} if n in sqs else set()\n  return set(tuple(sorted(t+(s,))) for s in sqs for t in findsums(n-s, m-1))\nprint([n for n in range(4, limit+1) if len(findsums(n, 4)) == 6]) \n"}
{"sequence_id": "A025371", "text": "Numbers that are the sum of 4 nonzero squares in 6 or more ways.", "sequence": "90,124,130,133,135,138,147,148,150,154,156,157,159,162,163,165,166,170,171,172,174,175,177,178,180,182,183,186,187,188,189,190,193,195,196,198,199,201,202,203,205,207,210,213,214,215,217,218,219,220,222,223,225,226", "code": "\nlimit = 226\nfrom functools import lru_cache\nsq = [k**2 for k in range(1, int(limit**.5)+2) if k**2 + 3 <= limit]\nsqs = set(sq)\n@lru_cache(maxsize=None)\ndef findsums(n, m):\n  if m == 1: return {(n, )} if n in sqs else set()\n  return set(tuple(sorted(t+(s,))) for s in sqs for t in findsums(n-s, m-1))\nprint([n for n in range(4, limit+1) if len(findsums(n, 4)) >= 6]) \n"}
{"sequence_id": "A025475", "text": "1 and the prime powers p^m where m >= 2, thus excluding the primes.", "sequence": "1,4,8,9,16,25,27,32,49,64,81,121,125,128,169,243,256,289,343,361,512,529,625,729,841,961,1024,1331,1369,1681,1849,2048,2187,2197,2209,2401,2809,3125,3481,3721,4096,4489,4913,5041,5329,6241,6561,6859,6889,7921,8192", "code": "\nfrom sympy import primerange\nA025475_list, m = [1], 10*2\nm2 = m**2\nfor p in primerange(1,m):\n    a = p**2\n    while a < m2:\n        A025475_list.append(a)\n        a *= p\nA025475_list = sorted(A025475_list) \n"}
{"sequence_id": "A025502", "text": "Number of terms in Zeckendorf representation of 10^n.", "sequence": "1,2,3,2,6,9,5,9,13,14,16,11,15,21,20,18,21,26,27,23,24,25,28,35,33,35,34,31,40,35,42,40,43,44,45,50,51,44,53,51,57,58,63,53,54,65,61,65,64,67,64,69,63,77,66,75,81,80,79,79,78,77,77,79,82,97,91,90,100,91,91,91,102", "code": "\ndef A025502(n):\n    m, tlist, s = 10**n, [1,2], 0\n    while tlist[-1]+tlist[-2] <= m:\n        tlist.append(tlist[-1]+tlist[-2])\n    for d in tlist[::-1]:\n        if d <= m:\n            s += 1\n            m -= d\n    return s \n"}
{"sequence_id": "A025523", "text": "a(n) = 1 + Sum_{ k < n and k | n} a(k).", "sequence": "1,2,3,5,6,9,10,14,16,19,20,28,29,32,35,43,44,52,53,61,64,67,68,88,90,93,97,105,106,119,120,136,139,142,145,171,172,175,178,198,199,212,213,221,229,232,233,281,283,291,294,302,303,323,326,346,349,352,353,397,398,401", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A025523(n):\n    if n == 0:\n        return 1\n    c, j = 2, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A025523(k1)\n        j, k1 = j2, n//j2\n    return n+c-j \n"}
{"sequence_id": "A025586", "text": "Largest value in '3x+1' trajectory of n.", "sequence": "1,2,16,4,16,16,52,8,52,16,52,16,40,52,160,16,52,52,88,20,64,52,160,24,88,40,9232,52,88,160,9232,32,100,52,160,52,112,88,304,40,9232,64,196,52,136,160,9232,48,148,88,232,52,160,9232,9232,56,196,88,304,160,184,9232", "code": "\ndef a(n):\n    if n<2: return 1\n    l=[n, ]\n    while True:\n        if n%2==0: n//=2\n        else: n = 3*n + 1\n        if not n in l:\n            l+=[n, ]\n            if n<2: break\n        else: break\n    return max(l)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A026136", "text": "For n >= 2, let L=n-[ n/2 ], R=n+[ n/2 ]; then a(L)=n if a(L) not yet defined, else a(R)=n; thus |a(n)-n|=[ (1/2)*a(n) ].", "sequence": "1,3,2,7,9,4,5,15,6,19,21,8,25,27,10,11,33,12,13,39,14,43,45,16,17,51,18,55,57,20,61,63,22,23,69,24,73,75,26,79,81,28,29,87,30,31,93,32,97,99,34,35,105,36,37,111,38,115,117,40,41,123", "code": "\nimport math\nA026136 ={1:1}\nfor n in range(2,3000):\n    h=math.floor(n/2)\n    L=n-h\n    R=n+h\n    if not L in A026136 :\n        A026136[L]=n\n    else :\n        A026136[R]=n\nfor n in range(1,2000):\n    if n in A026136:\n       print(str(n) + \" \"+ str(A026136[n]))\n    else:\n       break \n"}
{"sequence_id": "A026166", "text": "For n >= 2, let h=floor((n-1)/2), L=n-h, R=n+h; then a(L)=n if a(L) not yet defined, otherwise a(R)=n; thus |a(n)-n| = floor((1/2)*(a(n)-1)).", "sequence": "1,2,4,3,8,10,5,6,16,7,20,22,9,26,28,11,12,34,13,14,40,15,44,46,17,18,52,19,56,58,21,62,64,23,24,70,25,74,76,27,80,82,29,30,88,31,32,94,33,98,100,35,36,106,37,38,112,39,116,118,41,42", "code": "\nA026166 = {1: 1}\nfor n in range(2, 1000):\n    h=(n-1)//2\n    L=n-h\n    R=n+h\n    if not L in A026166 :\n        A026166[L]=n\n    else :\n        A026166[R]=n\nfor n in range(1,2000):\n    if n in A026166:\n       print(A026166[n], end=',')\n    else:\n        break\n\n"}
{"sequence_id": "A026356", "text": "a(n) = floor((n-1)*phi) + n + 1, n > 0, where phi = (1+sqrt(5))/2.", "sequence": "2,4,7,9,12,15,17,20,22,25,28,30,33,36,38,41,43,46,49,51,54,56,59,62,64,67,70,72,75,77,80,83,85,88,91,93,96,98,101,104,106,109,111,114,117,119,122,125,127,130,132,135,138,140,143,145", "code": "\nfrom sympy import sqrt\nimport math\nr=(1 + sqrt(5))/2\ndef a(n): return 1 if n<1 else int(math.floor((n - 1)*r)) + n + 1\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A026532", "text": "Ratios of successive terms are 3,2,3,2,3,2,3,2...", "sequence": "1,3,6,18,36,108,216,648,1296,3888,7776,23328,46656,139968,279936,839808,1679616,5038848,10077696,30233088,60466176,181398528,362797056,1088391168,2176782336,6530347008,13060694016,39182082048", "code": "\ndef a(n): return (3 if n%2 else 1)*6**(n//2)\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A026741", "text": "a(n) = n if n odd, n/2 if n even.", "sequence": "0,1,1,3,2,5,3,7,4,9,5,11,6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38", "code": "\ndef A026741(n): return n if n % 2 else n//2 \n"}
{"sequence_id": "A026791", "text": "Triangle in which n-th row lists juxtaposed lexicographically ordered partitions of n; e.g., the partitions of 3 (1+1+1,1+2,3) appear as 1,1,1,1,2,3 in row 3.", "sequence": "1,1,1,2,1,1,1,1,2,3,1,1,1,1,1,1,2,1,3,2,2,4,1,1,1,1,1,1,1,1,2,1,1,3,1,2,2,1,4,2,3,5,1,1,1,1,1,1,1,1,1,1,2,1,1,1,3,1,1,2,2,1,1,4,1,2,3,1,5,2,2,2,2,4,3,3,6,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,3,1,1,1,2,2,1,1,1,4,1,1,2,3,1,1,5", "code": "\nt = [[[]]]\nfor n in range(1, 10):\n    p = []\n    for minp in range(1, n):\n        p += [[minp] + pp for pp in t[n-minp] if min(pp) >= minp]\n    t.append(p + [[n]])\nprint(t)\n\n"}
{"sequence_id": "A026807", "text": "Triangular array T read by rows: T(n,k) = number of partitions of n in which every part is >=k, for k=1,2,...,n.", "sequence": "1,2,1,3,1,1,5,2,1,1,7,2,1,1,1,11,4,2,1,1,1,15,4,2,1,1,1,1,22,7,3,2,1,1,1,1,30,8,4,2,1,1,1,1,1,42,12,5,3,2,1,1,1,1,1,56,14,6,3,2,1,1,1,1,1,1,77,21,9,5,3,2,1,1,1,1,1,1,101,24,10,5,3,2,1,1,1,1,1,1,1,135,34,13", "code": "\nfrom see_there import a231599_row  \nfrom sympy.ntheory import npartitions  \ndef a026807(n, k):\n    if k > n:\n        return 0\n    elif k > n/2:\n        return 1\n    else:\n        vc = a231599_row(k-1)\n        t = len(vc)\n        vp_range = range(n-t, n+1)\n        vp_range = vp_range[::-1]  \n        r = 0\n        for i in range(0, t):\n            r += vc[i] * npartitions(vp_range[i])\n        return r\n\n"}
{"sequence_id": "A027375", "text": "Number of aperiodic binary strings of length n; also number of binary sequences with primitive period n.", "sequence": "0,2,2,6,12,30,54,126,240,504,990,2046,4020,8190,16254,32730,65280,131070,261576,524286,1047540,2097018,4192254,8388606,16772880,33554400,67100670,134217216,268419060,536870910,1073708010,2147483646,4294901760", "code": "\nfrom sympy import mobius, divisors\ndef a(n): return sum(mobius(d)*2**(n//d) for d in divisors(n))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A027426", "text": "Number of distinct products ijk with 0 <= i,j,k <= n.", "sequence": "1,2,5,11,17,31,41,66,81,101,121,174,195,267,302,344,379,493,537,679,733,805,877,1076,1131,1248,1344,1451,1538,1834,1910,2249,2363,2516,2669,2851,2941,3401,3588,3790,3920,4478,4625,5243,5441,5655,5917,6647,6799,7197", "code": "\nfrom itertools import combinations_with_replacement as mc\ndef a(n): return len(set(i*j*k for i, j, k in mc(range(n+1), 3)))\nprint([a(n) for n in range(50)]) \n"}
{"sequence_id": "A027429", "text": "Number of distinct products ijk with 0 <= i < j < k <= n.", "sequence": "0,0,1,2,5,11,17,30,43,61,76,112,127,178,207,239,275,362,397,508,555,614,678,839,884,1005,1093,1199,1278,1530,1591,1882,1999,2134,2276,2433,2519,2922,3097,3279,3392,3885,4015,4564,4751,4939,5187,5841,5988,6423", "code": "\nfrom itertools import combinations as C\ndef a(n): return len(set(i*j*k for i, j, k in C(range(n+1), 3)))\nprint([a(n) for n in range(50)]) \n"}
{"sequence_id": "A027580", "text": "Palindromes of the form n^2 + (n+1)^2 + (n+2)^2 + (n+3)^2 + (n+4)^2.", "sequence": "55,51015,554455,51488415,510151015,55883648705050784638855,531578379527444725973875135", "code": "\nA027580_list = []\nfor i in range(1,10**8,2):\n    s = str(5*(i*(i+4)+6))\n    if s == s[::-1]:\n        A027580_list.append(int(s)) \n"}
{"sequence_id": "A027602", "text": "a(n) = n^3 + (n+1)^3 + (n+2)^3.", "sequence": "9,36,99,216,405,684,1071,1584,2241,3060,4059,5256,6669,8316,10215,12384,14841,17604,20691,24120,27909,32076,36639,41616,47025,52884,59211,66024,73341,81180,89559,98496,108009,118116,128835,140184", "code": "\nA027602_list, m = [], [18, 0, 9, 9]\nfor _ in range(10**2):\n    A027602_list.append(m[-1])\n    for i in range(3):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A027603", "text": "a(n) = n^3 + (n+1)^3 + (n+2)^3 + (n+3)^3.", "sequence": "36,100,224,432,748,1196,1800,2584,3572,4788,6256,8000,10044,12412,15128,18216,21700,25604,29952,34768,40076,45900,52264,59192,66708,74836,83600,93024,103132,113948,125496,137800,150884,164772", "code": "\nA027603_list, m = [], [24, 12, 28, 36]\nfor _ in range(10**2):\n    A027603_list.append(m[-1])\n    for i in range(3):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A027611", "text": "Denominator of n * n-th harmonic number.", "sequence": "1,1,2,3,12,10,20,35,280,252,2520,2310,27720,25740,24024,45045,720720,680680,4084080,3879876,739024,235144,5173168,14872858,356948592,343219800,2974571600,2868336900,80313433200,77636318760", "code": "\nfrom sympy import harmonic\ndef A027611(n): return (n*harmonic(n)).q \n"}
{"sequence_id": "A027641", "text": "Numerator of Bernoulli number B_n.", "sequence": "1,-1,1,0,-1,0,1,0,-1,0,5,0,-691,0,7,0,-3617,0,43867,0,-174611,0,854513,0,-236364091,0,8553103,0,-23749461029,0,8615841276005,0,-7709321041217,0,2577687858367,0,-26315271553053477373,0,2929993913841559,0,-261082718496449122051", "code": "\nfrom sympy import bernoulli\nfrom fractions import Fraction\n[bernoulli(i).as_numer_denom()[0] for i in range(51)]  \n"}
{"sequence_id": "A027641", "text": "Numerator of Bernoulli number B_n.", "sequence": "1,-1,1,0,-1,0,1,0,-1,0,5,0,-691,0,7,0,-3617,0,43867,0,-174611,0,854513,0,-236364091,0,8553103,0,-23749461029,0,8615841276005,0,-7709321041217,0,2577687858367,0,-26315271553053477373,0,2929993913841559,0,-261082718496449122051", "code": "\nfrom sympy import bernoulli\ndef A027641(n): return bernoulli(n).p\nprint([A027641(n) for n in range(80)])  \n"}
{"sequence_id": "A027642", "text": "Denominator of Bernoulli number B_n.", "sequence": "1,2,6,1,30,1,42,1,30,1,66,1,2730,1,6,1,510,1,798,1,330,1,138,1,2730,1,6,1,870,1,14322,1,510,1,6,1,1919190,1,6,1,13530,1,1806,1,690,1,282,1,46410,1,66,1,1590,1,798,1,870,1,354,1,56786730,1", "code": "\nfrom sympy import bernoulli\n[bernoulli(i).denominator() for i in range(51)] \n"}
{"sequence_id": "A027697", "text": "Odious primes: primes with odd number of 1's in binary expansion.", "sequence": "2,7,11,13,19,31,37,41,47,59,61,67,73,79,97,103,107,109,127,131,137,151,157,167,173,179,181,191,193,199,211,223,227,229,233,239,241,251,271,283,307,313,331,367,379,397,409,419,421,431,433,439,443,457,463,487,491,499,521,541,557,563", "code": "\nfrom sympy import primerange\nprint([n for n in primerange(1, 1001) if bin(n)[2:].count(\"1\")%2]) \n"}
{"sequence_id": "A027748", "text": "Irregular triangle in which first row is 1, n-th row (n > 1) lists distinct prime factors of n.", "sequence": "1,2,3,2,5,2,3,7,2,3,2,5,11,2,3,13,2,7,3,5,2,17,2,3,19,2,5,3,7,2,11,23,2,3,5,2,13,3,2,7,29,2,3,5,31,2,3,11,2,17,5,7,2,3,37,2,19,3,13,2,5,41,2,3,7,43,2,11,3,5,2,23,47,2,3,7,2,5,3,17,2,13,53,2,3,5,11,2,7,3,19,2,29,59,2,3,5,61,2,31", "code": "\nfrom sympy import primefactors\nfor n in range(2, 101):\n    print([i for i in primefactors(n)]) \n"}
{"sequence_id": "A027750", "text": "Triangle read by rows in which row n lists the divisors of n.", "sequence": "1,1,2,1,3,1,2,4,1,5,1,2,3,6,1,7,1,2,4,8,1,3,9,1,2,5,10,1,11,1,2,3,4,6,12,1,13,1,2,7,14,1,3,5,15,1,2,4,8,16,1,17,1,2,3,6,9,18,1,19,1,2,4,5,10,20,1,3,7,21,1,2,11,22,1,23,1,2,3,4,6,8,12,24,1,5,25,1,2,13,26,1,3,9,27,1,2,4,7,14,28,1,29", "code": "\nfrom sympy import divisors\nfor n in range(1, 16):\n    print(divisors(n)) \n"}
{"sequence_id": "A027751", "text": "Irregular triangle read by rows in which row n lists the proper divisors of n (those divisors of n which are < n), with the first row {1} by convention.", "sequence": "1,1,1,1,2,1,1,2,3,1,1,2,4,1,3,1,2,5,1,1,2,3,4,6,1,1,2,7,1,3,5,1,2,4,8,1,1,2,3,6,9,1,1,2,4,5,10,1,3,7,1,2,11,1,1,2,3,4,6,8,12,1,5,1,2,13,1,3,9,1,2,4,7,14,1,1,2,3,5,6,10,15,1,1,2,4,8,16,1,3,11,1,2,17,1,5,7,1,2,3,4,6,9,12,18", "code": "\nfrom sympy import divisors\ndef a(n): return [1] if n==1 else divisors(n)[:-1]\nfor n in range(21): print(a(n)) \n"}
{"sequence_id": "A027854", "text": "Mutinous numbers: n>1 such that n/p^k > p, where p is the largest prime dividing n and p^k is the highest power of p dividing n.", "sequence": "12,24,30,36,40,45,48,56,60,63,70,72,80,84,90,96,105,108,112,120,126,132,135,140,144,150,154,160,165,168,175,176,180,182,189,192,195,198,200,208,210,216,220,224,225,231,234,240,252,260,264,270,273,275,280", "code": "\nfrom sympy import factorint, primefactors\ndef a053585(n):\n    if n==1: return 1\n    p = primefactors(n)[-1]\n    return p**factorint(n)[p]\nprint([n for n in range(2, 301) if n>a053585(n)*primefactors(n)[-1]]) \n"}
{"sequence_id": "A027855", "text": "Antimutinous numbers: n>1 such that n/p^k < p, where p is the largest prime dividing n and p^k is the highest power of p dividing n.", "sequence": "2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,18,19,20,21,22,23,25,26,27,28,29,31,32,33,34,35,37,38,39,41,42,43,44,46,47,49,50,51,52,53,54,55,57,58,59,61,62,64,65,66,67,68,69,71,73,74,75,76,77,78,79,81,82,83,85,86,87", "code": "\nfrom sympy import factorint, primefactors\ndef a053585(n):\n    if n==1: return 1\n    p = primefactors(n)[-1]\n    return p**factorint(n)[p]\nprint([n for n in range(2, 301) if n//a053585(n)<primefactors(n)[-1]]) \n"}
{"sequence_id": "A027864", "text": "Primes of the form k^2 + (k+1)^2 + (k+2)^2.", "sequence": "5,29,149,509,677,1877,3677,8429,9749,11909,13469,17789,22709,27077,28229,45389,46877,53069,70229,72077,81677,100469,102677,114077,128549,141269,154589,180077,192029,195077,207509,223589,230189,261077,312989,340709", "code": "\nfrom sympy import isprime\nprint(list(filter(isprime, (3*k**2+6*k+5 for k in range(350))))) \n"}
{"sequence_id": "A027868", "text": "Number of trailing zeros in n!; highest power of 5 dividing n!.", "sequence": "0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,6,6,6,6,6,7,7,7,7,7,8,8,8,8,8,9,9,9,9,9,10,10,10,10,10,12,12,12,12,12,13,13,13,13,13,14,14,14,14,14,15,15,15,15,15,16,16,16,16,16,18,18,18,18,18,19", "code": "\nfrom sympy import multiplicity\nA027868, p5 = [0,0,0,0,0], 0\nfor n in range(5,10**3,5):\n    p5 += multiplicity(5,n)\n    A027868.extend([p5]*5) \n"}
{"sequence_id": "A027868", "text": "Number of trailing zeros in n!; highest power of 5 dividing n!.", "sequence": "0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,6,6,6,6,6,7,7,7,7,7,8,8,8,8,8,9,9,9,9,9,10,10,10,10,10,12,12,12,12,12,13,13,13,13,13,14,14,14,14,14,15,15,15,15,15,16,16,16,16,16,18,18,18,18,18,19", "code": "\ndef A027868(n): return 0 if n<5 else n//5 + A027868(n//5) \n"}
{"sequence_id": "A027870", "text": "Number of zeros in 2^n.", "sequence": "0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,1,1,2,3,1,1,1,1,1,0,1,0,2,3,2,2,2,1,1,2,2,3,2,2,2,1,1,0,1,3,3,1,0,1,1,1,0,0,2,4,2,0,2,3,1,1,0,3,5,3,3,4,2,3,4,1,1,4,5,5,6,6,7,5,5", "code": "\ndef A027870(n):\n    return str(2**n).count('0') \n"}
{"sequence_id": "A028233", "text": "If n = p_1^e_1 * ... * p_k^e_k, p_1 < ... < p_k primes, then a(n) = p_1^e_1, with a(1) = 1.", "sequence": "1,2,3,4,5,2,7,8,9,2,11,4,13,2,3,16,17,2,19,4,3,2,23,8,25,2,27,4,29,2,31,32,3,2,5,4,37,2,3,8,41,2,43,4,9,2,47,16,49,2,3,4,53,2,5,8,3,2,59,4,61,2,9,64,5,2,67,4,3,2,71,8,73,2,3,4,7,2,79,16,81,2,83,4,5,2", "code": "\nfrom sympy import factorint\ndef a(n):\n    f = factorint(n)\n    return 1 if n==1 else min(f)**f[min(f)] \n"}
{"sequence_id": "A028234", "text": "If n = p_1^e_1 * ... * p_k^e_k, p_1 < ... < p_k primes, then a(n) = n/p_1^e_1, with a(1) = 1.", "sequence": "1,1,1,1,1,3,1,1,1,5,1,3,1,7,5,1,1,9,1,5,7,11,1,3,1,13,1,7,1,15,1,1,11,17,7,9,1,19,13,5,1,21,1,11,5,23,1,3,1,25,17,13,1,27,11,7,19,29,1,15,1,31,7,1,13,33,1,17,23,35,1,9,1,37,25,19,11,39,1,5,1,41,1,21", "code": "\nfrom sympy import factorint\ndef a(n):\n    f = factorint(n)\n    return 1 if n==1 else n/(min(f)**f[min(f)]) \n"}
{"sequence_id": "A028259", "text": "Engel expansion of the golden ratio, (1 + sqrt(5))/2 = 1.61803... .", "sequence": "1,2,5,6,13,16,16,38,48,58,104,177,263,332,389,4102,4575,5081,9962,18316,86613,233239,342534,964372,1452850,7037119,7339713,8270361,12855437,15900982,19211148,1365302354,1565752087,1731612283", "code": "\nj = 0\nwhile j<3100000:\n\n....if j == 0:\n........p0,q0 = 1,1\n....elif j == 1:\n........p1,q1 = p0+1,1\n....else:\n........p0,p1 = p1,p1+p0\n........q0,q1 = q1,q1+q0\n....j = j+1\ni = 0\nwhile i < 2410:\n....i = i+1\n....a = q0//p0+1\n....print(i,a)\n....p0 = a*p0-q0\n\n"}
{"sequence_id": "A028326", "text": "Twice Pascal's triangle A007318: T(n,k) = 2*C(n,k).", "sequence": "2,2,2,2,4,2,2,6,6,2,2,8,12,8,2,2,10,20,20,10,2,2,12,30,40,30,12,2,2,14,42,70,70,42,14,2,2,16,56,112,140,112,56,16,2,2,18,72,168,252,252,168,72,18,2,2,20,90,240,420,504,420,240,90,20,2,2,22,110,330,660,924,924,660,330,110,22,2", "code": "\nfrom sympy import binomial\ndef T(n, k):\n    return 2*binomial(n, k)\nfor n in range(21): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A028337", "text": "Palindromes of form n(n+1).", "sequence": "2,6,272,6006,289982,2629262,6039306,27999972,28233282,2704884072,20278187202,20591819502,2592587852952,2936231326392,21809166190812,27237788773272,229145919541922,233552101255332,250087292780052,2243922442293422,2570769009670752,20333113431133302,27785925652958772", "code": "\nA028337_list, n = [], 0\nfor i in range(2,10**6,2):\n....n += i\n....s = str(n)\n....if s == s[::-1]:\n........A028337_list.append(n) \n"}
{"sequence_id": "A028361", "text": "Number of totally isotropic spaces of index n in orthogonal geometry of dimension 2n.", "sequence": "1,2,6,30,270,4590,151470,9845550,1270075950,326409519150,167448083323950,171634285407048750,351678650799042888750,1440827432323678715208750,11804699153027899713705288750,193419995622362136809061156168750", "code": "\nfor n in range(2,50,2):\n  product = 1\n  for i in range(0,n//2-2 + 1):\n    product *= (2**i+1)\n  print(product)\n\n"}
{"sequence_id": "A028363", "text": "Total number of doubly-even self-dual binary codes of length 8n.", "sequence": "1,30,9845550,171634285407048750,193419995622362136809061156168750,14272693289804307141953423466197932293533748208968750", "code": "\nfor n in range(8, 50, 8):\n    product = 1\n    for i in range(n//2 - 1):\n        product *= 2**i + 1\n    print(product, end=\", \")\n\n"}
{"sequence_id": "A028374", "text": "Curved numbers: numbers that have only curved digits (0, 2, 3, 5, 6, 8, 9).", "sequence": "0,2,3,5,6,8,9,20,22,23,25,26,28,29,30,32,33,35,36,38,39,50,52,53,55,56,58,59,60,62,63,65,66,68,69,80,82,83,85,86,88,89,90,92,93,95,96,98,99,200,202,203,205,206,208,209,220,222,223,225,226,228,229,230,232,233", "code": "\nfor n in range(10**3):\n..s = str(n)\n..if not (s.count('1') + s.count('4') + s.count('7')):\n....print(n,end=', ') \n"}
{"sequence_id": "A028393", "text": "Iterate the map in A006368 starting at 8.", "sequence": "8,12,18,27,20,30,45,34,51,38,57,43,32,48,72,108,162,243,182,273,205,154,231,173,130,195,146,219,164,246,369,277,208,312,468,702,1053,790,1185,889,667,500,750,1125,844,1266,1899,1424,2136,3204,4806,7209,5407", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef F(n):\n    if n == 0: return 8\n    elif 3*F(n-1)%2 == 0: return 3*F(n-1)//2\n    else: return (3*F(n-1)+1)//4\nprint([F(i) for i in range(81)]) \n"}
{"sequence_id": "A028553", "text": "Numbers k such that k*(k+3) is a palindrome.", "sequence": "0,1,8,28,66,88,211,298,671,2126,2998,28814,29369,29998,63701,212206,212671,299998,636776,2122206,2861419,2999998,9443423,21341691,28862883,29999998,212325206,289053683,294127328,294174669,299999998,2134473706,2946920844,2999999998", "code": "\nn, m, A028553_list = 0, 0, []\nwhile n < 10**12:\n    s = str(m)\n    if s == s[::-1]:\n        A028553_list.append(n)\n    m += 2*(n+2)\n    n += 1 \n"}
{"sequence_id": "A028554", "text": "Palindromes of form n(n+3).", "sequence": "0,4,88,868,4554,8008,45154,89698,452254,4526254,8996998,830333038,862626268,899969998,4058008504,45032023054,45229592254,89999699998,405485584504,4503764673054,8187727277818,8999996999998,89178266287198,455467838764554,833066101660338", "code": "\nn, m, A028554_list = 4, 0, []\nwhile n < 10**12:\n    s = str(m)\n    if s == s[::-1]:\n        A028554_list.append(m)\n    m += n\n    n += 2 \n"}
{"sequence_id": "A028819", "text": "Numbers whose square has its digits in nondecreasing order.", "sequence": "0,1,2,3,4,5,6,7,12,13,15,16,17,34,35,37,38,67,83,106,107,116,117,167,183,334,335,337,367,383,587,667,1633,1667,3334,3335,3337,3367,3383,3667,4833,6667,16667,33334,33335,33337,33367,33667,36667,66667", "code": "\nfrom itertools import combinations_with_replacement\nfrom gmpy2 import is_square, isqrt\nA028819_list = [0] + [int(isqrt(n)) for n in (int(''.join(i)) for l in range(1,11) for i in combinations_with_replacement('123456789',l)) if is_square(n)] \n"}
{"sequence_id": "A028820", "text": "Squares with digits in nondecreasing order.", "sequence": "0,1,4,9,16,25,36,49,144,169,225,256,289,1156,1225,1369,1444,4489,6889,11236,11449,13456,13689,27889,33489,111556,112225,113569,134689,146689,344569,444889,2666689,2778889,11115556,11122225,11135569", "code": "\nfrom itertools import combinations_with_replacement\nfrom gmpy2 import is_square\nA028820_list = [0] + [n for n in (int(''.join(i)) for l in range(1,11) for i in combinations_with_replacement('123456789',l)) if is_square(n)] \n"}
{"sequence_id": "A028823", "text": "Numbers k such that k^2 + k + 17 is prime.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,18,19,21,22,23,24,26,27,28,29,30,31,35,37,38,40,42,44,45,46,47,49,53,56,57,59,60,62,63,64,70,72,73,75,76,79,81,82,86,87,91,92,95,98,103,104,108,109,110,113,114", "code": "\nfrom sympy import isprime\nprint([n for n in range(201) if isprime(n**2 + n + 17)]) \n"}
{"sequence_id": "A028834", "text": "Numbers whose sum of digits is a prime.", "sequence": "2,3,5,7,11,12,14,16,20,21,23,25,29,30,32,34,38,41,43,47,49,50,52,56,58,61,65,67,70,74,76,83,85,89,92,94,98,101,102,104,106,110,111,113,115,119,120,122,124,128,131,133,137,139,140,142,146,148,151,155,157,160,164,166,173,175,179,182", "code": "\nfrom sympy import isprime\ndef ok(n): return isprime(sum(map(int, str(n))))\nprint(list(filter(ok, range(183)))) \n"}
{"sequence_id": "A028888", "text": "Smaller of two successive primes with a palindromic product.", "sequence": "2,7,17,191,1051,1934063", "code": "\nfrom sympy import nextprime\ndef ispal(n): s = str(n); return s == s[::-1]\np, q = 2, 3\nwhile True:\n  if ispal(p*q): print(p)\n  p, q = q, nextprime(q) \n"}
{"sequence_id": "A028909", "text": "Arrange digits of 2^n in ascending order.", "sequence": "1,2,4,8,16,23,46,128,256,125,124,248,469,1289,13468,23678,35566,11237,122446,224588,145678,122579,134449,368888,11266777,23334455,1466788,112234778,234455668,12356789,112344778,1234446788,2244667999", "code": "\ndef A028909(n):\n    return int(''.join(sorted(str(2**n)))) \n"}
{"sequence_id": "A028910", "text": "Arrange digits of 2^n in descending order.", "sequence": "1,2,4,8,61,32,64,821,652,521,4210,8420,9640,9821,86431,87632,66553,732110,644221,885422,8765410,9752210,9444310,8888630,77766211,55443332,88766410,877432211,866554432,987653210,8774432110,8876444321", "code": "\ndef A028910(n):\n    return int(''.join(sorted(str(2**n),reverse=True))) \n"}
{"sequence_id": "A028978", "text": "Product of prime and previous prime is palindromic.", "sequence": "3,11,19,193,1061,1934071", "code": "\nfrom sympy import nextprime\ndef ispal(n): s = str(n); return s == s[::-1]\ndef aupto(lim):\n  prevp, p, alst = 2, 3, []\n  while p < lim:\n    if ispal(p * prevp): alst.append(p)\n    prevp, p = p, nextprime(p)\n  return alst\nprint(aupto(2*10**6)) \n"}
{"sequence_id": "A029455", "text": "Numbers k that divide the (right) concatenation of all numbers <= k written in base 10 (most significant digit on left).", "sequence": "1,2,3,5,6,9,10,12,15,18,20,25,27,30,36,45,50,54,60,69,75,90,100,108,120,125,135,150,162,180,200,216,225,248,250,270,300,324,360,375,405,450,470,500,540,558,600,648,675,710,750,810,900,1000,1053,1080,1116", "code": "\nA029455_list, r = [], 0\nfor n in range(1,10**6+1):\n....r = r*10**len(str(n))+n\n....if not (r % n):\n........A029455_list.append(n) \n"}
{"sequence_id": "A029471", "text": "Numbers k that divide the (left) concatenation of all numbers <= k written in base 2 (most significant digit on left).", "sequence": "1,85,145,245,1189,356717,19590671,35741759", "code": "\nfrom itertools import count\ndef a029471():\n    total = 0\n    power_of_two = 1\n    index_of_two = 0\n    length_of_string = 0\n    for n in count(1):\n        total += (n<<length_of_string)\n        if n == power_of_two:\n            power_of_two *= 2\n            index_of_two += 1\n        length_of_string += index_of_two\n        if total % n == 0:\n            yield n\n\n"}
{"sequence_id": "A029653", "text": "Numbers in (2,1)-Pascal triangle (by row).", "sequence": "1,2,1,2,3,1,2,5,4,1,2,7,9,5,1,2,9,16,14,6,1,2,11,25,30,20,7,1,2,13,36,55,50,27,8,1,2,15,49,91,105,77,35,9,1,2,17,64,140,196,182,112,44,10,1,2,19,81,204,336,378,294,156,54,11,1,2,21,100,285", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef u(n, x): return 1 if n==1 else u(n - 1, x) + x*v(n - 1, x)\ndef v(n, x): return 1 if n==1 else u(n - 1, x) + x*v(n - 1, x) + 1\ndef a(n): return Poly(v(n, x), x).all_coeffs()[::-1]\nfor n in range(1, 13): print(a(n)) \n"}
{"sequence_id": "A029731", "text": "Palindromic in bases 10 and 16.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,353,626,787,979,1991,3003,39593,41514,90209,94049,96369,98689,333333,512215,666666,749947,845548,1612161,2485842,5614165,6487846,9616169,67433476,90999909,94355349,94544549,119919911", "code": "\ndef palQ16(n): \n    s = hex(n)[2:]\n    return s == s[::-1]\ndef palQgen10(l): \n    if l > 0:\n        yield 0\n        for x in range(1,10**l):\n            s = str(x)\n            yield int(s+s[-2::-1])\n            yield int(s+s[::-1])\nA029731_list = sorted([n for n in palQgen10(6) if palQ16(n)])\n\n"}
{"sequence_id": "A029732", "text": "Palindromic primes in base 16 (or hexadecimal), but written here in base 10.", "sequence": "2,3,5,7,11,13,17,257,337,353,401,433,449,787,883,947,1301,1381,1429,1493,1831,1847,1879,2039,2377,2393,2441,2473,2521,2843,2939,2971,3019,3067,3373,3389,3469,3517,3533,3581,3919,3967,4079,65537", "code": "\nfrom itertools import chain\nfrom sympy import isprime\nfrom gmpy2 import digits\nA029732 = sorted((n for n in chain((int(digits(x,16)+digits(x,16)[::-1],16) for x in range(1,16**5)),(int(digits(x,16)+digits(x,16)[-2::-1],16) for x in range(1,16**5))) if isprime(n)))\n\n"}
{"sequence_id": "A029735", "text": "Numbers k such that k^3 is palindromic in base 16.", "sequence": "0,1,2,17,257,273,4097,4369,65537,65793,69649,1048577,1052929,1114129,16777217,16781313,16843009,16847105,17825809,17829905,268435457,268505089,269484289,285212689,4294967297,4295032833,4296019969,4296085505,4311744769,4563402769", "code": "\nA029735_list, j = [], 0\nfor i in range(10**9):\n    s = format(j,'x')\n    if s == s[::-1]:\n        A029735_list.append(i)\n    j += 3*i*(i+1)+1 \n"}
{"sequence_id": "A029736", "text": "Palindromic cubes in base 16.", "sequence": "0,1,8,4913,16974593,20346417,68769820673,83396175409,281487861809153,284799399232257,337866128966449,1152924803144876033,1167339716607161089,1382949865068368689,4722367327294625677313,4725826936714463031297,4778141888650615849729", "code": "\nA029736_list, j = [], 0\nfor i in range(10**9):\n    s = format(j,'x')\n    if s == s[::-1]:\n        A029736_list.append(j)\n    j += 3*i*(i+1)+1 \n"}
{"sequence_id": "A029742", "text": "Nonpalindromic numbers.", "sequence": "10,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,34,35,36,37,38,39,40,41,42,43,45,46,47,48,49,50,51,52,53,54,56,57,58,59,60,61,62,63,64,65,67,68,69,70,71,72,73,74,75,76,78,79,80,81,82,83,84,85,86,87,89,90,91,92,93,94,95,96,97,98,100,102,103,104,105,106,107", "code": "\ndef ok(n): s = str(n); return s != s[::-1]\nprint(list(filter(ok, range(108)))) \n"}
{"sequence_id": "A029790", "text": "None of the digits in n is present in n^2 or n^3.", "sequence": "2,3,7,8,22,47,53,77,92,157,187,188,192,552,558,577,707,772,922,2522,8338,17177,66888,575757,929522,1717177,8888588", "code": "\ndef a(n):\n..s = str(n)\n..s2 = str(n**2)\n..s3 = str(n**3)\n..count = 0\n..for i in s:\n....if s2.count(i) == 0 and s3.count(i) == 0:\n......count += 1\n....else:\n......break\n..if count == len(s):\n....return True\nn = 1\nwhile n < 10**9:\n..if a(n):\n....print(n,end=', ')\n..n += 1\n\n"}
{"sequence_id": "A029804", "text": "Numbers that are palindromic in bases 8 and 10.", "sequence": "0,1,2,3,4,5,6,7,9,121,292,333,373,414,585,3663,8778,13131,13331,26462,26662,30103,30303,207702,628826,660066,1496941,1935391,1970791,4198914,55366355,130535031,532898235,719848917,799535997,1820330281", "code": "\ndef palQ8(n): \n    s = oct(n)[2:]\n    return s == s[::-1]\ndef palQgen10(l): \n    if l > 0:\n        yield 0\n        for x in range(1,10**l):\n            s = str(x)\n            yield int(s+s[-2::-1])\n            yield int(s+s[::-1])\nA029804_list = sorted([n for n in palQgen10(6) if palQ8(n)])\n\n"}
{"sequence_id": "A029837", "text": "Binary order of n: log_2(n) rounded up to next integer.", "sequence": "0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7", "code": "\ndef A029837(n):\n    s = bin(n)[2:]\n    return len(s) - (1 if s.count('1') == 1 else 0) \n"}
{"sequence_id": "A029954", "text": "Palindromic in base 7.", "sequence": "0,1,2,3,4,5,6,8,16,24,32,40,48,50,57,64,71,78,85,92,100,107,114,121,128,135,142,150,157,164,171,178,185,192,200,207,214,221,228,235,242,250,257,264,271,278,285,292,300,307,314,321,328,335,342,344,400,456", "code": "\nfrom gmpy2 import digits\ndef palQgen(l,b): \n    if l > 0:\n        yield 0\n        for x in range(1,l+1):\n            for y in range(b**(x-1),b**x):\n                s = digits(y,b)\n                yield int(s+s[-2::-1],b)\n            for y in range(b**(x-1),b**x):\n                s = digits(y,b)\n                yield int(s+s[::-1],b)\nA029954_list = list(palQgen(4,7)) \n"}
{"sequence_id": "A029955", "text": "Palindromic in base 9.", "sequence": "0,1,2,3,4,5,6,7,8,10,20,30,40,50,60,70,80,82,91,100,109,118,127,136,145,154,164,173,182,191,200,209,218,227,236,246,255,264,273,282,291,300,309,318,328,337,346,355,364,373,382,391,400,410,419,428,437", "code": "\nfrom gmpy2 import digits\ndef palQgen(l,b): \n    if l > 0:\n        yield 0\n        for x in range(1,l+1):\n            for y in range(b**(x-1),b**x):\n                s = digits(y,b)\n                yield int(s+s[-2::-1],b)\n            for y in range(b**(x-1),b**x):\n                s = digits(y,b)\n                yield int(s+s[::-1],b)\nA029955_list = list(palQgen(4,9)) \n"}
{"sequence_id": "A029967", "text": "Palindromic in bases 12 and 10.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,181,555,616,676,737,797,1111,8008,35953,43934,88888,646646,3192913,5641465,8364638,9963699,133373331,139979931,293373392,520020025,713171317,796212697,1393223931", "code": "\nfrom gmpy2 import digits\ndef palQ(n,b): \n    s = digits(n,b)\n    return s == s[::-1]\ndef palQgen10(l): \n    if l > 0:\n        yield 0\n        for x in range(1,l+1):\n            for y in range(10**(x-1),10**x):\n                s = str(y)\n                yield int(s+s[-2::-1])\n            for y in range(10**(x-1),10**x):\n                s = str(y)\n                yield int(s+s[::-1])\nA029967_list = [n for n in palQgen10(5) if palQ(n,12)] \n"}
{"sequence_id": "A029968", "text": "Palindromic in bases 13 and 10.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,222,313,353,444,575,666,797,1111,6776,8778,24542,25452,26362,56265,311113,2377732,2713172,2832382,2906092,8864688,10122101,13055031,20244202,20944902,23177132,23877832", "code": "\nfrom gmpy2 import digits\ndef palQ(n,b): \n    s = digits(n,b)\n    return s == s[::-1]\ndef palQgen10(l): \n    if l > 0:\n        yield 0\n        for x in range(1,l+1):\n            for y in range(10**(x-1),10**x):\n                s = str(y)\n                yield int(s+s[-2::-1])\n            for y in range(10**(x-1),10**x):\n                s = str(y)\n                yield int(s+s[::-1])\nA029968_list = [n for n in palQgen10(9) if palQ(n,13)]\n\n"}
{"sequence_id": "A029976", "text": "Palindromic primes in base 8.", "sequence": "2,3,5,7,73,89,97,113,211,227,251,349,373,463,479,487,503,4289,4481,4937,5393,5521,5657,5849,6761,7537,7993,12547,12611,12739,13003,13259,13331,13523,14107,14563,14627,14891,15083,15667,15731,15859", "code": "\nfrom itertools import chain\nfrom sympy import isprime\nfrom gmpy2 import digits\nA029976 = sorted((n for n in chain((int(digits(x,8)+digits(x,8)[::-1],8) for x in range(1,8**6)),(int(digits(x,8)+digits(x,8)[-2::-1],8) for x in range(1,8**6))) if isprime(n)))\n\n"}
{"sequence_id": "A029997", "text": "Squares which are palindromes in base 11.", "sequence": "0,1,4,9,36,144,576,676,5184,7056,14884,17689,20736,59536,65025,77841,145924,535824,1774224,2143296,2547216,5827396,7096896,7817616,9375844,20034576,63872064,214388164,217946169,221533456,255488256,259371025", "code": "\nfrom gmpy2 import digits\nA029997_list = [n for n in (x**2 for x in range(10**7)) if digits(n,11) == digits(n,11)[::-1]]\n\n"}
{"sequence_id": "A030000", "text": "a(n) is the smallest nonnegative number k such that the decimal expansion of 2^k contains the string n.", "sequence": "10,0,1,5,2,8,4,15,3,12,10,40,7,17,18,21,4,27,30,13,11,18,43,41,10,8,18,15,7,32,22,17,5,25,27,25,16,30,14,42,12,22,19,22,18,28,42,31,11,32,52,9,19,16,25,16,8,20,33,33,23,58,18,14,6,16,46,24,15,34,29,21,17,30", "code": "\ndef a(n):\n  k, strn = 0, str(n)\n  while strn not in str(2**k): k += 1\n  return k\nprint([a(n) for n in range(74)]) \n"}
{"sequence_id": "A030056", "text": "C(2n+1,n-6).", "sequence": "1,15,136,969,5985,33649,177100,888030,4292145,20160075,92561040,417225900,1852482996,8122425444,35240152720,151532656696,646626422970,2741188875414,11554258485616,48459472266975", "code": "\nfrom __future__ import division\nA030056_list, b = [], 1\nfor n in range(6,501):\n    A030056_list.append(b)\n    b = b*(2*n+2)*(2*n+3)//((n-5)*(n+8)) \n"}
{"sequence_id": "A030076", "text": "a(n) = 10 - m, where m = maximal digit of n.", "sequence": "9,8,7,6,5,4,3,2,1,9,9,8,7,6,5,4,3,2,1,8,8,8,7,6,5,4,3,2,1,7,7,7,7,6,5,4,3,2,1,6,6,6,6,6,5,4,3,2,1,5,5,5,5,5,5,4,3,2,1,4,4,4,4,4,4,4,3,2,1,3,3,3,3,3,3,3,3,2,1,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,9,9,8,7,6,5", "code": "\ndef a(n): return (10 - int(max(str(n))))\nprint([a(n) for n in range(1, 106)]) \n"}
{"sequence_id": "A030078", "text": "Cubes of primes.", "sequence": "8,27,125,343,1331,2197,4913,6859,12167,24389,29791,50653,68921,79507,103823,148877,205379,226981,300763,357911,389017,493039,571787,704969,912673,1030301,1092727,1225043,1295029,1442897,2048383,2248091,2571353,2685619,3307949", "code": "\nfrom sympy import prime, primerange\ndef aupton(terms): return [p**3 for p in primerange(1, prime(terms)+1)]\nprint(aupton(35)) \n"}
{"sequence_id": "A030082", "text": "a(n) = prime^3 and digits of prime appear in a(n).", "sequence": "125,1331,24389,205379,226981,300763,357911,389017,912673,1030301,1295029,2571353,3442951,6967871,12008989,12649337,15813251,22188041,30080231,36264691,38272753,41781923,58863869,64481201,90518849,101847563,124251499,158340421,237176659", "code": "\nfrom sympy import prime\nA030082_list = []\nfor i in range(1,10**6):\n    p = prime(i)\n    q = p**3\n    if set(str(p)) <= set(str(q)):\n        A030082_list.append(q) \n"}
{"sequence_id": "A030087", "text": "Primes such that digits of p do not appear in p^3.", "sequence": "2,3,7,43,47,53,157,223,263,487,577,587,823,4657,5657,6653,7177,8287,9343,26777,36293,46477,58787,72727,75707,176777,363313,530353,566653,959953,1771787,2525557,2555353,2626277,3656363,4414447,7110707,8448343,20700077,54475457,71117177,72722977,135135113,393321293,457887457,505053053,672722627", "code": "\nfrom sympy import isprime\nA030087_list = [n for n in range(1,10**6) if set(str(n)) & set(str(n**3)) == set() and isprime(n)]\n\n"}
{"sequence_id": "A030098", "text": "Squares whose digits are all even.", "sequence": "0,4,64,400,484,4624,6084,6400,8464,26244,28224,40000,40804,48400,68644,88804,228484,242064,248004,446224,462400,608400,640000,806404,824464,846400,868624,2022084,2226064,2244004,2624400,2822400,2862864,4000000,4008004,4080400", "code": "\nfrom math import sqrt\ndef ok(sq): return all(d in \"02468\" for d in str(sq))\ndef aupto(limit):\n  sqs = (i*i for i in range(0, isqrt(limit)+1, 2))\n  return list(filter(ok, sqs))\nprint(aupto(4080400)) \n"}
{"sequence_id": "A030101", "text": "a(n) is the number produced when n is converted to binary digits, the binary digits are reversed and then converted back into a decimal number.", "sequence": "0,1,1,3,1,5,3,7,1,9,5,13,3,11,7,15,1,17,9,25,5,21,13,29,3,19,11,27,7,23,15,31,1,33,17,49,9,41,25,57,5,37,21,53,13,45,29,61,3,35,19,51,11,43,27,59,7,39,23,55,15,47,31,63,1,65,33,97,17,81,49,113,9,73,41,105,25,89,57", "code": "\ndef a(n): return int(bin(n)[2:][::-1], 2) \n"}
{"sequence_id": "A030166", "text": "Number of strokes in Chinese characters for n; also number of strokes in Japanese kanji characters for n.", "sequence": "13,1,2,3,5,4,4,2,2,2,2,3,4,5,7,6,6,4,4,4,4,5,6,7,9,8,8,6,6,6,5,6,7,8,10,9,9,7,7,7,7,8,9,10,12,11,11,9,9,9,6,7,8,9,11,10,10,8,8,8,6,7,8,9,11,10,10,8,8,8,4,5,6,7,9,8,8,6,6,6,4,5,6,7,9,8,8,6,6,6,4,5,6,7,9,8,8,6,6,6,7", "code": "\nfrom num2words import num2words\ndef A030166(n):\n    kanji=['\u4e00','\u4e8c','\u4e09','\u56db','\u4e94','\u516d','\u4e03','\u516b','\u4e5d','\u5341','\u767e','\u5343','\u4e07','\u5104','\u5146','\u4eac','\u5793','\u79ed','\u7a63','\u6e9d','\u6f97','\u6b63','\u8f09','\u6975','\u96f6']\n    strokes=[1,2,3,5,4,4,2,2,2,2,6,3,3,15,6,8,9,10,18,13,15,5,13,12,13]\n    return sum([strokes[kanji.index(i)] for i in num2words(n, lang='ja')]) \n"}
{"sequence_id": "A030292", "text": "Numbers k such that k^3 has at most two different digits.", "sequence": "0,1,2,3,4,7,10,11,20,100,200,1000,2000,10000,20000,100000,200000,1000000,2000000,10000000,20000000,100000000,200000000,1000000000,2000000000,10000000000,20000000000", "code": "\nA030292_list, m = [0], [6, -6, 1, 0]\nfor n in range(1,10**6+1):\n    for i in range(3):\n        m[i+1] += m[i]\n    if len(set(str(m[-1]))) <= 2:\n        A030292_list.append(n) \n"}
{"sequence_id": "A030299", "text": "Decimal representation of permutations of lengths 1, 2, 3, ... arranged lexicographically.", "sequence": "1,12,21,123,132,213,231,312,321,1234,1243,1324,1342,1423,1432,2134,2143,2314,2341,2413,2431,3124,3142,3214,3241,3412,3421,4123,4132,4213,4231,4312,4321,12345,12354,12435,12453,12534,12543,13245,13254,13425", "code": "\nfrom itertools import permutations\ndef pmap(s, m): return sum(s[i-1]*10**(m-i) for i in range(1, len(s)+1))\ndef agen():\n  m = 1\n  while True:\n    for s in permutations(range(1, m+1)): yield pmap(s, m)\n    m += 1\ndef aupton(terms):\n  alst, g = [], agen()\n  while len(alst) < terms: alst += [next(g)]\n  return alst\nprint(aupton(42)) \n"}
{"sequence_id": "A030308", "text": "Triangle T(n, k): Write n in base 2, reverse order of digits, to get the n-th row.", "sequence": "0,1,0,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,1,1,0,1", "code": " for n in range(20): print([int(z) for z in str(bin(n)[2:])[::-1]]) \n"}
{"sequence_id": "A030482", "text": "Primes with property that when cubed all even digits occur together and all odd digits occur together.", "sequence": "2,3,11,13,17,19,31,59,71,131,137,173,179,211,293,359,431,439,587,659,1277,4057,6379,13093,13537,15877,25799,28753,29173,36493,39293,39719,40013,60919,66071,69491,73681,87491,126011,137507,138599,189491,199831,201673", "code": "\nfrom sympy import primerange\nfrom itertools import groupby\ndef ok(n): return len([k for k, g in groupby([int(d in \"13579\") for d in str(n)])]) <= 2\ndef aupto(limit): return [p for p in primerange(2, limit+1) if ok(p**3)]\nprint(aupto(201673)) \n"}
{"sequence_id": "A030656", "text": "Pair up the numbers.", "sequence": "1,23,45,67,89,1011,1213,1415,1617,1819,2021,2223,2425,2627,2829,3031,3233,3435,3637,3839,4041,4243,4445,4647,4849,5051,5253,5455,5657,5859,6061,6263,6465,6667,6869,7071,7273,7475,7677,7879,8081,8283,8485,8687,8889", "code": "\ndef a(n): return int(str(2*n)+str(2*n+1))\nprint([a(n) for n in range(45)]) \n"}
{"sequence_id": "A030665", "text": "Smallest nontrivial extension of n which is prime.", "sequence": "11,23,31,41,53,61,71,83,97,101,113,127,131,149,151,163,173,181,191,2003,211,223,233,241,251,263,271,281,293,307,311,3203,331,347,353,367,373,383,397,401,419,421,431,443,457,461,479,487,491,503,5101", "code": "\nfrom sympy import nextprime\ndef A030665(n):\n    d, nd = 10, 10*n\n    while True:\n        x = nextprime(nd)\n        if x < nd+d:\n            return int(x)\n        d *= 10\n        nd *= 10 \n"}
{"sequence_id": "A030666", "text": "Smallest nontrivial extension of n which is a square.", "sequence": "16,25,36,49,529,64,729,81,900,100,1156,121,1369,144,1521,169,1764,1849,196,2025,2116,225,2304,2401,256,2601,2704,289,2916,3025,3136,324,3364,3481,35344,361,3721,3844,3969,400,41209,4225,4356,441", "code": "\nfrom gmpy2 import isqrt\ndef A030666(n):\n    d, nd = 10, 10*n\n    while True:\n        x = (isqrt(nd-1)+1)**2\n        if x < nd+d:\n            return int(x)\n        d *= 10\n        nd *= 10 \n"}
{"sequence_id": "A030668", "text": "Smallest nontrivial extension of n which is a cube.", "sequence": "125,27,343,4096,512,64,729,8000,9261,1000,110592,125,1331,140608,15625,166375,1728,185193,19683,205379,216,226981,238328,24389,250047,262144,2744,287496,29791,300763,314432,32768,3375,343,35937", "code": "\nfrom gmpy2 import iroot\ndef A030668(n):\n    d, nd = 10, 10*n\n    while True:\n        x = (iroot(nd-1,3)[0]+1)**3\n        if x < nd+d:\n            return int(x)\n        d *= 10\n        nd *= 10 \n"}
{"sequence_id": "A030688", "text": "Smallest nontrivial extension of n-th square which is a square not ending 00.", "sequence": "16,49,961,169,256,361,49284,64009,81225,100489,121104,1444,169744,196249,225625,256036,289444,3249,361201,400689,4414201,484416,529984,576081,625681,6765201,729316,784996,8415801,900601,9616201", "code": "\nfrom gmpy2 import isqrt\ndef A030688(n):\n    d, nd = 10, 10*n**2\n    while True:\n        x = isqrt(nd-1)+1\n        if not x % 10:\n            x += 1\n        x = x**2\n        if x < nd+d:\n            return int(x)\n        d *= 10\n        nd *= 10 \n"}
{"sequence_id": "A030690", "text": "Smallest nontrivial extension of n-th square which is a cube.", "sequence": "125,4096,9261,166375,250047,3652264,4913,64000,8120601,1000,12167,1442897,16974593,19683,225866529,25672375,28934443,3241792,3616805375,40001688,4410944,4843965888,529475129,5764224257", "code": "\nfrom gmpy2 import iroot\ndef A030690(n):\n    d, nd = 10, 10*n**2\n    while True:\n        x = (iroot(nd-1,3)[0]+1)**3\n        if x < nd+d:\n            return int(x)\n        d *= 10\n        nd *= 10 \n"}
{"sequence_id": "A030697", "text": "Smallest nontrivial extension of n-th cube which is a cube not ending 000.", "sequence": "125,85184,2744,6434856,1259712,2161700757,34328125,5124031424,7290099019,10007873875,13312053,172808693,21975528401,274498269499,337589698347,409675763483,491355848971,58320792152,68593724400375", "code": "\nfrom gmpy2 import iroot\ndef A030697(n):\n    d, nd = 10, 10*n**3\n    while True:\n        x = iroot(nd-1,3)[0]+1\n        if not x % 10:\n            x += 1\n        x = x**3\n        if x < nd+d:\n            return int(x)\n        d *= 10\n        nd *= 10 \n"}
{"sequence_id": "A031172", "text": "a(n) = prime(n+10) - prime(n).", "sequence": "29,34,36,36,36,40,42,42,44,42,42,42,42,46,50,48,44,46,42,42,54,52,54,50,52,50,54,56,58,60,52,50,54,54,48,48,54,60,60,56,54,58,50,58,60,64,58,48,50,52,50,54,66,60,56,54,62,66,70,68,70,66,60,62,66,66,58", "code": "\nfrom sympy import prime\nfor n in range(1,100): print(prime(n+10)-prime(n)) \n"}
{"sequence_id": "A031286", "text": "Additive persistence: number of summations of digits needed to obtain a single digit (the additive digital root).", "sequence": "0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,2,2,2,1,1,1,1,1,1,2,2,2,2,1,1,1,1,1,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2", "code": "\ndef A031286(n):\n    ap = 0\n    while n > 9:\n        n = sum(int(d) for d in str(n))\n        ap += 1\n    return ap\n\n"}
{"sequence_id": "A031346", "text": "Multiplicative persistence: number of iterations of \"multiply digits\" needed to reach a number < 10.", "sequence": "0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,2,2,2,2,2,3,1,1,1,2,2,2,2,3,2,3,1,1,2,2,2,3,2,3,2,3,1,1,2,2,2,2,3,2,3,3,1,1,2,2,3,3,2,4,3,3,1,1,2,2,2,2,3,3,3,3,1,1,2,3,3,3,3,3,3,2", "code": "\nfrom operator import mul\nfrom functools import reduce\ndef A031346(n):\n    mp = 0\n    while n > 9:\n        n = reduce(mul, (int(d) for d in str(n)))\n        mp += 1\n    return mp\n\n"}
{"sequence_id": "A031347", "text": "Multiplicative digital root of n (keep multiplying digits of n until reaching a single digit).", "sequence": "0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,2,4,6,8,0,2,4,6,8,0,3,6,9,2,5,8,2,8,4,0,4,8,2,6,0,8,6,6,8,0,5,0,5,0,0,0,5,0,0,0,6,2,8,8,0,8,8,6,0,0,7,4,2,6,5,8,8,0,8,0,8,6,8,6,0,6", "code": "\nfrom operator import mul\nfrom functools import reduce\ndef A031347(n):\n    while n > 9:\n       n = reduce(mul, (int(d) for d in str(n)))\n    return n\n\n"}
{"sequence_id": "A031415", "text": "Numbers k such that the continued fraction for sqrt(k) has odd period and if the last term of the periodic part is deleted then there are a pair of central terms both equal to 2.", "sequence": "41,61,113,130,181,202,265,269,313,317,394,421,458,586,613,617,685,697,761,773,853,925,929,937,986,1013,1066,1109,1117,1201,1213,1301,1325,1354,1409,1417,1429,1466,1586,1625,1637,1649,1714,1741,1745,1753,1861", "code": "\nfrom sympy.ntheory.continued_fraction import continued_fraction_periodic\nA031415_list = []\nfor n in range(1,10**3):\n    cf = continued_fraction_periodic(0,1,n)\n    if len(cf) > 1 and len(cf[1]) > 1 and len(cf[1]) % 2 and cf[1][len(cf[1])//2] == 2:\n        A031415_list.append(n) \n"}
{"sequence_id": "A031423", "text": "Numbers k such that the continued fraction for sqrt(k) has odd period and if the last term of the periodic part is deleted then there are a pair of central terms both equal to 10.", "sequence": "701,1418,1493,2197,2290,3257,4793,6154,6466,8389,8753,9577,9965,10765,11257,11677,12541,14218,14929,15413,15658,16001,16501,17009,17786,18049,18314,18581,19121,21577,22157,22745,24557,24677,25805,26561,27530,28517", "code": "\nfrom sympy.ntheory.continued_fraction import continued_fraction_periodic\nA031423_list = []\nfor n in range(1,10**4):\n    cf = continued_fraction_periodic(0,1,n)\n    if len(cf) > 1 and len(cf[1]) > 1 and len(cf[1]) % 2 and cf[1][len(cf[1])//2] == 10:\n        A031423_list.append(n) \n"}
{"sequence_id": "A031443", "text": "Digitally balanced numbers: numbers that in base 2 have the same number of 0's as 1's.", "sequence": "2,9,10,12,35,37,38,41,42,44,49,50,52,56,135,139,141,142,147,149,150,153,154,156,163,165,166,169,170,172,177,178,180,184,195,197,198,201,202,204,209,210,212,216,225,226,228,232,240", "code": "\nfrom sympy.utilities.iterables import multiset_permutations\nA031443_list = [int('1'+''.join(p),2) for n in range(1,10) for p in multiset_permutations('0'*n+'1'*(n-1))] \n"}
{"sequence_id": "A031557", "text": "that the continued fraction for sqrt(k) has even period and if the last term of the periodic part is deleted the central term is 59.", "sequence": "3483,3491,3499,3511,3527,3539,3547,3559,3571,3579,3583,3587,3607,3623,3631,3643,3647,3651,3659,3667,3671,3691,3699,3707,3719,13928,13952,13960,13984,14016,14080,14120,14152,14176,14208,14216,14240,14248,14304", "code": "\nfrom __future__ import division\nfrom sympy import continued_fraction_periodic\nA031557_list = [n for n, s in ((i, continued_fraction_periodic(0,1,i)[-1]) for i in range(1,10**5)) if isinstance(s, list) and len(s) % 2 == 0 and s[len(s)//2-1] == 59] \n"}
{"sequence_id": "A031597", "text": "that the continued fraction for sqrt(k) has even period and if the last term of the periodic part is deleted the central term is 99.", "sequence": "9803,9811,9839,9843,9851,9859,9871,9883,9887,9899,9907,9923,9931,9959,9963,9967,9987,9991,10007,10019,10031,10039,10067,10079,10083,10091,10099,10103,10107,10111,10131,10139,10147,10151,10159,10163,10199,39208", "code": "\nfrom __future__ import division\nfrom sympy import continued_fraction_periodic\nA031597_list = [n for n, s in ((i, continued_fraction_periodic(0,1,i)[-1]) for i in range(1,10**5)) if isinstance(s, list) and len(s) % 2 == 0 and s[len(s)//2-1] == 99] \n"}
{"sequence_id": "A031598", "text": "that the continued fraction for sqrt(k) has even period and if the last term of the periodic part is deleted the central term is 100.", "sequence": "10002,10006,10018,10022,10046,10054,10078,10082,10086,10102,10118,10134,10146,10162,10174,10178,10182,10194,10198,10214,10226,10238,10274,10278,10294,10306,10326,10334,10338,10342,10358,10402,22503,22521,22548,22557", "code": "\nfrom __future__ import division\nfrom sympy import continued_fraction_periodic\nA031598_list = [n for n, s in ((i, continued_fraction_periodic(0,1,i)[-1]) for i in range(1,10**5)) if isinstance(s, list) and len(s) % 2 == 0 and s[len(s)//2-1] == 100] \n"}
{"sequence_id": "A031688", "text": "Numbers k such that the continued fraction for sqrt(k) has odd period and if the last term of the periodic part is deleted the two central terms are both 100.", "sequence": "2501,123953,203482,204385,206197,304825,425273,568741,726193,727898,734738,906665,1119805,1124041,1334554,1341493,1346129,1565626,1568129,1570634,1573141,1578161,1580674,1583189,1590746,1593269,1828633,2126605,2138285,2144137", "code": "\nfrom sympy import continued_fraction_periodic\nA031688_list = [n for n, s in ((i, continued_fraction_periodic(0,1,i)[-1]) for i in range(1,10**5)) if isinstance(s, list) and len(s) % 2 and s[(len(s)-1)//2] == 100] \n"}
{"sequence_id": "A031702", "text": "Numbers k such that the least term in the periodic part of the continued fraction for sqrt(k) is 24.", "sequence": "145,578,1299,2308,3605,5190,7063,9224,11673,14410,17435,20748,24349,28238,32415,36880,41633,46674,52003,57620,63525,69718,76199,82968,90025,97370,97994,105003,112924,121133,129630,138415,147488,156849,166498", "code": "\nfrom sympy import continued_fraction_periodic\nA031702_list = [n for n, s in ((i, continued_fraction_periodic(0,1,i)[-1]) for i in range(1,10**5)) if isinstance(s, list) and min(s) == 24] \n"}
{"sequence_id": "A031713", "text": "Numbers k such that the least term in the periodic part of the continued fraction for sqrt(k) is 35.", "sequence": "1227,4904,11031,19608,30635,44112,60039,78416,99243,122520,148247,176424,207051,240128,275655,313632,354059,396936,442263,490040,540267,592944,648071,705648,765675,828152,893079,960456,1030283,1102560", "code": "\nfrom sympy import continued_fraction_periodic\nA031713_list = [n for n, d in ((n, continued_fraction_periodic(0,1,n)[-1]) for n in range(1,10**5)) if isinstance(d, list) and min(d) == 35] \n"}
{"sequence_id": "A031749", "text": "Numbers k such that the least term in the periodic part of the continued fraction for sqrt(k) is 71.", "sequence": "5043,20168,45375,80664,126035,181488,247023,322640,408339,504120,609983,725928,851955,988064,1134255,1290528,1456883,1633320,1819839,2016440,2223123,2439888,2666735,2903664,3150675,3407768,3674943,3952200,4239539", "code": "\nfrom sympy import continued_fraction_periodic\nA031749_list = [n for n, d in ((n, continued_fraction_periodic(0,1,n)[-1]) for n in range(1,10**5)) if isinstance(d, list) and min(d) == 71] \n"}
{"sequence_id": "A031775", "text": "Numbers k such that the least term in the periodic part of the continued fraction for sqrt(k) is 97.", "sequence": "9411,37640,84687,150552,235235,338736,461055,602192,762147,940920,1138511,1354920,1590147,1844192,2117055,2408736,2719235,3048552,3396687,3763640,4149411,4554000,4977407,5419632,5880675,6360536,6859215,7376712", "code": "\nfrom sympy import continued_fraction_periodic\nA031775_list = [n for n, d in ((n, continued_fraction_periodic(0,1,n)[-1]) for n in range(1,10**5)) if isinstance(d, list) and min(d) == 97] \n"}
{"sequence_id": "A031777", "text": "Numbers k such that the least term in the periodic part of the continued fraction for sqrt(k) is 99.", "sequence": "9803,39208,88215,156824,245035,352848,480263,627280,793899,980120,1185943,1411368,1656395,1921024,2205255,2509088,2832523,3175560,3538199,3920440,4322283,4743728,5184775,5645424,6125675,6625528,7144983,7684040", "code": "\nfrom sympy import continued_fraction_periodic\nA031777_list = [n for n, d in ((n, continued_fraction_periodic(0,1,n)[-1]) for n in range(1,10**5)) if isinstance(d, list) and min(d) == 99] \n"}
{"sequence_id": "A031877", "text": "Nontrivial reversal numbers (numbers which are integer multiples of their reversals), excluding palindromic numbers and multiples of 10.", "sequence": "8712,9801,87912,98901,879912,989901,8799912,9899901,87128712,87999912,98019801,98999901,871208712,879999912,980109801,989999901,8712008712,8791287912,8799999912,9801009801,9890198901,9899999901,87120008712,87912087912,87999999912", "code": "\nA031877 = []\nfor n in range(1,10**7):\n    if n % 10:\n        s1 = str(n)\n        s2 = s1[::-1]\n        if s1 != s2 and not n % int(s2):\n            A031877.append(n) \n"}
{"sequence_id": "A031923", "text": "Let r and s be consecutive Fibonacci numbers. Sequence is r^4, r^3 s, r^2 s^2, and r s^3.", "sequence": "1,2,4,8,16,24,36,54,81,135,225,375,625,1000,1600,2560,4096,6656,10816,17576,28561,46137,74529,120393,194481,314874,509796,825384,1336336,2161720,3496900,5656750,9150625,14807375,23961025,38773295,62742241,101515536", "code": "\ndef a(n, adict={0:0, 1:0, 2:0, 3:0, 4:0, 5:4, 6:15, 7:37, 8:87, 9:200}):\n    if n in adict:\n        return adict[n]\n    adict[n]=3*a(n-1)-2*a(n-2)+2*a(n-3)-4*a(n-4)+2*a(n-5)-2*a(n-6)-4*a(n-7)-a(n-8)+a(n-9)+2*a(n-10)\n    return adict[n] \n"}
{"sequence_id": "A031953", "text": "Numbers with exactly two distinct base-8 digits.", "sequence": "8,10,11,12,13,14,15,16,17,19,20,21,22,23,24,25,26,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44,46,47,48,49,50,51,52,53,55,56,57,58,59,60,61,62,64,65,72,74,75,76,77,78,79,81,82,89,91,97,100,105", "code": "\ndef ok(n): return len(set(oct(n)[2:])) == 2\nprint(list(filter(ok, range(106)))) \n"}
{"sequence_id": "A031955", "text": "Numbers with exactly two distinct base-10 digits.", "sequence": "10,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,34,35,36,37,38,39,40,41,42,43,45,46,47,48,49,50,51,52,53,54,56,57,58,59,60,61,62,63,64,65,67,68,69,70,71,72,73,74,75,76,78,79,80,81,82,83,84,85,86,87,89,90,91,92,93,94,95,96,97,98,100,101,110,112,113,114,115,116,117,118,119,121,122,131,133,141,144,151,155,161,166", "code": "\ndef ok(n): return len(set(str(n))) == 2\nprint(list(filter(ok, range(167)))) \n"}
{"sequence_id": "A031971", "text": "a(n) = Sum_{k=1..n} k^n.", "sequence": "1,5,36,354,4425,67171,1200304,24684612,574304985,14914341925,427675990236,13421957361110,457593884876401,16841089312342855,665478473553144000,28101527071305611528,1262899292504270591313,60182438244917445266889,3031284048960901518840700", "code": "\nfrom sympy import harmonic\ndef A031971(n):\n    return harmonic(n,-n) \n"}
{"sequence_id": "A031997", "text": "Odd numbers which when cubed give number composed just of the digits 0, 1, 2, 3.", "sequence": "1,11,101,1001,10001,100001,684917,1000001,10000001,100000001,1000000001,10000000001,100000000001,1000000000001,10000000000001,100000000000001,1000000000000001,10000000000000001,100000000000000001,1000000000000000001", "code": "\nA031997_list = [n for n in range(1,10**6,2) if max(str(n**3)) <= '3'] \n"}
{"sequence_id": "A032352", "text": "Numbers k such that there is no prime between 10*k and 10*k+9.", "sequence": "20,32,51,53,62,84,89,107,113,114,126,133,134,135,141,146,150,164,167,168,171,176,179,185,189,192,196,204,207,210,218,219,232,236,240,248,249,251,256,258,282,294,298,305,309,314,315,317,323,324,326,328,342", "code": "\nfrom sympy import isprime\ndef aupto(limit):\n  alst = []\n  for d in range(2, limit+1):\n    td = [10*d + j for j in [1, 3, 7, 9]]\n    if not any(isprime(t) for t in td): alst.append(d)\n  return alst\nprint(aupto(342)) \n"}
{"sequence_id": "A032682", "text": "Numbers k such that k surrounded by digit '1' is a prime.", "sequence": "0,3,5,8,9,15,17,18,20,23,29,30,32,36,38,45,47,48,51,53,57,60,62,72,74,80,81,83,86,87,90,93,95,107,113,116,117,125,126,131,132,135,141,147,149,155,162,168,170,173,180,182,183,194,197,198,201,204,207,210", "code": "\nfrom sympy import isprime\nprint([i for i in range(200) if isprime(int('1' + str(i) + '1'))]) \n"}
{"sequence_id": "A032684", "text": "Numbers k such that k surrounded by digit '7' is prime.", "sequence": "2,5,8,9,12,17,18,20,23,24,29,30,41,45,47,48,50,51,53,54,57,60,68,71,72,75,81,86,87,90,92,93,114,116,123,125,128,131,132,134,138,143,152,153,159,164,170,177,180,183,186,188,191,194,198,204,207", "code": "\nfrom sympy import isprime\nprint([i for i in range(200) if isprime(int('7' + str(i) + '7'))]) \n"}
{"sequence_id": "A032691", "text": "Exactly 1 digit from {1,2,3,4,5,6,7,8,9} can precede a term to form a prime.", "sequence": "89,107,139,141,169,189,223,249,267,313,379,383,403,453,497,587,589,633,667,751,757,763,799,859,893,899,913,959,961,977,979,981,983,989,991,1003,1007,1009,1041,1049,1063,1067,1087,1093,1107,1109,1123,1127", "code": "\nfrom sympy import isprime\nprint([i for i in range(1000) if [isprime(int(j + str(i))) for j in '123456789'].count(True) == 1]) \n"}
{"sequence_id": "A032693", "text": "Exactly 3 digits from {1,2,3,4,5,6,7,8,9} can precede a term to form a prime.", "sequence": "13,21,23,29,33,37,43,49,51,59,61,69,71,79,81,93,99,101,103,111,113,121,127,133,137,161,163,167,171,179,181,211,213,219,253,257,259,269,271,277,281,287,293,301,307,309,319,329,333,337,343,347,349,351,361", "code": "\nfrom sympy import isprime\nprint([i for i in range(400) if [isprime(int(j + str(i))) for j in '123456789'].count(True) == 3]) \n"}
{"sequence_id": "A032694", "text": "Exactly 4 digits from {1,2,3,4,5,6,7,8,9} can precede a(n) to form a prime.", "sequence": "11,19,27,31,41,47,53,67,73,87,91,97,109,129,151,153,187,203,209,217,231,243,273,283,311,323,373,389,423,433,447,451,467,481,539,549,581,583,591,607,621,623,637,643,657,659,663,669,673,677,691,693,699,753", "code": "\nfrom sympy import isprime\nprint([i for i in range(800) if [isprime(int(j + str(i))) for j in '123456789'].count(True) == 4]) \n"}
{"sequence_id": "A032731", "text": "Numbers k such that k prefixed by '6' and followed by '9' is a prime.", "sequence": "1,5,19,22,26,29,32,35,37,38,44,46,52,56,59,61,65,67,68,70,71,77,82,86,89,94,95,109,112,116,133,137,140,146,151,155,160,172,181,187,190,194,197,203,209,211,212,218,221,229,245,253,254,263,265,281,286,292", "code": "\nfrom sympy import isprime\ndef ok(n): return isprime(int('6'+str(n)+'9'))\nprint(list(filter(ok, range(293)))) \n"}
{"sequence_id": "A032822", "text": "Numbers whose set of base-10 digits is {1,4}.", "sequence": "1,4,11,14,41,44,111,114,141,144,411,414,441,444,1111,1114,1141,1144,1411,1414,1441,1444,4111,4114,4141,4144,4411,4414,4441,4444,11111,11114,11141,11144,11411,11414,11441,11444,14111,14114", "code": "\ndef a(n): return int(bin(n+1)[3:].replace('1', '4').replace('0', '1'))\nprint([a(n) for n in range(1, 45)]) \n"}
{"sequence_id": "A032828", "text": "Numbers whose set of base-16 digits is {1,4}.", "sequence": "1,4,17,20,65,68,273,276,321,324,1041,1044,1089,1092,4369,4372,4417,4420,5137,5140,5185,5188,16657,16660,16705,16708,17425,17428,17473,17476,69905,69908,69953,69956,70673,70676,70721", "code": "\ndef a(n): return int(bin(n+1)[3:].replace('1', '4').replace('0', '1'), 16)\nprint([a(n) for n in range(1, 38)]) \n"}
{"sequence_id": "A032840", "text": "Numbers whose set of base-16 digits is {3,4}.", "sequence": "3,4,51,52,67,68,819,820,835,836,1075,1076,1091,1092,13107,13108,13123,13124,13363,13364,13379,13380,17203,17204,17219,17220,17459,17460,17475,17476,209715,209716,209731,209732,209971,209972", "code": "\ndef a(n): return int(bin(n+1)[3:].replace('1', '4').replace('0', '3'), 16)\nprint([a(n) for n in range(1, 37)]) \n"}
{"sequence_id": "A032917", "text": "Numbers having only digits 1 and 3 in their decimal representation.", "sequence": "1,3,11,13,31,33,111,113,131,133,311,313,331,333,1111,1113,1131,1133,1311,1313,1331,1333,3111,3113,3131,3133,3311,3313,3331,3333,11111,11113,11131,11133,11311,11313,11331,11333,13111,13113", "code": "\ndef a(n): return int(bin(n+1)[3:].replace('1', '3').replace('0', '1'))\nprint([a(n) for n in range(1, 45)]) \n"}
{"sequence_id": "A032936", "text": "Numbers whose set of base-16 digits is {1,2}.", "sequence": "1,2,17,18,33,34,273,274,289,290,529,530,545,546,4369,4370,4385,4386,4625,4626,4641,4642,8465,8466,8481,8482,8721,8722,8737,8738,69905,69906,69921,69922,70161,70162,70177,70178,74001,74002", "code": "\ndef a(n): return int(bin(n+1)[3:].replace('1', '2').replace('0', '1'), 16)\nprint([a(n) for n in range(1, 41)]) \n"}
{"sequence_id": "A033010", "text": "Numbers each of whose runs of digits in base 12 has length 2.", "sequence": "13,26,39,52,65,78,91,104,117,130,143,1872,1898,1911,1924,1937,1950,1963,1976,1989,2002,2015,3744,3757,3783,3796,3809,3822,3835,3848,3861,3874,3887,5616,5629,5642,5668,5681,5694,5707,5720,5733,5746,5759,7488,7501", "code": "\nfrom sympy.ntheory import digits\nfrom itertools import groupby\ndef ok(n):\n  return all(len(list(g))==2 for k, g in groupby(digits(n, 12)[1:]))\nprint(list(filter(ok, range(1, 7502)))) \n"}
{"sequence_id": "A033015", "text": "Numbers whose base-2 expansion has no run of digits with length < 2.", "sequence": "3,7,12,15,24,28,31,48,51,56,60,63,96,99,103,112,115,120,124,127,192,195,199,204,207,224,227,231,240,243,248,252,255,384,387,391,396,399,408,412,415,448,451,455,460,463,480,483,487,496,499,504,508,511,768", "code": "\nfrom itertools import groupby\ndef ok(n): return all(len(list(g)) >= 2 for k, g in groupby(bin(n)[2:]))\nprint([i for i in range(1, 769) if ok(i)]) \n"}
{"sequence_id": "A033075", "text": "Positive numbers all of whose pairs of consecutive decimal digits differ by 1.", "sequence": "1,2,3,4,5,6,7,8,9,10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98,101,121,123,210,212,232,234,321,323,343,345,432,434,454,456,543,545,565,567,654,656,676,678,765,767,787,789,876", "code": "\ndef ok(n):\n    s = str(n)\n    return all(abs(int(s[i]) - int(s[i+1])) == 1 for i in range(len(s)-1))\nprint(list(filter(ok, range(1, 877)))) \n"}
{"sequence_id": "A033075", "text": "Positive numbers all of whose pairs of consecutive decimal digits differ by 1.", "sequence": "1,2,3,4,5,6,7,8,9,10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98,101,121,123,210,212,232,234,321,323,343,345,432,434,454,456,543,545,565,567,654,656,676,678,765,767,787,789,876", "code": " \ndef gen(d, s=None): \n    if d == 0:\n        yield tuple()\n        return\n    if s == None:\n        yield from [(i, ) + g for i in range(1, 10) for g in gen(d-1, s=i)]\n    else:\n        if s > 0:\n            yield from [(s-1, ) + g for g in gen(d-1, s=s-1)]\n        if s < 9:\n            yield from [(s+1, ) + g for g in gen(d-1, s=s+1)]\ndef agentod(digits):\n    for d in range(1, digits+1):\n        yield from [int(\"\".join(map(str, g))) for g in gen(d, s=None)]\nprint(list(agentod(11))) \n"}
{"sequence_id": "A033146", "text": "Decimal expansion of a(n) is given by the first n terms of the periodic sequence with initial period 1,0,0.", "sequence": "1,10,100,1001,10010,100100,1001001,10010010,100100100,1001001001,10010010010,100100100100,1001001001001,10010010010010,100100100100100,1001001001001001,10010010010010010,100100100100100100,1001001001001001001,10010010010010010010", "code": " print([100*10**n//999 for n in range(1,50)]) \n"}
{"sequence_id": "A033156", "text": "a(1) = 1; for m >= 2, a(n) = a(n-1) + floor(a(n-1)/(n-1)) + 2.", "sequence": "1,4,8,12,17,22,27,32,38,44,50,56,62,68,74,80,87,94,101,108,115,122,129,136,143,150,157,164,171,178,185,192,200,208,216,224,232,240,248,256,264,272,280,288,296,304,312,320,328,336,344,352,360,368,376,384,392,400,408", "code": "\ndef A033156(n):\n    s, i, z = 2*n-1, n-1, 1\n    while 0 <= i: s += i; i -= z; z += z\n    return s\nprint([A033156(n) for n in range(1, 60)]) \n"}
{"sequence_id": "A033175", "text": "n 3's followed by 1.", "sequence": "1,31,331,3331,33331,333331,3333331,33333331,333333331,3333333331,33333333331,333333333331,3333333333331,33333333333331,333333333333331,3333333333333331,33333333333333331,333333333333333331,3333333333333333331,33333333333333333331", "code": "\ndef a(n): return int('3'*n + '1')\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A033180", "text": "Numbers k such that k! contains k as a string of digits.", "sequence": "1,2,4,20,21,26,30,33,37,39,42,44,45,48,51,52,53,56,59,60,64,65,67,68,69,72,75,78,79,80,81,82,83,84,88,91,93,94,95,96,97,98,99,116,124,134,136,140,141,149,164,165,166,170,174,180,186,188,196,198,200,202,205", "code": "\nfrom math import factorial\ndef ok(n): return str(n) in str(factorial(n))\nprint(list(filter(ok, range(206)))) \n"}
{"sequence_id": "A033299", "text": "Smallest safe prime ((p-1)/2 is also prime) > n.", "sequence": "5,5,5,5,7,7,11,11,11,11,23,23,23,23,23,23,23,23,23,23,23,23,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,59,59,59,59,59,59,59,59,59,59,59,59,83,83,83,83,83,83,83,83,83", "code": "\nfrom sympy import isprime, nextprime\ndef a(n):\n  p = nextprime(n)\n  while not isprime((p-1)//2): p = nextprime(p)\n  return p\nprint([a(n) for n in range(1, 68)]) \n"}
{"sequence_id": "A033307", "text": "Decimal expansion of Champernowne constant (or Mahler's number), formed by concatenating the positive integers.", "sequence": "1,2,3,4,5,6,7,8,9,1,0,1,1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,2,0,2,1,2,2,2,3,2,4,2,5,2,6,2,7,2,8,2,9,3,0,3,1,3,2,3,3,3,4,3,5,3,6,3,7,3,8,3,9,4,0,4,1,4,2,4,3,4,4,4,5,4,6,4,7,4,8,4,9,5,0,5,1,5,2,5,3,5,4,5,5,5,6,5", "code": "\nfrom itertools import count\ndef agen():\n    for k in count(1): yield from list(map(int, str(k)))\na = agen()\nprint([next(a) for i in range(104)]) \n"}
{"sequence_id": "A033479", "text": "3x+1 sequence beginning at 9.", "sequence": "9,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1", "code": "\nfrom itertools import accumulate\ndef f(x, _): return x//2 if x%2 == 0 else 3*x+1\nprint(list(accumulate([9]*92, f))) \n"}
{"sequence_id": "A033493", "text": "Sum of the numbers in the trajectory of n for the 3x+1 problem.", "sequence": "1,3,49,7,36,55,288,15,339,46,259,67,119,302,694,31,214,357,519,66,148,281,633,91,658,145,101440,330,442,724,101104,63,841,248,540,393,535,557,2344,106,101331,190,1338,325,497,679,100979,139,806,708,1130,197", "code": "\ndef a(n):\n    if n==1: return 1\n    l=[n, ]\n    while True:\n        if n%2==0: n/=2\n        else: n = 3*n + 1\n        l+=[n, ]\n        if n<2: break\n    return sum(l)\nprint([a(n) for n in range(1, 101)])  \n"}
{"sequence_id": "A033496", "text": "Numbers n such that initial number is largest number in trajectory of Collatz (3x+1) problem.", "sequence": "1,2,4,8,16,20,24,32,40,48,52,56,64,68,72,80,84,88,96,100,104,112,116,128,132,136,144,148,152,160,168,176,180,184,192,196,200,208,212,224,228,232,240,244,256,260,264,272,276,280,288,296,304,308,312,320,324", "code": "\ndef a(n):\n    if n<2: return [1]\n    l=[n, ]\n    while True:\n        if n%2==0: n//=2\n        else: n = 3*n + 1\n        if n not in l:\n            l.append(n)\n            if n<2: break\n        else: break\n    return l\nprint([n for n in range(1, 501) if max(a(n)) == n]) \n"}
{"sequence_id": "A033539", "text": "a(0)=1, a(1)=1, a(2)=1, a(n) = 2*a(n-1) + a(n-2) + 1.", "sequence": "1,1,1,4,10,25,61,148,358,865,2089,5044,12178,29401,70981,171364,413710,998785,2411281,5821348,14053978,33929305,81912589,197754484,477421558,1152597601,2782616761,6717831124,16218279010,39154389145", "code": "\n\ndef myrev(lista):\n  '''Reverses a list, in cumbersome way.'''\n  if(len(lista) < 2): return(lista)\n  else:\n    tr = myrev(lista[1:])\n    return([tr[0]]+myrev([lista[0]]+myrev(tr[1:])))\n"}
{"sequence_id": "A033548", "text": "Honaker primes: primes P(k) such that sum of digits of P(k) equals sum of digits of k.", "sequence": "131,263,457,1039,1049,1091,1301,1361,1433,1571,1913,1933,2141,2221,2273,2441,2591,2663,2707,2719,2729,2803,3067,3137,3229,3433,3559,3631,4091,4153,4357,4397,4703,4723,4903,5009,5507,5701,5711,5741,5801,5843", "code": "\nfrom sympy.ntheory.factor_ import digits\nfrom sympy import primepi, primerange\nprint([n for n in primerange(1, 5901) if (sum(digits(n)[1:])==sum(digits(primepi(n))[1:]))]) \n"}
{"sequence_id": "A033549", "text": "Numbers n such that sum of digits of n-th prime equals sum of digits of n.", "sequence": "32,56,88,175,176,182,212,218,227,248,293,295,323,331,338,362,377,386,394,397,398,409,439,446,457,481,499,508,563,571,595,599,635,637,655,671,728,751,752,755,761,767,779,820,821,826,827,847,848,857,869,878", "code": "\nfrom sympy.ntheory.factor_ import digits\nfrom sympy import prime\nprint([n for n in range(1, 1001) if sum(digits(n)[1:])==sum(digits(prime(n))[1:])]) \n"}
{"sequence_id": "A033620", "text": "Numbers all of whose prime factors are palindromes.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,14,15,16,18,20,21,22,24,25,27,28,30,32,33,35,36,40,42,44,45,48,49,50,54,55,56,60,63,64,66,70,72,75,77,80,81,84,88,90,96,98,99,100,101,105,108,110,112,120,121,125,126,128,131", "code": "\nfrom sympy import isprime, primefactors\ndef pal(n): s = str(n); return s == s[::-1]\ndef ok(n): return all(pal(f) for f in primefactors(n))\nprint(list(filter(ok, range(1, 132)))) \n"}
{"sequence_id": "A033632", "text": "Numbers n such that sigma(phi(n)) = phi(sigma(n)).", "sequence": "1,9,225,242,516,729,3872,13932,14406,17672,18225,20124,21780,29262,29616,45996,65025,76832,92778,95916,106092,106308,114630,114930,121872,125652,140130,140625,145794,149124,160986,179562,185100,234876,248652,252978,256860", "code": "\nfrom sympy import divisor_sigma as sigma, totient as phi\ndef ok(n): return sigma(phi(n)) == phi(sigma(n))\ndef aupto(nn): return [m for m in range(1, nn+1) if ok(m)]\nprint(aupto(10**4)) \n"}
{"sequence_id": "A033664", "text": "Every suffix is prime.", "sequence": "2,3,5,7,13,17,23,37,43,47,53,67,73,83,97,103,107,113,137,167,173,197,223,283,307,313,317,337,347,353,367,373,383,397,443,467,503,523,547,607,613,617,643,647,653,673,683,743,773,797,823,853,883,907,937,947", "code": "\nfrom sympy import isprime, primerange\ndef ok(p): \n    s = str(p)\n    return all(isprime(int(s[i:])) for i in range(1, len(s)))\nprint(list(filter(ok, primerange(1, 1000)))) \n"}
{"sequence_id": "A033664", "text": "Every suffix is prime.", "sequence": "2,3,5,7,13,17,23,37,43,47,53,67,73,83,97,103,107,113,137,167,173,197,223,283,307,313,317,337,347,353,367,373,383,397,443,467,503,523,547,607,613,617,643,647,653,673,683,743,773,797,823,853,883,907,937,947", "code": " \ndef agen(maxdigits):\n    yield from [2, 3, 5, 7]\n    primestrs, digits, d = [\"2\", \"3\", \"5\", \"7\"], \"0123456789\", 1\n    while len(primestrs) > 0 and d < maxdigits:\n        cands = set(d+p for p in primestrs for d in \"0123456789\")\n        primestrs = [c for c in cands if c[0] == \"0\" or isprime(int(c))]\n        yield from sorted(map(int, (p for p in primestrs if p[0] != \"0\")))\n        d += 1\nprint([p for p in agen(11)]) \n"}
{"sequence_id": "A033676", "text": "Largest divisor of n <= sqrt(n).", "sequence": "1,1,1,2,1,2,1,2,3,2,1,3,1,2,3,4,1,3,1,4,3,2,1,4,5,2,3,4,1,5,1,4,3,2,5,6,1,2,3,5,1,6,1,4,5,2,1,6,7,5,3,4,1,6,5,7,3,2,1,6,1,2,7,8,5,6,1,4,3,7,1,8,1,2,5,4,7,6,1,8,9,2,1,7,5,2,3", "code": "\nfrom sympy import divisors\ndef A033676(n):\n    d = divisors(n)\n    return d[(len(d)-1)//2]  \n"}
{"sequence_id": "A033677", "text": "Smallest divisor of n >= sqrt(n).", "sequence": "1,2,3,2,5,3,7,4,3,5,11,4,13,7,5,4,17,6,19,5,7,11,23,6,5,13,9,7,29,6,31,8,11,17,7,6,37,19,13,8,41,7,43,11,9,23,47,8,7,10,17,13,53,9,11,8,19,29,59,10,61,31,9,8,13,11,67,17,23,10,71,9,73,37,15,19,11,13,79,10", "code": "\nfrom sympy import divisors\ndef A033677(n):\n    d = divisors(n)\n    return d[len(d)//2]  \n"}
{"sequence_id": "A033814", "text": "Convolution of positive integers n with Lucas numbers L(k)(A000032) for k >= 4.", "sequence": "7,25,61,126,238,426,737,1247,2079,3432,5628,9188,14955,24293,39409,63874,103466,167534,271205,438955,710387,1149580,1860216,3010056,4870543,7880881,12751717,20632902,33384934,54018162,87403433,141421943,228825735,370248048", "code": "\nfrom sympy import lucas\ndef a(n): return lucas(n+7) - 11*n - 29\nprint([a(n) for n in range(1, 35)]) \n"}
{"sequence_id": "A033861", "text": "Sort-then-add sequence: a(1) = 316, a(n+1) = a(n) + sort(a(n)).", "sequence": "316,452,697,1376,2743,5090,5149,6608,7276,9953,13552,25907,28486,53174,66631,80297,83086,86774,133552,256907,282586,508274,532852,756410,770977,848756,1305544,1439999,2789998,5578997,11156896", "code": "\nA033861_list = [316]\nfor i in range(100):\n    x = A033861_list[-1]\n    A033861_list.append(x+int(''.join(sorted(str(x))))) \n"}
{"sequence_id": "A033896", "text": "Sort then Add!.", "sequence": "9,18,36,72,99,198,387,765,1332,2565,5121,6246,8712,9990,10989,12888,25776,51453,64908,69597,126396,250065,252621,374877,722655,948222,1170711,1281888,2410776,2535453,4870008,4874796,9342585,11688174,22834962,45069651", "code": "\nfrom itertools import accumulate\ndef sta(anm1, _): return anm1 + int(\"\".join(sorted(str(anm1))))\nprint(list(accumulate([9]*36, sta))) \n"}
{"sequence_id": "A033915", "text": "Numbers n such that s(n)+s(n+1)+...+s(n+10) = t(n)+t(n+1)+...+t(n+10).", "sequence": "1,29,57,217,1099,4615,1630311,3827247,108899227,305185735,3189176095,50514325279", "code": "\nfrom sympy import divisor_sigma\ndef s(n): return divisor_sigma(n) - n\ndef t(n): return abs(s(n) - n)\ndef ok(n): return sum(s(i) for i in range(n, n+11)) == sum(t(i) for i in range(n, n+11))\nprint([m for m in range(1, 10**4) if ok(m)]) \n"}
{"sequence_id": "A033918", "text": "Triangular array in which n-th row consists of the numbers 1^1, 2^2, ... n^n.", "sequence": "1,1,4,1,4,27,1,4,27,256,1,4,27,256,3125,1,4,27,256,3125,46656,1,4,27,256,3125,46656,823543,1,4,27,256,3125,46656,823543,16777216,1,4,27,256,3125,46656,823543,16777216,387420489,1,4,27,256,3125,46656", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\nm=(n-t*(t+1)/2)**(n-t*(t+1)/2)\n"}
{"sequence_id": "A033950", "text": "Refactorable numbers: number of divisors of k divides k. Also known as tau numbers.", "sequence": "1,2,8,9,12,18,24,36,40,56,60,72,80,84,88,96,104,108,128,132,136,152,156,180,184,204,225,228,232,240,248,252,276,288,296,328,344,348,360,372,376,384,396,424,441,444,448,450,468,472,480,488,492,504,516,536", "code": "\nfrom sympy import divisor_count\nprint([n for n in range(1, 1001) if not n % divisor_count(n)]) \n"}
{"sequence_id": "A033951", "text": "Write 1,2,... in clockwise spiral; sequence gives numbers on positive x axis.", "sequence": "1,8,23,46,77,116,163,218,281,352,431,518,613,716,827,946,1073,1208,1351,1502,1661,1828,2003,2186,2377,2576,2783,2998,3221,3452,3691,3938,4193,4456,4727,5006,5293,5588,5891,6202,6521,6848,7183,7526,7877,8236", "code": "\n[4*n**2 + 3*n + 1 for n in range(46)] \n"}
{"sequence_id": "A034002", "text": "A005150 expanded into single digits.", "sequence": "1,1,1,2,1,1,2,1,1,1,1,1,2,2,1,3,1,2,2,1,1,1,3,1,1,2,2,2,1,1,1,1,3,2,1,3,2,1,1,3,1,1,3,1,2,1,1,1,3,1,2,2,1,1,3,2,1,1,3,1,1,1,2,3,1,1,3,1,1,2,2,1,1,1,1,1,3,1,2,2,1,1,3,3,1,1,2,1,3,2,1,1,3,2,1,2,2,2,1", "code": "\nfrom sympy import flatten\nl=[1]\nL=[1]\nn=s=1\ny=''\nwhile n<21:\n    x=str(l[n - 1]) + ' '\n    for i in range(len(x) - 1):\n        if x[i]==x[i + 1]: s+=1\n        else:\n            y+=str(s)+str(x[i])\n            s=1\n    x=''\n    n+=1\n    l.append(int(y))\n    L.append([int(a) for a in list(y)])\n    y=''\n    s=1\nprint(l) \nprint(flatten(L)) \n"}
{"sequence_id": "A034050", "text": "Numbers with multiplicative digital root value 3.", "sequence": "3,13,31,113,131,311,1113,1131,1311,3111,11113,11131,11311,13111,31111,111113,111131,111311,113111,131111,311111,1111113,1111131,1111311,1113111,1131111,1311111,3111111,11111113,11111131,11111311,11113111", "code": " \nprint([int(\"1\"*(d-i)+\"3\"+\"1\"*i) for d in range(8) for i in range(d+1)]) \n"}
{"sequence_id": "A034057", "text": "Decimal part of a(n)^(1/2) starts with n (squares excluded).", "sequence": "26,10,5,11,2,21,7,3,8,35,199,83,17,124,51,173,10,201,67,27,149,52,126,5,18,541,127,86,53,28,69,11,40,336,54,19,70,179,29,108,41,2,71,89,6,181,12,20,42,182,1407,381,157,91,57,43,31,134,21,92,13,58", "code": "\nfrom math import sqrt\ndef a(n):\n  k, s, pow10 = 3, sqrt(2), 10**len(str(n))\n  while int(pow10*(s-int(s))) != n: k, s = k+1, sqrt(k)\n  return k-1\nprint([a(n) for n in range(1, 67)]) \n"}
{"sequence_id": "A034097", "text": "Fractional part of square root of a(n) starts with digit 1.", "sequence": "10,17,27,38,51,66,67,83,84,103,104,124,125,147,148,172,173,174,199,200,201,229,230,231,260,261,262,293,294,295,328,329,330,331,365,366,367,368,405,406,407,408,446,447,448,449,489,490,491,492,534,535,536", "code": "\nfrom math import sqrt\ndef aupto(lim): return [k for k in range(lim+1) if int(10*sqrt(k))%10 == 1]\nprint(aupto(536)) \n"}
{"sequence_id": "A034104", "text": "Fractional part of square root of a(n) starts with digit 8.", "sequence": "8,15,24,34,47,61,62,78,79,97,98,117,118,140,141,164,165,166,191,192,193,220,221,222,250,251,252,283,284,285,317,318,319,320,354,355,356,357,393,394,395,396,433,434,435,436,476,477,478,479,520,521,522,523", "code": "\nfrom math import sqrt\ndef ok(n): r = sqrt(n); return int(10*(r-int(r))) == 8\nprint(list(filter(ok, range(524)))) \n"}
{"sequence_id": "A034107", "text": "Fractional part of square root of a(n) starts with 1: first term of runs.", "sequence": "10,17,27,38,51,66,83,103,124,147,172,199,229,260,293,328,365,405,446,489,534,581,631,682,735,790,847,907,968,1031,1096,1163,1233,1304,1377,1452,1529,1609,1690,1773,1858,1945,2035,2126,2219,2314,2411,2511,2612", "code": "\nfrom math import sqrt\ndef a(n):\n    k = (n + 2)**2\n    while int(10*sqrt(k))%10 != 1: k += 1\n    return k\nprint([a(n) for n in range(1, 50)]) \n"}
{"sequence_id": "A034117", "text": "Fractional part of cube root of a(n) starts with digit 1.", "sequence": "10,30,31,32,69,70,71,72,73,74,133,134,135,136,137,138,139,140,227,228,229,230,231,232,233,234,235,236,237,238,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,532,533,534,535,536,537,538,539", "code": "\nfrom sympy import integer_nthroot\ndef ok(n): return integer_nthroot(1000*n, 3)[0]%10 == 1\nprint([k for k in range(540) if ok(k)]) \n"}
{"sequence_id": "A034127", "text": "Decimal part of cube root of a(n) starts with 1: first term of runs.", "sequence": "10,30,69,133,227,358,532,754,1031,1368,1772,2249,2804,3443,4174,5001,5930,6968,8121,9394,10794,12327,13998,15814,17780,19903,22189,24643,27271,30081,33077,36265,39652,43244,47046,51065,55307,59777,64482,69427,74619,80063", "code": "\ndef a(n): q, r = divmod((10*n + 11)**3, 1000); return q + int(r != 0)\nprint([a(n) for n in range(1, 43)]) \n"}
{"sequence_id": "A034296", "text": "Number of flat partitions of n: partitions {a_i} with each |a_i - a_{i-1}| <= 1.", "sequence": "1,1,2,3,4,5,7,8,10,13,15,18,23,26,31,39,44,52,63,72,85,101,115,134,158,181,208,243,277,318,369,418,478,549,622,710,809,914,1036,1177,1328,1498,1695,1904,2143,2416,2706,3036,3408,3811,4264,4769,5319,5934,6621", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n, i): return 1 if n==0 else 0 if i<1 else sum(b(n - i*j, i - 1) for j in range(1, n//i + 1))\ndef a(n): return sum(b(n, k) for k in range(n + 1))\nprint([a(n) for n in range(71)]) \n"}
{"sequence_id": "A034297", "text": "Number of ordered positive integer solutions (m_1, m_2, ..., m_k) (for some k) to Sum_{i=1..k} m_i=n with |m_i-m_{i-1}| <= 1 for i = 2 ... k.", "sequence": "1,1,2,4,6,11,17,29,47,78,130,215,357,595,990,1651,2748,4584,7643,12744,21256,35451,59133,98636,164531,274463,457837,763746,1274060,2125356,3545491,5914545,9866602,16459421,27457549,45804648,76411272,127469285,212644336", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n, i): return 1 if n==i else 0 if n<0 or i<1 else sum(b(n - i, i + j) for j in range(-1, 2))\ndef a(n): return sum(b(n, k) for k in range(n + 1))\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A034302", "text": "Zeroless primes that remain prime if any digit is deleted.", "sequence": "23,37,53,73,113,131,137,173,179,197,311,317,431,617,719,1499,1997,2239,2293,3137,4919,6173,7433,9677,19973,23833,26833,47933,73331,74177,91733,93491,94397,111731,166931,333911,355933,477797,477977", "code": "\nfrom itertools import product\nfrom sympy import isprime\nA034302_list, m = [23, 37, 53, 73], 7\nfor l in range(1,m-1): \n    for d in product('123456789',repeat=l):\n        for e in product('1379',repeat=2):\n            s = ''.join(d+e)\n            if isprime(int(s)):\n                for i in range(len(s)):\n                    if not isprime(int(s[:i]+s[i+1:])):\n                        break\n                else:\n                    A034302_list.append(int(s)) \n"}
{"sequence_id": "A034387", "text": "Sum of primes <= n.", "sequence": "0,2,5,5,10,10,17,17,17,17,28,28,41,41,41,41,58,58,77,77,77,77,100,100,100,100,100,100,129,129,160,160,160,160,160,160,197,197,197,197,238,238,281,281,281,281,328,328,328,328,328,328", "code": "\nfrom sympy import isprime\nfrom itertools import accumulate\ndef alist(n): return list(accumulate(k*isprime(k) for k in range(1, n+1)))\nprint(alist(57)) \n"}
{"sequence_id": "A034444", "text": "a(n) is the number of unitary divisors of n (d such that d divides n, gcd(d, n/d) = 1).", "sequence": "1,2,2,2,2,4,2,2,2,4,2,4,2,4,4,2,2,4,2,4,4,4,2,4,2,4,2,4,2,8,2,2,4,4,4,4,2,4,4,4,2,8,2,4,4,4,2,4,2,4,4,4,2,4,4,4,4,4,2,8,2,4,4,2,4,8,2,4,4,8,2,4,2,4,4,4,4,8,2,4,2,4,2,8,4,4,4,4,2,8,4,4,4,4,4,4,2,4,4,4,2,8,2,4,8", "code": "\nfrom sympy import divisors, gcd\ndef a(n):\n    return sum(1 for d in divisors(n) if gcd(d, n//d)==1)\n\n"}
{"sequence_id": "A034444", "text": "a(n) is the number of unitary divisors of n (d such that d divides n, gcd(d, n/d) = 1).", "sequence": "1,2,2,2,2,4,2,2,2,4,2,4,2,4,4,2,2,4,2,4,4,4,2,4,2,4,2,4,2,8,2,2,4,4,4,4,2,4,4,4,2,8,2,4,4,4,2,4,2,4,4,4,2,4,4,4,4,4,2,8,2,4,4,2,4,8,2,4,4,8,2,4,2,4,4,4,4,8,2,4,2,4,2,8,4,4,4,4,2,8,4,4,4,4,4,4,2,4,4,4,2,8,2,4,8", "code": "\nfrom sympy import primefactors\ndef a(n): return 2**len(primefactors(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A034660", "text": "Sum of n-th powers of divisors of 12.", "sequence": "6,28,210,2044,22386,257908,3037530,36130444,431733666,5170140388,61978939050,743375541244,8918294543346,107006334784468,1283997101947770,15407492847694444,184887084343023426,2218628050709022148,26623434909949071690,319480609006403630044", "code": "\ndef a(n): return sum(d**n for d in [1, 2, 3, 4, 6, 12])\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A034665", "text": "Sum of n-th powers of divisors of 32.", "sequence": "6,63,1365,37449,1118481,34636833,1090785345,34630287489,1103823438081,35253226045953,1127000493261825,36046397799139329,1153203048319815681,36897992296869404673,1180663682709764194305", "code": " print([1+2**n+4**n+8**n+16**n+32**n for n in range(15)]) \n"}
{"sequence_id": "A034690", "text": "Sum of digits of all the divisors of n.", "sequence": "1,3,4,7,6,12,8,15,13,9,3,19,5,15,15,22,9,30,11,15,14,9,6,33,13,15,22,29,12,27,5,27,12,18,21,46,11,24,20,27,6,33,8,21,33,18,12,52,21,21,18,26,9,48,18,48,26,27,15,42,8,15,32,37,21,36,14,36,24,36,9,69,11,24,34", "code": "\nfrom sympy import divisors\ndef sd(n): return sum(map(int, str(n)))\ndef a(n): return sum(sd(d) for d in divisors(n))\nprint([a(n) for n in range(1, 76)]) \n"}
{"sequence_id": "A034696", "text": "Dirichlet convolution of primes (A000040) with themselves.", "sequence": "4,12,20,37,44,82,68,118,117,182,124,296,164,274,298,375,236,512,268,612,462,502,332,950,509,650,642,924,436,1310,508,1108,858,910,970,1831,628,1054,1078,1942,716,2034,764,1680,1764,1294,844,2968,1197,2136,1522", "code": "\nfrom sympy import divisors, prime, primerange\ndef dirichlet(f, g, n): return sum(f[d] * g[n//d] for d in divisors(n))\ndef aupton(terms):\n  p = [0] + list(primerange(2, prime(terms)+1))\n  return [dirichlet(p, p, k) for k in range(1, terms+1)]\nprint(aupton(51)) \n"}
{"sequence_id": "A034708", "text": "Numbers for which the sum of reciprocals of digits is an integer.", "sequence": "1,11,22,111,122,212,221,236,244,263,326,333,362,424,442,623,632,1111,1122,1212,1221,1236,1244,1263,1326,1333,1362,1424,1442,1623,1632,2112,2121,2136,2144,2163,2211,2222,2316,2361,2414,2441,2488,2613,2631,2666", "code": "\nfrom fractions import Fraction\ndef srd(n): return sum(Fraction(1, int(d)) for d in str(n)) \ndef ok(n): return False if '0' in str(n) else srd(n).denominator == 1\ndef aupto(nn): return [m for m in range(1, nn+1) if ok(m)]\nprint(aupto(2666)) \n"}
{"sequence_id": "A034709", "text": "Numbers divisible by their last digit.", "sequence": "1,2,3,4,5,6,7,8,9,11,12,15,21,22,24,25,31,32,33,35,36,41,42,44,45,48,51,52,55,61,62,63,64,65,66,71,72,75,77,81,82,84,85,88,91,92,93,95,96,99,101,102,104,105,111,112,115,121,122,123,124,125,126,128,131,132", "code": "\nA034709_list = [n for n in range(1, 1000) if n % 10 and not n % (n % 10)]\n\n"}
{"sequence_id": "A034808", "text": "Concatenation of 'prevprime(n) and n' is a prime.", "sequence": "3,9,37,39,51,63,87,89,111,117,123,153,157,163,173,177,183,207,211,213,217,219,239,249,257,263,267,269,273,277,279,289,321,323,327,333,337,339,343,359,369,379,407,423,439,441,459,471,473,477,479,489,497,513", "code": "\nfrom sympy import isprime, prevprime\ndef aupto(m):\n  return [k for k in range(3, m+1) if isprime(int(str(prevprime(k))+str(k)))]\nprint(aupto(513)) \n"}
{"sequence_id": "A034809", "text": "Numbers k such that the concatenation of k and previous_prime(k) is a prime.", "sequence": "4,5,9,10,16,24,33,36,42,46,51,53,56,59,63,66,67,69,75,76,78,81,87,96,102,106,108,111,114,116,123,125,129,130,135,137,144,145,147,148,153,156,159,170,171,177,179,180,184,187,190,192,195,196,198,207,211,214", "code": "\nfrom sympy import isprime, prevprime\ndef ok(n): return isprime(int(str(n) + str(prevprime(n))))\nprint(list(filter(ok, range(3, 215)))) \n"}
{"sequence_id": "A034822", "text": "Numbers n such that there are no palindromic squares of length n.", "sequence": "2,4,8,10,14,18,20,24,30,38,40", "code": "\nfrom sympy import integer_nthroot as iroot\ndef ispal(n): s = str(n); return s == s[::-1]\ndef ok(n):\n  for r in range(iroot(10**(n-1), 2)[0] + 1, iroot(10**n, 2)[0]):\n    if ispal(r*r): return False\n  return True\nprint([m for m in range(1, 16) if ok(m)]) \n"}
{"sequence_id": "A034838", "text": "Numbers k that are divisible by every digit of k.", "sequence": "1,2,3,4,5,6,7,8,9,11,12,15,22,24,33,36,44,48,55,66,77,88,99,111,112,115,122,124,126,128,132,135,144,155,162,168,175,184,212,216,222,224,244,248,264,288,312,315,324,333,336,366,384,396,412,424,432,444,448", "code": "\nA034838_list = []\nfor g in range(1,4):\n    for n in product('123456789',repeat=g):\n        s = ''.join(n)\n        m = int(s)\n        if not any(m % int(d) for d in s):\n            A034838_list.append(m) \n"}
{"sequence_id": "A034838", "text": "Numbers k that are divisible by every digit of k.", "sequence": "1,2,3,4,5,6,7,8,9,11,12,15,22,24,33,36,44,48,55,66,77,88,99,111,112,115,122,124,126,128,132,135,144,155,162,168,175,184,212,216,222,224,244,248,264,288,312,315,324,333,336,366,384,396,412,424,432,444,448", "code": "\nfor n in range(10**3):\n    s = str(n)\n    if '0' not in s:\n        c = 0\n        for i in s:\n            if n%int(i):\n                c += 1\n                break\n        if not c:\n            print(n,end=', ') \n"}
{"sequence_id": "A034838", "text": "Numbers k that are divisible by every digit of k.", "sequence": "1,2,3,4,5,6,7,8,9,11,12,15,22,24,33,36,44,48,55,66,77,88,99,111,112,115,122,124,126,128,132,135,144,155,162,168,175,184,212,216,222,224,244,248,264,288,312,315,324,333,336,366,384,396,412,424,432,444,448", "code": " \nfrom math import gcd\ndef lcm(a, b): return a * b // gcd(a, b)\ndef inF(q): return q[0]%q[1] == 0\ndef delta(q, c): return ((10*q[0]+c)%2520, lcm(q[1], c))\ndef ok(n):\n    q = (0, 1)\n    for c in map(int, str(n)):\n        if c == 0: return False \n        else: q = delta(q, c)\n    return inF(q)\nprint(list(filter(ok, range(450)))) \n"}
{"sequence_id": "A034868", "text": "Left half of Pascal's triangle.", "sequence": "1,1,1,2,1,3,1,4,6,1,5,10,1,6,15,20,1,7,21,35,1,8,28,56,70,1,9,36,84,126,1,10,45,120,210,252,1,11,55,165,330,462,1,12,66,220,495,792,924,1,13,78,286,715,1287,1716,1,14,91,364,1001,2002,3003,3432,1,15", "code": "\nimport math\nfrom sympy import binomial\nfor n in range(15):\n    print([binomial(n, k) for k in range(int(math.floor(n/2)) + 1)]) \n"}
{"sequence_id": "A034869", "text": "Right half of Pascal's triangle.", "sequence": "1,1,2,1,3,1,6,4,1,10,5,1,20,15,6,1,35,21,7,1,70,56,28,8,1,126,84,36,9,1,252,210,120,45,10,1,462,330,165,55,11,1,924,792,495,220,66,12,1,1716,1287,715,286,78,13,1,3432,3003,2002,1001,364,91,14,1", "code": "\nimport math\nfrom sympy import binomial\nfor n in range(15):\n    print([binomial(n, k) for k in range(math.ceil(n/2), n + 1)]) \n"}
{"sequence_id": "A034874", "text": "a(n) = n times the reverse of a(n-1).", "sequence": "1,2,6,24,210,72,189,7848,76383,383670,840213,3744576,87808149,1318532292,43835371965,910677661344,7533835192323,58192476900426,1185618381154515,103090236763316220,474880720273896321", "code": "\nA034874_list, a = [1], 1\nfor n in range(2,100):\n....a = n*int(str(a)[::-1])\n....A034874_list.append(a) \n"}
{"sequence_id": "A034883", "text": "Maximum length of Euclidean algorithm starting with n and any nonnegative i<n.", "sequence": "0,1,2,2,3,2,3,4,3,3,4,4,5,4,4,4,4,5,5,4,6,4,5,4,5,5,5,5,6,6,6,5,5,7,5,5,6,5,6,6,6,6,6,6,6,6,7,6,7,7,6,6,6,5,8,6,6,6,6,7,6,6,6,7,7,7,7,7,7,6,7,6,7,7,7,8,6,6,8,8,8,7,7,6,7,7,7,7,9,6,7,7,7,7,7,6,8,7,7,7", "code": "\ndef euclid_steps(a,b):\n    step_count = 0\n    while(b != 0):\n        a , b = b , a % b\n        step_count += 1\n    return step_count\nfor n in range(1,1001):\n    l = 0\n    for i in range(n): l = max(l,euclid_steps(n,i))\n    print(str(n)+\" \"+str(l)) \n"}
{"sequence_id": "A034895", "text": "Dropping any digit gives a prime number.", "sequence": "22,23,25,27,32,33,35,37,52,53,55,57,72,73,75,77,111,113,117,119,131,137,171,173,179,197,311,317,371,411,413,417,431,437,471,473,611,617,671,711,713,719,731,1013,1031,1037,1073,1079,1097,1379,1397,1499,1673", "code": " from sympy import isprime\ndef is_A034895(n):\n....s = str(n)\n....return n>9 and all(isprime(int(s[:i]+s[i+1:])) for i in range(len(s)))\n\n"}
{"sequence_id": "A034924", "text": "Numbers k such that 47^k-46 is prime.", "sequence": "5,11,13,53,115,899,2287", "code": "\nfrom sympy import isprime\ndef afind(limit, startat=1):\n  pow47 = 47**startat\n  for k in range(startat, limit+1):\n    if isprime(pow47 - 46): print(k, end=\", \")\n    pow47 *= 47\nafind(900) \n"}
{"sequence_id": "A034945", "text": "Successive approximations to 7-adic integer sqrt(2).", "sequence": "0,3,10,108,2166,4567,38181,155830,1802916,24862120,266983762,1961835256,5916488742,19757775943,116646786350,9611769806236,42844700375837,275475214363044,6789129606004840,75182500718243698", "code": "\ndef a034945(n):\n    ary=[0]\n    a, mod=3, 7\n    while len(ary) - 1<n:\n        b=a%mod\n        if b!=ary[-1]: ary.append(b)\n        a=b**2 + b - 2\n        mod*=7\n    return ary\nprint(a034945(100)) \n"}
{"sequence_id": "A034947", "text": "Jacobi (or Kronecker) symbol (-1/n).", "sequence": "1,1,-1,1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,1", "code": "\ndef A034947(n):\n    s = bin(n)[2:]\n    m = len(s)\n    i = s[::-1].find('1')\n    return 1-2*int(s[m-i-2]) if m-i-2 >= 0 else 1 \n"}
{"sequence_id": "A034955", "text": "Even triangular numbers with prime indices.", "sequence": "6,28,66,190,276,496,946,1128,1770,2278,2556,3160,3486,5356,5778,8128,8646,9730,11476,13366,14028,16110,18336,19900,22366,24976,25878,28680,31626,34716,36856,40186,47278,48516,54946,60378,64620,67528,72010,73536,87990", "code": "\nfrom sympy import primerange\ndef aupto(lim):\n    pitri = (p*(p+1)//2 for p in primerange(2, int((2*lim)**.5)+1))\n    return [t for t in pitri if t%2 == 0]\nprint(aupto(90000)) \n"}
{"sequence_id": "A034968", "text": "Minimal number of factorials that add to n.", "sequence": "0,1,1,2,2,3,1,2,2,3,3,4,2,3,3,4,4,5,3,4,4,5,5,6,1,2,2,3,3,4,2,3,3,4,4,5,3,4,4,5,5,6,4,5,5,6,6,7,2,3,3,4,4,5,3,4,4,5,5,6,4,5,5,6,6,7,5,6,6,7,7,8,3,4,4,5,5,6,4,5,5,6,6,7,5,6,6,7,7,8,6,7,7,8,8,9,4,5,5,6,6,7,5,6,6,7", "code": "\ndef a(n):\n    k=2\n    r=0\n    while n>0:\n        r+=n%k\n        n=n//k\n        k+=1\n    return r\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A035016", "text": "Fourier coefficients of E_{0,4}.", "sequence": "1,-16,112,-448,1136,-2016,3136,-5504,9328,-12112,14112,-21312,31808,-35168,38528,-56448,74864,-78624,84784,-109760,143136,-154112,149184,-194688,261184,-252016,246176,-327040,390784,-390240,395136,-476672,599152,-596736", "code": "\nfrom sympy import divisors\ndef a(n): return 1 if n==0 else 16*sum((-1)**d*d**3 for d in divisors(n))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A035057", "text": "Numbers n such that 2^n does not contain the digit 1 (probably finite).", "sequence": "1,2,3,5,6,8,11,12,15,16,19,23,25,28,32,33,35,38,43,52,56,59,63,66,73,91", "code": "\nA035057_list = [n for n in range(1,10**3) if '1' not in str(2**n)] \n"}
{"sequence_id": "A035059", "text": "Numbers k such that 2^k does not contain the digit 4 (probably finite).", "sequence": "0,1,3,4,5,7,8,9,13,15,16,17,21,23,24,29,40,41,43,55,69,75,85,107", "code": "\nN = 200; modder = 10**N; REPORT = 10**5\ndef ok(s):  return '4' not in s\ndef ok1(n): return ok(str(pow(2, n, modder)))\ndef afind(limit, startk=0, verbose=False):\n    full_tests = 0\n    for k in range(startk, limit):\n        if ok1(k):\n            full_tests += 1\n            if ok(str(pow(2, k))): print(k, end=\", \")\n        if verbose and k and k%REPORT == 0:\n            print(\"[ ...\", k, full_tests, \"]\")\n        k += 1\nafind(10**6, verbose=True) \n"}
{"sequence_id": "A035070", "text": "a(n) is root of square starting with digit 3: first term of runs.", "sequence": "6,18,55,174,548,1733,5478,17321,54773,173206,547723,1732051,5477226,17320509,54772256,173205081,547722558,1732050808,5477225576,17320508076,54772255751,173205080757,547722557506,1732050807569,5477225575052,17320508075689,54772255750517", "code": "\nfrom math import isqrt\ndef a(n): return isqrt(3*10**n) + 1\nprint([a(n) for n in range(1, 28)]) \n"}
{"sequence_id": "A035073", "text": "a(n) is root of square starting with digit 6: first term of runs.", "sequence": "8,25,78,245,775,2450,7746,24495,77460,244949,774597,2449490,7745967,24494898,77459667,244948975,774596670,2449489743,7745966693,24494897428,77459666925,244948974279,774596669242,2449489742784,7745966692415,24494897427832,77459666924149", "code": "\nfrom math import isqrt\ndef a(n): return isqrt(6*10**n) + 1\nprint([a(n) for n in range(1, 28)]) \n"}
{"sequence_id": "A035075", "text": "a(n) = ceiling(sqrt(8*10^n)).", "sequence": "9,29,90,283,895,2829,8945,28285,89443,282843,894428,2828428,8944272,28284272,89442720,282842713,894427191,2828427125,8944271910,28284271248,89442719100,282842712475,894427191000,2828427124747", "code": "\nfrom math import isqrt\ndef a(n): return isqrt(8*10**n) + 1\nprint([a(n) for n in range(1, 25)]) \n"}
{"sequence_id": "A035132", "text": "Nonsquarefree palindromes.", "sequence": "4,8,9,44,88,99,121,171,212,232,242,252,272,292,333,343,363,404,414,424,444,464,484,525,575,585,616,636,656,666,676,686,696,747,808,828,848,868,888,909,999,1331,1881,2112,2332,2552,2662,2772,2992,3663,3773", "code": "\nfrom itertools import product\nfrom sympy.ntheory.factor_ import core\ndef palsthru(maxdigits):\n  midrange = [[\"\"], [str(i) for i in range(10)]]\n  for digits in range(1, maxdigits+1):\n    for p in product(\"0123456789\", repeat=digits//2):\n      left = \"\".join(p)\n      if len(left) and left[0] == '0': continue\n      for middle in midrange[digits%2]: yield int(left+middle+left[::-1])\ndef okpal(p): return p > 3 and core(p, 2) != p\nprint(list(filter(okpal, palsthru(4)))) \n"}
{"sequence_id": "A035134", "text": "Squarefree composite palindromes.", "sequence": "6,22,33,55,66,77,111,141,161,202,222,262,282,303,323,393,434,454,474,494,505,515,535,545,555,565,595,606,626,646,707,717,737,767,777,818,838,858,878,898,939,949,959,969,979,989,1001,1111,1221,1441,1551,1661", "code": "\nfrom itertools import product\nfrom sympy import factorint, isprime\ndef pals(d, base=10): \n    digits = \"\".join(str(i) for i in range(base))\n    for p in product(digits, repeat=d//2):\n        if d > 1 and p[0] == \"0\": continue\n        left = \"\".join(p); right = left[::-1]\n        for mid in [[\"\"], digits][d%2]: yield int(left + mid + right)\ndef ok(pal): f = factorint(pal); return len(f)>1 and all(f[p]<2 for p in f)\nprint(list(filter(ok, (p for d in range(1, 5) for p in pals(d) if ok(p))))) \n"}
{"sequence_id": "A035139", "text": "Digits of prime factors of k do not appear in k.", "sequence": "1,4,6,8,9,10,14,16,18,21,27,34,38,40,44,46,48,49,54,56,57,58,60,64,66,68,69,76,78,80,81,84,86,87,88,90,96,98,99,100,106,108,111,116,118,129,134,140,144,146,148,158,160,161,166,168,174,177,180,184,188,189,196", "code": "\nfrom sympy import factorint\ndef ok(n):\n    return set(str(n)) & set(\"\".join(str(p) for p in factorint(n))) == set()\nprint(list(filter(ok, range(1601))))  \n"}
{"sequence_id": "A035237", "text": "Smallest number that has exactly n substrings which are square.", "sequence": "2,0,10,49,100,1000,1441,4900,11449,104900,144100,490000,1440000,1144900,11144900,16810000,114490049,156250000,114490000,1114490000,1681000000", "code": "\nLIMIT = 10**7\nss = set(str(i*i) for i in range(int(LIMIT**.5)+2))\ndef num_square_substrings(s):\n  return sum(s[i:j] in ss for i in range(len(s)) for j in range(i+1, len(s)+1))\ndef agen():\n  n, k, data = 0, 0, dict()\n  while True:\n    if n in data: yield data[n]; n += 1; continue\n    while True:\n      if k > LIMIT: assert False, \"LIMIT exceeded\"\n      nss = num_square_substrings(str(k))\n      if nss == n: data[n] = k; yield k; break\n      elif nss > n:\n        if nss not in data: data[nss] = k\n      k += 1\n    n += 1\ng = agen()\nfor i in range(13): print(next(g)) \n"}
{"sequence_id": "A035287", "text": "Number of ways to place a non-attacking white and black rook on n X n chessboard.", "sequence": "0,4,36,144,400,900,1764,3136,5184,8100,12100,17424,24336,33124,44100,57600,73984,93636,116964,144400,176400,213444,256036,304704,360000,422500,492804,571536,659344,756900,864900,984064,1115136,1258884", "code": "\nfor n in range(100):\n  print(((n+1)*n)**2) \n"}
{"sequence_id": "A035310", "text": "Let f(n) = number of ways to factor n = A001055(n); a(n) = sum of f(k) over all terms k in A025487 that have n factors.", "sequence": "1,4,12,47,170,750,3255,16010,81199,448156,2579626,15913058,102488024,698976419,4976098729,37195337408,289517846210,2352125666883,19841666995265,173888579505200,1577888354510786,14820132616197925,143746389756336173,1438846957477988926", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import divisors, isprime, prime\nfrom operator import mul\n@cacheit\ndef g(n, k):\n    return (0 if n > k else 1) + (0 if isprime(n) else sum(g(n//d, d) for d in divisors(n)[1:-1] if d <= k))\n@cacheit\ndef b(n, i, l):\n    if n==0:\n        p = reduce(mul, (prime(t + 1)**l[t] for t in range(len(l))))\n        return g(p, p)\n    else:\n        return 0 if i<1 else sum([b(n - i*j, i - 1, l + [i]*j) for j in range(n//i + 1)])\ndef a(n):\n    return b(n, n, [])\nfor n in range(1, 11): print(a(n)) \n"}
{"sequence_id": "A035327", "text": "Write n in binary, interchange 0's and 1's, convert back to decimal.", "sequence": "1,0,1,0,3,2,1,0,7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46", "code": "\ndef a(n): return int(''.join('1' if i == '0' else '0' for i in bin(n)[2:]), 2) \n"}
{"sequence_id": "A035327", "text": "Write n in binary, interchange 0's and 1's, convert back to decimal.", "sequence": "1,0,1,0,3,2,1,0,7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46", "code": "\ndef a(n): return 1 if n == 0 else n^((1 << n.bit_length()) - 1)\nprint([a(n) for n in range(100)]) \n"}
{"sequence_id": "A035336", "text": "a(n) = 2*floor(n*phi) + n - 1, where phi = (1+sqrt(5))/2.", "sequence": "2,7,10,15,20,23,28,31,36,41,44,49,54,57,62,65,70,75,78,83,86,91,96,99,104,109,112,117,120,125,130,133,138,143,146,151,154,159,164,167,172,175,180,185,188,193,198,201,206,209,214,219,222,227,230,235,240", "code": "\nfrom sympy import floor\nfrom mpmath import phi\ndef a(n): return 2*floor(n*phi) + n - 1 \n"}
{"sequence_id": "A035337", "text": "Third column of Wythoff array.", "sequence": "3,11,16,24,32,37,45,50,58,66,71,79,87,92,100,105,113,121,126,134,139,147,155,160,168,176,181,189,194,202,210,215,223,231,236,244,249,257,265,270,278,283,291,299,304,312", "code": "\nfrom sympy import floor\nfrom mpmath import phi\ndef a(n): return 3*floor((n + 1)*phi) + 2*n \n"}
{"sequence_id": "A035485", "text": "Card on top of deck at n-th stage of R. K. Guy's shuffling problem.", "sequence": "1,2,3,1,6,5,9,1,4,2,16,10,12,14,23,16,18,20,17,27,30,33,38,10,14,37,32,6,11,19,53,37,25,21,12,34,38,8,50,48,46,14,18,23,47,53,84,52,31,49,1,51,91,61,42,79,4,29,6,49,26,23,115,4,70,93,109,11,16,19,49,18,124,97,70,10,134,111,7,38,14,79,11,129", "code": "\ndef aupton(terms):\n  alst, deck = [1], list(range(1, 2*terms+1))\n  for n in range(1, terms+1):\n    first, next = deck[:n], deck[n:2*n]\n    deck[0:2*n:2] = next\n    deck[1:2*n:2] = first\n    alst.append(deck[0])\n  return alst\nprint(aupton(83)) \n"}
{"sequence_id": "A035513", "text": "Wythoff array read by antidiagonals.", "sequence": "1,2,4,3,7,6,5,11,10,9,8,18,16,15,12,13,29,26,24,20,14,21,47,42,39,32,23,17,34,76,68,63,52,37,28,19,55,123,110,102,84,60,45,31,22,89,199,178,165,136,97,73,50,36,25,144,322,288,267,220,157,118,81,58,41,27,233,521", "code": "\nfrom sympy import fibonacci as F, sqrt\nimport math\ntau = (sqrt(5) + 1)/2\ndef T(n, k): return F(k + 1)*int(math.floor(n*tau)) + F(k)*(n - 1)\nfor n in range(1, 11): print([T(k, n - k + 1) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A035523", "text": "Reverse and add (in base 3).", "sequence": "1,2,4,8,16,32,96,160,320,960,1600,2880,3520,6080,11200,21440,62400,86080,169280,338560,648248,1902840,3281200,6404832,6510784,12950936,25744192,51882584,156278688,261609208,506142216,531792640,1008314456,2014504120", "code": "\ndef reversedigits(n, b=10): \n    x, y = n, 0\n    while x >= b:\n        x, r = divmod(x, b)\n        y = b*y + r\n    return b*y + x\nA035523_list, l = [1], 1\nfor _ in range(50):\n    l += reversedigits(l, 3)\n    A035523_list.append(l)\n \n"}
{"sequence_id": "A035524", "text": "Reverse and add (in base 4).", "sequence": "1,2,4,5,10,20,25,50,85,170,340,425,850,1385,3070,6140,10225,15335,29410,65135,129070,317675,1280860,2163725,3999775,7999550,20321515,81946460,138412045,255852575,511705150,1300234475,5242880860", "code": "\ndef reversedigits(n, b=10): \n....x, y = n, 0\n....while x >= b:\n........x, r = divmod(x, b)\n........y = b*y + r\n....return b*y + x\nA035524_list, l = [1], 1\nfor _ in range(50):\n....l += reversedigits(l,4)\n....A035524_list.append(l)\n"}
{"sequence_id": "A035526", "text": "Reverse and add (in binary).", "sequence": "1,10,11,110,1001,10010,11011,110110,1010001,10010110,11111111,111111110,1011111101,10111111010,100011110111,1011111101000,1101011100101,10111111010000,11001011001101,101111110100000", "code": "\nfrom itertools import accumulate, repeat\ndef iterate(n, _): b = str(n); return int(bin(int(b, 2)+int(b[::-1], 2))[2:])\ndef aupto(nn): return list(accumulate(repeat(1, nn), iterate))\nprint(aupto(20)) \n"}
{"sequence_id": "A035531", "text": "a(n) = A000120(n) + A001221(n) - 1.", "sequence": "0,1,2,1,2,3,3,1,2,3,3,3,3,4,5,1,2,3,3,3,4,4,4,3,3,4,4,4,4,6,5,1,3,3,4,3,3,4,5,3,3,5,4,4,5,5,5,3,3,4,5,4,4,5,6,4,5,5,5,6,5,6,7,1,3,4,3,3,4,5,4,3,3,4,5,4,5,6,5,3,3,4,4,5,5,5,6,4,4,6,6,5,6,6,7,3,3,4,5,4,4,6,5,4,6,5,5,5,5,7,7", "code": "\nfrom sympy import primefactors\ndef a(n): return 0 if n<2 else bin(n)[2:].count(\"1\") + len(primefactors(n)) - 1 \n"}
{"sequence_id": "A035614", "text": "Horizontal para-Fibonacci sequence: says which column of Wythoff array (starting column count at 0) contains n.", "sequence": "0,1,2,0,3,0,1,4,0,1,2,0,5,0,1,2,0,3,0,1,6,0,1,2,0,3,0,1,4,0,1,2,0,7,0,1,2,0,3,0,1,4,0,1,2,0,5,0,1,2,0,3,0,1,8,0,1,2,0,3,0,1,4,0,1,2,0,5,0,1,2,0,3,0,1,6,0,1,2,0,3", "code": "\nfrom sympy import fibonacci\ndef a122840(n): return len(str(n)) - len(str(int(str(n)[::-1])))\ndef a014417(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef a(n): return a122840(a014417(n + 1)) \n"}
{"sequence_id": "A035928", "text": "Numbers n such that BCR(n) = n, where BCR = binary-complement-and-reverse = take one's complement then reverse bit order.", "sequence": "2,10,12,38,42,52,56,142,150,170,178,204,212,232,240,542,558,598,614,666,682,722,738,796,812,852,868,920,936,976,992,2110,2142,2222,2254,2358,2390,2470,2502,2618,2650,2730,2762,2866,2898,2978,3010,3132,3164,3244", "code": "\ndef comp(s): z, o = ord('0'), ord('1'); return s.translate({z:o, o:z})\ndef BCR(n): return int(comp(bin(n)[2:])[::-1], 2)\ndef aupto(limit): return [m for m in range(limit+1) if BCR(m) == m]\nprint(aupto(3244)) \n"}
{"sequence_id": "A035930", "text": "Maximal product of any two numbers whose concatenation is n.", "sequence": "0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,0,2,4,6,8,10,12,14,16,18,0,3,6,9,12,15,18,21,24,27,0,4,8,12,16,20,24,28,32,36,0,5,10,15,20,25,30,35,40,45,0,6,12,18,24,30,36,42,48,54,0,7,14,21,28,35,42,49,56,63,0,8,16,24,32,40,48,56,64,72,0,9,18,27,36,45,54,63,72,81,0,10,20,30,40,50,60,70", "code": "\ndef a(n):\n    s = str(n)\n    return max((int(s[:i])*int(s[i:]) for i in range(1, len(s))), default=0)\nprint([a(n) for n in range(108)]) \n"}
{"sequence_id": "A036044", "text": "BCR(n): write in binary, complement, reverse.", "sequence": "1,0,2,0,6,2,4,0,14,6,10,2,12,4,8,0,30,14,22,6,26,10,18,2,28,12,20,4,24,8,16,0,62,30,46,14,54,22,38,6,58,26,42,10,50,18,34,2,60,28,44,12,52,20,36,4,56,24,40,8,48,16,32,0,126,62,94,30,110,46,78,14,118,54,86", "code": "\ndef comp(s): z, o = ord('0'), ord('1'); return s.translate({z:o, o:z})\ndef BCR(n): return int(comp(bin(n)[2:])[::-1], 2)\nprint([BCR(n) for n in range(75)]) \n"}
{"sequence_id": "A036059", "text": "The summarize Fibonacci sequence: summarize the previous two terms!.", "sequence": "1,1,21,1221,3231,233231,533221,15534221,3514334231,3534533241,3544832231,183544733221,28172544634231,2827162554535241,2827265554337241,2837267544338231,3847264544637221,3847362564636221,2837662564536221,2827863534537221,3837564524538221", "code": "\ndef aupton(nn):\n  alst = [1, 1]\n  for n in range(2, nn+1):\n    prev2, anstr = sorted(str(alst[-2]) + str(alst[-1])), \"\"\n    for d in sorted(set(prev2), reverse=True):\n      anstr += str(prev2.count(d)) + d\n    alst.append(int(anstr))\n  return alst\nprint(aupton(20)) \n"}
{"sequence_id": "A036110", "text": "A summarize Fibonacci sequence: summarize the previous two terms!.", "sequence": "2,2,22,32,1332,332211,433231,14533231,1524632231,162524534241,263544336241,363564435231,463554733221,17364544733221,37263554634231,37363554734231,37364544933221,1937263554933221,3927263544835231,391827264534836231,293827363544836231", "code": "\ndef aupton(nn):\n  alst = [2, 2]\n  for n in range(2, nn+1):\n    prev2, anstr = sorted(str(alst[-2]) + str(alst[-1])), \"\"\n    for d in sorted(set(prev2), reverse=True):\n      anstr += str(prev2.count(d)) + d\n    alst.append(int(anstr))\n  return alst\nprint(aupton(20)) \n"}
{"sequence_id": "A036119", "text": "a(n) = 3^n mod 17.", "sequence": "1,3,9,10,13,5,15,11,16,14,8,7,4,12,2,6,1,3,9,10,13,5,15,11,16,14,8,7,4,12,2,6,1,3,9,10,13,5,15,11,16,14,8,7,4,12,2,6,1,3,9,10,13,5,15,11,16,14,8,7,4,12,2,6,1,3,9,10", "code": " for n in range(0, 100): print(int(pow(3, n, 17)), end=' ') \n"}
{"sequence_id": "A036120", "text": "a(n) = 2^n mod 19.", "sequence": "1,2,4,8,16,13,7,14,9,18,17,15,11,3,6,12,5,10,1,2,4,8,16,13,7,14,9,18,17,15,11,3,6,12,5,10,1,2,4,8,16,13,7,14,9,18,17,15,11,3,6,12,5,10,1,2,4,8,16,13,7,14,9,18,17,15", "code": " for n in range(0, 100): print(int(pow(2, n, 19)), end=' ') \n"}
{"sequence_id": "A036128", "text": "a(n) = 2^n mod 53.", "sequence": "1,2,4,8,16,32,11,22,44,35,17,34,15,30,7,14,28,3,6,12,24,48,43,33,13,26,52,51,49,45,37,21,42,31,9,18,36,19,38,23,46,39,25,50,47,41,29,5,10,20,40,27,1,2,4,8,16,32,11,22", "code": " for n in range(0, 100): print(int(pow(2, n, 53)), end=' ') \n"}
{"sequence_id": "A036131", "text": "a(n) = 2^n mod 67.", "sequence": "1,2,4,8,16,32,64,61,55,43,19,38,9,18,36,5,10,20,40,13,26,52,37,7,14,28,56,45,23,46,25,50,33,66,65,63,59,51,35,3,6,12,24,48,29,58,49,31,62,57,47,27,54,41,15,30,60,53", "code": " for n in range(0, 100): print(int(pow(2, n, 67)), end=' ') \n"}
{"sequence_id": "A036132", "text": "a(n) = 7^n mod 71.", "sequence": "1,7,49,59,58,51,2,14,27,47,45,31,4,28,54,23,19,62,8,56,37,46,38,53,16,41,3,21,5,35,32,11,6,42,10,70,64,22,12,13,20,69,57,44,24,26,40,67,43,17,48,52,9,63,15,34,25,33", "code": " for n in range(0, 100): print(int(pow(7, n, 71)), end=' ') \n"}
{"sequence_id": "A036133", "text": "a(n) = 5^n mod 73.", "sequence": "1,5,25,52,41,59,3,15,2,10,50,31,9,45,6,30,4,20,27,62,18,17,12,60,8,40,54,51,36,34,24,47,16,7,35,29,72,68,48,21,32,14,70,58,71,63,23,42,64,28,67,43,69,53,46,11,55,56", "code": " for n in range(0, 100): print(int(pow(5, n, 73)), end=' ') \n"}
{"sequence_id": "A036134", "text": "a(n) = 3^n mod 79.", "sequence": "1,3,9,27,2,6,18,54,4,12,36,29,8,24,72,58,16,48,65,37,32,17,51,74,64,34,23,69,49,68,46,59,19,57,13,39,38,35,26,78,76,70,52,77,73,61,25,75,67,43,50,71,55,7,21,63,31,14", "code": " for n in range(0, 100): print(int(pow(3, n, 79)), end=' ') \n"}
{"sequence_id": "A036135", "text": "a(n) = 2^n mod 83.", "sequence": "1,2,4,8,16,32,64,45,7,14,28,56,29,58,33,66,49,15,30,60,37,74,65,47,11,22,44,5,10,20,40,80,77,71,59,35,70,57,31,62,41,82,81,79,75,67,51,19,38,76,69,55,27,54,25,50,17", "code": " for n in range(0, 100): print(int(pow(2, n, 83)), end=' ') \n"}
{"sequence_id": "A036136", "text": "a(n) = 3^n mod 89.", "sequence": "1,3,9,27,81,65,17,51,64,14,42,37,22,66,20,60,2,6,18,54,73,41,34,13,39,28,84,74,44,43,40,31,4,12,36,19,57,82,68,26,78,56,79,59,88,86,80,62,8,24,72,38,25,75,47,52,67,23", "code": " for n in range(0, 100): print(int(pow(3, n, 89)), end=' ') \n"}
{"sequence_id": "A036137", "text": "a(n) = 5^n mod 97.", "sequence": "1,5,25,28,43,21,8,40,6,30,53,71,64,29,48,46,36,83,27,38,93,77,94,82,22,13,65,34,73,74,79,7,35,78,2,10,50,56,86,42,16,80,12,60,9,45,31,58,96,92,72,69,54,76,89,57,91,67", "code": " for n in range(0, 100): print(int(pow(5, n, 97)), end=' ') \n"}
{"sequence_id": "A036229", "text": "Smallest n-digit prime containing only digits 1 or 2 or -1 if no such prime exists.", "sequence": "2,11,211,2111,12211,111121,1111211,11221211,111112121,1111111121,11111121121,111111211111,1111111121221,11111111112221,111111112111121,1111111112122111,11111111111112121,111111111111112111,1111111111111111111,11111111111111212121", "code": "\nfrom sympy import isprime\ndef A036229(n):\n    k, r, m = (10**n-1)//9, 2**n-1, 0\n    while m <= r:\n        t = k+int(bin(m)[2:])\n        if isprime(t):\n            return t\n        m += 1\n    return -1 \n"}
{"sequence_id": "A036278", "text": "Denominators in Taylor series for cot x.", "sequence": "1,3,45,945,4725,93555,638512875,18243225,162820783125,38979295480125,1531329465290625,13447856940643125,201919571963756521875,11094481976030578125,564653660170076273671875,5660878804669082674070015625,31245110285511170603633203125", "code": "\nfrom sympy import bernoulli, factorial\ndef a(n):\n    return ((-4)**(n + 1)*bernoulli(2*n + 2)/factorial(2*n + 2)).denominator()\nprint([a(n) for n in range(-1, 20)]) \n"}
{"sequence_id": "A036289", "text": "a(n) = n*2^n.", "sequence": "0,2,8,24,64,160,384,896,2048,4608,10240,22528,49152,106496,229376,491520,1048576,2228224,4718592,9961472,20971520,44040192,92274688,192937984,402653184,838860800,1744830464,3623878656,7516192768,15569256448,32212254720", "code": " a=lambda n: n<<n \n"}
{"sequence_id": "A036299", "text": "Binary Fibonacci (or rabbit) sequence.", "sequence": "1,10,101,10110,10110101,1011010110110,101101011011010110101,1011010110110101101011011010110110,1011010110110101101011011010110110101101011011010110101", "code": "\ndef aupton(terms):\n  alst = [1, 10]\n  while len(alst) < terms: alst.append(int(str(alst[-1]) + str(alst[-2])))\n  return alst[:terms]\nprint(aupton(9)) \n"}
{"sequence_id": "A036301", "text": "Numbers whose sum of even digits and sum of odd digits are equal.", "sequence": "0,112,121,134,143,156,165,178,187,211,314,336,341,358,363,385,413,431,516,538,561,583,615,633,651,718,781,817,835,853,871,1012,1021,1034,1043,1056,1065,1078,1087,1102,1120,1201,1210,1223,1232,1245,1254,1267,1276,1289,1298", "code": "\ndef eodiff(n):\n  digs = list(map(int, str(n)))\n  return abs(sum(d for d in digs if d%2==0)-sum(d for d in digs if d%2==1))\ndef aupto(lim): return [m for m in range(lim+1) if eodiff(m) == 0]\nprint(aupto(1298)) \n"}
{"sequence_id": "A036303", "text": "Composite numbers whose prime factors contain no digits other than 1 and 3.", "sequence": "9,27,33,39,81,93,99,117,121,143,169,243,279,297,339,341,351,363,393,403,429,507,729,837,891,933,939,961,993,1017,1023,1053,1089,1179,1209,1243,1287,1331,1441,1469,1521,1573,1703,1859,2187,2197,2511,2673,2799", "code": "\nfrom sympy import factorint\ndef ok(n):\n    f = factorint(n)\n    return sum(f.values()) > 1 and all(set(str(p)) <= set(\"13\") for p in f)\nprint(list(filter(ok, range(2800)))) \n"}
{"sequence_id": "A036336", "text": "Smallest positive integer with n digits and exactly n prime factors (counted with multiplicity).", "sequence": "2,10,102,1012,10010,100040,1000125,10000096,100000032,1000000080,10000000080,100000000512,1000000001280,10000000014336,100000000004096,1000000000010880,10000000000008192,100000000000008192,1000000000000010240,10000000000000045056", "code": "\nfrom sympy import factorint\ndef a(n):\n  for m in range(10**(n-1), 10**n):\n    if sum(factorint(m).values()) == n: return m\nprint([a(n) for n in range(1, 13)]) \n"}
{"sequence_id": "A036433", "text": "Number of divisors is a digit in the base 10 representation of n.", "sequence": "1,2,14,23,29,34,46,63,68,74,76,78,88,94,116,127,128,134,138,141,142,143,145,146,164,182,184,186,189,194,196,211,214,223,227,229,233,236,238,239,241,247,248,249,251,254,257,258,261,263,268,269,271,274,277", "code": "\nfrom sympy import divisor_count\nA036433_list = []\nfor i in range(1,10**5):\n....d = divisor_count(i)\n....if d < 10 and str(d) in str(i):\n........A036433_list.append(i) \n"}
{"sequence_id": "A036448", "text": "Smallest positive number containing n e's when spelled out in US English.", "sequence": "2,1,3,11,17,111,117,317,1317,3317,11317,17317,111317,117317,317317,1317317,3317317,11317317,17317317,111317317,117317317,317317317,1317317317,3317317317,11317317317,17317317317,111317317317,117317317317,317317317317,1317317317317,3317317317317", "code": "\nfrom num2words import num2words\ndef A036448(n):\n    i = 1\n    while num2words(i).count(\"e\")!=n:\n        i += 1\n    return i\nprint([A036448(n) for n in range(1,12)]) \n"}
{"sequence_id": "A036554", "text": "Numbers whose binary representation ends in an odd number of zeros.", "sequence": "2,6,8,10,14,18,22,24,26,30,32,34,38,40,42,46,50,54,56,58,62,66,70,72,74,78,82,86,88,90,94,96,98,102,104,106,110,114,118,120,122,126,128,130,134,136,138,142,146,150,152,154,158,160,162,166,168,170,174", "code": "\ndef ok(n):\n  c = 0\n  while n%2 == 0: n //= 2; c += 1\n  return c%2 == 1\nprint([m for m in range(1, 175) if ok(m)]) \n"}
{"sequence_id": "A036581", "text": "Ternary Thue-Morse sequence: closed under a->abc, b->ac, c->b.", "sequence": "0,2,1,0,1,2,0,2,1,2,0,1,0,2,1,0,1,2,0,1,0,2,1,2,0,2,1,0,1,2,0,2,1,2,0,1,0,2,1,2,0,2,1,0,1,2,0,1,0,2,1,0,1,2,0,2,1,2,0,1,0,2,1,0,1,2,0,1,0,2,1,2,0,2,1,0,1,2,0,1,0,2,1,0,1,2,0,2,1,2,0,1,0,2,1,2,0,2,1", "code": "\ndef a010060(n): return bin(n)[2:].count(\"1\")%2\ndef a(n): return (a010060(n + 1) - a010060(n) - 1)%3 \n"}
{"sequence_id": "A036679", "text": "a(n) = n^n - n!.", "sequence": "0,0,2,21,232,3005,45936,818503,16736896,387057609,9996371200,285271753811,8915621446656,302868879571453,11111919647266816,437892582706491375,18446723150919663616,827239906198908668177,39346401672922831847424,1978419534015213180291979", "code": "\nfrom math import factorial\ndef a(n): return n**n - factorial(n)\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A036688", "text": "Number of distinct n-digit suffixes of base 10 squares not containing digit 0.", "sequence": "5,18,119,698,5449,41735,359207,3085197,27434602,243921771,2188569304,19636586858", "code": "\nfrom math import isqrt\ndef a(n):\n    suffixes = set()\n    for k in range(isqrt(10 ** (n - 1)) + 1, 10 ** n):\n        kk = k * k\n        s = str(kk)[-n:]\n        if \"0\" not in s and len(s) >= n:\n            suffixes.add(s)\n    return len(suffixes)\nprint([a(n) for n in range(1, 8)])  \n"}
{"sequence_id": "A036691", "text": "Compositorial numbers: product of first n composite numbers.", "sequence": "1,4,24,192,1728,17280,207360,2903040,43545600,696729600,12541132800,250822656000,5267275776000,115880067072000,2781121609728000,69528040243200000,1807729046323200000,48808684250726400000,1366643159020339200000", "code": "\nfrom sympy import factorial, primepi, primorial, composite\ndef A036691(n):\n    return factorial(composite(n))//primorial(primepi(composite(n))) if n > 0 else 1 \n"}
{"sequence_id": "A036839", "text": "RATS(n): Reverse Add Then Sort the digits.", "sequence": "0,2,4,6,8,1,12,14,16,18,11,22,33,44,55,66,77,88,99,11,22,33,44,55,66,77,88,99,11,112,33,44,55,66,77,88,99,11,112,123,44,55,66,77,88,99,11,112,123,134,55,66,77,88,99,11,112,123,134,145,66,77", "code": "\ndef A036839(n):\n    x = str(n+int(str(n)[::-1]))\n    return int(\"\".join(sorted(x))) \n"}
{"sequence_id": "A036937", "text": "Smallest n-digit prime containing only digits 2 and 3.", "sequence": "2,23,223,2333,23333,222323,2222333,22222223,222323333,2222232323,22222222223,222222333323,2222222222323,22222222223323,222222222332233,2222222222323223,22222222222233323,222222222222233323,2222222222222233333,22222222222222232233", "code": "\nfrom sympy import isprime\nfrom itertools import product\ndef a(n):\n  for b in product(\"01\", repeat=n):\n    m = int(\"\".join(b).replace(\"0\", \"2\").replace(\"1\", \"3\"))\n    if isprime(m): return m\n  return None\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A036953", "text": "Primes containing only digits from the set {0, 1, 2}.", "sequence": "2,11,101,211,1021,1201,2011,2111,2221,10111,10211,12011,12101,12211,20011,20021,20101,20201,21001,21011,21101,21121,21211,21221,22111,101021,101111,101221,102001,102101,102121,110221,111121,111211,112111", "code": " from gmpy2 import digits\nfrom sympy import isprime\n[int(digits(n,3)) for n in range(1000) if isprime(int(digits(n,3)))] \n"}
{"sequence_id": "A036967", "text": "4-full numbers: if a prime p divides k then so does p^4.", "sequence": "1,16,32,64,81,128,243,256,512,625,729,1024,1296,2048,2187,2401,2592,3125,3888,4096,5184,6561,7776,8192,10000,10368,11664,14641,15552,15625,16384,16807,19683,20000,20736,23328,28561,31104,32768,34992", "code": "\nfrom sympy import factorint\nA036967_list = [n for n in range(1,10**5) if min(factorint(n).values(),default=4) >= 4] \n"}
{"sequence_id": "A036987", "text": "Fredholm-Rueppel sequence.", "sequence": "1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom sympy import catalan\ndef a(n): return catalan(n)%2 \n"}
{"sequence_id": "A037015", "text": "Numbers n with property that, reading binary expansion of n from right to left, run lengths strictly increase.", "sequence": "0,1,3,6,7,14,15,28,30,31,57,60,62,63,120,121,124,126,127,241,248,249,252,254,255,483,496,497,504,505,508,510,511,966,993,995,1008,1009,1016,1017,1020,1022,1023,1987,1990,2016,2017,2019,2032,2033,2040,2041,2044", "code": "\nfrom itertools import groupby\nA037015_list = []\nfor n in range(10**5):\n    c = None\n    for x, y in groupby(bin(n)[2:]):\n        z = len(list(y))\n        if c != None and z >= c:\n            break\n        c = z\n    else:\n        A037015_list.append(n) \n"}
{"sequence_id": "A037024", "text": "Position of start of first occurrence of prime(n) after the decimal point in expansion of Pi.", "sequence": "6,9,4,13,94,110,95,37,16,186,137,46,2,23,119,8,4,219,98,39,299,13,26,11,12,852,3486,1487,206,362,297,1096,859,525,2606,393,1657,1410,1182,428,438,728,1944,168,37,704,93,135,484,185,229,1688,1707,1713,1006", "code": "\nfrom itertools import takewhile\nfrom sympy import S, prime, primerange\n\n\npi_digits = str(S.Pi.n(10**4))[1:] \ndef aupton(nn):\n    plocs = (pi_digits.find(str(p)) for p in primerange(2, prime(nn)+1))\n    return list(takewhile(lambda x: x>=0, plocs)) \nprint(aupton(55)) \n"}
{"sequence_id": "A037101", "text": "Trajectory of 3 under map n->7n+1 if n odd, n->n/2 if n even.", "sequence": "3,22,11,78,39,274,137,960,480,240,120,60,30,15,106,53,372,186,93,652,326,163,1142,571,3998,1999,13994,6997,48980,24490,12245,85716,42858,21429,150004,75002,37501,262508,131254,65627,459390,229695,1607866,803933", "code": "\ndef iter(n): return 7*n+1 if n%2 == 1 else n//2\ndef aupton(terms):\n  alst = [3]\n  for n in range(1, terms+1): alst.append(iter(alst[-1]))\n  return alst\nprint(aupton(43)) \n"}
{"sequence_id": "A037102", "text": "Trajectory of 3 under map n->9n+1 if n odd, n->n/2 if n even.", "sequence": "3,28,14,7,64,32,16,8,4,2,1,10,5,46,23,208,104,52,26,13,118,59,532,266,133,1198,599,5392,2696,1348,674,337,3034,1517,13654,6827,61444,30722,15361,138250,69125,622126,311063,2799568,1399784,699892,349946,174973", "code": "\nfrom itertools import accumulate\ndef f(n, _): return 9*n+1 if n%2 == 1 else n//2\ndef aupton(terms): return list(accumulate([3]*terms, f))\nprint(aupton(48)) \n"}
{"sequence_id": "A037254", "text": "Triangle read by rows: T(n,k) (n >= 1, 1 <= k< = n) gives number of non-distorting tie-avoiding integer vote weights.", "sequence": "1,1,2,2,3,4,3,5,6,7,6,9,11,12,13,11,17,20,22,23,24,22,33,39,42,44,45,46,42,64,75,81,84,86,87,88,84,126,148,159,165,168,170,171,172,165,249,291,313,324,330,333,335,336,337,330,495,579,621,643,654,660,663,665", "code": "\ndef T(n, k):\n    if k==1:\n        if n==1: return 1\n        else: return T(n - 1, (n + 1)//2)\n    return T(n, 1) + T(n - 1, k - 1)\nfor n in range(1, 12): print([T(n, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A037255", "text": "For n weights, number of combinations when limited to two weights per pan.", "sequence": "0,1,4,12,31,70,141,259,442,711,1090,1606,2289,3172,4291,5685,7396,9469,11952,14896,18355,22386,27049,32407,38526,45475,53326,62154,72037,83056,95295,108841,123784,140217,158236,177940,199431,222814,248197,275691,305410", "code": "\nfrom __future__ import division\nA037255_list = [n*(n*(n*(n - 2) + 7) + 2)//8 for n in range(10**3)] \n"}
{"sequence_id": "A037264", "text": "Numbers whose sum of reciprocals of digits is the reciprocal of an integer.", "sequence": "1,2,3,4,5,6,7,8,9,22,36,44,63,66,88,236,244,263,326,333,362,424,442,488,623,632,666,848,884,999,2488,2666,2848,2884,3366,3446,3464,3636,3644,3663,4288,4346,4364,4436,4444,4463,4634,4643,4828,4882,6266,6336", "code": "\nfrom fractions import Fraction\ndef ok(n):\n    ds = list(map(int, str(n)))\n    return 0 not in ds and sum(Fraction(1, d) for d in ds).numerator == 1\nprint(list(filter(ok, range(1, 6337)))) \n"}
{"sequence_id": "A037268", "text": "Sum of reciprocals of digits = 1.", "sequence": "1,22,236,244,263,326,333,362,424,442,623,632,2488,2666,2848,2884,3366,3446,3464,3636,3644,3663,4288,4346,4364,4436,4444,4463,4634,4643,4828,4882,6266,6336,6344,6363,6434,6443,6626,6633,6662,8248,8284,8428,8482,8824", "code": "\nfrom fractions import Fraction\ndef ok(n):\n  sn = str(n)\n  return False if '0' in sn else sum(Fraction(1, int(d)) for d in sn) == 1\ndef aupto(limit): return [m for m in range(1, limit+1) if ok(m)]\nprint(aupto(8824)) \n"}
{"sequence_id": "A037270", "text": "a(n) = n^2*(n^2 + 1)/2.", "sequence": "0,1,10,45,136,325,666,1225,2080,3321,5050,7381,10440,14365,19306,25425,32896,41905,52650,65341,80200,97461,117370,140185,166176,195625,228826,266085,307720,354061,405450,462241,524800,593505,668746,750925,840456,937765", "code": " for n in range(0,30): print(n**2*(n**2+1)/2, end=', ') \n"}
{"sequence_id": "A037273", "text": "Number of steps to reach a prime under \"replace n with concatenation of its prime factors\", or -1 if no prime is ever reached.", "sequence": "-1,0,0,2,0,1,0,13,2,4,0,1,0,5,4,4,0,1,0,15,1,1,0,2,3,4,4,1,0,2,0,2,1,5,3,2,0,2,1,9,0,2,0,9,6,1,0,15", "code": "\nfrom sympy import factorint\ndef a(n):\n    if n < 2: return -1\n    klst, f = [n], sorted(factorint(n, multiple=True))\n    while len(f) > 1:\n        klst.append(int(\"\".join(map(str, f))))\n        f = sorted(factorint(klst[-1], multiple=True))\n    return len(klst) - 1\nprint([a(n) for n in range(1, 49)]) \n"}
{"sequence_id": "A037276", "text": "Start with 1; for n>1, replace n with the concatenation of its prime factors in increasing order.", "sequence": "1,2,3,22,5,23,7,222,33,25,11,223,13,27,35,2222,17,233,19,225,37,211,23,2223,55,213,333,227,29,235,31,22222,311,217,57,2233,37,219,313,2225,41,237,43,2211,335,223,47,22223,77,255,317,2213,53,2333", "code": "\nfrom sympy import factorint\ndef a(n):\n    f=factorint(n)\n    l=sorted(f)\n    return 1 if n==1 else int(\"\".join(str(i)*f[i] for i in l))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A037277", "text": "Replace n with concatenation of its divisors >1.", "sequence": "0,2,3,24,5,236,7,248,39,2510,11,234612,13,2714,3515,24816,17,236918,19,2451020,3721,21122,23,234681224,525,21326,3927,2471428,29,2356101530,31,2481632,31133,21734,5735,23469121836,37,21938,31339", "code": "\nfrom sympy import divisors\ndef a(n):\n  divisors_gt1 = divisors(n)[1:]\n  if len(divisors_gt1) == 0: return 0\n  else: return int(\"\".join(str(d) for d in divisors_gt1))\nprint([a(n) for n in range(1, 40)]) \n"}
{"sequence_id": "A037278", "text": "Replace n with concatenation of its divisors.", "sequence": "1,12,13,124,15,1236,17,1248,139,12510,111,1234612,113,12714,13515,124816,117,1236918,119,12451020,13721,121122,123,1234681224,1525,121326,13927,12471428,129,12356101530,131,12481632,131133,121734,15735,123469121836,137", "code": "\nfrom sympy import divisors\ndef a(n): return int(\"\".join(str(d) for d in divisors(n)))\nprint([a(n) for n in range(1, 35)]) \n"}
{"sequence_id": "A037283", "text": "Replace n with concatenation of its odd divisors.", "sequence": "1,1,13,1,15,13,17,1,139,15,111,13,113,17,13515,1,117,139,119,15,13721,111,123,13,1525,113,13927,17,129,13515,131,1,131133,117,15735,139,137,119,131339,15,141,13721,143,111,13591545,123,147,13,1749,1525,131751", "code": "\nfrom sympy import divisors\ndef a(n): return int(\"\".join(str(d) for d in divisors(n) if d%2==1))\nprint([a(n) for n in range(1, 52)]) \n"}
{"sequence_id": "A037284", "text": "Replace n with concatenation of its odd divisors >1.", "sequence": "0,0,3,0,5,3,7,0,39,5,11,3,13,7,3515,0,17,39,19,5,3721,11,23,3,525,13,3927,7,29,3515,31,0,31133,17,5735,39,37,19,31339,5,41,3721,43,11,3591545,23,47,3,749,525,31751", "code": "\nfrom sympy import divisors\ndef a(n):\n  odd_divisors_gt1 = [d for d in divisors(n)[1:] if d%2 == 1]\n  if len(odd_divisors_gt1) == 0: return 0\n  else: return int(\"\".join(str(d) for d in odd_divisors_gt1))\nprint([a(n) for n in range(1, 52)]) \n"}
{"sequence_id": "A037285", "text": "Replace n with concatenation of its nontrivial odd divisors.", "sequence": "0,0,0,0,0,3,0,0,3,5,0,3,0,7,35,0,0,39,0,5,37,11,0,3,5,13,39,7,0,3515,0,0,311,17,57,39,0,19,313,5,0,3721,0,11,35915,23,0,3,7,525,317,13,0,3927,511,7,319,29,0,3515,0,31,37921,0,513,31133,0,17,323,5735,0,39,0", "code": "\nfrom sympy import divisors\ndef a(n):\n  nontrivial_odd_divisors = [d for d in divisors(n)[1:-1] if d%2 == 1]\n  if len(nontrivial_odd_divisors) == 0: return 0\n  else: return int(\"\".join(str(d) for d in nontrivial_odd_divisors))\nprint([a(n) for n in range(1, 70)]) \n"}
{"sequence_id": "A037308", "text": "Numbers whose base-2 and base-10 expansions have the same digit sum.", "sequence": "0,1,20,21,122,123,202,203,222,223,230,231,302,303,410,411,502,503,1130,1131,1150,1151,1202,1203,1212,1213,1230,1231,1300,1301,1402,1403,1502,1503,1510,1511,2006,2007,2032,2033,2102,2103,2200,2201,3006,3007,3012", "code": "\ndef ok(n): return sum(map(int, str(n))) == sum(map(int, bin(n)[2:]))\nprint(list(filter(ok, range(3013)))) \n"}
{"sequence_id": "A037335", "text": "Numbers whose base-8 and base-10 expansions have the same digit sum.", "sequence": "1,2,3,4,5,6,7,70,71,130,131,132,133,134,135,260,261,262,263,320,321,322,323,324,325,326,327,390,391,450,451,452,453,454,455,1080,1081,1082,1083,1084,1085,1086,1087,1144,1145,1146,1147,1148,1149,1208,1209,1272", "code": "\ndef ok(n): return sum(map(int, str(n))) == sum(map(int, oct(n)[2:]))\nprint(list(filter(ok, range(1, 1273)))) \n"}
{"sequence_id": "A037406", "text": "Numbers k such that every base-8 digit of k is a base-10 digit of k.", "sequence": "1,2,3,4,5,6,7,45,105,127,235,274,365,436,487,614,713,731,1017,1024,1025,1026,1032,1042,1124,1162,1206,1233,1234,1235,1243,1273,1426,1462,1603,1630,1653,1723,1737,1739,1743,1753,2048", "code": "\ndef ok(n): return set(oct(n)[2:]) <= set(str(n))\nprint(list(filter(ok, range(1, 2049)))) \n"}
{"sequence_id": "A037445", "text": "Number of infinitary divisors (or i-divisors) of n.", "sequence": "1,2,2,2,2,4,2,4,2,4,2,4,2,4,4,2,2,4,2,4,4,4,2,8,2,4,4,4,2,8,2,4,4,4,4,4,2,4,4,8,2,8,2,4,4,4,2,4,2,4,4,4,2,8,4,8,4,4,2,8,2,4,4,4,4,8,2,4,4,8,2,8,2,4,4,4,4,8,2,4,2,4,2,8,4,4,4,8,2,8,4,4,4,4,4,8,2,4,4,4,2,8,2,8,8", "code": "\nfrom sympy import factorint\ndef wt(n): return bin(n).count(\"1\")\ndef a(n):\n    f=factorint(n)\n    return 2**sum([wt(f[i]) for i in f]) \n"}
{"sequence_id": "A037497", "text": "Base-4 digits are, in order, the first n terms of the periodic sequence with initial period 1,0,2.", "sequence": "1,4,18,73,292,1170,4681,18724,74898,299593,1198372,4793490,19173961,76695844,306783378,1227133513,4908534052,19634136210,78536544841,314146179364,1256584717458,5026338869833,20105355479332,80421421917330", "code": " print([2*4**n//7 for n in range(1, 25)]) \n"}
{"sequence_id": "A037576", "text": "Base-4 digits are, in order, the first n terms of the periodic sequence with initial period 1,3.", "sequence": "1,7,29,119,477,1911,7645,30583,122333,489335,1957341,7829367,31317469,125269879,501079517,2004318071,8017272285,32069089143,128276356573,513105426295,2052421705181,8209686820727,32838747282909", "code": " print([7*4**n//15 for n in range(1,30)]) \n"}
{"sequence_id": "A037583", "text": "Base 4 digits are, in order, the first n terms of the periodic sequence with initial period 3,1.", "sequence": "3,13,55,221,887,3549,14199,56797,227191,908765,3635063,14540253,58161015,232644061,930576247,3722304989,14889219959,59556879837,238227519351,952910077405,3811640309623,15246561238493,60986244953975", "code": " print([13*4**n//15 for n in range(1,30)]) \n"}
{"sequence_id": "A037604", "text": "Base-4 digits are, in order, the first n terms of the periodic sequence with initial period 1,2,3.", "sequence": "1,6,27,109,438,1755,7021,28086,112347,449389,1797558,7190235,28760941,115043766,460175067,1840700269,7362801078,29451204315,117804817261,471219269046,1884877076187,7539508304749,30158033218998", "code": " print([3*4**n//7 for n in range(1,24)]) \n"}
{"sequence_id": "A037861", "text": "(Number of 0's) - (number of 1's) in the base-2 representation of n.", "sequence": "1,-1,0,-2,1,-1,-1,-3,2,0,0,-2,0,-2,-2,-4,3,1,1,-1,1,-1,-1,-3,1,-1,-1,-3,-1,-3,-3,-5,4,2,2,0,2,0,0,-2,2,0,0,-2,0,-2,-2,-4,2,0,0,-2,0,-2,-2,-4,0,-2,-2,-4,-2,-4,-4,-6,5,3,3,1,3,1,1,-1,3", "code": "\ndef A037861(n):\n    return 2*format(n,'b').count('0')-len(format(n,'b')) \n"}
{"sequence_id": "A037916", "text": "Concatenate exponents in prime factorization of n.", "sequence": "0,1,1,2,1,11,1,3,2,11,1,21,1,11,11,4,1,12,1,21,11,11,1,31,2,11,3,21,1,111,1,5,11,11,11,22,1,11,11,31,1,111,1,21,21,11,1,41,2,12,11,21,1,13,11,31,11,11,1,211,1,11,21,6,11,111,1,21,11,111,1,32,1,11,12,21,11,111", "code": "\nfrom sympy import factorint\ndef a(n): return 0 if n<2 else int(\"\".join(map(str, factorint(n).values())))\nprint([a(n) for n in range(1, 79)]) \n"}
{"sequence_id": "A037920", "text": "Trajectory of 8 under prime factor concatenation procedure.", "sequence": "8,2,2,2,2,3,37,3,19,41,3,3,3,7,13,13,3,11123771,7,149,317,941,229,31219729,11,2084656339,3,347,911,118189,11,613,496501723,97,130517,917327,53,1832651281459,3,3,3,11,139,653,3863,5107", "code": "\nfrom sympy import factorint\ndef iterate(n):\n    flst, f = [n], sorted(factorint(n, multiple=True))\n    while len(f) > 1:\n        flst += f\n        f = sorted(factorint(int(\"\".join(map(str, f))), multiple=True))\n    return flst\nprint(iterate(8)) \n"}
{"sequence_id": "A037967", "text": "a(n) = (C(2*n,n)^2+C(2*n,n))/2.", "sequence": "1,3,21,210,2485,31878,427350,5891028,82824885,1181976510,17067482146,248817506028,3656231188246,54086245380300,804670817838300,12030722583033960,180648817921816245,2722858996178147310,41179040361190612650,624643836563467851900", "code": "\nfrom gmpy2 import bincoef\ndef A037967(n):\n    return bincoef(bincoef(2*n,n)+1,2) \n"}
{"sequence_id": "A037970", "text": "Numbers whose maximal base-2 run length is 3.", "sequence": "7,8,14,17,23,24,28,29,34,35,39,40,46,49,55,56,57,58,59,68,69,70,71,72,78,81,87,88,92,93,98,99,103,104,110,113,114,115,116,117,118,119,136,137,138,139,140,141,142,145,151,152,156,157,162,163,167,168,174", "code": "\ndef ok(n):\n    b = bin(n)[2:]\n    return (\"000\" in b or \"111\" in b) and not (\"0000\" in b or \"1111\" in b)\nprint(list(filter(ok, range(175)))) \n"}
{"sequence_id": "A038003", "text": "Odd Catalan numbers; more precisely, A000108(2^n-1).", "sequence": "1,1,5,429,9694845,14544636039226909,94295850558771979787935384946380125,11311095732253345760960290897769189975961199415637572612957718759342193629", "code": "\nfrom __future__ import division\nA038003_list, c, s = [1, 1], 1, 3\nfor n in range(2,10**5+1):\n....c = (c*(4*n-2))//(n+1)\n....if n == s:\n........A038003_list.append(c)\n........s = 2*s+1 \n"}
{"sequence_id": "A038129", "text": "Beatty sequence for cube root of 2.", "sequence": "0,1,2,3,5,6,7,8,10,11,12,13,15,16,17,18,20,21,22,23,25,26,27,28,30,31,32,34,35,36,37,39,40,41,42,44,45,46,47,49,50,51,52,54,55,56,57,59,60,61,62,64,65,66,68,69,70,71,73,74,75,76,78,79,80,81,83,84,85,86,88,89", "code": "\nfrom sympy import integer_nthroot\ndef A038129(n): return integer_nthroot(2*n**3,3)[0] \n"}
{"sequence_id": "A038183", "text": "One-dimensional cellular automaton 'sigma-minus' (Rule 90): 000,001,010,011,100,101,110,111 -> 0,1,0,1,1,0,1,0.", "sequence": "1,5,17,85,257,1285,4369,21845,65537,327685,1114129,5570645,16843009,84215045,286331153,1431655765,4294967297,21474836485,73014444049,365072220245,1103806595329,5519032976645,18764712120593,93823560602965", "code": "\na=1\nfor n in range(55):\n    print(a, end=\",\")\n    a ^= a*4\n\n"}
{"sequence_id": "A038186", "text": "Numbers divisible by the sum and product of their digits.", "sequence": "1,2,3,4,5,6,7,8,9,12,24,36,111,112,132,135,144,216,224,312,315,432,612,624,735,1116,1212,1296,1332,1344,1416,2112,2232,2916,3132,3168,3276,3312,4112,4224,6624,6912,8112,9612,11112,11115,11133,11172,11232", "code": "\nfrom math import prod\ndef sd(n): return sum(map(int, str(n)))\ndef pd(n): return prod(map(int, str(n)))\ndef ok(n): return n%sd(n) == 0 and pd(n) and n%pd(n) == 0\ndef aupto(limit): return [m for m in range(1, limit+1) if ok(m)]\nprint(aupto(11233)) \n"}
{"sequence_id": "A038189", "text": "Bit to left of least significant 1-bit in binary expansion of n.", "sequence": "0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1", "code": "\ndef A038189(n):\n    s = bin(n)[2:]\n    m = len(s)\n    i = s[::-1].find('1')\n    return int(s[m-i-2]) if m-i-2 >= 0 else 0 \n"}
{"sequence_id": "A038199", "text": "Row sums of triangle T(m,n) = number of solutions to 1 <= a(1) < a(2) < ... < a(m) <= n, where gcd(a(1), a(2), ..., a(m), n) = 1, in A020921.", "sequence": "1,2,6,12,30,54,126,240,504,990,2046,4020,8190,16254,32730,65280,131070,261576,524286,1047540,2097018,4192254,8388606,16772880,33554400,67100670,134217216,268419060,536870910,1073708010,2147483646", "code": "\nfrom sympy import mobius, divisors\ndef a(n): return sum(mobius(n//d) * (2**d - 1) for d in divisors(n))\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A038206", "text": "Can express a(n) with the digits of a(n)^2 in order, only adding plus signs.", "sequence": "0,1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000,1296,1702,1782,2223,2728,3366,3646,3682,4132,4879,4906,4950,5050,5149,5292,6832,7191,7272,7389", "code": "\ndef expr(t, d): \n    if t < 0: return False\n    if t == int(d): return True\n    return any(expr(t-int(d[:i]), d[i:]) for i in range(1, len(d)))\ndef ok(n): return expr(n, str(n*n))\nprint(list(filter(ok, range(7500)))) \n"}
{"sequence_id": "A038366", "text": "n is divisible by (product of digits) + (sum of digits).", "sequence": "10,19,20,29,30,39,40,42,49,50,59,60,69,70,79,80,89,90,99,100,102,108,110,120,126,132,140,150,180,190,200,201,204,207,209,210,220,230,240,270,280,285,300,306,308,312,320,330,360,370,400,402,405,407,408,410", "code": "\nfrom math import prod\ndef ok(n): d = list(map(int, str(n))); return n and n%(sum(d)+prod(d)) == 0\nprint([k for k in range(411) if ok(k)]) \n"}
{"sequence_id": "A038395", "text": "Concatenation of the first n odd numbers in reverse order.", "sequence": "1,31,531,7531,97531,1197531,131197531,15131197531,1715131197531,191715131197531,21191715131197531,2321191715131197531,252321191715131197531,27252321191715131197531,2927252321191715131197531,312927252321191715131197531", "code": "\ndef a(n): return int(\"\".join(map(str, range(2*n-1, 0, -2))))\nprint([a(n) for n in range(1, 17)]) \n"}
{"sequence_id": "A038470", "text": "Sums of 2 distinct powers of 4.", "sequence": "5,17,20,65,68,80,257,260,272,320,1025,1028,1040,1088,1280,4097,4100,4112,4160,4352,5120,16385,16388,16400,16448,16640,17408,20480,65537,65540,65552,65600,65792,66560,69632,81920,262145,262148,262160", "code": "\ndef aupto(limit):\n  p = [4**i for i in range(limit//4+1) if 4**i < limit]\n  p2 = set(a+b for i, a in enumerate(p) for b in p[i+1:] if a+b <= limit)\n  return sorted(p2)\nprint(aupto(265000)) \n"}
{"sequence_id": "A038474", "text": "Sums of two distinct powers of 5.", "sequence": "6,26,30,126,130,150,626,630,650,750,3126,3130,3150,3250,3750,15626,15630,15650,15750,16250,18750,78126,78130,78150,78250,78750,81250,93750,390626,390630,390650,390750,391250,393750,406250,468750,1953126,1953130,1953150", "code": "\nfrom itertools import combinations, count, takewhile\ndef aupto(lim):\n  p = takewhile(lambda x: x<= lim, (5**i for i in count(0)))\n  t = (sum(c) for c in combinations(p, 2))\n  return sorted(filter(lambda x: x <= lim, t))\nprint(aupto(10**6)) \n"}
{"sequence_id": "A038529", "text": "n-th prime - n-th composite.", "sequence": "-2,-3,-3,-2,1,1,3,4,7,11,11,16,19,19,22,27,32,33,37,39,40,45,48,53,59,62,63,65,65,68,81,83,88,89,98,99,103,108,111,116,121,121,129,130,133,134,145,155,158,159,161,165,166,175,180,185,189,190,195,197,198,207", "code": "\nfrom sympy import prime, composite\ndef A038529(n):\n    return prime(n)-composite(n) \n"}
{"sequence_id": "A038554", "text": "Derivative of n: write n in binary, replace each pair of adjacent bits with their mod 2 sum (a(0)=a(1)=0 by convention). Also n XOR (n shift 1).", "sequence": "0,0,1,0,2,3,1,0,4,5,7,6,2,3,1,0,8,9,11,10,14,15,13,12,4,5,7,6,2,3,1,0,16,17,19,18,22,23,21,20,28,29,31,30,26,27,25,24,8,9,11,10,14,15,13,12,4,5,7,6,2,3,1,0,32,33,35,34,38,39,37,36,44,45,47,46,42,43,41,40,56,57", "code": "\nimport math\ndef a003188(n): return n^(n>>1)\ndef a(n): return 0 if n<2 else a003188(n) - 2**int(math.floor(math.log(a003188(n), 2))) \n"}
{"sequence_id": "A038567", "text": "Denominators in canonical bijection from positive integers to positive rationals <= 1.", "sequence": "1,2,3,3,4,4,5,5,5,5,6,6,7,7,7,7,7,7,8,8,8,8,9,9,9,9,9,9,10,10,10,10,11,11,11,11,11,11,11,11,11,11,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,15,15,15,15,15,15,15,15,16,16,16,16,16,16", "code": "\nfrom sympy import totient\ndef a(n):\n    s=1\n    while sum(totient(i) for i in range(1, s + 1))<n: s+=1\n    return s \n"}
{"sequence_id": "A038568", "text": "Numerators in canonical bijection from positive integers to positive rationals.", "sequence": "1,1,2,1,3,2,3,1,4,3,4,1,5,2,5,3,5,4,5,1,6,5,6,1,7,2,7,3,7,4,7,5,7,6,7,1,8,3,8,5,8,7,8,1,9,2,9,4,9,5,9,7,9,8,9,1,10,3,10,7,10,9,10,1,11,2,11,3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,1,12,5,12,7,12,11,12,1,13,2", "code": "\nfrom sympy import totient, gcd\ndef a(n):\n    s=1\n    k=2\n    while s<n:\n        s+=2*totient(k)\n        k+=1\n    s-=2*totient(k - 1)\n    j=1\n    while s<n:\n        if gcd(j, k - 1)==1: s+=2\n        j+=1\n    if s>n: return j - 1\n    return k - 1 \n"}
{"sequence_id": "A038569", "text": "Denominators in canonical bijection from positive integers to positive rationals.", "sequence": "1,2,1,3,1,3,2,4,1,4,3,5,1,5,2,5,3,5,4,6,1,6,5,7,1,7,2,7,3,7,4,7,5,7,6,8,1,8,3,8,5,8,7,9,1,9,2,9,4,9,5,9,7,9,8,10,1,10,3,10,7,10,9,11,1,11,2,11,3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,12,1,12,5,12,7,12,11,13,1,13", "code": "\nfrom sympy import totient, gcd\ndef a(n):\n    s=1\n    k=2\n    while s<=n:\n        s+=2*totient(k)\n        k+=1\n    s-=2*totient(k - 1)\n    j=1\n    while s<=n:\n        if gcd(j, k - 1)==1: s+=2\n        j+=1\n    if s>n + 1: return k - 1\n    return j - 1 \n"}
{"sequence_id": "A038572", "text": "a(n) = n rotated one binary place to the right.", "sequence": "0,1,1,3,2,6,3,7,4,12,5,13,6,14,7,15,8,24,9,25,10,26,11,27,12,28,13,29,14,30,15,31,16,48,17,49,18,50,19,51,20,52,21,53,22,54,23,55,24,56,25,57,26,58,27,59,28,60,29,61,30,62,31,63,32,96,33,97,34,98,35,99,36,100", "code": "\ndef A038572(n):\n    x = bin(n)[2:]\n    return int(x[-1]+x[:-1],2) \n"}
{"sequence_id": "A038585", "text": "Write n in binary, delete 0's.", "sequence": "1,1,11,1,11,11,111,1,11,11,111,11,111,111,1111,1,11,11,111,11,111,111,1111,11,111,111,1111,111,1111,1111,11111,1,11,11,111,11,111,111,1111,11,111,111,1111,111,1111,1111,11111,11,111,111,1111,111,1111,1111", "code": "\ndef A038585(n):\n    return int(bin(n)[2:].replace('0','')) \n"}
{"sequence_id": "A038603", "text": "Primes not containing the digit '1'.", "sequence": "2,3,5,7,23,29,37,43,47,53,59,67,73,79,83,89,97,223,227,229,233,239,257,263,269,277,283,293,307,337,347,349,353,359,367,373,379,383,389,397,409,433,439,443,449,457,463,467,479,487,499,503,509,523,547,557", "code": "\nfrom sympy import nextprime\ni=p=1\nwhile i<=500:\n    p = nextprime(p)\n    if '1' not in str(p):\n        print(str(i)+\" \"+str(p))\n        i+=1\n\n\n"}
{"sequence_id": "A038604", "text": "Primes not containing the digit '2'.", "sequence": "3,5,7,11,13,17,19,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397", "code": "\nfrom sympy import isprime, nextprime\ndef is_A038604(n): return str(n).find('2')<0 and isprime(n)\ndef next_A038604(n): \n    while True:\n        n = nextprime(n); s = str(n); t = s.find('2')\n        if t < 0: return n\n        t = 10**(len(s)-1-t); n += t - n%t\ndef A038604_upto(stop=math.inf, start=3):\n    while start < stop: yield start; start = next_A038604(start)\nlist(A038604_upto(400))\n\n"}
{"sequence_id": "A038611", "text": "Primes not containing the digit '3'.", "sequence": "2,5,7,11,17,19,29,41,47,59,61,67,71,79,89,97,101,107,109,127,149,151,157,167,179,181,191,197,199,211,227,229,241,251,257,269,271,277,281,401,409,419,421,449,457,461,467,479,487,491,499,509,521,541,547,557", "code": "\nfrom sympy import isprime\ni=j=1\nwhile j<=5000:\n    if isprime(i) and \"3\" not in str(i):\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A038617", "text": "Primes not containing the digit '9'.", "sequence": "2,3,5,7,11,13,17,23,31,37,41,43,47,53,61,67,71,73,83,101,103,107,113,127,131,137,151,157,163,167,173,181,211,223,227,233,241,251,257,263,271,277,281,283,307,311,313,317,331,337,347,353,367,373,383,401,421", "code": "\nfrom sympy import isprime\ni = 1\nwhile i <= 300:\n    if \"9\" not in str(i) and isprime(i):\n        print(str(i), end=\",\")\n    i += 1 \n"}
{"sequence_id": "A038625", "text": "a(n) is smallest number m such that m = n*pi(m), where pi(k) = number of primes <= k (A000720).", "sequence": "2,27,96,330,1008,3059,8408,23526,64540,175197,480852,1304498,3523884,9557955,25874752,70115412,189961182,514272411,1394193580,3779849598,10246935644,27788566029,75370121160,204475052375,554805820452,1505578023621,4086199301996,11091501630949", "code": "\nfrom math import exp\nfrom sympy import primepi\ndef a(n):\n  m = 2 if n == 2 else int(exp(n)) \n  while m != n*primepi(m): m += 1\n  return m\nprint([a(n) for n in range(2, 10)]) \n"}
{"sequence_id": "A038770", "text": "Numbers divisible by at least one of their digits.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,24,25,26,28,30,31,32,33,35,36,39,40,41,42,44,45,48,50,51,52,55,60,61,62,63,64,65,66,70,71,72,75,77,80,81,82,84,85,88,90,91,92,93,95,96,99,100,101,102", "code": "\ndef ok(n): return any(n%int(d) == 0 for d in str(n) if d != '0')\nprint(list(filter(ok, range(1, 103)))) \n"}
{"sequence_id": "A038772", "text": "Numbers not divisible by any of their digits.", "sequence": "23,27,29,34,37,38,43,46,47,49,53,54,56,57,58,59,67,68,69,73,74,76,78,79,83,86,87,89,94,97,98,203,207,209,223,227,229,233,239,247,249,253,257,259,263,267,269,277,283,289,293,299,307,308,323,329,334,337,338", "code": "\ndef ok(n): return not any(n%int(d) == 0 for d in str(n) if d != '0')\nprint(list(filter(ok, range(1, 339)))) \n"}
{"sequence_id": "A039276", "text": "Numbers whose base-3 representation has the same nonzero number of 0's and 2's.", "sequence": "6,11,15,19,21,32,34,38,42,46,48,56,58,60,64,66,72,89,95,97,101,103,105,113,115,119,123,127,129,137,139,141,145,147,153,167,169,173,175,177,181,183,191,193,195,199,201,207,217,219,225,260,266,268,278,284", "code": "\nfrom sympy.ntheory import count_digits\ndef ok(n): d = count_digits(n, 3); return 0 in d and 2 in d and d[0] == d[2]\nprint(list(filter(ok, range(285)))) \n"}
{"sequence_id": "A039283", "text": "Numbers whose base-5 representation has the same nonzero number of 0's and 1's.", "sequence": "5,27,28,29,35,40,45,51,55,76,80,101,105,126,130,137,138,139,142,143,144,147,148,149,150,177,178,179,185,190,195,202,203,204,210,215,220,227,228,229,235,240,245,257,258,259,261,266,271,277,278,279,285,290", "code": "\nfrom sympy.ntheory import count_digits\ndef ok(n): c = count_digits(n, 5); return 0 in c and 1 in c and c[0] == c[1]\nprint(list(filter(ok, range(291)))) \n"}
{"sequence_id": "A039284", "text": "Numbers whose base-5 representation has the same nonzero number of 0's and 2's.", "sequence": "10,27,35,51,53,54,55,65,70,77,85,102,110,132,136,138,139,142,147,152,160,176,178,179,180,190,195,202,210,227,235,252,256,258,259,260,266,268,269,271,273,274,276,278,279,280,290,295,300,326,328,329,330,340", "code": "\nfrom sympy.ntheory import count_digits\ndef ok(n): c = count_digits(n, b=5); return c[0] == c[2] > 0\nprint([k for k in range(341) if ok(k)]) \n"}
{"sequence_id": "A039723", "text": "Numbers in base -10.", "sequence": "0,1,2,3,4,5,6,7,8,9,190,191,192,193,194,195,196,197,198,199,180,181,182,183,184,185,186,187,188,189,170,171,172,173,174,175,176,177,178,179,160,161,162,163,164,165,166,167,168,169,150,151,152,153,154,155", "code": "\ndef A039723(n):\n    s, q = '', n\n    while q >= 10 or q < 0:\n        q, r = divmod(q, -10)\n        if r < 0:\n            q += 1\n            r += 10\n        s += str(r)\n    return int(str(q)+s[::-1]) \n"}
{"sequence_id": "A039724", "text": "Numbers in base -2.", "sequence": "0,1,110,111,100,101,11010,11011,11000,11001,11110,11111,11100,11101,10010,10011,10000,10001,10110,10111,10100,10101,1101010,1101011,1101000,1101001,1101110,1101111,1101100,1101101,1100010,1100011,1100000,1100001,1100110,1100111,1100100", "code": "\ndef A039724(n):\n    s, q = '', n\n    while q >= 2 or q < 0:\n        q, r = divmod(q, -2)\n        if r < 0:\n            q += 1\n            r += 2\n        s += str(r)\n    return int(str(q)+s[::-1]) \n"}
{"sequence_id": "A039752", "text": "Ruth-Aaron numbers (2): sum of prime divisors of n = sum of prime divisors of n+1 (both taken with multiplicity).", "sequence": "5,8,15,77,125,714,948,1330,1520,1862,2491,3248,4185,4191,5405,5560,5959,6867,8280,8463,10647,12351,14587,16932,17080,18490,20450,24895,26642,26649,28448,28809,33019,37828,37881,41261,42624,43215,44831,44891,47544,49240", "code": "\nfrom sympy import factorint\ndef aupton(terms):\n  alst, k, sopfrk, sopfrkp1 = [], 2, 2, 3\n  while len(alst) < terms:\n    if sopfrkp1 == sopfrk: alst.append(k)\n    k += 1\n    fkp1 = factorint(k+1)\n    sopfrk, sopfrkp1 = sopfrkp1, sum(p*fkp1[p] for p in fkp1)\n  return alst\nprint(aupton(42)) \n"}
{"sequence_id": "A039824", "text": "Number of different coefficient values in expansion of Product (1+q^1+q^3...+q^(2i-1)), i=1 to n.", "sequence": "1,2,4,11,20,31,46,61,78,97,118,141,166,193,222,253,286,321,358,397,438,481,526,573,622,673,726,781,838,897,958,1021,1086,1153,1222,1293,1366,1441,1518,1597,1678,1761,1846,1933,2022,2113,2206,2301,2398,2497", "code": "\ndef get(d, x): return d[x] if len(d) > x >= 0 else 0\ndef convolve(a, b):\n    r = []\n    for x in range(len(a) + len(b) - 1):\n        n = 0\n        for k in range(x + 1): n += get(a, k) * get(b, x - k)\n        r.append(n)\n    return r\ndef unique_in(d):\n    out = list([])\n    for elem in d:\n        if elem not in out: out.append(elem)\n    return len(out)\ndef A039824(x):\n    seed = [0**k + k % 2 for k in range(2*(x+1))]\n    product = seed[0:2]\n    out = list([1])\n    for k in range(2, x + 1):\n        product = convolve(product, seed[0:2*k])\n        out.append(unique_in(product))\n    return out\n\n"}
{"sequence_id": "A039935", "text": "Smallest k for which k, 2k, ... nk all contain the digit 4.", "sequence": "4,24,47,471,487,1248,1249,6248,6249,6249,12493,12493,12493,12493,12498,31249,62499,62499,62499,62499,62499,62499,62499,62499,62499,62499,62499,62499,62499,62499,62499,312497,312497,312497,624984,624984,624984,624984,624984", "code": "\ndef aupton(terms):\n  k, n, alst = 1, 1, []\n  while len(alst) < terms:\n    while not all(str(i*k).count('4') > 0 for i in range(1, n+1)): k += 1\n    while str(n*k).count('4') > 0: alst.append(k); n += 1\n    k += 1\n  return alst[:terms]\nprint(aupton(39)) \n"}
{"sequence_id": "A039942", "text": "Number of points needed to display n on the LCD (liquid-crystal display) of a TI-83 calculator.", "sequence": "19,10,14,14,14,17,15,11,17,15,29,20,24,24,24,27,25,21,27,25,33,24,28,28,28,31,29,25,31,29,33,24,28,28,28,31,29,25,31,29,33,24,28,28,28,31,29,25,31,29,36,27,31,31,31,34,32,28,34,32,34,25,29,29,29,32,30,26,32", "code": "\ndef A039942(n):\n....s=0\n....for i in str(n):\n........s+=[19,10,14,14,14,17,15,11,17,15][int(i)]\n....return s \n"}
{"sequence_id": "A039993", "text": "Number of different primes embedded in n.", "sequence": "0,1,1,0,1,0,1,0,0,0,1,1,3,1,1,1,3,0,1,1,1,1,3,1,2,1,2,1,2,1,3,3,1,2,3,1,4,2,1,0,1,1,2,0,1,0,2,0,0,1,1,2,3,1,1,1,2,1,2,0,1,1,1,0,1,0,2,0,0,1,3,2,4,2,2,2,1,1,3,0,0,1,2,0,1,0,1,0,1,0,1,2,1,0,2,0,3,1,0,0,2,1,4,2,1", "code": "\nfrom itertools import permutations\nfrom sympy import isprime\ndef a(n):\n    l=list(str(n))\n    L=[]\n    for i in range(len(l)):\n        L+=[int(\"\".join(x)) for x in permutations(l, i + 1)]\n    return len([i for i in set(L) if isprime(i)])\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A040025", "text": "a(n) is the number of prime palindromes with 2n+1 digits.", "sequence": "4,15,93,668,5172,42042,353701,3036643,27045226,239093865,2158090933,19742800564", "code": "\nfrom sympy import isprime\nfrom itertools import product\ndef candidate_pals(n): \n  if n == 0: yield from [2, 3, 5, 7]; return \n  for rightbutend in product(\"0123456789\", repeat=n-1):\n    rightbutend = \"\".join(rightbutend)\n    for end in \"1379\": \n      left = end + rightbutend[::-1]\n      for mid in \"0123456789\": yield int(left + mid + rightbutend + end)\ndef a(n): return sum(isprime(p) for p in candidate_pals(n))\nprint([a(n) for n in range(6)]) \n"}
{"sequence_id": "A040027", "text": "The Gould numbers.", "sequence": "1,1,3,9,31,121,523,2469,12611,69161,404663,2512769,16485691,113842301,824723643,6249805129,49416246911,406754704841,3478340425563,30845565317189,283187362333331,2687568043654521,26329932233283223,265946395403810289,2766211109503317451", "code": "\n\nA040027_list = lambda size: Gould_diag(2, size)\nprint(A040027_list(24)) \n"}
{"sequence_id": "A040051", "text": "Parity of partition function A000041.", "sequence": "1,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1", "code": "\nfrom sympy import npartitions\ndef a(n): return npartitions(n)%2 \n"}
{"sequence_id": "A040081", "text": "Riesel problem: a(n) = smallest m >= 0 such that n*2^m-1 is prime, or -1 if no such prime exists.", "sequence": "2,1,0,0,2,0,1,0,1,1,2,0,3,0,1,1,2,0,1,0,1,1,4,0,3,2,1,3,4,0,1,0,2,1,2,1,1,0,3,1,2,0,7,0,1,3,4,0,1,2,1,1,2,0,1,2,1,3,12,0,3,0,2,1,4,1,5,0,1,1,2,0,7,0,1,1,2,2,1,0,3,1,2,0,5,6,1,23,4,0,1,2,3,3,2,1,1,0,1,1,10,0,3", "code": "\nfrom sympy import isprime\ndef a(n):\n  m = 0\n  while not isprime(n*2**m - 1): m += 1\n  return m\nprint([a(n) for n in range(1, 88)]) \n"}
{"sequence_id": "A040163", "text": "a(n) is the absolute value of (the first digit of n minus the last digit of n).", "sequence": "0,0,0,0,0,0,0,0,0,1,0,1,2,3,4,5,6,7,8,2,1,0,1,2,3,4,5,6,7,3,2,1,0,1,2,3,4,5,6,4,3,2,1,0,1,2,3,4,5,5,4,3,2,1,0,1,2,3,4,6,5,4,3,2,1,0,1,2,3,7,6,5,4,3,2,1,0,1,2,8,7,6,5,4,3,2,1,0,1,9,8,7,6,5,4,3,2,1,0,1,0,1,2,3,4,5", "code": " for n in range(1,51): print(abs(int(str(n)[0])-int(str(n)[-1]))) \n"}
{"sequence_id": "A041143", "text": "Denominators of continued fraction convergents to sqrt(80).", "sequence": "1,1,17,18,305,323,5473,5796,98209,104005,1762289,1866294,31622993,33489287,567451585,600940872,10182505537,10783446409,182717648081,193501094490,3278735159921,3472236254411,58834515230497,62306751484908,1055742538989025", "code": " from sympy import continued_fraction_convergents as convergents, continued_fraction_iterator as cf, sqrt, denom\ndenominators = (denom(c) for c in convergents(cf(sqrt(80))))\nprint([next(denominators) for _ in range(30)]) \n"}
{"sequence_id": "A041190", "text": "Numerators of continued fraction convergents to sqrt(106).", "sequence": "10,31,72,103,175,278,453,1184,4005,81284,247857,576998,824855,1401853,2226708,3628561,9483830,32080051,651084850,1985334601,4621754052,6607088653,11228842705,17835931358,29064774063,75965479484,256961212515,5215189729784", "code": "\nfrom sympy import sqrt\nfrom sympy.ntheory.continued_fraction import *\ndef aupton(terms):\n  g = continued_fraction_convergents(continued_fraction_iterator(sqrt(106)))\n  return [next(g).numerator() for n in range(terms)]\nprint(aupton(28)) \n"}
{"sequence_id": "A041191", "text": "Denominators of continued fraction convergents to sqrt(106).", "sequence": "1,3,7,10,17,27,44,115,389,7895,24074,56043,80117,136160,216277,352437,921151,3115890,63238951,192832743,448904437,641737180,1090641617,1732378797,2823020414,7378419625,24958279289,506544005405,1544590295504,3595724596413", "code": "\nfrom sympy import sqrt\nfrom sympy.ntheory.continued_fraction import *\ndef aupton(terms):\n  g = continued_fraction_convergents(continued_fraction_iterator(sqrt(106)))\n  return [next(g).denominator() for n in range(terms)]\nprint(aupton(30)) \n"}
{"sequence_id": "A043000", "text": "Number of digits in all base-b representations of n, for 2 <= b <= n.", "sequence": "2,4,7,9,11,13,16,19,21,23,25,27,29,31,35,37,39,41,43,45,47,49,51,54,56,59,61,63,65,67,70,72,74,76,79,81,83,85,87,89,91,93,95,97,99,101,103,106,108,110,112,114,116,118,120,122,124,126", "code": "\ndef count(n,b):\n    c = 0\n    while n > 0:\n        n, c = n//b, c+1\n    return c\nn = 0\nwhile n < 50:\n    n = n+1\n    a, b = 0, 1\n    while b < n:\n        b = b+1\n        a = a + count(n,b)\n    print(n,a) \n"}
{"sequence_id": "A043096", "text": "Numbers in which every pair of adjacent digits are distinct.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,34,35,36,37,38,39,40,41,42,43,45,46,47,48,49,50,51,52,53,54,56,57,58,59,60,61,62,63,64,65,67,68,69", "code": "\ndef ok(n): s = str(n); return all(s[i] != s[i+1] for i in range(len(s)-1))\nprint(list(filter(ok, range(70)))) \n"}
{"sequence_id": "A043152", "text": "Numbers k such that 0 and 1 occur juxtaposed in the base-8 representation of k but not of k-1.", "sequence": "8,64,129,136,193,200,257,264,321,328,385,392,449,456,512,641,648,705,712,769,776,833,840,897,904,961,968,1025,1032,1088,1153,1160,1217,1224,1281,1288,1345,1352,1409,1416,1473,1480,1537", "code": "\ndef ok(n):\n    on, onm1 = oct(n)[2:], oct(n-1)[2:]\n    return (\"01\" in on or \"10\" in on) and not (\"01\" in onm1 or \"10\" in onm1)\nprint(list(filter(ok, range(1, 1538)))) \n"}
{"sequence_id": "A043216", "text": "Numbers k such that 0 and 1 occur juxtaposed in the base-10 representation of k but not of k-1.", "sequence": "10,100,201,210,301,310,401,410,501,510,601,610,701,710,801,810,901,910,1000,1201,1210,1301,1310,1401,1410,1501,1510,1601,1610,1701,1710,1801,1810,1901,1910,2001,2010,2100,2201,2210,2301", "code": "\ndef ok(n):\n    sn, snm1 = str(n), str(n-1)\n    return (\"01\" in sn or \"10\" in sn) and not (\"01\" in snm1 or \"10\" in snm1)\nprint(list(filter(ok, range(1, 2302)))) \n"}
{"sequence_id": "A043291", "text": "Every run length in base 2 is 2.", "sequence": "3,12,51,204,819,3276,13107,52428,209715,838860,3355443,13421772,53687091,214748364,858993459,3435973836,13743895347,54975581388,219902325555,879609302220,3518437208883,14073748835532,56294995342131,225179981368524,900719925474099", "code": "\ndef a(n): return int(''.join([['11', '00'][i%2] for i in range(n)]), 2)\nprint([a(n) for n in range(1, 26)]) \n"}
{"sequence_id": "A043295", "text": "Sum of digits of numerator of Bernoulli number B(2n).", "sequence": "1,1,1,1,5,16,7,17,28,20,26,34,25,47,53,44,79,79,88,82,88,86,104,146,113,152,145,164,152,158,160,206,164,190,193,250,205,262,259,341,257,278,331,301,323,362,295,356,349,355,346,359,380,475,457,449,415,464", "code": "\nfrom sympy import bernoulli\ndef a(n): return sum(map(int, str(abs(bernoulli(2*n).numerator()))))\nprint([a(n) for n in range(1, 59)]) \n"}
{"sequence_id": "A043296", "text": "Sum of digits of denominator of Bernoulli number B(2n).", "sequence": "6,3,6,3,12,12,6,6,24,6,12,12,6,15,12,6,6,30,6,12,15,15,12,15,12,15,24,15,12,42,6,6,21,3,24,21,6,3,15,6,21,15,6,12,21,6,6,24,6,12,15,15,12,30,15,24,6,15,6,39,6,3,42,6,24,24,6,6,30,33,6,42,6,15,21,3,12,42,6,6", "code": "\nfrom sympy import bernoulli\ndef a(n): return sum(map(int, str(bernoulli(2*n).denominator())))\nprint([a(n) for n in range(1, 81)]) \n"}
{"sequence_id": "A043521", "text": "Numbers having one 8 in base 10.", "sequence": "8,18,28,38,48,58,68,78,80,81,82,83,84,85,86,87,89,98,108,118,128,138,148,158,168,178,180,181,182,183,184,185,186,187,189,198,208,218,228,238,248,258,268,278,280,281,282,283,284,285,286,287,289,298,308,318", "code": "\ndef ok(n): return str(n).count('8') == 1\nprint(list(filter(ok, range(320)))) \n"}
{"sequence_id": "A043525", "text": "Numbers having one 9 in base 10.", "sequence": "9,19,29,39,49,59,69,79,89,90,91,92,93,94,95,96,97,98,109,119,129,139,149,159,169,179,189,190,191,192,193,194,195,196,197,198,209,219,229,239,249,259,269,279,289,290,291,292,293,294,295,296,297,298,309,319", "code": "\ndef ok(n): return str(n).count('9') == 1\nprint(list(filter(ok, range(320)))) \n"}
{"sequence_id": "A043569", "text": "Numbers whose base-2 representation has exactly 2 runs.", "sequence": "2,4,6,8,12,14,16,24,28,30,32,48,56,60,62,64,96,112,120,124,126,128,192,224,240,248,252,254,256,384,448,480,496,504,508,510,512,768,896,960,992,1008,1016,1020,1022,1024,1536,1792,1920,1984,2016,2032,2040,2044", "code": "\ndef ok(n): b = bin(n)[2:]; return \"10\" in b and \"01\" not in b\nprint([m for m in range(2045) if ok(m)]) \n"}
{"sequence_id": "A043705", "text": "Numbers whose base-16 representation has an even number of runs.", "sequence": "16,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,69,70,71,72,73,74,75,76,77,78,79", "code": "\nfrom itertools import groupby\ndef ok(n): return len(list(g for k, g in groupby(hex(n)[2:])))%2 == 0\nprint(list(filter(ok, range(1, 80)))) \n"}
{"sequence_id": "A043719", "text": "Numbers whose base-16 representation has an odd number of runs.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,273,288,289,291,292,293,294,295", "code": "\nfrom itertools import groupby\ndef ok(n): return len(list(g for k, g in groupby(hex(n)[2:])))%2 == 1\nprint(list(filter(ok, range(1, 296)))) \n"}
{"sequence_id": "A043880", "text": "Numbers k such that 0 and 1 occur juxtaposed in the base-4 representation of k but not of k+1.", "sequence": "4,20,33,36,49,52,84,97,100,113,116,129,135,148,161,164,177,180,193,199,212,225,228,241,244,340,353,356,369,372,385,391,404,417,420,433,436,449,455,468,481,484,497,500,513,519,543,545,548,561,564,596,609,612", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef has01or10(k):\n  s = \"\".join(map(str, digits(k, 4)[1:])); return \"01\" in s or \"10\" in s\ndef ok(n): return has01or10(n) and not has01or10(n+1)\nprint(list(filter(ok, range(613)))) \n"}
{"sequence_id": "A043932", "text": "Numbers k such that 0 and 1 occur juxtaposed in the base-8 representation of k but not of k+1.", "sequence": "8,72,129,136,193,200,257,264,321,328,385,392,449,456,584,641,648,705,712,769,776,833,840,897,904,961,968,1025,1039,1096,1153,1160,1217,1224,1281,1288,1345,1352,1409,1416,1473,1480,1537", "code": "\ndef ok(n):\n    on, onm1 = oct(n)[2:], oct(n+1)[2:]\n    return (\"01\" in on or \"10\" in on) and not (\"01\" in onm1 or \"10\" in onm1)\nprint(list(filter(ok, range(1, 1538)))) \n"}
{"sequence_id": "A044446", "text": "Numbers k such that string 1,0 occurs in the base-4 representation of k but not of k+1.", "sequence": "4,20,36,52,84,100,116,132,148,164,180,196,212,228,244,340,356,372,388,404,420,436,452,468,484,500,516,532,548,564,596,612,628,644,660,676,692,708,724,740,756,772,788,804,820,852,868,884,900,916,932,948,964", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef has10(k): s = \"\".join(map(str, digits(k, 4)[1:])); return \"10\" in s\ndef ok(n): return has10(n) and not has10(n+1)\nprint(list(filter(ok, range(965)))) \n"}
{"sequence_id": "A044460", "text": "Numbers n such that string 0,2 occurs in the base 5 representation of n but not of n+1.", "sequence": "27,52,77,102,127,139,152,177,202,227,252,264,277,302,327,352,377,389,402,427,452,477,502,514,527,552,577,602,627,639,652,699,702,727,752,764,777,802,827,852,877,889,902,927,952,977", "code": "\nfrom gmpy2 import digits\nA044460_list = [n for n in range(5**7) if '02' in digits(n,5) and '02' not in digits(n+1,5)] \n"}
{"sequence_id": "A044813", "text": "Positive integers having distinct base-2 run lengths.", "sequence": "1,3,4,6,7,8,14,15,16,24,28,30,31,32,35,39,48,49,55,57,59,60,62,63,64,67,79,96,97,111,112,120,121,123,124,126,127,128,131,135,143,159,192,193,223,224,225,239,241,247,248,249,251,252,254,255,256,259,263", "code": "\nfrom itertools import groupby\ndef ok(n):\n  runlengths = [len(list(g)) for k, g in groupby(bin(n)[2:])]\n  return len(runlengths) == len(set(runlengths))\nprint([i for i in range(1, 264) if ok(i)]) \n"}
{"sequence_id": "A044821", "text": "Positive integers having distinct base-10 run lengths.", "sequence": "1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,100,110,111,112,113,114,115,116,117,118,119,122,133,144,155,166,177,188,199,200,211,220,221,222,223,224,225,226,227,228,229,233,244,255", "code": "\nfrom itertools import groupby\ndef ok(n):\n  runlengths = [len(list(g)) for k, g in groupby(str(n))]\n  return len(runlengths) == len(set(runlengths))\nprint([i for i in range(1, 256) if ok(i)]) \n"}
{"sequence_id": "A044873", "text": "Numbers having, in base 2, (sum of even run lengths)=(sum of odd run lengths).", "sequence": "9,11,13,133,135,140,143,146,148,150,152,154,156,161,164,166,172,175,178,180,182,189,196,198,200,202,206,210,212,214,216,218,220,225,228,230,236,239,241,245,247,2065,2069,2071,2077", "code": "\nfrom itertools import groupby\ndef ok(n):\n    rl_sums = [0, 0]\n    for k, g in groupby(bin(n)[2:]):\n        rl = len(list(g))\n        rl_sums[rl%2] += rl\n    return rl_sums[0] == rl_sums[1]\nprint(list(filter(ok, range(2078)))) \n"}
{"sequence_id": "A044879", "text": "Numbers having, in base 8, (sum of even run lengths)=(sum of odd run lengths).", "sequence": "513,514,515,516,517,518,519,521,530,539,548,557,566,575,577,578,579,580,581,582,583,592,593,595,596,597,598,599,600,601,602,604,605,606,607,608,609,610,611,613,614,615,616,617,618", "code": "\nfrom itertools import groupby\ndef ok(n):\n    rl_sums = [0, 0]\n    for k, g in groupby(oct(n)[2:]):\n        rl = len(list(g))\n        rl_sums[rl%2] += rl\n    return rl_sums[0] == rl_sums[1]\nprint(list(filter(ok, range(619)))) \n"}
{"sequence_id": "A044881", "text": "Numbers having, in base 10, (sum of even run lengths)=(sum of odd run lengths).", "sequence": "1001,1002,1003,1004,1005,1006,1007,1008,1009,1011,1022,1033,1044,1055,1066,1077,1088,1099,1101,1102,1103,1104,1105,1106,1107,1108,1109,1120,1121,1123,1124,1125,1126,1127,1128,1129", "code": "\nfrom itertools import groupby\ndef ok(n):\n    rl_sums = [0, 0]\n    for k, g in groupby(str(n)):\n        rl = len(list(g))\n        rl_sums[rl%2] += rl\n    return rl_sums[0] == rl_sums[1]\nprint(list(filter(ok, range(1130)))) \n"}
{"sequence_id": "A044887", "text": "Numbers having, in base 16, (sum of even run lengths)=(sum of odd run lengths).", "sequence": "4097,4098,4099,4100,4101,4102,4103,4104,4105,4106,4107,4108,4109,4110,4111,4113,4130,4147,4164,4181,4198,4215,4232,4249,4266,4283,4300,4317,4334,4351,4353,4354,4355,4356,4357,4358", "code": "\nfrom itertools import groupby\ndef ok(n):\n    rl_sums = [0, 0]\n    for k, g in groupby(hex(n)[2:]):\n        rl = len(list(g))\n        rl_sums[rl%2] += rl\n    return rl_sums[0] == rl_sums[1]\nprint(list(filter(ok, range(4359)))) \n"}
{"sequence_id": "A044888", "text": "Numbers whose base-2 run lengths alternate: even, odd, even, ...", "sequence": "3,6,15,24,27,30,54,63,96,99,111,120,123,126,198,216,219,222,246,255,384,387,399,438,447,480,483,495,504,507,510,774,792,795,798,864,867,879,888,891,894,966,984,987,990,1014,1023,1536", "code": "\nfrom itertools import groupby\ndef ok(n): return all(len(list(g))%2 == i%2 for i, (k, g) in enumerate(groupby(bin(n)[2:])))\nprint([i for i in range(1, 1537) if ok(i)]) \n"}
{"sequence_id": "A044903", "text": "Base-2 run lengths alternate: odd, even, odd, ...", "sequence": "1,4,7,9,16,28,31,33,36,39,57,64,73,112,124,127,129,132,135,144,156,159,225,228,231,249,256,265,289,292,295,313,448,457,496,508,511,513,516,519,528,540,543,576,585,624,636,639,897,900", "code": "\nfrom itertools import groupby\ndef ok(n): return all(len(list(g))%2 != i%2 for i, (k, g) in enumerate(groupby(bin(n)[2:])))\nprint([i for i in range(1, 901) if ok(i)]) \n"}
{"sequence_id": "A044995", "text": "Numbers n with property that in base 3 representation the numbers of 0's and 2's are 1 and 1, respectively.", "sequence": "6,11,15,19,21,32,34,38,42,46,48,58,64,66,95,97,103,113,115,119,123,127,129,139,145,147,175,193,199,201,284,286,292,310,338,340,346,356,358,362,366,370,372,382,388,390,418,436,442,444", "code": "\nfrom sympy.ntheory import count_digits\ndef ok(n): d = count_digits(n, 3); return d[0] == 1 and d[2] == 1\nprint(list(filter(ok, range(500)))) \n"}
{"sequence_id": "A045015", "text": "Numbers n with property that in base 4 representation the numbers of 0's and 1's are 0 and 2, respectively.", "sequence": "5,22,23,25,29,37,53,90,91,94,95,102,103,105,109,118,119,121,125,150,151,153,157,165,181,214,215,217,221,229,245,362,363,366,367,378,379,382,383,410,411,414,415,422,423,425,429,438", "code": "\nfrom sympy.ntheory import count_digits\ndef ok(n): c = count_digits(n, 4); return 0 not in c and c[1] == 2\nprint(list(filter(ok, range(439)))) \n"}
{"sequence_id": "A045051", "text": "Numbers n with property that in base 4 representation the numbers of 0's and 2's are 2 and 4, respectively.", "sequence": "2090,2186,2210,2216,2570,2594,2600,2690,2696,2720,4266,4650,4746,4770,4776,6186,6282,6306,6312,6666,6690,6696,6786,6792,6816,8298,8346,8358,8361,8363,8366,8378,8426,8490,8586,8610", "code": "\nimport numpy as np\nfor a in range(10000):\n    x = np.base_repr(a, base=4)\n    if(x.count(\"0\") == 2 and x.count(\"2\") == 4):\n        print(a)\n\n"}
{"sequence_id": "A045412", "text": "a(1)=3; for n > 1, a(n) = a(n-1) + 1 if n is already in the sequence, a(n) = a(n-1) + 3 otherwise.", "sequence": "3,6,7,10,13,14,15,18,21,22,25,28,29,30,31,34,37,38,41,44,45,46,49,52,53,56,59,60,61,62,63,66,69,70,73,76,77,78,81,84,85,88,91,92,93,94,97,100,101,104,107,108,109,112,115,116,119,122,123,124,125,126", "code": "\nl=[3]\na=3\nfor n in range(2, 101):\n    if n not in l: a+=3\n    else: a+=1\n    l.append(a)\nprint(l) \n"}
{"sequence_id": "A045499", "text": "Fourth-from-right diagonal of triangle A121207.", "sequence": "1,1,5,20,85,400,2046,11226,65676,407787,2675410,18475311,133843405,1014271763,8019687099,66011609670,564494701167,5005880952390,45958055208576,436161412834300,4273045478169842,43160044390231165", "code": "\n\nA045499_list = lambda size: Gould_diag(4, size)\nprint(A045499_list(24)) \n"}
{"sequence_id": "A045500", "text": "Fifth-from-right diagonal of triangle A121207.", "sequence": "1,1,6,27,125,635,3488,20425,126817,831915,5744784,41618459,315388311,2493721645,20526285716,175529425815,1556577220651,14290644428279,135624265589086,1328702240382589,13420603191219111,139592874355534071", "code": "\n\nA045500_list = lambda size: Gould_diag(5, size)\nprint(A045500_list(24)) \n"}
{"sequence_id": "A045501", "text": "Third-from-right diagonal of triangle A121207.", "sequence": "1,1,4,14,54,233,1101,5625,30846,180474,1120666,7352471,50772653,367819093,2787354668,22039186530,181408823710,1551307538185,13756835638385,126298933271289,1198630386463990,11742905240821910", "code": "\n\nA045501_list = lambda size: Gould_diag(3, size)\nprint(A045501_list(24)) \n"}
{"sequence_id": "A045541", "text": "Square previous term and then delete digits of previous term.", "sequence": "2,4,16,25,6,3,9,81,656,43033,18518989,3422322,11718787168,33299240224,118856557176,42330949,17161,29449992,867300880006,522114591215,760366360676,5815244491919,3370600766306,11949525822594424885", "code": "\nA045541_list, l = [2], 2\nfor _ in range(10**4):\n....l = int(''.join(d for d in str(l**2) if not d in set(str(l))))\n....A045541_list.append(l) \n"}
{"sequence_id": "A045636", "text": "Numbers of the form p^2 + q^2, with p and q primes.", "sequence": "8,13,18,29,34,50,53,58,74,98,125,130,146,170,173,178,194,218,242,290,293,298,314,338,365,370,386,410,458,482,530,533,538,554,578,650,698,722,818,845,850,866,890,962,965,970,986,1010,1058,1082,1130,1202,1250", "code": "\nfrom sympy import primerange\ndef aupto(limit):\n    primes = list(primerange(2, int((limit-4)**.5)+2))\n    nums = [p*p + q*q for i, p in enumerate(primes) for q in primes[i:]]\n    return sorted(set(k for k in nums if k <= limit))\nprint(aupto(1251)) \n"}
{"sequence_id": "A045708", "text": "Primes with first digit 2.", "sequence": "2,23,29,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221", "code": "\nfrom sympy import isprime\ndef agen(limit=float('inf')):\n  yield 2\n  digits, adder = 1, 20\n  while True:\n    for i in range(1, 10**digits, 2):\n      test = adder + i\n      if test > limit: return\n      if isprime(test): yield test\n    digits, adder = digits+1, adder*10\nagento = lambda lim: agen(limit=lim)\nprint(list(agento(2222))) \n"}
{"sequence_id": "A045720", "text": "3-fold convolution of A001700(n), n >= 0.", "sequence": "1,9,57,312,1578,7599,35401,161052,719790,3173090,13836426,59803104,256596276,1094249019,4642178601,19605872724,82483419846,345839048094,1445715336366,6027524015664,25070662980876,104056307673654", "code": "\nimport math\ndef C(n,r):\n....f=math.factorial\n....return f(n)/f(r)/f(n-r)\ndef A045720(n):\n....return (n+5)*C(2*(n+3),n+3)/4-3*2**(2*n+3) \n"}
{"sequence_id": "A045759", "text": "Maris-McGwire numbers: numbers k such that f(k) = f(k+1), where f(k) = sum of digits of k + sum of digits of prime factors of k (including multiplicities).", "sequence": "7,14,43,50,61,63,67,80,84,118,122,134,137,163,196,212,213,224,241,273,274,277,279,283,351,352,373,375,390,398,421,457,462,474,475,489,495,510,516,523,526,537,547,555,558,577,584,590,592,616,638,644,660,673,687,691", "code": "\nfrom sympy import factorint\ndef sd(n): return sum(map(int, str(n)))\ndef  f(n): return sd(n) + sum(sd(p)*e for p, e in factorint(n).items())\ndef ok(n): return f(n) == f(n+1)\nprint(list(filter(ok, range(692)))) \n"}
{"sequence_id": "A045778", "text": "Number of factorizations of n into distinct factors greater than 1.", "sequence": "1,1,1,1,1,2,1,2,1,2,1,3,1,2,2,2,1,3,1,3,2,2,1,5,1,2,2,3,1,5,1,3,2,2,2,5,1,2,2,5,1,5,1,3,3,2,1,7,1,3,2,3,1,5,2,5,2,2,1,9,1,2,3,4,2,5,1,3,2,5,1,9,1,2,3,3,2,5,1,7,2,2,1,9,2,2,2,5,1,9,2,3,2,2,2,10,1,3,3,5,1,5,1,5", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import divisors, isprime\n@cacheit\ndef b(n, k): return (0 if n>k else 1) + (0 if isprime(n) else sum(0 if d>k else b(n//d, d - 1) for d in divisors(n)[1:-1]))\ndef a(n): return b(n, n)\nprint([a(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A045860", "text": "Numbers whose square has initial digit '6'.", "sequence": "8,25,26,78,79,80,81,82,83,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799", "code": "\nfrom math import isqrt\ndef aupto(limit):\n    alst, d, end = [], 1, 0\n    while end < limit:\n        start, end = isqrt(6*10**d) + 1, isqrt(7*10**d-1)\n        alst.extend([an for an in list(range(start, end+1)) if an <= limit])\n        d += 1\n    return alst\nprint(aupto(799)) \n"}
{"sequence_id": "A045862", "text": "Numbers whose square has initial digit '8'.", "sequence": "9,29,90,91,92,93,94,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923", "code": "\nfrom math import isqrt\ndef auptorun(runs):\n    alst = []\n    for n in range(1, runs+1):\n        alst.extend(list(range(isqrt(8*10**n) + 1, isqrt(9*10**n - 1)+1)))\n    return alst\nprint(auptorun(5)) \n"}
{"sequence_id": "A045875", "text": "a(n) is the smallest m for which the decimal representation of 2^m contains n consecutive identical digits.", "sequence": "0,16,24,41,220,971,972,8554,42485,42486,271979,1039315,1727602,6855865,63416789", "code": "\ndef A045875(n):\n    l, x = [str(d)*n for d in range(10)], 1\n    for m in range(10**9):\n        s = str(x)\n        for k in l:\n            if k in s:\n                return m\n        x *= 2\n    return 'search limit reached'\n\n"}
{"sequence_id": "A045887", "text": "Number of distinct even numbers visible as proper subsequences of n.", "sequence": "0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,2,1,1,1,2,1,2,1,2,1,1,0,1,0,1,0,1,0,1,0,2,1,2,1,1,1,2,1,2,1,1,0,1,0,1,0,1,0,1,0,2,1,2,1,2,1,1,1,2,1,1,0,1,0,1,0,1,0,1,0,2,1,2,1,2,1,2,1,1,1,1,0,1,0,1,0,1,0,1,0,2,2,4,2,4", "code": "\nfrom itertools import combinations\ndef a(n):\n  s, eset = str(n), set()\n  for i in range(len(s)):\n    for j in range(i+1, len(s)+1):\n      if s[j-1] in \"02468\":\n        if len(s[i:j]) <= 2 and j-i < len(s):\n          eset.add(int(s[i:j]))\n        else:\n          middle = s[i+1:j-1]\n          for k in range(len(middle)+1):\n            for c in combinations(middle, k):\n              t = s[i] + \"\".join(c) + s[j-1]\n              if len(t) < len(s):\n                eset.add(int(t))\n  return len(eset)\nprint([a(n) for n in range(105)]) \n"}
{"sequence_id": "A045888", "text": "Number of distinct odd numbers visible as proper subsequences of n.", "sequence": "0,0,0,0,0,0,0,0,0,1,1,1,2,1,2,1,2,1,2,0,1,0,1,0,1,0,1,0,1,1,2,1,1,1,2,1,2,1,2,0,1,0,1,0,1,0,1,0,1,1,2,1,2,1,1,1,2,1,2,0,1,0,1,0,1,0,1,0,1,1,2,1,2,1,2,1,1,1,2,0,1,0,1,0,1,0,1,0,1,1,2,1,2,1,2,1,2,1,1,1,2,1,3,1,3", "code": "\nfrom itertools import combinations\ndef a(n):\n  s, eset = str(n), set()\n  for i in range(len(s)):\n    for j in range(i+1, len(s)+1):\n      if s[j-1] in \"13579\":\n        if len(s[i:j]) <= 2 and j-i < len(s):\n          eset.add(int(s[i:j]))\n        else:\n          middle = s[i+1:j-1]\n          for k in range(len(middle)+1):\n            for c in combinations(middle, k):\n              t = s[i] + \"\".join(c) + s[j-1]\n              if len(t) < len(s):\n                eset.add(int(t))\n  return len(eset)\nprint([a(n) for n in range(1, 105)]) \n"}
{"sequence_id": "A045894", "text": "4-fold convolution of A001700(n), n >= 0.", "sequence": "1,12,94,608,3525,19044,97954,486000,2345930,11081880,51447036,235454848,1064832173,4767347796,21160397050,93223960784,408037319262,1775744775592,7688699122724,33140226601920,142262721338146", "code": "\nimport math\ndef C(n,r):\n....f=math.factorial\n....return f(n)/f(r)/f(n-r)\ndef A045894(n):\n....return (n+11)*4**(n+2)-(n+5)*C(2*(n+4),(n+4))/2 \n"}
{"sequence_id": "A045917", "text": "From Goldbach problem: number of decompositions of 2n into unordered sums of two primes.", "sequence": "0,1,1,1,2,1,2,2,2,2,3,3,3,2,3,2,4,4,2,3,4,3,4,5,4,3,5,3,4,6,3,5,6,2,5,6,5,5,7,4,5,8,5,4,9,4,5,7,3,6,8,5,6,8,6,7,10,6,6,12,4,5,10,3,7,9,6,5,8,7,8,11,6,5,12,4,8,11,5,8,10,5,6,13,9,6,11,7,7,14,6,8,13,5,8,11,7,9", "code": "\nfrom sympy import isprime\ndef A045917(n):\n    x = 0\n    for i in range(2,n+1):\n        if isprime(i) and isprime(2*n-i):\n            x += 1\n    return x \n"}
{"sequence_id": "A045918", "text": "Describe n. Also called the \"Say What You See\" or \"Look and Say\" sequence LS(n).", "sequence": "10,11,12,13,14,15,16,17,18,19,1110,21,1112,1113,1114,1115,1116,1117,1118,1119,1210,1211,22,1213,1214,1215,1216,1217,1218,1219,1310,1311,1312,23,1314,1315,1316,1317,1318,1319,1410,1411,1412", "code": "\nfrom re import finditer\ndef A045918(n):\n    return int(''.join([str(len(m.group(0)))+m.group(0)[0] for m in finditer(r'(\\d)\\1*',str(n))]))\n\n"}
{"sequence_id": "A045945", "text": "Hexagonal matchstick numbers: a(n) = 3*n*(3*n+1).", "sequence": "0,12,42,90,156,240,342,462,600,756,930,1122,1332,1560,1806,2070,2352,2652,2970,3306,3660,4032,4422,4830,5256,5700,6162,6642,7140,7656,8190,8742,9312,9900,10506,11130,11772,12432,13110,13806,14520,15252,16002", "code": " def a(n): return 3*n*(3*n+1) \n"}
{"sequence_id": "A045965", "text": "a(1)=2; if n = Product p_i^e_i, n > 1, then a(n) = Product p_{i+1}^e_i.", "sequence": "2,3,5,9,7,15,11,27,25,21,13,45,17,33,35,81,19,75,23,63,55,39,29,135,49,51,125,99,31,105,37,243,65,57,77,225,41,69,85,189,43,165,47,117,175,87,53,405,121,147,95,153,59,375,91,297,115,93,61,315,67,111,275,729,119", "code": "\nfrom sympy import factorint, primepi, prime, prod\ndef a(n):\n    f=factorint(n)\n    return 2 if n==1 else prod(prime(primepi(i) + 1)**f[i] for i in f) \n"}
{"sequence_id": "A046063", "text": "Numbers n such that n-th partition number A000041(n) is prime.", "sequence": "2,3,4,5,6,13,36,77,132,157,168,186,188,212,216,302,366,417,440,491,498,525,546,658,735,753,825,841,863,1085,1086,1296,1477,1578,1586,1621,1793,2051,2136,2493,2502,2508,2568,2633,2727,2732,2871,2912,3027,3098,3168,3342,3542,3641,4118", "code": "\nfrom sympy import isprime, npartitions\nprint([n for n in range(1, 5001) if isprime(npartitions(n))]) \n"}
{"sequence_id": "A046073", "text": "Number of squares in multiplicative group modulo n.", "sequence": "1,1,1,1,2,1,3,1,3,2,5,1,6,3,2,2,8,3,9,2,3,5,11,1,10,6,9,3,14,2,15,4,5,8,6,3,18,9,6,2,20,3,21,5,6,11,23,2,21,10,8,6,26,9,10,3,9,14,29,2,30,15,9,8,12,5,33,8,11,6,35,3,36,18,10,9,15,6,39,4,27,20,41,3,16,21", "code": "\nfrom sympy import factorint, prod\ndef a(n): return 1 if n==1 else prod([2**max(e - 3, 0) if p==2 else (p - 1)*p**(e - 1)//2 for p, e in factorint(n).items()])\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A046099", "text": "Numbers that are not cubefree. Numbers divisible by a cube greater than 1. Complement of A004709.", "sequence": "8,16,24,27,32,40,48,54,56,64,72,80,81,88,96,104,108,112,120,125,128,135,136,144,152,160,162,168,176,184,189,192,200,208,216,224,232,240,243,248,250,256,264,270,272,280,288,296,297,304,312,320,324,328,336", "code": "\nfrom sympy.ntheory.factor_ import core\ndef ok(n): return core(n, 3) != n\nprint(list(filter(ok, range(1, 337)))) \n"}
{"sequence_id": "A046109", "text": "Number of lattice points (x,y) on the circumference of a circle of radius n with center at (0,0).", "sequence": "1,4,4,4,4,12,4,4,4,4,12,4,4,12,4,12,4,12,4,4,12,4,4,4,4,20,12,4,4,12,12,4,4,4,12,12,4,12,4,12,12,12,4,4,4,12,4,4,4,4,20,12,12,12,4,12,4,4,12,4,12,12,4,4,4,36,4,4,12,4,12,4,4,12,12,20,4,4,12,4,12,4,12,4,4,36", "code": "\nfrom sympy import factorint\ndef a(n):\n    r = 1\n    for p, e in factorint(n).items():\n        if p%4 == 1: r *= 2*e + 1\n    return 4*r if n > 0 else 0\n\n"}
{"sequence_id": "A046127", "text": "Maximal number of regions into which space can be divided by n spheres.", "sequence": "0,2,4,8,16,30,52,84,128,186,260,352,464,598,756,940,1152,1394,1668,1976,2320,2702,3124,3588,4096,4650,5252,5904,6608,7366,8180,9052,9984,10978,12036,13160,14352,15614,16948,18356,19840,21402,23044", "code": "\ndef a(n):\n....return n*(n**2 - 3*n + 8)//3\n\n"}
{"sequence_id": "A046255", "text": "a(1) = 5; a(n) is smallest number >= a(n-1) such that the juxtaposition a(1)a(2)...a(n) is a prime.", "sequence": "5,9,9,21,53,67,71,87,87,91,117,161,187,213,363,419,501,537,543,739,879,1101,1329,1391,1641,1939,2093,2109,2331,2557,2639,2697,2863,3441,3441,4413,4461,4479,4557,5489,6033,6267,6351,6973,7181,7459,7679,8113,8241", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n  alst, astr = [5], \"5\"\n  while len(alst) < terms:\n    an = alst[-1]\n    while an%5 ==0 or not isprime(int(astr + str(an))): an += 2\n    alst, astr = alst + [an], astr + str(an)\n  return alst\nprint(aupton(49)) \n"}
{"sequence_id": "A046256", "text": "a(1) = 6; a(n) is smallest number >= a(n-1) such that the juxtaposition a(1)a(2)...a(n) is a prime.", "sequence": "6,7,7,9,27,59,69,181,201,257,267,399,573,603,861,901,923,1021,1133,1239,1251,1519,1589,1729,1863,1901,2541,3001,3017,3049,3243,4407,4481,5457,5839,5889,5919,6159,6201,6293,6577,6603,6969,7217,8131,8981,9033", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n  alst, astr = [6], \"6\"\n  for n in range(2, terms+1):\n    an = alst[-1]\n    while not isprime(int(astr+str(an))): an += 1\n    alst, astr = alst + [an], astr + str(an)\n  return alst\nprint(aupton(62)) \n"}
{"sequence_id": "A046332", "text": "Palindromes with exactly 6 prime factors (counted with multiplicity).", "sequence": "2772,2992,6776,8008,21112,21712,21912,23632,23832,25452,25752,25952,27472,28782,29392,40104,40304,40404,42024,42924,44044,44144,44744,44944,45954,46764,46864,48984,53235,54945,55755,59895,60606,61216", "code": "\nfrom sympy import factorint\ndef palQgen10(l): \n....if l > 0:\n........yield 0\n........for x in range(1,l+1):\n............for y in range(10**(x-1),10**x):\n................s = str(y)\n................yield int(s+s[-2::-1])\n............for y in range(10**(x-1),10**x):\n................s = str(y)\n................yield int(s+s[::-1])\nA046332_list = [x for x in palQgen10(4) if sum(list(factorint(x).values())) == 6]\n\n"}
{"sequence_id": "A046346", "text": "Composite numbers that are divisible by the sum of their prime factors (counted with multiplicity).", "sequence": "4,16,27,30,60,70,72,84,105,150,180,220,231,240,256,286,288,308,378,440,450,476,528,540,560,576,588,594,624,627,646,648,650,728,800,805,840,884,897,900,945,960,1008,1040,1056,1080,1100,1122,1134,1160,1170,1248", "code": "\nfrom sympy import factorint\ndef ok(n):\n  f = factorint(n)\n  return sum(f[p] for p in f) > 1 and n % sum(p*f[p] for p in f) == 0\nprint(list(filter(ok, range(1250)))) \n"}
{"sequence_id": "A046349", "text": "Composite numbers with only palindromic prime factors.", "sequence": "4,6,8,9,10,12,14,15,16,18,20,21,22,24,25,27,28,30,32,33,35,36,40,42,44,45,48,49,50,54,55,56,60,63,64,66,70,72,75,77,80,81,84,88,90,96,98,99,100,105,108,110,112,120,121,125,126,128,132,135,140,144,147,150", "code": "\nfrom sympy import isprime, primefactors\ndef pal(n): s = str(n); return s == s[::-1]\ndef ok(n): return not isprime(n) and all(pal(f) for f in primefactors(n))\nprint(list(filter(ok, range(4, 151)))) \n"}
{"sequence_id": "A046350", "text": "Odd composite numbers with only palindromic prime factors.", "sequence": "9,15,21,25,27,33,35,45,49,55,63,75,77,81,99,105,121,125,135,147,165,175,189,225,231,243,245,275,297,303,315,343,363,375,385,393,405,441,453,495,505,525,539,543,567,573,605,625,655,675,693,707,729,735,755", "code": "\nfrom sympy import isprime, primefactors\ndef pal(n): s = str(n); return s == s[::-1]\ndef ok(n): return not isprime(n) and all(pal(f) for f in primefactors(n))\nprint(list(filter(ok, range(9, 756, 2)))) \n"}
{"sequence_id": "A046351", "text": "Palindromic composite numbers with only palindromic prime factors.", "sequence": "4,6,8,9,22,33,44,55,66,77,88,99,121,202,242,252,262,303,343,363,393,404,484,505,525,606,616,626,686,707,808,909,939,1111,1331,1441,1661,1991,2112,2222,2662,2772,2882,3333,3443,3773,3883,3993,4224,4444,5445", "code": "\nfrom itertools import product\nfrom sympy import isprime, primefactors as pf\ndef pal(n): s = str(n); return s == s[::-1]\ndef palsthru(maxdigits):\n  midrange = [[\"\"], [str(i) for i in range(10)]]\n  for digits in range(1, maxdigits+1):\n    for p in product(\"0123456789\", repeat=digits//2):\n      left = \"\".join(p)\n      if len(left) and left[0] == '0': continue\n      for middle in midrange[digits%2]: yield int(left+middle+left[::-1])\ndef okpal(p): return p > 3 and not isprime(p) and all(pal(f) for f in pf(p))\nprint(list(filter(okpal, palsthru(4)))) \n"}
{"sequence_id": "A046353", "text": "Odd composite numbers whose sum of prime factors is palindromic (counted with multiplicity).", "sequence": "9,15,27,45,57,85,121,123,259,305,351,403,413,415,483,495,575,597,627,639,663,687,689,705,717,735,807,875,893,931,935,985,989,1073,1135,1183,1203,1207,1263,1285,1293,1331,1353,1383,1385,1407,1473,1505,1545", "code": "\nfrom sympy import factorint\ndef is_046353(n):\n    if n % 2 == 0: return False\n    f = factorint(n)\n    if sum([f[i] for i in f]) < 2: return False\n    sfa = sum([i*f[i] for i in f])\n    if sfa == int(str(sfa)[::-1]): return True\n    return False \n"}
{"sequence_id": "A046358", "text": "Composite numbers divisible by the palindromic sum of their prime factors (counted with multiplicity).", "sequence": "4,16,27,308,440,528,594,627,1122,1276,3432,3861,4070,4543,5445,5808,6248,6534,7881,8085,8096,9108,9306,9702,11550,13860,14784,16500,16632,17556,18711,19800,19866,20900,21091,21120,22275,22308,23463,23474", "code": "\nfrom sympy import isprime, factorint\nA046358 = [n for n in range(2,10**6) if not isprime(n) and not n % sum([p*e for p,e in factorint(n).items()]) and str(sum([p*e for p,e in factorint(n).items()])) == str(sum([p*e for p,e in factorint(n).items()]))[::-1]] \n"}
{"sequence_id": "A046365", "text": "Composite palindromes whose sum of prime factors is prime (counted with multiplicity).", "sequence": "6,22,88,99,202,252,333,414,424,454,464,595,686,747,777,808,838,848,858,909,1001,1551,1771,2442,3553,4114,5335,5775,6336,6996,8008,8228,9009,9559,9669,9889,12121,14241,16261,16761,17171,18081,18381,20102,20602,21012", "code": "\nfrom itertools import product\nfrom sympy import factorint, isprime\ndef pals(d, base=10): \n    digits = \"\".join(str(i) for i in range(base))\n    for p in product(digits, repeat=d//2):\n        if d > 1 and p[0] == \"0\": continue\n        left = \"\".join(p); right = left[::-1]\n        for mid in [[\"\"], digits][d%2]: yield int(left + mid + right)\ndef ok(pal):\n    f = factorint(pal); return len(f)>1 and isprime(sum(p*f[p] for p in f))\nprint(list(filter(ok, (p for d in range(1, 6) for p in pals(d) if ok(p))))) \n"}
{"sequence_id": "A046380", "text": "Palindromes with exactly 6 palindromic prime factors (counted with multiplicity).", "sequence": "2772,6776,25452,59895,88788,549945,1931391,8117118,8447448,51033015,52711725,58344385,103838301,535707535,620434026,1663223661,8262112628,15271417251,25227972252,27747974772,27974547972,92628082629,97079897079,6421339331246,8401825281048", "code": "\nfrom sympy import factorint\ndef palQgen10(l): \n....if l > 0:\n........yield 0\n........for x in range(1,l+1):\n............for y in range(10**(x-1),10**x):\n................s = str(y)\n................yield int(s+s[-2::-1])\n............for y in range(10**(x-1),10**x):\n................s = str(y)\n................yield int(s+s[::-1])\nA046380_list = []\nfor x in palQgen10(6):\n....a = factorint(x)\n....if sum(list(a.values())) == 6:\n........for p in a:\n............s = str(p)\n............if s != s[::-1]:\n................break\n........else:\n............A046380_list.append(x) \n"}
{"sequence_id": "A046392", "text": "Palindromes with exactly 2 distinct prime factors.", "sequence": "6,22,33,55,77,111,141,161,202,262,303,323,393,454,505,515,535,545,565,626,707,717,737,767,818,838,878,898,939,949,959,979,989,1111,1441,1661,1991,3113,3223,3443,3883,7117,7447,7997,9119,9229,9449,10001", "code": "\nfrom sympy import factorint\nfrom itertools import product\ndef pals(d, base=10): \n    digits = \"\".join(str(i) for i in range(base))\n    for p in product(digits, repeat=d//2):\n        if d > 1 and p[0] == \"0\": continue\n        left = \"\".join(p); right = left[::-1]\n        for mid in [[\"\"], digits][d%2]: yield int(left + mid + right)\ndef ok(pal): f = factorint(pal); return len(f) == 2 and sum(f.values()) == 2\nprint(list(filter(ok, (p for d in range(1, 5) for p in pals(d) if ok(p))))) \n"}
{"sequence_id": "A046408", "text": "Palindromes with exactly 2 distinct palindromic prime factors.", "sequence": "6,22,33,55,77,202,262,303,393,505,626,707,939,1111,1441,1661,1991,3443,3883,7997,13231,15251,18281,19291,20602,22622,22822,24842,26662,28682,30903,31613,33933,35653,37673,38683,39993,60206,60406,60806,62026,64646,64846", "code": "\nfrom sympy import factorint\nfrom itertools import product\ndef ispal(n): s = str(n); return s == s[::-1]\ndef pals(d, base=10): \n    digits = \"\".join(str(i) for i in range(base))\n    for p in product(digits, repeat=d//2):\n        if d > 1 and p[0] == \"0\": continue\n        left = \"\".join(p); right = left[::-1]\n        for mid in [[\"\"], digits][d%2]: yield int(left + mid + right)\ndef ok(pal):\n    f = factorint(pal)\n    return len(f) == 2 and sum(f.values()) == 2 and all(ispal(p) for p in f)\nprint(list(filter(ok, (p for d in range(1, 6) for p in pals(d) if ok(p))))) \n"}
{"sequence_id": "A046411", "text": "Composite numbers the concatenation of whose prime factors is a prime.", "sequence": "6,12,18,21,22,28,33,39,46,51,52,54,58,63,66,70,82,84,93,98,111,115,117,133,141,142,148,154,159,162,165,166,171,172,175,177,182,187,198,201,205,207,210,219,220,226,232,235,237,245,246,247,249,253,255,261", "code": "\nfrom sympy import isprime, factorint\ndef ok(n):\n    f = factorint(n)\n    if sum(e for e in f.values()) < 2: return False\n    return isprime(int(\"\".join(str(p)*e for p, e in f.items())))\nprint(list(filter(ok, range(2, 262)))) \n"}
{"sequence_id": "A046447", "text": "Apart from initial term, composite numbers with property that concatenation of prime factors is a palindrome.", "sequence": "1,4,8,9,16,25,27,32,39,49,64,69,81,119,121,125,128,129,159,219,243,249,256,259,329,339,343,403,429,469,507,512,625,669,679,729,795,1024,1207,1309,1329,1331,1533,1547,1587,1589,1703,2023,2048,2097,2187,2319", "code": "\nfrom sympy import factorint, isprime\nA046447_list = [1]\nfor n in range(4,10**6):\n....if not isprime(n):\n........s = ''.join([str(p)*e for p,e in sorted(factorint(n).items())])\n........if s == s[::-1]:\n............A046447_list.append(n) \n"}
{"sequence_id": "A046477", "text": "Primes that are palindromic in bases 8 and 10.", "sequence": "2,3,5,7,373,13331,30103,1496941,1970791", "code": " \nfrom sympy import isprime\nfrom itertools import product\ndef candidate_prime_pals(digits):\n  ruled_out = \"024568\" \n  midrange = [[\"\"], \"0123456789\"]\n  for p in product(\"0123456789\", repeat=digits//2):\n    left = \"\".join(p)\n    if len(left):\n      if left[0] in ruled_out: continue\n    for middle in midrange[digits%2]:\n      yield left+middle+left[::-1]\nfor digits in range(1, 15):\n  for p in candidate_prime_pals(digits):\n    intp = int(p); octp = oct(intp)[2:]\n    if octp==octp[::-1]:\n      if isprime(intp):\n        print(intp, end=\", \") \n"}
{"sequence_id": "A046477", "text": "Primes that are palindromic in bases 8 and 10.", "sequence": "2,3,5,7,373,13331,30103,1496941,1970791", "code": " \nfrom sympy import isprime\ndef ispal(n): strn = str(n); return strn==strn[::-1]\nfor n in range(10**7):\n  if ispal(n) and ispal(oct(n)[2:]) and isprime(n):\n    print(n) \n"}
{"sequence_id": "A046498", "text": "Palindromes expressible as the sum of 3 consecutive palindromes.", "sequence": "6,9,66,99,333,363,393,636,666,696,939,969,999,3333,3663,3993,6336,6666,6996,9339,9669,9999,30303,30603,30903,33333,33633,33933,36363,36663,36963,39393,39693,39993,60306,60606,60906,63336,63636,63936", "code": "\nfrom itertools import product\ndef ispal(n): s = str(n); return s == s[::-1]\ndef pals(d, base=10): \n  digits = \"\".join(str(i) for i in range(base))\n  for p in product(digits, repeat=d//2):\n    if d > 1 and p[0] == \"0\": continue\n    left = \"\".join(p); right = left[::-1]\n    for mid in [[\"\"], digits][d%2]: yield int(left + mid + right)\ndef auptod(dd):\n  alst  = [6, 9]\n  last3 = [7, 8, 9]\n  for d in range(2, dd+1):\n    for p in pals(d):\n      last3 = last3[1:] + [p]\n      if ispal(sum(last3)): alst.append(sum(last3))\n  return alst\nprint(auptod(5)) \n"}
{"sequence_id": "A046523", "text": "Smallest number with same prime signature as n.", "sequence": "1,2,2,4,2,6,2,8,4,6,2,12,2,6,6,16,2,12,2,12,6,6,2,24,4,6,8,12,2,30,2,32,6,6,6,36,2,6,6,24,2,30,2,12,12,6,2,48,4,12,6,12,2,24,6,24,6,6,2,60,2,6,12,64,6,30,2,12,6,30,2,72,2,6,12,12,6,30,2,48,16,6,2,60,6,6,6,24,2", "code": "\nfrom sympy import factorint\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1 \n"}
{"sequence_id": "A046657", "text": "a(n) = A002088(n)/2.", "sequence": "1,2,3,5,6,9,11,14,16,21,23,29,32,36,40,48,51,60,64,70,75,86,90,100,106,115,121,135,139,154,162,172,180,192,198,216,225,237,245,265,271,292,302,314,325,348,356,377,387,403,415,441,450,470,482", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A046657(n): \n    if n == 0:\n        return 0\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(4*A046657(k1)-1)\n        j, k1 = j2, n//j2\n    return (n*(n-1)-c+j)//4 \n"}
{"sequence_id": "A046694", "text": "Ramanujan tau numbers mod 691 = sum of 11th power of divisors mod 691.", "sequence": "1,667,252,601,684,171,531,178,372,168,469,123,629,385,309,388,611,55,672,630,449,491,92,632,57,106,88,580,173,185,366,666,27,538,429,379,622,456,269,136,87,280,36,632,160,556,435,345,194,14,570,52,209,652,172,542,49", "code": "\nfrom sympy import divisor_sigma\ndef a(n): return divisor_sigma(n, 11)%691 \n"}
{"sequence_id": "A046699", "text": "a(1) = a(2) = 1, a(n) = a(n - a(n-1)) + a(n-1 - a(n-2)) if n > 2.", "sequence": "1,1,2,2,3,4,4,4,5,6,6,7,8,8,8,8,9,10,10,11,12,12,12,13,14,14,15,16,16,16,16,16,17,18,18,19,20,20,20,21,22,22,23,24,24,24,24,25,26,26,27,28,28,28,29,30,30,31,32,32,32,32,32,32,33,34,34,35,36,36,36,37", "code": "\nfrom sympy import factorial\ndef a(n):\n    if n<3: return 1\n    s=1\n    while factorial(2*s)%(2**(n - 1))>0: s+=1\n    return s\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A046705", "text": "Palindromic primes whose product of digits is a prime.", "sequence": "2,3,5,7,131,151,11311,1117111,111111151111111,111111111111111111131111111111111111111,1111111111111111111111111111111117111111111111111111111111111111111,1111111111111111111111111111111111111111111115111111111111111111111111111111111111111111111", "code": "\nfrom __future__ import division\nfrom sympy import isprime\nA046705_list = [n for n in ((10**(2*l+1)-1)//9+d*10**l for l in range(100) for d in [1,2,4,6]) if isprime(n)] \n"}
{"sequence_id": "A046732", "text": "\"Norep emirps\": primes with distinct digits which remain prime when reversed.", "sequence": "2,3,5,7,13,17,31,37,71,73,79,97,107,149,157,167,179,347,359,389,701,709,739,743,751,761,769,907,937,941,953,967,971,983,1069,1097,1237,1249,1259,1279,1283,1409,1429,1439,1453,1487,1523,1583,1597,1657,1723,1753", "code": "\nfrom sympy import prime, isprime\nA046732 = [p for p in (prime(n) for n in range(1,10**3)) if len(str(p)) == len(set(str(p))) and isprime(int(str(p)[::-1]))] \n"}
{"sequence_id": "A046798", "text": "Number of divisors of 2^n + 1.", "sequence": "2,2,2,3,2,4,4,4,2,8,6,4,4,4,8,12,2,4,16,4,4,12,8,4,8,16,16,20,4,8,48,4,4,24,16,32,16,8,16,12,4,8,64,4,8,64,32,8,8,8,64,48,8,8,64,48,8,24,8,16,16,4,32,64,4,64,64,8,12,24,96,8,32,8,32,96,16,64,768,4,8,192,32,64", "code": "\nfrom sympy.ntheory import divisor_count\ndef A046798(n): return divisor_count(2**n + 1) \n"}
{"sequence_id": "A046820", "text": "Number of 1's in binary expansion of 5n.", "sequence": "0,2,2,4,2,3,4,3,2,4,3,5,4,2,3,4,2,4,4,6,3,4,5,5,4,6,2,4,3,3,4,5,2,4,4,6,4,5,6,4,3,5,4,6,5,4,5,6,4,6,6,8,2,3,4,4,3,5,3,5,4,4,5,6,2,4,4,6,4,5,6,5,4,6,5,7,6,3,4,5,3,5,5,7,4,5,6,6,5,7,4,6,5", "code": "\ndef A046820(n):\n....return bin(5*n)[2:].count(\"1\") \n"}
{"sequence_id": "A047241", "text": "Numbers that are congruent to {1, 3} mod 6.", "sequence": "1,3,7,9,13,15,19,21,25,27,31,33,37,39,43,45,49,51,55,57,61,63,67,69,73,75,79,81,85,87,91,93,97,99,103,105,109,111,115,117,121,123,127,129,133,135,139,141,145,147,151,153,157,159,163,165,169,171,175,177,181,183", "code": " for n in range(1,10**5):print(3*n-2-((n+1)%2)) \n"}
{"sequence_id": "A047390", "text": "Numbers that are congruent to {0, 3, 5} mod 7.", "sequence": "0,3,5,7,10,12,14,17,19,21,24,26,28,31,33,35,38,40,42,45,47,49,52,54,56,59,61,63,66,68,70,73,75,77,80,82,84,87,89,91,94,96,98,101,103,105,108,110,112,115,117,119,122,124,126,129,131,133,136,138,140,143", "code": "\nimport math\na = lambda n: 2*(n-1)+math.ceil((n-1)/3.0)\nfor n in range(1,101): print(a(n), end = \", \") \n"}
{"sequence_id": "A047714", "text": "Sums of 3 but no fewer nonzero fourth powers.", "sequence": "3,18,33,48,83,98,113,163,178,243,258,273,288,338,353,418,513,528,593,627,642,657,707,722,768,787,882,897,962,1137,1251,1266,1298,1313,1328,1331,1378,1393,1458,1506,1553,1568,1633,1808,1875,1922,1937,2002,2177", "code": "\ndef aupto(lim):\n  p1 = set(i**4 for i in range(1, int(lim**.25)+2) if i**4 <= lim)\n  p2 = set(a+b for a in p1 for b in p1 if a+b <= lim)\n  p3 = set(apb+c for apb in p2 for c in p1 if apb+c <= lim)\n  return sorted(p3-p2-p1)\nprint(aupto(2400)) \n"}
{"sequence_id": "A047715", "text": "Numbers that are the sum of 4 but no fewer nonzero fourth powers.", "sequence": "4,19,34,49,64,84,99,114,129,164,179,194,244,259,274,289,304,324,339,354,369,419,434,499,514,529,544,594,609,628,643,658,673,674,708,723,738,769,784,788,803,849,868,883,898,913,963,978,1024,1043,1138,1153", "code": "\nlimit = 1153\nfrom functools import lru_cache\nqd = [k**4 for k in range(1, int(limit**.25)+2) if k**4 + 3 <= limit]\nqds = set(qd)\n@lru_cache(maxsize=None)\ndef findsums(n, m):\n  if m == 1: return {(n,)} if n in qds else set()\n  return set(tuple(sorted(t+(q,))) for q in qds for t in findsums(n-q, m-1))\nA003338s = set(n for n in range(4, limit+1) if len(findsums(n, 4)) >= 1)\nA003337s = set(n for n in range(3, limit+1) if len(findsums(n, 3)) >= 1)\nA003336s = set(n for n in range(2, limit+1) if len(findsums(n, 2)) >= 1)\nprint(sorted(A003338s - A003337s - A003336s - qds)) \n"}
{"sequence_id": "A047716", "text": "Sums of 5 but no fewer nonzero fourth powers.", "sequence": "5,20,35,50,65,80,85,100,115,130,145,165,180,195,210,245,260,275,290,305,320,325,340,355,370,385,405,420,435,450,500,515,530,545,560,580,595,610,629,644,659,675,689,690,709,724,739,754,755,770,785,789,800", "code": "\nfrom itertools import combinations_with_replacement as combs_with_rep\ndef aupto(limit):\n  qd = [k**4 for k in range(1, int(limit**.25)+2) if k**4 + 4 <= limit]\n  ss = [set(sum(c) for c in combs_with_rep(qd, k)) for k in range(6)]\n  return sorted(filter(lambda x: x <= limit, ss[5]-ss[4]-ss[3]-ss[2]-ss[1]))\nprint(aupto(800)) \n"}
{"sequence_id": "A047718", "text": "Numbers that are the sum of 7 but no fewer nonzero fourth powers.", "sequence": "7,22,37,52,67,87,102,112,117,132,147,167,177,182,197,212,227,242,247,262,277,292,307,322,327,342,352,357,372,387,402,407,417,422,437,452,467,482,487,502,517,532,547,562,567,577,582,592,597,612,631,646,662", "code": "\nfrom itertools import combinations_with_replacement as mc\ndef aupto(limit):\n    qd = [k**4 for k in range(1, int(limit**.25)+2) if k**4 + 6 <= limit]\n    ss = [set(sum(c) for c in mc(qd, i)) for i in range(8)]\n    s7nf = ss[7] - ss[6] - ss[5] - ss[4] - ss[3] - ss[2] - ss[1]\n    return sorted(s for s in s7nf if s <= limit)\nprint(aupto(663)) \n"}
{"sequence_id": "A047721", "text": "Sum of 10 but no fewer nonzero fourth powers.", "sequence": "10,25,40,55,70,90,105,120,135,150,160,170,185,200,215,225,230,250,265,280,295,310,330,345,360,375,390,400,410,425,440,455,465,470,485,490,505,520,535,550,565,570,585,600,615,634,640,650,665,680,695,714,730", "code": "\nfrom itertools import count, takewhile, combinations_with_replacement as mc\ndef aupto(lim):\n    p4 = list(takewhile(lambda x: x <= lim, (i**4 for i in count(1))))\n    s = [set(sum(c) for c in mc(p4, i) if sum(c) <= lim) for i in range(11)]\n    ans = s[10]\n    for i in range(1, 10):\n        ans -= s[i]\n    return sorted(ans)\nprint(aupto(730)) \n"}
{"sequence_id": "A047778", "text": "Concatenation of first n numbers in binary, converted to base 10.", "sequence": "1,6,27,220,1765,14126,113015,1808248,28931977,462911642,7406586283,118505380540,1896086088653,30337377418462,485398038695407,15532737238253040,497047591624097297,15905522931971113522", "code": "\ndef a(n): return int(\"\".join([(bin(i))[2:] for i in range(1, n+1)]), 2)\nprint([a(n) for n in range(1, 19)]) \n"}
{"sequence_id": "A047781", "text": "a(n) = Sum_{k=0..n-1} binomial(n-1,k)*binomial(n+k,k). Also a(n) = T(n,n), array T as in A049600.", "sequence": "0,1,4,19,96,501,2668,14407,78592,432073,2390004,13286043,74160672,415382397,2333445468,13141557519,74174404608,419472490257,2376287945572,13482186743203,76598310928096,435730007006341,2481447593848524,14146164790774359", "code": "\nfrom sympy import binomial\ndef a(n):\n    return sum(binomial(n - 1, k) * binomial(n + k, k) for k in range(n))\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A047842", "text": "Describe n (count digits in order of increasing value, ignoring missing digits).", "sequence": "10,11,12,13,14,15,16,17,18,19,1011,21,1112,1113,1114,1115,1116,1117,1118,1119,1012,1112,22,1213,1214,1215,1216,1217,1218,1219,1013,1113,1213,23,1314,1315,1316,1317,1318,1319,1014,1114,1214,1314,24,1415,1416", "code": "\ndef A047842(n):\n    s, x = '', str(n)\n    for i in range(10):\n        y = str(i)\n        c = str(x.count(y))\n        if c != '0':\n            s += c+y\n    return int(s) \n"}
{"sequence_id": "A047863", "text": "Number of labeled graphs with 2-colored nodes where black nodes are only connected to white nodes and vice versa.", "sequence": "1,2,6,26,162,1442,18306,330626,8488962,309465602,16011372546,1174870185986,122233833963522,18023122242478082,3765668654914699266,1114515608405262434306,467221312005126294077442,277362415313453291571118082", "code": "\nfrom sympy import binomial\ndef a(n): return sum([binomial(n, k)*2**(k*(n - k)) for k in range(n + 1)]) \n"}
{"sequence_id": "A047898", "text": "a(1) = 6; for n > 0, a(n+1) = a(n) * (sum of digits of a(n)).", "sequence": "6,36,324,2916,52488,1417176,38263752,1377495072,61987278240,3347313024960,150629086123200,6778308875544000,488038239039168000,35138753210820096000,2213741452281666048000,159389384564279955456000", "code": "\nA047898_list, l = [6], 6\nfor _ in range(10**2):\n....l *= sum(int(d) for d in str(l))\n....A047898_list.append(l) \n"}
{"sequence_id": "A047901", "text": "a(1) = 9; a(n+1) = a(n) * sum of decimal digits of a(n).", "sequence": "9,81,729,13122,118098,3188646,114791256,4132485216,148769467776,10711401679872,578415690713088,41645929731342336,2998506940656648192,296852187125008171008,24045027157125661851648,2164052444141309566648320", "code": "\nA047901_list, l = [9], 9\nfor _ in range(10**2):\n....l *= sum(int(d) for d in str(l))\n....A047901_list.append(l) \n"}
{"sequence_id": "A047904", "text": "a(n+1) = a(n) + n (if n is odd), a(n+1) = a(n) * n (if n is even).", "sequence": "1,2,4,7,28,33,198,205,1640,1649,16490,16501,198012,198025,2772350,2772365,44357840,44357857,798441426,798441445,15968828900,15968828921,351314236262,351314236285,8431541670840,8431541670865,219220083442490", "code": "\na=1\nfor n in range(1,33):\n    print(a, end=\", \")\n    if n&1:\n        a += n\n    else:\n        a *= n\n\n"}
{"sequence_id": "A047905", "text": "a(n+1) = a(n) + n (if n is even), a(n+1) = a(n) * n (if n is odd).", "sequence": "1,1,3,9,13,65,71,497,505,4545,4555,50105,50117,651521,651535,9773025,9773041,166141697,166141715,3156692585,3156692605,66290544705,66290544727,1524682528721,1524682528745,38117063218625,38117063218651", "code": "\na=1\nfor n in range(1,33):\n    print(a, end=\", \")\n    if n&1:\n        a *= n\n    else:\n        a += n\n\n"}
{"sequence_id": "A047924", "text": "a(n) = B_{A_n+1}+1, where A_n = floor(n*phi) = A000201(n), B_n = floor(n*phi^2) = A001950(n) and phi is the golden ratio.", "sequence": "3,6,11,14,19,24,27,32,35,40,45,48,53,58,61,66,69,74,79,82,87,90,95,100,103,108,113,116,121,124,129,134,137,142,147,150,155,158,163,168,171,176,179,184,189,192,197,202,205,210,213,218,223,226,231,234,239", "code": "\nfrom mpmath import *\nmp.dps=100\nimport math\ndef A(n): return int(math.floor(n*phi))\ndef B(n): return int(math.floor(n*phi**2))\ndef a(n): return B(A(n) + 1) + 1 \n"}
{"sequence_id": "A047972", "text": "Distance of n-th prime to nearest square.", "sequence": "1,1,1,2,2,3,1,3,2,4,5,1,5,6,2,4,5,3,3,7,8,2,2,8,3,1,3,7,9,8,6,10,7,5,5,7,12,6,2,4,10,12,5,3,1,3,14,2,2,4,8,14,15,5,1,7,13,15,12,8,6,4,17,13,11,7,7,13,14,12,8,2,6,12,18,17,11,3,1,9,19,20,10,8,2,2,8,16,20,21", "code": "\nfrom sympy import integer_nthroot, prime\ndef A047972(n):\n    p = prime(n)\n    a = integer_nthroot(p,2)[0]\n    return min(p-a**2,(a+1)**2-p) \n"}
{"sequence_id": "A047983", "text": "Number of integers less than n but with the same number of divisors.", "sequence": "0,0,1,0,2,0,3,1,1,2,4,0,5,3,4,0,6,1,7,2,5,6,8,0,2,7,8,3,9,1,10,4,9,10,11,0,11,12,13,2,12,3,13,5,6,14,14,0,3,7,15,8,15,4,16,5,17,18,16,0,17,19,9,0,20,6,18,10,21,7,19,1,20,22,11,12,23,8,21,1,1,24,22,2,25,26,27", "code": "\nfrom sympy import divisor_count as D\ndef a(n): return sum([1 for k in range(1, n) if D(k) == D(n)]) \n"}
{"sequence_id": "A047994", "text": "Unitary totient (or unitary phi) function uphi(n).", "sequence": "1,1,2,3,4,2,6,7,8,4,10,6,12,6,8,15,16,8,18,12,12,10,22,14,24,12,26,18,28,8,30,31,20,16,24,24,36,18,24,28,40,12,42,30,32,22,46,30,48,24,32,36,52,26,40,42,36,28,58,24,60,30,48,63,48,20,66,48,44,24,70", "code": "\nfrom math import prod\nfrom sympy import factorint\ndef A047994(n): return prod(p**e-1 for p, e in factorint(n).items()) \n"}
{"sequence_id": "A047999", "text": "Sierpi\u0144ski's [Sierpinski's] triangle (or gasket): triangle, read by rows, formed by reading Pascal's triangle mod 2.", "sequence": "1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1", "code": "\ndef A047999_T(n,k):\n    return int(not ~n & k) \n"}
{"sequence_id": "A048004", "text": "Triangular array read by rows: T(n,k) = number of binary vectors of length n whose longest run of consecutive 1's has length k, for n >= 0, 0 <= k <= n.", "sequence": "1,1,1,1,2,1,1,4,2,1,1,7,5,2,1,1,12,11,5,2,1,1,20,23,12,5,2,1,1,33,47,27,12,5,2,1,1,54,94,59,28,12,5,2,1,1,88,185,127,63,28,12,5,2,1,1,143,360,269,139,64,28,12,5,2,1,1,232,694,563,303,143,64,28,12,5,2,1,1,376,1328,1167,653,315,144,64,28,12,5,2,1", "code": " \n"}
{"sequence_id": "A048050", "text": "Chowla's function: sum of divisors of n except 1 and n.", "sequence": "0,0,0,2,0,5,0,6,3,7,0,15,0,9,8,14,0,20,0,21,10,13,0,35,5,15,12,27,0,41,0,30,14,19,12,54,0,21,16,49,0,53,0,39,32,25,0,75,7,42,20,45,0,65,16,63,22,31,0,107,0,33,40,62,18,77,0,57,26,73,0,122,0,39,48,63,18,89", "code": "\nfrom sympy import divisors\ndef a(n): return sum(divisors(n)[1:-1]) \n"}
{"sequence_id": "A048050", "text": "Chowla's function: sum of divisors of n except 1 and n.", "sequence": "0,0,0,2,0,5,0,6,3,7,0,15,0,9,8,14,0,20,0,21,10,13,0,35,5,15,12,27,0,41,0,30,14,19,12,54,0,21,16,49,0,53,0,39,32,25,0,75,7,42,20,45,0,65,16,63,22,31,0,107,0,33,40,62,18,77,0,57,26,73,0,122,0,39,48,63,18,89", "code": "\nfrom sympy import divisor_sigma\ndef A048050(n): return 0 if n == 1 else divisor_sigma(n)-n-1 \n"}
{"sequence_id": "A048054", "text": "Number of n-digit reversible primes (emirps).", "sequence": "4,9,43,204,1499,9538,71142,535578,4197196,33619380,274932272,2294771254,19489886063", "code": "\nfrom sympy import isprime, primerange\ndef A048054(n):\n    return len([p for p in primerange(10**(n-1),10**n)\n                if isprime(int(str(p)[::-1]))]) \n"}
{"sequence_id": "A048055", "text": "Numbers n such that (sum of the nonprime proper divisors of n) - (sum of prime divisors of n) = n.", "sequence": "532,945,2624,5704,6536,229648,497696,652970,685088,997408,1481504,11177984,32869504,52813084,132612224,224841856,2140668416,2404135424,2550700288,6469054976,9367192064,19266023936,23414463358,31381324288,45812547584,55620289024", "code": "\nfrom sympy import divisors, primefactors\nA048055 = []\nfor n in range(1,10**4):\n....s = sum(divisors(n))\n....if not s % 2 and 2*n <= s and (s-2*n)/2 == sum(primefactors(n)):\n........A048055.append(n) \n"}
{"sequence_id": "A048106", "text": "Number of unitary divisors of n (A034444) - number of non-unitary divisors of n (A048105).", "sequence": "1,2,2,1,2,4,2,0,1,4,2,2,2,4,4,-1,2,2,2,2,4,4,2,0,1,4,0,2,2,8,2,-2,4,4,4,-1,2,4,4,0,2,8,2,2,2,4,2,-2,1,2,4,2,2,0,4,0,4,4,2,4,2,4,2,-3,4,8,2,2,4,8,2,-4,2,4,2,2,4,8,2,-2,-1,4,2,4,4,4,4,0,2,4,4,2,4,4,4,-4,2,2,2", "code": "\nfrom sympy import divisor_count, primefactors\ndef a(n): return 1 if n==1 else 2**(1 + len(primefactors(n))) - divisor_count(n) \n"}
{"sequence_id": "A048175", "text": "Size of range 1..m generatable from the digits of an n-digit integer and + - x /.", "sequence": "3,10,51,192,963,4021", "code": " \n"}
{"sequence_id": "A048291", "text": "Number of {0,1} n X n matrices with no zero rows or columns.", "sequence": "1,1,7,265,41503,24997921,57366997447,505874809287625,17343602252913832063,2334958727565749108488321,1243237913592275536716800402887,2630119877024657776969635243647463625", "code": "\nimport math\nf = math.factorial\ndef A048291(n): return sum([(f(n)/f(s)/f(n - s))*(-1)**s*(2**(n - s) - 1)**n for s in range(0, n+1)]) \n"}
{"sequence_id": "A048332", "text": "a(n) in base 7 is a repdigit.", "sequence": "0,1,2,3,4,5,6,8,16,24,32,40,48,57,114,171,228,285,342,400,800,1200,1600,2000,2400,2801,5602,8403,11204,14005,16806,19608,39216,58824,78432,98040,117648,137257,274514,411771,549028,686285,823542,960800", "code": "\nA048332_list = [0] + [int(d*l,7) for l in range(1,10) for d in '123456'] \n"}
{"sequence_id": "A048335", "text": "a(n) in base 11 is a repdigit.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,12,24,36,48,60,72,84,96,108,120,133,266,399,532,665,798,931,1064,1197,1330,1464,2928,4392,5856,7320,8784,10248,11712,13176,14640,16105,32210,48315,64420,80525,96630,112735,128840", "code": "\nA048335_list = [0] + [int(d*l,11) for l in range(1,10) for d in '123456789a'] \n"}
{"sequence_id": "A048336", "text": "a(n) in base 12 is a repdigit.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,11,13,26,39,52,65,78,91,104,117,130,143,157,314,471,628,785,942,1099,1256,1413,1570,1727,1885,3770,5655,7540,9425,11310,13195,15080,16965,18850,20735,22621,45242,67863,90484,113105", "code": "\nA048336_list = [0] + [int(d*l,12) for l in range(1,10) for d in '123456789ab'] \n"}
{"sequence_id": "A048337", "text": "a(n) in base 13 is a repdigit.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,11,12,14,28,42,56,70,84,98,112,126,140,154,168,183,366,549,732,915,1098,1281,1464,1647,1830,2013,2196,2380,4760,7140,9520,11900,14280,16660,19040,21420,23800,26180,28560,30941,61882", "code": "\nA048337_list = [0] + [int(d*l,13) for l in range(1,10) for d in '123456789abc'] \n"}
{"sequence_id": "A048338", "text": "a(n) in base 14 is a repdigit.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,11,12,13,15,30,45,60,75,90,105,120,135,150,165,180,195,211,422,633,844,1055,1266,1477,1688,1899,2110,2321,2532,2743,2955,5910,8865,11820,14775,17730,20685,23640,26595,29550,32505,35460", "code": "\nA048338_list = [0] + [int(d*l,14) for l in range(1,10) for d in '123456789abcd'] \n"}
{"sequence_id": "A048339", "text": "a(n) in base 15 is a repdigit.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,16,32,48,64,80,96,112,128,144,160,176,192,208,224,241,482,723,964,1205,1446,1687,1928,2169,2410,2651,2892,3133,3374,3616,7232,10848,14464,18080,21696,25312,28928,32544", "code": "\nA048339_list = [0] + [int(d*l,15) for l in range(1,10) for d in '123456789abcde'] \n"}
{"sequence_id": "A048340", "text": "a(n) in base 16 is a repdigit.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255,273,546,819,1092,1365,1638,1911,2184,2457,2730,3003,3276,3549,3822,4095,4369,8738,13107,17476,21845,26214,30583", "code": "\nA048340_list = [0] + [int(d*l,16) for l in range(1,10) for d in '123456789abcdef'] \n"}
{"sequence_id": "A048343", "text": "Total number of distinct palindromes of form 'n-digit number' x 'n-digit number_reversed' (n-digit number not palindromic).", "sequence": "0,1,3,10,19,44,86,171,308,551,920", "code": "\ndef A048343(n):\n....y, plist = 0, []\n....for i in range(10**(n-1),10**n):\n........s1 = str(i)\n........s2 = s1[::-1]\n........if s1 != s2:\n............p = i*int(s2)\n............if not p in plist:\n................sp = str(p)\n................if sp == sp[::-1]:\n....................plist.append(p)\n....................y += 1\n....return y \n"}
{"sequence_id": "A048344", "text": "a(n) * a(n)_reversed is a palindrome (and a(n) is not palindromic).", "sequence": "12,21,102,112,122,201,211,221,1002,1011,1012,1021,1022,1101,1102,1112,1121,1201,1202,1211,2001,2011,2012,2021,2101,2102,2111,2201,10002,10011,10012,10021,10022,10102,10111,10112,10121,10202,10211,11001", "code": "\nA048344_list = []\nfor n in range(1,10**5):\n....s = str(n)\n....s2 = str(n)[::-1]\n....if s != s2:\n........s3 = str(n*int(s2))\n........if s3 == s3[::-1]:\n............A048344_list.append(n) \n"}
{"sequence_id": "A048351", "text": "a(n)^2 is the smallest square containing exactly n 6's.", "sequence": "4,26,216,1291,5164,68313,163284,785294,3559026,26393686,129099069,254296413,816435342,4081257976,80413106314,215329205326,2463064689907,5165911014784,24832773982716,81401883640163", "code": "\ndef a(n):\n  k = 1\n  while not str(k**2).count('6') == n: k += 1\n  return k\nprint([a(n) for n in range(1, 11)]) \n"}
{"sequence_id": "A048375", "text": "Numbers whose square is a concatenation of two nonzero squares.", "sequence": "7,13,19,35,38,41,57,65,70,125,130,190,205,223,253,285,305,350,380,410,475,487,570,650,700,721,905,975,985,1012,1201,1250,1265,1300,1301,1442,1518,1771,1900,2024,2050,2163,2225,2230,2277,2402,2435,2530,2850", "code": "\nfrom math import isqrt\ndef issquare(n): return isqrt(n)**2 == n\ndef ok(n):\n  d = str(n)\n  for i in range(1, len(d)):\n    if d[i] != '0' and issquare(int(d[:i])) and issquare(int(d[i:])):\n      return True\n  return False\nprint([r for r in range(2851) if ok(r*r)]) \n"}
{"sequence_id": "A048385", "text": "In base-10 notation replace digits of n with their squared values (Version 1).", "sequence": "0,1,4,9,16,25,36,49,64,81,10,11,14,19,116,125,136,149,164,181,40,41,44,49,416,425,436,449,464,481,90,91,94,99,916,925,936,949,964,981,160,161,164,169,1616,1625,1636,1649,1664,1681,250,251,254,259,2516,2525", "code": "\ndef digits(n):\n    d=[]\n    while n>0:\n        d.append(n%10)\n        n=n//10\n    return d\ndef sqdig(n):\n    new=0\n    num=digits(n)\n    spacing=0\n    while num:\n        k=num.pop(0)\n        new+=(10**(spacing))*(k**2)\n        if k>3:\n            spacing+=1\n        spacing+=1\n    return new\n\n"}
{"sequence_id": "A048393", "text": "Replacing digits d in decimal expansion of n with d^3 yields a prime.", "sequence": "11,13,23,31,41,43,53,61,73,101,107,109,121,137,143,149,151,157,161,169,173,181,191,211,217,221,229,233,241,253,257,259,271,277,281,299,307,311,313,319,323,331,421,427,431,449,469,493,511,527,541,577,589", "code": "\nfrom sympy import primerange, isprime\nfor n in primerange(2,600):\n    t=int(''.join(str(int(i)**3) for i in str(n)))\n    if sympy.isprime(t):\n         print(n)\n\n"}
{"sequence_id": "A048411", "text": "Squares whose consecutive digits differ by 1.", "sequence": "0,1,4,9,121,676,12321,1234321,123454321,12345654321,1234567654321,123456787654321,12345678987654321", "code": "\nfrom sympy.ntheory.primetest import is_square\ndef gen(d, s=None):\n    if d == 0: yield tuple(); return\n    if s == None:\n        yield from [(i, ) + g for i in range(1, 10) for g in gen(d-1, s=i)]\n    else:\n        if s > 0: yield from [(s-1, ) + g for g in gen(d-1, s=s-1)]\n        if s < 9: yield from [(s+1, ) + g for g in gen(d-1, s=s+1)]\ndef afind(maxdigits):\n    print(0, end=\", \")\n    for d in range(1, maxdigits+1):\n        for g in gen(d, s=None):\n            t = int(\"\".join(map(str, g)))\n            if is_square(t): print(t, end=\", \")\nafind(17) \n"}
{"sequence_id": "A048543", "text": "a(n) is the smallest value of m such that A002378(m), the m-th oblong number, contains exactly n 7's.", "sequence": "8,108,878,870,8813,27924,84129,882483,2788865,7601169,88190572,421518419,4204014483,26034169427,42305694389,88022598108,546605779129", "code": "\ndef A048543(n):\n    k, m = 1, 2\n    while True:\n        if str(m).count('7') == n:\n            return k\n        k += 1\n        m += 2*k \n"}
{"sequence_id": "A048544", "text": "Smallest pronic number containing exactly n 7's.", "sequence": "72,11772,771762,757770,77677782,779777700,7077772770,778777127772,7777770777090,57777777767730,7777577077877756,177677777977777980,17673737777477771772,677777977779775677756,1789771777777771777710,7747977777770507777772,298777877777767737777770", "code": "\ndef A048544(n):\n    k, m = 1, 2\n    while True:\n        if str(m).count('7') == n:\n            return m\n        k += 1\n        m += 2*k \n"}
{"sequence_id": "A048611", "text": "Find smallest pair (x,y) such that x^2 - y^2 = 11...1 (n times) = (10^n-1)/9; sequence gives value of x.", "sequence": "1,6,20,56,156,340,2444,4440,167000,55556,267444,333400,132687920,5555556,10731400,40938800,2682647040,333334000,555555555555555556,3334367856,11034444280,35595935980,5555555555555555555556", "code": "\nfrom sympy import divisors\ndef A048611(n):\n    d = divisors((10**n-1)//9)\n    l = len(d)\n    return (d[l//2]+d[(l-1)//2])//2 \n"}
{"sequence_id": "A048612", "text": "Find smallest pair (x,y) such that x^2-y^2 = 11...1 (n times) = (10^n-1)/9; sequence gives value of y.", "sequence": "0,5,17,45,115,67,2205,2933,166667,44445,245795,6667,132683733,4444445,2012917,23767083,2680575317,666667,555555555555555555,83053525,3263104267,12488376483,5555555555555555555555,66666667,2952525627555", "code": "\nfrom sympy import divisors\ndef A048612(n):\n    d = divisors((10**n-1)//9)\n    l = len(d)\n    return (d[l//2]-d[(l-1)//2])//2 \n"}
{"sequence_id": "A048646", "text": "Primes p such that the decimal digits of p^2 can be partitioned into two or more nonzero squares.", "sequence": "7,13,19,37,41,107,191,223,379,487,997,1063,1093,1201,1301,1907,2029,3019,3169,3371,5081,5099,5693,6037,9041,9619,9721,9907,10007,11681,12227,12763,17393,18493,19013,19213,19219,21059,21157,21193,25931", "code": "\nfrom math import isqrt\nfrom sympy import primerange\ndef issquare(n): return isqrt(n)**2 == n\ndef ok(n, c):\n    if n%10 in {2, 3, 7, 8}: return False\n    if issquare(n) and c > 1: return True\n    d = str(n)\n    for i in range(1, len(d)):\n        if d[i] != '0' and issquare(int(d[:i])) and ok(int(d[i:]), c+1):\n            return True\n    return False\ndef aupto(lim): return [p for p in primerange(1, lim+1) if ok(p*p, 1)]\nprint(aupto(25931)) \n"}
{"sequence_id": "A048647", "text": "Write n in base 4, then replace each digit with its base-4 negative.", "sequence": "0,3,2,1,12,15,14,13,8,11,10,9,4,7,6,5,48,51,50,49,60,63,62,61,56,59,58,57,52,55,54,53,32,35,34,33,44,47,46,45,40,43,42,41,36,39,38,37,16,19,18,17,28,31,30,29,24,27,26,25,20,23,22,21,192,195,194,193,204,207,206", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a(n):\n    return int(\"\".join(str(4 - d) if d!=0 else '0' for d in digits(n, 4)[1:]), 4)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A048653", "text": "Numbers k such that the decimal digits of k^2 can be partitioned into two or more nonzero squares.", "sequence": "7,12,13,19,21,35,37,38,41,44,57,65,70,107,108,112,119,120,121,125,129,130,190,191,204,205,209,210,212,223,253,285,305,306,315,342,343,345,350,369,370,379,380,408,410,413,440,441,475,487,501,538,570,642,650", "code": "\nfrom math import isqrt\ndef issquare(n): return isqrt(n)**2 == n\ndef ok(n, c):\n    if n%10 in {2, 3, 7, 8}: return False\n    if issquare(n) and c > 1: return True\n    d = str(n)\n    for i in range(1, len(d)):\n        if d[i] != '0' and issquare(int(d[:i])) and ok(int(d[i:]), c+1):\n            return True\n    return False\ndef aupto(lim): return [r for r in range(lim+1) if ok(r*r, 1)]\nprint(aupto(650)) \n"}
{"sequence_id": "A048673", "text": "Permutation of natural numbers: a(n) = (A003961(n)+1) / 2 [where A003961(n) shifts the prime factorization of n one step towards larger primes].", "sequence": "1,2,3,5,4,8,6,14,13,11,7,23,9,17,18,41,10,38,12,32,28,20,15,68,25,26,63,50,16,53,19,122,33,29,39,113,21,35,43,95,22,83,24,59,88,44,27,203,61,74,48,77,30,188,46,149,58,47,31,158,34,56,138,365,60,98,36,86,73", "code": "\nfrom sympy import factorint, nextprime, prod\ndef a(n):\n    f = factorint(n)\n    return 1 if n==1 else (1 + prod(nextprime(i)**f[i] for i in f))//2 \n"}
{"sequence_id": "A048675", "text": "If n = p_i^e_i * ... * p_k^e_k, p_i < ... < p_k primes (with p_i = prime(i)), then a(n) = (1/2) * (e_i * 2^i + ... + e_k * 2^k).", "sequence": "0,1,2,2,4,3,8,3,4,5,16,4,32,9,6,4,64,5,128,6,10,17,256,5,8,33,6,10,512,7,1024,5,18,65,12,6,2048,129,34,7,4096,11,8192,18,8,257,16384,6,16,9,66,34,32768,7,20,11,130,513,65536,8,131072,1025,12,6,36,19", "code": "\nfrom sympy import factorint, primepi\ndef a(n):\n    if n==1: return 0\n    f=factorint(n)\n    return sum([f[i]*2**(primepi(i) - 1) for i in f])\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A048678", "text": "Binary expansion of nonnegative integers expanded to \"Zeckendorffian format\" with rewrite rules 0->0, 1->01.", "sequence": "0,1,2,5,4,9,10,21,8,17,18,37,20,41,42,85,16,33,34,69,36,73,74,149,40,81,82,165,84,169,170,341,32,65,66,133,68,137,138,277,72,145,146,293,148,297,298,597,80,161,162,325,164,329,330,661,168,337,338,677,340", "code": "\ndef a(n):\n    return 0 if n==0 else (3 - (-1)**n)*a(n//2) + (1 - (-1)**n)//2\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A048700", "text": "Binary palindromes of odd length (written in base 10).", "sequence": "1,5,7,17,21,27,31,65,73,85,93,99,107,119,127,257,273,297,313,325,341,365,381,387,403,427,443,455,471,495,511,1025,1057,1105,1137,1161,1193,1241,1273,1285,1317,1365,1397,1421,1453,1501,1533,1539,1571,1619,1651", "code": "\ndef A048700(n):\n    s = bin(n)[2:]\n    return int(s+s[-2::-1],2) \n"}
{"sequence_id": "A048701", "text": "List of binary palindromes of even length (written in base 10).", "sequence": "0,3,9,15,33,45,51,63,129,153,165,189,195,219,231,255,513,561,585,633,645,693,717,765,771,819,843,891,903,951,975,1023,2049,2145,2193,2289,2313,2409,2457,2553,2565,2661,2709,2805,2829,2925,2973,3069,3075,3171,3219,3315", "code": "\ndef A048701(n):\n    s = bin(n-1)[2:]\n    return int(s+s[::-1],2) \n"}
{"sequence_id": "A048703", "text": "Numbers which in base 4 are palindromes and have an even number of digits.", "sequence": "0,5,10,15,65,85,105,125,130,150,170,190,195,215,235,255,1025,1105,1185,1265,1285,1365,1445,1525,1545,1625,1705,1785,1805,1885,1965,2045,2050,2130,2210,2290,2310,2390", "code": "\ndef A048703(n):\n    s = bin(n-1)[2:]\n    if len(s) % 2: s = '0'+s\n    t = [s[i:i+2] for i in range(0,len(s),2)]\n    return int(''.join(t+t[::-1]),2) \n"}
{"sequence_id": "A048715", "text": "Binary expansion matches (100(0)*)*(0|1|10)?; or, Zeckendorf-like expansion of n using recurrence f(n) = f(n-1) + f(n-3).", "sequence": "0,1,2,4,8,9,16,17,18,32,33,34,36,64,65,66,68,72,73,128,129,130,132,136,137,144,145,146,256,257,258,260,264,265,272,273,274,288,289,290,292,512,513,514,516,520,521,528,529,530,544,545,546,548,576,577,578,580", "code": "\nimport re\ndef ok(n): return re.fullmatch('(100(0)*)*(0|1|10)?', bin(n)[2:]) != None\nprint(list(filter(ok, range(581)))) \n"}
{"sequence_id": "A048724", "text": "Write n and 2n in binary and add them mod 2.", "sequence": "0,3,6,5,12,15,10,9,24,27,30,29,20,23,18,17,48,51,54,53,60,63,58,57,40,43,46,45,36,39,34,33,96,99,102,101,108,111,106,105,120,123,126,125,116,119,114,113,80,83,86,85,92,95,90,89,72,75,78,77,68,71,66,65,192", "code": "\ndef A048724(n): return n^(n<<1) \n"}
{"sequence_id": "A048728", "text": "Differences between A008585 (multiples of 3) and A048724.", "sequence": "0,0,0,4,0,0,8,12,0,0,0,4,16,16,24,28,0,0,0,4,0,0,8,12,32,32,32,36,48,48,56,60,0,0,0,4,0,0,8,12,0,0,0,4,16,16,24,28,64,64,64,68,64,64,72,76,96,96,96,100,112,112,120", "code": "\ndef a(n): return 3*n - (2*n^n) \n"}
{"sequence_id": "A048735", "text": "a(n) = (n AND floor(n/2)), where AND is bitwise and-operator (A004198).", "sequence": "0,0,0,1,0,0,2,3,0,0,0,1,4,4,6,7,0,0,0,1,0,0,2,3,8,8,8,9,12,12,14,15,0,0,0,1,0,0,2,3,0,0,0,1,4,4,6,7,16,16,16,17,16,16,18,19,24,24,24,25,28,28,30,31,0,0,0,1,0,0,2,3,0,0,0,1,4,4,6,7,0", "code": "\ndef a(n): return n&int(n/2) \n"}
{"sequence_id": "A048764", "text": "Largest factorial <= n.", "sequence": "1,2,2,2,2,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24", "code": "\nfrom sympy import factorial as f\ndef a(n):\n    k=1\n    while f(k + 1)<=n: k+=1\n    return f(k)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A048766", "text": "Integer part of cube root of n. Or, number of cubes <= n. Or, n appears 3n^2 + 3n + 1 times.", "sequence": "0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4", "code": "\nfrom sympy import integer_nthroot\ndef a(n): return integer_nthroot(n, 3)[0]\nprint([a(n) for n in range(105)]) \n"}
{"sequence_id": "A048787", "text": "Write n in base 3 then rotate left one place.", "sequence": "1,2,1,4,7,2,5,8,1,4,7,10,13,16,19,22,25,2,5,8,11,14,17,20,23,26,1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,79,2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68", "code": "\ndef A048787(n):\n....x=A007089(n)\n....return int (x[1:]+x[0],3) \n"}
{"sequence_id": "A048864", "text": "Number of nonprime numbers (composites and 1) in the reduced residue system of n.", "sequence": "1,1,1,1,2,1,3,1,3,2,6,1,7,2,4,3,10,1,11,2,6,4,14,1,12,5,10,5,19,1,20,6,11,7,15,3,25,8,14,6,28,2,29,8,12,10,32,3,28,7,19,11,37,4,26,10,22,14,42,2,43,14,20,15,32,5,48,15,27,8,51,6,52,17,21,17,41,6,57,12,33,20", "code": "\nfrom sympy import totient, primepi, primefactors\ndef a(n): return totient(n) - (primepi(n) - len(primefactors(n))) \n"}
{"sequence_id": "A048889", "text": "Composite numbers not ending in zero that yield a prime when turned upside down.", "sequence": "68,116,118,161,166,169,188,608,616,1006,1018,1066,1081,1096,1106,1108,1118,1169,1186,1606,1618,1808,1816,1898,1916,1918,1969,1981,1988,1996,6001,6008,6016,6098,6188,6191,6196,6616,6668,6698,6808,6809,6881,6896", "code": "\nfrom itertools import product\nfrom sympy import isprime\nA048889_list = [m for m in (int(''.join(d)) for d in product('01689',repeat=6)) if m % 10 and not isprime(m) and isprime(int(str(m)[::-1].translate(''.maketrans('69','96'))))] \n"}
{"sequence_id": "A048890", "text": "Primes that yield a different prime when rotated by 180 degrees.", "sequence": "19,61,109,199,601,661,1019,1061,1091,1109,1181,1601,1609,1669,1699,1811,1901,1999,6011,6091,6101,6199,6619,6661,6689,6691,6899,6991,10061,10069,10091,10691,10861,10909,11069,11681,11909,16001,16619,16661", "code": "\nfrom itertools import product\nfrom sympy import isprime\nA048890_list = []\nfor d in product('01689',repeat=6):\n    s = ''.join(d)\n    p = int(s)\n    if p > 0:\n        q = int(s[::-1].rstrip('0').translate(''.maketrans('69','96')))\n        if p != q and isprime(q) and isprime(p):\n            A048890_list.append(p) \n"}
{"sequence_id": "A048926", "text": "Numbers that are the sum of 5 positive cubes in exactly 1 way.", "sequence": "5,12,19,26,31,33,38,40,45,52,57,59,64,68,71,75,78,82,83,89,90,94,96,97,101,108,109,115,116,120,127,129,131,134,135,136,138,143,145,146,150,152,153,155,162,164,169,171,172,176,181,183,188,190,192,194,195", "code": "\nfrom collections import Counter\nfrom itertools import combinations_with_replacement as combs_with_rep\ndef aupto(lim):\n  s = filter(lambda x: x<=lim, (i**3 for i in range(1, int(lim**(1/3))+2)))\n  s2 = filter(lambda x: x<=lim, (sum(c) for c in combs_with_rep(s, 5)))\n  s2counts = Counter(s2)\n  return sorted(k for k in s2counts if s2counts[k] == 1)\nprint(aupto(196)) \n"}
{"sequence_id": "A048929", "text": "Numbers that are the sum of 6 positive cubes in exactly 1 way.", "sequence": "6,13,20,27,32,34,39,41,46,48,53,58,60,65,67,69,72,76,79,83,84,86,90,91,95,97,98,102,104,105,109,110,116,117,121,123,124,128,130,132,135,136,137,139,142,143,144,146,147,151,153,154,156,160,161,162,163,170", "code": "\nfrom collections import Counter\nfrom itertools import combinations_with_replacement as multi_combs\ndef aupto(lim):\n  c = filter(lambda x: x<=lim, (i**3 for i in range(1, int(lim**(1/3))+2)))\n  s = filter(lambda x: x<=lim, (sum(mc) for mc in multi_combs(c, 6)))\n  counts = Counter(s)\n  return sorted(k for k in counts if counts[k]==1)\nprint(aupto(20000)) \n"}
{"sequence_id": "A048943", "text": "Product of divisors of n is a square.", "sequence": "1,6,8,10,14,15,16,21,22,24,26,27,30,33,34,35,38,39,40,42,46,51,54,55,56,57,58,60,62,65,66,69,70,72,74,77,78,81,82,84,85,86,87,88,90,91,93,94,95,96,102,104,105,106,108,110,111,114,115,118,119,120", "code": "\nfrom sympy import divisor_count\nfrom gmpy2 import iroot\nA048943_list = [i for i in range(1,10**3) if iroot(i,4)[1] or not divisor_count(i) % 4] \n"}
{"sequence_id": "A048991", "text": "Write down the numbers 1,2,3,... but omit any number (such as 12 or 23 or 31 ...) which appears in the concatenation of all earlier terms.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,32,33,35,36,37,38,39,40,43,44,46,47,48,49,50,54,55,57,58,59,60,65,66,68,69,70,76,77,79,80,87,88,90,99,100,102,103,104,105,106,107,108,109,110,112", "code": " \n"}
{"sequence_id": "A048992", "text": "Hannah Rollman's numbers: the numbers excluded from A048991.", "sequence": "12,23,31,34,41,42,45,51,52,53,56,61,62,63,64,67,71,72,73,74,75,78,81,82,83,84,85,86,89,91,92,93,94,95,96,97,98,101,111,113,121,122,123,131,141,151,161,171,181,191,192,201,202,210,211,212,213,214,215,216,217", "code": " \n"}
{"sequence_id": "A049035", "text": "Number of pairs of twin primes whose smaller element is <= 10^n-th prime.", "sequence": "5,25,174,1270,10250,86027,738597,6497407,58047180,524733511", "code": "\nfrom sympy import prime, sieve \ndef afind(terms):\n  c, prevp = 0, 1\n  for n in range(1, terms+1):\n    for p in sieve.primerange(prevp+1, prime(10**n)+3):\n      if prevp == p - 2: c += 1\n      prevp = p\n    print(c, end=\", \")\nafind(6) \n"}
{"sequence_id": "A049060", "text": "a(n) = (-1)^omega(n)*Sum_{d|n} d*(-1)^omega(d), where omega(n) = A001221(n) is number of distinct primes dividing n.", "sequence": "1,1,2,5,4,2,6,13,11,4,10,10,12,6,8,29,16,11,18,20,12,10,22,26,29,12,38,30,28,8,30,61,20,16,24,55,36,18,24,52,40,12,42,50,44,22,46,58,55,29,32,60,52,38,40,78,36,28,58,40,60,30,66,125,48,20,66,80,44,24,70", "code": "\nfrom math import prod\nfrom sympy import factorint\ndef A049060(n): return prod((p**(e+1)-2*p+1)//(p-1) for p,e in factorint(n).items()) \n"}
{"sequence_id": "A049074", "text": "Ulam's conjecture (steps to return n to 1 after division by 2 and, if needed, multiplication by 3 with 1 added).", "sequence": "8,3,49,7,36,55,288,15,339,46,259,67,119,302,694,31,214,357,519,66,148,281,633,91,658,145,101440,330,442,724,101104,63,841,248,540,393,535,557,2344,106,101331,190,1338,325,497,679,100979,139,806,708,1130,197", "code": "\ndef a(n):\n    if n==1: return 8\n    l=[n]\n    while True:\n        if n%2==0: n//=2\n        else: n = 3*n + 1\n        l.append(n)\n        if n<2: break\n    return sum(l)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A049201", "text": "If n is not composite, a(n) = n followed by 1; if n is composite, a(n) = concatenation of prime factors of n.", "sequence": "1,11,21,31,22,51,23,71,222,33,25,111,223,131,27,35,2222,171,233,191,225,37,211,231,2223,55,213,333,227,291,235,311,22222,311,217,57,2233,371,219,313,2225,411,237,431,2211,335,223,471,22223,77,255,317,2213", "code": "\nfrom sympy import factorint\ndef a(n):\n    if n == 0: return 1\n    f = factorint(n)\n    if n == 1 or sum(f.values()) == 1: return int(str(n)+'1')\n    return int(\"\".join(str(p)*e for p, e in f.items()))\nprint([a(n) for n in range(53)]) \n"}
{"sequence_id": "A049304", "text": "Numbers k such that k is a substring of 6^k.", "sequence": "6,7,9,13,21,22,23,29,39,40,42,44,45,48,53,55,56,60,63,64,65,67,68,69,70,73,74,75,76,77,79,82,83,87,89,92,93,94,98,105,107,127,129,131,134,137,143,147,152,163,165,167,174,179,184,189,197,224,226,227,234,240", "code": "\ndef ok(n): return str(n) in str(6**n)\nprint(list(filter(ok, range(241)))) \n"}
{"sequence_id": "A049305", "text": "Numbers k such that k is a substring of 7^k.", "sequence": "3,4,6,8,12,15,20,40,42,43,50,53,55,59,60,61,62,69,72,73,74,75,78,79,80,81,83,86,87,88,89,93,94,95,96,97,99,100,103,111,113,114,118,164,165,185,193,200,207,210,215,220,230,232,238,241,243,250,253,254,255", "code": "\ndef ok(n): return str(n) in str(7**n)\nprint(list(filter(ok, range(256)))) \n"}
{"sequence_id": "A049306", "text": "Numbers k such that k is a substring of 8^k.", "sequence": "4,6,7,10,13,17,18,28,31,33,36,38,42,44,47,48,49,52,54,56,58,60,63,64,67,68,69,76,77,79,81,82,83,85,86,89,90,91,94,97,112,115,124,130,135,165,173,176,178,189,193,195,206,208,215,221,225,249,251,252,253,256", "code": "\ndef ok(n): return str(n) in str(8**n)\nprint(list(filter(ok, range(257)))) \n"}
{"sequence_id": "A049345", "text": "n written in primorial base.", "sequence": "0,1,10,11,20,21,100,101,110,111,120,121,200,201,210,211,220,221,300,301,310,311,320,321,400,401,410,411,420,421,1000,1001,1010,1011,1020,1021,1100,1101,1110,1111,1120,1121,1200,1201,1210,1211,1220,1221,1300,1301,1310,1311", "code": "\nfrom sympy import nextprime\ndef a(n, p=2):\n    if n>2099: print(\"Error! Ambiguous primorial representation when n is larger than 2099\")\n    else: return n if n<p else a(n//p, nextprime(p))*10 + n%p\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A049413", "text": "Largest prime dividing Sum_{k=0..n} k! * (n-k)!.", "sequence": "2,5,2,2,13,151,3,83,73,1433,647,29,28211,337,19,73,18181,130349,771079,731957,6619,4111,61927,140001721,42829,774885169,745984697,41711914513,34311919,117695654963,1139908799,2390249,54413,4707207067,129164452987,12496027", "code": "\nfrom sympy import factorial as f, primefactors\ndef a(n): return max(primefactors(sum(f(k)*f(n-k) for k in range(n+1))))\nprint([a(n) for n in range(1, 37)]) \n"}
{"sequence_id": "A049445", "text": "Numbers n with property that the number of 1's in binary expansion of n (see A000120) divides n.", "sequence": "1,2,4,6,8,10,12,16,18,20,21,24,32,34,36,40,42,48,55,60,64,66,68,69,72,80,81,84,92,96,108,110,115,116,120,126,128,130,132,136,138,144,155,156,160,162,168,172,180,184,185,192,204,205,212,216,220,222,228", "code": "\nA049445 = [n for n in range(1,10**5) if not n % sum([int(d) for d in bin(n)[2:]])] \n"}
{"sequence_id": "A049479", "text": "Smallest prime dividing 2^n - 1.", "sequence": "3,7,3,31,3,127,3,7,3,23,3,8191,3,7,3,131071,3,524287,3,7,3,47,3,31,3,7,3,233,3,2147483647,3,7,3,31,3,223,3,7,3,13367,3,431,3,7,3,2351,3,127,3,7,3,6361,3,23,3,7,3,179951,3,2305843009213693951,3,7,3,31", "code": "\nfrom sympy import factorint\ndef A049479(n):\n    return min(factorint(2**n-1)) \n"}
{"sequence_id": "A049502", "text": "Major index of n, 2nd definition.", "sequence": "0,0,0,0,0,1,0,0,0,1,2,2,0,1,0,0,0,1,2,2,3,4,3,3,0,1,2,2,0,1,0,0,0,1,2,2,3,4,3,3,4,5,6,6,4,5,4,4,0,1,2,2,3,4,3,3,0,1,2,2,0,1,0,0,0,1,2,2,3,4,3,3,4,5,6,6,4,5,4,4,5,6,7,7,8,9,8,8,5,6,7,7,5,6,5,5,0,1,2,2,3,4,3,3,4", "code": "\ndef m(n):\n    x=bin(int(n))[2:][::-1]\n    s=0\n    for i in range(1,len(x)):\n        if x[i-1]==\"1\" and x[i]==\"0\":\n            s+=i\n    return s\nfor i in range(101):\n    print(str(i)+\" \"+str(m(i))) \n"}
{"sequence_id": "A049559", "text": "a(n) = gcd(n - 1, phi(n)).", "sequence": "1,1,2,1,4,1,6,1,2,1,10,1,12,1,2,1,16,1,18,1,4,1,22,1,4,1,2,3,28,1,30,1,4,1,2,1,36,1,2,1,40,1,42,1,4,1,46,1,6,1,2,3,52,1,2,1,4,1,58,1,60,1,2,1,16,5,66,1,4,3,70,1,72,1,2,3,4,1,78,1,2,1,82,1,4,1,2,1,88,1,18,1,4", "code": "\nfrom sympy import totient, gcd\nprint([gcd(totient(n), n - 1) for n in range(1, 101)]) \n"}
{"sequence_id": "A050231", "text": "a(n) is the number of n-tosses having a run of 3 or more heads for a fair coin (i.e., probability is a(n)/2^n).", "sequence": "0,0,1,3,8,20,47,107,238,520,1121,2391,5056,10616,22159,46023,95182,196132,402873,825259,1686408,3438828,6999071,14221459,28853662,58462800,118315137,239186031,483072832,974791728,1965486047", "code": "\ndef a(n, adict={0:0, 1:0, 2:1, 3:3}):\n    if n in adict:\n        return adict[n]\n    adict[n]=3*a(n-1)-a(n-2)-a(n-3)-2*a(n-4)\n    return adict[n] \n"}
{"sequence_id": "A050232", "text": "a(n) is the number of n-tosses having a run of 4 or more heads for a fair coin (i.e., probability is a(n)/2^n).", "sequence": "0,0,0,1,3,8,20,48,111,251,558,1224,2656,5713,12199,25888,54648,114832,240335,501239,1042126,2160676,4468664,9221281,18989899,39034824,80103276,164126496,335808927,686182387,1400438814", "code": "\ndef a(n, adict={0:0, 1:0, 2:0, 3:1, 4:3}):\n    if n in adict:\n        return adict[n]\n    adict[n]=3*a(n-1) - a(n-2) - a(n-3) - a(n-4) - 2*a(n-5)\n    return adict[n] \n"}
{"sequence_id": "A050251", "text": "Number of palindromic primes less than 10^n.", "sequence": "4,5,20,20,113,113,781,781,5953,5953,47995,47995,401696,401696,3438339,3438339,30483565,30483565,269577430,269577430,2427668363,2427668363,22170468927,22170468927", "code": "\nfrom __future__ import division\nfrom sympy import isprime\ndef paloddgen(l,b=10): \n....if l > 0:\n........yield 0\n........for x in range(1,l+1):\n............n = b**(x-1)\n............n2 = n*b\n............for y in range(n,n2):\n................k, m = y//b, 0\n................while k >= b:\n....................k, r = divmod(k,b)\n....................m = b*m + r\n................yield y*n + b*m + k\ndef A050251(n):\n....if n == 0:\n........return 4\n....else:\n........c = 1\n........for i in paloddgen(n//2+1):\n............if isprime(i):\n................c += 1\n........return c \n"}
{"sequence_id": "A050260", "text": "Quiteprimes: numbers k such that |2*(k mod p) - p| <= p + 1 - sqrt(p) for all primes p <= sqrt(k).", "sequence": "2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,137,139,149,151,157,163,167,173,179,191,193,211,223,227,229,239,251,257,269,271,277,281,283,293,317,347,349", "code": "\nfrom math import isqrt\nfrom sympy import primerange\ndef ok(n):\n    if n < 2: return False\n    for p in primerange(2, isqrt(n)+1):\n        isqrtp = isqrt(p)\n        if abs(2*(n%p)-p) > p + 1 - isqrt(p) - (isqrtp**2 < p): return False\n    return True\nprint(list(filter(ok, range(2, 350)))) \n"}
{"sequence_id": "A050278", "text": "Pandigital numbers: numbers containing the digits 0-9. Version 1: each digit appears exactly once.", "sequence": "1023456789,1023456798,1023456879,1023456897,1023456978,1023456987,1023457689,1023457698,1023457869,1023457896,1023457968,1023457986,1023458679,1023458697,1023458769,1023458796,1023458967,1023458976,1023459678,1023459687,1023459768", "code": "\nfrom itertools import permutations\nA050278_list = [int(''.join(d)) for d in permutations('0123456789',10) if d[0] != '0'] \n"}
{"sequence_id": "A050370", "text": "Number of ways to factor n into composite factors.", "sequence": "1,0,0,1,0,1,0,1,1,1,0,1,0,1,1,2,0,1,0,1,1,1,0,2,1,1,1,1,0,1,0,2,1,1,1,3,0,1,1,2,0,1,0,1,1,1,0,3,1,1,1,1,0,2,1,2,1,1,0,3,0,1,1,4,1,1,0,1,1,1,0,4,0,1,1,1,1,1,0,3,2,1,0,3,1,1,1,2,0,3,1,1,1,1,1,5,0,1,1,3,0,1", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import mobius, divisors, isprime\n@cacheit\ndef g(n, k): return (0 if n>k else 1) + (0 if isprime(n) else sum((0 if d>k else g(n//d, d)) for d in divisors(n)[1:-1]))\ndef a(n): return sum(mobius(n//d)*g(d, d) for d in divisors(n))\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A050376", "text": "\"Fermi-Dirac primes\": numbers of the form p^(2^k) where p is prime and k >= 0.", "sequence": "2,3,4,5,7,9,11,13,16,17,19,23,25,29,31,37,41,43,47,49,53,59,61,67,71,73,79,81,83,89,97,101,103,107,109,113,121,127,131,137,139,149,151,157,163,167,169,173,179,181,191,193,197,199,211,223,227,229,233,239,241", "code": "\nfrom sympy import isprime, perfect_power\ndef ok(n):\n  if isprime(n): return True\n  answer = perfect_power(n)\n  if not answer: return False\n  b, e = answer\n  if not isprime(b): return False\n  while e%2 == 0: e //= 2\n  return e == 1\ndef aupto(limit):\n  alst, m = [], 1\n  for m in range(1, limit+1):\n    if ok(m): alst.append(m)\n  return alst\nprint(aupto(241)) \n"}
{"sequence_id": "A050407", "text": "a(n) = n*(n^2 - 6*n + 11)/6.", "sequence": "0,1,1,1,2,5,11,21,36,57,85,121,166,221,287,365,456,561,681,817,970,1141,1331,1541,1772,2025,2301,2601,2926,3277,3655,4061,4496,4961,5457,5985,6546,7141,7771,8437,9140,9881,10661,11481,12342,13245,14191", "code": " for n in range(0,50): print(n*(n**2 - 6*n + 11)/6, end=', ') \n"}
{"sequence_id": "A050420", "text": "Numbers for which in base 2 the least number of digits that can be removed to leave a palindrome (possibly beginning with 0) is 1.", "sequence": "2,4,6,8,10,11,13,14,16,18,19,22,23,25,29,30,32,34,35,36,37,41,42,43,46,47,49,53,54,55,59,61,62,64,66,67,69,76,77,81,82,83,89,90,91,94,95,97,101,102,103,109,111,115,123,125,126,128,130,131,133,136", "code": "\ndef ok(n):\n    b = bin(n)[2:]\n    if b == b[::-1]: return False\n    for skip in range(len(b)):\n        newb = b[:skip] + b[skip+1:]\n        if len(newb) > 0 and newb == newb[::-1]:\n            return True\n    return False\nprint(list(filter(ok, range(137)))) \n"}
{"sequence_id": "A050421", "text": "Numbers for which in base 2 the least number of digits that can be removed to leave a palindrome (possibly beginning with 0) is 2.", "sequence": "12,20,24,26,28,38,39,40,44,48,50,57,58,60,68,70,71,72,74,75,78,79,80,84,86,87,92,96,98,100,105,106,108,110,113,117,118,121,122,124,132,134,135,138,139,140,141,144,152,154,155,158,159,160,164,166,167,172", "code": "\nfrom itertools import combinations\ndef ok(n):\n    b = bin(n)[2:]\n    for digs_to_remove in range(4):\n        for skip in combinations(range(len(b)), digs_to_remove):\n            newb = \"\".join(b[i] for i in range(len(b)) if i not in skip)\n            if len(newb) > 0 and newb == newb[::-1]:\n                return (digs_to_remove == 2)\n    return False\nprint(list(filter(ok, range(173)))) \n"}
{"sequence_id": "A050422", "text": "Numbers for which in base 2 the least number of digits that can be removed to leave a palindrome (possibly beginning with 0) is 3.", "sequence": "52,56,88,104,112,114,116,120,142,143,150,151,168,176,184,196,200,208,212,216,220,224,226,228,233,234,236,241,242,244,248,268,270,271,278,279,282,283,286,287,302,303,304,332,334,335,336,344,352,356,360,376,388", "code": "\nfrom itertools import combinations\ndef ok(n):\n    b = bin(n)[2:]\n    for digs_to_remove in range(4):\n        for skip in combinations(range(len(b)), digs_to_remove):\n            newb = \"\".join(b[i] for i in range(len(b)) if i not in skip)\n            if len(newb) > 0 and newb == newb[::-1]:\n                return (digs_to_remove == 3)\n    return False\nprint(list(filter(ok, range(390)))) \n"}
{"sequence_id": "A050423", "text": "Numbers for which in base 2 the least number of digits that can be removed to leave a palindrome (possibly beginning with 0) is 4.", "sequence": "232,240,368,424,432,440,452,456,464,468,472,480,482,484,488,496,542,543,558,559,688,720,736,752,816,848,864,868,872,888,900,912,920,928,932,960,962,970,972,977,978,980,984,993,994,996,1000,1008,1052,1054,1055,1068,1070,1071,1078,1079", "code": "\nfrom itertools import combinations\ndef ok(n):\n    b = bin(n)[2:]\n    for digs_to_remove in range(5):\n        for skip in combinations(range(len(b)), digs_to_remove):\n            newb = \"\".join(b[i] for i in range(len(b)) if i not in skip)\n            if newb == newb[::-1]: return (digs_to_remove == 4)\n    return False\nprint(list(filter(ok, range(1080)))) \n"}
{"sequence_id": "A050424", "text": "Numbers for which in base 2 the least number of digits that can be removed to leave a palindrome (possibly beginning with 0) is 5.", "sequence": "880,936,944,964,968,976,992,1504,1744,1760,1776,1840,1872,1888,1924,1936,1944,1952,1956,1960,1968,1984,1986,1988,1992,2000,2016,2110,2111,2142,2143,2158,2159,2166,2167,2206,2207,2222,2223,2334,2335,2784,2896,2912", "code": "\nfrom itertools import combinations\ndef ok(n):\n    b = bin(n)[2:]\n    for digs_to_remove in range(6):\n        for skip in combinations(range(len(b)), digs_to_remove):\n            newb = \"\".join(b[i] for i in range(len(b)) if i not in skip)\n            if newb == newb[::-1]: return (digs_to_remove == 5)\n    return False\nprint(list(filter(ok, range(2913)))) \n"}
{"sequence_id": "A050425", "text": "Numbers for which in base 2 the least number of digits that can be removed to leave a base 2 palindromic number (beginning with 1) is 1.", "sequence": "2,6,10,11,13,14,18,19,23,25,29,30,34,35,37,41,42,43,47,49,53,54,55,59,61,62,66,67,69,77,81,83,89,90,91,95,97,101,102,103,109,111,115,123,125,126,130,131,133,137,145,146,147,149,157,161,163,169,170,171", "code": "\ndef ok(n):\n    b = bin(n)[2:]\n    if b == b[::-1]: return False\n    for skip in range(len(b)):\n        newb = b[:skip] + b[skip+1:]\n        if len(newb) > 0 and newb[0] == '1' and newb == newb[::-1]:\n            return True\n    return False\nprint(list(filter(ok, range(172)))) \n"}
{"sequence_id": "A050426", "text": "Numbers for which in base 2 the least number of digits that can be removed to leave a base 2 palindromic number (beginning with 1) is 2.", "sequence": "4,12,20,22,26,28,36,38,39,46,50,57,58,60,68,70,71,74,75,79,82,84,86,87,94,98,105,106,108,110,113,117,118,121,122,124,132,134,135,138,139,141,154,155,159,162,166,167,175,177,178,179,180,182,190,194,202", "code": "\nfrom itertools import combinations\ndef ok(n):\n    b = bin(n)[2:]\n    for digs_to_remove in range(4):\n        for skip in combinations(range(len(b)), digs_to_remove):\n            newb = \"\".join(b[i] for i in range(len(b)) if i not in skip)\n            if len(newb) > 0 and newb[0] == '1' and newb == newb[::-1]:\n                return (digs_to_remove == 2)\n    return False\nprint(list(filter(ok, range(203)))) \n"}
{"sequence_id": "A050427", "text": "Numbers for which in base 2 the least number of digits that can be removed to leave a base 2 palindromic number (beginning with 1) is 3.", "sequence": "8,24,40,44,52,56,72,76,78,92,100,114,116,120,136,140,142,143,148,150,151,158,164,168,172,174,188,196,210,212,216,220,226,233,234,236,241,242,244,248,264,268,270,271,276,278,279,282,283,287,303,308,310,318", "code": "\nfrom itertools import combinations\ndef ok(n):\n    b = bin(n)[2:]\n    for digs_to_remove in range(4):\n        for skip in combinations(range(len(b)), digs_to_remove):\n            newb = \"\".join(b[i] for i in range(len(b)) if i not in skip)\n            if len(newb) > 0 and newb[0] == '1' and newb == newb[::-1]:\n                return (digs_to_remove == 3)\n    return False\nprint(list(filter(ok, range(320)))) \n"}
{"sequence_id": "A050428", "text": "Numbers for which in base 2 the least number of digits that can be removed to leave a base 2 palindromic number (beginning with 1) is 4.", "sequence": "16,48,80,88,104,112,144,152,156,184,200,228,232,240,272,280,284,286,296,300,302,316,328,336,344,348,376,392,420,424,432,440,452,466,468,472,482,484,488,496,528,536,540,542,543,552,556,558,559,564,566,574,606", "code": "\nfrom itertools import combinations\ndef ok(n):\n    b = bin(n)[2:]\n    for digs_to_remove in range(5):\n        for skip in combinations(range(len(b)), digs_to_remove):\n            newb = \"\".join(b[i] for i in range(len(b)) if i not in skip)\n            if len(newb) > 0 and newb[0] == '1' and newb == newb[::-1]:\n                return (digs_to_remove == 4)\n    return False\nprint(list(filter(ok, range(607)))) \n"}
{"sequence_id": "A050429", "text": "Numbers for which in base 2 the least number of digits that can be removed to leave a base 2 palindromic number (beginning with 1) is 5.", "sequence": "32,96,160,176,208,224,288,304,312,368,400,456,464,480,544,560,568,572,592,600,604,632,656,672,688,696,752,784,840,848,864,880,904,932,936,944,964,968,976,992,1056,1072,1080,1084,1086,1104,1112,1116,1118,1128", "code": "\nfrom itertools import combinations\ndef ok(n):\n    b = bin(n)[2:]\n    for digs_to_remove in range(6):\n        for skip in combinations(range(len(b)), digs_to_remove):\n            newb = \"\".join(b[i] for i in range(len(b)) if i not in skip)\n            if len(newb) > 0 and newb[0] == '1' and newb == newb[::-1]:\n                return (digs_to_remove == 5)\n    return False\nprint(list(filter(ok, range(1129)))) \n"}
{"sequence_id": "A050435", "text": "a(n) = composite(composite(n)), where composite = A002808, composite numbers.", "sequence": "9,12,15,16,18,21,24,25,26,28,32,33,34,36,38,39,40,42,45,48,49,50,51,52,55,56,57,60,63,64,65,68,69,70,72,74,76,77,78,80,81,84,86,87,88,90,91,93,94,95,98,100,102,104,105,106,110,111,112,115,116,117,118,119", "code": "\nfrom sympy import composite\ndef a(n): return composite(composite(n))\nprint([a(n) for n in range(1, 65)]) \n"}
{"sequence_id": "A050486", "text": "a(n) = binomial(n+6,6)*(2n+7)/7.", "sequence": "1,9,44,156,450,1122,2508,5148,9867,17875,30888,51272,82212,127908,193800,286824,415701,591261,826804,1138500,1545830,2072070,2744820,3596580,4665375,5995431,7637904,9651664,12104136,15072200,18643152,22915728,28001193", "code": "\nA050486_list, m = [], [2]+[1]*7\nfor _ in range(10**2):\n    A050486_list.append(m[-1])\n    for i in range(7):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A050488", "text": "a(n) = 3*(2^n-1) - 2*n.", "sequence": "0,1,5,15,37,83,177,367,749,1515,3049,6119,12261,24547,49121,98271,196573,393179,786393,1572823,3145685,6291411,12582865,25165775,50331597,100663243,201326537,402653127,805306309,1610612675,3221225409", "code": " for n in range(0, 30): print(3*(2**n-1) - 2*n, end=', ') \n"}
{"sequence_id": "A050548", "text": "Iterated triangular numbers.", "sequence": "7,28,406,82621,3413156131,5824817388998022646,16964248807586870937449001943463431981,143892868802856286225154411591351342616163027795335641150249224655238508171", "code": "\nfrom itertools import accumulate\ndef f(an, _): return an*(an+1)//2\nprint(list(accumulate([7]*11, f))) \n"}
{"sequence_id": "A050782", "text": "Smallest multiplier m (>0) such that mn is palindromic (or zero if no such m exists).", "sequence": "0,1,1,1,1,1,1,1,1,1,0,1,21,38,18,35,17,16,14,9,0,12,1,7,29,21,19,37,9,8,0,14,66,1,8,15,7,3,13,15,0,16,6,23,1,13,9,3,44,7,0,19,13,4,518,1,11,3,4,13,0,442,7,4,33,9,1,11,4,6,0,845,88,4,3,7,287,1,11,6,0,12345679,8", "code": "\nfrom __future__ import division\ndef palgen(l,b=10): \n    if l > 0:\n        yield 0\n        for x in range(1,l+1):\n            n = b**(x-1)\n            n2 = n*b\n            for y in range(n,n2):\n                k, m = y//b, 0\n                while k >= b:\n                    k, r = divmod(k,b)\n                    m = b*m + r\n                yield y*n + b*m + k\n            for y in range(n,n2):\n                k, m = y, 0\n                while k >= b:\n                    k, r = divmod(k,b)\n                    m = b*m + r\n                yield y*n2 + b*m + k\ndef A050782(n, l=10):\n    if n % 10:\n        x = palgen(l)\n        next(x)  \n        for i in x:\n            q, r = divmod(i, n)\n            if not r:\n                return q\n        else:\n            return 'search limit reached.'\n    else:\n        return 0 \n"}
{"sequence_id": "A050804", "text": "Numbers n such that n^3 is the sum of two nonzero squares in exactly one way.", "sequence": "2,8,18,32,72,98,128,162,242,288,392,512,648,722,882,968,1058,1152,1458,1568,1922,2048,2178,2592,2888,3528,3698,3872,4232,4418,4608,4802,5832,6272,6498,6962,7688,7938,8192", "code": "\nfrom sympy import factorint\nA050804_list = [2*i for i in range(1,10**6) if not any(p % 4 == 1 or factorint(i)[p] % 2 for p in factorint(i))] \n"}
{"sequence_id": "A050812", "text": "Number of times n is palindromic in bases b, 2 <= b <= 10.", "sequence": "9,9,8,8,7,7,5,5,4,3,3,1,1,1,1,2,2,2,2,0,2,3,1,1,2,1,2,2,2,1,1,2,1,2,1,1,2,1,1,0,3,1,1,1,1,2,2,0,1,1,2,2,2,0,1,3,1,2,0,1,1,1,1,3,1,3,1,2,1,0,1,1,1,2,1,0,0,1,2,0,3,1,2,1,0,3", "code": "\nfrom sympy.ntheory.digits import digits\ndef ispal(n, b):\n    digs = digits(n, b)[1:]\n    return digs == digs[::-1]\ndef a(n): return sum(ispal(n, b) for b in range(2, 11))\nprint([a(n) for n in range(87)]) \n"}
{"sequence_id": "A050897", "text": "Numbers k such that 277*2^k-1 is prime.", "sequence": "5,21,101,105,333,461,933,1041,2157,3321,5177,5513,5781,9737,11505,16457,17357,490805", "code": "\nfrom sympy import isprime\ndef afind(limit, startat=0):\n  pow2 = 2**startat\n  for k in range(startat, limit+1):\n    if isprime(277*pow2-1): print(k, end=\", \")\n    pow2 *= 2\nafind(3333) \n"}
{"sequence_id": "A050918", "text": "Woodall primes: primes of form k*2^k-1.", "sequence": "7,23,383,32212254719,2833419889721787128217599,195845982777569926302400511,4776913109852041418248056622882488319,1307960347852357218937346147315859062783,225251798594466661409915431774713195745814267044878909733007331390393510002687", "code": "\nfrom sympy import isprime\ndef auptok(limit):\n    return list(filter(isprime, (k*2**k-1 for k in range(1, limit+1))))\nprint(auptok(1000)) \n"}
{"sequence_id": "A050932", "text": "Denominator of (n+1)*Bernoulli(n).", "sequence": "1,1,2,1,6,1,6,1,10,1,6,1,210,1,2,1,30,1,42,1,110,1,6,1,546,1,2,1,30,1,462,1,170,1,6,1,51870,1,2,1,330,1,42,1,46,1,6,1,6630,1,22,1,30,1,798,1,290,1,6,1,930930,1,2,1,102,1,966,1,10,1,66,1,1919190", "code": "\nfrom sympy import bernoulli, gcd\ndef A050932(n):\n    q = bernoulli(n).q\n    return q//gcd(q,n+1) \n"}
{"sequence_id": "A050985", "text": "Cubefree part of n.", "sequence": "1,2,3,4,5,6,7,1,9,10,11,12,13,14,15,2,17,18,19,20,21,22,23,3,25,26,1,28,29,30,31,4,33,34,35,36,37,38,39,5,41,42,43,44,45,46,47,6,49,50,51,52,53,2,55,7,57,58,59,60,61,62,63,1,65,66,67,68,69,70,71,9,73,74,75", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import factorint\ndef A050985(n):\n    return 1 if n <=1 else reduce(mul,[p**(e % 3) for p,e in factorint(n).items()])\n\n"}
{"sequence_id": "A050987", "text": "Number of n-digit left-truncatable primes.", "sequence": "4,11,39,99,192,326,429,521,545,517,448,354,276,212,117,72,42,24,13,6,5,4,3,1,0", "code": "\nfrom sympy import isprime\ndef alst():\n  primes, alst = [2, 3, 5, 7], [4]\n  while len(primes) > 0:\n    candidates = set(int(d+str(p)) for p in primes for d in \"123456789\")\n    primes = [c for c in candidates if isprime(c)]\n    alst.append(len(primes))\n  return alst\nprint(alst()) \n"}
{"sequence_id": "A051013", "text": "Number of nonaveraging subsets on {1,2,...,n}.", "sequence": "1,2,4,7,13,23,40,65,106,169,278,443,705,1117,1760,2692,4151,6314,9526,14127,20944,30848,45589,66495,96847,140840,204380,293822,425859,613446,880288,1258349,1794256,2545965,3623774,5123746,7207773,10159163,14273328,19925242,27893419", "code": "\n\ndef nonaveragingsets(n):\n    avoid=list()\n    for skip in range(1,(n+1)//2):\n        for start in range (1,n+1-2*skip):\n            avoid.append(set({start,start+skip,start+2*skip}))\n    s=list()\n    for i in range(3):\n        for smallset in comb(range(1,n+1),i):\n            s.append(smallset)\n    for i in range(3,n+1):\n        for temptuple in comb(range(1,n+1),i):\n            tempset=set(temptuple)\n            status=True\n            for avoidset in avoid:\n                if avoidset <= tempset:\n                    status=False\n                    break\n            if status:\n                s.append(tempset)\n    return s\n\ndef a(n):\n    return len(nonaveragingsets(n)) \n"}
{"sequence_id": "A051042", "text": "Number of ternary cubefree words of length n.", "sequence": "1,3,9,24,66,180,486,1314,3558,9606,25956,70134,189462,511866,1382880,3735888,10092762,27266340,73661610,199001490,537615066,1452399978,3923748270", "code": "\nfrom itertools import product\ndef cf(s):\n  for l in range(1, len(s)//3 + 1):\n    for i in range(len(s) - 3*l + 1):\n      if s[i:i+l]*2 == s[i+l:i+3*l]: return False\n  return True\ndef a(n):\n  if n == 0: return 1\n  return 3*sum(cf(\"0\"+\"\".join(w)) for w in product(\"012\", repeat=n-1))\nprint([a(n) for n in range(14)]) \n"}
{"sequence_id": "A051043", "text": "Number of quaternary cubefree words of length n.", "sequence": "1,4,16,60,228,864,3264,12336,46632,176208,665892,2516412,9509364,35935476,135798588,513176076,1939267560,7328398344", "code": "\nfrom itertools import product\ndef cf(s):\n  for l in range(1, len(s)//3+1):\n    for i in range(len(s) - 3*l+1):\n      if s[i:i+l]*2 == s[i+l:i+3*l]: return False\n  return True\ndef a(n):\n  if n == 0: return 1\n  return 4*sum(cf(\"0\"+\"\".join(w)) for w in product(\"0123\", repeat=n-1))\nprint([a(n) for n in range(1, 12)]) \n"}
{"sequence_id": "A051065", "text": "a(n) = A004128(n) mod 2.", "sequence": "0,1,0,0,1,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,0,1", "code": "\nTOP = 1000\na = [0]*TOP\nfor n in range(1, TOP):\n    print(a[n-1], end=',')\n    a[n] = (n + a[n//3]) % 2\n\n"}
{"sequence_id": "A051102", "text": "Floor of exp(n-th prime).", "sequence": "7,20,148,1096,59874,442413,24154952,178482300,9744803446,3931334297144,29048849665247,11719142372802611,639843493530054949,4727839468229346561,258131288619006739623,104137594330290877971834,42012104037905142549565934,310429793570191990870734214", "code": "\nfrom sympy import floor, E, prime\ndef a(n):  return floor(E**prime(n))\nprint([a(n) for n in range(1, 19)]) \n"}
{"sequence_id": "A051109", "text": "Hyperinflation sequence for banknotes.", "sequence": "1,2,5,10,20,50,100,200,500,1000,2000,5000,10000,20000,50000,100000,200000,500000,1000000,2000000,5000000,10000000,20000000,50000000,100000000,200000000,500000000,1000000000,2000000000,5000000000", "code": " print( [ ((n % 3) ** 2 + 1) * 10**int(n/3) for n in range(100)] )\n"}
{"sequence_id": "A051119", "text": "n/p^k, where p = largest prime dividing n and p^k = highest power of p dividing n.", "sequence": "1,1,1,1,1,2,1,1,1,2,1,4,1,2,3,1,1,2,1,4,3,2,1,8,1,2,1,4,1,6,1,1,3,2,5,4,1,2,3,8,1,6,1,4,9,2,1,16,1,2,3,4,1,2,5,8,3,2,1,12,1,2,9,1,5,6,1,4,3,10,1,8,1,2,3,4,7,6,1,16,1,2,1,12,5,2,3,8,1,18,7,4,3,2,5,32,1,2,9,4,1", "code": "\nfrom sympy import factorint, primefactors\ndef a053585(n):\n    if n==1: return 1\n    p = primefactors(n)[-1]\n    return p**factorint(n)[p]\ndef a(n): return n/a053585(n) \n"}
{"sequence_id": "A051202", "text": "Numbers n such that A005210(n) = 0.", "sequence": "3,7,11,28,31,140,239,600,6476,33172,64375,65287,79051,97864,105099,421335,710147,1464192,3946972,5423007,5822348,6150008,6297183,20801744,22375360,79009771,197449588,266929040,537524972,5929856931,6365146483,7274986071,7983314176,19034311884,198776542655,1773302419915", "code": "\nA051202_list, a2, a1 = [], 1, 1\nfor n in range(3,10**13):\n....a = abs(a1+2*a2-n)\n....if a == 0:\n........A051202_list.append(n)\n....a1, a2 = a, a1 \n"}
{"sequence_id": "A051256", "text": "Numbers formed from binomial coefficients (mod 2) interpreted as digits in factorial base.", "sequence": "1,3,7,33,121,843,5167,46233,362881,3991683,40279687,522910113,6227383801,93409304523,1313941673647,22324392524313,355687428096001,6758061133824003,122000787836928007,2561305169719296033", "code": "\nfrom math import factorial\ndef A051256(n):\n    return sum(0 if ~n & k else factorial(k+1) for k in range(n+1)) \n"}
{"sequence_id": "A051270", "text": "Numbers that are divisible by exactly 5 different primes.", "sequence": "2310,2730,3570,3990,4290,4620,4830,5460,5610,6006,6090,6270,6510,6630,6930,7140,7410,7590,7770,7854,7980,8190,8580,8610,8778,8970,9030,9240,9282,9570,9660,9690,9870,10010,10230,10374,10626,10710,10920,11130", "code": "\nfrom sympy import primefactors\nprint([n for n in range(2, 20001) if len(primefactors(n))==5]) \n"}
{"sequence_id": "A051286", "text": "Whitney number of level n of the lattice of the ideals of the fence of order 2n.", "sequence": "1,1,2,5,11,26,63,153,376,931,2317,5794,14545,36631,92512,234205,594169,1510192,3844787,9802895,25027296,63972861,163701327,419316330,1075049011,2758543201,7083830648,18204064403,46812088751,120452857976", "code": "\nfrom sympy import binomial\ndef a(n): return sum(binomial(n - k, k)**2 for k in range(n//2 + 1))\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A051382", "text": "Numbers k whose base 3 expansion matches (0|1)*(02)?(0|1)* (no more than one \"02\" allowed in midst of 0's and 1's).", "sequence": "0,1,2,3,4,6,7,9,10,11,12,13,18,19,21,22,27,28,29,30,31,33,34,36,37,38,39,40,54,55,57,58,63,64,66,67,81,82,83,84,85,87,88,90,91,92,93,94,99,100,102,103,108,109,110,111,112,114,115,117,118,119,120,121,162,163", "code": "\nimport re\nfrom sympy.ntheory.digits import digits\ndef b3(n): return \"\".join(map(str, digits(n, 3)[1:]))\ndef ok(n): return re.fullmatch('2(0|1)*|(0|1)*(02)?(0|1)*', b3(n)) != None\nprint(list(filter(ok, range(164)))) \n"}
{"sequence_id": "A051572", "text": "a(1) = 5, a(n) = sigma(a(n-1)).", "sequence": "5,6,12,28,56,120,360,1170,3276,10192,24738,61440,196584,491520,1572840,5433480,20180160,94859856,355532800,1040179456,2143289344,4966055344,10092086208,31800637440,137371852800,641012414823", "code": "\nfrom itertools import accumulate, repeat \nfrom sympy import divisor_sigma\nA051572_list = list(accumulate(repeat(5,100), lambda x, _: divisor_sigma(x)))\n\n"}
{"sequence_id": "A051626", "text": "Period of decimal representation of 1/n, or 0 if 1/n terminates.", "sequence": "0,0,1,0,0,1,6,0,1,0,2,1,6,6,1,0,16,1,18,0,6,2,22,1,0,6,3,6,28,1,15,0,2,16,6,1,3,18,6,0,5,6,21,2,1,22,46,1,42,0,16,6,13,3,2,6,18,28,58,1,60,15,6,0,6,2,33,16,22,6,35,1,8,3,1,18,6,6,13,0,9,5,41,6,16,21,28,2,44,1", "code": "\ndef A051626(n):\n    if isA003592(n):\n        return 0\n    else:\n        lpow=1\n        while True:\n            for mpow in range(lpow-1,-1,-1):\n                if (10**lpow-10**mpow) % n == 0:\n                    return lpow-mpow\n            lpow += 1 \n"}
{"sequence_id": "A051640", "text": "a(n) contains the digit b-1 in all bases b from 2 to n.", "sequence": "1,2,7,14,23,47,47,239,239,239,239,5927,13679,13679,13679,57119,159119,500399,500399,1627919,2585519,3694397,7305479,17067599,41126399,41126399,41126399,61483967,586370399,589188599,1278033119,1278033119,1278033119,1278033119,1278033119", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef A051640(n):\n    m = 0\n    while True:\n        for b in range(2,n+1):\n            if b-1 not in digits(m,b)[1:]:\n                break\n        else:\n            return m\n        m += 1 \n"}
{"sequence_id": "A051652", "text": "Smallest number at distance n from nearest prime.", "sequence": "2,1,0,26,23,118,53,120,409,532,293,1140,211,1340,1341,1342,1343,1344,2179,15702,3967,15704,15705,19632,16033,19634,19635,31424,31425,31426,24281,31428,31429,31430,31431,31432,31433,155958,155959,155960,38501", "code": " \nfrom sympy import prevprime, nextprime\ndef A051700(n):\n  return [2, 1, 1][n] if n < 3 else min(n-prevprime(n), nextprime(n)-n)\ndef a(n):\n  if n == 0: return 2\n  m = 0\n  while A051700(m) != n: m += 1\n  return m\nprint([a(n) for n in range(26)]) \n"}
{"sequence_id": "A051674", "text": "a(n) = prime(n)^prime(n).", "sequence": "4,27,3125,823543,285311670611,302875106592253,827240261886336764177,1978419655660313589123979,20880467999847912034355032910567,2567686153161211134561828214731016126483469", "code": " from gmpy2 import mpz\n[mpz(prime(n))**mpz(prime(n)) for n in range(1,100)] \n"}
{"sequence_id": "A051701", "text": "Closest prime to n-th prime p that is different from p (break ties by taking the smaller prime).", "sequence": "3,2,3,5,13,11,19,17,19,31,29,41,43,41,43,47,61,59,71,73,71,83,79,83,101,103,101,109,107,109,131,127,139,137,151,149,151,167,163,167,181,179,193,191,199,197,199,227,229,227,229,241,239,257,251,257,271,269", "code": "\nfrom sympy import nextprime\ndef aupton(terms):\n  prv, cur, nxt, alst = 0, 2, 3, []\n  while len(alst) < terms:\n    alst.append(prv if 2*cur - prv <= nxt else nxt)\n    prv, cur, nxt = cur, nxt, nextprime(nxt)\n  return alst\nprint(aupton(58)) \n"}
{"sequence_id": "A051801", "text": "Product of the nonzero digits of n.", "sequence": "1,1,2,3,4,5,6,7,8,9,1,1,2,3,4,5,6,7,8,9,2,2,4,6,8,10,12,14,16,18,3,3,6,9,12,15,18,21,24,27,4,4,8,12,16,20,24,28,32,36,5,5,10,15,20,25,30,35,40,45,6,6,12,18,24,30,36,42,48,54,7,7,14,21", "code": "\nfrom operator import mul\nfrom functools import reduce\ndef A051801(n):\n    return reduce(mul, (int(d) for d in str(n) if d != '0')) if n > 0 else 1 \n"}
{"sequence_id": "A051801", "text": "Product of the nonzero digits of n.", "sequence": "1,1,2,3,4,5,6,7,8,9,1,1,2,3,4,5,6,7,8,9,2,2,4,6,8,10,12,14,16,18,3,3,6,9,12,15,18,21,24,27,4,4,8,12,16,20,24,28,32,36,5,5,10,15,20,25,30,35,40,45,6,6,12,18,24,30,36,42,48,54,7,7,14,21", "code": "\nfrom math import prod\ndef a(n): return prod(int(d) for d in str(n) if d != '0')\nprint([a(n) for n in range(74)]) \n(Swift 5)\nA051801(n): String(n).compactMap{$0.wholeNumberValue == 0 ? 1 : $0.wholeNumberValue}.reduce(1, *) // _Egor Khmara_, Jan 15 2021\n"}
{"sequence_id": "A051802", "text": "Nonzero multiplicative digital root of n.", "sequence": "1,1,2,3,4,5,6,7,8,9,1,1,2,3,4,5,6,7,8,9,2,2,4,6,8,1,2,4,6,8,3,3,6,9,2,5,8,2,8,4,4,4,8,2,6,2,8,6,6,8,5,5,1,5,2,1,3,5,4,2,6,6,2,8,8,3,8,8,6,2,7,7,4,2,6,5,8,8,3,8,8,8,6,8,6,4,6", "code": "\nfrom operator import mul\nfrom functools import reduce\ndef A051802(n):\n    if n == 0:\n        return 1\n    while n > 9:\n        n = reduce(mul, (int(d) for d in str(n) if d != '0'))\n    return n\n\n"}
{"sequence_id": "A051903", "text": "Maximal exponent in prime factorization of n.", "sequence": "0,1,1,2,1,1,1,3,2,1,1,2,1,1,1,4,1,2,1,2,1,1,1,3,2,1,3,2,1,1,1,5,1,1,1,2,1,1,1,3,1,1,1,2,2,1,1,4,2,2,1,2,1,3,1,3,1,1,1,2,1,1,2,6,1,1,1,2,1,1,1,3,1,1,2,2,1,1,1,4,4,1,1,2,1,1,1,3,1,2,1,2,1,1,1,5,1,2,2,2,1,1,1,3,1", "code": "\nfrom sympy import factorint\ndef A051903(n):\n    return max(factorint(n).values()) if n > 1 else 0\n\n(Scheme, with memoization-macro definec)\n(definec (A051903 n) (if (= 1 n) 0 (max (A067029 n) (A051903 (A028234 n))))) ;; _Antti Karttunen_, Aug 08 2016\n"}
{"sequence_id": "A051904", "text": "Minimal exponent in prime factorization of n.", "sequence": "0,1,1,2,1,1,1,3,2,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,2,1,3,1,1,1,1,5,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1", "code": "\nfrom sympy import factorint\ndef a(n):\n    f = factorint(n)\n    l = [f[p] for p in f]\n    return 0 if n == 1 else min(l)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A051953", "text": "Cototient(n) := n - phi(n).", "sequence": "0,1,1,2,1,4,1,4,3,6,1,8,1,8,7,8,1,12,1,12,9,12,1,16,5,14,9,16,1,22,1,16,13,18,11,24,1,20,15,24,1,30,1,24,21,24,1,32,7,30,19,28,1,36,15,32,21,30,1,44,1,32,27,32,17,46,1,36,25,46,1,48,1,38,35,40,17,54,1,48,27", "code": "\nfrom sympy.ntheory import totient\nprint([i - totient(i) for i in range(1, 101)]) \n"}
{"sequence_id": "A052018", "text": "Numbers n with property that the sum of the digits of n is substring of n.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100,109,119,129,139,149,159,169,179,189,199,200,300,400,500,600,700,800,900,910,911,912,913,914,915,916,917,918,919,1000,1009,1018,1027,1036,1045,1054,1063", "code": "\nloop = (str(n) for n in range(399))\nprint([int(n) for n in loop if str(sum(int(k) for k in n)) in n]) \n"}
{"sequence_id": "A052045", "text": "Cubes lacking the digit zero in their decimal expansion.", "sequence": "1,8,27,64,125,216,343,512,729,1331,1728,2197,2744,3375,4913,5832,6859,9261,12167,13824,15625,17576,19683,21952,24389,29791,32768,35937,42875,46656,54872,59319,68921,85184,91125,97336,117649,132651,148877", "code": "\nA052045 = [n**3 for n in range(1,10**5) if not str(n**3).count('0')]\n\n"}
{"sequence_id": "A052072", "text": "Smallest cubes whose digits occur with the same frequency n.", "sequence": "0,1331,700227072,22676697737363992239,1728999927211172788179288,256263633328535368685258882625,19194114355415391344355399945943513", "code": "\ndef A052072(n):\n    a, b, c = 0, 0, 0\n    for i in range(10**9):\n        s = str(c)\n        for d in set(s):\n            if s.count(d) != n:\n                break\n        else:\n            return c\n        c += a + b + 1\n        b += 2*a + 3\n        a += 3\n    return 'search limit reached.'  \n"}
{"sequence_id": "A052091", "text": "Left parts needed for the construction of the palindromic prime pyramid starting with 2.", "sequence": "2,7,3,33,9,30,18,92,3,133,18,117,17,15,346,93,33,180,120,194,126,336,331,330,95,12,118,369,39,32,165,313,165,134,13,149,195,145,158,720,18,396,193,102,737,964,722,156,106,395,945,303,310,113,150,303,715,123", "code": "\nfrom sympy import isprime\nA052091_list, p = [2], 2\nfor _ in range(30):\n    m, ps = 1, str(p)\n    s = int('1'+ps+'1')\n    while not isprime(s):\n        m += 1\n        ms = str(m)\n        if ms[0] in '268':\n            ms = str(int(ms[0])+1) + '0'*(len(ms)-1)\n            m = int(ms)\n        if ms[0] in '45':\n            ms = '7' + '0'*(len(ms)-1)\n            m = int(ms)\n        s = int(ms+ps+ms[::-1])\n    p = s\n    A052091_list.append(m) \n"}
{"sequence_id": "A052092", "text": "Lengths of the palindromic primes from Honaker's sequence A053600.", "sequence": "1,3,5,9,11,15,19,23,25,31,35,41,45,49,55,59,63,69,75,81,87,93,99,105,109,113,119,125,129,133,139,145,151,157,161,167,173,179,185,191,195,201,207,213,219,225,231,237,243,249,255,261,267,273,279,285,291,297", "code": "\nfrom sympy import isprime\nA052092_list, l, p = [1], 1, 2\nfor _ in range(100):\n    m, ps = 1, str(p)\n    s = int('1'+ps+'1')\n    while not isprime(s):\n        m += 1\n        ms = str(m)\n        if ms[0] in '268':\n            ms = str(int(ms[0])+1) + '0'*(len(ms)-1)\n            m = int(ms)\n        if ms[0] in '45':\n            ms = '7' + '0'*(len(ms)-1)\n            m = int(ms)\n        s = int(ms+ps+ms[::-1])\n    p = s\n    l += 2*len(ms)\n    A052092_list.append(l) \n"}
{"sequence_id": "A052093", "text": "a(n)^4 is the smallest fourth power whose decimal expansion digits occur with same frequency n.", "sequence": "0,207,130398,5694207,426424828,18304641024,1002719491659", "code": "\ng = agen(POW=4) \nprint([next(g) for n in range(1, 5)]) \n"}
{"sequence_id": "A052094", "text": "Smallest fourth powers whose decimal expansion digits occur with same frequency n.", "sequence": "0,1836036801,289123718973983667216,1051315345334684056886604801,33065106952901022329359695121613056,112265125207703310302573655130362165067776,1010922420949465152104650155209626996061445542961", "code": "\ng = agen(POW=4) \nprint([next(g)**4 for n in range(1, 5)]) \n"}
{"sequence_id": "A052180", "text": "Last filtering prime for n-th prime p: find smallest prime factor of each of the composite numbers between p and next prime; take maximal value.", "sequence": "2,2,3,2,3,2,3,5,2,5,3,2,3,7,5,2,5,3,2,7,3,5,7,3,2,3,2,3,11,3,7,2,11,2,5,7,3,13,5,2,11,2,3,2,11,13,3,2,3,5,2,13,11,7,5,2,5,3,2,17,13,3,2,3,17,5,11,2,3,5,19,7,13,3,5,17,3,13,7,2,7,2,19,3,5,11,3,2,3,11,13,3,17", "code": "\nfrom sympy import prime, nextprime, primefactors\ndef a(n):\n  p = prime(n); q = nextprime(p)\n  return max(min(primefactors(m)) for m in range(p+1, q))\nprint([a(n) for n in range(2, 95)]) \n"}
{"sequence_id": "A052191", "text": "Smallest multiple of n with no isolated digits.", "sequence": "11,22,33,44,55,66,77,88,99,1100,11,444,1144,3388,555,2288,1122,666,2299,1100,777,22,2277,888,1100,1144,999,3388,2233,3300,4433,6688,33,1122,1155,1188,111,3344,5577,2200,2255,5544,3311,44,4455,5566,7755", "code": "\ndef A052191(n):\n    k = 0\n    while True:\n        k += n\n        x = split('(0+|1+|2+|3+|4+|5+|6+|7+|8+|9+)',str(k))\n        for d in x:\n            if len(d) == 1:\n                break\n        else:\n            return k \n"}
{"sequence_id": "A052213", "text": "Numbers k with prime signature(k) = prime signature(k+1).", "sequence": "2,14,21,33,34,38,44,57,75,85,86,93,94,98,116,118,122,133,135,141,142,145,147,158,171,177,201,202,205,213,214,217,218,230,244,253,285,296,298,301,302,326,332,334,375,381,387,393,394,429,434,445,446,453,481", "code": "\nfrom sympy import factorint\ndef aupto(limit):\n    alst, prevsig = [], [1]\n    for k in range(3, limit+2):\n        sig = sorted(factorint(k).values())\n        if sig == prevsig: alst.append(k - 1)\n        prevsig = sig\n    return alst\nprint(aupto(250)) \n"}
{"sequence_id": "A052219", "text": "Numbers whose sum of digits is 5.", "sequence": "5,14,23,32,41,50,104,113,122,131,140,203,212,221,230,302,311,320,401,410,500,1004,1013,1022,1031,1040,1103,1112,1121,1130,1202,1211,1220,1301,1310,1400,2003,2012,2021,2030,2102,2111,2120,2201,2210,2300,3002", "code": "\nfrom sympy.utilities.iterables import multiset_permutations\ndef auptodigs(maxdigits):\n  alst = [5]\n  for d in range(2, maxdigits+1):\n    fulldigset = list(\"0\"*(d-1) + \"1111122345\")\n    for firstdig in \"12345\":\n      target_sum, restdigset = 5-int(firstdig), fulldigset[:]\n      restdigset.remove(firstdig)\n      for p in multiset_permutations(restdigset, d-1):\n        if sum(map(int, p)) == target_sum:\n          alst.append(int(firstdig+\"\".join(p)))\n          if int(p[0]) == target_sum: break\n  return alst\nprint(auptodigs(4)) \n"}
{"sequence_id": "A052220", "text": "Numbers whose sum of digits is 6.", "sequence": "6,15,24,33,42,51,60,105,114,123,132,141,150,204,213,222,231,240,303,312,321,330,402,411,420,501,510,600,1005,1014,1023,1032,1041,1050,1104,1113,1122,1131,1140,1203,1212,1221,1230,1302,1311,1320,1401,1410", "code": "\nfrom sympy.utilities.iterables import multiset_permutations\ndef auptodigs(maxdigits):\n    alst = []\n    for d in range(1, maxdigits+1):\n        digset = \"0\"*(d-1) + \"11111122233456\"\n        for p in multiset_permutations(digset, d):\n            if p[0] != '0' and sum(map(int, p)) == 6:\n                alst.append(int(\"\".join(p)))\n    return alst\nprint(auptodigs(4)) \n"}
{"sequence_id": "A052221", "text": "Numbers whose sum of digits is 7.", "sequence": "7,16,25,34,43,52,61,70,106,115,124,133,142,151,160,205,214,223,232,241,250,304,313,322,331,340,403,412,421,430,502,511,520,601,610,700,1006,1015,1024,1033,1042,1051,1060,1105,1114,1123,1132,1141,1150,1204", "code": "\ndef ok(n): return sum(map(int, str(n))) == 7\nprint(list(filter(ok, range(1205)))) \n"}
{"sequence_id": "A052221", "text": "Numbers whose sum of digits is 7.", "sequence": "7,16,25,34,43,52,61,70,106,115,124,133,142,151,160,205,214,223,232,241,250,304,313,322,331,340,403,412,421,430,502,511,520,601,610,700,1006,1015,1024,1033,1042,1051,1060,1105,1114,1123,1132,1141,1150,1204", "code": " \nfrom sympy.utilities.iterables import multiset_permutations\ndef auptodigs(maxdigits):\n    alst = []\n    for d in range(1, maxdigits+1):\n        digset = \"0\"*(d-1) + \"1111111222334567\"\n        for p in multiset_permutations(digset, d):\n            if p[0] != '0' and sum(map(int, p)) == 7:\n                alst.append(int(\"\".join(p)))\n    return alst\nprint(auptodigs(4)) \n"}
{"sequence_id": "A052222", "text": "Numbers whose sum of digits is 8.", "sequence": "8,17,26,35,44,53,62,71,80,107,116,125,134,143,152,161,170,206,215,224,233,242,251,260,305,314,323,332,341,350,404,413,422,431,440,503,512,521,530,602,611,620,701,710,800,1007,1016,1025,1034,1043,1052,1061", "code": "\nfrom sympy.utilities.iterables import multiset_permutations\ndef auptodigs(maxdigits):\n    alst = []\n    for d in range(1, maxdigits+1):\n        digset = \"0\"*(d-1) + \"11111111222233445678\"\n        for p in multiset_permutations(digset, d):\n            if p[0] != '0' and sum(map(int, p)) == 8:\n                alst.append(int(\"\".join(p)))\n    return alst\nprint(auptodigs(4)) \n"}
{"sequence_id": "A052224", "text": "Numbers whose sum of digits is 10.", "sequence": "19,28,37,46,55,64,73,82,91,109,118,127,136,145,154,163,172,181,190,208,217,226,235,244,253,262,271,280,307,316,325,334,343,352,361,370,406,415,424,433,442,451,460,505,514,523,532,541,550,604,613,622,631,640", "code": "\nfrom sympy.utilities.iterables import multiset_permutations\ndef auptodigs(maxdigits, b=10, sod=10): \n    alst = [sod] if 0 <= sod < b else []\n    nzdigs = [i for i in range(1, b) if i <= sod]\n    nzmultiset = []\n    for d in range(1, b):\n        nzmultiset += [d]*(sod//d)\n    for d in range(2, maxdigits + 1):\n        fullmultiset = [0]*(d-1-(sod-1)//(b-1)) + nzmultiset\n        for firstdig in nzdigs:\n            target_sum, restmultiset = sod - int(firstdig), fullmultiset[:]\n            restmultiset.remove(firstdig)\n            for p in multiset_permutations(restmultiset, d-1):\n              if sum(p) == target_sum:\n                  alst.append(int(\"\".join(map(str, [firstdig]+p)), b))\n                  if p[0] == target_sum:\n                      break\n    return alst\nprint(auptodigs(4)) \n"}
{"sequence_id": "A052307", "text": "Triangle read by rows: T(n,k) = number of bracelets (reversible necklaces) with n beads, k of which are black and n - k are white.", "sequence": "1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,2,2,1,1,1,1,3,3,3,1,1,1,1,3,4,4,3,1,1,1,1,4,5,8,5,4,1,1,1,1,4,7,10,10,7,4,1,1,1,1,5,8,16,16,16,8,5,1,1,1,1,5,10,20,26,26,20,10,5,1,1,1,1,6,12,29,38,50,38,29,12,6,1,1,1,1,6,14,35,57,76,76,57,35,14,6,1,1", "code": "\nfrom sympy import binomial as C, totient, divisors, gcd\ndef T(n, k): return 1 if n==0 else C((n//2) - k%2 * (1 - n%2), (k//2))/2 + sum(totient(d)*C(n//d, k//d) for d in divisors(gcd(n, k)))/(2*n)\nfor n in range(11): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A052382", "text": "Numbers without 0 as a digit, a.k.a. zeroless numbers.", "sequence": "1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68,69,71,72,73,74,75,76,77,78,79,81,82,83,84,85,86,87,88,89,91,92,93,94,95,96,97,98,99,111,112,113", "code": "\nA052382 = [n for n in range(1,10**5) if not str(n).count('0')]\n\n"}
{"sequence_id": "A052406", "text": "Numbers without 4 as a digit.", "sequence": "0,1,2,3,5,6,7,8,9,10,11,12,13,15,16,17,18,19,20,21,22,23,25,26,27,28,29,30,31,32,33,35,36,37,38,39,50,51,52,53,55,56,57,58,59,60,61,62,63,65,66,67,68,69,70,71,72,73,75,76,77,78,79,80,81,82,83,85,86,87,88,89", "code": " def A052406(n): n-=1; return sum((d+(d>3))*10**i for d,i in ((n//9**i%9,i) for i in range(math.ceil(math.log(n+1,9))))) \n"}
{"sequence_id": "A052410", "text": "Write n = m^k with m, k integers, k >= 1, then a(n) is the smallest possible choice for m.", "sequence": "1,2,3,2,5,6,7,2,3,10,11,12,13,14,15,2,17,18,19,20,21,22,23,24,5,26,3,28,29,30,31,2,33,34,35,6,37,38,39,40,41,42,43,44,45,46,47,48,7,50,51,52,53,54,55,56,57,58,59,60,61,62,63,2,65,66,67,68,69,70,71,72,73,74", "code": "\ndef upto(n):\n    list = [1] + [0] * (n - 1)\n    for i in range(2, n + 1):\n        if not list[i - 1]:\n            j = i\n            while j <= n:\n                list[j - 1] = i\n                j *= i\n    return list\n\n"}
{"sequence_id": "A052413", "text": "Numbers without 5 as a digit.", "sequence": "0,1,2,3,4,6,7,8,9,10,11,12,13,14,16,17,18,19,20,21,22,23,24,26,27,28,29,30,31,32,33,34,36,37,38,39,40,41,42,43,44,46,47,48,49,60,61,62,63,64,66,67,68,69,70,71,72,73,74,76,77,78,79,80,81,82,83,84,86,87,88,89", "code": " \ndef A052413(n): n-=1; return sum(n//9**e%9*6//5*10**e for e in range(math.ceil(math.log(n+1,9)))) \n"}
{"sequence_id": "A052545", "text": "Expansion of (1-x)^2/(1-3*x+x^3).", "sequence": "1,1,4,11,32,92,265,763,2197,6326,18215,52448,151018,434839,1252069,3605189,10380728,29890115,86065156,247814740,713554105,2054597159,5915976737,17034376106,49048531159,141229616740,406654474114", "code": "\nTOP = 33\na = [1]*TOP\na[2]=4\nfor n in range(3,TOP):\n    print(a[n-3], end=',')\n    a[n] = 3*a[n-1] - a[n-3]\n\n"}
{"sequence_id": "A052750", "text": "a(n) = (2*n + 1)^(n - 1).", "sequence": "1,1,5,49,729,14641,371293,11390625,410338673,16983563041,794280046581,41426511213649,2384185791015625,150094635296999121,10260628712958602189,756943935220796320321,59938945498865420543457", "code": " for n in range(0, 20): print((2*n + 1)**(n - 1), end=', ') \n"}
{"sequence_id": "A052992", "text": "Expansion of 1/((1 - x)*(1 - 2*x)*(1 + 2*x)).", "sequence": "1,1,5,5,21,21,85,85,341,341,1365,1365,5461,5461,21845,21845,87381,87381,349525,349525,1398101,1398101,5592405,5592405,22369621,22369621,89478485,89478485,357913941,357913941,1431655765,1431655765,5726623061,5726623061", "code": " for n in range(0,40): print(int(4**(1+int((n+2)/2)-1)/3), end=', ') \n"}
{"sequence_id": "A053004", "text": "Decimal expansion of AGM(1,sqrt(2)).", "sequence": "1,1,9,8,1,4,0,2,3,4,7,3,5,5,9,2,2,0,7,4,3,9,9,2,2,4,9,2,2,8,0,3,2,3,8,7,8,2,2,7,2,1,2,6,6,3,2,1,5,6,5,1,5,5,8,2,6,3,6,7,4,9,5,2,9,4,6,4,0,5,2,1,4,1,4,3,9,1,5,6,7,0,8,3,5,8,8,5,5,5,6,4,8,9,7,9,3,3,8,9,3,7,5,9,0", "code": "\nfrom mpmath import mp, agm, sqrt\nmp.dps=106\nprint([int(z) for z in list(str(agm(1, sqrt(2))).replace('.', '')[:-1])]) \n"}
{"sequence_id": "A053062", "text": "Concatenate n, 2n, 3n, ... nn.", "sequence": "1,24,369,481216,510152025,61218243036,7142128354249,816243240485664,91827364554637281,102030405060708090100,112233445566778899110121,1224364860728496108120132144,13263952657891104117130143156169,14284256708498112126140154168182196", "code": "\ndef a(n): return int(\"\".join(str(n*i) for i in range(1, n+1)))\nprint([a(n) for n in range(1, 15)]) \n"}
{"sequence_id": "A053067", "text": "a(n) is the concatenation of next n numbers (omit leading 0's).", "sequence": "1,23,456,78910,1112131415,161718192021,22232425262728,2930313233343536,373839404142434445,46474849505152535455,5657585960616263646566,676869707172737475767778,79808182838485868788899091,9293949596979899100101102103104105,106107108109110111112113114115116117118119120", "code": "\ndef a(n): return int(\"\".join(map(str, range((n-1)*n//2+1, n*(n+1)//2+1))))\nprint([a(n) for n in range(1, 16)]) \n"}
{"sequence_id": "A053095", "text": "Number of primes having exactly same digits as appear in first n primes.", "sequence": "1,1,1,8,62,568,5370,114546,2898058,0", "code": "\nfrom sympy import isprime, prime\nfrom sympy.utilities.iterables import multiset_permutations\ndef A053095(n):\n    return sum(1 for d in multiset_permutations(''.join(str(prime(m+1)) for m in range(n))) if isprime(int(''.join(d)))) \n"}
{"sequence_id": "A053165", "text": "4th-power-free part of n.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,2,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,3,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,4,65,66,67,68,69,70,71,72,73", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import factorint\ndef A053165(n):\n    return 1 if n <=1 else reduce(mul,[p**(e % 4) for p,e in factorint(n).items()])\n\n"}
{"sequence_id": "A053178", "text": "Numbers ending in 1 which are not prime.", "sequence": "1,21,51,81,91,111,121,141,161,171,201,221,231,261,291,301,321,341,351,361,371,381,391,411,441,451,471,481,501,511,531,551,561,581,591,611,621,651,671,681,711,721,731,741,771,781,791,801,831,841,851,861,871", "code": "\nfrom sympy import isprime\ndef aupto(lim): return [m for m in range(1, lim+1, 10) if not isprime(m)]\nprint(aupto(871)) \n"}
{"sequence_id": "A053347", "text": "a(n) = binomial(n+7, 7)*(n+4)/4.", "sequence": "1,10,54,210,660,1782,4290,9438,19305,37180,68068,119340,201552,329460,523260,810084,1225785,1817046,2643850,3782350,5328180,7400250,10145070,13741650,18407025,24402456,32040360,41692024,53796160", "code": "\nA053347_list, m = [], [2]+[1]*8\nfor _ in range(10**2):\n    A053347_list.append(m[-1])\n    print(m[-1])\n    for i in range(8):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A053392", "text": "a(n) is the concatenation of the sums of every pair of consecutive digits of n (with a(n) = 0 for 0 <= n <= 9).", "sequence": "0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7,8,9,10,11,12,13,14,6,7,8,9,10,11,12,13,14,15,7,8,9,10,11,12,13,14,15,16,8,9,10,11,12,13,14,15,16,17,9,10,11,12,13,14,15,16,17,18,10,11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,210", "code": "\ndef A053392(n):\n    if n < 10: return 0\n    d = list(map(int, str(n)))\n    return int(\"\".join(str(d[i] + d[i+1]) for i in range(len(d)-1)))\nprint([A053392(n) for n in range(120)]) \n"}
{"sequence_id": "A053393", "text": "Periodic points under the map A053392 that adds consecutive pairs of digits and concatenates them.", "sequence": "0,991,992,993,994,995,996,997,998,999,1810,1811,1812,1813,1814,1815,1816,1817,1818,6664,6665,6666,6667,6668,6669,33331,33332,33333,33334,33335,33336,121210,121211,121212,121213,121214,121215", "code": "\ndef f(n):\n  if 0 <= n <= 9: return 0\n  d = str(n)\n  return int(\"\".join(str(int(di)+int(dj)) for di, dj in zip(d[:-1], d[1:])))\ndef aupto(limit):\n  n, DIVERGENCELIMIT = 0, 10**100\n  while n <= limit:\n    m, orbit = n, []\n    while m <= DIVERGENCELIMIT and m not in orbit: orbit.append(m); m = f(m)\n    if m in orbit and m == orbit[0]: print(n, end=\", \")\n    n += 1\naupto(130000) \n"}
{"sequence_id": "A053547", "text": "Smallest prime starting with A000422(n).", "sequence": "11,211,3217,432121,543217,65432117,76543217,876543211,9876543211,1098765432101,11109876543211,12111098765432101,1312111098765432139,141312111098765432113,15141312111098765432173", "code": "\nfrom sympy import isprime\ndef A053547(n):\n    s = int(''.join(str(m) for m in range(n,0,-1)))\n    for i in range(1,10):\n        s *= 10\n        for j in range(1,10**i,2):\n            x = s+j\n            if isprime(x):\n                return x\n    else:\n        return 'search limit reached.' \n"}
{"sequence_id": "A053585", "text": "If n = p_1^e_1 * ... * p_k^e_k, p_1 < ... < p_k primes, then a(n) = p_k^e_k.", "sequence": "1,2,3,4,5,3,7,8,9,5,11,3,13,7,5,16,17,9,19,5,7,11,23,3,25,13,27,7,29,5,31,32,11,17,7,9,37,19,13,5,41,7,43,11,5,23,47,3,49,25,17,13,53,27,11,7,19,29,59,5,61,31,7,64,13,11,67,17,23,7,71,9,73,37,25,19,11,13,79", "code": "\nfrom sympy import factorint, primefactors\ndef a(n):\n    if n==1: return 1\n    p = primefactors(n)[-1]\n    return p**factorint(n)[p] \n"}
{"sequence_id": "A053600", "text": "a(1) = 2; for n>=1, a(n+1) is the smallest palindromic prime with a(n) as a central substring.", "sequence": "2,727,37273,333727333,93337273339,309333727333903,1830933372733390381,92183093337273339038129,3921830933372733390381293,1333921830933372733390381293331,18133392183093337273339038129333181", "code": "\nfrom gmpy2 import digits, mpz, is_prime\nA053600_list, p = [2], 2\nfor _ in range(30):\n....m, ps = 1, digits(p)\n....s = mpz('1'+ps+'1')\n....while not is_prime(s):\n........m += 1\n........ms = digits(m)\n........s = mpz(ms+ps+ms[::-1])\n....p = s\n....A053600_list.append(int(p)) \n"}
{"sequence_id": "A053644", "text": "Most significant bit of n, msb(n); largest power of 2 less than or equal to n; write n in binary and change all but the first digit to zero.", "sequence": "0,1,2,2,4,4,4,4,8,8,8,8,8,8,8,8,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,64,64,64,64,64,64,64,64,64,64,64", "code": "\ndef a(n): return 0 if n==0 else 2**(len(bin(n)[2:]) - 1) \n"}
{"sequence_id": "A053645", "text": "Distance to largest power of 2 less than or equal to n; write n in binary, change the first digit to zero, and convert back to decimal.", "sequence": "0,0,1,0,1,2,3,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20", "code": "\ndef a(n): return n - 2**(n.bit_length()-1)\nprint([a(n) for n in range(1, 85)]) \n"}
{"sequence_id": "A053669", "text": "Smallest prime not dividing n.", "sequence": "2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,7,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,7,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,7,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2", "code": "\nfrom sympy import nextprime\ndef a(n):\n    p = 2\n    while True:\n        if n%p: return p\n        else: p=nextprime(p) \n"}
{"sequence_id": "A053669", "text": "Smallest prime not dividing n.", "sequence": "2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,7,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,7,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,7,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2", "code": "\n\nimport math\ndef a(n):\n    k = 2\n    while math.gcd(n,k) > 1: k += 1\n    return k \n"}
{"sequence_id": "A053670", "text": "Least number coprime to n and n+1.", "sequence": "3,5,5,3,7,5,3,5,7,3,5,5,3,11,7,3,5,5,3,11,5,3,5,7,3,5,5,3,7,7,3,5,5,3,11,5,3,5,7,3,5,5,3,7,7,3,5,5,3,7,5,3,5,7,3,5,5,3,7,7,3,5,5,3,7,5,3,5,11,3,5,5,3,7,7,3,5,5,3,7,5,3,5,11,3,5,5,3,7,11,3,5,5,3,7,5,3,5,7,3,5", "code": "\nfrom math import gcd\ndef a(n):\n    k, m = 3, n*(n+1)\n    while gcd(k, m) != 1: k += 2\n    return k\nprint([a(n) for n in range(1, 102)]) \n"}
{"sequence_id": "A053726", "text": "\"Flag numbers\": number of dots that can be arranged in successive rows of K, K-1, K, K-1, K, ..., K-1, K (assuming there is a total of L > 1 rows of size K > 1).", "sequence": "5,8,11,13,14,17,18,20,23,25,26,28,29,32,33,35,38,39,41,43,44,46,47,48,50,53,56,58,59,60,61,62,63,65,67,68,71,72,73,74,77,78,80,81,83,85,86,88,89,92,93,94,95,98,101,102,103,104,105,107,108,109,110,111,113,116", "code": "\nfrom sympy import isprime\ndef ok(n): return n > 1 and not isprime(2*n-1)\nprint(list(filter(ok, range(1, 117)))) \n"}
{"sequence_id": "A053755", "text": "a(n) = 4*n^2 + 1.", "sequence": "1,5,17,37,65,101,145,197,257,325,401,485,577,677,785,901,1025,1157,1297,1445,1601,1765,1937,2117,2305,2501,2705,2917,3137,3365,3601,3845,4097,4357,4625,4901,5185,5477,5777,6085,6401,6725,7057", "code": " for n in range(0,50): print(4*n**2+1, end=', ') \n"}
{"sequence_id": "A053782", "text": "Numbers k such that the sum of the first k composite numbers is prime.", "sequence": "5,14,17,20,35,36,37,43,47,48,53,54,63,64,68,73,74,75,86,101,106,127,142,149,154,159,208,209,214,221,231,234,250,254,258,259,272,283,302,304,329,332,346,352,374,398,417,424,439,440,445,458,471,550,551,556", "code": "\nfrom sympy import isprime\nA053782_list, n, m, s = [], 1, 4, 4\nwhile len(A053782_list) < 10000:\n    if isprime(s):\n        A053782_list.append(n)\n    m += 1\n    if isprime(m):\n        m += 1\n    n += 1\n    s += m \n"}
{"sequence_id": "A053790", "text": "Composite numbers arising as sum of first k primes.", "sequence": "10,28,58,77,100,129,160,238,328,381,440,501,568,639,712,791,874,963,1060,1161,1264,1371,1480,1593,1720,1851,1988,2127,2276,2427,2584,2747,2914,3087,3266,3447,3638,3831,4028,4227,4438,4661,4888,5117,5350,5589,5830", "code": "\nfrom sympy import isprime, nextprime\ndef aupto(limit):\n    alst, s, p = [], 2, 2\n    while s < limit:\n        if not isprime(s): alst.append(s)\n        p = nextprime(p)\n        s += p\n    return alst\nprint(aupto(6000)) \n"}
{"sequence_id": "A053795", "text": "Composite numbers ending in 1, 3, 7 or 9.", "sequence": "9,21,27,33,39,49,51,57,63,69,77,81,87,91,93,99,111,117,119,121,123,129,133,141,143,147,153,159,161,169,171,177,183,187,189,201,203,207,209,213,217,219,221,231,237,243,247,249,253,259,261,267,273,279,287", "code": "\nfrom sympy import isprime\ndef ok(n): return n > 1 and n%10 in {1, 3, 7, 9} and not isprime(n)\nprint(list(filter(ok, range(2, 288)))) \n"}
{"sequence_id": "A053846", "text": "Number of n X n matrices over GF(3) of order dividing 2 (i.e., number of solutions of X^2=I in GL(n,3)).", "sequence": "1,2,14,236,12692,1783784,811523288,995733306992,3988947598331024,43581058503809001248,1559669026899267564563936,152805492791495918971070907584,49094725258525117931062810300451648,43237014297639482582550110281347475757696,124920254287369111633119733942816364074145497472", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef T(n, k): return 0 if k<0 or k>n else 1 if n==0 else T(n - 1, k - 1) + 3**k*T(n - 1, k)\ndef a(n): return sum(3**(k*(n - k))*T(n, k) for k in range(n + 1))\nprint([a(n) for n in range(15)]) \n"}
{"sequence_id": "A053872", "text": "Primes arising in A053782.", "sequence": "37,199,277,367,997,1049,1103,1451,1709,1777,2137,2213,2953,3041,3407,3889,3989,4091,5309,7193,7883,11113,13757,15083,16073,17093,28643,28909,30259,32203,35089,35977,40879,42157,43451,43777,48119,51949", "code": "\nfrom python import isprime\nA053872_list, n, m, s = [], 1, 4, 4\nwhile len(A053872_list) < 10000:\n    if isprime(s):\n        A053872_list.append(s)\n    m += 1\n    if isprime(m):\n        m += 1\n    n += 1\n    s += m \n"}
{"sequence_id": "A053918", "text": "Numbers k such that k^2 contains only digits {2,3,5}.", "sequence": "5,15,235,485,1885,5765,15885,50235,57665,72335,1798765,15249765,187703365,179876492415,159789024443333515", "code": " \ndef aupto(limit):\n  alst = []\n  for k in range(1, limit+1):\n    if set(str(k*k)) <= set(\"235\"): alst.append(k)\n  return alst\nprint(aupto(2*10**6)) \n"}
{"sequence_id": "A053919", "text": "Squares composed of digits {2,3,5}.", "sequence": "25,225,55225,235225,3553225,33235225,252333225,2523555225,3325252225,5232352225,3235555525225,232555332555225,35232553232323225,32355552523523552532225,25532532332552235533223325522255225", "code": " \nfrom math import isqrt\ndef aupto(limit):\n  alst, rootlimit = [], isqrt(limit)\n  for k in range(1, rootlimit+1):\n    if set(str(k*k)) <= set(\"235\"): alst.append(k*k)\n  return alst\nprint(aupto(4*10**12)) \n"}
{"sequence_id": "A053964", "text": "Numbers k such that k^2 contains only digits {4,7,9}.", "sequence": "2,3,7,88,212,893,69242288,8819171038", "code": "\nfrom itertools import product\nfrom sympy import integer_nthroot\nA053964_list = []\nfor l in range(1,21):\n    for p in product(*['479']*l):\n        a, b = integer_nthroot(int(''.join(p)),2)\n        if b:\n            A053964_list.append(a) \n"}
{"sequence_id": "A053965", "text": "Squares composed of digits {4,7,9}.", "sequence": "4,9,49,7744,44944,797449,4794494447474944,77777777797497997444", "code": "\nfrom itertools import product\nfrom sympy import integer_nthroot\nA053965_list = []\nfor l in range(1,21):\n    for p in product(*['479']*l):\n        n = int(''.join(p))\n        if integer_nthroot(n,2)[1]:\n            A053965_list.append(n) \n"}
{"sequence_id": "A054212", "text": "a(n)^5 is the smallest fifth power whose decimal expansion digits occur with same frequency n.", "sequence": "0,2955,49995,10365589,75418384,2592877410,100661113419,3989342709778", "code": "\ndef agen(POW=5):\n  n = 1\n  while True:\n    k = 0\n    while True:\n      kpowstr = str(pow(k, POW))\n      q, r = divmod(len(kpowstr), n)\n      if r == 0:\n        ok = True\n        for d in set(kpowstr):\n          if kpowstr.count(d) != n:\n            ok = False; break\n        if ok: break\n        k += 1\n      else: \n        k = max(k+1, int((10**((q+1)*n-1))**(1/POW)))\n    yield k\n    n += 1\ng = agen() \nprint([next(g) for n in range(1, 5)]) \n"}
{"sequence_id": "A054213", "text": "Smallest fifth powers whose decimal expansion digits occur with same frequency n.", "sequence": "0,225313610074846875,312343781246875156246875,119665765800843104737370354851986949,2439979134100773706931016420916722663424,117195225794292252449115584887987847895470100000,10334956410016814668660393585195309584134568401459883099,1010431164918909763339703798486498718473866680301776494470190368", "code": "\ng = agen() \nprint([next(g)**5 for n in range(1, 5)]) \n"}
{"sequence_id": "A054221", "text": "Consider all integer triples (i,j,k), j,k>0, with binomial(i+2,3)=binomial(j+2,3)+k^3, ordered by increasing i; sequence gives i values.", "sequence": "7,8,10,23,27,48,64,125,199,216,343,512,621,729,978,1000,1222,1331,1728,2197,2744,3375,3563,4034,4096,4331,4913,5017,5832,6442,6859,6886,7783,8000,8699,9261,10648,11157,12167,12287,12386,13824,15625,17576,19683", "code": "\n\nn=0; i=0; T_i=0\nwhile i<100000:\n..j=i; i+=1; k=1; kd2=1; kd3=0; T_j=T_i; delta=T_j+j; T_i+=i;\n..while j>0:\n....if delta>0:\n......kd3+=6; kd2+=kd3; delta-=kd2; k+=1;\n....else:\n......if delta==0:\n........print(\"A054221(%d)= %d, A054222(%d)= %d, A054223(%d)= %d\"%\n..............(n,i,n,j,n,k)); n+=1;\n......delta += T_j; T_j-=j; j-=1;\n\n"}
{"sequence_id": "A054247", "text": "Number of n X n binary matrices under action of dihedral group of the square D_4.", "sequence": "1,2,6,102,8548,4211744,8590557312,70368882591744,2305843028004192256,302231454921524358152192,158456325028538104598816096256,332306998946229005407670289177772032,2787593149816327892769293535238052808491008", "code": "\ndef a(n):\n    return 2**(n**2-3)+2**((n**2-8)/4)+2**((n**2-6)/2)+2**((n**2-4)/2)+2**((n**2+n-4)/2) if n % 2 == 0 else 2**(n**2-3)+2**((n**2-5)/4)+2**((n**2-5)/2)+2**((n**2+n-2)//2) \n"}
{"sequence_id": "A054248", "text": "Binary entropy: a(n) = n + min { a(k)+a(n-k) : 1 <= k <= n-1 }.", "sequence": "1,2,6,8,13,16,21,24,30,34,40,44,50,54,60,64,71,76,83,88,95,100,107,112,119,124,131,136,143,148,155,160,168,174,182,188,196,202,210,216,224,230,238,244,252,258,266,272,280,286,294,300,308,314", "code": "\ndef A054248(n):\n    s, i, z = n - (n-1) % 2, n-1, 1\n    while 0 <= i: s += i; i -= z; z += z\n    return s\nprint([A054248(n) for n in range(1, 55)]) \n"}
{"sequence_id": "A054268", "text": "Sum of composite numbers between prime p and nextprime(p) is a repdigit.", "sequence": "3,5,109,111111109,259259257", "code": "\nfrom sympy import prime\nA054268 = [prime(n) for n in range(2,10**5) if len(set(str(int((prime(n+1)-prime(n)-1)*(prime(n+1)+prime(n))/2)))) == 1]\n\n"}
{"sequence_id": "A054351", "text": "Successive generations of the Kolakoski sequence A000002.", "sequence": "1,12,1221,1221121,12211212212,122112122122112112,1221121221221121122121121221,1221121221221121122121121221121121221221121,12211212212211211221211212211211212212211212212112112212211212212", "code": "\nfrom itertools import accumulate, groupby, repeat\ndef K(n, _):\n  c, s = \"12\", \"\"\n  for i, k in enumerate(str(n)): s += c[i%2]*int(k)\n  return int(s + c[(i+1)%2])\ndef aupton(nn): return list(accumulate(repeat(1, nn+1), K))\nprint(aupton(8)) \n"}
{"sequence_id": "A054352", "text": "Lengths of successive generations of the Kolakoski sequence A000002.", "sequence": "1,2,4,7,11,18,28,43,65,99,150,226,340,511,768,1153,1728,2590,3885,5826,8742,13116,19674,29514,44280,66431,99667,149531,224306,336450,504648,756961,1135450,1703197,2554846,3832292,5748474,8622646,12933971,19400955,29101203", "code": "\ndef aupton(nn):\n  alst, A054353, idx = [1], 0, 1\n  K = Kolakoski()  \n  for n in range(2, nn+1):\n    target = alst[-1]\n    while idx <= target:\n      A054353 += next(K)\n      idx += 1\n    alst.append(A054353 + 1)  \n  return alst\nprint(aupton(36))  \n"}
{"sequence_id": "A054353", "text": "Partial sums of Kolakoski sequence A000002.", "sequence": "1,3,5,6,7,9,10,12,14,15,17,19,20,21,23,24,25,27,29,30,32,33,34,36,37,39,41,42,43,45,46,47,49,50,52,54,55,57,59,60,61,63,64,66,68,69,71,72,73,75,76,77,79,81,82,84,86,87,88,90,91,93,95,96,98,100", "code": "\nfrom itertools import accumulate\ndef alst(nn):\n  K = Kolakoski() \n  return list(accumulate(next(K) for i in range(1, nn+1)))\nprint(alst(66))   \n"}
{"sequence_id": "A054357", "text": "Number of unlabeled 2-ary cacti having n polygons. Also number of bi-colored plane trees with n edges.", "sequence": "1,1,2,3,6,10,28,63,190,546,1708,5346,17428,57148,191280,646363,2210670,7626166,26538292,93013854,328215300,1165060668,4158330416,14915635378,53746119972,194477856100,706437056648,2575316704200,9419571138368", "code": "\nfrom sympy import binomial, divisors, totient\ndef a(n): return 1 if n==0 else (binomial(2*n, n)//(n + 1) + sum(binomial(2*d, d)*totient(n//d)*(d<n) for d in divisors(n)))//n\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A054377", "text": "Primary pseudoperfect numbers: numbers n > 1 such that 1/n + sum 1/p = 1, where the sum is over the primes p | n.", "sequence": "2,6,42,1806,47058,2214502422,52495396602,8490421583559688410706771261086", "code": "\nfrom sympy import primefactors\nA054377 = [n for n in range(2,10**5) if sum([n/p for p in primefactors(n)]) +1 == n] \n"}
{"sequence_id": "A054383", "text": "Number of (zeroless) pandigital fractions for 1/n.", "sequence": "0,12,2,4,12,3,7,46,3,0,0,4,3,8,2,3,27,1,2,0,0,1,3,2,0,9,4,1,2,0,0,1,0,0,5,0,1,2,0,0,0,0,1,5,0,1,0,0,0,0,0,1,4,0,0,0,0,0,1,0,0,2,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom itertools import permutations\nl = {}\nfor d in permutations('123456789', 9):\n....for i in range(8):\n........s1, s2 = int(''.join(d[:i+1])), int(''.join(d[i+1:]))\n........q, r = divmod(s1,s2)\n........if not r:\n............if q in l:\n................l[q] += 1\n............else:\n................l[q] = 1\nA054383_list = [0]*max(l)\nfor d in l:\n....A054383_list[d-1] = l[d] \n"}
{"sequence_id": "A054385", "text": "Beatty sequence for e/(e-1); complement of A022843.", "sequence": "1,3,4,6,7,9,11,12,14,15,17,18,20,22,23,25,26,28,30,31,33,34,36,37,39,41,42,44,45,47,49,50,52,53,55,56,58,60,61,63,64,66,68,69,71,72,74,75,77,79,80,82,83,85,87,88,90,91,93,94,96,98,99,101,102,104,105,107,109", "code": "\nfrom sympy import E\nprint([n*E//(E-1) for n in range(1, 70)]) \n"}
{"sequence_id": "A054408", "text": "a(n) = smallest positive integer not already in sequence such that the partial sum a(1)+...+a(n) is prime.", "sequence": "2,1,4,6,10,8,12,16,14,24,30,22,18,26,34,36,20,28,38,40,32,42,46,48,44,52,56,60,54,58,66,50,64,62,70,84,90,72,92,76,86,94,74,88,68,82,80,102,96,100,114,98,78,112,120,110,108,106,126,122,130,132,134,124,128,118", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n    alst, aset, asum = [], set(), 0\n    while len(alst) < terms:\n        an = 1\n        while True:\n            while an in aset: an += 1\n            if isprime(asum + an):\n                alst, aset, asum = alst + [an], aset | {an}, asum + an\n                break\n            an += 1\n    return alst\nprint(aupton(66)) \n"}
{"sequence_id": "A054410", "text": "Susceptibility series H_3 for 2-dimensional Ising model (divided by 2).", "sequence": "1,12,52,148,328,620,1052,1652,2448,3468,4740,6292,8152,10348,12908,15860,19232,23052,27348,32148,37480,43372,49852,56948,64688,73100,82212,92052,102648,114028,126220,139252,153152,167948,183668,200340,217992,236652", "code": "\ndef A054410(n):\n    if n == 0: return 1\n    return 2*(n*(11 + 7*n**2))/3 \n"}
{"sequence_id": "A054430", "text": "Simple self-inverse permutation of natural numbers: List each clump of phi(n) numbers (starting from phi(2) = 1) in reverse order.", "sequence": "1,3,2,5,4,9,8,7,6,11,10,17,16,15,14,13,12,21,20,19,18,27,26,25,24,23,22,31,30,29,28,41,40,39,38,37,36,35,34,33,32,45,44,43,42,57,56,55,54,53,52,51,50,49,48,47,46,63,62,61,60,59,58,71,70,69,68,67,66,65,64,79", "code": "\nfrom sympy import totient\ndef A(u):\n    a=[]\n    k=0\n    for n in range(2, u + 1):\n        m=k + totient(n)\n        for i in range(1, totient(n) + 1):\n            a+=[m,]\n            m-=1\n            k+=1\n    return a\nprint(A(30)) \n"}
{"sequence_id": "A054635", "text": "Champernowne sequence: write n in base 3 and juxtapose.", "sequence": "0,1,2,1,0,1,1,1,2,2,0,2,1,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,2,0,0,2,0,1,2,0,2,2,1,0,2,1,1,2,1,2,2,2,0,2,2,1,2,2,2,1,0,0,0,1,0,0,1,1,0,0,2,1,0,1,0,1,0,1,1,1,0,1,2,1,0,2,0,1,0,2,1", "code": "\nfrom sympy.ntheory.digits import digits\ndef agen(limit):\n    for n in range(limit):\n        yield from digits(n, 3)[1:]\nprint([an for an in agen(35)]) \n"}
{"sequence_id": "A054683", "text": "Numbers n such that sum of digits is even.", "sequence": "0,2,4,6,8,11,13,15,17,19,20,22,24,26,28,31,33,35,37,39,40,42,44,46,48,51,53,55,57,59,60,62,64,66,68,71,73,75,77,79,80,82,84,86,88,91,93,95,97,99,101,103,105,107,109,110,112,114,116,118,121,123,125,127,129,130", "code": "\nA054683_list = [i for i in range(10**3) if not sum(int(d) for d in str(i)) % 2] \n"}
{"sequence_id": "A054793", "text": "Earliest sequence with a(a(n)) = n^4.", "sequence": "0,1,3,16,5,256,7,1296,9,4096,11,10000,13,20736,15,38416,81,18,83521,20,130321,22,194481,24,279841,26,390625,28,531441,30,707281,32,923521,34,1185921,36,1500625,38,1874161,40,2313441,42,2825761,44,3418801,46", "code": "\nfrom sympy import integer_nthroot\ndef A054793(n):\n    a, b = integer_nthroot(n,4)\n    return n if n <= 1 else A054793(a)**4 if b else n+1 if (n-a**4) % 2 else (n-1)**4 \n"}
{"sequence_id": "A054869", "text": "Digits of an idempotent 6-adic number.", "sequence": "3,1,2,0,5,3,1,2,2,2,5,1,5,5,1,4,1,3,1,2,5,5,5,0,5,2,5,5,5,3,1,4,3,3,0,4,2,2,4,0,1,3,3,1,4,0,2,0,1,2,5,2,4,0,2,3,3,0,3,4,5,5,2,5,5,4,3,2,3,1,5,4,5,4,0,1,1,0,4,2,0,1,3,0,1,5,0,4,3,5,0,1,0,2,4,0,3,4,2", "code": "\nn=10000;res=1-pow((3**n+1)//2,n,3**n)*2**n\nfor i in range(n):print(i,res%6);res//=6\n\n"}
{"sequence_id": "A054977", "text": "a(0)=2, a(n)=1, n >= 1.", "sequence": "2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", "code": "\ndef A054977(n):\n    return 1 if n else 2 \n"}
{"sequence_id": "A055023", "text": "a(n) = n/A055032(n).", "sequence": "1,2,3,1,5,2,7,1,1,2,11,1,13,2,1,1,17,2,19,1,3,2,23,1,1,2,1,1,29,2,31,1,1,2,1,1,37,2,3,1,41,2,43,1,1,2,47,1,1,2,1,1,53,2,1,1,3,2,59,1,61,2,1,1,1,2,67,1,1,2,71,1,73,2,3,1,1,2,79,1,1,2,83,1,1", "code": "\nfrom sympy import Integer\ndef a(n): return Integer(n)/((sum(m**(n - 1) for m in range(1, n)) + 1)/Integer(n)).denominator() \n"}
{"sequence_id": "A055031", "text": "Numerator of (Sum(m^(n-1),m=1..n-1)+1)/n.", "sequence": "1,1,2,37,71,2213,9596,1200305,24684613,287152493,1355849266,427675990237,1032458258547,228796942438201,16841089312342856,665478473553144001,1653031004194447737,631449646252135295657,3167496749732497119310", "code": "\nfrom sympy import Integer\ndef a(n): return ((sum(m**(n - 1) for m in range(1, n)) + 1)/Integer(n)).numerator() \n"}
{"sequence_id": "A055032", "text": "Denominator of (Sum(m^(n-1),m=1..n-1)+1)/n.", "sequence": "1,1,1,4,1,3,1,8,9,5,1,12,1,7,15,16,1,9,1,20,7,11,1,24,25,13,27,28,1,15,1,32,33,17,35,36,1,19,13,40,1,21,1,44,45,23,1,48,49,25,51,52,1,27,55,56,19,29,1,60,1,31,63,64,65,33,1,68,69,35,1,72,1", "code": "\nfrom sympy import Integer\ndef a(n): return ((sum(m**(n - 1) for m in range(1, n)) + 1)/Integer(n)).denominator() \n"}
{"sequence_id": "A055095", "text": "a(n) = 2*A000120(A003188(A055094(n))) - (n-1) = 2*A005811(A055094(n)) - (n-1).", "sequence": "0,1,2,1,2,3,2,1,4,1,2,1,2,3,2,-3,2,7,2,-3,4,3,2,-3,14,1,10,-3,2,3,2,-11,4,1,-2,-7,2,3,2,-11,2,7,2,-7,-4,3,2,-19,8,25,2,-11,2,19,-6,-15,4,1,2,-19,2,3,-6,-23,-10,7,2,-15,4,-5,2,-27,2,1,6,-15,-4,3,2,-39,28,1,2,-27,-14,3,2,-27,2,-9,-10,-19,4,3,-14,-47,2,15,-14,-19,2,3,2,-35,-24", "code": "\nfrom sympy.ntheory.residue_ntheory import quadratic_residues as q\ndef a055094(n):\n    Q=q(n)\n    z=0\n    for i in range(1, n):\n        z*=2\n        if i in Q: z+=1\n    return z\ndef a005811(n): return bin(n^(n>>1))[2:].count(\"1\")\ndef a(n): return 0 if n == 1 else 2*a005811(a055094(n)) - (n - 1) \n"}
{"sequence_id": "A055155", "text": "a(n) = Sum_{d|n} gcd(d, n/d).", "sequence": "1,2,2,4,2,4,2,6,5,4,2,8,2,4,4,10,2,10,2,8,4,4,2,12,7,4,8,8,2,8,2,14,4,4,4,20,2,4,4,12,2,8,2,8,10,4,2,20,9,14,4,8,2,16,4,12,4,4,2,16,2,4,10,22,4,8,2,8,4,8,2,30,2,4,14,8,4,8,2,20,17,4,2,16,4,4,4,12,2,20,4,8,4,4", "code": "\nfrom sympy import divisors, gcd\ndef A055155(n): return sum(gcd(d,n//d) for d in divisors(n,generator=True)) \n"}
{"sequence_id": "A055165", "text": "Number of invertible n X n matrices with entries equal to 0 or 1.", "sequence": "1,6,174,22560,12514320,28836612000,270345669985440,10160459763342013440", "code": "\nfrom itertools import product\nfrom sympy import Matrix\ndef A055165(n): return sum(1 for s in product([0,1],repeat=n**2) if Matrix(n,n,s).det() != 0) \n"}
{"sequence_id": "A055227", "text": "Nearest integer to sqrt( n! ).", "sequence": "1,1,1,2,5,11,27,71,201,602,1905,6318,21886,78911,295260,1143536,4574144,18859677,80014834,348776577,1559776269,7147792818,33526120082,160785623545,787685471323,3938427356615", "code": "\nfrom gmpy2 import isqrt\nA055227_list, g = [1], 1\nfor i in range(1, 101):\n....g *= i\n....s = isqrt(g)\n....A055227_list.append(int(s if g-s*(s+1) <= 0 else s+1))  \n"}
{"sequence_id": "A055259", "text": "Sums of two powers of 8.", "sequence": "2,9,16,65,72,128,513,520,576,1024,4097,4104,4160,4608,8192,32769,32776,32832,33280,36864,65536,262145,262152,262208,262656,266240,294912,524288,2097153,2097160,2097216,2097664,2101248,2129920,2359296,4194304,16777217", "code": "\ndef valuation(n, b):\n  v = 0\n  while n > 1: n //= b; v += 1\n  return v\ndef aupto(lim):\n  pows8 = [8**i for i in range(valuation(lim-1, 8) + 1)]\n  sum_pows8 = sorted([a+b for i, a in enumerate(pows8) for b in pows8[i:]])\n  return [s for s in sum_pows8 if s <= lim]\nprint(aupto(16777217)) \n"}
{"sequence_id": "A055260", "text": "Sums of two powers of 9.", "sequence": "2,10,18,82,90,162,730,738,810,1458,6562,6570,6642,7290,13122,59050,59058,59130,59778,65610,118098,531442,531450,531522,532170,538002,590490,1062882,4782970,4782978,4783050,4783698,4789530,4842018,5314410,9565938,43046722", "code": "\ndef valuation(n, b):\n  v = 0\n  while n > 1: n //= b; v += 1\n  return v\ndef aupto(lim):\n  pows = [9**i for i in range(valuation(lim-1, 9) + 1)]\n  sum_pows = sorted([a+b for i, a in enumerate(pows) for b in pows[i:]])\n  return [s for s in sum_pows if s <= lim]\nprint(aupto(43046722)) \n"}
{"sequence_id": "A055268", "text": "a(n) = (11*n + 4)*C(n+3, 3)/4.", "sequence": "1,15,65,185,420,826,1470,2430,3795,5665,8151,11375,15470,20580,26860,34476,43605,54435,67165,82005,99176,118910,141450,167050,195975,228501,264915,305515,350610,400520,455576,516120,582505,655095,734265", "code": "\nA055268_list, m = [], [11, 1, 1, 1, 1]\nfor _ in range(10**2):\n    A055268_list.append(m[-1])\n    for i in range(4):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A055396", "text": "Smallest prime dividing n is a(n)-th prime (a(1)=0).", "sequence": "0,1,2,1,3,1,4,1,2,1,5,1,6,1,2,1,7,1,8,1,2,1,9,1,3,1,2,1,10,1,11,1,2,1,3,1,12,1,2,1,13,1,14,1,2,1,15,1,4,1,2,1,16,1,3,1,2,1,17,1,18,1,2,1,3,1,19,1,2,1,20,1,21,1,2,1,4,1,22,1,2,1,23,1,3,1,2,1,24,1,4,1,2,1,3,1", "code": "\nfrom sympy import primepi, isprime, primefactors\ndef a049084(n): return primepi(n)*(1*isprime(n))\ndef a(n): return 0 if n==1 else a049084(min(primefactors(n))) \n"}
{"sequence_id": "A055471", "text": "Divisible by the product of its nonzero digits.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,15,20,24,30,36,40,50,60,70,80,90,100,101,102,104,105,110,111,112,115,120,128,132,135,140,144,150,175,200,208,210,212,216,220,224,240,250,300,306,312,315,360,384,400,432,480,500", "code": "\nfrom math import prod\ndef ok(n): return n > 0 and n%prod([int(d) for d in str(n) if d!='0']) == 0\nprint(list(filter(ok, range(501)))) \n"}
{"sequence_id": "A055472", "text": "Primes of the form k(k+1)/2+2 (i.e., two more than a triangular number).", "sequence": "2,3,5,17,23,47,107,173,233,353,467,563,743,863,1277,1433,1487,2213,2417,2777,3083,3323,4007,4373,5153,7877,8387,10733,11177,11783,13043,13697,14537,15053,15227,17207,17393,17957,18917,21323,22157,23873", "code": "\nimport sympy\n[n*(n+1)/2+2 for n in range(10**6) if sympy.ntheory.primetest.isprime(n*(n+1)/2+2)] \n"}
{"sequence_id": "A055483", "text": "a(n) = GCD of n and the reverse of n.", "sequence": "1,2,3,4,5,6,7,8,9,1,11,3,1,1,3,1,1,9,1,2,3,22,1,6,1,2,9,2,1,3,1,1,33,1,1,9,1,1,3,4,1,6,1,44,9,2,1,12,1,5,3,1,1,9,55,1,3,1,1,6,1,2,9,2,1,66,1,2,3,7,1,9,1,1,3,1,77,3,1,8,9,2,1,12,1,2,3,88,1,9,1,1,3,1,1,3,1,1,99,1,101,3,1,1,3,1,1,9,1,11,111", "code": "\nfrom math import gcd\ndef a(n): return gcd(n, int(str(n)[::-1]))\nprint([a(n) for n in range(1, 112)]) \n"}
{"sequence_id": "A055601", "text": "Number of n X n binary matrices with no zero rows.", "sequence": "1,1,9,343,50625,28629151,62523502209,532875860165503,17878103347812890625,2375680873491867011912191,1255325460068093790930770843649,2644211984585174742731315532085090303,22235498641774645581443610453175918212890625", "code": " a = lambda n:((1<<n)-1)**n \n"}
{"sequence_id": "A055601", "text": "Number of n X n binary matrices with no zero rows.", "sequence": "1,1,9,343,50625,28629151,62523502209,532875860165503,17878103347812890625,2375680873491867011912191,1255325460068093790930770843649,2644211984585174742731315532085090303,22235498641774645581443610453175918212890625", "code": "\nN = 58\nbase = 0\na = []\nfor i in range(N):\n....a += [base**i]\n....base = (base<<1)|1 \nprint(a)\n\n"}
{"sequence_id": "A055616", "text": "Numbers, with an even number of digits, that are the sum of the squares of their two halves (leading zeros allowed only for the second half).", "sequence": "1233,8833,990100,94122353,1765038125,2584043776,7416043776,8235038125,9901009901,116788321168,123288328768,876712328768,883212321168,999900010000,13793103448276,15348303604525,84651703604525,86206903448276,91103202846976,92318202663025", "code": "\ndef a():\n..n = 1\n..while n < 10**6:\n....st = str(n)\n....if len(st) % 2 == 0:\n......s1 = st[:int(len(st)/2)]\n......s2 = st[int(len(st)/2):int(len(st))]\n......if int(s1)**2+int(s2)**2 == int(st):\n........print(n,end=', ')\n........n += 1\n......else:\n........n += 1\n....else:\n......n = 10*n\na()\n\n"}
{"sequence_id": "A055620", "text": "Digits of an idempotent 6-adic number.", "sequence": "4,4,3,5,0,2,4,3,3,3,0,4,0,0,4,1,4,2,4,3,0,0,0,5,0,3,0,0,0,2,4,1,2,2,5,1,3,3,1,5,4,2,2,4,1,5,3,5,4,3,0,3,1,5,3,2,2,5,2,1,0,0,3,0,0,1,2,3,2,4,0,1,0,1,5,4,4,5,1,3,5,4,2,5,4,0,5,1,2,0,5,4,5,3,1,5,2,1,3,3,2,3,3,5,3", "code": "\nn=10000;res=pow((3**n+1)//2,n,3**n)*2**n\nfor i in range(n):print(i,res%6);res//=6\n\n"}
{"sequence_id": "A055685", "text": "Numbers k such that 2^k == -1 (mod k-1).", "sequence": "2,6,66,378,1190,1470,25806,58590,134946,137346,170586,272610,285390,420210,538734,592410,618450,680706,778806,1163066,1520442,1700946,2099202,2831010,4020030,4174170,4516110,5059890,5215770", "code": "\nA055685_list = [n for n in range(2,10**6) if pow(2,n,n-1) == n-2] \n"}
{"sequence_id": "A055777", "text": "a(n) = 3^(3^n).", "sequence": "3,27,19683,7625597484987,443426488243037769948249630619149892803", "code": "\nprint([3**(3**n) for n in range(5)]) \n"}
{"sequence_id": "A055882", "text": "a(n) = 2^n*Bell(n). E.g.f.: exp(exp(2x)-1).", "sequence": "1,2,8,40,240,1664,12992,112256,1059840,10827264,118758400,1389711360,17258893312,226463227904,3127694491648,45316785602560,686826595745792,10861264214949888,178802342273744896,3058036745204924416,54236710945813430272,995874184692762673152", "code": "\n\nfrom itertools import accumulate\nA055882_list, blist, b, n2 = [1,2], [1], 1, 4\nfor _ in range(2,201):\n....blist = list(accumulate([b]+blist))\n....b = blist[-1]\n....A055882_list.append(b*n2)\n....n2 *= 2 \n"}
{"sequence_id": "A055938", "text": "Integers not generated by b(n) = b(floor(n/2)) + n (cf. A005187).", "sequence": "2,5,6,9,12,13,14,17,20,21,24,27,28,29,30,33,36,37,40,43,44,45,48,51,52,55,58,59,60,61,62,65,68,69,72,75,76,77,80,83,84,87,90,91,92,93,96,99,100,103,106,107,108,111,114,115,118,121,122,123,124,125,126,129", "code": "\ndef a053644(n): return 0 if n==0 else 2**(len(bin(n)[2:]) - 1)\ndef a043545(n):\n    x=bin(n)[2:]\n    return int(max(x)) - int(min(x))\ndef a079559(n): return 1 if n==0 else a043545(n + 1)*a079559(n + 1 - a053644(n + 1))\nprint([n for n in range(1, 201) if a079559(n)==0]) \n"}
{"sequence_id": "A055941", "text": "a(n) = Sum_{j=0..k-1} (i(j) - j) where n = Sum_{j=0..k-1} 2^i(j).", "sequence": "0,0,1,0,2,1,2,0,3,2,3,1,4,2,3,0,4,3,4,2,5,3,4,1,6,4,5,2,6,3,4,0,5,4,5,3,6,4,5,2,7,5,6,3,7,4,5,1,8,6,7,4,8,5,6,2,9,6,7,3,8,4,5,0,6,5,6,4,7,5,6,3,8,6,7,4,8,5,6,2,9,7,8,5,9,6,7,3,10,7,8,4,9,5,6,1,10,8,9,6,10,7,8,4", "code": "\ndef A055941(n):\n    s = bin(n)[2:]\n    return sum(s[i:].count('0') for i,d in enumerate(s,start=1) if d == '1')\n\n"}
{"sequence_id": "A055987", "text": "a(n+1) = a(n) converted to base 10 from base 16.", "sequence": "10,16,22,34,52,82,130,304,772,1906,6406,25606,153094,1388692,20481682,541595266,22571209318,2359835005720,621877793937184,441783186105790852,1256072821702053660754", "code": "\ndef aupton(nn):\n    alst = [10]\n    for n in range(1, nn+1):\n        alst.append(int(str(alst[-1]), 16))\n    return alst\nprint(aupton(20)) \n"}
{"sequence_id": "A056059", "text": "GCD of largest square and squarefree part of central binomial coefficients.", "sequence": "1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,2,3,6,2,1,1,1,3,3,1,1,1,2,1,1,1,2,1,2,6,3,1,1,1,2,3,6,2,1,1,2,2,1,2,1,1,2,1,1,1,1,1,1,1,2,1,1,1,2,1,2,2,1,1,1,1,2,3,6,6,3,1,2,2,1,2,1,3,6,1,1,1,2,1,2", "code": "\nfrom sympy import binomial, gcd\nfrom sympy.ntheory.factor_ import core\ndef a001405(n): return binomial(n, n//2)\ndef a055229(n):\n    c = core(n)\n    return gcd(c, n//c)\ndef a(n): return a055229(a001405(n))\nprint([a(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A056109", "text": "Fifth spoke of a hexagonal spiral.", "sequence": "1,6,17,34,57,86,121,162,209,262,321,386,457,534,617,706,801,902,1009,1122,1241,1366,1497,1634,1777,1926,2081,2242,2409,2582,2761,2946,3137,3334,3537,3746,3961,4182,4409,4642,4881,5126,5377,5634,5897,6166,6441", "code": " for n in range(0, 100): print(int(3*n**2 + 2*n + 1), end=' ') \n"}
{"sequence_id": "A056169", "text": "Number of unitary prime divisors of n.", "sequence": "0,1,1,0,1,2,1,0,0,2,1,1,1,2,2,0,1,1,1,1,2,2,1,1,0,2,0,1,1,3,1,0,2,2,2,0,1,2,2,1,1,3,1,1,1,2,1,1,0,1,2,1,1,1,2,1,2,2,1,2,1,2,1,0,2,3,1,1,2,3,1,0,1,2,1,1,2,3,1,1,0,2,1,2,2,2,2,1,1,2,2,1,2,2,2,1,1,1,1,0,1,3,1,1,3", "code": "\nfrom sympy import factorint\ndef a(n):\n    f=factorint(n)\n    return 0 if n==1 else sum(1 for i in f if f[i]==1)\nprint([a(n) for n in range(1, 101)]) \n(Scheme, with memoization-macro definec) (definec (A056169 n) (if (= 1 n) 0 (+ (if (= 1 (A067029 n)) 1 0) (A056169 (A028234 n))))) ;; _Antti Karttunen_, Nov 28 2017\n"}
{"sequence_id": "A056170", "text": "Number of non-unitary prime divisors of n.", "sequence": "0,0,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,0,2,0,0,1,1,0,0,0,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,2,0,0,0,1,0", "code": "\nfrom sympy import factorint\ndef a(n):\n    f = factorint(n)\n    return sum([1 for i in f if f[i]!=1]) \n"}
{"sequence_id": "A056171", "text": "a(n) = pi(n) - pi(floor(n/2)), where pi is A000720.", "sequence": "0,1,2,1,2,1,2,2,2,1,2,2,3,2,2,2,3,3,4,4,4,3,4,4,4,3,3,3,4,4,5,5,5,4,4,4,5,4,4,4,5,5,6,6,6,5,6,6,6,6,6,6,7,7,7,7,7,6,7,7,8,7,7,7,7,7,8,8,8,8,9,9,10,9,9,9,9,9,10,10,10,9,10,10,10,9,9,9,10,10,10,10,10,9,9,9,10,10", "code": "\nfrom sympy import primepi\n[primepi(n) - primepi(n//2) for n in range(1,151)] \n"}
{"sequence_id": "A056207", "text": "Number of binary trees of height <= n.", "sequence": "3,24,675,458328,210066388899,44127887745906175987800,1947270476915296449559703445493848930452791203,3791862310265926082868235028027893277370233152247388584761734150717768254410341175325352024", "code": "\nfrom itertools import accumulate\ndef f(anm1, _): return anm1**2 + 4*anm1 + 3\ndef aupton(terms): return list(accumulate([3]*terms, f))\nprint(aupton(8)) \n"}
{"sequence_id": "A056303", "text": "Number of primitive (period n) n-bead necklace structures using exactly two different colored beads.", "sequence": "0,1,1,2,3,5,9,16,28,51,93,170,315,585,1091,2048,3855,7280,13797,26214,49929,95325,182361,349520,671088,1290555,2485504,4793490,9256395,17895679,34636833,67108864,130150493,252645135,490853403,954437120,1857283155", "code": "\nfrom sympy import divisors, mobius\ndef a000048(n): return 1 if n<1 else sum([mobius(d)*2**(n/d) for d in divisors(n) if d%2 == 1])/(2*n)\ndef a(n): return a000048(n) - 0**(n - 1) \n"}
{"sequence_id": "A056524", "text": "Palindromes with even number of digits.", "sequence": "11,22,33,44,55,66,77,88,99,1001,1111,1221,1331,1441,1551,1661,1771,1881,1991,2002,2112,2222,2332,2442,2552,2662,2772,2882,2992,3003,3113,3223,3333,3443,3553,3663,3773,3883,3993,4004,4114,4224,4334,4444,4554", "code": "\ndef a(n): s = str(n); return int(s + s[::-1])\nprint([a(n) for n in range(1, 46)]) \n"}
{"sequence_id": "A056539", "text": "Self-inverse permutation: reverse the bits in binary expansion of n and also complement them (0->1, 1->0) if the run count (A005811) is even.", "sequence": "0,1,2,3,6,5,4,7,14,9,10,13,12,11,8,15,30,17,22,25,26,21,18,29,28,19,20,27,24,23,16,31,62,33,46,49,54,41,38,57,58,37,42,53,50,45,34,61,60,35,44,51,52,43,36,59,56,39,40,55,48,47,32,63,126,65,94,97,110,81,78", "code": "\ndef a005811(n): return bin(n^(n>>1))[2:].count(\"1\")\ndef a(n):\n    if n==0: return 0\n    x=bin(n)[2:][::-1]\n    if a005811(n)%2==1: return int(x, 2)\n    z=''.join('1' if i == '0' else '0' for i in x)\n    return int(z, 2) \n"}
{"sequence_id": "A056582", "text": "Highest common factor (or GCD) of n^n and hyperfactorial(n-1), i.e., gcd(n^n, product(k^k) for k < n).", "sequence": "1,1,4,1,1728,1,65536,19683,3200000,1,8916100448256,1,13492928512,437893890380859375,18446744073709551616,1,39346408075296537575424,1,104857600000000000000000000", "code": "\nfrom gmpy2 import gcd\nA056582_list, n = [], 1\nfor i in range(2,201):\n    m = i**i\n    A056582_list.append(int(gcd(n,m)))\n    n *= m \n"}
{"sequence_id": "A056608", "text": "Least prime factor of the n-th composite number.", "sequence": "2,2,2,3,2,2,2,3,2,2,2,3,2,2,5,2,3,2,2,2,3,2,5,2,2,3,2,2,2,3,2,2,7,2,3,2,2,5,2,3,2,2,2,3,2,5,2,2,3,2,2,2,3,2,7,2,2,3,2,2,5,2,3,2,2,7,2,3,2,5,2,2,3,2,2,2,3,2,2,2,3,2,2,5,2,3,2,7,2,11,2,3,2,5,2,2,3,2,2,7,2,3,2,2,2", "code": "\nfrom sympy import composite, factorint\ndef A056608(n):\n    return min(factorint(composite(n))) \n"}
{"sequence_id": "A056671", "text": "1 + the number of unitary and squarefree divisors of n = number of divisors of reduced squarefree part of n.", "sequence": "1,2,2,1,2,4,2,1,1,4,2,2,2,4,4,1,2,2,2,2,4,4,2,2,1,4,1,2,2,8,2,1,4,4,4,1,2,4,4,2,2,8,2,2,2,4,2,2,1,2,4,2,2,2,4,2,4,4,2,4,2,4,2,1,4,8,2,2,4,8,2,1,2,4,2,2,4,8,2,2,1,4,2,4,4,4,4,2,2,4,4,2,4,4,4,2,2,2,2,1,2,8,2,2,8", "code": "\nfrom sympy import factorint, prod\ndef a(n): return 1 if n==1 else prod([2 if e==1 else 1 for p, e in factorint(n).items()])\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A056674", "text": "Number of squarefree divisors which are not unitary. Also number of unitary divisors which are not squarefree.", "sequence": "0,0,0,1,0,0,0,1,1,0,0,2,0,0,0,1,0,2,0,2,0,0,0,2,1,0,1,2,0,0,0,1,0,0,0,3,0,0,0,2,0,0,0,2,2,0,0,2,1,2,0,2,0,2,0,2,0,0,0,4,0,0,2,1,0,0,0,2,0,0,0,3,0,0,2,2,0,0,0,2,1,0,0,4,0,0,0,2,0,4,0,2,0,0,0,2,0,2,2,3,0,0,0,2,0", "code": "\nfrom sympy import gcd, primefactors, divisor_count\nfrom sympy.ntheory.factor_ import core\ndef a055229(n):\n    c=core(n)\n    return gcd(c, n//c)\ndef a056674(n): return 2**len(primefactors(n)) - divisor_count(core(n)//a055229(n))\nprint([a056674(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A056733", "text": "Each number is the sum of the cubes of its 3 sections.", "sequence": "153,370,371,407,165033,221859,336700,336701,340067,341067,407000,407001,444664,487215,982827,983221,166500333,296584415,333667000,333667001,334000667,710656413,828538472,142051701000,166650003333,262662141664,333366670000", "code": "\ndef a():\n..n = 1\n..while n < 10**9:\n....st = str(n)\n....if len(st) % 3 == 0:\n......s1 = st[:int(len(st)/3)]\n......s2 = st[int(len(st)/3):int(2*len(st)/3)]\n......s3 = st[int(2*len(st)/3):int(len(st))]\n......if int(s1)**3+int(s2)**3+int(s3)**3 == int(st):\n........print(n, end=', ')\n........n += 1\n......else:\n........n += 1\n....else:\n......n = 10*n\na()\n\n"}
{"sequence_id": "A056733", "text": "Each number is the sum of the cubes of its 3 sections.", "sequence": "153,370,371,407,165033,221859,336700,336701,340067,341067,407000,407001,444664,487215,982827,983221,166500333,296584415,333667000,333667001,334000667,710656413,828538472,142051701000,166650003333,262662141664,333366670000", "code": "\ndef a():\n..for i in range(1,10):\n....for j in range(10):\n......for k in range(10):\n........if i**3 + j**3 + k**3 == i*100 + j*10 + k:\n..........print(i*100 + j*10 + k)\n..for i in range(10,100):\n....for j in range(100):\n......for k in range(100):\n........if i**3 + j**3 + k**3 == i*10000 + j*100 + k:\n..........print(i*10000 + j*100 + k)\n..for i in range(100,1000):\n....for j in range(1000):\n......for k in range(1000):\n........if i**3 + j**3 + k**3 == i*1000000 + j*1000 + k:\n..........print(i*1000000 + j*1000 + k)\na()\n\n"}
{"sequence_id": "A056791", "text": "Weight of binary expansion of n + length of binary expansion of n.", "sequence": "1,2,3,4,4,5,5,6,5,6,6,7,6,7,7,8,6,7,7,8,7,8,8,9,7,8,8,9,8,9,9,10,7,8,8,9,8,9,9,10,8,9,9,10,9,10,10,11,8,9,9,10,9,10,10,11,9,10,10,11,10,11,11,12,8,9,9,10,9,10,10,11,9,10,10,11,10,11,11,12,9,10,10,11,10,11,11", "code": "\ndef a(n): b = bin(n)[2:]; return b.count('1') + len(b)\nprint([a(n) for n in range(87)]) \n"}
{"sequence_id": "A056810", "text": "Numbers whose fourth power is a palindrome.", "sequence": "0,1,11,101,1001,10001,100001,1000001,10000001,100000001,1000000001,10000000001,100000000001", "code": "\ndef ispal(n): s = str(n); return s == s[::-1]\ndef afind(limit):\n    for k in range(limit+1):\n        if ispal(k**4): print(k, end=\", \")\nafind(10000001) \n"}
{"sequence_id": "A056825", "text": "Numbers such that no smaller positive integer has the same maximal palindrome in the periodic part of the simple continued fraction for its square root.", "sequence": "2,3,6,7,11,13,14,18,19,21,22,23,27,28,29,31,34,38,41,43,44,45,46,47,51,52,53,54,55,57,58,59,61,62,66,67,69,70,71,73,76,77,79,83,85,86,88,89,91,92,93,94,97,98,102,103,106,107,108,109,111,113,114,115,116,117,118,119", "code": "\nfrom sympy.ntheory.continued_fraction import continued_fraction_periodic\nA056825_list, nset, n = [], set(), 1\nwhile len(A056825_list) < 10000:\n    cf = continued_fraction_periodic(0,1,n)\n    if len(cf) > 1:\n        pal = tuple(cf[1][:-1])\n        if pal not in nset:\n            A056825_list.append(n)\n            nset.add(pal)\n    n += 1 \n"}
{"sequence_id": "A056857", "text": "Triangle read by rows: T(n,c) = number of successive equalities in set partitions of n.", "sequence": "1,1,1,2,2,1,5,6,3,1,15,20,12,4,1,52,75,50,20,5,1,203,312,225,100,30,6,1,877,1421,1092,525,175,42,7,1,4140,7016,5684,2912,1050,280,56,8,1,21147,37260,31572,17052,6552,1890,420,72,9,1,115975,211470,186300,105240,42630,13104,3150,600,90,10,1", "code": "\nfrom sympy import bell, binomial\nfor n in range(1,12):\n    print([bell(n - 1 - k) * binomial(n - 1, k) for k in range(n)]) \n"}
{"sequence_id": "A056964", "text": "a(n) = n + reversal of digits of n.", "sequence": "0,2,4,6,8,10,12,14,16,18,11,22,33,44,55,66,77,88,99,110,22,33,44,55,66,77,88,99,110,121,33,44,55,66,77,88,99,110,121,132,44,55,66,77,88,99,110,121,132,143,55,66,77,88,99,110,121,132,143,154,66,77,88,99,110", "code": " def A056964(n): return n+int(str(n)[::-1]) \n"}
{"sequence_id": "A056965", "text": "a(n) = n - (reversal of digits of n).", "sequence": "0,0,0,0,0,0,0,0,0,0,9,0,-9,-18,-27,-36,-45,-54,-63,-72,18,9,0,-9,-18,-27,-36,-45,-54,-63,27,18,9,0,-9,-18,-27,-36,-45,-54,36,27,18,9,0,-9,-18,-27,-36,-45,45,36,27,18,9,0,-9,-18,-27,-36,54,45,36,27,18,9,0,-9,-18,-27,63,54,45,36,27,18,9,0,-9,-18,72,63,54", "code": "\ndef a(n): return n - int(str(n)[::-1]) \n"}
{"sequence_id": "A057045", "text": "Let R(i,j) be the rectangle with antidiagonals 1; 2,3; 4,5,6; ...; the n-th Lucas number is in antidiagonal a(n).", "sequence": "2,1,2,3,4,5,6,8,10,12,16,20,25,32,41,52,66,85,107,137,174,221,281,358,455,579,737,937,1192,1516,1929,2454,3121,3970,5050,6424,8171,10394,13221,16818,21393,27212", "code": "\nfrom gmpy2 import isqrt_rem, lucas\ndef A057045(n):\n    i, j = isqrt_rem(2*lucas(n-1))\n    return int(i + int(4*(j-i) >= 1)) \n"}
{"sequence_id": "A057104", "text": "The non-octal numbers: numbers containing an 8 or 9 (they cannot be mistaken for octal numbers).", "sequence": "8,9,18,19,28,29,38,39,48,49,58,59,68,69,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,108,109,118,119,128,129,138,139,148,149,158,159,168,169,178,179,180,181,182,183,184,185,186,187,188", "code": "\ndef ok(n): return {'8', '9'} & set(str(n)) != set()\nprint(list(filter(ok, range(189)))) \n"}
{"sequence_id": "A057147", "text": "a(n) = n times sum of digits of n.", "sequence": "0,1,4,9,16,25,36,49,64,81,10,22,36,52,70,90,112,136,162,190,40,63,88,115,144,175,208,243,280,319,90,124,160,198,238,280,324,370,418,468,160,205,252,301,352,405,460,517,576,637,250,306,364,424,486,550,616", "code": "\n[n*sum([int(d) for d in str(n)]) for n in range(10**5)] \n"}
{"sequence_id": "A057332", "text": "a(n) is the number of (2n+1)-digit palindromic primes that undulate.", "sequence": "4,15,52,210,1007,5156,25571,133293,727082,3874464,21072166,117829671,654556778", "code": "\nfrom sympy import isprime\nfrom itertools import product\ndef sign(n): return (n > 0) - (n < 0)\ndef unds(n):\n  s = str(n)\n  if len(s) == 1: return True\n  signs = set(sign(int(s[i-1]) - int(s[i])) for i in range(1, len(s), 2))\n  if len(signs) > 1: return False\n  if len(s) % 2 == 0: return signs == {1} or signs == {-1}\n  return sign(int(s[-1]) - int(s[-2])) in signs - {0}\ndef candidate_pals(n): \n  if n == 0: yield from [2, 3, 5, 7]; return \n  for rightbutend in product(\"0123456789\", repeat=n-1):\n    rightbutend = \"\".join(rightbutend)\n    for end in \"1379\": \n      left = end + rightbutend[::-1]\n      for mid in \"0123456789\": yield int(left + mid + rightbutend + end)\ndef a(n): return sum(1 for p in candidate_pals(n) if unds(p) and isprime(p))\nprint([a(n) for n in range(6)]) \n"}
{"sequence_id": "A057332", "text": "a(n) is the number of (2n+1)-digit palindromic primes that undulate.", "sequence": "4,15,52,210,1007,5156,25571,133293,727082,3874464,21072166,117829671,654556778", "code": "\nfrom sympy import isprime\ndef f(w,dir):\n    if dir == 1:\n        for s in w:\n            for t in range(int(s[-1])+1,10):\n                yield s+str(t)\n    else:\n        for s in w:\n            for t in range(0,int(s[-1])):\n                yield s+str(t)\ndef A057332(n):\n    c = 0\n    for d in '123456789':\n        x = d\n        for i in range(1,n+1):\n            x = f(x,(-1)**i)\n        c += sum(1 for p in x if isprime(int(p+p[-2::-1])))\n        if n > 0:\n            y = d\n            for i in range(1,n+1):\n                y = f(y,(-1)**(i+1))\n            c += sum(1 for p in y if isprime(int(p+p[-2::-1])))\n    return c \n"}
{"sequence_id": "A057333", "text": "Numbers of n-digit primes that undulate.", "sequence": "4,20,74,347,1743,8385,44355,229952,1235489,6629026,37152645,202017712,1142393492,6333190658", "code": "\nfrom sympy import isprime\ndef f(w,dir):\n    if dir == 1:\n        for s in w:\n            for t in range(int(s[-1])+1,10):\n                yield s+str(t)\n    else:\n        for s in w:\n            for t in range(0,int(s[-1])):\n                yield s+str(t)\ndef A057333(n):\n    c = 0\n    for d in '123456789':\n        x = d\n        for i in range(1,n):\n            x = f(x,(-1)**i)\n        c += sum(1 for p in x if isprime(int(p)))\n        if n > 1:\n            y = d\n            for i in range(1,n):\n                y = f(y,(-1)**(i+1))\n            c += sum(1 for p in y if isprime(int(p)))\n    return c \n"}
{"sequence_id": "A057354", "text": "a(n) = floor(2*n/5).", "sequence": "0,0,0,1,1,2,2,2,3,3,4,4,4,5,5,6,6,6,7,7,8,8,8,9,9,10,10,10,11,11,12,12,12,13,13,14,14,14,15,15,16,16,16,17,17,18,18,18,19,19,20,20,20,21,21,22,22,22,23,23,24,24,24,25,25,26,26,26,27,27,28,28,28,29,29,30,30", "code": " [int(2*n/5) for n in range(80)] \n"}
{"sequence_id": "A057436", "text": "Contains digits 1 through 6 only.", "sequence": "1,2,3,4,5,6,11,12,13,14,15,16,21,22,23,24,25,26,31,32,33,34,35,36,41,42,43,44,45,46,51,52,53,54,55,56,61,62,63,64,65,66,111,112,113,114,115,116,121,122,123,124,125,126,131,132,133,134,135,136,141,142,143", "code": "\nfrom itertools import product\nA057436_list = [int(''.join(d)) for l in range(1,5) for d in product('123456',repeat=l)] \n"}
{"sequence_id": "A057450", "text": "Prime recurrence: a(n+1) = a(n)-th prime, with a(1) = 4.", "sequence": "4,7,17,59,277,1787,15299,167449,2269733,37139213,718064159,16123689073,414507281407,12055296811267,392654585611999,14199419938376521,565855918431234443", "code": "\nfrom sympy import prime\nfrom itertools import accumulate\ndef f(an, _): return prime(an)\nprint(list(accumulate([4]*12, f))) \n"}
{"sequence_id": "A057453", "text": "Prime recurrence: a(n+1) = a(n)-th prime, with a(1) = 9.", "sequence": "9,23,83,431,3001,27457,318211,4535189,77557187,1559861749,36294260117,963726515729,28871271685163,966399998477597,35843152090509943,1462429366668283501", "code": "\nfrom sympy import prime\nfrom itertools import accumulate\ndef anext(an, _): return prime(an)\nprint(list(accumulate([9]*10, anext))) \n"}
{"sequence_id": "A057456", "text": "Prime recurrence: a(n+1) = a(n)-th prime, with a(1) = 10.", "sequence": "10,29,109,599,4397,42043,506683,7474967,131807699,2724711961,64988430769,1765037224331,53982894593057,1841803943951113,69532764058102673,2884247930418152801", "code": "\nfrom sympy import prime\nfrom itertools import accumulate\ndef f(an, _): return prime(an)\nprint(list(accumulate([10]*10, f))) \n"}
{"sequence_id": "A057514", "text": "Number of peaks in mountain ranges encoded by A014486, number of leaves in the corresponding rooted plane trees (the root node is never counted as a leaf).", "sequence": "0,1,2,1,3,2,2,2,1,4,3,3,3,2,3,2,3,3,2,2,2,2,1,5,4,4,4,3,4,3,4,4,3,3,3,3,2,4,3,3,3,2,4,3,4,4,3,3,3,3,2,3,2,3,3,2,3,3,3,2,2,2,2,2,1,6,5,5,5,4,5,4,5,5,4,4,4,4,3,5,4,4,4,3,5,4,5,5,4,4,4,4,3,4,3,4,4,3,4,4,4,3,3,3,3", "code": "\ndef a005811(n): return bin(n^(n>>1))[2:].count(\"1\")\ndef ok(n): \n    B=bin(n)[2:] if n!=0 else 0\n    s=0\n    for b in B:\n        s+=1 if b==\"1\" else -1\n        if s<0: return 0\n    return s==0\ndef A(n): return [0] + [i for i in range(1, n + 1) if ok(i)]\nl=A(200)\nprint([a005811(l[i])//2 for i in range(len(l))]) \n"}
{"sequence_id": "A057521", "text": "Powerful (1) part of n: if n = Product_i (pi^ei) then a(n) = Product_{i : ei > 1} (pi^ei); if n=b*c^2*d^3 then a(n)=c^2*d^3 when b is minimized.", "sequence": "1,1,1,4,1,1,1,8,9,1,1,4,1,1,1,16,1,9,1,4,1,1,1,8,25,1,27,4,1,1,1,32,1,1,1,36,1,1,1,8,1,1,1,4,9,1,1,16,49,25,1,4,1,27,1,8,1,1,1,4,1,1,9,64,1,1,1,4,1,1,1,72,1,1,25,4,1,1,1,16,81,1,1,4,1,1,1,8,1,9,1,4,1,1,1,32,1", "code": "\nfrom sympy import factorint, prod\ndef a(n): return 1 if n==1 else prod(1 if e==1 else p**e for p, e in factorint(n).items())\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A057539", "text": "Birthday set of order 7, i.e., numbers congruent to +- 1 modulo 2, 3, 4, 5, 6 and 7.", "sequence": "1,29,41,71,139,169,181,209,211,239,251,281,349,379,391,419,421,449,461,491,559,589,601,629,631,659,671,701,769,799,811,839,841,869,881,911,979,1009,1021,1049,1051,1079,1091,1121,1189,1219,1231,1259,1261,1289", "code": "\ndef ok(n): return all(n%d in [1, d-1] for d in range(2, 8))\ndef aupto(nn): return [m for m in range(1, nn+1) if ok(m)]\nprint(aupto(1300)) \n"}
{"sequence_id": "A057567", "text": "Number of partitions of n where the product of parts divides n.", "sequence": "1,2,2,4,2,5,2,7,4,5,2,11,2,5,5,12,2,11,2,11,5,5,2,21,4,5,7,11,2,15,2,19,5,5,5,26,2,5,5,21,2,15,2,11,11,5,2,38,4,11,5,11,2,21,5,21,5,5,2,36,2,5,11,30,5,15,2,11,5,15,2,52,2,5,11,11,5,15,2,38,12,5,2,36,5,5,5,21", "code": "\nfrom sympy import divisors, isprime\ndef T(n, m):\n    if isprime(n): return 1 if n <= m else 0\n    A = (d for d in divisors(n) if 1 < d < n and d <= m)\n    s = sum(T(n // d, d) for d in A)\n    return s + 1 if n <= m else s\ndef a001055(n): return T(n, n)\ndef a(n): return sum(a001055(d) for d in divisors(n))\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A057615", "text": "ATS: Add Then Sort (i.e., double previous term and then sort digits).", "sequence": "1,2,4,8,16,23,46,29,58,116,223,446,289,578,1156,1223,2446,2489,4789,5789,11578,12356,12247,24449,48889,77789,155578,111356,122227,244445,48889,77789,155578,111356,122227,244445,48889,77789,155578,111356", "code": "\nfrom itertools import accumulate\ndef ats(anm1, _): return int(\"\".join(sorted(str(2*anm1))))\nprint(list(accumulate([1]*40, ats))) \n"}
{"sequence_id": "A057630", "text": "Primes such that replacing each digit d with d copies of the digit d produces a prime. Zeros are allowed.", "sequence": "11,31,53,101,131,149,223,283,311,313,331,397,463,503,641,691,937,941,1031,1049,1069,1301,1409,1439,1511,1609,1741,1871,1949,1993,1999,2083,2111,2203,2447,2803,2939,3001,3011,3061,3163,3301,3391,3433,3499,3559", "code": "\nfrom sympy import isprime, nextprime\nA057630_list, dlist, p = [], [str(d)*d for d in range(10)], 2\nwhile len(A057630_list) < 10000:\n    if isprime(''.join(dlist[int(d)] for d in str(p))):\n        A057630_list.append(p)\n    p = nextprime(p) \n"}
{"sequence_id": "A057683", "text": "Numbers k such that k^2+k+1, k^3+k+1 and k^4+k+1 are all prime.", "sequence": "1,2,5,6,12,69,77,131,162,426,701,792,1221,1494,1644,1665,2129,2429,2696,3459,3557,3771,4350,4367,5250,5670,6627,7059,7514,7929,8064,9177,9689,10307,10431,11424,13296,13299,13545,14154,14286,14306,15137", "code": "\nfrom sympy import isprime\nA057683_list = [n for n in range(10**5) if isprime(n**2+n+1) and isprime(n**3+n+1) and isprime(n**4+n+1)] \n"}
{"sequence_id": "A057699", "text": "Primes whose reversal is a cube.", "sequence": "521,806041,969407,1393939,2303461,3989683,4831037,5783273,8081153,8485181,11520991,15231851,23206301,25578253,29925251,32296051,48762541,52182343,57369149,61277761,67134511,67954643,74825299", "code": "\nfrom sympy import isprime\nA057699_list = []\nfor i in range(10**6):\n    if i % 10:\n        p = int(str(i**3)[::-1])\n        if isprime(p):\n            A057699_list.append(p)\nA057699_list = sorted(A057699_list) \n"}
{"sequence_id": "A057706", "text": "Smaller of twin primes whose average is a primorial number.", "sequence": "5,29,2309", "code": "\nfrom sympy import isprime, prime, primerange\ndef auptoprimorial(limit):\n  phash, alst = 1, []\n  for p in primerange(1, prime(limit)+1):\n    phash *= p\n    if isprime(phash-1) and isprime(phash+1): alst.append(phash-1)\n  return alst\nprint(auptoprimorial(5)) \n"}
{"sequence_id": "A057708", "text": "Numbers n such that 2^n reversed is prime.", "sequence": "1,4,5,7,10,17,24,37,45,55,70,77,107,137,150,271,364,1157,1656,2004,2126,3033,3489,3645,4336,6597,7279,12690,13840,20108,21693,28888,84155,102930", "code": "\nfrom sympy import isprime\nk, m, A057708_list = 1, 2,  []\nwhile k <= 10**3:\n    if isprime(int(str(m)[::-1])):\n        A057708_list.append(k)\n    k += 1\n    m *= 2 \n"}
{"sequence_id": "A057736", "text": "Primes p such that 2^p + 3 is prime.", "sequence": "2,3,7,67", "code": "\nfrom sympy import isprime, primerange\ndef afind(limit):\n  for p in primerange(2, limit+1):\n    if isprime(2**p + 3): print(p, end=\", \")\nafind(1000) \n"}
{"sequence_id": "A057752", "text": "Difference between nearest integer to Li(10^n) and pi(10^n), where Li(x) = integral of log(x) and  pi(10^n) = number of primes <= 10^n (A006880).", "sequence": "2,5,10,17,38,130,339,754,1701,3104,11588,38263,108971,314890,1052619,3214632,7956589,21949555,99877775,222744644,597394254,1932355208,7250186216,17146907278,55160980939,155891678121,508666658006,1427745660374", "code": "\nfrom sympy import N, li, primepi, floor\ndef round(n):\n    return int(floor(n+0.5))\ndef A057752(n):\n    return round(N(li(10**n),10*n)) - primepi(10**n) \n"}
{"sequence_id": "A057821", "text": "a(n) is the least nonnegative integer k such that 2^n - k is a safe prime.", "sequence": "1,5,9,5,21,29,9,5,9,17,45,161,165,269,285,17,45,233,9,17,321,317,633,677,405,437,189,1385,69,209,9,641,849,137,45,401,381,437,1965,2201,741,1493,573,857,1485,5297,2709,161,465,473,1269,4805,789", "code": "\nfrom sympy import isprime\ndef a(n):\n    k=0\n    while True:\n        k+=1\n        if isprime(2**n - k) and isprime((2**n - k - 1)//2): return k\nprint([a(i) for i in range(3, 21)]) \n"}
{"sequence_id": "A057839", "text": "Numbers k such that k | 10^k + 8^k + 6^k + 4^k + 2^k + 1.", "sequence": "1,31,198089,876881261,2026728077", "code": "\ndef afind(limit):\n  for k in range(1, limit+1, 2):\n    if (1 + sum(pow(e, k, k) for e in [2, 4, 6, 8, 10])) % k == 0:\n      print(k, end=\", \")\nafind(10**6) \n"}
{"sequence_id": "A057889", "text": "Bit-reverse of n, including as many leading as trailing zeros.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,13,12,11,14,15,16,17,18,25,20,21,26,29,24,19,22,27,28,23,30,31,32,33,34,49,36,41,50,57,40,37,42,53,52,45,58,61,48,35,38,51,44,43,54,59,56,39,46,55,60,47,62,63,64,65,66,97,68,81,98,113", "code": "\ndef a(n):\n    x = bin(n)[2:]\n    y = x[::-1]\n    return int(str(int(y))+(len(x) - len(str(int(y))))*'0', 2)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A057890", "text": "In base 2, either a palindrome or becomes a palindrome if trailing 0's are omitted.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,12,14,15,16,17,18,20,21,24,27,28,30,31,32,33,34,36,40,42,45,48,51,54,56,60,62,63,64,65,66,68,72,73,80,84,85,90,93,96,99,102,107,108,112,119,120,124,126,127,128,129,130,132,136,144,146", "code": "\nA057890 = [n for n in range(10**6) if bin(n)[2:].rstrip('0') == bin(n)[2:].rstrip('0')[::-1]] \n"}
{"sequence_id": "A057960", "text": "Number of base 5 (n+1)-digit numbers starting with a zero and with adjacent digits differing by one or less.", "sequence": "1,2,5,13,35,95,259,707,1931,5275,14411,39371,107563,293867,802859,2193451,5992619,16372139,44729515,122203307,333865643,912137899,2492007083,6808289963,18600594091,50817768107,138836724395,379308985003,1036291418795,2831200807595", "code": "\nfrom functools import cache\n@cache\ndef B(n, j):\n    if not 0 <= j < 5:\n        return 0\n    if n == 0:\n        return j == 0\n    return B(n - 1, j - 1) + B(n - 1, j) + B(n - 1, j + 1)\ndef A057960(n):\n    return sum(B(n, j) for j in range(5))\nprint([A057960(n) for n in range(30)]) \n"}
{"sequence_id": "A058009", "text": "a(n) is obtained by applying the map k -> prime(k) n times, starting at n.", "sequence": "2,5,31,277,5381,87803,2269733,50728129,1559861749,64988430769,2428095424619,119543903707171,5519908106212193,248761474969923757", "code": "\nfrom sympy import prime\ndef A058009(n):\n    k = n\n    for _ in range(n):\n        k = prime(k)\n    return k \n"}
{"sequence_id": "A058031", "text": "a(n) = n^4 - 2*n^3 + 3*n^2 - 2*n + 1, the Alexander polynomial for reef and granny knots.", "sequence": "1,1,9,49,169,441,961,1849,3249,5329,8281,12321,17689,24649,33489,44521,58081,74529,94249,117649,145161,177241,214369,257049,305809,361201,423801,494209,573049,660969,758641,866761,986049,1117249,1261129,1418481,1590121", "code": " def a(n): return n**4 - 2*n**3 + 3*n**2 - 2*n + 1 \n"}
{"sequence_id": "A058039", "text": "a(n) = a(n-1) + 2*a(floor(n/2)) if n > 0, otherwise 1.", "sequence": "1,3,9,15,33,51,81,111,177,243,345,447,609,771,993,1215,1569,1923,2409,2895,3585,4275,5169,6063,7281,8499,10041,11583,13569,15555,17985,20415,23553,26691,30537,34383,39201,44019,49809,55599,62769,69939,78489,87039", "code": "\ndef a(n): return 1 if n == 0 else a(n-1) + 2*a(n//2)\nprint([a(n) for n in range(44)]) \n"}
{"sequence_id": "A058049", "text": "Numbers k such that the sum of the digits of the first k primes is a prime.", "sequence": "1,2,4,5,6,7,8,11,12,14,23,33,43,45,48,64,69,72,73,77,87,94,95,96,98,110,118,124,130,133,140,148,152,154,157,162,171,174,178,181,196,200,201,206,210,212,219,232,241,244,253,257,267,269,272,277,299,304,306", "code": "\nfrom sympy import isprime, nextprime\ndef sd(n): return sum(map(int, str(n)))\ndef aupto(limit):\n    alst, k, p, s = [], 1, 2, 2\n    while k <= limit:\n        if isprime(s): alst.append(k)\n        k += 1; p = nextprime(p); s += sd(p)\n    return alst\nprint(aupto(306)) \n"}
{"sequence_id": "A058052", "text": "Sum of the distances between the 2^n vertices in the De Bruijn Graphs on words of length n on alphabet {0,1}.", "sequence": "2,18,118,680,3620,18274,88760,418900,1933904,8775534,39277136,173843142,762388102,3317784992,14344443516,61671799608,263865053452,1124175400716,4771570406736,20185774001256,85141101913670", "code": "\nfrom numba import njit\n@njit\ndef d(x, y, n):\n  for k in range(n):\n    mask = (1 << (n-k)) - 1\n    if x & mask == (y >> k): return k\n  return n\n@njit\ndef a(n):\n  s = 0\n  for x in range(2**(n-1)):\n    for y in range(2**n):\n      s += d(x, y, n)\n  return 2*s\nprint([a(n) for n in range(1, 15)]) \n"}
{"sequence_id": "A058230", "text": "Numbers k such that the product of the lengths of the words in the name of k in American English is equal to k.", "sequence": "4,24,84672,1852200,829785600,20910597120,92215733299200,1239789303244800000,887165996513213819259682435576627200000000", "code": "\n\n\n"}
{"sequence_id": "A058233", "text": "Primes p such that p#+1 is divisible by the next prime after p.", "sequence": "2,17,1459,2999", "code": "\nfrom sympy import nextprime\nA058233_list, p, q, r = [], 2, 3, 2\nfor _ in range(10**3):\n    if (r+1) % q == 0:\n        A058233_list.append(p)\n    r *= q\n    p, q = q, nextprime(q) \n"}
{"sequence_id": "A058304", "text": "Continued fraction for Liouville's number (A012245).", "sequence": "0,9,11,99,1,10,9,999999999999,1,8,10,1,99,11,9,999999999999999999999999999999999999999999999999999999999999999999999999,1,8,11,99,1,10,8,1,999999999999,9,10,1,99,11,9", "code": "\nn,f,i,p,q,base = 1,1,0,0,1,10\nwhile i < 1000:\n    i,p,q = i+1,p*base,q*base\n    if i == f:\n        p,n = p+1,n+1\n        f = f*n\nn,a,j = 0,0,0\nwhile p%q > 0:\n    a,f,p,q = a+1,p//q,q,p%q\n    print(a-1,f)\n\n"}
{"sequence_id": "A058333", "text": "Number of 3 X 3 matrices with elements from [0,...,(n-1)] satisfying the condition that the middle element of each row or column is the difference of the two end elements (in absolute value).", "sequence": "1,16,73,208,465,896,1561,2528,3873,5680,8041,11056,14833,19488,25145,31936,40001,49488,60553,73360,88081,104896,123993,145568,169825,196976,227241,260848,298033,339040", "code": "\nfrom numba import njit\n@njit\ndef a(n):\n  count = 0\n  for i in range(n):\n    for j in range(n):\n      for k in range(n):\n        for l in range(n):\n          if abs(abs(i-j) - abs(k-l)) == abs(abs(i-k) - abs(j-l)):\n            count += 1\n  return count\nprint([a(n) for n in range(1, 39)]) \n"}
{"sequence_id": "A058369", "text": "Numbers n such that n and n^2 have same digit sum.", "sequence": "0,1,9,10,18,19,45,46,55,90,99,100,145,180,189,190,198,199,289,351,361,369,379,388,450,451,459,460,468,495,496,550,558,559,568,585,595,639,729,739,775,838,855,900,954,955,990,999,1000,1098,1099,1179,1188,1189", "code": "\ndef ds(n): return sum(map(int, str(n)))\ndef ok(n): return ds(n) == ds(n**2)\ndef aupto(nn): return [m for m in range(nn+1) if ok(m)]\nprint(aupto(1189)) \n"}
{"sequence_id": "A058411", "text": "Numbers k such that k^2 contains only digits {0,1,2}, not ending with zero.", "sequence": "1,11,101,149,1001,1011,1101,10001,10011,11001,14499,100001,100011,100101,101001,110001,316261,1000001,1000011,1000101,1010001,1010011,1100001,1100101,10000001,10000011,10000101,10001001,10001011,10001101,10010001,10100001,10100011,10110001", "code": "\nA058411_list = [i for i in range(10**6) if i % 10 and max(str(i**2)) < '3'] \n"}
{"sequence_id": "A058653", "text": "Numbers k such that sigma(phi(k)) = phi(sigma(k)-k).", "sequence": "2,18,50,1250,1980,6900,61080,1369020,2025660,2820240,4003230,4917360,8597316,15396360,15893010,28725648,41427360,53423760,148663020,209752500,212019024,222746160,232210080,281870316,298848144,314121180,322230180,385612260,390760260", "code": "\nfrom sympy import divisor_sigma as sigma, totient as phi\ndef aupto(limit):\n  for k in range(2, limit):\n    if sigma(phi(k)) == phi(sigma(k) - k): print(k, end=\", \")\naupto(10**4) \n"}
{"sequence_id": "A058665", "text": "a(n) = gcd(n+1, n-Phi(n)).", "sequence": "2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,1,1,1,1,3,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,5,1,1,1,1,1,1,1,1,1,1,3,1,1,1,5,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,7,1", "code": "\nfrom sympy import gcd, totient\ndef a(n): return gcd(n + 1, n - totient(n))\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A058796", "text": "Row 5 of A007754.", "sequence": "33,492,2055,5898,13797,28248,52587,91110,149193,233412,351663,513282,729165,1011888,1375827,1837278,2414577,3128220,4000983,5058042,6327093,7838472,9625275,11723478,14172057,17013108,20291967,24057330", "code": " for n in range(0, 40): print(33+173*n+189*n**2+81*n**3+15*n**4+n**5, end=', ') \n"}
{"sequence_id": "A058846", "text": "Numbers k such that the sum of odd primes up to k is palindromic.", "sequence": "3,5,229,257,1031,7213,11863,133853,1002073,31924583,97137589,1837875227", "code": "\nfrom sympy import primerange\ndef ispal(n): s = str(n); return s == s[::-1]\ndef afind(limit):\n  s = 0\n  for p in primerange(3, limit):\n    s += p\n    if ispal(s): print(p, end=\", \")\nafind(2*10**6) \n"}
{"sequence_id": "A058993", "text": "Numbers n such that 5^n reversed is a prime.", "sequence": "1,3,26,36,43,66,76,149,511,885,3767", "code": "\nfrom sympy import isprime\nk, m, A058993_list = 1, 5,  []\nwhile k <= 10**3:\n    if isprime(int(str(m)[::-1])):\n        A058993_list.append(k)\n    k += 1\n    m *= 5 \n"}
{"sequence_id": "A058994", "text": "Numbers n such that 7^n reversed is prime.", "sequence": "1,12,24,225,392,819,1201,1645,1775", "code": "\nfrom sympy import isprime\nk, m, A058994_list = 1, 7,  []\nwhile k <= 10**3:\n    if isprime(int(str(m)[::-1])):\n        A058994_list.append(k)\n    k += 1\n    m *= 7 \n"}
{"sequence_id": "A058995", "text": "Numbers n such that 13^n reversed is prime.", "sequence": "1,379,467,479,1325,7144,10311", "code": "\nfrom sympy import isprime\nk, m, A058995_list = 1, 13,  []\nwhile k <= 10**3:\n    if isprime(int(str(m)[::-1])):\n        A058995_list.append(k)\n    k += 1\n    m *= 13 \n"}
{"sequence_id": "A058996", "text": "Primes whose reversal is a fourth power.", "sequence": "61,61483,123031,125329,5260051,14854831,18005983,61277761,63367741,127009213,163740361,526098739,639360181,639714223,1088352997,1808902273,10007631583,10278214831,14838314173,16121301661", "code": "\nfrom sympy import isprime\nA058996_list = []\nfor i in range(10**6):\n    if i % 10:\n        p = int(str(i**4)[::-1])\n        if isprime(p):\n            A058996_list.append(p)\nA058996_list = sorted(A058996_list) \n"}
{"sequence_id": "A059000", "text": "Primes whose reversal is a fifth power.", "sequence": "23,4201,102658511,344800741,39715342481,70496383033,869910021839,998699567381,3457914828521,3487946075153,5265190686031,5786421085169,7020715917491,9432574158041,9925883645611,9987727089187", "code": "\nfrom sympy import isprime\nA059000_list = []\nfor i in range(10**6):\n    if i % 10:\n        p = int(str(i**5)[::-1])\n        if isprime(p):\n            A059000_list.append(p)\nA059000_list = sorted(A059000_list) \n"}
{"sequence_id": "A059009", "text": "Numbers having an odd number of zeros in their binary expansion.", "sequence": "0,2,5,6,8,11,13,14,17,18,20,23,24,27,29,30,32,35,37,38,41,42,44,47,49,50,52,55,56,59,61,62,65,66,68,71,72,75,77,78,80,83,85,86,89,90,92,95,96,99,101,102,105,106,108,111,113,114,116,119,120,123,125,126,128,131", "code": "\ni=j=0\nwhile j<=800:\n    if bin(i)[2:].count(\"0\")%2:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A059010", "text": "Natural numbers having an even number of nonleading zeros in their binary expansion.", "sequence": "1,3,4,7,9,10,12,15,16,19,21,22,25,26,28,31,33,34,36,39,40,43,45,46,48,51,53,54,57,58,60,63,64,67,69,70,73,74,76,79,81,82,84,87,88,91,93,94,97,98,100,103,104,107,109,110,112,115,117,118,121,122,124,127,129,130", "code": "\n\ni=1\nj=0\nwhile j<=250:\n    if bin(i)[2:].count(\"0\")%2==0:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A059012", "text": "Numbers that have an even number of 0's and 1's in their binary expansion.", "sequence": "3,9,10,12,15,33,34,36,39,40,43,45,46,48,51,53,54,57,58,60,63,129,130,132,135,136,139,141,142,144,147,149,150,153,154,156,159,160,163,165,166,169,170,172,175,177,178,180,183,184,187,189,190,192,195,197,198", "code": "\ni=0\nj=1\nwhile j<=300:\n    if bin(i)[2:].count(\"1\")%2 == 0 == bin(i)[2:].count(\"0\")%2:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A059014", "text": "Numbers that have an even number of 0's and an odd number of 1's in binary expansion.", "sequence": "1,4,7,16,19,21,22,25,26,28,31,64,67,69,70,73,74,76,79,81,82,84,87,88,91,93,94,97,98,100,103,104,107,109,110,112,115,117,118,121,122,124,127,256,259,261,262,265,266,268,271,273,274,276,279,280,283,285,286", "code": "\ni=1\nj=1\nwhile j<=100:\n    if not bin(i)[2:].count(\"0\")%2 and bin(i)[2:].count(\"1\")%2:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A059095", "text": "List consisting of the representation of n in base 3 using -1,0,1 for n=1,2,3,4,...", "sequence": "1,1,-1,1,0,1,1,1,-1,-1,1,-1,0,1,-1,1,1,0,-1,1,0,0,1,0,1,1,1,-1,1,1,0,1,1,1,1,-1,-1,-1,1,-1,-1,0,1,-1,-1,1,1,-1,0,-1,1,-1,0,0,1,-1,0,1,1,-1,1,-1,1,-1,1,0,1,-1,1,1,1,0,-1,-1,1,0,-1,0,1,0,-1,1,1,0,0,-1,1,0,0,0,1,0,0,1,1,0,1,-1,1,0,1,0,1,0,1,1,1,1,-1,-1", "code": "\ndef b3(n):\n    if n == 0: return []\n    carry, trailing = [(0, 0), (0, 1), (1, -1)][n % 3]\n    return b3(n//3 + carry) + [trailing]\nt = []\nfor n in range(50):\n    t += b3(n)\nprint(t)\n\n"}
{"sequence_id": "A059168", "text": "Primes in which digits alternately rise and fall (or vice versa); sometimes called undulating primes.", "sequence": "2,3,5,7,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,131,151,163,173,181,191,193,197,241,251,263,271,281,283,293,307,313,317,353,373,383,397,401,409,419,439,461,463,487,491", "code": "\nfrom sympy import isprime\ndef f(w,dir):\n    if dir == 1:\n        for s in w:\n            for t in range(int(s[-1])+1,10):\n                yield s+str(t)\n    else:\n        for s in w:\n            for t in range(0,int(s[-1])):\n                yield s+str(t)\nA059168_list = []\nfor l in range(5):\n    for d in '123456789':\n        x = d\n        for i in range(1,l+1):\n            x = f(x,(-1)**i)\n        A059168_list.extend([int(p) for p in x if isprime(int(p))])\n        if l > 0:\n            y = d\n            for i in range(1,l+1):\n                y = f(y,(-1)**(i+1))\n            A059168_list.extend([int(p) for p in y if isprime(int(p))]) \n"}
{"sequence_id": "A059247", "text": "Denominator of Sum_{j=1..n} d(j)/n, where d = number of divisors function (A000005).", "sequence": "1,2,3,1,1,3,7,2,9,10,11,12,13,14,1,8,17,9,19,10,3,11,23,2,25,2,27,28,29,10,31,32,11,34,35,9,37,19,13,20,41,1,43,1,45,23,1,8,49,50,51,52,53,54,5,56,19,58,59,20,61,62,3,8,65,33,67,17,69,35,71", "code": "\nfrom math import isqrt, gcd\ndef A059247(n): return n//gcd(n,(lambda m: 2*sum(n//k for k in range(1, m+1))-m*m)(isqrt(n))) \n"}
{"sequence_id": "A059260", "text": "Triangle read by rows giving coefficient T(i,j) of x^i y^j in 1/(1-y-x*y-x^2) = 1/((1+x)(1-x-y)) for (i,j) = (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), ...", "sequence": "1,0,1,1,1,1,0,2,2,1,1,2,4,3,1,0,3,6,7,4,1,1,3,9,13,11,5,1,0,4,12,22,24,16,6,1,1,4,16,34,46,40,22,7,1,0,5,20,50,80,86,62,29,8,1,1,5,25,70,130,166,148,91,37,9,1,0,6,30,95,200,296,314,239,128,46,10,1", "code": "\nfrom sympy import binomial\ndef T(n, k): return sum((-1)**(n - j)*binomial(j, k) for j in range(n + 1))\nfor n in range(13): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A059343", "text": "Triangle of nonzero coefficients of Hermite polynomials H_n(x) in increasing powers of x.", "sequence": "1,2,-2,4,-12,8,12,-48,16,120,-160,32,-120,720,-480,64,-1680,3360,-1344,128,1680,-13440,13440,-3584,256,30240,-80640,48384,-9216,512,-30240,302400,-403200,161280,-23040,1024,-665280,2217600,-1774080,506880,-56320,2048,665280,-7983360,13305600", "code": "\nfrom sympy import hermite, Poly, Symbol\nx = Symbol('x')\ndef a(n):\n    return Poly(hermite(n, x), x).coeffs()[::-1]\nfor n in range(21): print(a(n)) \n"}
{"sequence_id": "A059378", "text": "Jordan function J_5(n).", "sequence": "1,31,242,992,3124,7502,16806,31744,58806,96844,161050,240064,371292,520986,756008,1015808,1419856,1822986,2476098,3099008,4067052,4992550,6436342,7682048,9762500,11510052,14289858,16671552,20511148", "code": "\nfrom sympy import divisors, mobius\ndef a(n):\n    return sum(d**5 * mobius(n // d) for d in divisors(n))\n\n"}
{"sequence_id": "A059402", "text": "Numbers with more than one prime factor that do not end in 0 and contain as substrings every maximal prime power dividing them.", "sequence": "1197,14673,83731,129717,167835,322794,429635,831328,1127125,1183497,1184128,1319825,1344837,1371294,1724786,1731195,1943795,2597175,2971137,2993715,3161907,3181437,3719193,4609731,4913928,5037365,5912739,5981125,6193563", "code": "\nfrom sympy import factorint\nA059402_list = [n for n in range(2,10**6) if n % 10 and len(factorint(n)) > 1 and all(str(a**b) in str(n) for a, b in factorint(n).items())] \n"}
{"sequence_id": "A059539", "text": "Beatty sequence for 3^(1/3).", "sequence": "1,2,4,5,7,8,10,11,12,14,15,17,18,20,21,23,24,25,27,28,30,31,33,34,36,37,38,40,41,43,44,46,47,49,50,51,53,54,56,57,59,60,62,63,64,66,67,69,70,72,73,74,76,77,79,80,82,83,85,86,87,89,90,92,93,95,96,98,99,100", "code": "\nfrom sympy import integer_nthroot\ndef A059539(n): return integer_nthroot(3*n**3,3)[0] \n"}
{"sequence_id": "A059706", "text": "Smallest prime p such that p^n reversed is a prime.", "sequence": "2,19,5,2,2,107,2,23,131,2,17,7,71,41,47,53,2,157,79,641,47,743,109,2,19,5,1201,193,541,47,643,1231,3023,173,113,5,2,101,67,71,349,353,5,53,2,709,163,677,4337,1327,919,769,317,23,2,503,1009,197,167,1663,23,37", "code": "\nfrom sympy import isprime, nextprime\ndef ok(p, n): return isprime(int(str(p**n)[::-1]))\ndef a(n):\n  p = 2\n  while not ok(p, n): p = nextprime(p)\n  return p\nprint([a(n) for n in range(1, 63)]) \n"}
{"sequence_id": "A059729", "text": "Carryless squares n X n base 10.", "sequence": "0,1,4,9,6,5,6,9,4,1,100,121,144,169,186,105,126,149,164,181,400,441,484,429,466,405,446,489,424,461,900,961,924,989,946,905,966,929,984,941,600,681,664,649,626,605,686,669,644,621,500,501,504,509,506,505", "code": "\ndef A059729(n):\n    s = [int(d) for d in str(n)]\n    l = len(s)\n    t = [0]*(2*l-1)\n    for i in range(l):\n        for j in range(l):\n            t[i+j] = (t[i+j] + s[i]*s[j]) % 10\n    return int(\"\".join(str(d) for d in t)) \n"}
{"sequence_id": "A059758", "text": "Undulating palindromic primes: numbers that are prime, palindromic in base 10, and the digits alternate: ababab... with a != b.", "sequence": "101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,18181,32323,35353,72727,74747,78787,94949,95959,1212121,1616161,323232323,383838383,727272727,919191919,929292929,979797979,989898989", "code": "\nfrom sympy import isprime\nA059758_list = []\nfor l in range(1,300):\n    for a in '1379':\n        for b in '0123456789':\n            if a != b:\n                p = int((a+b)*l+a)\n                if isprime(p):\n                    A059758_list.append(p) \n"}
{"sequence_id": "A059833", "text": "\"Madonna's Sequence\": add 1 (mod 10) to each digit of Pi.", "sequence": "4,2,5,2,6,0,3,7,6,4,6,9,0,8,0,4,3,4,9,5,7,3,7,5,4,4,9,4,3,8,0,6,1,3,9,9,5,2,0,8,2,7,0,4,0,0,4,8,6,2,1,6,9,3,1,0,8,5,0,5,5,6,0,3,4,1,8,9,2,7,5,1,7,3,9,7,3,1,9,0,0,9,7,3,9,1,4,5,9,3,6,4,5,3,2,2,8,1,7,8,0,9,3,2,5", "code": "\nfrom sympy import S\ndef alist(nn): return [4]+[(1+int(d))%10 for d in str(S.Pi.n(nn+2))[2:nn+1]]\nprint(alist(105)) \n"}
{"sequence_id": "A059868", "text": "There exist no palindromic pentagonal numbers of length a(n).", "sequence": "3,9,11,12,24", "code": "\ndef ispal(n): s = str(n); return s == s[::-1]\ndef penpals(limit):\n  for k in range(limit+1):\n    if ispal(k*(3*k-1)//2): yield k*(3*k-1)//2\ndef aupto(limit):\n  lengths = set(range(1, limit+1))\n  for p in penpals(10**limit):\n    lp, minlen = len(str(p)), min(lengths)\n    for li in list(lengths):\n      if li < lp: print(li, \"in A059868\"); lengths.discard(li)\n    if lp in lengths: lengths.discard(lp); print(\"... discarding\", lp)\n    if len(lengths) == 0: return\naupto(15) \n"}
{"sequence_id": "A059892", "text": "a(n) = |{m : multiplicative order of 10 mod m is equal to n}|.", "sequence": "3,3,5,6,9,53,9,36,12,33,9,186,21,33,111,144,9,564,3,330,239,273,3,1756,84,165,76,714,93,16167,21,5952,111,177,363,4288,21,15,99,5724,45,48807,45,4314,1140,183,9,14192,36,2940,495,1338,45,11572,747,11484", "code": "\nfrom sympy import divisors, mobius, divisor_count\ndef a(n): return sum(mobius(n//d)*divisor_count(10**d - 1) for d in divisors(n)) \n"}
{"sequence_id": "A059893", "text": "Reverse the order of all but the most significant bit in binary expansion of n: if n = 1ab..yz then a(n) = 1zy..ba.", "sequence": "1,2,3,4,6,5,7,8,12,10,14,9,13,11,15,16,24,20,28,18,26,22,30,17,25,21,29,19,27,23,31,32,48,40,56,36,52,44,60,34,50,42,58,38,54,46,62,33,49,41,57,37,53,45,61,35,51,43,59,39,55,47,63,64,96,80,112,72,104,88,120", "code": "\ndef a(n): return int('1' + bin(n)[3:][::-1], 2)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A059894", "text": "Complement and reverse the order of all but the most significant bit in binary expansion of n. n = 1ab..yz -> 1ZY..BA = a(n), where A = 1-a, B = 1-b, ... .", "sequence": "1,3,2,7,5,6,4,15,11,13,9,14,10,12,8,31,23,27,19,29,21,25,17,30,22,26,18,28,20,24,16,63,47,55,39,59,43,51,35,61,45,53,37,57,41,49,33,62,46,54,38,58,42,50,34,60,44,52,36,56,40,48,32,127,95,111,79,119,87,103,71", "code": "\ndef a(n): return int('1' + ''.join('0' if i=='1' else '1' for i in bin(n)[3:])[::-1], 2)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A059905", "text": "Index of first half of decomposition of integers into pairs based on A000695.", "sequence": "0,1,0,1,2,3,2,3,0,1,0,1,2,3,2,3,4,5,4,5,6,7,6,7,4,5,4,5,6,7,6,7,0,1,0,1,2,3,2,3,0,1,0,1,2,3,2,3,4,5,4,5,6,7,6,7,4,5,4,5,6,7,6,7,8,9,8,9,10,11,10,11,8,9,8,9,10,11,10,11,12,13,12,13,14,15,14,15,12,13,12,13,14", "code": "\ndef a(n): return sum([(n>>2*i&1)<<i for i in range(len(bin(n)[2:])//2 + 1)])\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A059906", "text": "Index of second half of decomposition of integers into pairs based on A000695.", "sequence": "0,0,1,1,0,0,1,1,2,2,3,3,2,2,3,3,0,0,1,1,0,0,1,1,2,2,3,3,2,2,3,3,4,4,5,5,4,4,5,5,6,6,7,7,6,6,7,7,4,4,5,5,4,4,5,5,6,6,7,7,6,6,7,7,0,0,1,1,0,0,1,1,2,2,3,3,2,2,3,3,0,0,1,1,0,0,1,1,2,2,3,3,2,2,3,3,4,4,5,5,4,4,5,5,6", "code": "\ndef a(n):\n    x=[int(t) for t in list(bin(n)[2:])[::-1]]\n    return sum(x[2*i + 1]*2**i for i in range(int(len(x)//2)))\nprint([a(n) for n in range(105)]) \n"}
{"sequence_id": "A059929", "text": "a(n) = Fibonacci(n)*Fibonacci(n+2).", "sequence": "0,2,3,10,24,65,168,442,1155,3026,7920,20737,54288,142130,372099,974170,2550408,6677057,17480760,45765226,119814915,313679522,821223648,2149991425,5628750624,14736260450,38580030723,101003831722,264431464440,692290561601", "code": "\nfrom sympy import fibonacci\n[fibonacci(n)*fibonacci(n+2) for n in range(30)] \n"}
{"sequence_id": "A059934", "text": "Third step in Goodstein sequences, i.e., g(5) if g(2)=n: write g(4)=A057650(n) in hereditary representation base 4, bump to base 5, then subtract 1 to produce g(5).", "sequence": "0,2,60,467,3125,3127,6310,9842,15625,15627,15685,16092,18750,18752,53793641718868912174424175024032593379100060", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef bump(n,b):\n  s=digits(n,b)[1:]\n  l=len(s)\n  return sum(s[i]*(b+1)**bump(l-i-1,b) for i in range(l) if s[i])\ndef A059934(n):\n  for i in range(2,5):\n    n=bump(n,i)-1\n  return n \n"}
{"sequence_id": "A059935", "text": "Fourth step in Goodstein sequences, i.e., g(6) if g(2)=n: write g(5)=A059934(n) in hereditary representation base 5, bump to base 6, then subtract 1 to produce g(6).", "sequence": "1,83,775,46655,46657,93395,140743,279935,279937,280019,280711,326591,326593,19916489515870532960258562190639398471599239042185934648024761145811", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef bump(n,b):\n  s=digits(n,b)[1:]\n  l=len(s)\n  return sum(s[i]*(b+1)**bump(l-i-1,b) for i in range(l) if s[i])\ndef A059935(n):\n  for i in range(2,6):\n    n=bump(n,i)-1\n  return n \n"}
{"sequence_id": "A059936", "text": "Fifth step in Goodstein sequences, i.e., g(7) if g(2)=n: write g(6)=A059935(n) in hereditary representation base 6, bump to base 7, then subtract 1 to produce g(7).", "sequence": "0,109,1197,98039,823543,1647195,2471826,4215754,5764801,5764910,5765998,5862840,6588344,5103708485122940631839901111036829791435007685667303872450435153015345686896530517814322070729709", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef bump(n,b):\n  s=digits(n,b)[1:]\n  l=len(s)\n  return sum(s[i]*(b+1)**bump(l-i-1,b) for i in range(l) if s[i])\ndef A059936(n):\n  for i in range(2,7):\n    n=bump(n,i)-1\n  return n \n"}
{"sequence_id": "A059953", "text": "Ordering of a deck of 52 cards after an out-shuffle.", "sequence": "1,27,2,28,3,29,4,30,5,31,6,32,7,33,8,34,9,35,10,36,11,37,12,38,13,39,14,40,15,41,16,42,17,43,18,44,19,45,20,46,21,47,22,48,23,49,24,50,25,51,26,52", "code": "\ndef out_shuffle(deck):\n  shuffle = [i for i in range(len(deck))]\n  shuffle[0::2] = deck[:(len(deck)+1)//2]\n  shuffle[1::2] = deck[(len(deck)+1)//2:]\n  return shuffle\nprint(out_shuffle(range(1, 53))) \n"}
{"sequence_id": "A060060", "text": "Third column of triangle A060058.", "sequence": "5,61,331,1211,3486,8526,18522,36762,67947,118547,197197,315133,486668,729708,1066308,1523268,2132769,2933049,3969119,5293519,6967114,9059930,11652030,14834430,18710055,23394735", "code": "\nimport math\ndef C(n,r):\n....f=math.factorial\n....return f(n)/f(r)/f(n-r)\ndef A060060(n):\n....return C(n+4, 4)*(20*n**2+88*n+75)/15 \n"}
{"sequence_id": "A060061", "text": "Fourth column of triangle A060058.", "sequence": "61,1385,12284,68060,281210,948002,2749340,7097948,16700255,36419955,74551048,144631240,267951892,476948260,819683560,1365672424,2213323585,3499318141,5410278500,8197124100", "code": "\nimport math\ndef C(n, r):\n....f=math.factorial\n....return f(n)/f(r)/f(n-r)\ndef A060061(n):\n....return (C(n+6,6)*(280*n**3+2436*n**2+5906*n+3843))/63 \n"}
{"sequence_id": "A060165", "text": "Number of orbits of length n under the map whose periodic points are counted by A000984.", "sequence": "2,2,6,16,50,150,490,1600,5400,18450,64130,225264,800046,2865226,10341150,37566720,137270954,504171432,1860277042,6892317200,25631327190,95640829922,357975249026,1343650040256,5056424257500,19073789328750,72108867614796", "code": "\nfrom sympy import mobius, binomial, divisors\ndef a(n): return sum(mobius(n//d) * binomial(2*d, d) for d in divisors(n))//n\nprint([a(n) for n in range(1, 31)])  \n"}
{"sequence_id": "A060175", "text": "Table T(n,k) by antidiagonals of exponent of largest power of k-th prime which divides n.", "sequence": "0,0,1,0,0,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0", "code": "\nfrom sympy import prime\ndef a(n, k):\n    p=prime(n)\n    i=z=0\n    while p**i<=k:\n        if k%(p**i)==0: z=i\n        i+=1\n    return z\nfor n in range(1, 10): print([a(n - k + 1, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A060199", "text": "Number of primes between n^3 and (n+1)^3.", "sequence": "0,4,5,9,12,17,21,29,32,39,49,52,58,73,76,88,92,109,117,125,140,151,159,176,188,199,207,233,247,254,267,284,305,320,346,338,373,385,416,418,437,458,481,504,517,551,555,583,599,636,648,678,686,733,723,753,810", "code": "\nfrom sympy import primepi\ndef a(n): return primepi((n+1)**3) - primepi(n**3)\nprint([a(n) for n in range(57)]) \n"}
{"sequence_id": "A060212", "text": "Primes q such that 6*q-1 and 6*q+1 are twin primes. Proper subset of A002822.", "sequence": "2,3,5,7,17,23,47,103,107,137,283,313,347,373,397,443,467,577,593,653,773,787,907,1033,1117,1423,1433,1613,1823,2027,2063,2137,2153,2203,2287,2293,2333,2347,2677,2903,3257,3307,3407,3413,3593,3623,3673,3923", "code": " from sympy import *; print([p for p in primerange(2,9999) if isprime(6*p-1) and isprime(6*p+1)]) \n"}
{"sequence_id": "A060216", "text": "Number of orbits of length n under the full 13-shift (whose periodic points are counted by A001022).", "sequence": "13,78,728,7098,74256,804076,8964072,101962770,1178277464,13785812040,162923672184,1941506688940,23298085122480,281241165925044,3412392867581152,41588538022965570", "code": "\nfrom sympy import divisors, mobius\nprint([sum(mobius(d) * 13**(n//d) for d in divisors(n))//n for n in range(1, 21)]) \n"}
{"sequence_id": "A060358", "text": "a(n) = largest prime < lcm(1..n).", "sequence": "5,11,59,59,419,839,2503,2503,27701,27701,360337,360337,360337,720703,12252197,12252197,232792559,232792559,232792559,232792559,5354228879,5354228879,26771144371,26771144371,80313433159,80313433159,2329089562799,2329089562799", "code": "\nfrom sympy import prevprime, lcm\ndef A060358(n):\n    return prevprime(lcm(range(1,n+1))) \n"}
{"sequence_id": "A060382", "text": "In base n, a(n) is the smallest number m that leads to a palindrome-free sequence, using the following process: start with m; reverse the digits and add it to m, repeat. Stop if you reach a palindrome.", "sequence": "22,103,290,708,1079,2656,1021,593,196,1011,237,2701,361,447,413,3297,519,341,379,711,461,505,551,1022,649,701,755,811,869,929,991,1055,1799,1922,1259,1331,1405,1481,1559,1639,1595,1762,1891,1934,2069,2161", "code": "\ndef rev(n,base):\n....m = 0\n....while n > 0:\n........n, m = n//base, m*base+n%base\n....return m\nn, a, steps = 2, 3, 0\nwhile n <= 20000:\n....aa = a\n....ra = rev(a,n)\n....while aa != ra and steps < 1000:\n........aa = aa+ra\n........ra, steps = rev(aa,n), steps+1\n....if aa == ra:\n........a, aa, steps = a+1, a+1, 0\n....if steps == 1000:\n........print(n,a)\n........n, a, steps = n+1, n+2, 0 \n"}
{"sequence_id": "A060445", "text": "\"Dropping time\" in 3x+1 problem starting at 2n+1 (number of steps to reach a lower number than starting value). Also called glide(2n+1).", "sequence": "0,6,3,11,3,8,3,11,3,6,3,8,3,96,3,91,3,6,3,13,3,8,3,88,3,6,3,8,3,11,3,88,3,6,3,83,3,8,3,13,3,6,3,8,3,73,3,13,3,6,3,68,3,8,3,50,3,6,3,8,3,13,3,24,3,6,3,11,3,8,3,11,3,6,3,8,3,65,3,34,3,6,3,47,3,8,3,13,3,6,3,8,3", "code": "\ndef a(n):\n    if n<1: return 0\n    n=2*n + 1\n    N=n\n    x=0\n    while True:\n        if n%2==0: n//=2\n        else: n = 3*n + 1\n        x+=1\n        if n<N: break\n    return x\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A060474", "text": "a(n) = denominator of phi(n)/(n+1), where phi(n) is Euler's phi, A000010.", "sequence": "2,3,2,5,3,7,4,9,5,11,6,13,7,5,2,17,9,19,10,21,11,23,12,25,13,9,14,29,15,31,16,33,17,35,3,37,19,13,5,41,21,43,22,9,23,47,24,49,25,51,13,53,27,55,7,19,29,59,30,61,31,21,16,65,11,67,34,69,35,71,36,73,37,25,19,77,13,79,40", "code": "\nfrom sympy import totient, gcd\ndef A060474(n): return (n+1)//gcd(n+1,totient(n)) \n"}
{"sequence_id": "A060594", "text": "Number of solutions to x^2 == 1 (mod n), that is, square roots of unity modulo n.", "sequence": "1,1,2,2,2,2,2,4,2,2,2,4,2,2,4,4,2,2,2,4,4,2,2,8,2,2,2,4,2,4,2,4,4,2,4,4,2,2,4,8,2,4,2,4,4,2,2,8,2,2,4,4,2,2,4,8,4,2,2,8,2,2,4,4,4,4,2,4,4,4,2,8,2,2,4,4,4,4,2,8,2,2,2,8,4,2,4,8,2,4,4,4,4,2,4,8,2,2,4,4,2,4,2", "code": "\nfrom sympy import primefactors\ndef a007814(n): return 1 + bin(n - 1).count('1') - bin(n).count('1')\ndef a(n):\n    if n%2==0:\n        A=a007814(n)\n        b=2**A\n        c=n//b\n        return min(b//2, 4)*a(c)\n    else: return 2**len(primefactors(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A060632", "text": "a(n) = 2^wt(floor(n/2)) (i.e., 2^A000120(floor(n/2)), or A001316(floor(n/2))).", "sequence": "1,1,2,2,2,2,4,4,2,2,4,4,4,4,8,8,2,2,4,4,4,4,8,8,4,4,8,8,8,8,16,16,2,2,4,4,4,4,8,8,4,4,8,8,8,8,16,16,4,4,8,8,8,8,16,16,8,8,16,16,16,16,32,32,2,2,4,4,4,4,8,8,4,4,8,8,8,8,16,16,4,4,8,8,8,8,16,16,8,8,16,16,16,16,32", "code": "\ndef A060632(n):\n    return 2**bin(n/2)[2:].count(\"1\") \n"}
{"sequence_id": "A060693", "text": "Triangle (0 <= k <= n) read by rows: T(n, k) is the number of Schr\u00f6der paths from (0,0) to (2n,0) having k peaks.", "sequence": "1,1,1,2,3,1,5,10,6,1,14,35,30,10,1,42,126,140,70,15,1,132,462,630,420,140,21,1,429,1716,2772,2310,1050,252,28,1,1430,6435,12012,12012,6930,2310,420,36,1,4862,24310,51480,60060,42042,18018,4620,660,45,1,16796", "code": "\nfrom sympy import binomial\ndef T(n, k): return binomial(n, k) * binomial(2 * n - k, n) / (n - k + 1)\nfor n in range(11): print([T(n, k) for k in range(n + 1)])  \n"}
{"sequence_id": "A060736", "text": "Array of square numbers read by antidiagonals in up direction.", "sequence": "1,2,4,5,3,9,10,6,8,16,17,11,7,15,25,26,18,12,14,24,36,37,27,19,13,23,35,49,50,38,28,20,22,34,48,64,65,51,39,29,21,33,47,63,81,82,66,52,40,30,32,46,62,80,100", "code": " \nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nif i>=j:\n   result=i**2-j+1\nelse:\n   result=(j-1)**2+i\n"}
{"sequence_id": "A060750", "text": "Step at which card n appears on top of deck for first time in Guy's shuffling problem A035485.", "sequence": "3,1,2,8,5,4,78,37,6,11,28,12,349,13,383,10,18,16,29,17,33,210,14,133,32,60,19,106,57,20,48,26,21,35,97,217,25,22,13932,863,205,54,30452,306,2591,40,44,39,49,38,51,47,30,252992198,2253,101,112,246,402,119,53,139", "code": "\ndef a(n):\n  deck = list(range(1, 2*maxcards+1))\n  for step in range(1, maxcards+1):\n    first, next = deck[:step], deck[step:2*step]\n    deck[0:2*step:2] = next\n    deck[1:2*step:2] = first\n    if deck[0] == n: return step\n  return '>' + str(step)\nmaxcards = 31000\nprint([a(n) for n in range(1, 54)]) \n"}
{"sequence_id": "A060792", "text": "Numbers that are palindromic in bases 2 and 3.", "sequence": "0,1,6643,1422773,5415589,90396755477,381920985378904469,1922624336133018996235,2004595370006815987563563,8022581057533823761829436662099,392629621582222667733213907054116073,32456836304775204439912231201966254787,428027336071597254024922793107218595973", "code": "\nfrom itertools import chain\nfrom gmpy2 import digits, mpz\nA060792 = [int(n,2) for n in chain(map(lambda x:bin(x)[2:]+bin(x)[2:][::-1],range(1,2**16)),map(lambda x:bin(x)[2:]+bin(x)[2:][-2::-1], range(1,2**16))) if mpz(int(n,2)).digits(3) == mpz(int(n,2)).digits(3)[::-1]] \n"}
{"sequence_id": "A060821", "text": "Triangle T(n,k) read by rows giving coefficients of Hermite polynomial of order n (n >= 0, 0 <= k <= n).", "sequence": "1,0,2,-2,0,4,0,-12,0,8,12,0,-48,0,16,0,120,0,-160,0,32,-120,0,720,0,-480,0,64,0,-1680,0,3360,0,-1344,0,128,1680,0,-13440,0,13440,0,-3584,0,256,0,30240,0,-80640,0,48384,0,-9216,0,512,-30240,0,302400,0,-403200,0,161280,0,-23040,0,1024", "code": "\nfrom sympy import hermite, Poly, symbols\nx = symbols('x')\ndef a(n): return Poly(hermite(n, x), x).all_coeffs()[::-1]\nfor n in range(21): print(a(n)) \n"}
{"sequence_id": "A060857", "text": "Describe all the numbers already used (sorted into increasing order - not splitting numbers up into their digits).", "sequence": "1,11,31,4113,612314,8112332416,1113253342618,131528344153628111,1617210364354648211113,181921239445661758110311213116,2211121431146586276829210411112313216118", "code": "\ndef summarize_lst(lst):\n  ans = []\n  for d in sorted(set(lst)): ans += [lst.count(d), d]\n  return ans\ndef aupton(nn):\n  alst, arunninglst = [1], [1]\n  for n in range(nn):\n    nxt_lst = summarize_lst(arunninglst)\n    arunninglst += nxt_lst\n    alst.append(int(\"\".join(map(str, nxt_lst))))\n  return alst\nprint(aupton(10)) \n"}
{"sequence_id": "A060958", "text": "Gregorian Easter dates, starting after 2000-04-23, a(2000) = 54.", "sequence": "46,31,51,42,27,47,39,23,43,35,55,39,31,51,36,27,47,32,52,43,35,48,40,31,51,36,28,47,32,52,44,28,48,40,25,44,36,56,41,32,52,37,29,48,40,25,45,36,49,41,33,52,37,29,49,33,53,45,30,49,41,26,46,37,29,42", "code": "\nfrom dateutil.easter import *\ndef a(n): return (easter(n).month-3)*31 + easter(n).day\nprint([a(n) for n in range(2001, 2067)]) \n"}
{"sequence_id": "A060984", "text": "a(1) = 1; a(n+1) = a(n) + (largest square <= a(n)).", "sequence": "1,2,3,4,8,12,21,37,73,137,258,514,998,1959,3895,7739,15308,30437,60713,121229,242333,484397,967422,1933711,3865811,7730967,15459367,30912128,61814609,123625653,247235577,494448306,988888002,1977738918,3955408759,7910812423", "code": "\nfrom sympy import integer_nthroot\nA060984_list = [1]\nfor i in range(10**3): A060984_list.append(A060984_list[-1]+integer_nthroot(A060984_list[-1],2)[0]**2) \n"}
{"sequence_id": "A060984", "text": "a(1) = 1; a(n+1) = a(n) + (largest square <= a(n)).", "sequence": "1,2,3,4,8,12,21,37,73,137,258,514,998,1959,3895,7739,15308,30437,60713,121229,242333,484397,967422,1933711,3865811,7730967,15459367,30912128,61814609,123625653,247235577,494448306,988888002,1977738918,3955408759,7910812423", "code": "\nfrom math import isqrt\nfrom itertools import accumulate\ndef f(an, _): return an + isqrt(an)**2\nprint(list(accumulate([1]*36, f))) \n"}
{"sequence_id": "A061026", "text": "Smallest number m such that phi(m) is divisible by n, where phi = Euler totient function A000010.", "sequence": "1,3,7,5,11,7,29,15,19,11,23,13,53,29,31,17,103,19,191,25,43,23,47,35,101,53,81,29,59,31,311,51,67,103,71,37,149,191,79,41,83,43,173,69,181,47,283,65,197,101,103,53,107,81,121,87,229,59,709,61,367,311,127,85", "code": "\nfrom sympy import totient as phi\ndef a(n):\n  k = 1\n  while phi(k)%n != 0: k += 1\n  return k\nprint([a(n) for n in range(1, 65)]) \n"}
{"sequence_id": "A061040", "text": "Denominator of 1/9 - 1/n^2.", "sequence": "1,144,225,12,441,576,81,900,1089,48,1521,1764,75,2304,2601,324,3249,3600,147,4356,4761,64,5625,6084,729,7056,7569,100,8649,9216,363,10404,11025,1296,12321,12996,507,14400,15129,588,16641,17424", "code": "\nfrom math import gcd\ndef A061040(n): return 9*n**2//gcd(n**2-9,9*n**2) \n"}
{"sequence_id": "A061051", "text": "Smallest square of the form [n digits][same n digits][further digits].", "sequence": "0,225,40401,2042041,317231721,16198161984,3921203921209,400000040000001,23391004233910041,1100298301100298304,141162631214116263129,1322314049613223140496,3171326702963171326702969,107786983188610778698318864,29726516052320297265160523209,1003781781031081003781781031081", "code": "\nfrom sympy import integer_nthroot\ndef A061051(n):\n    if n == 0:\n        return 0\n    nstart = 10**(n-1)\n    nend = 10*nstart\n    for i in range(nstart,nend):\n        k = int(str(i)*2)\n        if integer_nthroot(k,2)[1]:\n            return k\n    for i in range(nstart,nend):\n        si = str(i)*2\n        for sj in '014569':\n            k = int(si+sj)\n            if integer_nthroot(k,2)[1]:\n                return k \n"}
{"sequence_id": "A061120", "text": "Compute sum of divisors of the prime(n+1)-prime(n)-1 composite numbers between two consecutive primes; choose the smallest.", "sequence": "7,12,13,28,24,39,32,31,72,48,56,96,72,57,72,168,84,96,195,96,121,108,112,156,216,162,280,152,133,176,160,288,168,372,192,192,252,183,240,546,216,508,294,468,240,252,342,560,384,288,744,280,288,304,324,720", "code": "\nfrom sympy import prime, divisor_sigma as sigma\ndef a(n): return min(sigma(c) for c in range(prime(n)+1, prime(n+1)))\nprint([a(n) for n in range(2, 58)]) \n"}
{"sequence_id": "A061141", "text": "Compute sum of divisors of the prime(n+1)-prime(n)-1 composite numbers between two consecutive primes; choose the largest.", "sequence": "7,12,18,28,31,39,42,60,72,91,90,96,84,124,120,168,144,144,195,168,186,224,252,217,216,210,280,248,360,255,336,288,403,372,392,378,294,480,372,546,384,508,399,468,576,600,504,560,450,546,744,504,728,588,720", "code": "\nfrom sympy import prime, divisor_sigma as sigma\ndef a(n): return max(sigma(c) for c in range(prime(n)+1, prime(n+1)))\nprint([a(n) for n in range(2, 57)]) \n"}
{"sequence_id": "A061168", "text": "Partial sums of floor(log_2(k)) (= A000523(k)).", "sequence": "0,1,2,4,6,8,10,13,16,19,22,25,28,31,34,38,42,46,50,54,58,62,66,70,74,78,82,86,90,94,98,103,108,113,118,123,128,133,138,143,148,153,158,163,168,173,178,183,188,193,198,203,208,213,218,223,228,233,238,243,248", "code": "\ndef A061168(n):\n    s, i, z = -n , n, 1\n    while 0 <= i: s += i; i -= z; z += z\n    return s\nprint([A061168(n) for n in range(1, 62)]) \n"}
{"sequence_id": "A061205", "text": "a(n) = n times R(n) where R(n) (A004086) is the digit reversal of n.", "sequence": "0,1,4,9,16,25,36,49,64,81,10,121,252,403,574,765,976,1207,1458,1729,40,252,484,736,1008,1300,1612,1944,2296,2668,90,403,736,1089,1462,1855,2268,2701,3154,3627,160,574,1008,1462,1936,2430,2944,3478,4032,4606", "code": "\ndef A061205(n):\n    return n*A004086(n) \n"}
{"sequence_id": "A061242", "text": "Primes of the form 9*k - 1.", "sequence": "17,53,71,89,107,179,197,233,251,269,359,431,449,467,503,521,557,593,647,683,701,719,773,809,827,863,881,953,971,1061,1097,1151,1187,1223,1259,1277,1367,1439,1493,1511,1583,1601,1619,1637,1709,1871,1889,1907", "code": "\nfrom sympy import prime\nA061242 = [p for p in (prime(n) for n in range(1,10**3)) if not (p+1) % 18]\n\n"}
{"sequence_id": "A061246", "text": "Prime numbers with every digit a perfect square, i.e., consisting of only digits 0, 1, 4, 9.", "sequence": "11,19,41,101,109,149,191,199,401,409,419,449,491,499,911,919,941,991,1009,1019,1049,1091,1109,1409,1499,1901,1949,1999,4001,4019,4049,4091,4099,4111,4409,4441,4909,4919,4999,9001,9011,9041,9049,9091,9109,9199", "code": "\nfrom itertools import product\nfrom sympy import isprime\nA061246_list = [int(i+''.join(j)+k) for l in range(10) for i in '149' for j in product('0149',repeat=l) for k in '19' if isprime(int(i+''.join(j)+k))] \n"}
{"sequence_id": "A061280", "text": "Smallest base b >= 2 for which b^n contains n as a substring.", "sequence": "10,5,7,7,5,2,3,7,3,2,11,7,6,25,7,11,4,8,5,7,6,6,6,3,4,9,17,3,6,13,8,5,8,5,2,2,2,8,6,6,5,4,7,2,6,9,8,6,2,4,2,8,6,5,5,5,3,8,4,2,3,3,6,5,6,12,2,6,3,5,3,2,2,6,5,6,3,3,4,3,4,2,3,4,2,4,3,7,2,8,8,4,2,6,3,4,7,6,7,7", "code": "\ndef a(n):\n    b, s = 2, str(n)\n    while s not in str(b**n): b += 1\n    return b\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A061286", "text": "Smallest integer for which the number of divisors is the n-th prime.", "sequence": "2,4,16,64,1024,4096,65536,262144,4194304,268435456,1073741824,68719476736,1099511627776,4398046511104,70368744177664,4503599627370496,288230376151711744,1152921504606846976", "code": "\nfrom sympy import isprime, divisor_count as tau\n[2] + [2**(2*n) for n in range(1, 33) if isprime(tau(2**(2*n)))] \n"}
{"sequence_id": "A061308", "text": "Smaller of two consecutive primes whose sum is a cube.", "sequence": "3,107,10973,37039,186619,2125757,2634011,5323949,5470519,6406447,7443463,8001491,12967153,20353771,27435973,29659499,57395627,66325487,99588343,104792291,129847021,134793059,153090997,172974199,186623993,271669247,283831771,343064479", "code": "\nfrom __future__ import division\nfrom sympy import prevprime, nextprime\nA061308_list = [prevprime(n**3//2) for n in range(2,10**4) if prevprime(n**3//2)+nextprime(n**3//2) == n**3] \n"}
{"sequence_id": "A061341", "text": "Numbers not ending in 0 whose cubes are concatenations of other cubes.", "sequence": "22,303,1006,2272,3003,6001,6006,10006,30003,50015,50024,60001,60006,60025,100006,120015,121925,150005,150012,240005,300003,466085,500015,500024,600001,600006,600025,600075,1000006,1200015,1500005,1500012,1500015,2400005,2500006", "code": "\nfrom sympy import integer_nthroot\ndef iscube(n): return integer_nthroot(n, 3)[1]\ndef ok3(n, c):\n    if n%10 == 9 or (c == 1 and n%10 == 0): return False\n    if c > 1 and iscube(n): return True\n    d = str(n)\n    for i in range(1, len(d)):\n        if iscube(int(d[:i])) and ok3(int(d[i:]), c+1): return True\n    return False\nprint([r for r in range(61000) if ok3(r**3, 1)]) \n"}
{"sequence_id": "A061358", "text": "Number of ways of writing n = p+q with p, q primes and p >= q.", "sequence": "0,0,0,0,1,1,1,1,1,1,2,0,1,1,2,1,2,0,2,1,2,1,3,0,3,1,3,0,2,0,3,1,2,1,4,0,4,0,2,1,3,0,4,1,3,1,4,0,5,1,4,0,3,0,5,1,3,0,4,0,6,1,3,1,5,0,6,0,2,1,5,0,6,1,5,1,5,0,7,0,4,1,5,0,8,1,5,0,4,0,9,1,4,0,5,0,7,0,3,1,6,0,8,1,5,1", "code": "\nfrom sympy import primerange, isprime, floor\ndef a(n):\n    s=0\n    for q in primerange(2, n//2 + 1): s+=isprime(n - q)\n    return s\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A061395", "text": "Let p be the largest prime factor of n; if p is the k-th prime then set a(n) = k; a(1) = 0 by convention.", "sequence": "0,1,2,1,3,2,4,1,2,3,5,2,6,4,3,1,7,2,8,3,4,5,9,2,3,6,2,4,10,3,11,1,5,7,4,2,12,8,6,3,13,4,14,5,3,9,15,2,4,3,7,6,16,2,5,4,8,10,17,3,18,11,4,1,6,5,19,7,9,4,20,2,21,12,3,8,5,6,22,3,2,13,23,4,7,14,10,5,24,3,6,9,11,15", "code": "\nfrom sympy import primepi, primefactors\ndef a(n): return 0 if n==1 else primepi(primefactors(n)[-1])\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A061417", "text": "Number of permutations up to cyclic rotations; permutation siteswap necklaces.", "sequence": "1,2,4,10,28,136,726,5100,40362,363288,3628810,39921044,479001612,6227066928,87178295296,1307675013928,20922789888016,355687438476444,6402373705728018,121645100594641896,2432902008177690360", "code": "\nfrom sympy import divisors, factorial, totient\ndef a(n):\n    return sum(totient(n//d)*(n//d)**d*factorial(d) for d in divisors(n))//n\nprint([a(n) for n in range(1, 22)]) \n"}
{"sequence_id": "A061428", "text": "Geometric mean of the digits = 4. In other words the product of the digits is = 4^k where k is the number of digits.", "sequence": "4,28,44,82,188,248,284,428,444,482,818,824,842,881,1488,1848,1884,2288,2448,2484,2828,2844,2882,4188,4248,4284,4428,4444,4482,4818,4824,4842,4881,8148,8184,8228,8244,8282,8418,8424,8442,8481,8814,8822,8841,12888", "code": "\nfrom math import prod\nfrom sympy.utilities.iterables import multiset_combinations, multiset_permutations\ndef auptod(maxdigits):\n  n, digs, alst, powsexps2 = 0, 1, [], [(1, 0), (2, 1), (4, 2), (8, 3)]\n  for digs in range(1, maxdigits+1):\n    target, okdigs = 4**digs, set()\n    mcstr = \"\".join(str(d)*(digs//max(1, r//2)) for d, r in powsexps2)\n    for mc in multiset_combinations(mcstr, digs):\n      if prod(map(int, mc)) == target:\n        n += 1\n        okdigs |= set(\"\".join(mp) for mp in multiset_permutations(mc, digs))\n    alst += sorted(map(int, okdigs))\n  return alst\nprint(auptod(4)) \n"}
{"sequence_id": "A061434", "text": "a(n) is the smallest n-digit cube.", "sequence": "1,27,125,1000,10648,103823,1000000,10077696,100544625,1000000000,10007873875,100026577288,1000000000000,10000909453625,100000721719296,1000000000000000,10000073940248384,100000075387171679,1000000000000000000,10000004316234262875", "code": "\nfrom sympy import integer_nthroot\ndef a(n):\n  r, exact = integer_nthroot(10**(n-1), 3)\n  return 10**(n-1) if exact else (r+1)**3\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A061537", "text": "Product of unitary divisors of n.", "sequence": "1,2,3,4,5,36,7,8,9,100,11,144,13,196,225,16,17,324,19,400,441,484,23,576,25,676,27,784,29,810000,31,32,1089,1156,1225,1296,37,1444,1521,1600,41,3111696,43,1936,2025,2116,47,2304,49,2500,2601,2704,53,2916", "code": "\nfrom sympy import divisors, gcd, prod\ndef a(n): return prod(d for d in divisors(n) if gcd(d, n//d)==1)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A061548", "text": "Numerator of probability that there is no error when average of n numbers is computed, assuming errors of +1, -1 are possible and they each occur with p = 1/4.", "sequence": "1,3,35,231,6435,46189,676039,5014575,300540195,2268783825,34461632205,263012370465,8061900920775,61989816618513,956086325095055,7391536347803839,916312070471295267,7113260368810144185,110628135069209194801,861577581086657669325,26876802183334044115405", "code": "\nimport math\nfrom fractions import gcd\nf = math.factorial\ndef A061548(n): return f(4*n) / gcd(f(4*n), (2**(4*n)*f(2*n)**2)) \n"}
{"sequence_id": "A061549", "text": "Denominator of probability that there is no error when average of n numbers is computed, assuming errors of +1, -1 are possible and they each occur with p=1/4.", "sequence": "1,8,128,1024,32768,262144,4194304,33554432,2147483648,17179869184,274877906944,2199023255552,70368744177664,562949953421312,9007199254740992,72057594037927936,9223372036854775808,73786976294838206464,1180591620717411303424,9444732965739290427392", "code": "\nimport math\nfrom fractions import gcd\nf = math.factorial\ndef A061549(n): return (2**(4*n)*f(2*n)**2)/ gcd(f(4*n), (2**(4*n)*f(2*n)**2)) \n"}
{"sequence_id": "A061583", "text": "a(1) = 1, a(n) is the number obtained by replacing each digit of a(n-1) with five times its value.", "sequence": "1,5,25,1025,501025,250501025,10250250501025,501025010250250501025,2505010250501025010250250501025,1025025050102502505010250501025010250250501025", "code": "\ndef A061583_first(n):\n    an = \"1\"\n    a061583 = []\n    while n > 1:\n        a061583.append(int(an))\n        newan = \"\"\n        for i in an:\n            newan += str(5*int(i))\n        an = newan\n        n -= 1\n    a061583.append(int(an))\n    return a061583 \n"}
{"sequence_id": "A061584", "text": "a(1) = 1, a(n)= number obtained by replacing each digit of a(n-1) with six times its value.", "sequence": "1,6,36,1836,6481836,3624486481836,1836122424483624486481836,64818366121224122424481836122424483624486481836,362448648183636612612122461212241224244864818366121224122424481836122424483624486481836", "code": "\ndef A061584_first(n):\n    an = \"1\"\n    a061584 = []\n    while n > 1:\n        a061584.append(int(an))\n        newan = \"\"\n        for i in an:\n            newan += str(6*int(i))\n        an = newan\n        n -= 1\n    a061584.append(int(an))\n    return a061584 \n"}
{"sequence_id": "A061585", "text": "a(1) = 1, a(n)= number obtained by replacing each digit of a(n-1) with seven times its value.", "sequence": "1,7,49,2863,14564221,72835422814147,49145621352814145672872849,286372835421472135145672872835424914564914562863,1456422149145621352814728491472135728354249145649145621352814286372835422863728354214564221", "code": "\ndef A061585_first(n):\n    an = \"1\"\n    a061585 = []\n    while n > 1:\n        a061585.append(int(an))\n        newan = \"\"\n        for i in an:\n            newan += str(7*int(i))\n        an = newan\n        n -= 1\n    a061585.append(int(an))\n    return a061585 \n"}
{"sequence_id": "A061586", "text": "a(1) = 1, a(n)= number obtained by replacing each digit of a(n-1) with eight times its value.", "sequence": "1,8,64,4832,32642416,241648321632848,1632848326424168482416643264,84824166432642416483216328486432641632848483224164832,64326416328484832241648321632848326424168482416643264483224164832848241664326432642416163284832642416", "code": "\ndef A061586_first(n):\n    an = \"1\"\n    cnt = 1\n    a061586 = []\n    while cnt < n:\n        a061586.append(int(an))\n        newan = \"\"\n        for i in an:\n            newan += str(8*int(i))\n        an = newan\n        cnt += 1\n    a061586.append(int(an))\n    return a061586 \n"}
{"sequence_id": "A061588", "text": "a(1) = 2, a(n) = number obtained by replacing each digit of a(n-1) with its square.", "sequence": "2,4,16,136,1936,181936,164181936,13616164181936,193613613616164181936,1819361936193613613616164181936,1641819361819361819361936193613613616164181936", "code": "\ndef digits(n):\n.d=[]\n.while n>0:\n..d.append(n%10)\n..n=n//10\n.return d\ndef sqdig(n):\n.new=0\n.num=digits(n)\n.spacing=0\n.while num:\n..k=num.pop(0)\n..new+=(10**(spacing))*(k**2)\n..if k>3:\n...spacing+=1\n..spacing+=1\n.return new\ndef davidson(n):\n.i=2\n.while n>1:\n..i=sqdig(i)\n..n-=1\n.return i\n\n"}
{"sequence_id": "A061601", "text": "9's complement of n: a(n) = 10^d - 1 - n where d is the number of digits in n. If a is a digit in n replace it with 9 - a.", "sequence": "9,8,7,6,5,4,3,2,1,0,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28", "code": "\ndef A061601(n):\n    return 10**len(str(n))-1-n \n"}
{"sequence_id": "A061602", "text": "Sum of factorials of the digits of n.", "sequence": "1,1,2,6,24,120,720,5040,40320,362880,2,2,3,7,25,121,721,5041,40321,362881,3,3,4,8,26,122,722,5042,40322,362882,7,7,8,12,30,126,726,5046,40326,362886,25,25,26,30,48,144,744,5064,40344,362904,121,121,122,126", "code": "\nimport math\ndef A061602(n):\n    s=0\n    for i in str(n):\n        s+=math.factorial(int(i))\n    return s \n"}
{"sequence_id": "A061673", "text": "Even numbers k such that k+1 and k-1 are both composite.", "sequence": "26,34,50,56,64,76,86,92,94,116,118,120,122,124,134,142,144,146,154,160,170,176,184,186,188,202,204,206,208,214,216,218,220,236,244,246,248,254,260,266,274,286,288,290,296,298,300,302,304,320,322,324,326", "code": "\nfrom sympy import isprime\ndef abelow(limit):\n  for k in range(2, limit, 2):\n    if not isprime(k-1) and not isprime(k+1): yield k\nprint([an for an in abelow(327)]) \n"}
{"sequence_id": "A061712", "text": "Smallest prime with Hamming weight n (i.e., with exactly n 1's when written in binary).", "sequence": "2,3,7,23,31,311,127,383,991,2039,3583,6143,8191,73727,63487,129023,131071,522239,524287,1966079,4128767,16250879,14680063,33546239,67108351,201064447,260046847,536739839,1073479679,5335154687,2147483647", "code": "\nfrom itertools import combinations\nfrom sympy import isprime\ndef A061712(n):\n    l, k = n-1, 2**n\n    while True:\n        for d in combinations(range(l-1,-1,-1),l-n+1):\n            m = k-1 - sum(2**(e) for e in d)\n            if isprime(m):\n                return m\n        l += 1\n        k *= 2 \n"}
{"sequence_id": "A061762", "text": "a(n) = (sum of digits of n) + (product of digits of n).", "sequence": "0,2,4,6,8,10,12,14,16,18,1,3,5,7,9,11,13,15,17,19,2,5,8,11,14,17,20,23,26,29,3,7,11,15,19,23,27,31,35,39,4,9,14,19,24,29,34,39,44,49,5,11,17,23,29,35,41,47,53,59,6,13,20,27,34,41,48,55,62,69,7,15,23,31,39,47", "code": "\nfrom operator import mul\nfrom functools import reduce\ndef A067162(n):\n    a = [int(d) for d in str(n)]\n    return sum(a)+reduce(mul,a) \n"}
{"sequence_id": "A061783", "text": "Luhn primes: primes p such that p + (p reversed) is also a prime.", "sequence": "229,239,241,257,269,271,277,281,439,443,463,467,479,499,613,641,653,661,673,677,683,691,811,823,839,863,881,20011,20029,20047,20051,20101,20161,20201,20249,20269,20347,20389,20399,20441,20477,20479,20507", "code": "\nfrom sympy import isprime, prime\nA061783 = [prime(n) for n in range(1,10**5) if isprime(prime(n)+int(str(prime(n))[::-1]))] \n"}
{"sequence_id": "A061853", "text": "Difference between smallest prime not dividing n and smallest nondivisor of n.", "sequence": "0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0", "code": "\nfrom sympy import nextprime\ndef a053669(n):\n    p=2\n    while n%p==0: p=nextprime(p)\n    return p\ndef a007978(n):\n    p=2\n    while n%p==0: p+=1\n    return p\ndef a(n): return a053669(n) - a007978(n)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A061873", "text": "Numbers n such that |first digit - second digit + third digit - fourth digit ...| = 4.", "sequence": "4,15,26,37,40,48,51,59,62,73,84,95,103,114,125,136,147,150,158,161,169,172,183,194,202,213,224,235,246,257,260,268,271,279,282,293,301,312,323,334,345,356,367,370,378,381,389,392,400,411,422,433,444,455", "code": "\ndef ok(n): return abs(sum((-1)**i*int(d) for i, d in enumerate(str(n))))==4\nprint(list(filter(ok, range(456)))) \n"}
{"sequence_id": "A061875", "text": "|First digit - second digit + third digit - fourth digit ...| = 6.", "sequence": "6,17,28,39,60,71,82,93,105,116,127,138,149,170,181,192,204,215,226,237,248,259,280,291,303,314,325,336,347,358,369,390,402,413,424,435,446,457,468,479,501,512,523,534,545,556,567,578,589,600,611,622,633,644", "code": "\ndef ok(n): return abs(sum(int(d)*(-1)**i for i, d in enumerate(str(n))))==6\nprint(list(filter(ok, range(645)))) \n"}
{"sequence_id": "A061877", "text": "|First digit - second digit + third digit - fourth digit ...| = 8.", "sequence": "8,19,80,91,107,118,129,190,206,217,228,239,305,316,327,338,349,404,415,426,437,448,459,503,514,525,536,547,558,569,602,613,624,635,646,657,668,679,701,712,723,734,745,756,767,778,789,800,811,822,833,844,855", "code": "\ndef ok(n): return abs(sum((-1)**i*int(d) for i, d in enumerate(str(n))))==8\nprint(list(filter(ok, range(860)))) \n"}
{"sequence_id": "A061906", "text": "Obtain m by omitting trailing zeros from n; a(n) = smallest k such that k*m is a palindrome.", "sequence": "1,1,1,1,1,1,1,1,1,1,1,1,21,38,18,35,17,16,14,9,1,12,1,7,29,21,19,37,9,8,1,14,66,1,8,15,7,3,13,15,1,16,6,23,1,13,9,3,44,7,1,19,13,4,518,1,11,3,4,13,1,442,7,4,33,9,1,11,4,6,1,845,88,4,3,7,287,1,11,6,1,12345679,8", "code": "\nfrom __future__ import division\ndef palgen(l, b=10): \n....if l > 0:\n........yield 0\n........for x in range(1, l+1):\n............n = b**(x-1)\n............n2 = n*b\n............for y in range(n, n2):\n................k, m = y//b, 0\n................while k >= b:\n....................k, r = divmod(k, b)\n....................m = b*m + r\n................yield y*n + b*m + k\n............for y in range(n, n2):\n................k, m = y, 0\n................while k >= b:\n....................k, r = divmod(k, b)\n....................m = b*m + r\n................yield y*n2 + b*m + k\ndef A050782(n, l=10):\n....if n % 10:\n........x = palgen(l)\n........next(x)  \n........for i in x:\n............q, r = divmod(i, n)\n............if not r:\n................return q\n........else:\n............return 'search limit reached.'\n....else:\n........return 0\ndef A061906(n, l=10):\n....return A050782(int(str(n).rstrip('0')),l) if n > 0 else 1\n\n"}
{"sequence_id": "A061910", "text": "Positive numbers n such that sum of digits of n^2 is a square.", "sequence": "1,2,3,6,9,10,11,12,13,14,15,18,20,21,22,23,30,31,39,41,45,48,51,58,59,60,67,68,76,77,85,86,90,94,95,100,101,102,103,104,105,110,111,112,113,120,121,122,130,131,139,140,148,150,157,158,166,175,176,180,184,185", "code": "\nfrom gmpy2 import is_square\nA061910 = [n for n in range(1,10**3) if is_square(sum(int(d) for d in str(n*n)))] \n"}
{"sequence_id": "A061928", "text": "Array T(n,m) = 1/beta(n+1,m+1) read by antidiagonals.", "sequence": "6,12,12,20,30,20,30,60,60,30,42,105,140,105,42,56,168,280,280,168,56,72,252,504,630,504,252,72,90,360,840,1260,1260,840,360,90,110,495,1320,2310,2772,2310,1320,495,110,132,660,1980,3960,5544,5544,3960", "code": "\nfrom sympy import factorial as f\ndef T(n, m): return f(n + m + 1)/(f(n)*f(m))\nfor n in range(1, 11): print([T(m, n - m + 1) for m in range(1, n + 1)]) \n"}
{"sequence_id": "A062052", "text": "Numbers with 2 odd integers in their Collatz (or 3x+1) trajectory.", "sequence": "5,10,20,21,40,42,80,84,85,160,168,170,320,336,340,341,640,672,680,682,1280,1344,1360,1364,1365,2560,2688,2720,2728,2730,5120,5376,5440,5456,5460,5461,10240,10752,10880,10912,10920,10922,20480,21504,21760,21824", "code": "\ndef a(n):\n    l=[n, ]\n    while True:\n        if n%2==0: n//=2\n        else: n = 3*n + 1\n        if n not in l:\n            l.append(n)\n            if n<2: break\n        else: break\n    return len([i for i in l if i % 2])\nprint([n for n in range(1, 22001) if a(n)==2]) \n"}
{"sequence_id": "A062059", "text": "Numbers with 9 odd integers in their Collatz (or 3x+1) trajectory.", "sequence": "33,65,66,67,130,131,132,133,134,260,261,262,264,266,268,269,273,289,520,522,524,525,528,529,532,533,536,538,546,547,555,571,577,578,579,583,633,635,1040,1044,1045,1048,1050,1056,1058,1059,1064,1066,1072,1076,1077", "code": "\ndef a(n):\n    l=[n, ]\n    while True:\n        if n%2==0: n//=2\n        else: n = 3*n + 1\n        if n not in l:\n            l+=[n, ]\n            if n<2: break\n        else: break\n    return len([i for i in l if i%2])\n[n for n in range(30, 1101) if a(n)==9] \n"}
{"sequence_id": "A062060", "text": "Numbers with 10 odd integers in their Collatz (or 3x+1) trajectory.", "sequence": "43,86,87,89,172,173,174,177,178,179,344,346,348,349,354,355,356,357,358,385,423,688,692,693,696,698,705,708,709,710,712,714,716,717,729,761,769,770,771,777,846,847,1376,1384,1386,1392,1393,1396,1397,1410,1411,1415", "code": "\ndef a(n):\n    l=[n]\n    while True:\n        if n%2==0: n//=2\n        else: n = 3*n + 1\n        if n not in l:\n            l.append(n)\n            if n<2: break\n        else: break\n    return len([1 for i in l if i%2])\nprint([n for n in range(40, 1501) if a(n)==10]) \n"}
{"sequence_id": "A062067", "text": "a(1) = 1; a(n) is smallest square > a(n-1) such that a(n) + a(n-1) is a prime.", "sequence": "1,4,9,64,169,400,529,900,961,1936,2401,5476,6241,6400,7921,9216,10201,10816,11025,13456,14161,15376,17161,17956,19321,19600,22201,22500,24649,24964,27225,29584,29929,31684,33489,40804,41209,52900", "code": "\nfrom sympy import isprime\nA062067, a = [1], 1\nfor _ in range(1,10000):\n    a += 1\n    b = 2*a*(a-1) + 1\n    while not isprime(b):\n        b += 4*(a+1)\n        a += 2\n    A062067.append(a**2) \n"}
{"sequence_id": "A062138", "text": "Coefficient triangle of generalized Laguerre polynomials n!*L(n,5,x)(rising powers of x).", "sequence": "1,6,-1,42,-14,1,336,-168,24,-1,3024,-2016,432,-36,1,30240,-25200,7200,-900,50,-1,332640,-332640,118800,-19800,1650,-66,1,3991680,-4656960,1995840,-415800,46200,-2772,84,-1,51891840,-69189120", "code": "\nimport math\nf=math.factorial\ndef C(n, r):return f(n)//f(r)//f(n-r)\ni=-1\nfor n in range(26):\n    for m in range(n+1):\n        i += 1\n        print(str(i)+\" \"+str(((-1)**m)*f(n)*C(n+5, n-m)//f(m))) \n"}
{"sequence_id": "A062139", "text": "Coefficient triangle of generalized Laguerre polynomials n!*L(n,2,x) (rising powers of x).", "sequence": "1,3,-1,12,-8,1,60,-60,15,-1,360,-480,180,-24,1,2520,-4200,2100,-420,35,-1,20160,-40320,25200,-6720,840,-48,1,181440,-423360,317520,-105840,17640,-1512,63,-1,1814400,-4838400,4233600", "code": "\nimport math\nf=math.factorial\ndef C(n,r):return f(n)//f(r)//f(n-r)\ni=0\nfor n in range(16):\n    for m in range(n+1):\n        i += 1\n        print(i,((-1)**m)*f(n)*C(n+2,n-m)//f(m)) \n"}
{"sequence_id": "A062140", "text": "Coefficient triangle of generalized Laguerre polynomials n!*L(n,4,x) (rising powers of x).", "sequence": "1,5,-1,30,-12,1,210,-126,21,-1,1680,-1344,336,-32,1,15120,-15120,5040,-720,45,-1,151200,-181440,75600,-14400,1350,-60,1,1663200,-2328480,1164240,-277200,34650,-2310,77,-1,19958400,-31933440", "code": "\nimport math\nf=math.factorial\ndef C(n,r):\n    return f(n)//f(r)//f(n-r)\ni=0\nfor n in range(26):\n    for m in range(n+1):\n        print(i, (-1)**m*f(n)*C(n+4,n-m)//f(m))\n        i+=1 \n"}
{"sequence_id": "A062141", "text": "Third column sequence of coefficient triangle A062137 of generalized Laguerre polynomials n!*L(n,3,x).", "sequence": "1,18,252,3360,45360,635040,9313920,143700480,2335132800,39956716800,719220902400,13599813427200,269729632972800,5602076992512000,121645100408832000,2757288942600192000,65140951268929536000,1601701037083090944000,40932359836567879680000", "code": "\nimport math\nf=math.factorial\ndef C(n,r):return f(n)/f(r)/f(n-r)\ndef A062141(n): return f(n+2)*C(n+5,5)/f(2) \n"}
{"sequence_id": "A062142", "text": "Fourth (unsigned) column sequence of coefficient triangle A062137 of generalized Laguerre polynomials n!*L(n,3,x).", "sequence": "1,28,560,10080,176400,3104640,55883520,1037836800,19978358400,399567168000,8310997094400,179819755315200,4045944494592000,94612855873536000,2297740785500160000,57903067794604032000", "code": "\nimport math\nf=math.factorial\ndef C(n,r):\n    return f(n)/f(r)/f(n-r)\ndef A062142(n):return f(n+3)*C(n+6,6)/f(3) \n"}
{"sequence_id": "A062143", "text": "Fifth column sequence of coefficient triangle A062137 of generalized Laguerre polynomials n!*L(n,3,x).", "sequence": "1,40,1080,25200,554400,11975040,259459200,5708102400,128432304000,2968213248000,70643475302400,1733976211968000,43927397369856000,1148870392750080000,31019500604252160000,864410083505160192000", "code": "\nimport math\nf=math.factorial\ndef C(n,r):return f(n)/f(r)/f(n-r)\ndef A062143(n):return f(n+4)*C(n+7,7)/f(4) \n"}
{"sequence_id": "A062144", "text": "Sixth (unsigned) column sequence of coefficient triangle A062137 of generalized Laguerre polynomials n!*L(n,3,x).", "sequence": "1,54,1890,55440,1496880,38918880,998917920,25686460800,667847980800,17660868825600,476843458291200,13178219210956800,373382877643776000,10856825211488256000,324153781314435072000", "code": "\nimport math\nf=math.factorial\ndef C(n, r):return f(n)/f(r)/f(n-r)\ndef A062144(n): return f(n+5)*C(n+8, 8)/f(5) \n"}
{"sequence_id": "A062148", "text": "Second (unsigned) column sequence of triangle A062138 (generalized a=5 Laguerre).", "sequence": "1,14,168,2016,25200,332640,4656960,69189120,1089728640,18162144000,319653734400,5928123801600,115598414131200,2365321396838400,50685458503680000,1135354270482432000", "code": "\nimport math\nf=math.factorial\ndef C(n,r):return f(n)/f(r)/f(n-r)\ndef A062148(n): return f(n+1)*C(n+6,6) \n"}
{"sequence_id": "A062149", "text": "Third column sequence of triangle A062138 (generalized a=5 Laguerre).", "sequence": "1,24,432,7200,118800,1995840,34594560,622702080,11675664000,228324096000,4657811558400,99084354969600,2196369868492800,50685458503680000,1216451004088320000,30330178368602112000", "code": "\nimport math\nf=math.factorial\ndef C(n, r):return f(n)/f(r)/f(n-r)\ndef A062149(n): return f(n+2)*C(n+7, 7)/f(2) \n"}
{"sequence_id": "A062150", "text": "Fourth (unsigned) column sequence of triangle A062138 (generalized a=5 Laguerre).", "sequence": "1,36,900,19800,415800,8648640,181621440,3891888000,85621536000,1940754816000,45413662694400,1098184934246400,27454623356160000,709596419051520000,18956361480376320000,523195576858386432000", "code": "\nimport math\nf=math.factorial\ndef C(n, r):return f(n)/f(r)/f(n-r)\ndef A062150(n): return f(n+3)*C(n+8, 8)/f(3) \n"}
{"sequence_id": "A062151", "text": "Fifth column sequence of triangle A062138 (generalized a=5 Laguerre).", "sequence": "1,50,1650,46200,1201200,30270240,756756000,19027008000,485188704000,12614906304000,335556507686400,9151541118720000,256243151324160000,7371918353479680000,217998157024327680000", "code": "\nimport math\nf=math.factorial\ndef C(n, r):return f(n)/f(r)/f(n-r)\ndef A062151(n): return f(n+4)*C(n+9, 9)/f(4) \n"}
{"sequence_id": "A062152", "text": "Sixth (unsigned) column of triangle A062138 (generalized a=5 Laguerre).", "sequence": "1,66,2772,96096,3027024,90810720,2663781120,77630192640,2270683134720,67111301537280,2013339046118400,61498356317798400,1916698771904716800,61039483966811750400,1988143192061868441600", "code": "\nimport math\nf=math.factorial\ndef C(n, r):return f(n)/f(r)/f(n-r)\ndef A062152(n): return f(n+5)*C(n+10, 10)/f(5) \n"}
{"sequence_id": "A062181", "text": "Harmonic mean of digits is 3.", "sequence": "3,26,33,62,236,244,263,326,333,362,424,442,623,632,1999,2266,2336,2344,2363,2434,2443,2626,2633,2662,3236,3244,3263,3326,3333,3362,3424,3442,3623,3632,4234,4243,4324,4342,4423,4432,6226,6233,6262,6323,6332", "code": "\nfrom fractions import Fraction\ndef hm(n):\n  s = str(n)\n  return None if '0' in s else len(s)/sum(Fraction(1, int(d)) for d in s)\ndef aupto(limit): return [m for m in range(limit+1) if hm(m) == 3]\nprint(aupto(6332)) \n"}
{"sequence_id": "A062249", "text": "a(n) = n + d(n), where d(n) = number of divisors of n, cf. A000005.", "sequence": "2,4,5,7,7,10,9,12,12,14,13,18,15,18,19,21,19,24,21,26,25,26,25,32,28,30,31,34,31,38,33,38,37,38,39,45,39,42,43,48,43,50,45,50,51,50,49,58,52,56,55,58,55,62,59,64,61,62,61,72,63,66,69,71,69,74,69,74,73,78,73", "code": "\nfrom sympy.ntheory import divisor_count\n[n + divisor_count(n) for n in range(101)] \n"}
{"sequence_id": "A062267", "text": "Row sums of (signed) triangle A060821 (Hermite polynomials).", "sequence": "1,2,2,-4,-20,-8,184,464,-1648,-10720,8224,230848,280768,-4978816,-17257600,104891648,727511296,-1901510144,-28538404352,11377556480,1107214478336,1759326697472,-42984354695168,-163379084079104", "code": "\nfrom sympy import hermite, Poly\ndef a(n): return sum(Poly(hermite(n, x), x).all_coeffs()) \n"}
{"sequence_id": "A062298", "text": "Number of nonprimes <= n.", "sequence": "1,1,1,2,2,3,3,4,5,6,6,7,7,8,9,10,10,11,11,12,13,14,14,15,16,17,18,19,19,20,20,21,22,23,24,25,25,26,27,28,28,29,29,30,31,32,32,33,34,35,36,37,37,38,39,40,41,42,42,43,43,44,45,46,47,48,48,49,50,51,51,52,52,53", "code": "\nfrom sympy import primepi\nprint([n - primepi(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A062340", "text": "Primes whose sum of digits is a multiple of 5.", "sequence": "5,19,23,37,41,73,109,113,127,131,163,181,271,307,311,389,401,433,479,523,541,569,587,613,631,659,677,811,839,857,929,947,983,997,1009,1013,1031,1063,1103,1117,1153,1171,1289,1301,1423,1487,1531,1559,1621,1667", "code": "\nfrom sympy import primerange as primes\ndef ok(p): return sum(map(int, str(p)))%5 == 0\nprint(list(filter(ok, primes(1, 1668)))) \n"}
{"sequence_id": "A062341", "text": "Primes whose sum of digits is 5.", "sequence": "5,23,41,113,131,311,401,1013,1031,1103,1301,2003,2111,3011,4001,10103,10211,10301,11003,12011,12101,13001,20021,20201,21011,21101,30011,100103,101021,101111,102101,103001,120011,121001,200003,200201,201011,201101,202001", "code": "\nfrom sympy import primerange as primes\ndef ok(p): return sum(map(int, str(p))) == 5\nprint(list(filter(ok, primes(1, 202002)))) \n"}
{"sequence_id": "A062351", "text": "Palindromic primes with strictly increasing digits up to the middle and then strictly decreasing.", "sequence": "2,3,5,7,11,131,151,181,191,353,373,383,787,797,12421,12721,12821,13831,13931,14741,17971,34543,34843,35753,1235321,1245421,1257521,1268621,1278721,1456541,1469641,1489841,1579751,1589851,3479743", "code": "\nfrom sympy import isprime\nfrom itertools import combinations\ndef agen():\n  for digits in range(1, 19):\n    for left in combinations(\"123456789\", (digits+1)//2):\n      left = \"\".join(left)\n      yield int(left + (left[:digits//2])[::-1])\nprint(list(filter(isprime, agen()))) \n"}
{"sequence_id": "A062402", "text": "a(n) = sigma(phi(n)).", "sequence": "1,1,3,3,7,3,12,7,12,7,18,7,28,12,15,15,31,12,39,15,28,18,36,15,42,28,39,28,56,15,72,31,42,31,60,28,91,39,60,31,90,28,96,42,60,36,72,31,96,42,63,60,98,39,90,60,91,56,90,31,168,72,91,63,124,42,144,63,84,60,144", "code": "\nfrom sympy import divisor_sigma, totient\nprint([divisor_sigma(totient(n)) for n in range(1, 101)]) \n"}
{"sequence_id": "A062439", "text": "Primes at large indices: a(n) = prime(n!).", "sequence": "2,2,3,13,89,659,5443,49033,484037,5222429,61194647,774825383,10552185239,153903050137,2394322471421,39588599419319,693389445083107,12826386978604427,249902442548157673,5115640857307591139,109776797549312197217,2464348772728229970857", "code": "\nfrom sympy import prime, factorial\nfor n in range(0,14): print(prime(factorial(n))) \n"}
{"sequence_id": "A062520", "text": "3^a(n) is smallest nonnegative power of 3 containing n.", "sequence": "10,0,3,1,5,8,8,3,4,2,21,19,17,22,11,13,17,11,7,9,18,7,19,13,5,26,19,3,24,6,16,12,13,31,15,21,24,29,18,31,17,12,18,5,12,28,16,11,15,10,35,32,33,12,26,27,8,40,26,10,21,8,19,17,24,8,33,16,9,14,35,11,6,29,18,47", "code": "\ndef a(n):\n    s, k = str(n), 0\n    while s not in str(3**k): k += 1\n    return k\nprint([a(n) for n in range(76)]) \n"}
{"sequence_id": "A062529", "text": "Smallest prime p such that there is a gap of 2^n between p and the next prime.", "sequence": "2,3,7,89,1831,5591,89689,3851459,1872851947,1999066711391,22790428875364879", "code": "\nimport sympy\nn=0\nwhile n>=0:\n....p=2\n....while  sympy.nextprime(p)-p!=(2**n):\n........p=sympy.nextprime(p)\n....print(p)\n....n=n+1\n....p=sympy.nextprime(p)\n\n"}
{"sequence_id": "A062550", "text": "a(n) = Sum_{k = 1..2n} floor(2n/k).", "sequence": "0,3,8,14,20,27,35,41,50,58,66,74,84,91,101,111,119,127,140,146,158,168,176,186,198,207,217,227,239,247,261,267,280,292,300,312,326,332,344,356,368,377,391,399,411,425,435,443,459,467,482,492,502,514,528", "code": "\nfrom math import isqrt\ndef A062550(n): return (lambda m: 2*sum(2*n//k for k in range(1, m+1))-m*m)(isqrt(2*n)) \n"}
{"sequence_id": "A062671", "text": "Every divisor (except 1) contains the digit 5.", "sequence": "5,25,53,59,125,151,157,251,257,265,295,353,359,457,503,509,521,523,541,547,557,563,569,571,577,587,593,599,625,653,659,751,755,757,785,853,857,859,953,1051,1151,1153,1255,1259,1285,1325,1451,1453,1459,1475,1511", "code": "\nfrom sympy import divisors\ndef ok(n): return all('5' in str(d) for d in divisors(n)[1:])\nprint(list(filter(ok, range(2, 1512)))) \n"}
{"sequence_id": "A062700", "text": "Terms of A000203 that are prime.", "sequence": "3,7,13,31,31,127,307,1093,1723,2801,3541,8191,5113,8011,10303,19531,17293,28057,30941,30103,131071,88741,86143,147073,524287,292561,459007,492103,797161,552793,579883,598303,684757,704761,732541,735307", "code": "\nfrom sympy import isprime, divisor_sigma\nA062700_list = [3]+[n for n in (divisor_sigma(d**2) for d in range(1,10**4)) if isprime(n)] \n"}
{"sequence_id": "A062841", "text": "Palindromes of the form k^3-1.", "sequence": "0,7,999,999999,258474852,999999999,999999999999,999999999999999,999999999999999999,999999999999999999999,999999999999999999999999,999999999999999999999999999,999999999999999999999999999999,999999999999999999999999999999999", "code": "\ndef afind(limit):\n  for n in range(limit+1):\n    s = str(n**3 - 1)\n    if s == s[::-1]: print(int(s), end=\", \")\nprint(afind(10**7)) \n"}
{"sequence_id": "A062845", "text": "When expressed in base 2 and then interpreted in base 3, is a multiple of the original number.", "sequence": "0,1,5,6,10,12,30,36,60,120,180,215,216,252,360,430,432,1080,2730,3276,13710,14724,16380,20520,24624,24840,27125,27420,32760,38880,48606,49091,54250,54840,97212,98280", "code": "\ndef BaseUp(n,b):\n    up, b1 = 0, 1\n    while n > 0:\n        up, b1, n = up+(n%b)*b1, b1*(b+1), n//b\n    return up\nn, k = 1, 0\nprint(1,0)\nwhile n < 35:\n    n, k = n+1, k+1\n    while BaseUp(k,2)%k != 0:\n        k = k+1\n    print(n,k) \n"}
{"sequence_id": "A062892", "text": "Number of squares that can be obtained by permuting the digits of n.", "sequence": "1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,2,0,0,0,0", "code": "\nfrom math import isqrt\nfrom sympy.utilities.iterables import multiset_permutations as mp\ndef sqr(n): return isqrt(n)**2 == n\ndef a(n):\n    s = str(n)\n    perms = (int(\"\".join(p)) for p in mp(s, len(s)))\n    return len(set(p for p in perms if sqr(p)))\nprint([a(n) for n in range(105)] ) \n"}
{"sequence_id": "A062935", "text": "Palindromes of the form n! + 1.", "sequence": "2,3,7,121", "code": "\nA062935_list, n = [], 1\nfor i in range(1,10**3):\n....n *= i\n....s = str(n+1)\n....if s == s[::-1]:\n........A062935_list.append(n+1) \n"}
{"sequence_id": "A062936", "text": "Numbers n such that n*R(n) is a palindrome, where R(n) (A004086) = digit reversal.", "sequence": "1,2,3,11,12,21,22,101,102,111,112,121,122,201,202,211,212,221,1001,1002,1011,1012,1021,1022,1101,1102,1111,1112,1121,1201,1202,1211,2001,2002,2011,2012,2021,2101,2102,2111,2201,10001,10002,10011,10012", "code": "\nA062936_list = []\nfor n in range(1,10**5):\n....s = str(n*int(str(n)[::-1]))\n....if s == s[::-1]:\n........A062936_list.append(n) \n"}
{"sequence_id": "A062980", "text": "a(0) = 1, a(1) = 5; for n > 1, a(n) = 6*n*a(n-1) + Sum_{k=1..n-2} a(k)*a(n-k-1).", "sequence": "1,5,60,1105,27120,828250,30220800,1282031525,61999046400,3366961243750,202903221120000,13437880555850250,970217083619328000,75849500508999712500,6383483988812390400000,575440151532675686278125,55318762960656722780160000", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n): return n*4 + 1 if n<2 else 6*n*a(n - 1) + sum(a(k)*a(n - k - 1) for k in range(1, n - 1))\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A063000", "text": "Number of paths of length n+2 originating at a corner of a 4 X 4 Boggle board.", "sequence": "3,15,75,322,1184,3814,10918,27772,61734,116966,183256,228016,211502,128994,37948", "code": "\ndef nn(c): \n  i, j = divmod(c, 4)\n  N = set((i+io, j+jo) for io in [-1, 0, 1] for jo in [-1, 0, 1]) - {(i, j)}\n  return [4*i+j for i, j in N if 0 <= i < 4 and 0 <= j < 4]\ndef afind():\n  n, paths = 0, {(0,)}\n  while n+2 <= 16:\n    paths1 = set(p + (e,) for p in paths for e in nn(p[-1]) if e not in p)\n    print(len(paths1), end=\", \")\n    n, paths = n+1, paths1\nafind() \n"}
{"sequence_id": "A063001", "text": "Number of paths of length n+2 originating at a non-corner edge of 4 X 4 Boggle board.", "sequence": "5,24,109,435,1512,4621,12463,29565,60596,104542,147032,161759,130777,68989,17681", "code": "\ndef nn(c): \n  i, j = divmod(c, 4)\n  N = set((i+io, j+jo) for io in [-1, 0, 1] for jo in [-1, 0, 1]) - {(i, j)}\n  return [4*i+j for i, j in N if 0 <= i < 4 and 0 <= j < 4]\ndef afind():\n  n, paths = 0, {(1, )}\n  while n+2 <= 16:\n    paths1 = set(p + (e, ) for p in paths for e in nn(p[-1]) if e not in p)\n    print(len(paths1), end=\", \")\n    n, paths = n+1, paths1\nafind() \n"}
{"sequence_id": "A063095", "text": "Record prime gap among first n+1 primes.", "sequence": "1,2,2,4,4,4,4,4,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,8,8,8,8,8,8,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14", "code": "\nfrom sympy import nextprime\ndef A063095(n):\n    c, p = 0, 2\n    for i in range(n):\n        q = nextprime(p)\n        c, p = max(c,q-p), q\n    return c \n"}
{"sequence_id": "A063250", "text": "Number of binary right-rotations (iterations of A038572) to reach fixed point.", "sequence": "0,0,1,0,2,2,1,0,3,3,3,3,2,2,1,0,4,4,4,4,4,4,4,4,3,3,3,3,2,2,1,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,4,4,4,3,3,3,3,2,2,1,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5", "code": "\ndef a(n):\n    if n<2: return 0\n    b=bin(n)[2:]\n    s=0\n    while \"0\" in b:\n        N=int(b[-1] + b[:-1], 2)\n        s+=1\n        b=bin(N)[2:]\n    return s\nprint([a(n) for n in range(105)]) \n"}
{"sequence_id": "A063383", "text": "a(1) = 6, a(n) = concatenation of two closest divisors of a(n-1) whose product equals a(n-1) or if a(n-1) is a prime then the concatenation of 1 and a(n-1).", "sequence": "6,23,123,341,1131,2939,12939,57227,89643,329881,1073083,1197553,7171079,17171079,57301247,208327509,1171780577,1219684137,1478297171,2587571433,2795835979,8663322733,13666409441,113666409441,1030771102733,2114885171103,6993025586797", "code": "\nfrom sympy import divisors, isprime\ndef aupton(terms):\n    alst = [6]\n    for n in range(2, terms+1):\n        if isprime(alst[-1]): alst.append(int('1' + str(alst[-1])))\n        else:\n            divs = divisors(alst[-1])\n            d1 = divs[(len(divs)-1)//2]\n            d2 = alst[-1]//d1\n            alst.append(int(str(d1) + str(d2)))\n    return alst\nprint(aupton(27)) \n"}
{"sequence_id": "A063454", "text": "Number of solutions to x^3 + y^3 = z^3 mod n.", "sequence": "1,4,9,20,25,36,55,112,189,100,121,180,109,220,225,448,289,756,487,500,495,484,529,1008,725,436,2187,1100,841,900,1081,2048,1089,1156,1375,3780,973,1948,981,2800,1681,1980,1513,2420,4725,2116,2209,4032", "code": "\ndef A063454(n):\n    ndict = {}\n    for i in range(n):\n        m = pow(i,3,n)\n        if m in ndict:\n            ndict[m] += 1\n        else:\n            ndict[m] = 1\n    count = 0\n    for i in ndict:\n        ni = ndict[i]\n        for j in ndict:\n            k = (i+j) % n\n            if k in ndict:\n                count += ni*ndict[j]*ndict[k]\n    return count \n"}
{"sequence_id": "A063492", "text": "a(n) = (2*n - 1)*(11*n^2 - 11*n + 6)/6.", "sequence": "1,14,60,161,339,616,1014,1555,2261,3154,4256,5589,7175,9036,11194,13671,16489,19670,23236,27209,31611,36464,41790,47611,53949,60826,68264,76285,84911,94164,104066,114639,125905,137886,150604,164081,178339,193400,209286,226019", "code": "\nA063492_list, m = [], [22, -11, 2, 1]\nfor _ in range(10**2):\n    A063492_list.append(m[-1])\n    for i in range(3):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A063493", "text": "a(n) = (2*n-1)*(13*n^2-13*n+6)/6.", "sequence": "1,16,70,189,399,726,1196,1835,2669,3724,5026,6601,8475,10674,13224,16151,19481,23240,27454,32149,37351,43086,49380,56259,63749,71876,80666,90145,100339,111274,122976,135471,148785,162944,177974,193901", "code": "\nA063493_list, m = [], [26, -13, 2, 1]\nfor _ in range(10**2):\n    A063493_list.append(m[-1])\n    for i in range(3):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A063527", "text": "Numbers that are divisible by all of their 1 and 2 digit substrings.", "sequence": "1,2,3,4,5,6,7,8,9,11,12,15,22,24,33,36,44,48,55,66,77,88,99,1111,1155,1248,2222,3333,4444,5555,6666,7777,8888,9999,27216,31248,111111,116688,121212,142128,212184,222222,242424,313131,321216,333333,363636,368424,444444", "code": "\nfrom itertools import product\nA063527_list = []\nfor g in range(1,7):\n....for n in product('123456789', repeat=g):\n........s = ''.join(n)\n........m = int(s)\n........if not any([m % int(d) for d in s]):\n............for i in range(len(s)-1):\n................if m % int(s[i:i+2]):\n....................break\n............else:\n................A063527_list.append(m) \n"}
{"sequence_id": "A063543", "text": "a(n) = n - product of nonzero digits of n.", "sequence": "0,0,0,0,0,0,0,0,0,9,10,10,10,10,10,10,10,10,10,18,19,18,17,16,15,14,13,12,11,27,28,26,24,22,20,18,16,14,12,36,37,34,31,28,25,22,19,16,13,45,46,42,38,34,30,26,22,18,14,54,55,50,45,40,35,30,25,20,15,63,64,58", "code": "\ndef a(n):\n    digits = map(int, str(n))\n    product = 1\n    for d in digits:\n        if d != 0:\n            product *= d\n    return n - product\n[a(n) for n in range(20)]\n\n"}
{"sequence_id": "A063565", "text": "Smallest positive number k such that 2^k contains n.", "sequence": "10,4,1,5,2,8,4,15,3,12,10,40,7,17,18,21,4,27,30,13,11,18,43,41,10,8,18,15,7,32,22,17,5,25,27,25,16,30,14,42,12,22,19,22,18,28,42,31,11,32,52,9,19,16,25,16,8,20,33,33,23,58,18,14,6,16,46,24,15,34,29,21,17,30", "code": "\ndef A063565(n):\n....s, k, k2 = str(n), 1, 2\n....while True:\n........if s in str(k2):\n............return k\n........k += 1\n........k2 *= 2 \n"}
{"sequence_id": "A063566", "text": "3^a(n) = smallest positive power of 3 having n in its decimal representation.", "sequence": "10,4,3,1,5,8,8,3,4,2,21,19,17,22,11,13,17,11,7,9,18,7,19,13,5,26,19,3,24,6,16,12,13,31,15,21,24,29,18,31,17,12,18,5,12,28,16,11,15,10,35,32,33,12,26,27,8,40,26,10,21,8,19,17,24,8,33,16,9,14", "code": "\ndef a(n):\n    s, k = str(n), 1\n    while s not in str(3**k): k += 1\n    return k\nprint([a(n) for n in range(70)]) \n"}
{"sequence_id": "A063567", "text": "Smallest positive power of 4 having n in its decimal representation.", "sequence": "5,2,4,7,1,4,2,10,7,6,5,20,25,35,9,29,2,17,15,11,28,9,36,29,5,4,9,19,24,16,11,37,38,43,35,14,8,15,7,21,6,11,16,11,9,14,21,18,10,16,26,20,30,8,14,8,4,10,25,22,22,29,9,7,3,8,23,12,14,17,23,13", "code": "\ndef a(n):\n  target, k, pow4 = str(n), 1, 4\n  while not target in str(pow4): k, pow4 = k+1, pow4*4\n  return k\nprint([a(n) for n in range(72)]) \n"}
{"sequence_id": "A063569", "text": "6^a(n) is smallest positive power of 6 containing the string 'n'.", "sequence": "9,3,3,2,6,6,1,5,12,4,9,16,4,13,28,18,3,10,15,21,26,3,22,12,27,26,17,7,16,4,13,22,24,12,27,19,2,21,22,30,13,14,22,25,17,15,6,15,28,15,21,31,46,23,28,18,6,15,20,17,10,8,11,33,14,6,6,8,18,9,11,22,26,17,16,33", "code": "\ndef A063569(n):\n    m, k, s = 1, 6, str(n)\n    while s not in str(k):\n        m += 1\n        k *= 6\n    return m \n"}
{"sequence_id": "A063570", "text": "Smallest positive power of 7 having n in its decimal representation.", "sequence": "4,4,4,3,2,7,5,1,5,2,13,6,12,12,19,15,5,6,19,11,12,22,14,7,4,30,11,23,10,16,14,19,11,16,3,7,9,19,12,17,4,12,27,3,18,21,32,10,8,2,15,17,10,9,7,21,15,8,21,18,9", "code": "\ndef A063570(n):\n    m, k, s = 1, 7, str(n)\n    while s not in str(k):\n        m += 1\n        k *= 7\n    return m \n"}
{"sequence_id": "A063571", "text": "Smallest power of 8 having n in its decimal representation.", "sequence": "4,3,3,5,2,3,2,5,1,4,10,14,3,9,6,7,8,9,10,12,7,6,17,21,10,17,6,5,9,20,26,25,5,21,9,15,12,10,13,14,4,10,9,14,6,11,14,12,17,13,18,3,7,29,13,13,16,25,11,11,20", "code": "\ndef a(n):\n  k, pow8, s = 1, 8, str(n)\n  while s not in str(pow8): k += 1; pow8 *= 8\n  return k\nprint([a(n) for n in range(61)]) \n"}
{"sequence_id": "A063572", "text": "Smallest power of 9 having n in its decimal representation.", "sequence": "5,2,3,6,5,4,4,3,2,1,11,15,18,11,6,18,17,19,13,23,9,8,14,21,12,13,26,28,12,3,8,6,13,24,10,18,12,27,9,27,10,6,9,8,6,14,8,7,9,5,18,16,18,6,13,35,4,20,13,5,11,4,23,18,12,4,17,8,24,7,22,17,3", "code": "\ndef a(n):\n  target, k, pow9 = str(n), 1, 9\n  while not target in str(pow9): k, pow9 = k+1, pow9*9\n  return k\nprint([a(n) for n in range(73)]) \n"}
{"sequence_id": "A063655", "text": "Smallest semiperimeter of integral rectangle with area n.", "sequence": "2,3,4,4,6,5,8,6,6,7,12,7,14,9,8,8,18,9,20,9,10,13,24,10,10,15,12,11,30,11,32,12,14,19,12,12,38,21,16,13,42,13,44,15,14,25,48,14,14,15,20,17,54,15,16,15,22,31,60,16,62,33,16,16,18,17,68,21,26", "code": "\nfrom sympy import divisors\ndef A063655(n):\n    d = divisors(n)\n    l = len(d)\n    return d[(l-1)//2] + d[l//2] \n"}
{"sequence_id": "A063664", "text": "Numbers whose reciprocal is the sum of two reciprocals of squares.", "sequence": "2,8,18,20,32,50,72,80,90,98,128,144,162,180,200,242,272,288,320,338,360,392,450,468,500,512,576,578,648,650,720,722,800,810,882,968,980,1058,1088,1152,1250,1280,1296,1332,1352,1440,1458,1568,1620,1682,1800", "code": "\nfrom fractions import Fraction\ndef aupto(lim):\n  sqr_recips = [Fraction(1, i*i) for i in range(1, lim+2)]\n  ssr = set(f + g for i, f in enumerate(sqr_recips) for g in sqr_recips[i:])\n  representable = [f.denominator for f in ssr if f.numerator == 1]\n  return sorted(r for r in representable if r <= lim)\nprint(aupto(1800)) \n"}
{"sequence_id": "A063733", "text": "A variant of Recam\u00e1n's sequence: a(0)=1, a(n) = a(n-1)-(n-1) if positive and new, else a(n) = a(n-1)+(n-1).", "sequence": "1,1,2,4,7,3,8,14,21,13,22,12,23,11,24,10,25,9,26,44,63,43,64,42,19,43,18,44,17,45,16,46,15,47,80,114,79,115,78,40,79,39,80,38,81,37,82,36,83,35,84,34,85,33,86,32,87,31,88,30,89,29,90,28,91,27", "code": "\nl=[1]\nfor n in range(1, 101):\n    x = l[n - 1] - (n - 1)\n    if x > 0 and x not in l:\n        l.append(x)\n    else:\n        l.append(l[n - 1] + (n - 1))\nprint(l) \n"}
{"sequence_id": "A063871", "text": "Trajectory of 3 under map n->7n-1 if n odd, n->n/2 if n even.", "sequence": "3,20,10,5,34,17,118,59,412,206,103,720,360,180,90,45,314,157,1098,549,3842,1921,13446,6723,47060,23530,11765,82354,41177,288238,144119,1008832,504416,252208,126104,63052,31526,15763,110340,55170,27585,193094,96547", "code": "\ndef iter(n): return 7*n-1 if n%2 == 1 else n//2\ndef aupton(terms):\n  alst = [3]\n  for n in range(1, terms+1): alst.append(iter(alst[-1]))\n  return alst\nprint(aupton(42)) \n"}
{"sequence_id": "A063886", "text": "Number of n-step walks on a line starting from the origin but not returning to it.", "sequence": "1,2,2,4,6,12,20,40,70,140,252,504,924,1848,3432,6864,12870,25740,48620,97240,184756,369512,705432,1410864,2704156,5408312,10400600,20801200,40116600,80233200,155117520,310235040,601080390,1202160780", "code": "\nfrom math import ceil\nfrom sympy import binomial\ndef a(n):\n    if n==0: return 1\n    return 2*binomial(n-1,(n-1)//2)\nprint([a(n) for n in range(18)])\n\n"}
{"sequence_id": "A063946", "text": "Write n in binary and complement second bit (from the left), with a(0)=0 and a(1)=1.", "sequence": "0,1,3,2,6,7,4,5,12,13,14,15,8,9,10,11,24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,96,97,98,99,100,101,102", "code": "\nimport math\ndef a(n): return n if n<2 else 3/2*2**int(math.floor(math.log(n)/math.log(2))) - 2**int(math.floor(math.log(4/3*n)/math.log(2))) + n \n"}
{"sequence_id": "A063970", "text": "a(1) = 1; for n>1, write down all divisors of the previous term in order of magnitude.", "sequence": "2,12,1234612,1247915831639077814156283086536173061234612", "code": "\nfrom sympy import divisors\ndef aupton(terms):\n  alst = [2]\n  for n in range(2, terms+1):\n    alst.append(int(\"\".join(str(d) for d in divisors(alst[-1]))))\n  return alst\nprint(aupton(4)) \n"}
{"sequence_id": "A063985", "text": "Partial sums of cototient sequence A051953.", "sequence": "0,1,2,4,5,9,10,14,17,23,24,32,33,41,48,56,57,69,70,82,91,103,104,120,125,139,148,164,165,187,188,204,217,235,246,270,271,291,306,330,331,361,362,386,407,431,432,464,471,501,520,548,549,585,600,632,653,683", "code": "\nfrom sympy.ntheory import totient\ndef a(n): return sum(x - totient(x) for x in range(1,n + 1))\n[a(n) for n in range(1, 51)] \n"}
{"sequence_id": "A063985", "text": "Partial sums of cototient sequence A051953.", "sequence": "0,1,2,4,5,9,10,14,17,23,24,32,33,41,48,56,57,69,70,82,91,103,104,120,125,139,148,164,165,187,188,204,217,235,246,270,271,291,306,330,331,361,362,386,407,431,432,464,471,501,520,548,549,585,600,632,653,683", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A063985(n): \n    if n == 0:\n        return 0\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(k1*(k1+1)-2*A063985(k1)-1)\n        j, k1 = j2, n//j2\n    return (2*n+c-j)//2 \n"}
{"sequence_id": "A063987", "text": "Irregular triangle in which n-th row gives quadratic residues modulo the n-th prime.", "sequence": "1,1,1,4,1,2,4,1,3,4,5,9,1,3,4,9,10,12,1,2,4,8,9,13,15,16,1,4,5,6,7,9,11,16,17,1,2,3,4,6,8,9,12,13,16,18,1,4,5,6,7,9,13,16,20,22,23,24,25,28,1,2,4,5,7,8,9,10,14,16,18,19,20,25,28,1,3,4,7,9,10,11,12,16,21,25", "code": "\nfrom sympy import jacobi_symbol as J, prime\ndef a(n):\n    p = prime(n)\n    return [1] if n==1 else [i for i in range(1, p) if J(i, p)==1]\nfor n in range(1, 11): print(a(n)) \n"}
{"sequence_id": "A063988", "text": "Triangle in which n-th row gives quadratic non-residues modulo the n-th prime.", "sequence": "2,2,3,3,5,6,2,6,7,8,10,2,5,6,7,8,11,3,5,6,7,10,11,12,14,2,3,8,10,12,13,14,15,18,5,7,10,11,14,15,17,19,20,21,22,2,3,8,10,11,12,14,15,17,18,19,21,26,27,3,6,11,12,13,15,17,21,22,23,24,26,27,29,30,2,5,6,8,13,14", "code": "\nfrom sympy import jacobi_symbol as J, prime\ndef a(n):\n    p=prime(n)\n    return [i for i in range(1, p) if J(i, p)==-1]\nprint([a(n) for n in range(2, 13)]) \n"}
{"sequence_id": "A063990", "text": "Amicable numbers.", "sequence": "220,284,1184,1210,2620,2924,5020,5564,6232,6368,10744,10856,12285,14595,17296,18416,63020,66928,66992,67095,69615,71145,76084,79750,87633,88730,100485,122265,122368,123152,124155,139815,141664,142310", "code": "\nfrom sympy import divisors\nA063990 = [n for n in range(1,10**5) if sum(divisors(n))-2*n and not sum(divisors(sum(divisors(n))-n))-sum(divisors(n))] \n"}
{"sequence_id": "A063994", "text": "a(n) = Product_{primes p dividing n } gcd(p-1, n-1).", "sequence": "1,1,2,1,4,1,6,1,2,1,10,1,12,1,4,1,16,1,18,1,4,1,22,1,4,1,2,3,28,1,30,1,4,1,4,1,36,1,4,1,40,1,42,1,8,1,46,1,6,1,4,3,52,1,4,1,4,1,58,1,60,1,4,1,16,5,66,1,4,3,70,1,72,1,4,3,4,1,78,1,2,1,82,1,16,1,4,1,88,1,36,1", "code": "\ndef a(n):\n    if n == 1: return 1\n    return len([1 for witness in range(1,n) if pow(witness, n - 1, n) == 1])\n[a(n) for n in range(1, 100)]\n"}
{"sequence_id": "A064169", "text": "Numerator - denominator in n-th harmonic number, 1 + 1/2 + 1/3 + ... + 1/n.", "sequence": "0,1,5,13,77,29,223,481,4609,4861,55991,58301,785633,811373,835397,1715839,29889983,10190221,197698279,40315631,13684885,13920029,325333835,990874363,25128807667,25472027467,232222818803,235091155703,6897956948587,6975593267347", "code": "\nfrom sympy import harmonic\ndef A064169(n): return (lambda x: x.p - x.q)(harmonic(n)) \n"}
{"sequence_id": "A064216", "text": "Replace each p^e with prevprime(p)^e in the prime factorization of odd numbers; inverse of sequence A048673 considered as a permutation of the natural numbers.", "sequence": "1,2,3,5,4,7,11,6,13,17,10,19,9,8,23,29,14,15,31,22,37,41,12,43,25,26,47,21,34,53,59,20,33,61,38,67,71,18,35,73,16,79,39,46,83,55,58,51,89,28,97,101,30,103,107,62,109,57,44,65,49,74,27,113,82,127,85,24,131", "code": "\nfrom sympy import factorint, prevprime\nfrom operator import mul\ndef a(n):\n    f=factorint(2*n - 1)\n    return 1 if n==1 else reduce(mul, [prevprime(i)**f[i] for i in f]) \n"}
{"sequence_id": "A064224", "text": "Numbers having more than one representation as the product of consecutive integers > 1.", "sequence": "120,210,720,5040,175560,17297280,19958400,259459200,20274183401472000,25852016738884976640000,368406749739154248105984000000", "code": "\nimport heapq\ndef aupton(terms, verbose=False):\n    p = 2*3; h = [(p, 2, 3)]; nextcount = 4; alst = []; oldv = None\n    while len(alst) < terms:\n        (v, s, l) = heapq.heappop(h)\n        if v == oldv and v not in alst:\n            alst.append(v)\n            if verbose: print(f\"{v}, [= Prod_{{i = {s}..{l}}} i = Prod_{{i = {olds}..{oldl}}} i]\")\n        if v >= p:\n            p *= nextcount\n            heapq.heappush(h, (p, 2, nextcount))\n            nextcount += 1\n        oldv, olds, oldl = v, s, l\n        v //= s; s += 1; l += 1; v *= l\n        heapq.heappush(h, (v, s, l))\n    return alst\nprint(aupton(8, verbose=True)) \n"}
{"sequence_id": "A064298", "text": "Square array read by antidiagonals of self-avoiding rook paths joining opposite corners of n X k board.", "sequence": "1,1,1,1,2,1,1,4,4,1,1,8,12,8,1,1,16,38,38,16,1,1,32,125,184,125,32,1,1,64,414,976,976,414,64,1,1,128,1369,5382,8512,5382,1369,128,1,1,256,4522,29739,79384,79384,29739,4522,256,1,1,512,14934,163496,752061,1262816,752061,163496,14934,512,1", "code": "\n\nfrom graphillion import GraphSet\nimport graphillion.tutorial as tl\ndef A064298(n, k):\n    if n == 1 or k == 1: return 1\n    universe = tl.grid(n - 1, k - 1)\n    GraphSet.set_universe(universe)\n    start, goal = 1, k * n\n    paths = GraphSet.paths(start, goal)\n    return paths.len()\nprint([A064298(j + 1, i - j + 1) for i in range(11) for j in range(i + 1)])  \n"}
{"sequence_id": "A064365", "text": "a(0) = 0; thereafter a(n) = a(n-1)-prime(n) if positive and new, otherwise a(n) = a(n-1)+prime(n), where prime(n) is the n-th prime.", "sequence": "0,2,5,10,3,14,1,18,37,60,31,62,25,66,23,70,17,76,15,82,11,84,163,80,169,72,173,276,383,274,161,34,165,28,167,316,467,310,147,314,141,320,139,330,137,334,135,346,123,350,121,354,115,356,105,362,99,368,97,374,93", "code": "\nfrom sympy import primerange, prime\ndef aupton(terms):\n  alst = [0]\n  for n, pn in enumerate(primerange(1, prime(terms)+1), start=1):\n    x = alst[-1] - pn\n    alst += [x if x > 0 and x not in alst else alst[-1] + pn]\n  return alst\nprint(aupton(60)) \n"}
{"sequence_id": "A064413", "text": "EKG sequence (or ECG sequence): a(1) = 1; a(2) = 2; for n > 2, a(n) = smallest number not already used which shares a factor with a(n-1).", "sequence": "1,2,4,6,3,9,12,8,10,5,15,18,14,7,21,24,16,20,22,11,33,27,30,25,35,28,26,13,39,36,32,34,17,51,42,38,19,57,45,40,44,46,23,69,48,50,52,54,56,49,63,60,55,65,70,58,29,87,66,62,31,93,72,64,68,74,37,111,75,78,76,80,82", "code": "\nfrom fractions import gcd\nA064413_list, l, s, b = [1,2], 2, 3, {}\nfor _ in range(10**5):\n....i = s\n....while True:\n........if not i in b and gcd(i,l) > 1:\n............A064413_list.append(i)\n............l, b[i] = i, True\n............while s in b:\n................b.pop(s)\n................s += 1\n............break\n........i += 1 \n"}
{"sequence_id": "A064419", "text": "a(n) = n for n <= 5; for n > 5, a(n) = smallest number not already used such that gcd(a(n), a(n-1)) >= 5.", "sequence": "1,2,3,4,5,10,15,20,25,30,6,12,18,9,27,36,24,8,16,32,40,35,7,14,21,28,42,48,54,45,50,55,11,22,33,44,66,60,65,13,26,39,52,78,72,56,49,63,70,75,80,64,88,77,84,90,81,99,108,96,102,17,34,51,68,85,95,19,38,57,76,114,120", "code": "\nfrom sympy import gcd\nl=list(range(1, 6))\nfor n in range(5, 101):\n    k=6\n    while k in l or gcd(l[n - 1], k)<5: k+=1\n    l.append(k)\nprint(l) \n"}
{"sequence_id": "A064438", "text": "Numbers which are divisible by the sum of their quaternary digits.", "sequence": "1,2,3,4,6,8,9,12,16,18,20,21,24,28,30,32,33,35,36,40,42,48,50,52,54,60,63,64,66,68,69,72,76,78,80,81,84,88,90,91,96,100,102,108,112,114,120,126,128,129,132,136,138,140,144,148,150,154,156,160,162,168,171,180", "code": "\nfrom sympy.ntheory.factor_ import digits\nprint([n for n in range(1, 201) if n%sum(digits(n, 4)[1:]) == 0]) \n"}
{"sequence_id": "A064484", "text": "Triangle T(n,k), n >= 2, n+1 <= k <= 2*n-1, number of permutations p of 1,...,n, with max(p(i)+p(i-1), i=2..n) = k.", "sequence": "2,2,4,4,8,12,4,32,36,48,8,64,216,192,240,8,208,648,1536,1200,1440,16,416,3024,6144,12000,8640,10080,16,1280,9072,37632,60000,103680,70560,80640,32,2560,38880,150528,456000,622080,987840,645120,725760", "code": "\n\nfrom itertools import permutations\ndef onerow(n):\n..row=[0]*(n-1)\n..for i in permutations(range(1,n+1)):\n....row[max([j[0]+j[1] for j in zip(i,i[1:])])-n-1]+=1\n..return row\n\nrows=[[2]]; row=[2]\nfor i in range(19):\n..row=[(row[j]*(j+2)+sum(row[:j])*2) if (i+j)%2==1 else row[j]*(j+1) for j in range(i+1)]+[row[-1]*(i+2)]\n..rows.append(row)\n\n"}
{"sequence_id": "A064489", "text": "Let p = prime(n); a(n) = smallest m such that prime(m) has p digits.", "sequence": "5,26,1230,78499,455052512,37607912019,279238341033926,24739954287740861,201467286689315906291", "code": "\nfrom sympy import prime, nextprime, primepi\ndef a(n): return primepi(nextprime(10**(prime(n)-1)))\nprint([a(n) for n in range(1, 6)]) \n"}
{"sequence_id": "A064490", "text": "Smallest prime with prime(n) decimal digits.", "sequence": "11,101,10007,1000003,10000000019,1000000000039,10000000000000061,1000000000000000003,10000000000000000000009,10000000000000000000000000331,1000000000000000000000000000057,1000000000000000000000000000000000067", "code": "\nfrom sympy import prime, nextprime, primepi\ndef a(n): return nextprime(10**(prime(n)-1))\nprint([a(n) for n in range(1, 14)]) \n"}
{"sequence_id": "A064532", "text": "Total number of holes in decimal expansion of the number n, assuming 4 has no hole.", "sequence": "1,0,0,0,0,0,1,0,2,1,1,0,0,0,0,0,1,0,2,1,1,0,0,0,0,0,1,0,2,1,1,0,0,0,0,0,1,0,2,1,1,0,0,0,0,0,1,0,2,1,1,0,0,0,0,0,1,0,2,1,2,1,1,1,1,1,2,1,3,2,1,0,0,0,0,0,1,0,2,1,3,2,2,2,2,2,3,2,4,3,2,1,1,1,1,1,2,1,3,2,2,1,1,1,1", "code": "\ndef A064532(n):\n....x=str(n)\n....return x.count(\"0\")+x.count(\"6\")+x.count(\"8\")*2+x.count(\"9\") \n"}
{"sequence_id": "A064538", "text": "a(n) is the smallest positive integer such that a(n)*(1^n + 2^n + ... + x^n) is a polynomial in x with integer coefficients.", "sequence": "1,2,6,4,30,12,42,24,90,20,66,24,2730,420,90,48,510,180,3990,840,6930,660,690,720,13650,1092,378,56,870,60,14322,7392,117810,7140,210,72,1919190,103740,8190,1680,94710,13860,99330,9240,217350,9660,9870,10080,324870", "code": "\nfrom __future__ import division\nfrom sympy.ntheory.factor_ import digits, nextprime\ndef A064538(n):\n    p, m = 2, n+1\n    while p <= (n+2)//(2+ (n% 2)):\n        if sum(d for d in digits(n+1,p)[1:]) >= p:\n            m *= p\n        p = nextprime(p)\n    return m \n"}
{"sequence_id": "A064547", "text": "Sum of binary digits (or count of 1-bits) in the exponents of the prime factorization of n.", "sequence": "0,1,1,1,1,2,1,2,1,2,1,2,1,2,2,1,1,2,1,2,2,2,1,3,1,2,2,2,1,3,1,2,2,2,2,2,1,2,2,3,1,3,1,2,2,2,1,2,1,2,2,2,1,3,2,3,2,2,1,3,1,2,2,2,2,3,1,2,2,3,1,3,1,2,2,2,2,3,1,2,1,2,1,3,2,2,2,3,1,3,2,2,2,2,2,3,1,2,2,2,1,3,1,3,3", "code": "\nfrom sympy import factorint\ndef wt(n): return bin(n).count(\"1\")\ndef a(n):\n    f=factorint(n)\n    return sum([wt(f[i]) for i in f]) \n"}
{"sequence_id": "A064609", "text": "Partial sums of A034448: sum of unitary divisors from 1 to n.", "sequence": "1,4,8,13,19,31,39,48,58,76,88,108,122,146,170,187,205,235,255,285,317,353,377,413,439,481,509,549,579,651,683,716,764,818,866,916,954,1014,1070,1124,1166,1262,1306,1366,1426,1498,1546,1614,1664,1742,1814,1884", "code": "\nfrom sympy.ntheory.factor_ import udivisor_sigma\ndef a(n): return sum(udivisor_sigma(j,1) for j in range(1,n + 1))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A064614", "text": "Exchange 2 and 3 in the prime factorization of n.", "sequence": "1,3,2,9,5,6,7,27,4,15,11,18,13,21,10,81,17,12,19,45,14,33,23,54,25,39,8,63,29,30,31,243,22,51,35,36,37,57,26,135,41,42,43,99,20,69,47,162,49,75,34,117,53,24,55,189,38,87,59,90,61,93,28,729,65,66,67,153,46", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import factorint\ndef A064614(n):\n    return reduce(mul,((5-p if 2<=p<=3 else p)**e for p,e in factorint(n).items())) if n > 1 else n\n\n"}
{"sequence_id": "A064675", "text": "Numbers k such that sopfr(k) = sopf(k+1), where sopf(k) = A008472(k) and sopfr(k) = A001414(k).", "sequence": "5,27,77,714,836,948,1449,4185,4624,5405,5560,8476,8855,10175,16932,17080,18655,20450,20600,21183,26642,28809,31524,35631,37828,37881,40081,47544,48203,49240,52155,52554,53192,63344,63426,63665,79118,80800,81576,83780", "code": "\nfrom sympy import factorint\ndef aupton(terms):\n  alst, k, sopfk, sopfrk, sopfkp1, sopfrkp1 = [], 2, 2, 3, 2, 3\n  while len(alst) < terms:\n    if sopfrk == sopfkp1: alst.append(k)\n    k += 1\n    fkp1 = factorint(k+1)\n    sopfk, sopfkp1 = sopfkp1, sum(p for p in fkp1)\n    sopfrk, sopfrkp1 = sopfrkp1, sum(p*fkp1[p] for p in fkp1)\n  return alst\nprint(aupton(40)) \n"}
{"sequence_id": "A064686", "text": "a(n) = number of n-digit base-3 biquams.", "sequence": "0,2,7,23,73,227,697,2123,6433,19427,58537,176123,529393,1590227,4774777,14332523,43013953,129074627,387289417,1161999323,3486260113,10459304627,31378962457,94138984523,282421147873,847271832227", "code": "\nprint([0]+[3**n - 2**(n-1) for n in range(1,29)])\n\n"}
{"sequence_id": "A064692", "text": "Total number of holes in decimal expansion of the number n, assuming 4 has 1 hole.", "sequence": "1,0,0,0,1,0,1,0,2,1,1,0,0,0,1,0,1,0,2,1,1,0,0,0,1,0,1,0,2,1,1,0,0,0,1,0,1,0,2,1,2,1,1,1,2,1,2,1,3,2,1,0,0,0,1,0,1,0,2,1,2,1,1,1,2,1,2,1,3,2,1,0,0,0,1,0,1,0,2,1,3,2,2,2,3,2,3,2,4,3,2,1,1,1,2,1,2,1,3,2,2,1,1,1,2", "code": "\ndef A064692(n):\n....x=str(n)\n....return x.count(\"0\")+x.count(\"4\")+x.count(\"6\")+x.count(\"8\")*2+x.count(\"9\") \n"}
{"sequence_id": "A064799", "text": "Sum of n-th prime number and n-th composite number.", "sequence": "6,9,13,16,21,25,31,34,39,47,51,58,63,67,72,79,86,89,97,103,106,113,118,125,135,140,143,149,153,158,173,179,186,189,200,203,211,218,223,230,237,241,253,256,261,264,277,291,296,299,305,313,316,327,334,341", "code": "\nfrom sympy import prime, composite\ndef A064799(n): return prime(n)+composite(n) \n"}
{"sequence_id": "A064834", "text": "If n (in base 10) is d_1 d_2 ... d_k then a(n) = Sum_{i = 1..[k/2] } |d_i - d_{k-i+1}|.", "sequence": "0,0,0,0,0,0,0,0,0,0,1,0,1,2,3,4,5,6,7,8,2,1,0,1,2,3,4,5,6,7,3,2,1,0,1,2,3,4,5,6,4,3,2,1,0,1,2,3,4,5,5,4,3,2,1,0,1,2,3,4,6,5,4,3,2,1,0,1,2,3,7,6,5,4,3,2,1,0,1,2,8,7,6,5,4,3,2,1,0,1,9,8,7,6,5,4,3,2,1,0,1,0,1,2,3", "code": "\nfrom sympy import floor, ceiling\ndef A064834(n):\n    x, y = str(n), 0\n    lx2 = len(x)/2\n    for a,b in zip(x[:floor(lx2)],x[:ceiling(lx2)-1:-1]):\n        y += abs(int(a)-int(b))\n    return y\n\n"}
{"sequence_id": "A064901", "text": "Semiprimes p1*p2 such that p2 > p1 and p2 mod p1 = 3.", "sequence": "65,115,119,215,217,265,365,377,413,415,511,515,517,565,629,707,779,815,865,965,1099,1115,1165,1207,1243,1315,1391,1393,1415,1465,1501,1565,1589,1687,1727,1765,1769,1865,1883,1915,1969,1981,2165,2177,2215", "code": "\nfrom sympy import factorint\ndef is_A064901(n):\n    f = factorint(n)\n    return (sum([f[i] for i in f]) == 2) and (max(f) % min(f) == 3)\ndef first_A064901(n):\n    x = 1\n    an = []\n    while len(an) < n:\n        if is_A064901(x): an.append(x)\n        x += 2\n    return an \n"}
{"sequence_id": "A064902", "text": "Semiprimes p1*p2 such that p2 mod p1 = 4, with p2 > p1.", "sequence": "77,95,145,221,295,371,395,407,437,445,469,545,559,649,695,745,763,895,959,995,1057,1133,1145,1159,1195,1253,1345,1351,1513,1517,1679,1745,1795,1841,1895,1939,1945,2021,2045,2095,2101,2195,2245,2249,2395,2429", "code": "\nfrom sympy import factorint\ndef is_A064902(n):\n    f = factorint(n)\n    return (sum([f[i] for i in f]) == 2) and (max(f) % min(f) == 4)\ndef first_A064902(n):\n    x = 1\n    an = []\n    while len(an) < n:\n        if is_A064902(x):an.append(x)\n        n += 2\n    return an \n"}
{"sequence_id": "A064904", "text": "Semiprimes p1*p2 such that p2 mod p1 = 6, with p2 > p1.", "sequence": "91,187,247,287,391,581,667,671,679,913,923,973,1147,1169,1261,1267,1397,1561,1591,1639,1757,1919,1927,1937,2051,2123,2149,2443,2491,2641,2933,2951,3031,3091,3127,3227,3281,3521,3817,3841,3859,4087,4109,4207", "code": "\nfrom sympy import factorint\ndef is_A064904(n):\n    f = factorint(n)\n    return (sum([f[i] for i in f]) == 2) and (max(f) % min(f) == 6) \n"}
{"sequence_id": "A064907", "text": "Semiprimes p1*p2 such that p2 mod p1 = 9.", "sequence": "341,583,731,793,893,1067,1469,1793,1807,1943,2201,2323,2483,2519,2761,3043,3071,3487,3497,3781,4213,4439,4511,4777,4841,4849,4939,5497,5809,5933,5947,6511,6539,6989,7093,7117,7391,7493,7601,7613,7783,7891,7967", "code": "\nfrom sympy import factorint\ndef is_A064907(n):\n    f = factorint(n)\n    return (sum([f[i] for i in f]) == 2) and (max(f) % min(f) == 9)\ndef list_A064907(cnt):\n    inx = 0\n    n = 1\n    an = []\n    while inx < cnt:\n        if is_A064907(n):\n            an.append(n)\n            inx += 1\n        n += 2\n    return an \n"}
{"sequence_id": "A064908", "text": "Semiprimes p1*p2 such that p2 mod p1 = 10, with p2 > p1.", "sequence": "299,473,551,1037,1199,1271,1273,1313,1441,1651,1739,1817,2167,2279,2327,2651,2771,2813,2893,3193,3341,3349,3377,3439,3679,4103,4331,4829,4883,5071,5707,5977,6049,6059,6239,6281,6383,6523,6817,7031,7037,7097", "code": "\nfrom sympy import factorint\ndef is_A064908(n):\n    f = factorint(n)\n    return (sum([f[i] for i in f]) == 2) and (max(f) % min(f) == 10) \n"}
{"sequence_id": "A064909", "text": "Semiprimes p1*p2 such that p2 > p1 and p2 mod p1 = 11.", "sequence": "481,1157,1343,1921,2171,2263,2369,2509,3077,3097,3427,3523,3683,4171,4537,4541,4811,5213,5263,5389,5543,6107,6227,6707,7123,7241,8279,8593,8621,8717,8857,8873,9353,9607,10411,10537,11359,11461,11567,11747,11761,11819", "code": "\nfrom sympy import factorint\ndef is_A064909(n):\n    f = factorint(n)\n    return (sum([f[i] for i in f]) == 2) and (max(f) % min(f) == 11)\ndef first_A064909(n):\n    x = 1\n    an = []\n    while len(an) < n:\n        if is_A064909(x): an.append(x)\n        x += 2\n    return an \n"}
{"sequence_id": "A064940", "text": "Values of k for which A065358(k) is 0.", "sequence": "0,2,6,34,38,42,50,54,78,86,90,106,110,114,834,842,1390,1406,1410,1470,1578,1586,1650,1662,1842,1850,3382,3490,3506,3514,3518,3546,3658,3690,3718,3746,3778,3818,3822,3842,3850,3854,3870,3898,3938,3946,3986,3990", "code": "\nfrom sympy import nextprime\nA064940_list, p, d, n, r = [], 2, -1, 0, False\nwhile n <= 10**6:\n    pn, k = p-n, d if r else -d\n    if 0 < k <= pn:\n        A064940_list.append(n+k-1)\n    d += -pn if r else pn\n    r, n, p = not r, p, nextprime(p) \n"}
{"sequence_id": "A064988", "text": "Multiplicative with a(p^e) = prime(p)^e.", "sequence": "1,3,5,9,11,15,17,27,25,33,31,45,41,51,55,81,59,75,67,99,85,93,83,135,121,123,125,153,109,165,127,243,155,177,187,225,157,201,205,297,179,255,191,279,275,249,211,405,289,363,295,369,241,375,341,459,335,327", "code": "\nfrom sympy import factorint, prime\nfrom operator import mul\ndef a(n): return 1 if n==1 else reduce(mul, [prime(p)**e for p, e in factorint(n).items()])\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A064989", "text": "Multiplicative with a(2^e) = 1 and a(p^e) = prevprime(p)^e for odd primes p.", "sequence": "1,1,2,1,3,2,5,1,4,3,7,2,11,5,6,1,13,4,17,3,10,7,19,2,9,11,8,5,23,6,29,1,14,13,15,4,31,17,22,3,37,10,41,7,12,19,43,2,25,9,26,11,47,8,21,5,34,23,53,6,59,29,20,1,33,14,61,13,38,15,67,4,71,31,18,17,35,22,73,3,16", "code": "\nfrom sympy import factorint, prevprime\nfrom operator import mul\nfrom functools import reduce\ndef a(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==2 else prevprime(i)**f[i] for i in f])\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A065156", "text": "Numbers n such that some Lucas number (A000204) is divisible by n.", "sequence": "1,2,3,4,6,7,9,11,14,18,19,22,23,27,29,31,38,41,43,44,46,47,49,54,58,59,62,67,71,76,79,81,82,83,86,94,98,101,103,107,116,118,121,123,124,127,129,131,134,139,142,151,158,161,162,163,166,167,179,181,191,199", "code": "\na, n = 0, 0\nwhile n < 1000:\n    a, f0, f1, i = a+1, 1, 2, 1\n    if f1%a == 0:\n        n = n+1\n        print(n,a)\n    else:\n        while f0%a != 0 and i <= a:\n            f0, f1, i = f0+f1, f0, i+1\n        if i <= a:\n            n = n+1\n            print(n,a) \n"}
{"sequence_id": "A065190", "text": "Self-inverse permutation of the positive integers: 1 is fixed, followed by an infinite number of adjacent transpositions (n n+1).", "sequence": "1,3,2,5,4,7,6,9,8,11,10,13,12,15,14,17,16,19,18,21,20,23,22,25,24,27,26,29,28,31,30,33,32,35,34,37,36,39,38,41,40,43,42,45,44,47,46,49,48,51,50,53,52,55,54,57,56,59,58,61,60,63,62,65,64,67,66,69,68,71,70,73", "code": " def a(n): return 1 if n<2 else n + (-1)**n \n"}
{"sequence_id": "A065191", "text": "Limit of the recursion B_[k] = T[k](B_[k-1]), where B_[1] = (1,2,3,4,5,...) and T[k] is the transformation that permutes the entries k(2i-1) + j and k(2i) + j for all j = 0,..,k-1 and positive integers i.", "sequence": "1,4,8,3,5,16,18,19,11,2,40,13,15,10,24,29,37,50,12,9,63,28,66,7,33,60,22,31,35,44,26,45,57,80,6,47,109,128,14,39,155,64,48,49,25,32,106,227,53,82,150,139,143,58,78,169,147,198,70,23,131,88,156,75,103,166,192", "code": "\nfor n in range(1,5001):\n..pos = n\n..for k in range(n,1,-1): pos -= k*(-1)**(pos//k)\n..print(n,pos)\n\n"}
{"sequence_id": "A065207", "text": "Two 'Reverse and Add' steps are needed to reach a palindrome.", "sequence": "19,28,37,39,46,48,49,57,58,64,67,73,75,76,82,84,85,91,93,94,109,119,129,139,149,150,152,153,154,159,160,162,163,169,170,172,173,179,189,208,218,219,228,229,238,239,248,250,251,253,258,259,260,261,268,269", "code": "\ndef ra(n): s = str(n); return int(s) + int(s[::-1])\ndef ispal(n): s = str(n); return s == s[::-1]\ndef aupto(limit):\n  alst = []\n  for k in range(limit+1):\n    if ispal(k): continue\n    k2 = ra(k)\n    if ispal(k2): continue\n    if ispal(ra(k2)): alst.append(k)\n  return alst\nprint(aupto(269)) \n"}
{"sequence_id": "A065300", "text": "Numbers n such that sum of divisors is a squarefree number.", "sequence": "1,2,4,5,8,9,13,16,18,20,25,26,29,36,37,41,45,49,50,61,64,72,73,74,80,100,101,104,109,113,116,117,121,122,128,137,144,146,148,157,169,173,180,181,193,196,200,208,218,225,229,234,242,244,256,257,261,277,281", "code": "\nfrom sympy import mobius, divisor_sigma\nfrom sympy.ntheory.factor_ import core\n[n for n in range(1,301) if abs(mobius(divisor_sigma(n, 1))) == 1] \n[n for n in range(1,301) if core(divisor_sigma(n,1)) == divisor_sigma(n,1)] \n"}
{"sequence_id": "A065301", "text": "Both n and the sum of its divisors are squarefree numbers.", "sequence": "1,2,5,13,26,29,37,41,61,73,74,101,109,113,122,137,146,157,173,181,193,218,229,257,277,281,313,314,317,353,362,373,386,389,397,401,409,421,433,457,458,461,509,541,554,569,601,613,617,626,641,653,661,673,677", "code": "\nfrom sympy import divisor_sigma\nfrom sympy.ntheory.factor_ import core\ndef issquarefree(n): return core(n)==n\nprint([n for n in range(1, 1001) if issquarefree(n) and issquarefree(divisor_sigma(n,1))]) \n"}
{"sequence_id": "A065303", "text": "Neither n nor sigma(n) is squarefree.", "sequence": "12,24,27,28,32,40,44,48,52,54,56,60,63,68,75,76,81,84,88,90,92,96,98,99,108,112,120,124,125,126,132,135,136,140,147,150,152,153,156,160,162,164,168,171,172,175,176,184,188,189,192,198,204,207,212,216,220", "code": "\nfrom sympy import divisor_sigma\nfrom sympy.ntheory.factor_ import core\ndef is_squarefree(n): return core(n) == n\nprint([i for i in range(1, 251) if not is_squarefree(i) and not is_squarefree(divisor_sigma(i,1))]) \n"}
{"sequence_id": "A065359", "text": "Alternating bit sum for n: replace 2^k with (-1)^k in binary expansion of n.", "sequence": "0,1,-1,0,1,2,0,1,-1,0,-2,-1,0,1,-1,0,1,2,0,1,2,3,1,2,0,1,-1,0,1,2,0,1,-1,0,-2,-1,0,1,-1,0,-2,-1,-3,-2,-1,0,-2,-1,0,1,-1,0,1,2,0,1,-1,0,-2,-1,0,1,-1,0,1,2,0,1,2,3,1,2,0,1,-1,0,1,2,0,1,2,3,1,2,3,4,2,3,1,2,0,1,2,3,1,2,0,1,-1,0,1,2,0,1,-1,0,-2", "code": "\ndef a(n):\n    return sum((-1)**k for k, bi in enumerate(bin(n)[2:][::-1]) if bi=='1')\nprint([a(n) for n in range(107)]) \n"}
{"sequence_id": "A065363", "text": "Sum of balanced ternary digits in n. Replace 3^k with 1 in balanced ternary expansion of n.", "sequence": "0,1,0,1,2,-1,0,1,0,1,2,1,2,3,-2,-1,0,-1,0,1,0,1,2,-1,0,1,0,1,2,1,2,3,0,1,2,1,2,3,2,3,4,-3,-2,-1,-2,-1,0,-1,0,1,-2,-1,0,-1,0,1,0,1,2,-1,0,1,0,1,2,1,2,3,-2,-1,0,-1,0,1,0,1,2,-1,0,1,0,1,2,1,2,3,0,1,2,1,2,3,2,3,4,-1,0,1,0,1,2,1,2,3,0,1,2,1,2", "code": "\ndef a(n):\n    s=0\n    x=0\n    while n>0:\n        x=n%3\n        n=n//3\n        if x==2:\n            x=-1\n            n+=1\n        s+=x\n    return s\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A065368", "text": "Alternating sum of ternary digits in n. Replace 3^k with (-1)^k in ternary expansion of n.", "sequence": "0,1,2,-1,0,1,-2,-1,0,1,2,3,0,1,2,-1,0,1,2,3,4,1,2,3,0,1,2,-1,0,1,-2,-1,0,-3,-2,-1,0,1,2,-1,0,1,-2,-1,0,1,2,3,0,1,2,-1,0,1,-2,-1,0,-3,-2,-1,-4,-3,-2,-1,0,1,-2,-1,0,-3,-2,-1,0,1,2,-1,0,1,-2,-1,0,1,2,3,0,1,2,-1,0,1,2,3,4,1,2,3,0,1,2,3,4,5,2,3", "code": "\nfrom sympy.ntheory.digits import digits\ndef a(n):\n    return sum(bi*(-1)**k for k, bi in enumerate(digits(n, 3)[1:][::-1]))\nprint([a(n) for n in range(104)]) \n"}
{"sequence_id": "A065428", "text": "Numbers k such that no x^2 mod k is prime.", "sequence": "1,2,3,4,5,8,12,15,16,24,28,40,48,56,60,72,88,112,120,168,232,240,280,312,408,520,760,840,1320,1848", "code": "\nfrom sympy import isprime\ndef ok(n): return not any(isprime((x**2)%n) for x in range(2, n))\nprint(list(filter(ok, range(1, 2000)))) \n"}
{"sequence_id": "A065585", "text": "Smallest prime beginning with exactly n 2's.", "sequence": "3,2,223,2221,22229,2222203,22222253,22222223,222222227,22222222273,22222222223,2222222222243,22222222222201,22222222222229,222222222222227,222222222222222043,222222222222222281,222222222222222221,22222222222222222253,222222222222222222277", "code": "\nfrom sympy import isprime\ndef a(n):\n  if n < 2: return list([3, 2])[n]\n  n2s, i, pow10, end_digits = int('2'*n), 1, 1, 0\n  while True:\n    i = 1\n    while i < pow10:\n      istr = str(i)\n      if istr[0] == '2' and len(istr) == end_digits:\n        i += pow10 // 10\n      else:\n        t = n2s * pow10 + i\n        if isprime(t): return t\n        i += 2\n    pow10 *= 10; end_digits += 1\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A065588", "text": "Smallest prime beginning with exactly n 5's.", "sequence": "2,5,557,5557,555521,555557,55555517,55555553,5555555501,5555555557,5555555555057,555555555551,5555555555551,555555555555529,555555555555557,55555555555555519,5555555555555555021,555555555555555559,55555555555555555567,5555555555555555555087", "code": "\nfrom sympy import isprime\ndef a(n):\n  if n < 2: return list([2, 5])[n]\n  n5s, i, pow10, end_digits = int('5'*n), 1, 1, 0\n  while True:\n    i = 1\n    while i < pow10:\n      istr = str(i)\n      if istr[0] == '5' and len(istr) == end_digits:\n        i += 2 if pow10 <= 10 else pow10 // 10\n      else:\n        t = n5s * pow10 + i\n        if isprime(t): return t\n        i += 2\n    pow10 *= 10; end_digits += 1\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A065620", "text": "a(0)=0; thereafter a(2n) = 2a(n), a(2n+1) = -2a(n) + 1.", "sequence": "0,1,2,-1,4,-3,-2,3,8,-7,-6,7,-4,5,6,-5,16,-15,-14,15,-12,13,14,-13,-8,9,10,-9,12,-11,-10,11,32,-31,-30,31,-28,29,30,-29,-24,25,26,-25,28,-27,-26,27,-16,17,18,-17,20,-19,-18,19,24,-23,-22,23,-20,21,22,-21,64,-63,-62,63,-60,61,62,-61,-56", "code": "\ndef a(n): return n if n<3 else 2*a(n/2) if n%2==0 else -2*a((n - 1)/2) + 1 \n"}
{"sequence_id": "A065621", "text": "Reversing binary representation of n. Converting sum of powers of 2 in binary representation of a(n) to alternating sum gives n.", "sequence": "1,2,7,4,13,14,11,8,25,26,31,28,21,22,19,16,49,50,55,52,61,62,59,56,41,42,47,44,37,38,35,32,97,98,103,100,109,110,107,104,121,122,127,124,117,118,115,112,81,82,87,84,93,94,91,88,73,74,79,76,69,70,67,64,193", "code": "\ndef a(n): return n^(2*(n - (n & -n))) \n"}
{"sequence_id": "A065642", "text": "a(1) = 1; for n > 1, a(n) = Min {m > n | m has same prime factors as n ignoring multiplicity}.", "sequence": "1,4,9,8,25,12,49,16,27,20,121,18,169,28,45,32,289,24,361,40,63,44,529,36,125,52,81,56,841,60,961,64,99,68,175,48,1369,76,117,50,1681,84,1849,88,75,92,2209,54,343,80,153,104,2809,72,275,98,171,116,3481,90,3721", "code": "\nfrom sympy import primefactors, prod\ndef a007947(n): return 1 if n < 2 else prod(primefactors(n))\ndef a(n):\n    if n==1: return 1\n    r=a007947(n)\n    n += r\n    while a007947(n)!=r:\n        n+=r\n    return n\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A065710", "text": "Number of 2's in decimal expansion of 2^n.", "sequence": "0,1,0,0,0,1,0,1,1,1,1,1,0,1,0,1,0,1,2,2,0,2,0,0,1,1,0,2,1,1,1,1,2,1,0,0,0,1,1,0,1,4,0,3,1,2,0,1,1,3,3,3,1,2,0,1,2,1,2,2,2,3,1,3,0,2,2,3,3,2,2,4,4,4,0,1,2,4,3,1,3,6,2,0,2,4,4,4,2,3,6,2,1,5,1,2,4,4,1,2,6", "code": "\ndef A065710(n):\n    return str(2**n).count('2') \n"}
{"sequence_id": "A065712", "text": "Number of 1's in decimal expansion of 2^n.", "sequence": "1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,2,1,0,1,1,1,0,2,0,1,2,0,1,2,1,0,0,3,0,1,1,0,1,3,1,3,0,3,1,1,1,2,2,2,2,0,1,3,1,0,4,4,0,3,1,3,0,3,3,0,2,2,3,6,3,1,0,2,3,3,5,1,1,5,3,1,2,5,1,4,2,2,5,2,0,5,3,1,6,2,2,4,5,2", "code": "\ndef A065712(n):\n    return str(2**n).count('1') \n"}
{"sequence_id": "A065714", "text": "Number of 3's in decimal expansion of 2^n.", "sequence": "0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,3,0,1,1,1,1,1,0,1,0,4,1,3,0,1,0,1,1,1,0,3,1,3,0,2,0,1,2,0,1,2,2,0,2,3,0,4,1,3,1,4,2,1,1,1,2,3,2,3,1,2,4,1,4,3,0,3,2,3,4,4,3,3,2,1,3,0,0,4,2,2,6,1,4,4,2", "code": "\ndef A065714(n):\n    return str(2**n).count('3') \n"}
{"sequence_id": "A065715", "text": "Number of 4's in decimal expansion of 2^n.", "sequence": "0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,2,1,1,0,3,0,0,2,1,1,2,0,2,3,2,1,1,1,1,2,3,1,0,0,3,0,3,1,3,2,2,2,2,1,2,2,3,0,1,2,2,3,2,1,3,1,4,3,3,2,1,0,3,4,3,4,4,0,2,2,4,3,2,3,4,3,2,0,2,4,3,3,4,5,3,2,3,1,3,1,3,3,2", "code": "\ndef A065715(n):\n    return str(2**n).count('4') \n"}
{"sequence_id": "A065716", "text": "Number of 5's in decimal expansion of 2^n.", "sequence": "0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,2,0,0,1,1,1,0,0,0,2,0,0,2,1,0,0,0,2,0,1,0,1,0,3,1,4,1,0,1,1,0,2,1,2,1,2,2,1,1,0,2,4,1,2,2,2,0,2,2,0,0,3,5,5,1,0,1,1,3,2,4,3,3,2,1,3,3,2,1,3,4,4,3,1,1,3,4,1,3,2,4,5,5,2,2", "code": "\ndef A065716(n):\n    return str(2**n).count('5') \n"}
{"sequence_id": "A065717", "text": "Number of 6's in decimal expansion of 2^n.", "sequence": "0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,2,0,1,0,1,0,0,1,2,0,2,0,2,1,0,1,2,0,1,1,3,0,1,0,2,0,1,1,2,0,3,0,3,1,2,1,2,0,0,3,1,0,1,2,4,1,3,1,3,1,4,2,1,1,1,3,6,1,1,3,2,2,3,2,4,1,2,4,3,6,3,2,2,4,0,1,4,0,3,4,3,3,2,3,5", "code": "\ndef A065717(n):\n    return str(2**n).count('6') \n"}
{"sequence_id": "A065718", "text": "Number of 7's in decimal expansion of 2^n.", "sequence": "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,0,3,0,1,2,0,1,2,1,1,0,2,1,3,2,3,1,3,0,0,1,1,1,4,2,3,0,0,1,2,2,0,2,4,2,3,2,1,0,2,3,3,1,3,3,2,2,2,0,1,3,2,5,3,3,2,2,3,1,3,3,1,2,4,2,2,2,2,5,2,1,2,5,2,4,4,2,3", "code": "\ndef A065718(n):\n    return str(2**n).count('7') \n"}
{"sequence_id": "A065719", "text": "Number of 8's in decimal expansion of 2^n.", "sequence": "0,0,0,1,0,0,0,1,0,0,0,1,0,1,1,1,0,0,0,2,1,0,0,4,0,0,2,1,1,1,1,2,0,2,2,2,1,1,1,4,0,0,1,2,1,4,1,3,1,0,2,3,0,0,4,3,0,4,2,2,1,1,3,3,1,3,3,2,2,2,1,4,2,0,7,3,1,4,0,4,2,2,5,1,4,3,1,1,4,1,3,6,1,1,7,3,1,5,1,4,1", "code": "\ndef A065719(n):\n    return str(2**n).count('8') \n"}
{"sequence_id": "A065744", "text": "Number of 9's in the decimal expansion of 2^n.", "sequence": "0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,3,3,2,1,1,1,2,1,2,2,1,2,1,0,0,0,1,3,3,2,3,5,3,3,3,0,0,0,2,3,1,1,1,2,2,3,3,2,1,0,2,5,2,3,2,0,2,2,3,3,1,4,3,2,1,2,2,4,4,2,6,8,3,3,3,1,1,0,2", "code": "\ndef A065744(n):\n    return str(2**n).count('9')  \n"}
{"sequence_id": "A065766", "text": "Sum of divisors of twice a square number, divided by three.", "sequence": "1,5,13,21,31,65,57,85,121,155,133,273,183,285,403,341,307,605,381,651,741,665,553,1105,781,915,1093,1197,871,2015,993,1365,1729,1535,1767,2541,1407,1905,2379,2635,1723,3705,1893,2793,3751,2765,2257,4433,2801", "code": "\nfrom sympy import divisor_sigma\nfor n in range(1,50): print(divisor_sigma(2*n**2,1)/3) \n"}
{"sequence_id": "A065847", "text": "Let u be any string of n digits from {0,...,5}; let f(u) = number of distinct primes, not beginning with 0, formed by permuting the digits of u; then a(n) = max_u f(u).", "sequence": "1,2,4,8,21,60,269,1147,4250,17883,71966,342060,1724337,8428101", "code": "\nfrom sympy import isprime\nfrom sympy.utilities.iterables import multiset_permutations\nfrom itertools import combinations_with_replacement\ndef A065847(n):\n    return max(sum(1 for t in multiset_permutations(s) if t[0] != '0' and isprime(int(''.join(t),6))) for s in combinations_with_replacement('012345',n)) \n"}
{"sequence_id": "A065855", "text": "Number of composites <= n.", "sequence": "0,0,0,1,1,2,2,3,4,5,5,6,6,7,8,9,9,10,10,11,12,13,13,14,15,16,17,18,18,19,19,20,21,22,23,24,24,25,26,27,27,28,28,29,30,31,31,32,33,34,35,36,36,37,38,39,40,41,41,42,42,43,44,45,46,47,47,48,49,50,50,51,51,52,53", "code": "\nfrom sympy import primepi\ndef A065855(n):\n    return 0 if n < 4 else n - primepi(n) - 1 \n"}
{"sequence_id": "A065899", "text": "a(n) is the index of the n-th compositorial number, A036691(n), in the sequence of composites (A002808).", "sequence": "1,14,148,1458,15293,188782,2692726,40909988,660637057,11976280879,240871231369,5080851687840,112183659405198,2700581280109040,67686358108129808,1763651979163805444,47707175694652299653,1337959106215345951164,40196133912310028013721,1287910861213828031657392", "code": "\nfrom sympy import factorial, primepi, composite, primorial, compositepi\ndef A065899(n):\n    return compositepi(factorial(composite(n))//primorial(primepi(composite(n)))) \n"}
{"sequence_id": "A065914", "text": "Number of primes in the interval [ 1/2 * q(n), 3/2 * q(n) - 1 ] where q(n) is prime(n)#, the n-th primorial.", "sequence": "1,3,8,38,294,2922,38949,604764,11635147,287020007,7721129740,250811981714", "code": "\nfrom __future__ import division\nfrom sympy import primepi, primorial\ndef A065914(n):\n    pm = primorial(n)\n    return primepi(3*pm//2-1)-primepi(pm//2-1) \n"}
{"sequence_id": "A065925", "text": "Smallest k such that sopf(n+k) = sopf(k), where sopf = A008472.", "sequence": "5,2,7,4,114,2,5,8,13,10,25,4,5,2,19,16,85,6,5,5,209,22,25,3,493,26,31,4,20,2,5,32,7,34,516,12,33,38,10,10,99,6,5,44,57,46,25,6,5,50,49,52,52,18,855,8,61,58,295,4,261,2,91,64,602,6,5,68,21,10,25,9,7,74,13,76", "code": "\nfrom sympy import primefactors\nfrom itertools import count, dropwhile\ndef sopf(n): return sum(p for p in primefactors(n))\ndef a(n):\n  k = 1\n  while sopf(n+k) != sopf(k): k += 1\n  return k\nprint([a(n) for n in range(1, 77)]) \n"}
{"sequence_id": "A066007", "text": "a(n) is that n-digit number m which minimizes m/(sum of digits of m); in case of a tie pick the smallest.", "sequence": "1,19,199,1099,10999,109999,1099999,10999999,109999999,1099999999,10999999999,109999999999,1099999999999,10999999999999,100999999999999,1009999999999999,10099999999999999,100999999999999999,1009999999999999999,10099999999999999999", "code": "\ndef k(r): return (10**r - 1)//9 + r + 2\ndef a(n):\n  r = 0\n  while k(r+1) <= n: r += 1\n  return int('1' + '0'*r + '9'*(n-r-1))\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A066008", "text": "Number of n-digit positive integers m for which m/(sum of digits of m) is an integer, sometimes referred to as Niven or Harshad numbers.", "sequence": "9,23,180,1325,10334,83556,710667,6148698,54619717,491432596,4471325309,40951585117", "code": "\ndef sd(m): return sum(map(int, str(m)))\ndef is_harshad(m): return m > 0 and m%sd(m) == 0\ndef a(n): return sum(is_harshad(m) for m in range(10**(n-1), 10**n))\nprint([a(n) for n in range(1, 7)]) \n"}
{"sequence_id": "A066032", "text": "Number of ways to write n as a product with no factor larger than m (1 <= m <=n, written row by row).", "sequence": "1,0,1,0,0,1,0,1,1,2,0,0,0,0,1,0,0,1,1,1,2,0,0,0,0,0,0,1,0,1,1,2,2,2,2,3,0,0,1,1,1,1,1,1,2,0,0,0,0,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0,1,0,0,1,2,2,3,3,3,3,3,3,4,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,2", "code": "\nfrom sympy import divisors, isprime\ndef T(n, m):\n    if isprime(n): return 1 if n<=m else 0\n    A=(d for d in divisors(n)[1:-1] if d <= m)\n    s=sum(T(n//d, d) for d in A)\n    return s + 1 if n<=m else s\nfor n in range(1, 21): print([T(n, m) for m in range(1, n + 1)]) \n"}
{"sequence_id": "A066058", "text": "In base 2: smallest integer which requires n 'Reverse and Add' steps to reach a palindrome.", "sequence": "0,2,11,44,19,20,275,326,259,202,103,74,1027,1070,1049,1072,1547,1310,1117,794,569,398,3083,2154,1177,1064,4697,4264,4443,2678,2169,1422,779,3226,1551,1114,1815,1062,4197,3106,8697,7238,16633,12302,6683", "code": "\ndef A066058(n):\n....if n > 0:\n........k = 0\n........while True:\n............m = k\n............for i in range(n):\n................s1 = format(m,'b')\n................s2 = s1[::-1]\n................if s1 == s2:\n....................break\n................m += int(s2,2)\n............else:\n................s1 = format(m,'b')\n................if s1 == s1[::-1]:\n....................return k\n............k += 1\n....else:\n........return 0 \n"}
{"sequence_id": "A066199", "text": "a(1) = 1; for n > 1, a(n) = a(n-1)-(n+1) if this is positive and has not already appeared in the sequence, otherwise a(n) = a(n-1)+(n+1).", "sequence": "1,4,8,3,9,2,10,19,29,18,6,19,5,20,36,53,35,16,36,15,37,14,38,13,39,12,40,11,41,72,104,71,105,70,34,71,33,72,32,73,31,74,30,75,121,168,120,169,119,68,120,67,121,66,122,65,7,66,126,187,125,62,126,61,127,60,128", "code": "\nl=[0, 1]\nfor n in range(2, 101):\n    x=l[n - 1] - (n + 1)\n    if x>0 and x not in l: l.append(x)\n    else: l.append(l[n - 1] + (n + 1))\nprint(l[1:]) \n"}
{"sequence_id": "A066200", "text": "a(1) = 1; for n > 1, a(n) = a(n-1)-(n+2) if this is positive and has not already appeared, otherwise a(n) = a(n-1)+(n+2).", "sequence": "1,5,10,4,11,3,12,2,13,25,38,24,9,25,8,26,7,27,6,28,51,75,50,76,49,21,50,20,51,19,52,18,53,17,54,16,55,15,56,14,57,101,146,100,147,99,148,98,47,99,46,100,45,101,44,102,43,103,42,104,41,105,40,106,39,107,176", "code": "\nl=[0, 1]\nfor n in range(2, 101):\n    x=l[n - 1] - (n + 2)\n    if x>0 and x not in l: l.append(x)\n    else: l.append(l[n - 1] + (n + 2))\nprint(l[1:]) \n"}
{"sequence_id": "A066203", "text": "a(1) = 2; a(2) = 1; for n > 2, a(n) = a(n-1)-(n-1) if this is positive and has not already appeared in the sequence, otherwise a(n) = a(n-1)+(n-1).", "sequence": "2,1,3,6,10,5,11,4,12,21,31,20,8,21,7,22,38,55,37,18,38,17,39,16,40,15,41,14,42,13,43,74,106,73,107,72,36,73,35,74,34,75,33,76,32,77,123,170,122,171,121,70,122,69,123,68,124,67,9,68,128,189,127,64,128,63,129,62", "code": "\nl=[0, 2, 1]\nfor n in range(3, 101):\n    x=l[n - 1] - (n - 1)\n    if x>0 and x not in l: l.append(x)\n    else: l.append(l[n - 1] + (n - 1))\nprint(l[1:]) \n"}
{"sequence_id": "A066272", "text": "Number of anti-divisors of n.", "sequence": "0,0,1,1,2,1,3,2,2,3,3,2,4,3,3,2,5,4,3,3,3,5,5,2,5,3,5,5,3,3,5,6,5,3,5,2,5,7,5,4,4,5,5,3,7,5,5,3,6,6,3,7,7,3,5,3,5,7,7,6,4,5,7,2,5,5,9,7,3,5,5,6,7,5,5,5,9,5,3,5,6,7,7,4,8,5,7,7,3,5,5,5,7,9,9,1,7,8,5,4,5,7,7,7,9", "code": "\nfrom sympy import divisors\ndef A066272(n):\n    return len([d for d in divisors(2*n) if n > d >=2 and n%d]) +  len([d for d in divisors(2*n-1) if n > d >=2 and n%d]) +  len([d for d in divisors(2*n+1) if n > d >=2 and n%d]) \n"}
{"sequence_id": "A066318", "text": "Number of necklaces with n labeled beads of 2 colors.", "sequence": "2,4,16,96,768,7680,92160,1290240,20643840,371589120,7431782400,163499212800,3923981107200,102023508787200,2856658246041600,85699747381248000,2742391916199936000,93241325150797824000,3356687705428721664000,127554132806291423232000", "code": " import math\nfor n in range(1,10): print(math.factorial(n-1)*2**n, end=', ') \n"}
{"sequence_id": "A066321", "text": "Binary representation of base-(i-1) expansion of n: replace i-1 with 2 in base-(i-1) expansion of n.", "sequence": "0,1,12,13,464,465,476,477,448,449,460,461,272,273,284,285,256,257,268,269,3280,3281,3292,3293,3264,3265,3276,3277,3088,3089,3100,3101,3072,3073,3084,3085,3536,3537,3548,3549,3520,3521,3532,3533,3344,3345,3356", "code": "\nfrom gmpy2 import c_divmod\nu = ('0000','1000','0011','1011')\ndef A066321(n):\n    if n == 0:\n        return 0\n    else:\n        s, q = '', n\n        while q:\n            q, r = c_divmod(q, -4)\n            s += u[r]\n        return int(s[::-1],2) \n"}
{"sequence_id": "A066325", "text": "Coefficients of unitary Hermite polynomials He_n(x).", "sequence": "1,0,1,-1,0,1,0,-3,0,1,3,0,-6,0,1,0,15,0,-10,0,1,-15,0,45,0,-15,0,1,0,-105,0,105,0,-21,0,1,105,0,-420,0,210,0,-28,0,1,0,945,0,-1260,0,378,0,-36,0,1,-945,0,4725,0,-3150,0,630,0,-45,0,1,0,-10395,0,17325,0,-6930,0,990,0,-55,0,1", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef H(n, x): return 1 if n==0 else x if n==1 else x*H(n - 1, x) - (n - 1)*H(n - 2, x)\ndef a(n): return Poly(H(n, x), x).all_coeffs()[::-1]\nfor n in range(21): print(a(n)) \n"}
{"sequence_id": "A066369", "text": "Number of subsets of {1, ..., n} with no four terms in arithmetic progression.", "sequence": "1,2,4,8,15,29,56,103,192,364,668,1222,2233,3987,7138,12903,22601,40200,71583,125184,218693,386543,670989,1164385,2021678,3462265,5930954,10189081,17266616,29654738,50912618,86017601,145327544,247555043,415598432,698015188", "code": "\nfrom sympy import subsets\ndef noap4(n):\n    avoid=list()\n    for skip in range(1,(n+2)//3):\n        for start in range (1,n+1-3*skip):\n            avoid.append(set({start,start+skip,start+2*skip,start+3*skip}))\n    s=list()\n    for i in range(4):\n        for smallset in subsets(range(1,n+1),i):\n            s.append(smallset)\n    for i in range(4,n+1):\n        for temptuple in subsets(range(1,n+1),i):\n            tempset=set(temptuple)\n            status=True\n            for avoidset in avoid:\n                if avoidset <= tempset:\n                    status=False\n                    break\n            if status:\n                s.append(tempset)\n    return s\n\ndef a(n):\n    return len(noap4(n)) \n"}
{"sequence_id": "A066411", "text": "Form a triangle with the numbers [0..n] on the base, where each number is the sum of the two below; a(n) is the number of different possible values for the apex.", "sequence": "1,1,3,5,23,61,143,215,995,2481,5785,12907,29279,64963,144289,158049,683311,1471123,3166531,6759177,14404547,30548713", "code": "\nfrom sympy import binomial\ndef partitionpairs(xlist): \n    if len(xlist) <= 2:\n        yield [sum(xlist)]\n    else:\n        m = len(xlist)\n        for i in range(m-1):\n            for j in range(i+1,m):\n                rem = xlist[:i]+xlist[i+1:j]+xlist[j+1:]\n                y = [xlist[i]+xlist[j]]\n                for d in partitionpairs(rem):\n                    yield y+d\ndef A066411(n):\n    b = [binomial(n,k) for k in range(n//2+1)]\n    return len(set((sum(d[i]*b[i] for i in range(n//2+1)) for d in partitionpairs(list(range(n+1)))))) \n"}
{"sequence_id": "A066417", "text": "Sum of anti-divisors of n.", "sequence": "0,0,2,3,5,4,10,8,8,14,12,13,19,16,18,14,28,28,18,24,22,36,34,23,39,24,42,46,24,36,42,58,48,30,52,32,50,70,52,55,41,66,56,40,86,58,60,56,72,80,42,94,88,52,74,56,74,96,90,107,57,78,112,46,84,86,132,112,54,102", "code": "\nfrom sympy import divisors\nA066417 = [sum([2*d for d in divisors(n) if n > 2*d and n%(2*d)] + [d for d in divisors(2*n-1) if n > d >=2 and n%d] + [d for d in divisors(2*n+1) if n > d >=2 and n%d]) for n in range(1,10**6)] \n"}
{"sequence_id": "A066419", "text": "Numbers k such that k! is not divisible by the sum of the decimal digits of k!.", "sequence": "432,444,453,458,474,476,485,489,498,507,509,532,539,541,548,550,552,554,555,556,560,565,567,576,593,597,603,608,609,610,611,612,613,624,630,632,634,640,645,657,663,665,683,685,686,692,698,703,706,708,714", "code": "\nfrom math import factorial\ndef sd(n): return sum(map(int, str(n)))\ndef ok(f): return f%sd(f) != 0\nprint([n for n in range(1, 715) if ok(factorial(n))]) \n"}
{"sequence_id": "A066425", "text": "Smallest increasing sequence (with a(1) = 1) such that a(n) minus any sum of distinct earlier terms is not already in the sequence.", "sequence": "1,3,8,18,41,84,181,364,751,1512,3037,6107,12216,24547,49117,98236,196544,393178,786407,1573201,3146426,6292969,12586763,25173709,50347996,100696725,201393664,402788102,805576428,1611153169,3222306562", "code": " def solve(n,arr,dupl):\n..s = [i for i in seq if i <= n and i > n//(3-dupl)]\n..if n in s: return 1\n..for i in s:\n....if i in arr and dupl: continue\n....ar = arr.copy() + [i]\n....if solve(n-i,ar,i in arr or dupl): return 1\n..return 0\nseq = [0]\nfor n in range(70):\n..k = 2*seq[-1]+1\n..while solve(k,[],0): k += 1\n..print(n+1,k)\n..seq.append(k)\n\n"}
{"sequence_id": "A066452", "text": "Anti-phi(n).", "sequence": "1,1,2,1,4,1,4,4,3,2,8,3,7,7,9,2,8,5,10,10,8,6,19,6,12,9,9,8,22,9,12,12,15,10,31,9,11,14,24,13,23,9,24,17,16,10,35,15,23,25,20,12,40,17,34,21,18,14,37,17,24,25,41,20,39,14,31,34,33,18,42,16,32,37,41,18,44,25", "code": "\ndef A066452(n):\n....return len([x for x in range(1,n) if all([x % d  for d in range(2,n) if (n % d) and (2*n) % d in [d-1,0,1]])]) \n"}
{"sequence_id": "A066459", "text": "Product of factorials of the digits of n.", "sequence": "1,1,2,6,24,120,720,5040,40320,362880,1,1,2,6,24,120,720,5040,40320,362880,2,2,4,12,48,240,1440,10080,80640,725760,6,6,12,36,144,720,4320,30240,241920,2177280,24,24,48,144,576,2880,17280,120960,967680", "code": "\nimport math\ndef A066459(n):\n    s=1\n    for i in str(n):\n        s*=math.factorial(int(i))\n    return s \n"}
{"sequence_id": "A066467", "text": "Numbers having just two anti-divisors.", "sequence": "5,8,9,12,16,24,36,64,576,4096,65536,262144,1073741824,39582418599936,1152921504606846976,41505174165846491136,85070591730234615865843651857942052864,14809541015890854379394722643016154544844622790702218770137481216", "code": "\nfrom sympy.ntheory.factor_ import antidivisor_count\nA066467_list = [n for n in range(1,10**5) if antidivisor_count(n) == 2]\n\n"}
{"sequence_id": "A066469", "text": "Numbers having exactly four anti-divisors.", "sequence": "13,18,40,41,61,84,100,169,289,421,784,1024,1104,1296,3121,5776,9216,12544,12769,13924,16129,17956,24649,32761,33024,35344,36721,36864,38809,71821,75076,106261,110224,119716,135721,147456,167281,175561,199081,232324,237169", "code": "\nfrom sympy.ntheory.factor_ import antidivisor_count\nA066469_list = [n for n in range(1,10**3) if antidivisor_count(n) == 4] \n"}
{"sequence_id": "A066472", "text": "Numbers having exactly six anti-divisors.", "sequence": "32,49,50,60,72,81,121,128,145,180,181,196,264,288,324,361,480,529,684,685,961,1156,1405,2304,2401,2500,2521,2704,2809,4624,4705,5041,5184,7396,8064,8581,9385,10816,11881,13456,14281,25600,26569,27556,34585", "code": "\nfrom sympy.ntheory.factor_ import antidivisor_count\nA066472_list = [n for n in range(1,10**5) if antidivisor_count(n) == 6] \n"}
{"sequence_id": "A066527", "text": "Triangular numbers that for some k are also the sum of the first k primes.", "sequence": "10,28,133386,4218060,54047322253,14756071005948636,600605016143706003,41181981873797476176,240580227206205322973571,1350027226921161196478736", "code": "\nfrom sympy import integer_nthroot, isprime, nextprime\ndef istri(n): return integer_nthroot(8*n+1, 2)[1]\ndef afind(limit):\n    s, p = 2, 2\n    while s < limit:\n        if istri(s): print(s, end=\", \")\n        p = nextprime(p)\n        s += p\nafind(10**11) \n"}
{"sequence_id": "A066620", "text": "Number of unordered triples of distinct pairwise coprime divisors of n.", "sequence": "0,0,0,0,0,1,0,0,0,1,0,2,0,1,1,0,0,2,0,2,1,1,0,3,0,1,0,2,0,7,0,0,1,1,1,4,0,1,1,3,0,7,0,2,2,1,0,4,0,2,1,2,0,3,1,3,1,1,0,13,0,1,2,0,1,7,0,2,1,7,0,6,0,1,2,2,1,7,0,4,0,1,0,13,1,1,1,3,0,13,1,2,1,1,1,5,0,2,2,4,0,7,0", "code": "\nfrom sympy import divisor_count as d\ndef a(n): return (d(n**3) - 3*d(n) + 2)/6 \n"}
{"sequence_id": "A066711", "text": "RATS: Reverse Add Then Sort the digits applied to previous term, starting with 9.", "sequence": "9,18,99,189,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117,288,117", "code": "\nfrom itertools import accumulate\ndef rats(anm1, _):\n    return int(\"\".join(sorted(str(anm1 + int(str(anm1)[::-1])))))\nprint(list(accumulate([9]*49, rats))) \n"}
{"sequence_id": "A066713", "text": "RATS(2^n): Reverse Add the digits of 2^n, Then Sort: a(n) = A036839(2^n).", "sequence": "2,4,8,16,77,55,11,499,89,277,2255,145,11,1111,44567,111499,12299,1234,3467,113467,677789,144556,1222889,14445667,4577789,55669999,1134899,11356999,12237899,445557799,1223555555,11113366,1122222266", "code": "\ndef A066713(n):\n    m = 2**n\n    return int(''.join(sorted(str(m+int(str(m)[::-1]))))) \n"}
{"sequence_id": "A066736", "text": "Least number > 1 such that the nonzero product of the digits of its n-th power is also an n-th power.", "sequence": "2,2,2,118,382,580408,178758,12,1254514,53067715,51773525,314537797,110242999", "code": "\nimport sympy\nfrom sympy import factorint\ndef DigitProd(x):\n..total = 1\n..for i in str(x):\n....total *= int(i)\n..return total\ndef Prod(x):\n..n = 2\n..while n < 4*(10**8):\n....if DigitProd(n**x) != 0 and DigitProd(n**x) != 1:\n......count = 0\n......for i in list(factorint(DigitProd(n**x)).values()):\n........if (int(i)/x) % 1 == 0:\n..........count += 1\n........else:\n..........break\n......if count == len(list(factorint(DigitProd(n**x)).values())):\n........return n\n......else:\n........n += 1\n....else:\n......n += 1\nx = 1\nwhile x < 100:\n..print(Prod(x))\n..x += 1 \n"}
{"sequence_id": "A066739", "text": "Number of representations of n as a sum of products of positive integers. 1 is not allowed as a factor, unless it is the only factor. Representations which differ only in the order of terms or factors are considered equivalent.", "sequence": "1,1,2,3,6,8,14,19,32,44,67,91,139,186,269,362,518,687,960,1267,1747,2294,3106,4052,5449,7063,9365,12092,15914,20422,26639,34029,44091,56076,72110,91306,116808,147272,187224,235201,297594,372390,468844,584644,732942", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import divisors, isprime\n@cacheit\ndef b(n, k): return (0 if n>k else 1) + (0 if isprime(n) else sum([0 if d>k else b(n//d, d) for d in divisors(n)[1:-1]]))\n@cacheit\ndef a(n): return 1 if n==0 else sum(sum(d*b(d, d) for d in divisors(j))*a(n - j)  for j in range(1, n + 1))//n\nprint([a(n) for n in range(61)]) \n"}
{"sequence_id": "A066779", "text": "Sum of squarefree numbers <= n.", "sequence": "1,3,6,6,11,17,24,24,24,34,45,45,58,72,87,87,104,104,123,123,144,166,189,189,189,215,215,215,244,274,305,305,338,372,407,407,444,482,521,521,562,604,647,647,647,693,740,740,740,740,791,791,844,844,899,899", "code": "\nfrom sympy.ntheory.factor_  import core\ndef a(n): return sum ([i for i in range(1, n + 1) if core(i) == i]) \n"}
{"sequence_id": "A066806", "text": "Expansion of Product_{k>=1} (1+x^k)^A001055(k).", "sequence": "1,1,1,2,3,4,6,8,11,16,21,27,38,49,63,84,109,138,180,228,289,369,463,578,732,911,1128,1407,1741,2140,2646,3243,3968,4862,5925,7198,8770,10620,12833,15524,18718,22502,27075,32467,38873,46537,55565,66220,78946", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import divisors, isprime\n@cacheit\ndef g(n, k): return (0 if n>k else 1) + (0 if isprime(n) else sum(0 if d>k else g(n//d, d) for d in divisors(n)[1:-1]))\n@cacheit\ndef b(n): return sum((-1)**(n//d + 1)*d*g(d, d) for d in divisors(n))\n@cacheit\ndef a(n): return 1 if n==0 else sum(a(n - k)*b(k) for k in range(1, n + 1))//n\nprint([a(n) for n in range(61)]) \n"}
{"sequence_id": "A066811", "text": "Numbers k such that the concatenation of odd numbers from 1 to k is a prime.", "sequence": "3,19,31,67,97,5139", "code": "\nfrom sympy import isprime\ndef agen():\n  k, str1tok = 1, '1'\n  while True:\n    if isprime(int(str1tok)): yield k\n    k, str1tok = k + 2, str1tok + str(k + 2)\ng = agen()\nprint([next(g) for i in range(5)]) \n"}
{"sequence_id": "A066949", "text": "Take the sum of the previous two terms, subtract n if this sum is greater than n.", "sequence": "0,1,1,2,3,5,2,7,1,8,9,6,3,9,12,6,2,8,10,18,8,5,13,18,7,25,6,4,10,14,24,7,31,5,2,7,9,16,25,2,27,29,14,43,13,11,24,35,11,46,7,2,9,11,20,31,51,25,18,43,1,44,45,26,7,33,40,6,46,52,28,9,37,46,9,55,64,42,28,70,18", "code": "\nl=[0, 1]\nfor n in range(2, 101):\n    x=l[n - 1] + l[n - 2]\n    if x>n: l.append(x - n)\n    else: l.append(x)\nprint(l) \n"}
{"sequence_id": "A067005", "text": "Totient of A061026(n) divided by n.", "sequence": "1,1,2,1,2,1,4,1,2,1,2,1,4,2,2,1,6,1,10,1,2,1,2,1,4,2,2,1,2,1,10,1,2,3,2,1,4,5,2,1,2,1,4,1,4,1,6,1,4,2,2,1,2,1,2,1,4,1,12,1,6,5,2,1,2,1,4,2,2,1,8,1,4,2,2,3,6,1,4,1,2,1,2,1,12,2,4,1,2,2,6,1,4,3,2,1,4,2,2,1", "code": "\nfrom sympy.ntheory import totient\ndef k(n):\n    m=1\n    while totient(m)%n: m+=1\n    return m\nprint([totient(k(n))//n for n in range(1, 101)]) \n"}
{"sequence_id": "A067029", "text": "Exponent of least prime factor in prime factorization of n, a(1)=0.", "sequence": "0,1,1,2,1,1,1,3,2,1,1,2,1,1,1,4,1,1,1,2,1,1,1,3,2,1,3,2,1,1,1,5,1,1,1,2,1,1,1,3,1,1,1,2,2,1,1,4,2,1,1,2,1,1,1,3,1,1,1,2,1,1,2,6,1,1,1,2,1,1,1,3,1,1,1,2,1,1,1,4,4,1,1,2,1,1,1,3,1,1", "code": "\nfrom sympy import factorint\ndef a(n):\n    f=factorint(n)\n    return 0 if n==1 else f[min(f)] \n"}
{"sequence_id": "A067060", "text": "A permutation of the positive integers in groups of four such that any two consecutive numbers differ by at least 2.", "sequence": "3,1,4,2,7,5,8,6,11,9,12,10,15,13,16,14,19,17,20,18,23,21,24,22,27,25,28,26,31,29,32,30,35,33,36,34,39,37,40,38,43,41,44,42,47,45,48,46,51,49,52,50,55,53,56,54,59,57,60,58,63,61,64,62,67,65,68,66,71,69,72,70", "code": " def a(n): return n+[-2,2,-1,1][n%4] \n"}
{"sequence_id": "A067175", "text": "Number of digits in the n-th primorial (A002110).", "sequence": "1,1,1,2,3,4,5,6,7,9,10,12,13,15,17,18,20,22,24,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,56,58,60,62,64,66,69,71,73,76,78,80,82,85,87,89,92,94,97,99,101,104,106,109,111,113,116,118,121,123,126,128,131,133", "code": "\nfrom sympy import primorial\ndef a(n): return 1 if n == 0 else len(str(primorial(n)))\nprint([a(n) for n in range(68)]) \n"}
{"sequence_id": "A067251", "text": "Numbers with no trailing zeros in decimal representation.", "sequence": "1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68,69,71,72,73,74,75,76,77,78,79,81,82,83,84,85,86,87,88,89,91,92,93,94,95,96,97,98,99,101,102,103,104", "code": "\ndef a(n): return n + (n-1)//9\nprint([a(n) for n in range(1, 95)]) \n"}
{"sequence_id": "A067276", "text": "Determinant of n X n matrix containing the first n^2 primes in increasing order.", "sequence": "2,-1,-78,880,-4656,-14304,-423936,8342720,711956736,-615707136,21057138688,-4663930678272,211912980656128,-9178450735677440,40005919124799488,83013253447139328,-8525111273818357760,-800258888289188708352,-15170733077495639179264", "code": "\nfrom sympy.matrices import Matrix\nfrom sympy import sieve\ndef a(n):\n    sieve.extend_to_no(n**2)\n    return Matrix(n, n, sieve[1:n**2+1]).det()\nprint([a(n) for n in range(1, 20)]) \n"}
{"sequence_id": "A067388", "text": "Initial prime in set of 4 consecutive primes with common gap 48.", "sequence": "55410683,102291263,141430363,226383163,280064453,457433213,531290533,542418463,555695713,582949903,629444003,664652203,665813153,777809113,802919653,852404053,887653633,894328243,898734673,979048313,993517643", "code": "\nfrom sympy import isprime, nextprime\nA067388_list, p = [], 2\nq, r, s = p+48, p+96, p+144\nwhile s <= 10**10:\n    np = nextprime(p)\n    if np == q and isprime(r) and isprime(s) and nextprime(q) == r and nextprime(r) == s:\n        A067388_list.append(p)\n    p, q, r, s = np, np+48, np+96, np+144 \n"}
{"sequence_id": "A067442", "text": "a(1) = 1 and then smallest nontrivial n-th power starting with 1.", "sequence": "1,16,125,16,1024,15625,128,1679616,19683,1024,177147,16777216,1594323,16384,14348907,152587890625,131072,101559956668416,1162261467,1048576,10460353203,17592186044416,11920928955078125,16777216", "code": "\nprint(1,1)\nn = 1\nwhile n < 20:\n    n, p = n+1, 2\n    s = str(p**n)\n    while s[0] != \"1\":\n        p = p+1\n        s = str(p**n)\n    print(n,p**n) \n"}
{"sequence_id": "A067443", "text": "Smallest n-th power starting with 2.", "sequence": "2,25,27,256,243,262144,2187,256,262144,282475249,2048,244140625,2541865828329,268435456,205891132094649,2821109907456,232630513987207,262144,274877906944,278218429446951548637196401,2097152,2384185791015625,27368747340080916343", "code": "\ndef a(n):\n  r = 1\n  while str(r**n)[0] != '2': r += 1\n  return r**n\nprint([a(n) for n in range(1, 24)]) \n"}
{"sequence_id": "A067462", "text": "a(n) = (1! + 2! + ... + (n-1)!) mod n.", "sequence": "0,1,0,1,3,3,5,1,0,3,0,9,9,5,3,9,12,9,8,13,12,11,20,9,13,9,9,5,16,3,1,25,0,29,33,9,4,27,9,33,3,33,15,33,18,43,17,9,47,13,12,9,12,9,33,33,27,45,27,33,21,1,54,25,48,33,64,29,66,33,67,9,54,41,63,65,33,9,19,73,63", "code": "\nn = 0\nwhile n < 200:\n    n,f,fs,i = n+1,1,0,1\n    while i < n:\n        f,i = (f*i)%n,i+1\n        fs = (fs+f)%n\n    print(n,fs) \n"}
{"sequence_id": "A067526", "text": "Numbers n such that n - 2^k is a prime or 1 for all k satisfying 0 < k, 2^k < n.", "sequence": "3,4,5,7,9,15,21,45,75,105", "code": "\nfrom sympy import isprime\ndef ok(n):\n  k, pow2 = 1, 2\n  while pow2 < n - 1:\n    if not isprime(n-pow2): return False\n    pow2 *= 2\n  return (2 < n)\nprint([m for m in range(1, 200) if ok(m)]) \n"}
{"sequence_id": "A067563", "text": "Product of n-th prime number and n-th composite number.", "sequence": "8,18,40,63,110,156,238,285,368,522,620,777,902,1032,1175,1378,1593,1708,2010,2272,2409,2686,2905,3204,3686,3939,4120,4494,4796,5085,5842,6288,6713,6950,7599,7852,8478,8965,9352,9861,10382,10860,11842,12159", "code": "\nfrom sympy import prime, composite\ndef A067563(n):\n    return prime(n)*composite(n) \n"}
{"sequence_id": "A067728", "text": "a(n) = 2*n^2 + 8*n.", "sequence": "10,24,42,64,90,120,154,192,234,280,330,384,442,504,570,640,714,792,874,960,1050,1144,1242,1344,1450,1560,1674,1792,1914,2040,2170,2304,2442,2584,2730,2880,3034,3192,3354,3520,3690,3864,4042,4224,4410,4600,4794", "code": "\ndef a(n): return (2*n + 8)*n\nprint([a(n) for n in range(1, 48)]) \n"}
{"sequence_id": "A067770", "text": "a(n) = Catalan(n) mod (n+2).", "sequence": "1,1,2,0,2,0,4,6,0,0,8,0,0,10,8,0,0,0,0,0,0,0,0,0,0,18,0,0,20,0,16,22,0,0,12,0,0,13,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,0,56,0,0,58,0,0", "code": "\nA067770_list, c = [1,1], 1\nfor n in range(2,10001):\n    c = c*(4*n-2)//(n+1)\n    A067770_list.append(c % (n+2)) \n"}
{"sequence_id": "A067872", "text": "Least m>0 for which m*n^2 + 1 is a square.", "sequence": "3,2,7,3,23,8,47,15,79,24,119,2,167,48,3,63,287,80,359,6,88,120,527,28,623,168,727,12,839,44,959,255,216,288,8,20,1367,360,19,77,1679,22,1847,30,208,528,2207,7,2399,624,128,42,2807,728,696,3,160,840,3479,11", "code": "\ndef A067872(n):\n    y, x, n2 = n*(n+2), 2*n+3, n**2\n    m, r = divmod(y,n2)\n    while r:\n        y += x\n        x += 2\n        m, r = divmod(y,n2)\n    return m \n"}
{"sequence_id": "A068076", "text": "Number of positive integers < n with the same number of 1's in their binary expansions as n.", "sequence": "0,1,0,2,1,2,0,3,3,4,1,5,2,3,0,4,6,7,4,8,5,6,1,9,7,8,2,9,3,4,0,5,10,11,10,12,11,12,5,13,13,14,6,15,7,8,1,14,16,17,9,18,10,11,2,19,12,13,3,14,4,5,0,6,15,16,20,17,21,22,15,18,23,24,16,25,17,18,6,19,26,27,19", "code": "\ndef a(n):\n    x=bin(n)[2:].count(\"1\")\n    return sum(1 for i in range(n) if bin(i)[2:].count(\"1\")==x) \n"}
{"sequence_id": "A068084", "text": "Smallest triangular number which is a multiple (>1) of the n-th triangular number.", "sequence": "3,6,36,120,45,105,1176,2016,630,990,528,780,3003,210,3240,32640,9180,11628,2850,630,3003,26565,16836,20100,44850,52650,17766,20706,10440,12090,461280,61776,11781,3570,25200,43956,221445,30381,5460,189420", "code": "\nfrom __future__ import division\ndef A068084(n):\n    u,v,t = 4*(n+1),(2*(n+1))**2-1,4*n*(n+1)\n    while True:\n        if not v % t:\n            return v//8\n        v += u+1\n        u += 2 \n"}
{"sequence_id": "A068105", "text": "Smallest prime starting with n 5s.", "sequence": "2,5,557,5557,555521,555557,55555517,55555553,5555555501,5555555557,555555555551,555555555551,5555555555551,555555555555529,555555555555557,55555555555555519,555555555555555559,555555555555555559,55555555555555555567,5555555555555555555087", "code": "\nfrom sympy import isprime\ndef a(n):\n  if n < 2: return list([2, 5])[n]\n  n5s, i, pow10 = int('5'*n), 1, 1\n  while True:\n    i = 1\n    while i < pow10:\n      t = n5s * pow10 + i\n      if isprime(t): return t\n      i += 2\n    pow10 *= 10\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A068109", "text": "a(1)=0, a(2)=1, a(n) = concatenate(a(n-1) and a(n-2)) - a(n-1).", "sequence": "0,1,9,82,747,74035,73961712,7396097312323,739609723836276649389,7396097238362026884173559820662934,7396097238362026884166163723424572712725550276455986455", "code": "\ndef f(v): return int((str(v[-1])+str(v[-2]))) - v[-1]\ndef aupton(nn):\n    alst = [0, 1]\n    for n in range(2, nn+1): alst.append(f(alst))\n    return alst[:nn+1]\nprint(aupton(10)) \n"}
{"sequence_id": "A068179", "text": "Product_{i=1..3} (i+x) / Product_(i=1..3} (i-x) = Sum_{n>=0} (a(n)/b(n))*x^n.", "sequence": "1,11,121,971,6721,43331,269641,1648091,9981841,60176051,361921561,2174145611,13052763361,78340331171,470113403881,2820895001531,16926014399281,101558020876691,609353931324601,3656141011383851", "code": " for n in range(0,20): print(5*2**(n+1)+6**(n+1)-5*3**(n+1), end=', ') \n"}
{"sequence_id": "A068186", "text": "a(n) is the largest number whose product of decimal digits equals n^n.", "sequence": "22,333,22222222,55555,333333222222,7777777,222222222222222222222222,333333333333333333,55555555552222222222,0,333333333333222222222222222222222222,0,7777777777777722222222222222", "code": "\nfrom sympy import factorint\ndef A068186(n):\n    if n == 1:\n        return 1\n    pf = factorint(n)\n    ps = sorted(pf.keys(),reverse=True)\n    if ps[0] > 7:\n        return 0\n    s = ''\n    for p in ps:\n        s += str(p)*(n*pf[p])\n    return int(s) \n"}
{"sequence_id": "A068187", "text": "a(n) is the smallest number such that the product of its decimal digits equals n^n, or 0 if no solutions exist.", "sequence": "1,4,39,488,55555,88999,7777777,88888888,999999999,25555555555888,0,88888888999999,0,4777777777777778888,35555555555555559999999,2888888888888888888888,0,888888999999999999999999,0,2555555555555555555558888888888888,37777777777777777777779999999999", "code": "\nfrom sympy import factorint\ndef A068187(n):\n    if n == 1:\n        return 1\n    pf = factorint(n)\n    return 0 if max(pf) > 7 else int(''.join(sorted(''.join(str(a)*(n*b) for a,b in pf.items()).replace('222','8').replace('22','4').replace('33','9')))) \n"}
{"sequence_id": "A068189", "text": "Smallest positive number whose product of digits equals n, or a(n)=0 if no such number exists, i.e. when n has a prime divisor greater than 7.", "sequence": "1,2,3,4,5,6,7,8,9,25,0,26,0,27,35,28,0,29,0,45,37,0,0,38,55,0,39,47,0,56,0,48,0,0,57,49,0,0,0,58,0,67,0,0,59,0,0,68,77,255,0,0,0,69,0,78,0,0,0,256,0,0,79,88,0,0,0,0,0,257,0,89,0,0,355,0,0,0,0,258,99,0,0,267,0", "code": "\ndef convert(n):\n    if n == 1:\n        return 1\n    result = 0\n    cur = 1\n    while n > 1:\n        found = False\n        for i in range(9, 1, -1):\n            if n % i == 0:\n                result += cur * i\n                cur *= 10\n                n //= i\n                found = True\n                break\n        if not found:\n            return 0\n    return result\nN = 256\nfor n in range(1, N):\n    print(n, convert(n))\n\n"}
{"sequence_id": "A068307", "text": "From Goldbach problem: number of decompositions of n into a sum of three primes.", "sequence": "0,0,0,0,0,1,1,1,2,1,2,2,2,1,3,2,4,2,3,2,5,2,5,3,5,3,7,3,7,2,6,3,9,2,8,4,9,4,10,2,11,3,10,4,12,3,13,4,12,5,15,4,16,3,14,5,17,3,16,4,16,6,19,3,21,5,20,6,20,2,22,5,21,6,22,5,28,5,24,7", "code": "\nfrom sympy import isprime, primerange, floor\ndef a(n):\n    s=0\n    for p in primerange(((n + 2)//3), n - 3):\n        for q in primerange(((n - p + 1)//2), min(n - p - 2, p) + 1):\n            if isprime(n - p - q): s+=1\n    return s\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A068396", "text": "n-th prime minus its reversal.", "sequence": "0,0,0,0,0,-18,-54,-72,-9,-63,18,-36,27,9,-27,18,-36,45,-9,54,36,-18,45,-9,18,0,-198,-594,-792,-198,-594,0,-594,-792,-792,0,-594,-198,-594,-198,-792,0,0,-198,-594,-792,99,-99,-495", "code": "\nfrom sympy import prime\ndef a(n): pn = prime(n); return pn - int(str(pn)[::-1])\nprint([a(n) for n in range(1, 50)]) \n"}
{"sequence_id": "A068403", "text": "Numbers k such that sigma(k) > 3*k.", "sequence": "180,240,360,420,480,504,540,600,660,720,780,840,900,960,1008,1080,1200,1260,1320,1344,1440,1512,1560,1584,1620,1680,1800,1848,1872,1890,1920,1980,2016,2040,2100,2160,2184,2280,2340,2352,2376,2400,2520,2640", "code": "\nfrom sympy import divisor_sigma\nprint([n for n in range(180, 3001) if divisor_sigma(n)>3*n]) \n"}
{"sequence_id": "A068492", "text": "Primes that remain prime after each digit is replaced by its square.", "sequence": "11,13,17,19,71,73,89,101,103,107,131,137,149,167,173,191,197,199,223,229,233,283,307,311,313,331,337,359,383,401,433,439,461,463,491,523,569,593,631,641,647,659,709,733,743,773,809,823,859,907,911,919,947", "code": "\nfrom sympy import isprime, nextprime\nn = 2\nwhile n < 8000:\n    t = int(''.join(str(int(i)**2) for i in list(str(n))))\n    if isprime(t):\n        print(n)\n    n = nextprime(n)\n\n"}
{"sequence_id": "A068539", "text": "Number of quinternary cubefree words of length n.", "sequence": "1,5,25,120,580,2800,13500,65100,313940,1513820,7299760,35200020,169736780,818482260,3946776920,19031623000", "code": "\nfrom itertools import product\ndef cf(s):\n  for l in range(1, len(s)//3 + 1):\n    for i in range(len(s) - 3*l + 1):\n      if s[i:i+l]*2 == s[i+l:i+3*l]: return False\n  return True\ndef a(n):\n  if n == 0: return 1\n  return 5*sum(cf(\"0\"+\"\".join(w)) for w in product(\"01234\", repeat=n-1))\nprint([a(n) for n in range(0, 10)]) \n"}
{"sequence_id": "A068601", "text": "a(n) = n^3 - 1.", "sequence": "0,7,26,63,124,215,342,511,728,999,1330,1727,2196,2743,3374,4095,4912,5831,6858,7999,9260,10647,12166,13823,15624,17575,19682,21951,24388,26999,29790,32767,35936,39303,42874,46655,50652,54871,59318,63999,68920", "code": " for n in range(1,50): print(n**3-1, end=', ') \n"}
{"sequence_id": "A068653", "text": "Composite numbers such that every cyclic shift (other than the number itself) gives a prime.", "sequence": "14,16,20,30,32,34,35,38,50,70,74,76,91,92,95,98,110,118,119,133,170,176,194,310,316,398,710,712,715,730,731,736,772,775,778,779,790,793,794,914,935,970,973,1118,1130,1195,1312,1336,1370,1774,1937,3110,3112", "code": "\nfrom itertools import product\nfrom sympy import isprime\nA068653_list = []\nfor l in range(1,9):\n    for m in product(('1379' if l > 1 else '123579'),repeat=l):\n        for d in '0123456789':\n            s = ''.join(m)+d\n            n = int(s)\n            if not isprime(n):\n                for k in range(len(s)-1):\n                    s = s[1:]+s[0]\n                    if not isprime(int(s)):\n                        break\n                else:\n                    A068653_list.append(n) \n"}
{"sequence_id": "A068660", "text": "Primes formed from the concatenation of k, k+1 and k for some k.", "sequence": "787,9109,111211,131413,333433,373837,394039,414241,474847,575857,596059,616261,697069,717271,777877,798079,818281,838483,101102101,103104103,129130129,149150149,181182181,187188187,189190189,191192191,193194193,207208207,217218217", "code": "\nfrom sympy import isprime\ndef aupto(N):\n  return [t for t in (int(str(k)+str(k+1)+str(k)) for k in range(1, N+1, 2)) if isprime(t)]\nprint(aupto(217)) \n"}
{"sequence_id": "A068679", "text": "Numbers which yield a prime whenever a 1 is inserted anywhere in them (including at the beginning or end).", "sequence": "1,3,7,13,31,49,63,81,91,99,103,109,117,123,151,181,193,213,231,279,319,367,427,459,571,601,613,621,697,721,801,811,951,987,1113,1117,1131,1261,1821,1831,1939,2101,2149,2211,2517,2611,3151,3219,4011,4411,4519,4887,5031,5361,6231,6487,6871,7011,7209,8671,9141,9801,10051", "code": "\nfrom sympy import isprime\nA068679_list, n = [], 1\nwhile len(A068679_list) < 1000:\n    if isprime(10*n+1):\n        s = str(n)\n        for i in range(len(s)):\n            if not isprime(int(s[:i]+'1'+s[i:])):\n                break\n        else:\n            A068679_list.append(n)\n    n += 1 \n"}
{"sequence_id": "A068831", "text": "Primes with all odd digits such that the next three primes also contain all odd digits.", "sequence": "3,5,7,11,191,311,313,9133,9371,11113,11171,15731,15937,15959,17939,17957,19319,19553,19739,19973,19979,31151,31333,31511,33353,35573,35753,39113,39119,39937,51131,51133,51971,53717,53719,53731,55313,55331", "code": "\nfrom itertools import product\nfrom sympy import isprime, nextprime\nA068831_list = [p for p in (int(''.join(d)) for l in range(1,9) for d in product('13579',repeat=l)) if isprime(p) and set(str(nextprime(p,1))) <= {'1','3','5','7','9'} and set(str(nextprime(p,2))) <= {'1','3','5','7','9'} and set(str(nextprime(p,3))) <= {'1','3','5','7','9'} ] \n"}
{"sequence_id": "A068896", "text": "Primes containing 2k digits in which the sum of the first k digits is that of the last k digits.", "sequence": "11,1423,1607,1753,1973,2011,2213,2341,2543,2617,2671,2819,2837,3407,3461,3517,3571,3719,3847,4013,4637,4673,4691,4729,4783,4967,5023,5261,5519,5573,5591,5647,5683,5849,5867,6143,6217,6271,6473,6491,6529,6547,7043,7649,7759,8017,8053,8219,8237,8273,8291,8329,8677,9137,9173,9283,9467", "code": "\nfrom sympy import primerange\ndef sd(s): return sum(map(int, s))\ndef auptod(digits):\n    alst = []\n    for d in range(2, digits+1, 2):\n        for p in primerange(10**(d-1), 10**d):\n            s = str(p)\n            if sd(s[:len(s)//2]) == sd(s[len(s)//2:]): alst.append(p)\n    return alst\nprint(auptod(4)) \n"}
{"sequence_id": "A068916", "text": "Smallest positive integer that is equal to the sum of the n-th powers of its prime factors (counted with multiplicity).", "sequence": "2,16,1096744,3125,256,823543,19683", "code": "\nfrom sympy import factorint\ndef a(n):\n  k = 1\n  while True:\n    f = factorint(k)\n    if k == sum(f[d]*d**n for d in f): return k\n    k += 1\nfor n in range(1, 8):\n  print(a(n), end=\", \") \n"}
{"sequence_id": "A068999", "text": "Numbers k such that k = (sum of distinct prime factors of k)*(product of distinct prime factors of k).", "sequence": "4,9,25,49,121,169,289,300,361,504,529,841,961,980,1056,1369,1404,1575,1681,1849,2209,2600,2736,2809,3481,3721,4489,4851,5041,5329,6241,6375,6696,6889,7436,7448,7695,7921,9409,9639,10201,10304,10609,11375,11449", "code": "\nfrom sympy import primerange\nimport math\nprimes = list(primerange(2,10000))\nfor n in range(1,10000):\n    d = n\n    sum = 0\n    product = 1\n    for p in primes:\n        if d%p==0:\n            sum += p\n            product *= p\n            while d%p==0:\n                d//=p\n            if d==1:\n                break\n    if sum*product==n:\n        print(n, end=',')\n\n"}
{"sequence_id": "A068999", "text": "Numbers k such that k = (sum of distinct prime factors of k)*(product of distinct prime factors of k).", "sequence": "4,9,25,49,121,169,289,300,361,504,529,841,961,980,1056,1369,1404,1575,1681,1849,2209,2600,2736,2809,3481,3721,4489,4851,5041,5329,6241,6375,6696,6889,7436,7448,7695,7921,9409,9639,10201,10304,10609,11375,11449", "code": "\nfrom math import prod\nfrom sympy import primefactors\ndef ok(n): pf = primefactors(n); return n == sum(pf)*prod(pf)\nprint(list(filter(ok, range(1, 11600)))) \n"}
{"sequence_id": "A069010", "text": "Number of runs of 1's in the binary representation of n.", "sequence": "0,1,1,1,1,2,1,1,1,2,2,2,1,2,1,1,1,2,2,2,2,3,2,2,1,2,2,2,1,2,1,1,1,2,2,2,2,3,2,2,2,3,3,3,2,3,2,2,1,2,2,2,2,3,2,2,1,2,2,2,1,2,1,1,1,2,2,2,2,3,2,2,2,3,3,3,2,3,2,2,2,3,3,3,3,4,3,3,2,3,3,3,2,3", "code": "\ndef A069010(n):\n    return sum(1 for d in bin(n)[2:].split('0') if len(d)) \n"}
{"sequence_id": "A069051", "text": "Primes p such that p-1 divides 2^p-2.", "sequence": "2,3,7,19,43,127,163,379,487,883,1459,2647,3079,3943,5419,9199,11827,14407,16759,18523,24967,26407,37339,39367,42463,71443,77659,95923,99079,113779,117307,143263,174763,175447,184843,265483,304039,308827", "code": "\nfrom sympy import prime\nfor n in range(1,350000):\n    if (2**prime(n)-2) % (prime(n)-1)==0:\n        print(prime(n)) \n"}
{"sequence_id": "A069090", "text": "Primes none of whose proper initial segments are primes.", "sequence": "2,3,5,7,11,13,17,19,41,43,47,61,67,83,89,97,101,103,107,109,127,149,151,157,163,167,181,401,409,421,443,449,457,461,463,467,487,491,499,601,607,631,641,643,647,653,659,661,683,691,809,811,821,823,827,829", "code": "\nfrom sympy import primerange, isprime\ndef ok(p):\n    s = str(p)\n    if len(s) == 1: return True\n    return all(not isprime(int(s[:i])) for i in range(1, len(s)))\ndef aupto(lim):\n    alst = []\n    for p in primerange(1, lim+1):\n        if ok(p): alst.append(p)\n    return alst\nprint(aupto(829)) \n"}
{"sequence_id": "A069100", "text": "n-th n-digit prime number.", "sequence": "2,13,107,1021,10061,100069,1000117,10000189,100000193,1000000181,10000000259,100000000193,1000000000303,10000000000411,100000000000487,1000000000000513,10000000000000931,100000000000000591,1000000000000000861,10000000000000000667", "code": "\nfrom sympy import nextprime\ndef a(n):  return nextprime(10**(n-1), ith=n)\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A069151", "text": "Concatenations of consecutive primes, starting with 2, that are also prime.", "sequence": "2,23,2357", "code": "\nfrom sympy import isprime, nextprime\ndef afind(terms, verbose=False):\n  n, p, pstr = 0, 2, \"2\"\n  while n < terms:\n    if isprime(int(pstr)): n += 1; print(n, int(pstr))\n    p = nextprime(p); pstr += str(p)\nafind(5) \n"}
{"sequence_id": "A069157", "text": "Number of positive divisors of n that are divisible by the smallest prime that divides n.", "sequence": "0,1,1,2,1,2,1,3,2,2,1,4,1,2,2,4,1,3,1,4,2,2,1,6,2,2,3,4,1,4,1,5,2,2,2,6,1,2,2,6,1,4,1,4,4,2,1,8,2,3,2,4,1,4,2,6,2,2,1,8,1,2,4,6,2,4,1,4,2,4,1,9,1,2,3,4,2,4,1,8,4,2,1,8,2,2,2,6,1,6,2,4,2,2,2,10,1,3,4,6", "code": "\nfrom sympy import divisor_count, factorint\ndef a067029(n): return 0 if n==1 else next(iter(factorint(n).values()))\ndef a(n): return divisor_count(n)*a067029(n)//(1 + a067029(n))\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A069192", "text": "Sum of the reversals of the divisors of n.", "sequence": "1,3,4,7,6,12,8,15,13,9,12,37,32,51,60,76,72,102,92,15,23,36,33,87,58,96,85,137,93,72,14,99,48,117,66,190,74,177,128,27,15,96,35,84,123,99,75,232,102,66,90,125,36,219,72,210,170,180,96,105,17,42,68,145,93,144,77,207,132,117,18,267,38,123,169,248", "code": "\ndef A069192(n):\n....s=0\n....for i in range(1,n+1):\n........if n%i==0: s+=int(str(i)[::-1])\n....return s \n"}
{"sequence_id": "A069250", "text": "Sum of the reversals of the proper divisors of n.", "sequence": "0,1,1,3,1,6,1,7,4,8,1,16,1,10,9,15,1,21,1,13,11,14,1,45,6,34,13,55,1,69,1,76,15,74,13,127,1,94,35,23,1,72,1,40,69,35,1,148,8,61,75,100,1,174,17,145,95,95,1,99,1,16,32,99,37,78,1,121,36,110,1,240,1,76,112,181,19,198,1,88,85,17,1,203", "code": "\ndef A069250(n):\n....s=0\n....for i in range(1,n):\n........if n%i==0: s+=int(str(i)[::-1])\n....return s \n"}
{"sequence_id": "A069482", "text": "a(n) = prime(n+1)^2 - prime(n)^2.", "sequence": "5,16,24,72,48,120,72,168,312,120,408,312,168,360,600,672,240,768,552,288,912,648,1032,1488,792,408,840,432,888,3360,1032,1608,552,2880,600,1848,1920,1320,2040,2112,720,3720,768,1560,792,4920,5208,1800,912,1848", "code": "\nfrom sympy import prime, primerange\ndef aupton(terms):\n  p = list(primerange(1, prime(terms+1)+1))\n  return [p[n+1]**2-p[n]**2 for n in range(terms)]\nprint(aupton(50)) \n"}
{"sequence_id": "A069484", "text": "a(n) = prime(n+1)^2 + prime(n)^2.", "sequence": "13,34,74,170,290,458,650,890,1370,1802,2330,3050,3530,4058,5018,6290,7202,8210,9530,10370,11570,13130,14810,17330,19610,20810,22058,23330,24650,28898,33290,35930,38090,41522,45002", "code": "\nfrom sympy import prime\nfor n in range(1,101): print(n, prime(n)**2+prime(n+1)**2) \n"}
{"sequence_id": "A069512", "text": "Geometric mean of digits = 2 and digits are in nondecreasing order.", "sequence": "2,14,22,118,124,222,1128,1144,1224,2222,11148,11228,11244,12224,22222,111188,111248,111444,112228,112244,122224,222222,1111288,1111448,1112248,1112444,1122228,1122244,1222224,2222222,11111488,11112288,11112448,11114444", "code": "\nfrom math import prod\nfrom sympy.utilities.iterables import multiset_combinations\ndef aupton(terms):\n  n, digits, alst, powsexps2 = 0, 1, [], [(1,0), (2,1), (4,2), (8,3)]\n  while n < terms:\n    target = 2**digits\n    mcstr = \"\".join(str(d)*(digits//max(1, r)) for d, r in powsexps2)\n    for mc in multiset_combinations(mcstr, digits):\n      if prod(map(int, mc)) == target:\n        n += 1\n        alst.append(int(\"\".join(mc)))\n        if n == terms: break\n    else: digits += 1\n  return alst\nprint(aupton(34)) \n"}
{"sequence_id": "A069516", "text": "Geometric mean of digits = 3 and digits are in nondecreasing order.", "sequence": "3,19,33,139,333,1199,1339,3333,11399,13339,33333,111999,113399,133339,333333,1113999,1133399,1333339,3333333,11119999,11133999,11333399,13333339,33333333,111139999,111333999,113333399,133333339,333333333,1111199999,1111339999", "code": "\nfrom math import prod\nfrom sympy.utilities.iterables import multiset_combinations\ndef aupton(terms):\n  n, digits, alst, powsexps3 = 0, 1, [], [(1, 0), (3, 1), (9, 2)]\n  while n < terms:\n    target = 3**digits\n    mcstr = \"\".join(str(d)*(digits//max(1, r)) for d, r in powsexps3)\n    for mc in multiset_combinations(mcstr, digits):\n      if prod(map(int, mc)) == target:\n        n += 1\n        alst.append(int(\"\".join(mc)))\n        if n == terms: break\n    else: digits += 1\n  return alst\nprint(aupton(31)) \n"}
{"sequence_id": "A069518", "text": "Geometric mean of digits = 4 and digits are in nondecreasing order.", "sequence": "4,28,44,188,248,444,1488,2288,2448,4444,12888,14488,22488,24448,44444,118888,124888,144488,222888,224488,244448,444444,1148888,1228888,1244888,1444488,2224888,2244488,2444448,4444444,11288888,11448888,12248888,12444888", "code": "\nfrom math import prod\nfrom sympy.utilities.iterables import multiset_combinations\ndef auptod(terms):\n  n, digits, alst, powsexps2 = 0, 1, [], [(1, 0), (2, 1), (4, 2), (8, 3)]\n  while n < terms:\n    target = 4**digits\n    mcstr = \"\".join(str(d)*(digits//max(1, r//2)) for d, r in powsexps2)\n    for mc in multiset_combinations(mcstr, digits):\n      if prod(map(int, mc)) == target:\n        n += 1\n        alst.append(int(\"\".join(mc)))\n        if n == terms: break\n    else: digits += 1\n  return alst\nprint(auptod(34)) \n"}
{"sequence_id": "A069537", "text": "Multiples of 2 whose digit sum is 2.", "sequence": "2,20,110,200,1010,1100,2000,10010,10100,11000,20000,100010,100100,101000,110000,200000,1000010,1000100,1001000,1010000,1100000,2000000,10000010,10000100,10001000,10010000,10100000,11000000,20000000,100000010,100000100,100001000", "code": "\nfrom itertools import product\ndef agen():\n  digits = 1\n  while True:\n    for i in range(digits-2): yield int(\"1\"+\"0\"*(digits-3-i)+\"1\"+\"0\"*i+\"0\")\n    yield int(\"2\"+\"0\"*(digits-1))\n    digits += 1\ng = agen()\nprint([next(g) for i in range(32)]) \n"}
{"sequence_id": "A069589", "text": "Smallest prime in which the n-th significant digit is a 3.", "sequence": "3,31,307,3001,30011,300007,3000017,30000001,300000007,3000000019,30000000001,300000000077,3000000000013,30000000000011,300000000000089,3000000000000037,30000000000000029,300000000000000011,3000000000000000037,30000000000000000041", "code": "\nfrom sympy import nextprime\ndef a(n): return nextprime(3*10**(n-1)-1)\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A069592", "text": "Smallest prime in which the n-th significant digit is a 5.", "sequence": "5,53,503,5003,50021,500009,5000011,50000017,500000003,5000000029,50000000021,500000000023,5000000000053,50000000000053,500000000000057,5000000000000023,50000000000000051,500000000000000021", "code": "\nimport sympy\ni=0\nprint(5)\ni=i+1\nwhile i > -1:\n....a=5*(10**i)\n....p=sympy.nextprime(a)\n....print(p)\n....i=i+1\n\n"}
{"sequence_id": "A069607", "text": "a(1) = 5; a(n) = smallest number such that the juxtaposition a(1)a(2)...a(n) is a prime.", "sequence": "5,3,23,1,3,9,21,9,21,23,43,3,23,7,21,89,37,21,137,1,119,493,143,133,483,267,179,7,333,359,439,101,33,31,533,19,63,39,333,839,63,693,423,327,73,29,39,21,517,27,99,251,7,411,243,33,149,49,227,283,303,351,303", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n  astr, alst = '5', [5]\n  for n in range(2, terms+1):\n    an = 1\n    while not isprime(int(astr + str(an))): an += 1\n    astr, alst = astr + str(an), alst + [an]\n  return alst\nprint(aupton(63)) \n"}
{"sequence_id": "A069608", "text": "a(1) = 6; a(n) = smallest number such that the juxtaposition a(1)a(2)...a(n) is a prime.", "sequence": "6,1,3,1,41,19,17,1,81,27,89,3,79,29,1,111,29,13,119,207,21,33,19,413,49,71,183,223,153,21,261,369,29,319,107,1,273,81,711,507,87,579,401,7,33,771,477,33,371,91,1559,357,297,9,177,523,77,103,167,199,143,199", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n  alst, astr = [6], \"6\"\n  for n in range(2, terms+1):\n    an = 1\n    while not isprime(int(astr+str(an))): an += 1\n    alst, astr = alst + [an], astr + str(an)\n  return alst\nprint(aupton(62)) \n"}
{"sequence_id": "A069610", "text": "a(1) = 8; a(n) = smallest number such that the juxtaposition a(1)a(2)...a(n) is a prime.", "sequence": "8,3,9,11,7,21,23,3,7,29,3,99,9,93,1,39,33,21,137,123,57,13,191,3,163,9,143,63,21,157,521,163,161,43,161,109,107,121,423,57,71,7,173,469,107,57,177,411,49,149,61,291,413,271,299,693,349,149,73,299,271,521", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n    alst, astr = [8], '8'\n    for n in range(2, terms+1):\n        an = 1\n        while not isprime(int(astr + str(an))): an += 2\n        alst, astr = alst + [an], astr + str(an)\n    return alst\nprint(aupton(62)) \n"}
{"sequence_id": "A069648", "text": "a(1) = 1, otherwise smallest m > 1 such that the sum of digits of m^n is k^n for some k > 1.", "sequence": "1,2,2,11,47,46,983,193534,676644395", "code": "\nimport sympy\nfrom sympy import factorint\ndef DigitSum(x):\n    return sum(int(i) for i in str(x))\ndef PowExp(p):\n    n = 2\n    while n < 10000*(10**(int(2**p/9)/p)):\n        if DigitSum(n**p) != 1:\n            count = 0\n            for i in list(factorint(DigitSum(n**p)).values()):\n                if (int(i)/p) % 1 == 0:\n                    count += 1\n            if count == len(list(factorint(DigitSum(n**p)).values())):\n                return n\n            else:\n                n += 1\n        else:\n            n += 1\nprint(1)\nx = 2\nwhile x < 20:\n    print(PowExp(x))\n    x += 1\n\n"}
{"sequence_id": "A069648", "text": "a(1) = 1, otherwise smallest m > 1 such that the sum of digits of m^n is k^n for some k > 1.", "sequence": "1,2,2,11,47,46,983,193534,676644395", "code": "\nfrom sympy import factorint\ndef A069648(n):\n....if (n == 1):\n........return 1\n....else:\n........m = 2\n........while True:\n............x = sum(int(d) for d in str(m**n))\n............if x > 1 and not any(map(lambda x:x%n,factorint(x).values())):\n................return m\n............m += 1 \n"}
{"sequence_id": "A069675", "text": "Primes all of whose internal digits (if any) are 0.", "sequence": "2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,307,401,409,503,509,601,607,701,709,809,907,1009,2003,3001,4001,4003,4007,5003,5009,6007,7001,8009,9001,9007,10007,10009", "code": "\nfrom sympy import isprime\nprint([2, 3, 5, 7] + list(filter(isprime, (a*10**d+b for d in range(1, 101) for a in range(1, 10) for b in [1, 3, 7, 9])))) \n"}
{"sequence_id": "A069677", "text": "Primes with either no internal digits or all internal digits are 2.", "sequence": "2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,127,223,227,229,421,521,523,727,821,823,827,829,929,1223,1229,2221,3221,3229,4229,5227,6221,6229,7229,8221,9221,9227,12227,22229,42221", "code": "\nfrom sympy import isprime\ndef agen(maxdigits):\n    yield from [2, 3, 5, 7]\n    for d in range(2, maxdigits+1):\n        pow10, mid = 10**(d-1), 0 if d < 3 else 10*int('2'*(d-2))\n        cands = (a*pow10+mid+b for a in range(1, 10) for b in [1, 3, 7, 9])\n        yield from filter(isprime, cands)\nprint([an for an in agen(100)]) \n"}
{"sequence_id": "A069690", "text": "Primes that yield another prime on placing a 9 on both sides (as leading and trailing digits).", "sequence": "2,19,23,31,41,43,47,53,61,67,71,73,83,101,107,109,113,149,163,193,211,239,241,263,269,277,313,317,331,347,373,397,409,421,439,443,499,521,523,541,547,607,617,619,641,647,673,677,757,787,829,863,877,907,911", "code": "\nfrom sympy import isprime, primerange\ndef ok(p): return isprime(int('9'+str(p)+'9'))\ndef aupto(lim): return [p for p in primerange(2, lim+1) if ok(p)]\nprint(aupto(911)) \n"}
{"sequence_id": "A069706", "text": "Primes with property that swapping first and last digits also gives a prime.", "sequence": "2,3,5,7,11,13,17,31,37,71,73,79,97,101,107,113,131,149,151,157,167,179,181,191,199,311,313,337,347,353,359,373,383,389,701,709,727,733,739,743,751,757,761,769,787,797,907,919,929,937,941,953,967,971,983,991,1009,1013", "code": "\nfrom sympy import prime, isprime\nA069706_list = [2,3,5,7]\nfor i in range(5,10**6):\n    p = prime(i)\n    s = str(p)\n    if isprime(int(s[-1]+s[1:-1]+s[0])):\n        A069706_list.append(p) \n"}
{"sequence_id": "A069862", "text": "Smallest k such that n divides the concatenation of numbers from (n+1) to (n+k), where (n+1) is on the most significant side.", "sequence": "1,2,2,2,5,2,9,4,8,10,10,8,22,16,5,4,2,8,3,20,20,10,17,12,25,22,26,16,25,20,110,20,11,2,20,8,998,52,38,20,60,20,4,32,35,42,50,20,96,50,2,96,93,26,10,20,3,50,44,20,46,40,45,40,50,32,86,32,17,20,75,72,26,926,50", "code": "\ndef A069862(n):\n....nk, kr, r = n+1, 1, 1 if n > 1 else 0\n....while r:\n........nk += 1\n........kr = (kr + 1) % n\n........r = (r*(10**len(str(nk)) % n)+kr) % n\n....return nk-n \n"}
{"sequence_id": "A069868", "text": "Smallest n-th power whose digit reversal is a prime.", "sequence": "2,16,125,16,32,16777216,128,16777216,35184372088832,1024,34271896307633,16777216,1490116119384765625,182059119829942534144,35184372088832,3876269050118516845397872321,131072,14551915228366851806640625,1134787999706880954999833295916475119,3584859224085422343574104404449462890625", "code": "\nfrom sympy import isprime\ndef a(n):\n  k = 1\n  while not isprime(int(str(k**n)[::-1])): k += 1\n  return k**n\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A069942", "text": "Reversal of n equals the sum of the reversals of the proper divisors of n.", "sequence": "6,10311,21661371,1460501511,7980062073,79862699373,798006269373", "code": "\nfrom sympy import divisors\nA069942 = [n for n in range(1,10**5) if sum(list(map(lambda x: int(str(x)[::-1]) if x < n else 0, divisors(n)))) == int(str(n)[::-1])] \n"}
{"sequence_id": "A070003", "text": "Numbers divisible by the square of their largest prime factor.", "sequence": "4,8,9,16,18,25,27,32,36,49,50,54,64,72,75,81,98,100,108,121,125,128,144,147,150,162,169,196,200,216,225,242,243,245,250,256,288,289,294,300,324,338,343,361,363,375,392,400,432,441,450,484,486,490,500,507", "code": "\nfrom sympy import factorint\ndef ok(n): f = factorint(n); return f[max(f)] >= 2\nprint(list(filter(ok, range(4, 508)))) \n"}
{"sequence_id": "A070014", "text": "Ceiling of number of prime factors of n divided by the number of n's distinct prime factors.", "sequence": "1,1,2,1,1,1,3,2,1,1,2,1,1,1,4,1,2,1,2,1,1,1,2,2,1,3,2,1,1,1,5,1,1,1,2,1,1,1,2,1,1,1,2,2,1,1,3,2,2,1,2,1,2,1,2,1,1,1,2,1,1,2,6,1,1,1,2,1,1,1,3,1,1,2,2,1,1,1,3,4,1,1,2,1,1,1,2,1,2,1,2,1,1,1,3,1,2,2,2,1,1,1,2,1,1", "code": "\nfrom sympy import primefactors, ceiling\ndef bigomega(n): return 0 if n==1 else bigomega(n//primefactors(n)[0]) + 1\ndef omega(n): return len(primefactors(n))\ndef a(n): return ceiling(bigomega(n)/omega(n))\nprint([a(n) for n in range(2, 51)]) \n"}
{"sequence_id": "A070165", "text": "Irregular triangle read by rows giving trajectory of n in Collatz problem.", "sequence": "1,2,1,3,10,5,16,8,4,2,1,4,2,1,5,16,8,4,2,1,6,3,10,5,16,8,4,2,1,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1,8,4,2,1,9,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1,10,5,16,8,4,2,1,11,34,17,52,26,13", "code": "\ndef a(n):\n    if n==1: return [1]\n    l=[n, ]\n    while True:\n        if n%2==0: n/=2\n        else: n = 3*n + 1\n        if n not in l:\n            l+=[n, ]\n            if n<2: break\n        else: break\n    return l\nfor n in range(1, 101): print(a(n)) \n"}
{"sequence_id": "A070168", "text": "Irregular triangle of Terras-modified Collatz problem.", "sequence": "1,2,1,3,5,8,4,2,1,4,2,1,5,8,4,2,1,6,3,5,8,4,2,1,7,11,17,26,13,20,10,5,8,4,2,1,8,4,2,1,9,14,7,11,17,26,13,20,10,5,8,4,2,1,10,5,8,4,2,1,11,17,26,13,20,10,5,8,4,2,1,12,6,3,5,8,4,2,1,13,20,10,5,8,4,2,1,14,7,11", "code": "\ndef a(n):\n    if n==1: return [1]\n    l=[n, ]\n    while True:\n        if n%2==0: n//=2\n        else: n = (3*n + 1)//2\n        l.append(n)\n        if n<2: break\n    return l\nfor n in range(1, 16): print(a(n)) \n"}
{"sequence_id": "A070171", "text": "Numbers k such that sigma(phi(k)) = k-phi(k).", "sequence": "2,18,84,15210,15216,66720,2858880,62905344,358313760,3633603510", "code": "\nfrom sympy import divisor_sigma as sigma, totient as phi\ndef aupto(limit):\n  for k in range(1, limit):\n    if sigma(phi(k), 1) == k - phi(k): print(k, end=\", \")\naupto(2*10**4) \n"}
{"sequence_id": "A070218", "text": "a(1) = 2; a(n) is the smallest prime greater than the sum of all previous terms.", "sequence": "2,3,7,13,29,59,127,241,487,971,1949,3889,7789,15569,31139,62297,124577,249181,498331,996689,1993357,3986711,7973419,15946841,31893713,63787391,127574789,255149591,510299171,1020598339,2041196683,4082393387,8164786771,16329573527", "code": "\nfrom sympy import nextprime\ndef aupton(terms):\n    alst, s = [2], 2\n    while len(alst) < terms:\n        p = nextprime(s)\n        alst.append(p)\n        s += p\n    return alst\nprint(aupton(31)) \n"}
{"sequence_id": "A070307", "text": "Number of n X n matrices with nonnegative integer entries such that every row sum equals 3.", "sequence": "1,16,1000,160000,52521875,30840979456,29509034655744,42998169600000000,90647430472564453125,265599227914240000000000,1047192117300356121695451136,5410240907043328777415185924096,35821862005173382840059779052734375,298285661929377847941529600000000000000", "code": "\nimport math\nf=math.factorial\ndef C(n, r): return f(n)/ f(r)/ f(n-r)\ndef A070307(n): return C(n + 2, 3)**n \n"}
{"sequence_id": "A070552", "text": "Semiprimes k such that k+1 is also a semiprime.", "sequence": "9,14,21,25,33,34,38,57,85,86,93,94,118,121,122,133,141,142,145,158,177,201,202,205,213,214,217,218,253,298,301,302,326,334,361,381,393,394,445,446,453,481,501,514,526,537,542,553,565,622,633,634,694,697", "code": "\nfrom sympy import factorint\ndef is_semiprime(n): return sum(e for e in factorint(n).values()) == 2\ndef ok(n): return is_semiprime(n) and is_semiprime(n+1)\nprint(list(filter(ok, range(698)))) \n"}
{"sequence_id": "A070837", "text": "Smallest number k such that abs(k - R(k)) = 9n, where R(k) is digit reversal of k (A004086); or 0 if no such k exists.", "sequence": "10,13,14,15,16,17,18,19,90,1011,100,0,0,0,0,0,0,0,0,1021,1090,103,0,0,0,0,0,0,0,1031,1080,0,104,0,0,0,0,0,0,1041,1070,0,0,105,0,0,0,0,0,1051,1060,0,0,0,106,0,0,0,0,1061,1050,0,0,0,0,107,0,0,0,1071,1040,0,0,0,0,0", "code": "\ndef back_difference(n):\n    r = int(str(n)[::-1])\n    return abs(r-n)\ndef a070837(n):\n    i = 0\n    while True:\n        if back_difference(i)==9*n:\n            return i\n        i+=1\n\n"}
{"sequence_id": "A070848", "text": "Smallest prime == 1 mod (4n).", "sequence": "5,17,13,17,41,73,29,97,37,41,89,97,53,113,61,193,137,73,229,241,337,89,277,97,101,313,109,113,233,241,373,257,397,137,281,433,149,457,157,641,821,337,173,353,181,1289,941,193,197,401,409,1249,1061,433,661", "code": "\nfrom sympy import isprime\ndef a(n):\n  k = 4*n + 1\n  while not isprime(k): k += 4*n\n  return k\nprint([a(n) for n in range(1, 56)]) \n"}
{"sequence_id": "A070871", "text": "a(n) = A002487(n) * A002487(n+1) (Conway's alimentary function).", "sequence": "1,2,2,3,6,6,3,4,12,15,10,10,15,12,4,5,20,28,21,24,40,35,14,14,35,40,24,21,28,20,5,6,30,45,36,44,77,70,30,33,88,104,65,60,84,63,18,18,63,84,60,65,104,88,33,30,70,77,44,36,45,30,6,7,42,66", "code": "\ndef a002487(n): return n if n<2 else a002487(n/2) if n%2==0 else a002487((n - 1)/2) + a002487((n + 1)/2)\ndef a(n): return a002487(n)*a002487(n + 1) \n"}
{"sequence_id": "A070939", "text": "Length of binary representation of n.", "sequence": "1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7", "code": "\ndef a(n): return len(bin(n)[2:])\nprint([a(n) for n in range(105)]) \n"}
{"sequence_id": "A070940", "text": "Number of digits that must be counted from left to right to reach the last 1 in the binary representation of n.", "sequence": "1,1,2,1,3,2,3,1,4,3,4,2,4,3,4,1,5,4,5,3,5,4,5,2,5,4,5,3,5,4,5,1,6,5,6,4,6,5,6,3,6,5,6,4,6,5,6,2,6,5,6,4,6,5,6,3,6,5,6,4,6,5,6,1,7,6,7,5,7,6,7,4,7,6,7,5,7,6,7,3,7,6,7,5,7,6,7,4,7,6,7,5,7", "code": "\ndef A070940(n):\n    while n%2 == 0:\n        n = n//2\n    a = 0\n    while n != 0:\n        n, a = n//2, a+1\n    return a\nn = 0\nwhile n < 100:\n    n = n+1\n    print(n,A070940(n)) \n"}
{"sequence_id": "A070947", "text": "Number of permutations on n letters that have only cycles of length 6 or less.", "sequence": "1,1,2,6,24,120,720,4320,29520,225360,1890720,17169120,166112640,1680462720,18189031680,209008512000,2532028896000,32143053484800,425585741760000,5865854258188800,84489178710067200,1266667808011315200,19700712491727974400", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial, factorial as f\n@cacheit\ndef a(n): return 1 if n==0 else sum(a(n-j)*binomial(n - 1, j - 1)*f(j - 1) for j in range(1, min(n, 6)+1))\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A070975", "text": "Number of steps to reach 1 in `3x+1' (or Collatz) problem starting with prime(n).", "sequence": "1,7,5,16,14,9,12,20,15,18,106,21,109,29,104,11,32,19,27,102,115,35,110,30,118,25,87,100,113,12,46,28,90,41,23,15,36,23,67,31,31,18,44,119,26,119,39,70,13,34,83,52,21,65,122,78,29,42,16,42,60,117,37,86,130,37,24", "code": "\nfrom sympy import prime\ndef a006577(n):\n    if n==1: return 0\n    x=0\n    while True:\n        if n%2==0: n//=2\n        else: n = 3*n + 1\n        x+=1\n        if n<2: break\n    return x\ndef a(n): return a006577(prime(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A071033", "text": "a(n) = n-th state of cellular automaton generated by \"Rule 94\" when started with a single ON cell.", "sequence": "1,111,11011,1110111,110101011,11101010111,1101010101011,111010101010111,11010101010101011,1110101010101010111,110101010101010101011,11101010101010101010111,1101010101010101010101011,111010101010101010101010111,11010101010101010101010101011", "code": " print([1, 111]+[(1099*100**n + 9090)//990 + 1 if n%2 else (1090*100**n + 10)//990 + 1 for n in range(2, 50)]) \n"}
{"sequence_id": "A071101", "text": "Expansion of (5 + 6*x + 3*x^2 - 2*x^3) / (1 - 2*x - 2*x^2 - 2*x^3 + x^4) in powers of x.", "sequence": "5,16,45,130,377,1088,3145,9090,26269,75920,219413,634114,1832625,5296384,15306833,44237570,127848949,369490320,1067846845,3086134658,8919094697,25776662080,74495936025,215297250946,622220603405,1798250918672,5197041610021", "code": "\nfrom math import log\na0,a1,a2,a3,n = 130,45,16,5,3\nprint(0,a3)\nprint(1,a2)\nprint(2,a1)\nprint(3,a0)\nwhile log(a0)/log(10) < 1000:\n    a0,a1,a2,a3,n = 2*(a0+a1+a2)-a3,a0,a1,a2,n+1\n    print(n,a0) \n"}
{"sequence_id": "A071150", "text": "Primes p such that the sum of all odd primes <= p is also a prime.", "sequence": "3,29,53,61,251,263,293,317,359,383,503,641,647,787,821,827,911,1097,1163,1249,1583,1759,1783,1861,1907,2017,2287,2297,2593,2819,2837,2861,3041,3079,3181,3461,3541,3557,3643,3779,4259,4409,4457,4597,4691,4729,4789", "code": "\nfrom sympy import isprime, nextprime\ndef aupto(limit):\n  p, s, alst = 3, 3, []\n  while p <= limit:\n    if isprime(s): alst.append(p)\n    p = nextprime(p)\n    s += p\n  return alst\nprint(aupto(4789)) \n"}
{"sequence_id": "A071162", "text": "Simple rewriting of binary expansion of n resulting A014486-codes for rooted binary trees with height equal to number of internal vertices. (Binary trees where at each internal vertex at least the other child is leaf).", "sequence": "0,2,10,12,42,44,52,56,170,172,180,184,212,216,232,240,682,684,692,696,724,728,744,752,852,856,872,880,936,944,976,992,2730,2732,2740,2744,2772,2776,2792,2800,2900,2904,2920,2928,2984,2992,3024,3040,3412,3416", "code": "\ndef a036044(n): return int(''.join('1' if i == '0' else '0' for i in bin(n)[2:][::-1]), 2)\ndef a209642(n):\n    s=0\n    i=1\n    while n!=0:\n        if n%2==0:\n            n//=2\n            s=4*s + 1\n        else:\n            n=(n - 1)//2\n            s=(s + i)*2\n        i*=4\n    return s\ndef a(n): return 0 if n==0 else a036044(a209642(n))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A071174", "text": "Numbers whose sum of exponents = product of prime factors.", "sequence": "4,27,96,144,216,324,486,2560,3125,6400,16000,40000,57344,100000,200704,250000,625000,702464,823543,1562500,2458624,3906250,8605184,23068672,23914845,30118144,39858075,66430125,105413504,110716875", "code": "\nfrom math import prod\nfrom sympy import factorint\ndef ok(n): f = factorint(n); return sum(f[p] for p in f)==prod(p for p in f)\nprint(list(filter(ok, range(10**6)))) \n"}
{"sequence_id": "A071175", "text": "Numbers whose product of exponents = sum of prime factors.", "sequence": "4,27,96,486,640,1440,2025,2400,2744,3024,3125,3528,3584,4032,4536,4860,5292,5625,9408,11907,12150,12348,14256,15360,16464,17424,20412,22400,22464,25344,31360,32805,36504,37500,39204,55566,56250,57624,59904,70304,71442", "code": "\nfrom math import prod\nfrom sympy import factorint\ndef ok(n): f = factorint(n); return prod(f[p] for p in f)==sum(p for p in f)\nprint(list(filter(ok, range(10**5)))) \n"}
{"sequence_id": "A071185", "text": "Smallest k such that prime(k*n)-k*prime(n) is prime.", "sequence": "7,4,2,2,2,2,6,6,4,2,2,6,2,8,2,20,4,2,2,2,6,6,8,6,6,2,4,12,2,8,6,8,2,2,6,4,2,4,6,26,24,2,2,2,4,8,18,4,2,2,4,12,4,4,18,8,6,16,4,2,2,2,4,2,2,2,4,18,6,6,4,2,4,4,6,18,2,6,2,18,4,24,6,2,6,6,18,40,2,4,2,2,18,8,34,2,2", "code": "\nfrom sympy import isprime, prime\ndef a(n):\n    pn = prime(n); k = 1\n    while not isprime(prime(k*n) - k*pn): k += 1\n    return k\nprint([a(n) for n in range(1, 98)]) \n"}
{"sequence_id": "A071220", "text": "Numbers n such that prime(n) + prime(n+1) is a cube.", "sequence": "2,28,1332,3928,16886,157576,192181,369440,378904,438814,504718,539873,847252,1291597,1708511,1837979,3416685,3914319,5739049,6021420,7370101,7634355,8608315,9660008,10378270,14797144,15423070,18450693", "code": "\nfrom __future__ import division\nfrom sympy import isprime, prevprime, nextprime, primepi\nA071220_list, i = [], 2\nwhile i < 10**6:\n    n = i**3\n    m = n//2\n    if not isprime(m) and prevprime(m) + nextprime(m) == n:\n        A071220_list.append(primepi(m))\n    i += 1 \n"}
{"sequence_id": "A071235", "text": "a(n) = (n^12 + n^6)/2.", "sequence": "0,1,2080,266085,8390656,122078125,1088414496,6920702425,34359869440,141215033961,500000500000,1569215074141,4458051717120,11649044974645,28346959952416,64873174640625,140737496743936,291311130683665,578415707719200,1106657483056021", "code": " for n in range(0,20): print(int((n**12 + n**6)/2), end=', ') \n"}
{"sequence_id": "A071246", "text": "a(n) = n*(n - 1)*(2*n^2 + n + 2)/6.", "sequence": "0,0,4,23,76,190,400,749,1288,2076,3180,4675,6644,9178,12376,16345,21200,27064,34068,42351,52060,63350,76384,91333,108376,127700,149500,173979,201348,231826,265640,303025,344224,389488,439076,493255,552300,616494", "code": " def a(n): return n*(n - 1)*(2*n**2 + n + 2)/6 \n"}
{"sequence_id": "A071252", "text": "a(n) = n*(n - 1)*(n^2 + 1)/2.", "sequence": "0,0,5,30,102,260,555,1050,1820,2952,4545,6710,9570,13260,17927,23730,30840,39440,49725,61902,76190,92820,112035,134090,159252,187800,220025,256230,296730,341852,391935,447330,508400,575520,649077,729470,817110,912420", "code": " def a(n): return  n*(n - 1)*(n**2 + 1)/2 \n"}
{"sequence_id": "A071268", "text": "Sum of all digit permutations of the concatenation of first n numbers.", "sequence": "1,33,1332,66660,3999960,279999720,22399997760,2015999979840,201599999798400,927359999990726400,1064447999999893555200,2058376319999997941623680,4439635199999999955603648000,10585935359999999998941406464000,27655756127999999999972344243872000", "code": "\nfrom math import factorial\nfrom operator import mul\nfrom functools import reduce\ndef A071268(n):\n    s = ''.join(str(i) for i in range(1,n+1))\n    return sum(int(d) for d in s)*factorial(len(s)-1)*(10**len(s)-1)//(9*reduce(mul,(factorial(d) for d in (s.count(w) for w in set(s))))) \n"}
{"sequence_id": "A071295", "text": "Product of numbers of 0's and 1's in binary representation of n.", "sequence": "0,0,1,0,2,2,2,0,3,4,4,3,4,3,3,0,4,6,6,6,6,6,6,4,6,6,6,4,6,4,4,0,5,8,8,9,8,9,9,8,8,9,9,8,9,8,8,5,8,9,9,8,9,8,8,5,9,8,8,5,8,5,5,0,6,10,10,12,10,12,12,12,10,12,12,12,12,12,12,10,10,12,12,12,12,12,12,10,12,12,12", "code": "\ndef A071295(n):\n    return bin(n)[1:].count('0')*bin(n).count('1') \n"}
{"sequence_id": "A071321", "text": "Alternating sum of all prime factors of n; primes nondecreasing, starting with the least prime factor: A020639(n).", "sequence": "0,2,3,0,5,-1,7,2,0,-3,11,3,13,-5,-2,0,17,2,19,5,-4,-9,23,-1,0,-11,3,7,29,4,31,2,-8,-15,-2,0,37,-17,-10,-3,41,6,43,11,5,-21,47,3,0,2,-14,13,53,-1,-6,-5,-16,-27,59,-2,61,-29,7,0,-8", "code": "\nfrom sympy import factorint\ndef A071321(n):\n    fs = factorint(n,multiple=True)\n    return sum(fs[::2])-sum(fs[1::2]) \n"}
{"sequence_id": "A071362", "text": "Smallest n-digit prime with strictly increasing digits.", "sequence": "2,13,127,1237,12347,123457,1234789,12356789", "code": "\nfrom sympy import nextprime\ndef inc(n):\n  s = str(n); return len(s)==1 or all(d>pd for pd, d in zip(s[:-1], s[1:]))\ndef a(n):\n  p = nextprime(10**(n-1))\n  while not inc(p): p = nextprime(p)\n  return p\nfor n in range(1, 9):\n  print(a(n), end=\", \") \n"}
{"sequence_id": "A071531", "text": "Smallest exponent r such that n^r contains at least one zero digit (in base 10).", "sequence": "10,10,5,8,9,4,4,5,1,5,4,6,7,4,3,7,4,4,1,5,3,6,6,4,6,5,5,4,1,6,2,2,3,4,5,3,4,5,1,5,3,3,4,2,5,2,2,2,1,2,2,2,4,2,5,4,6,3,1,5,6,3,2,4,6,3,9,3,1,2,6,3,3,4,8,4,2,3,1,4,5,5,2,4,3,3,6,3,1,5,5,3,3,2,7,2,2,2,1,1,1,1,1,1", "code": "\ndef a(n):\n    r, p = 1, n\n    while 1:\n        if \"0\" in str(p):\n            return r\n        r += 1\n        p *= n\n[a(n) for n in range(2, 100)] \n"}
{"sequence_id": "A071590", "text": "Numbers k such that reversal(k) < n.", "sequence": "10,20,21,30,31,32,40,41,42,43,50,51,52,53,54,60,61,62,63,64,65,70,71,72,73,74,75,76,80,81,82,83,84,85,86,87,90,91,92,93,94,95,96,97,98,100,110,120,130,140,150,160,170,180,190,200,201,210,211,220,221,230,231", "code": "\ndef ok(n): return int(str(n)[::-1]) < n\nprint([k for k in range(232) if ok(k)]) \n"}
{"sequence_id": "A071778", "text": "Number of ordered triples (a, b, c) with gcd(a, b, c) = 1 and 1 <= {a, b, c} <= n.", "sequence": "1,7,25,55,115,181,307,439,637,841,1171,1447,1915,2329,2881,3433,4249,4879,5905,6745,7861,8911,10429,11557,13297,14773,16663,18355,20791,22495,25285,27541,30361,32905,36289,38845,42841,46027,49987,53395", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A071778(n):\n    if n == 0:\n        return 0\n    c, j = 1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A071778(k1)\n        j, k1 = j2, n//j2\n    return n*(n**2-1)-c+j \n"}
{"sequence_id": "A071837", "text": "Numbers k with the property that in the prime factorization of k all prime exponents are prime, their sum is also prime and equals the sum of distinct prime factors of k.", "sequence": "4,27,72,108,800,3125,12500,247808,823543,37879808,190512000,266716800,428652000,529200000,600112800,1234800000,1452124800,2420208000,2679075000,3307500000,7351381800,7441875000,7717500000,9376762500", "code": "\nfrom sympy import factorint, isprime\nA071837 = []\nfor n in range(1,10**5):\n....f = factorint(n)\n....fp, fe = list(f.keys()),list(f.values())\n....if sum(fp) == sum(fe) and isprime(sum(fe)) and all([isprime(e) for e in fe]):\n........A071837.append(n)\n\n"}
{"sequence_id": "A071869", "text": "Numbers n such that gpf(n) < gpf(n+1) < gpf(n+2) where gpf(x) denotes the largest prime factor of x.", "sequence": "8,9,20,21,24,27,32,45,56,57,77,81,84,90,91,92,105,114,120,125,132,135,140,144,147,165,168,169,170,171,175,176,177,189,200,204,212,216,220,221,225,231,234,235,247,252,260,261,275,288,289,300,315,324,345,354", "code": "\nfrom sympy import factorint\nA071869_list, p, q, r = [], 1, 2, 3\nfor n in range(2,10**4):\n    p, q, r = q, r, max(factorint(n+2))\n    if p < q < r:\n        A071869_list.append(n) \n"}
{"sequence_id": "A071870", "text": "Numbers k such that gpf(k) > gpf(k+1) > gpf(k+2) where gpf(k) denotes the largest prime factor of k.", "sequence": "13,14,34,37,38,43,61,62,73,79,86,94,103,118,122,123,142,151,152,157,158,163,173,185,193,194,202,206,214,218,223,229,241,254,257,258,271,277,278,283,284,295,298,302,313,317,318,321,322,326,331,334,341,373", "code": "\nfrom sympy import factorint\nA071870_list, p, q, r = [], 1, 2, 3\nfor n in range(2,10**4):\n    p, q, r = q, r, max(factorint(n+2))\n    if p > q > r:\n        A071870_list.append(n) \n"}
{"sequence_id": "A071904", "text": "Odd composite numbers.", "sequence": "9,15,21,25,27,33,35,39,45,49,51,55,57,63,65,69,75,77,81,85,87,91,93,95,99,105,111,115,117,119,121,123,125,129,133,135,141,143,145,147,153,155,159,161,165,169,171,175,177,183,185,187,189,195,201,203,205", "code": "\nfrom sympy import isprime\ndef ok(n): return n > 3 and n%2 == 1 and not isprime(n)\nprint(list(filter(ok, range(206)))) \n"}
{"sequence_id": "A071911", "text": "Numbers m such that Stern's diatomic A002487(m) is divisible by 3.", "sequence": "0,5,7,10,14,20,28,33,35,40,45,47,49,51,56,61,63,66,70,73,75,80,85,87,90,94,98,102,105,107,112,117,119,122,126,132,140,146,150,153,155,160,165,167,170,174,180,188,196,204,210,214,217,219,224,229,231,234,238,244,252", "code": "\ndef aupto(nn):\n  ok = [1] + [0 for i in range(nn)]\n  for m in range(nn+1):\n    if ok[m]:  \n      for i in [2*m, 8*m-5, 8*m+5, 8*m-7, 8*m+7]:\n        if 0 <= i <= nn: ok[i] = 1\n  return [m for m in range(nn+1) if ok[m]]\nprint(aupto(252)) \n"}
{"sequence_id": "A071931", "text": "Non-St\u00f8rmer numbers whose largest prime factor is a St\u00f8rmer number.", "sequence": "8,30,32,38,46,50,55,57,75,76,99,100,111,122,128,132,133,142,174,177,183,185,200,203,212,213,228,237,242,253,254,265,266,268,274,278,302,305,319,322,327,334,342,348,360,377,380,381,394,395,411,413,418,437", "code": "\nfrom sympy import factorint\ndef stormer(n): return max(factorint(n*n + 1)) >= 2*n\ndef ok(n): return not stormer(n) and stormer(max(factorint(n)))\nprint(list(filter(ok, range(1, 438)))) \n"}
{"sequence_id": "A072178", "text": "a(n)-th factorial is the smallest factorial containing exactly n 4's, or 0 if no such number exists.", "sequence": "4,19,21,24,44,42,50,57,0,60,76,91,56,86,85,66,92,88,114,129,131,106,130,122,117,157,134,175,119,150,181,165,185,179,198,182,220,228,188,190,261,235,222,231,229,233,224,227,288,372,241,279,254,253,318,267", "code": "\nfrom math import factorial\ndef a(n, limit=1000):\n  fact = 1\n  for t in range(limit+1):\n    if str(fact).count('4') == n: return t\n    fact *= (t+1)\n  return 0\nprint([a(n) for n in range(1, 57)]) \n"}
{"sequence_id": "A072204", "text": "a(n) is the smallest integer k whose factorial contains exactly n 7's, or 0 if no such number exists.", "sequence": "6,14,18,31,49,22,54,48,56,71,82,72,86,81,92,97,87,122,91,119,131,112,121,140,104,152,144,173,127,157,172,201,227,179,200,187,183,210,236,221,193,217,279,212,213,235,238,289,265,228,256,261,250,242,285,307", "code": "\ndef a(n, bound=10**4):\n    k = f = 1\n    while not str(f).count('7') == n and k <= bound: k += 1; f *= k\n    return k * (k <= bound)\nprint([a(n) for n in range(1, 149)]) \n"}
{"sequence_id": "A072214", "text": "Number of partitions of Fibonacci(n).", "sequence": "1,1,1,2,3,7,22,101,792,12310,451276,49995925,22540654445,60806135438329,1596675274490756791,758949605954969709105721,14362612091531863067120268402228,29498346711208035625096160181520548669694,23537552807178094028466621551669121053281242290608650", "code": "\nfrom sympy import npartitions as p, fibonacci as f\ndef a(n): return p(f(n)) \n"}
{"sequence_id": "A072215", "text": "a(0) = 4; for n >= 0, a(n+1) = number of partitions of a(n).", "sequence": "4,5,7,15,176,476715857290", "code": "\nfrom itertools import accumulate\nfrom sympy.ntheory import npartitions\ndef f(an, _): return npartitions(an)\nprint(list(accumulate([4]*6, f))) \n"}
{"sequence_id": "A072283", "text": "Number of raised dots to represent n in Braille.", "sequence": "7,5,6,6,7,6,7,8,7,6,8,6,7,7,8,7,8,9,8,7,9,7,8,8,9,8,9,10,9,8,9,7,8,8,9,8,9,10,9,8,10,8,9,9,10,9,10,11,10,9,9,7,8,8,9,8,9,10,9,8,10,8,9,9,10,9,10,11,10,9,11,9,10,10,11,10,11,12,11,10,10,8,9,9,10,9,10,11,10,9", "code": "\nB=[3,1,2,2,3,2,3,4,3,2]\ndef A072283(n):\n....s=0\n....for i in str(n):\n........s+=B[int(i)]\n....return s+4 \n"}
{"sequence_id": "A072351", "text": "Smallest n-digit Fibonacci number.", "sequence": "1,13,144,1597,10946,121393,1346269,14930352,102334155,1134903170,12586269025,139583862445,1548008755920,10610209857723,117669030460994,1304969544928657,14472334024676221,160500643816367088,1100087778366101931,12200160415121876738", "code": "\ndef A072351_list(n):\n    list = [1]\n    x, y = 1, 1\n    while len(list) < n:\n        if len(str(x)) < len(str(y)):\n            list.append(y)\n        x, y = y, x + y\n    return list\nprint(A072351_list(20)) \n"}
{"sequence_id": "A072352", "text": "a(n) is the largest n-digit Fibonacci number.", "sequence": "8,89,987,6765,75025,832040,9227465,63245986,701408733,7778742049,86267571272,956722026041,6557470319842,72723460248141,806515533049393,8944394323791464,99194853094755497,679891637638612258,7540113804746346429,83621143489848422977", "code": "\ndef A072352_list(n):\n    list = []\n    x, y = 1, 1\n    while len(list) < n:\n        if len(str(x)) < len(str(y)):\n            list.append(x)\n        x, y = y, x + y\n    return list\nprint(A072352_list(20)) \n"}
{"sequence_id": "A072353", "text": "a(n) is the index of the largest Fibonacci number containing n digits.", "sequence": "6,11,16,20,25,30,35,39,44,49,54,59,63,68,73,78,83,87,92,97,102,106,111,116,121,126,130,135,140,145,150,154,159,164,169,173,178,183,188,193,197,202,207,212,216,221,226,231,236,240,245,250,255,260,264,269,274", "code": "\ndef A072353_list(n):\n    list = []\n    x, y, index = 1, 1, 1\n    while len(list) < n:\n        if len(str(x)) < len(str(y)):\n            list.append(index)\n        x, y = y, x + y\n        index += 1\n    return list\nprint(A072353_list(57)) \n"}
{"sequence_id": "A072384", "text": "Primes which can be represented as the sum of a cube and its reverse.", "sequence": "2,727,79697,85147,100699,3946493,9715169,10301029,11592961,11851481,13888793,13913093,17746387,125000521,176232571,358030753,417302813,433748423,726463627,810090007,817807817,832595227,854121557,875444677", "code": "\nfrom sympy import isprime\ndef rev(n): return int(str(n)[::-1])\ndef aupto(lim):\n    c = [p**3 for p in range(1, int(lim**(1/3))+2)]\n    s = set(ara for ara in (a + rev(a) for a in c) if ara <= lim)\n    return sorted(filter(isprime, s))\nprint(aupto(10**9)) \n"}
{"sequence_id": "A072390", "text": "Sum of two powers of 13.", "sequence": "2,14,26,170,182,338,2198,2210,2366,4394,28562,28574,28730,30758,57122,371294,371306,371462,373490,399854,742586,4826810,4826822,4826978,4829006,4855370,5198102,9653618,62748518,62748530,62748686,62750714,62777078,63119810", "code": "\ndef aupto(lim):\n  pows, p = [], 1\n  while p < lim: pows.append(p); p *= 13\n  return sorted([a+b for a in pows for b in pows if b >= a and a+b <= lim])\nprint(aupto(63119810)) \n"}
{"sequence_id": "A072411", "text": "LCM of exponents in prime factorization of n, a(1) = 1.", "sequence": "1,1,1,2,1,1,1,3,2,1,1,2,1,1,1,4,1,2,1,2,1,1,1,3,2,1,3,2,1,1,1,5,1,1,1,2,1,1,1,3,1,1,1,2,2,1,1,4,2,2,1,2,1,3,1,3,1,1,1,2,1,1,2,6,1,1,1,2,1,1,1,6,1,1,2,2,1,1,1,4,4,1,1,2,1,1,1,3,1,2,1,2,1,1,1,5,1,2,2,2,1,1,1,3,1,1,1,6,1,1,1,4,1,1,1,2,2,1,1,3", "code": "\nfrom sympy import lcm, factorint\ndef a(n):\n    l=[]\n    f=factorint(n)\n    for i in f: l+=[f[i],]\n    return lcm(l)\nprint([a(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A072436", "text": "Remove prime factors of form 4*k+3.", "sequence": "1,2,1,4,5,2,1,8,1,10,1,4,13,2,5,16,17,2,1,20,1,2,1,8,25,26,1,4,29,10,1,32,1,34,5,4,37,2,13,40,41,2,1,4,5,2,1,16,1,50,17,52,53,2,5,8,1,58,1,20,61,2,1,64,65,2,1,68,1,10,1,8,73,74,25,4,1,26,1,80,1,82,1,4,85,2,29", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef a(n):\n    f = factorint(n)\n    return 1 if n == 1 else reduce(mul, [1 if i%4==3 else i**f[i] for i in f])\n"}
{"sequence_id": "A072438", "text": "Remove prime factors of form 4*k+1.", "sequence": "1,2,3,4,1,6,7,8,9,2,11,12,1,14,3,16,1,18,19,4,21,22,23,24,1,2,27,28,1,6,31,32,33,2,7,36,1,38,3,8,1,42,43,44,9,46,47,48,49,2,3,4,1,54,11,56,57,2,59,12,1,62,63,64,1,66,67,4,69,14,71,72,1,2,3,76,77,6,79,16,81,2", "code": "\nfrom sympy import factorint, prod\ndef a(n):\n    f = factorint(n)\n    return 1 if n == 1 else prod(i**f[i] for i in f if i%4 != 1) \n"}
{"sequence_id": "A072452", "text": "a(n) = reversal(a(n-1)+n) for n>0, a(0) = 0.", "sequence": "0,1,3,6,1,6,21,82,9,81,19,3,51,46,6,12,82,99,711,37,75,69,19,24,84,901,729,657,586,516,645,676,807,48,28,36,27,46,48,78,811,258,3,64,801,648,496,345,393,244,492,345,793,648,207,262,813,78,631,96,651,217,972", "code": " \n"}
{"sequence_id": "A072481", "text": "a(n) = Sum_{k=1..n} Sum_{d=1..k} (k mod d).", "sequence": "0,0,0,1,2,6,9,17,25,37,50,72,89,117,148,184,220,271,318,382,443,513,590,688,773,876,988,1113,1237,1388,1526,1693,1860,2044,2241,2459,2657,2890,3138,3407,3665,3962,4246,4571,4899,5238,5596,5999,6373,6787,7207", "code": "\nfor n in range(99):\n    s = 0\n    for k in range(1,n+1):\n      for d in range(1,k+1):\n        s += k % d\n    print(str(s), end=',')\n"}
{"sequence_id": "A072649", "text": "n occurs Fibonacci(n) times (cf. A000045).", "sequence": "1,2,3,3,4,4,4,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10", "code": "\nfrom sympy import fibonacci\ndef a(n):\n    if n<1: return 0\n    m=0\n    while fibonacci(m)<=n: m+=1\n    return m-2\nprint([a(n) for n in range(1, 101)]) \n(MIT Scheme) (define (A072649 n) (let ((b (A072648 n))) (+ -1 b (floor->exact (/ n (A000045 (1+ b))))))) ;; (The implementation below is better)\n"}
{"sequence_id": "A072687", "text": "Number of primes with prime length names in range 1 -> 10^n.", "sequence": "3,8,39,269,3047,14288,140205,1567591,10764655", "code": "\nfrom num2words import num2words\nfrom sympy import isprime, primerange\ndef n2w(n):\n  return num2words(n).replace(\",\", \"\").replace(\" \", \"\").replace(\"-\", \"\")\ndef a(n): return sum(isprime(len(n2w(p))) for p in primerange(2, 10**n))\nprint([a(n) for n in range(1, 7)]) \n"}
{"sequence_id": "A072691", "text": "Decimal expansion of Pi^2/12.", "sequence": "8,2,2,4,6,7,0,3,3,4,2,4,1,1,3,2,1,8,2,3,6,2,0,7,5,8,3,3,2,3,0,1,2,5,9,4,6,0,9,4,7,4,9,5,0,6,0,3,3,9,9,2,1,8,8,6,7,7,7,9,1,1,4,6,8,5,0,0,3,7,3,5,2,0,1,6,0,0,4,3,6,9,1,6,8,1,4,4,5,0,3,0,9,8,7,9,3,5,2,6,5,2,0,0,2", "code": "\nfrom mpmath import *\nmp.dps=106\nprint([int(c) for c in list(str(zeta(2)/2))[2:-1]]) \n"}
{"sequence_id": "A072692", "text": "Sum of sigma(j) for 1<=j<=10^n, where sigma(j) is the sum of the divisors of j.", "sequence": "1,87,8299,823081,82256014,8224740835,822468118437,82246711794796,8224670422194237,822467034112360628,82246703352400266400,8224670334323560419029,822467033425357340138978,82246703342420509396897774,8224670334241228180927002517", "code": " [(i, sum([d*(10**i//d) for d in range(1,10**i+1)])) for i in range(8)] \n"}
{"sequence_id": "A072831", "text": "Number of bits in n!.", "sequence": "1,1,2,3,5,7,10,13,16,19,22,26,29,33,37,41,45,49,53,57,62,66,70,75,80,84,89,94,98,103,108,113,118,123,128,133,139,144,149,154,160,165,170,176,181,187,192,198,203,209,215,220,226,232,238,243,249,255,261,267", "code": "\nimport math\ndef a(n):\n  return len(bin(math.factorial(n))[2:]) \n"}
{"sequence_id": "A072857", "text": "Primeval numbers: numbers that set a record for the number of distinct primes that can be obtained by permuting some subset of their digits.", "sequence": "1,2,13,37,107,113,137,1013,1037,1079,1237,1367,1379,10079,10123,10136,10139,10237,10279,10367,10379,12379,13679,100279,100379,101237,102347,102379,103679,123479,1001237,1002347,1002379,1003679,1012349,1012379,1023457,1023467,1023479,1234579,1234679,10012349", "code": " \n"}
{"sequence_id": "A072960", "text": "Numbers using only the curved digits 0, 3, 6, 8 and 9.", "sequence": "0,3,6,8,9,30,33,36,38,39,60,63,66,68,69,80,83,86,88,89,90,93,96,98,99,300,303,306,308,309,330,333,336,338,339,360,363,366,368,369,380,383,386,388,389,390,393,396,398,399,600,603,606,608,609,630,633,636,638", "code": "\nfrom itertools import product\nA072960_list = [0] + [int(a+''.join(b)) for l in range(5) for a in '3689' for b in product('03689',repeat=l)] \n"}
{"sequence_id": "A072961", "text": "Numbers using only the digits 2 and 5, or numbers that are both curved and linear.", "sequence": "2,5,22,25,52,55,222,225,252,255,522,525,552,555,2222,2225,2252,2255,2522,2525,2552,2555,5222,5225,5252,5255,5522,5525,5552,5555,22222,22225,22252,22255,22522,22525,22552,22555,25222,25225,25252,25255", "code": "\nfrom itertools import product\nA072961_list = [int(''.join(a)) for l in range(1,11) for a in product('25',repeat=l)] \n"}
{"sequence_id": "A072968", "text": "Least k>0 such that the last digit of (n+k)^(n+k) is the same as the last digit of n^n.", "sequence": "10,16,14,2,10,2,6,4,10,10,10,2,14,2,10,8,6,4,10,10,10,16,14,2,10,2,6,4,10,10,10,2,14,2,10,8,6,4,10,10,10,16,14,2,10,2,6,4,10,10,10,2,14,2,10,8,6,4,10,10,10,16,14,2,10,2,6,4,10,10,10,2,14,2,10,8,6,4,10,10,10", "code": "\ndef a(n):\n    k, target = 1, pow(n, n, 10)\n    while pow(n+k, n+k, 10) != target: k += 1\n    return k\nprint([a(n) for n in range(1, 82)]) \n"}
{"sequence_id": "A073069", "text": "Indices of primes with non-distinct digits.", "sequence": "5,26,30,32,36,42,43,46,47,48,49,50,51,59,64,65,67,68,71,74,76,84,86,87,95,102,106,109,121,123,129,130,134,137,138,139,141,151,152,153,154,156,157,158,165,167,168,169,170,171,172,173,174,177,178,182,185,186", "code": "\nfrom sympy import prime, primerange\ndef ok(p): s = str(p); return len(set(s)) < len(s)\ndef aupto(limit):\n  alst = []\n  for pi, p in enumerate(primerange(1, prime(limit)+1), start = 1):\n    if ok(p): alst.append(pi)\n  return alst\nprint(aupto(186)) \n"}
{"sequence_id": "A073136", "text": "a(n) = prime(n) + prime(prime(n)).", "sequence": "5,8,16,24,42,54,76,86,106,138,158,194,220,234,258,294,336,344,398,424,440,480,514,550,606,648,666,694,708,730,836,870,910,936,1008,1028,1076,1130,1158,1204,1242,1268,1344,1364,1398,1416,1508,1632,1660,1676,1704", "code": "\nfrom sympy import prime, sieve\ndef aupton(terms):\n  p = [None] + list(sieve.primerange(1, prime(prime(terms))+1))\n  return [p[n] + p[p[n]] for n in range(1, terms+1)]\nprint(aupton(51)) \n"}
{"sequence_id": "A073137", "text": "a(n) is the least number whose binary representation has the same number of 0's and 1's as n.", "sequence": "0,1,2,3,4,5,5,7,8,9,9,11,9,11,11,15,16,17,17,19,17,19,19,23,17,19,19,23,19,23,23,31,32,33,33,35,33,35,35,39,33,35,35,39,35,39,39,47,33,35,35,39,35,39,39,47,35,39,39,47,39,47,47,63,64,65,65,67,65,67,67,71,65", "code": "\ndef a(n):\n    b = bin(n)[2:]; z = b.count('0'); w = len(b) - z\n    return int('1'*(w > 0) + '0'*z + '1'*(w-1), 2)\nprint([a(n) for n in range(73)]) \n"}
{"sequence_id": "A073137", "text": "a(n) is the least number whose binary representation has the same number of 0's and 1's as n.", "sequence": "0,1,2,3,4,5,5,7,8,9,9,11,9,11,11,15,16,17,17,19,17,19,19,23,17,19,19,23,19,23,23,31,32,33,33,35,33,35,35,39,33,35,35,39,35,39,39,47,33,35,35,39,35,39,39,47,35,39,39,47,39,47,47,63,64,65,65,67,65,67,67,71,65", "code": "\ndef a(n): b = bin(n)[2:]; return int(b[0] + \"\".join(sorted(b[1:])), 2)\nprint([a(n) for n in range(73)]) \n"}
{"sequence_id": "A073138", "text": "Largest number having in its binary representation the same number of 0's and 1's as n.", "sequence": "0,1,2,3,4,6,6,7,8,12,12,14,12,14,14,15,16,24,24,28,24,28,28,30,24,28,28,30,28,30,30,31,32,48,48,56,48,56,56,60,48,56,56,60,56,60,60,62,48,56,56,60,56,60,60,62,56,60,60,62,60,62,62,63,64,96,96,112,96,112,112", "code": "\ndef a(n): return int(\"\".join(sorted(bin(n)[2:], reverse=True)), 2)\nprint([a(n) for n in range(71)]) \n"}
{"sequence_id": "A073327", "text": "Write U.S. English name for n (ignoring hyphens and spaces) and add numerical values of letters using a=1, b=2, ..., y=25, z=26.", "sequence": "64,34,58,56,60,42,52,65,49,42,39,63,87,99,104,65,96,109,73,86,107,141,165,163,167,149,159,172,156,149,100,134,158,156,160,142,152,165,149,142,84,118,142,140,144,126,136,149,133,126,66,100,124,122,126,108,118", "code": "\nimport re\nfrom num2words import num2words\n\ndef A073327(n): return sum(ord(d)-96 for d in re.sub(\"\\sand\\s|[^a-z]\", \"\", num2words(n)))\n\ndef A073327(n): return sum(ord(d)-96 for d in re.sub(\"[^a-z]\", \"\", num2words(n, lang='en_GB'))) \n"}
{"sequence_id": "A073340", "text": "Fibonacci prime pairs: the indices of each pair differ by two and the relevant Fibonacci numbers are both prime.", "sequence": "3,5,5,7,11,13,431,433,569,571", "code": "\nfrom sympy import isprime\ndef afind(limit):\n  i, fnm2, fnm1 = 1, 1, 1\n  while i < limit:\n    if isprime(fnm2) and isprime(fnm2 + fnm1):\n      print(i, i+2, sep=\", \", end=\", \")\n    i, fnm2, fnm1 = i+1, fnm1, fnm2 + fnm1\nafind(600) \n"}
{"sequence_id": "A073395", "text": "Product of sums of prime factors of n: with and without repetition.", "sequence": "0,4,9,8,25,25,49,12,18,49,121,35,169,81,64,16,289,40,361,63,100,169,529,45,50,225,27,99,841,100,961,20,196,361,144,50,1369,441,256,77,1681,144,1849,195,88,625,2209,55,98,84,400,255,2809,55,256,117,484", "code": "\nfrom sympy import primefactors, factorint\ndef a001414(n):\n    f=factorint(n)\n    return sum([i*f[i] for i in f])\ndef a(n): return 0 if n==1 else sum(primefactors(n))*a001414(n)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A073443", "text": "Numbers n such that n! - n - 1 is prime.", "sequence": "3,4,10,12,346", "code": "\nfrom math import factorial\nfrom sympy import isprime\ndef ok(n): return isprime(factorial(n) - n - 1)\nprint([m for m in range(3, 500) if ok(m)]) \n"}
{"sequence_id": "A073490", "text": "Number of prime gaps in factorization of n.", "sequence": "0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,0,1,0,1,0,1,0,0,0,2,1,1,0,1,1,1,1,1,1,0", "code": "\nfrom sympy import primefactors, nextprime\ndef a(n):\n    pf = primefactors(n)\n    return sum(p2 != nextprime(p1) for p1, p2 in zip(pf[:-1], pf[1:]))\nprint([a(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A073493", "text": "Numbers having exactly one prime gap in their factorization.", "sequence": "10,14,20,21,22,26,28,33,34,38,39,40,42,44,46,50,51,52,55,56,57,58,62,63,65,66,68,69,70,74,76,78,80,82,84,85,86,87,88,91,92,93,94,95,98,99,100,102,104,106,111,112,114,115,116,117,118,119,122,123,124,126,129", "code": "\nfrom sympy import primefactors, nextprime\ndef ok(n):\n    pf = primefactors(n)\n    return sum(p2 != nextprime(p1) for p1, p2 in zip(pf[:-1], pf[1:])) == 1\nprint(list(filter(ok, range(1, 130)))) \n"}
{"sequence_id": "A073532", "text": "Number of n-digit primes with all digits distinct.", "sequence": "4,20,97,510,2529,10239,33950,90510,145227,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom itertools import permutations\nfrom sympy import isprime, primerange\ndef distinct_digs(n): s = str(n); return len(s) == len(set(s))\ndef a(n):\n  if n >= 10: return 0\n  return sum(isprime(int(\"\".join(p))) for p in permutations(\"0123456789\", n) if p[0] != '0')\nprint([a(n) for n in range(1, 31)]) \n"}
{"sequence_id": "A073577", "text": "a(n) = 4*n^2 + 4*n - 1.", "sequence": "7,23,47,79,119,167,223,287,359,439,527,623,727,839,959,1087,1223,1367,1519,1679,1847,2023,2207,2399,2599,2807,3023,3247,3479,3719,3967,4223,4487,4759,5039,5327,5623,5927,6239,6559,6887,7223,7567,7919,8279,8647", "code": " for n in range(1,50): print(4*n**2+4*n-1, end=', ') \n"}
{"sequence_id": "A073633", "text": "Numbers k that divide floor((3/2)^k) = A002379(k).", "sequence": "1,2,3,16,43,50,56,193,283,961,970,4958,9439,10493,11375,18552,57051,81602,617287,917186,1525995,5107085,9162821,22008620", "code": "\nfrom gmpy2 import mpz, t_div_2exp, t_mod\nA073633_list, m = [], mpz(1)\nfor n in range(1,10**9):\n    m *= 3\n    if t_mod(t_div_2exp(m,n),n) == 0:\n        A073633_list.append(n) \n"}
{"sequence_id": "A073642", "text": "Replace 2^k in the binary representation of n with k (i.e., if n = 2^a + 2^b + 2^c + ... then a(n) = a + b + c + ...).", "sequence": "0,0,1,1,2,2,3,3,3,3,4,4,5,5,6,6,4,4,5,5,6,6,7,7,7,7,8,8,9,9,10,10,5,5,6,6,7,7,8,8,8,8,9,9,10,10,11,11,9,9,10,10,11,11,12,12,12,12,13,13,14,14,15,15,6,6,7,7,8,8,9,9,9,9,10,10,11,11,12,12,10,10,11,11,12,12,13,13", "code": "\ndef A073642(n):\n    a, i = 0, 0\n    while n > 0:\n        a, n, i = a+(n%2)*i, n//2, i+1\n    return a\nprint([A073642(n) for n in range(30)]) \n"}
{"sequence_id": "A073785", "text": "Numbers in base -3.", "sequence": "0,1,2,120,121,122,110,111,112,100,101,102,220,221,222,210,211,212,200,201,202,12020,12021,12022,12010,12011,12012,12000,12001,12002,12120,12121,12122,12110,12111,12112,12100,12101,12102,12220,12221,12222", "code": "\ndef A073785(n):\n    s, q = '', n\n    while q >= 3 or q < 0:\n        q, r = divmod(q, -3)\n        if r < 0:\n            q += 1\n            r += 3\n        s += str(r)\n    return int(str(q)+s[::-1]) \n"}
{"sequence_id": "A073786", "text": "Numbers in base -5.", "sequence": "0,1,2,3,4,140,141,142,143,144,130,131,132,133,134,120,121,122,123,124,110,111,112,113,114,100,101,102,103,104,240,241,242,243,244,230,231,232,233,234,220,221,222,223,224,210,211,212,213,214,200,201,202,203", "code": "\ndef A073786(n):\n    s, q = '', n\n    while q >= 5 or q < 0:\n        q, r = divmod(q, -5)\n        if r < 0:\n            q += 1\n            r += 5\n        s += str(r)\n    return int(str(q)+s[::-1]) \n"}
{"sequence_id": "A073787", "text": "Numbers in base -6.", "sequence": "0,1,2,3,4,5,150,151,152,153,154,155,140,141,142,143,144,145,130,131,132,133,134,135,120,121,122,123,124,125,110,111,112,113,114,115,100,101,102,103,104,105,250,251,252,253,254,255,240,241,242,243,244,245", "code": "\ndef A073787(n):\n    s, q = '', n\n    while q >= 6 or q < 0:\n        q, r = divmod(q, -6)\n        if r < 0:\n            q += 1\n            r += 6\n        s += str(r)\n    return int(str(q)+s[::-1]) \n"}
{"sequence_id": "A073788", "text": "Numbers in base -7.", "sequence": "0,1,2,3,4,5,6,160,161,162,163,164,165,166,150,151,152,153,154,155,156,140,141,142,143,144,145,146,130,131,132,133,134,135,136,120,121,122,123,124,125,126,110,111,112,113,114,115,116,100,101,102,103,104,105", "code": "\ndef A073788(n):\n    s, q = '', n\n    while q >= 7 or q < 0:\n        q, r = divmod(q, -7)\n        if r < 0:\n            q += 1\n            r += 7\n        s += str(r)\n    return int(str(q)+s[::-1]) \n"}
{"sequence_id": "A073789", "text": "Numbers in base -8.", "sequence": "0,1,2,3,4,5,6,7,170,171,172,173,174,175,176,177,160,161,162,163,164,165,166,167,150,151,152,153,154,155,156,157,140,141,142,143,144,145,146,147,130,131,132,133,134,135,136,137,120,121,122,123,124,125,126", "code": "\ndef A073789(n):\n    s, q = '', n\n    while q >= 8 or q < 0:\n        q, r = divmod(q, -8)\n        if r < 0:\n            q += 1\n            r += 8\n        s += str(r)\n    return int(str(q)+s[::-1]) \n"}
{"sequence_id": "A073790", "text": "Numbers in base -9.", "sequence": "0,1,2,3,4,5,6,7,8,180,181,182,183,184,185,186,187,188,170,171,172,173,174,175,176,177,178,160,161,162,163,164,165,166,167,168,150,151,152,153,154,155,156,157,158,140,141,142,143,144,145,146,147,148,130,131", "code": "\ndef A073790(n):\n    s, q = '', n\n    while q >= 9 or q < 0:\n        q, r = divmod(q, -9)\n        if r < 0:\n            q += 1\n            r += 9\n        s += str(r)\n    return int(str(q)+s[::-1]) \n"}
{"sequence_id": "A073799", "text": "Numbers that begin a run of consecutive integers k such that PrimePi(k) divides 2^k.", "sequence": "2,7,19,53,131,311,719,1619,3671,8161,17863,38873,84017,180503,386093,821641,1742537,3681131,7754077,16290047,34136029,71378569,148948139,310248241,645155197,1339484197,2777105129,5750079047,11891268401,24563311309,50685770167,104484802057,215187847711", "code": "\nfrom sympy import prime\ndef A073799(n):\n    return 2 if n == 1 else prime(2**n) \n"}
{"sequence_id": "A073846", "text": "a(1) = 1; thereafter, every even-indexed term is prime and every odd-indexed term is composite.", "sequence": "1,2,4,3,6,5,8,7,9,11,10,13,12,17,14,19,15,23,16,29,18,31,20,37,21,41,22,43,24,47,25,53,26,59,27,61,28,67,30,71,32,73,33,79,34,83,35,89,36,97,38,101,39,103,40,107,42,109,44,113,45,127,46,131,48,137,49,139,50", "code": "\nfrom sympy import prime, composite\ndef A073846(n): return 1 if n == 1 else (composite(n//2) if n % 2 else prime(n//2)) \n"}
{"sequence_id": "A073930", "text": "Numbers that are equal to the sum of their anti-divisors.", "sequence": "5,8,41,56,946,5186,6874,8104,17386,27024,84026,167786,2667584,4921776,27914146,505235234,3238952914,73600829714,455879783074,528080296234,673223621664,4054397778846,4437083907194,4869434608274,6904301600914,7738291969456", "code": "\nfrom sympy import divisors\nA073930 = [n for n in range(1,10**5) if sum([2*d for d in divisors(n) if n > 2*d and n % (2*d)] + [d for d in divisors(2*n-1) if n > d >=2 and n % d] + [d for d in divisors(2*n+1) if n > d >=2 and n % d]) == n] \n"}
{"sequence_id": "A073931", "text": "Numbers n such that the sum of the anti-divisors of n = 2n.", "sequence": "77,1568,2768,4775040", "code": "\nfrom sympy import divisors\nA073931 = [n for n in range(3,10**5) if sum([2*d for d in divisors(n) if n > 2*d and n % (2*d)] + [d for d in divisors(2*n-1) if n > d >=2 and n % d] + [d for d in divisors(2*n+1) if n > d >=2 and n % d]) == 2*n]\n\n"}
{"sequence_id": "A073946", "text": "Squares k such that k + pi(k) is a prime.", "sequence": "9,36,81,121,361,625,961,3136,6724,8281,9604,10609,12996,13225,19881,25281,38025,39204,40000,43264,44944,45796,47961,60516,64009,79524,80089,80656,83521,86436,90000,93636,103684,117649,121801,129600", "code": "\nfrom sympy import primepi, isprime\nN = (x**2 for x in range(1, 1001))\nprint([n for n in N if isprime(n + primepi(n))]) \n"}
{"sequence_id": "A073954", "text": "Numbers k such that the sum of the anti-divisors of k exceeds 2*k.", "sequence": "143,175,203,247,248,270,280,297,315,325,333,347,357,368,410,423,462,472,473,500,518,522,553,563,567,578,585,598,630,637,675,682,693,697,725,742,760,770,787,788,808,833,850,858,878,893,913,945,963,977,990", "code": "\nA073954 = [n for n in range(1,10**5) if sum([d for d in range(2,n,2) if n%d and not 2*n%d])+sum([d for d in range(3,n,2) if n%d and 2*n%d in [d-1,1]]) > 2*n] \n"}
{"sequence_id": "A073956", "text": "Palindromes whose sum of anti-divisors is palindromic.", "sequence": "1,2,3,4,5,6,8,9,242,252,323,434,727,4774,32223,42024,43234,46864,64946,70607,4855584,4942494,6125216,6265626,149939941,188737881,241383142,389181983,470212074,27685458672,42685658624,45625352654,61039793016", "code": "\nfrom itertools import chain\ndef is_palindrome(x):\n....return x == x[::-1]\nA073956 = sorted([n for n in chain(map(lambda x:int(str(x)+str(x)[::-1]),range(1,10**2)),map(lambda x:int(str(x)+str(x)[-2::-1]), range(1,10**3))) if is_palindrome(str(int(sum([d for d in range(2,n,2) if n%d and not 2*n%d]))+int(sum([d for d in range(3,n,2) if n%d and 2*n%d in [d-1,1]]))))]) \n"}
{"sequence_id": "A074051", "text": "For each n there are uniquely determined numbers a(n) and b(n) and a polynomial p_n(x) such that for all integers m we have Sum_{i=1..m}i^n(i+1)! = a(n)*Sum_{i=1..m} (i+1)! + p_n(m)*(m+2)! + b(n). The sequence b(n) is A074052.", "sequence": "1,-1,0,3,-7,0,59,-217,146,2593,-15551,32802,160709,-1856621,7971872,1299951,-287113779,2262481448,-7275903849,-36989148757,698330745002,-4867040141851,10231044332629,184216198044034,-2679722886596295,17971204188130391,-17976259717948832", "code": "\nfrom itertools import accumulate\ndef A074051_list(size):\n    if size < 1: return []\n    L, accu = [], [1]\n    for n in range(size-1):\n        accu = list(accumulate([-accu[-1]] + accu))\n        L.append(-(-1)**n*accu[-2])\n    return L\nprint(A074051_list(28)) \n"}
{"sequence_id": "A074100", "text": "Cubes using only digits 1, 2, 3, 5 and 7.", "sequence": "1,27,125,512,1331,3375,753571,2571353,5177717,17173512,25153757,72511713,11512557512,22211737731,27135225125,125375375125,552377215125,2252212155712,3531251132352,7127771131125,23771111713777,31122112521375,37521355131352,125112533753375", "code": "\nA074100_list = [n**3 for n in range(1,10**6) if set(str(n**3)) <= set('12357')] \n"}
{"sequence_id": "A074200", "text": "a(n) = m, the smallest number such that (m+k)/k is prime for k=1, 2, ..., n.", "sequence": "1,2,12,12720,19440,5516280,5516280,7321991040,363500177040,2394196081200,3163427380990800,22755817971366480,3788978012188649280,2918756139031688155200", "code": "\nfrom sympy import isprime, lcm\ndef A074200(n):\n    a = lcm(range(1,n+1))\n    m = a\n    while True:\n        for k in range(n,0,-1):\n            if not isprime(m//k+1):\n                break\n        else:\n            return m\n        m += a \n"}
{"sequence_id": "A074340", "text": "a(1) = 5; a(n) is smallest number > a(n-1) such that the juxtaposition a(1)a(2)...a(n) is a prime.", "sequence": "5,9,23,37,39,47,57,97,119,187,257,271,273,281,309,367,449,529,687,759,933,1031,1131,1237,1263,1343,1731,1861,2177,2337,2589,2607,2743,3191,3199,3281,3499,3807,3867,4133,6079,6189,6593,7207,7479,7523,8569,8571", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n  alst, astr = [5], \"5\"\n  while len(alst) < terms:\n    an = alst[-1] + 2\n    while an%5 ==0 or not isprime(int(astr + str(an))): an += 2\n    alst, astr = alst + [an], astr + str(an)\n  return alst\nprint(aupton(48)) \n"}
{"sequence_id": "A074342", "text": "a(1) = 6; a(n) is smallest number > a(n-1) such that the juxtaposition a(1)a(2)...a(n) is a prime.", "sequence": "6,7,19,21,23,27,57,183,207,231,247,267,399,417,441,459,569,603,693,847,933,1107,1149,1197,1251,1581,1619,2061,2137,2139,2339,2643,2703,2743,2847,2987,3199,3447,3477,3641,3919,4241,4369,4599,4761,6647,6739,6831", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n  alst, astr = [6], \"6\"\n  for n in range(2, terms+1):\n    an = alst[-1] + 1\n    while not isprime(int(astr+str(an))): an += 1\n    alst, astr = alst + [an], astr + str(an)\n  return alst\nprint(aupton(62)) \n"}
{"sequence_id": "A074346", "text": "a(1) = 10; a(n) is smallest number > a(n-1) such that the juxtaposition a(1)a(2)...a(n) is a prime.", "sequence": "10,13,23,49,111,113,171,211,293,309,333,387,463,479,513,687,933,973,993,1329,1433,1449,1551,2071,2271,2423,2587,2621,2659,2757,2771,2911,3081,3243,3279,3671,4243,4247,4371,4453,4511,5229,6097,6177,6293,6571", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n    alst, astr = [10], \"10\"\n    while len(alst) < terms:\n        k = alst[-1] + 1 + (alst[-1]%2)\n        while not isprime(int(astr+str(k))): k += 2\n        alst.append(k)\n        astr += str(k)\n    return alst\nprint(aupton(46)) \n"}
{"sequence_id": "A074365", "text": "Smallest prime > the concatenation of the first n natural numbers.", "sequence": "2,13,127,1237,12347,123457,1234577,12345701,123456791,12345678923,1234567891013,123456789101119,12345678910111223,1234567891011121343,123456789101112131449,12345678910111213141523,1234567891011121314151753,123456789101112131415161869", "code": "\nfrom sympy import nextprime\ndef a(n):\n  return nextprime(int(\"\".join(map(str, (i for i in range(1, n+1)))))-1)\nprint([a(n) for n in range(1, 19)]) \n"}
{"sequence_id": "A074366", "text": "The first prime greater than the concatenation of the first n primes.", "sequence": "3,29,239,2371,235723,23571127,2357111357,235711131727,23571113171939,2357111317192343,235711131719232977,23571113171923293283,2357111317192329313801,235711131719232931374149,23571113171923293137414371,2357111317192329313741434781", "code": "\nfrom sympy import nextprime, prime, primerange\ndef a(n):\n  return nextprime(int(\"\".join(map(str, primerange(2, prime(n)+1)))))\nprint([a(n) for n in range(1, 17)]) \n"}
{"sequence_id": "A074473", "text": "Dropping time for the 3x+1 problem: for n >= 2, number of iteration that first becomes smaller than the initial value if Collatz-function (A006370) is iterated starting at n; a(1)=1 by convention.", "sequence": "1,2,7,2,4,2,12,2,4,2,9,2,4,2,12,2,4,2,7,2,4,2,9,2,4,2,97,2,4,2,92,2,4,2,7,2,4,2,14,2,4,2,9,2,4,2,89,2,4,2,7,2,4,2,9,2,4,2,12,2,4,2,89,2,4,2,7,2,4,2,84,2,4,2,9,2,4,2,14,2,4,2,7,2,4,2,9,2,4,2,74,2,4,2,14,2,4,2,7", "code": "\ndef a(n):\n    if n<3: return n\n    N=n\n    x=1\n    while True:\n        if n%2==0: n/=2\n        else: n = 3*n + 1\n        x+=1\n        if n<N: return x\n[a(n) for n in range(1, 101)] \n"}
{"sequence_id": "A074515", "text": "a(n) = 1^n + 4^n + 9^n.", "sequence": "3,14,98,794,6818,60074,535538,4799354,43112258,387682634,3487832978,31385253914,282446313698,2541932937194,22877060890418,205892205836474,1853024483819138,16677198879535754,150094704016475858", "code": "\ndef a(n): return 1 + 4**n + 9**n\nprint([a(n) for n in range(19)]) \n"}
{"sequence_id": "A074535", "text": "a(n) = 2^n + 4^n + 8^n.", "sequence": "3,14,84,584,4368,33824,266304,2113664,16843008,134480384,1074791424,8594130944,68736258048,549822930944,4398314962944,35185445863424,281479271743488,2251816993685504,18014467229220864,144115462954287104", "code": "\ndef a(n): return 2**n + 4**n + 8**n\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A074584", "text": "Esanacci (hexanacci or \"6-anacci\") numbers.", "sequence": "6,1,3,7,15,31,63,120,239,475,943,1871,3711,7359,14598,28957,57439,113935,225999,448287,889215,1763832,3498707,6939975,13766015,27306031,54163775,107438335,213112838,422726969,838513963,1663261911,3299217791,6544271807", "code": "\ndef aupton(nn):\n  alst = [6, 1, 3, 7, 15, 31]\n  for n in range(6, nn+1): alst.append(sum(alst[n-6:n]))\n  return alst[:nn+1]\nprint(aupton(33)) \n"}
{"sequence_id": "A074638", "text": "Denominator of 1/3 + 1/7 + 1/11 + ... + 1/(4n-1).", "sequence": "3,21,231,385,7315,168245,4542615,140821065,28164213,366134769,15743795067,739958368149,12579292258533,62896461292665,3710891216267235,3710891216267235,248629711489904745,17652709515783236895,88263547578916184475,6972820258734378573525", "code": "\nfrom fractions import Fraction\ndef a(n): return sum(Fraction(1, 4*i-1) for i in range(1, n+1)).denominator\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A074713", "text": "Numbers n such that the sum of the anti-divisors of n = phi(n).", "sequence": "3,19,131,139,3949,5881,11341,29501,65789,5440591,2471800109", "code": "\nfrom sympy import divisors, totient\nA074713 = [n for n in range(1,10**5) if sum([2*d for d in divisors(n) if n > 2*d and n%(2*d)] + [d for d in divisors(2*n-1) if n > d >=2 and n%d] + [d for d in divisors(2*n+1) if n > d >=2 and n%d]) == totient(n)] \n"}
{"sequence_id": "A074730", "text": "Squares whose sum of anti-divisors is a square.", "sequence": "1,121,169,841,2047288797225,61838862885361", "code": "\nfrom gmpy2 import is_square\nfrom sympy import divisors\nA074730 = [n for n in (x**2 for x in range(1,10**4)) if is_square(int(sum([2*d for d in divisors(n) if n > 2*d and n%(2*d)] + [d for d in divisors(2*n-1) if n > d >=2 and n%d] + [d for d in divisors(2*n+1) if n > d >=2 and n%d])))]\n\n"}
{"sequence_id": "A074748", "text": "Numbers for which the differences between consecutive anti-divisors (ordered by size) are not distinct.", "sequence": "15,17,20,22,28,30,32,37,38,39,43,45,52,53,58,59,62,67,73,75,77,82,85,87,88,90,94,95,97,98,99,105,111,115,118,120,122,123,124,127,128,135,137,138,142,143,145,148,149,150,157,158,162,171,172,173,175,178,179,181,182,185,188,189,193,195", "code": " \n"}
{"sequence_id": "A074831", "text": "Number of binary reversal primes less than 10^n.", "sequence": "3,20,101,508,3053,20053,141772,1045600,8038954,63830588,518935134,4311185894", "code": "\nfrom sympy import isprime, primerange\ndef is_bin_rev_prime(n): return isprime(int(bin(n)[2:][::-1], 2))\ndef a(n): return sum(is_bin_rev_prime(p) for p in primerange(1, 10**n))\nprint([a(n) for n in range(1, 7)]) \n"}
{"sequence_id": "A074832", "text": "Primes whose binary reversal is also prime.", "sequence": "3,5,7,11,13,17,23,29,31,37,41,43,47,53,61,67,71,73,83,97,101,107,113,127,131,151,163,167,173,181,193,197,199,223,227,229,233,251,257,263,269,277,283,307,313,331,337,349,353,359,373,383,409,421,431,433,443", "code": "\nfrom sympy import isprime, prime\nA074832 = [prime(n) for n in range(1,10**6) if isprime(int(bin(prime(n))[:1:-1],2))] \n"}
{"sequence_id": "A074837", "text": "Numbers k such that the penultimate 3 divisors of k sum to k.", "sequence": "6,18,42,54,66,78,102,114,126,138,162,174,186,198,222,234,246,258,282,294,306,318,342,354,366,378,402,414,426,438,462,474,486,498,522,534,546,558,582,594,606,618,642,654,666,678,702,714,726,738,762,774,786", "code": "\nfrom sympy import divisors\ndef ok(n): d = divisors(n); return False if len(d)<4 else n==sum(d[-4:-1])\nprint(list(filter(ok, range(800)))) \n"}
{"sequence_id": "A074851", "text": "Numbers k such that k and k+1 both have exactly 2 distinct prime factors.", "sequence": "14,20,21,33,34,35,38,39,44,45,50,51,54,55,56,57,62,68,74,75,76,85,86,87,91,92,93,94,95,98,99,111,115,116,117,118,122,123,133,134,135,141,142,143,144,145,146,147,152,158,159,160,161,171,175,176,177,183,184", "code": "\nimport sympy\nfrom sympy.ntheory.factor_ import primenu\nfor n in range(1,200):\n    if primenu(n)==2 and primenu(n+1)==2:\n        print(n, end=', '); \n"}
{"sequence_id": "A074925", "text": "Numbers n such that n^3 is a sum of two successive primes.", "sequence": "2,6,28,42,72,162,174,220,222,234,246,252,296,344,380,390,486,510,584,594,638,646,674,702,720,816,828,882,942,948,990,1044,1056,1146,1200,1314,1422,1436,1554,1566,1596,1602,1632,1740,1770,1778,1806,1818,1824", "code": "\nfrom sympy import nextprime, prevprime\nA074925_list = [i for i in range(2,10**4,2) if prevprime(i**3//2) + nextprime(i**3//2) == i**3] \n"}
{"sequence_id": "A074987", "text": "a(n) is the least m not equal to n such that phi(m) = phi(n).", "sequence": "2,1,4,3,8,3,9,5,7,5,22,5,21,7,16,15,32,7,27,15,13,11,46,15,33,13,19,13,58,15,62,17,25,17,39,13,57,19,35,17,55,13,49,25,35,23,94,17,43,25,64,35,106,19,41,35,37,29,118,17,77,31,37,51,104,25,134,51,92,35,142", "code": "\nfrom sympy import totient\ndef A074987(n):\n  m=1\n  while totient(m)!=totient(n) or m==n:\n    m+=1\n  return m \n"}
{"sequence_id": "A074989", "text": "Distance from n to nearest cube.", "sequence": "0,0,1,2,3,3,2,1,0,1,2,3,4,5,6,7,8,9,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24", "code": "\nfrom sympy import integer_nthroot\ndef A074989(n):\n    a = integer_nthroot(n,3)[0]\n    return min(n-a**3,(a+1)**3-n) \n"}
{"sequence_id": "A075032", "text": "Numbers n such that tau(n) <= tau(n+1) <= tau(n+2) where tau(n) = number of divisors of n.", "sequence": "1,2,13,14,25,26,33,34,37,38,43,61,62,73,74,85,86,93,94,97,98,103,115,118,121,122,133,134,141,142,145,146,157,158,163,187,188,193,194,201,202,205,206,213,214,217,218,229,230,241,242,243,244,253,254,274,277", "code": "\nfrom sympy import divisor_count as tau\n[n for n in range(1,303) if tau(n) <= tau(n+1) <= tau(n+2)] \n"}
{"sequence_id": "A075033", "text": "Numbers n such that tau(n) <= tau(n+1) <= tau(n+2) <= tau(n+3) where tau(n) = number of divisors of n.", "sequence": "1,13,25,33,37,61,73,85,93,97,121,133,141,145,157,187,193,201,205,213,217,229,241,242,243,253,277,283,301,361,373,393,397,421,427,445,453,457,481,537,541,547,603,613,633,661,662,663,697,723,733,745,757,781", "code": "\nfrom sympy import divisor_count as tau\n[n for n in range(1, 801) if tau(n) <= tau(n+1) <= tau(n+2) <= tau(n+3)] \n"}
{"sequence_id": "A075034", "text": "Numbers n such that tau(n) >= tau(n+1) >= tau(n+2) where tau(n) = number of divisors of n.", "sequence": "20,21,32,33,44,45,56,57,75,80,81,84,85,92,93,104,105,116,117,132,135,140,141,144,147,165,170,171,176,177,189,200,201,204,212,213,216,217,224,225,230,231,242,243,252,260,261,272,285,296,297,300,301,315,324", "code": "\nfrom sympy import divisor_count as tau\n[n for n in range(1,333) if tau(n) >= tau(n+1) >= tau(n+2)] \n"}
{"sequence_id": "A075035", "text": "Numbers n such that tau(n) >= tau(n+1) >= tau(n+2) >= tau(n+3) where tau(n) = number of divisors of n.", "sequence": "20,32,44,56,80,84,92,104,116,140,170,176,200,212,216,224,230,242,260,296,300,324,332,344,374,380,392,434,440,444,464,476,500,506,512,560,594,602,608,620,632,644,650,696,704,714,715,716,740,776,800,804,836", "code": "\nfrom sympy import divisor_count as tau\n[n for n in range(1,901) if tau(n) >= tau(n+1) >= tau(n+2) >= tau(n+3)] \n"}
{"sequence_id": "A075075", "text": "a(1) = 1, a(2) = 2 and then the smallest number not occurring earlier such that every term divides the product of its neighbors: a(n-1)*a(n+1)/a(n) is an integer.", "sequence": "1,2,4,6,3,5,10,8,12,9,15,20,16,24,18,21,7,11,22,14,28,26,13,17,34,30,45,27,33,44,32,40,25,35,42,36,48,52,39,51,68,56,70,50,55,66,54,63,49,77,88,64,72,81,90,60,38,19,23,46,58,29,31,62,74,37,41,82,76,114,57,43", "code": "\nfrom __future__ import division\nfrom fractions import gcd\nA075075_list, l1, l2, m, b = [1,2], 2, 1, 2, {1,2}\nfor _ in range(10**3):\n....i = m\n....while True:\n........if not i in b:\n............A075075_list.append(i)\n............l1, l2, m = i, l1, i//gcd(l1,i)\n............b.add(i)\n............break\n........i += m \n"}
{"sequence_id": "A075101", "text": "Numerator of 2^n/n.", "sequence": "2,2,8,4,32,32,128,32,512,512,2048,1024,8192,8192,32768,4096,131072,131072,524288,262144,2097152,2097152,8388608,2097152,33554432,33554432,134217728,67108864,536870912,536870912,2147483648,134217728,8589934592,8589934592,34359738368,17179869184,137438953472", "code": "\nfrom fractions import Fraction\ndef A075101(n):\n    return (Fraction(2**n)/n).numerator \n"}
{"sequence_id": "A075155", "text": "Cubes of Lucas numbers.", "sequence": "8,1,27,64,343,1331,5832,24389,103823,438976,1860867,7880599,33386248,141420761,599077107,2537716544,10749963743,45537538411,192900170952,817138135549,3461452853383,14662949322176,62113250509227,263115950765039,1114577054530568", "code": "\nfrom sympy import lucas\ndef a(n):  return lucas(n)**3\nprint([a(n) for n in range(25)]) \n"}
{"sequence_id": "A075195", "text": "Jablonski table T(n,k) read by antidiagonals: T(n,k) = number of necklaces with n beads of k colors.", "sequence": "1,2,1,3,3,1,4,6,4,1,5,10,11,6,1,6,15,24,24,8,1,7,21,45,70,51,14,1,8,28,76,165,208,130,20,1,9,36,119,336,629,700,315,36,1,10,45,176,616,1560,2635,2344,834,60,1,11,55,249,1044,3367,7826,11165,8230,2195,108,1", "code": "\nfrom sympy.ntheory import totient, divisors\ndef T(n,k): return sum(totient(d)*k**(n//d) for d in divisors(n))//n\nfor n in range(1, 16):\n    print([T(k, n - k + 1) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A075227", "text": "Smallest odd prime not occurring in the numerator of any of the 2^n subset sums generated from the set 1/1, 1/2, 1/3, ..., 1/n.", "sequence": "3,5,7,17,37,43,43,151,151,409,491,491,491,1087,2011,3709,3709,7417,7417,7417,19699,30139,35573,35573,40237,40237,132151,132151,158551,158551,245639,245639,961459,1674769,1674769,1674769,1674769,4339207", "code": "\nfrom sympy import sieve\nfrom fractions import Fraction\nfracs, newnums, primeset = {0}, {0}, set(sieve.primerange(3, 10**6+1))\nfor n in range(1, 24):\n  newfracs = set(Fraction(1, n) + f for f in fracs)\n  fracs |= newfracs\n  primeset -= set(f.numerator for f in newfracs)\n  print(min(primeset), end=\", \") \n"}
{"sequence_id": "A075565", "text": "Numbers n such that sopf(n) = sopf(n-1) + sopf(n-2), where sopf(x) = sum of the distinct prime factors of x.", "sequence": "5,23,58,901,1552,1921,4195,6280,10858,19649,20385,32017,63657,65704,83272,84120,86242,105571,145238,181845,271329,271742,316711,322954,331977,345186,379660,381431,409916,424504,490256,524477,542566,550272,561661,565217,566560", "code": "\nfrom sympy import primefactors\ndef sopf(n): return sum(primefactors(n))\ndef afind(limit):\n  sopfm2, sopfm1, sopf = 2, 3, 2\n  for k in range(4, limit+1):\n    if sopf == sopfm1 + sopfm2: print(k, end=\", \")\n    sopfm2, sopfm1, sopf = sopfm1, sopf, sum(primefactors(k+1))\nafind(600000) \n"}
{"sequence_id": "A075577", "text": "k^2 is a term if k^2 + (k-1)^2 and k^2 + (k+1)^2 are primes.", "sequence": "4,25,625,900,1225,4900,7225,10000,12100,50625,52900,67600,81225,84100,102400,152100,168100,225625,240100,245025,265225,348100,462400,483025,504100,562500,577600,714025,902500,1166400,1210000,1288225,1380625,1416100,1428025", "code": "\nfrom sympy import isprime\ndef aupto(limit):\n  alst, is2 = [], False\n  for k in range(1, int(limit**.5) + 2):\n    is1, is2 = is2, isprime(k**2 + (k+1)**2)\n    if is1 and is2: alst.append(k**2)\n  return alst\nprint(aupto(1500000)) \n"}
{"sequence_id": "A075677", "text": "Reduced Collatz function R applied to the odd integers: a(n) = R(2n-1), where R(k) = (3k+1)/2^r, with r as large as possible.", "sequence": "1,5,1,11,7,17,5,23,13,29,1,35,19,41,11,47,25,53,7,59,31,65,17,71,37,77,5,83,43,89,23,95,49,101,13,107,55,113,29,119,61,125,1,131,67,137,35,143,73,149,19,155,79,161,41,167,85,173,11,179,91,185,47,191,97,197", "code": "\nfrom sympy import divisors\ndef a(n):\n    return max(d for d in divisors(n) if d % 2)\nprint([a(6*n - 2) for n in range(1, 101)]) \n"}
{"sequence_id": "A075696", "text": "Sum-of-digits of k appears somewhere in prime(k).", "sequence": "7,12,13,21,25,28,30,45,47,72,81,100,104,106,107,108,114,123,133,143,150,151,152,162,171,172,180,181,191,200,207,214,230,239,249,259,269,278,279,288,298,312,314,319,322,333,340,342,344,359,397,400,403,405", "code": "\nfrom sympy import prime, primerange\ndef auptopn(lim):\n    alst = []\n    for k, pk in enumerate(primerange(2, prime(lim)+1), start=1):\n        if str(sum(map(int, str(k)))) in str(pk): alst.append(k)\n    return alst\nprint(auptopn(405)) \n"}
{"sequence_id": "A075697", "text": "a(n) = sum-of-digits(A075696(n)).", "sequence": "7,3,4,3,7,10,3,9,11,9,9,1,5,7,8,9,6,6,7,8,6,7,8,9,9,10,9,10,11,2,9,7,5,14,15,16,17,17,18,18,19,6,8,13,7,9,7,9,11,17,19,4,7,9,7,8,9,16,5,6,7,9,8,9,15,8,9,19,7,8,9,8,9,17,11,17,9,10,12,15,17,18,19,13,1,2,3,7,9", "code": "\nfrom sympy import prime, primerange\ndef auptopn(lim):\n    alst = []\n    for k, pk in enumerate(primerange(2, prime(lim)+1), start=1):\n        sdk =  sum(map(int, str(k)))\n        if str(sdk) in str(pk): alst.append(sdk)\n    return alst\nprint(auptopn(1010)) \n"}
{"sequence_id": "A075774", "text": "Number of syllables in n in American English.", "sequence": "2,1,1,1,1,1,1,2,1,1,1,3,1,2,2,2,2,3,2,2,2,3,3,3,3,3,3,4,3,3,2,3,3,3,3,3,3,4,3,3,2,3,3,3,3,3,3,4,3,3,2,3,3,3,3,3,3,4,3,3,2,3,3,3,3,3,3,4,3,3,3,4,4,4,4,4,4,5,4,4,2,3,3,3,3,3,3,4,3,3,2,3,3,3,3,3,3,4,3,3,3,4,4,4,4", "code": "\ndef A075774(n):\n    t = [(10**i, 2) for i in [12, 9, 6, 3, 2]]\n    if n > 99:\n        for ti, sti in t:\n            if n >= ti:\n                q, r = divmod(n, ti)\n                return A075774(q) + sti + (A075774(r) if r else 0)\n    if n < 20:\n        return 1 + (n in {0, 7, 13, 14, 15, 16, 18, 19}) + 2*(n in {11, 17})\n    else: return 2 + (n//10==7) + (A075774(n%10) if n%10 else 0)\nprint([A075774(n) for n in range(105)]) \n"}
{"sequence_id": "A075777", "text": "Minimal surface area of a rectangular solid with volume n and integer sides.", "sequence": "6,10,14,16,22,22,30,24,30,34,46,32,54,46,46,40,70,42,78,48,62,70,94,52,70,82,54,64,118,62,126,64,94,106,94,66,150,118,110,76,166,82,174,96,78,142,190,80,126,90,142,112,214,90,142,100,158,178,238,94,246,190", "code": "\nimport math\ndef cubestepdown(n):\n    s1_0 = int(math.ceil(n ** (1 / 3.0)))\n    minSA = -1\n    s1 = s1_0\n    while s1>=1:\n        while n % s1 > 0:\n            s1 = s1 - 1\n        s1quot = int(n/s1)\n        s2_0 = int(math.ceil(math.sqrt(n/s1)))\n        s2 = s2_0\n        while s2>=1:\n            while s1quot % s2 > 0:\n                s2 = s2 - 1\n            s3 = int(n / (s1 * s2))\n            SA = 2*(s1*s2 + s1*s3 + s2*s3)\n            if minSA==-1:\n                minSA = SA\n            else:\n                if SA<minSA:\n                    minSA = SA\n            s2 = s2 - 1\n        s1 = s1 - 1\n    return minSA\n\n"}
{"sequence_id": "A075786", "text": "Palindromic perfect powers.", "sequence": "1,4,8,9,121,343,484,676,1331,10201,12321,14641,40804,44944,69696,94249,698896,1002001,1030301,1234321,1367631,4008004,5221225,6948496,100020001,102030201,104060401,121242121,123454321,125686521,400080004,404090404,522808225,617323716,942060249", "code": "\nfrom math import isqrt\ndef ispal(n): s = str(n); return s == s[::-1]\ndef athrough(digits):\n  found, limit = {1}, 10**digits\n  for k in range(2, isqrt(limit) + 1):\n    kpow = k*k\n    while kpow < limit:\n      if ispal(kpow): found.add(kpow)\n      kpow *= k\n  return sorted(found)\nprint(athrough(9)) \n"}
{"sequence_id": "A075904", "text": "Numbers k such that k^4 has k as a substring of its decimal expansion.", "sequence": "0,1,5,6,10,25,50,60,76,83,92,100,107,211,217,250,352,363,376,500,556,600,625,636,760,863,909,935,1000,1531,1636,2263,2500,2503,3630,3760,4342,5000,5001,6000,6250,7245,7600,8578,9350,9376,10000", "code": "\nA075904_list, m = [0], [24, -36, 14, -1, 0]\nfor n in range(1,10**9+1):\n....for i in range(4):\n........m[i+1] += m[i]\n....if str(n) in str(m[-1]):\n........A075904_list.append(n) \n"}
{"sequence_id": "A075905", "text": "Numbers n such that n^5 has n as a substring of its representation.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,18,20,24,25,30,32,40,43,45,48,49,50,51,57,60,68,70,73,75,76,80,90,93,99,100,101,125,178,192,193,195,200,205,240,249,250,251,300,307,320,375,376,400,430,432,443,480,490,499,500,501", "code": "\nA075905_list, m = [0], [120, -240, 150, -30, 1, 0]\nfor n in range(1,10**8+1):\n....for i in range(5):\n........m[i+1] += m[i]\n....if str(n) in str(m[-1]):\n........A075905_list.append(n) \n"}
{"sequence_id": "A076068", "text": "Smallest number that can be formed by using the nonzero digits of the numbers 1+n(n-1)/2 through n(n+1)/2.", "sequence": "1,23,456,1789,1111112345,11111226789,22222222345678,122333333334569,12333344444445789,1234444455555556789,123455555666666666789,12345666677777777777889,112345677888888888889999,111111122334455678999999999,111111111111111111111111112234566778899", "code": "\ndef a(n):\n  s = \"\".join(sorted(\"\".join(map(str, range((n-1)*n//2+1, n*(n+1)//2+1)))))\n  if '0' not in s: return int(s)\n  return int(s[s.rfind('0')+1:])\nprint([a(n) for n in range(1, 16)]) \n"}
{"sequence_id": "A076106", "text": "Out of all the n-digit primes, which one takes the longest time to appear in the digits of Pi (ignoring the initial 3)? The answer is a(n), and it appears at position A076130(n).", "sequence": "7,73,373,9337,35569,805289,9271903", "code": "\n\nwith open('pi-billion.txt', 'r') as f: digits_of_pi = f.readline()[2:]\n\n\nfrom sympy import primerange\ndef A076106_A076130(n):\n    global digits_of_pi\n    bigp, bigloc = None, -1\n    for p in primerange(10**(n-1), 10**n):\n        loc = digits_of_pi.find(str(p))\n        if loc == -1: print(\"not enough digits\", n, p)\n        if loc > bigloc:\n            bigloc = loc\n            bigp = p\n    return (bigp, bigloc+1)\nprint([A076106_A076130(n)[0] for n in range(1, 6)]) \n"}
{"sequence_id": "A076130", "text": "Out of all the n-digit primes, which one takes the longest time to appear in the digits of Pi (ignoring the initial 3)? The answer is A076106(n) and the position where this prime appears is a(n).", "sequence": "13,299,5229,75961,715492,11137824,135224164", "code": " \nprint([A076106_A076130(n)[1] for n in range(1, 6)]) \n"}
{"sequence_id": "A076161", "text": "Numbers n such that n + sum of squares of digits of n (A258881) is a prime.", "sequence": "1,10,11,12,13,14,15,16,17,18,19,31,34,57,73,74,75,78,91,94,97,100,101,102,103,105,107,108,109,121,122,123,126,127,128,140,142,146,148,160,161,165,166,168,182,183,188,213,216,217,234,251,275,277,297,301", "code": "\nfrom sympy import isprime\ndef ssd(n): return sum(int(d)**2 for d in str(n))\ndef ok(n): return isprime(n + ssd(n))\ndef aupto(limit): return [m for m in range(1, limit+1) if ok(m)]\nprint(aupto(301)) \n"}
{"sequence_id": "A076197", "text": "Numbers k such that k!! + 2^10 is prime.", "sequence": "5,7,21,33,153,167,171,391,789,1323,2645,8655,10153,39967,45369,47599", "code": "\nfrom gmpy2 import is_prime\nA076197_list, g, h = [], 1, 1024\nfor i in range(3,10**5,2):\n....g *= i\n....if is_prime(g+h):\n........A076197_list.append(i) \n"}
{"sequence_id": "A076306", "text": "Numbers k such that k^3 is a sum of three successive primes.", "sequence": "11,47,145,223,229,267,313,353,365,391,397,409,507,565,567,571,573,641,661,723,793,799,841,887,895,1015,1051,1089,1293,1297,1411,1451,1469,1789,1909,1943,2043,2077,2171,2401,2459,2497,2671,2801,2851,2871,2921,3211", "code": "\nfrom __future__ import division\nfrom sympy import nextprime, prevprime, isprime\nA070306_list, i = [], 3\nwhile i < 10**6:\n    n = i**3\n    m = n//3\n    pm, nm = prevprime(m), nextprime(m)\n    k = n - pm - nm\n    if isprime(m):\n        if m == k:\n            A070306_list.append(i)\n    else:\n        if nextprime(nm) == k or prevprime(pm) == k:\n            A070306_list.append(i)\n    i += 1 \n"}
{"sequence_id": "A076314", "text": "a(n) = floor(n/10) + (n mod 10).", "sequence": "0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7,8,9,10,11,12,13,14,6,7,8,9,10,11,12,13,14,15,7,8,9,10,11,12,13,14,15,16,8,9,10,11,12,13,14", "code": " def A076314(n): return (n/10)+(n%10) \n"}
{"sequence_id": "A076449", "text": "Least number whose digits can be used to form exactly n different primes (not necessarily using all digits).", "sequence": "1,2,25,13,37,107,127,113,167,1027,179,137,1036,1127,1013,1137,1235,1136,1123,1037,1139,1079,10124,10126,1349,1279,1237,3479,10699,1367,10179,1379,10127,10079,10138,10123,10234,10235,10247,10339,10267", "code": " \n"}
{"sequence_id": "A076478", "text": "The binary Champernowne sequence: concatenate binary vectors of lengths 1, 2, 3, ... in numerical order.", "sequence": "0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0", "code": "\nfrom itertools import count, product\ndef agen():\n    for digits in count(1):\n        for b in product([0, 1], repeat=digits):\n            yield from b\ng = agen()\nprint([next(g) for n in range(105)]) \n"}
{"sequence_id": "A076479", "text": "a(n) = mu(rad(n)), where mu is the Moebius-function (A008683) and rad is the radical or squarefree kernel (A007947).", "sequence": "1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,-1,1,1,1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,1,1,1,-1,1,-1,1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,1,-1,-1,1,-1,1,-1,-1,1,1,1", "code": "\nfrom math import prod\nfrom sympy.ntheory import mobius, primefactors\ndef A076479(n): return mobius(prod(primefactors(n))) \n"}
{"sequence_id": "A076558", "text": "a(n) = r * min(e_1, ..., e_r), where n = p_1^e_1 . .... p_r^e_r is the canonical prime factorization of n, a(1) = 0.", "sequence": "0,1,1,2,1,2,1,3,2,2,1,2,1,2,2,4,1,2,1,2,2,2,1,2,2,2,3,2,1,3,1,5,2,2,2,4,1,2,2,2,1,3,1,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,1,3,1,2,2,6,2,3,1,2,2,3,1,4,1,2,2,2,2,3,1,2,4,2,1,3,2,2,2,2,1,3,2,2,2,2,2,2,1,2,2,4", "code": "\nfrom sympy import factorint\ndef a(n):\n    f=factorint(n)\n    l=[f[p] for p in f]\n    return 0 if n==1 else len(l)*min(l)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A076565", "text": "Greatest prime divisor of 2n+1 (sum of two successive integers).", "sequence": "3,5,7,3,11,13,5,17,19,7,23,5,3,29,31,11,7,37,13,41,43,5,47,7,17,53,11,19,59,61,7,13,67,23,71,73,5,11,79,3,83,17,29,89,13,31,19,97,11,101,103,7,107,109,37,113,23,13,17,11,41,5,127,43,131,19,5,137,139,47,13", "code": "\nfrom sympy.ntheory import primefactors\nprint([max(primefactors(2*n + 1)) for n in range(1,101)]) \n"}
{"sequence_id": "A076615", "text": "Number of permutations of {1,2,...,n} that result in a binary search tree with the minimum possible height.", "sequence": "1,1,2,2,16,40,80,80,11360,55040,253440,1056000,3801600,10982400,21964800,21964800,857213660160,7907423180800,72155129446400,645950912921600,5622693241651200,47110389109555200,375570435981312000,2811021970538496000,19445103757787136000", "code": "\nfrom math import factorial as f, log, floor\nB= {}\ndef b(n,x):\n    if (n,x) in B: return B[(n,x)]\n    if n<=1: B[(n,x)] = int(x>=0)\n    else: B[(n,x)]=sum([b(i,x-1)*b(n-1-i,x-1)*f(n-1)//f(i)//f(n-1-i) for i in range(n)])\n    return B[(n,x)]\nfor n in range(1,51): print(b(n,floor(log(n,2))))\n\n"}
{"sequence_id": "A076620", "text": "Coefficient of x^a(n) in (x+1)*(x+2)*...*(x+n) is the largest one.", "sequence": "0,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4", "code": "\nfrom sympy import prod, Poly\nfrom sympy.abc import x\ndef A076620(n):\n    y = Poly(prod(x+i for i in range(1,n+1))).all_coeffs()[::-1]\n    return y.index(max(y)) \n"}
{"sequence_id": "A076621", "text": "Least square greater than the product of two successive primes.", "sequence": "9,16,36,81,144,225,324,441,676,900,1156,1521,1764,2025,2500,3136,3600,4096,4761,5184,5776,6561,7396,8649,9801,10404,11025,11664,12321,14400,16641,17956,19044,20736,22500,23716,25600,27225,28900,30976,32400,34596,36864", "code": "\nfrom sympy import prime, primerange\ndef aupton(terms):\n    primes = list(primerange(3, prime(terms+1)+1))\n    return [9] + [((p+q)//2)**2 for p, q in zip(primes[:-1], primes[1:])]\nprint(aupton(43)) \n"}
{"sequence_id": "A076634", "text": "Coefficient of x^a(n) in (x+1/2)*(x+2/2)*...*(x+n/2) is the largest one.", "sequence": "1,1,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7", "code": "\nfrom sympy import prod, Poly\nfrom sympy.abc import x\ndef A076634(n):\n    y = Poly(prod(2*x+i for i in range(1,n+1))).all_coeffs()[::-1]\n    return y.index(max(y)) \n"}
{"sequence_id": "A076642", "text": "Coefficient of x^a(n) in (x+1/3!)*(x+2/3!)*...*(x+n/3!) is the largest one.", "sequence": "1,2,2,3,4,4,4,5,5,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,9,10,10,10,10,10,10,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15", "code": "\nfrom sympy import Poly, rf\nfrom sympy.abc import x\ndef A076642(n):\n    y = Poly(rf(6*x+1,n)).all_coeffs()[::-1]\n    return y.index(max(y)) \n"}
{"sequence_id": "A076683", "text": "Numbers k such that 7*k! + 1 is prime.", "sequence": "3,7,8,15,19,29,36,43,51,158,160,203,432,909,1235,3209", "code": "\nfrom sympy import isprime\nfrom math import factorial\ndef aupto(m): return [k for k in range(m+1) if isprime(7*factorial(k)+1)]\nprint(aupto(300)) \n"}
{"sequence_id": "A076730", "text": "Maximum number of (distinct) primes that an n-digit number may shelter (i.e., primes contained among all digital substrings' permutations).", "sequence": "1,4,11,31,106,402,1953,10542,64905,362451,2970505", "code": " \n"}
{"sequence_id": "A076886", "text": "Smallest palindrome with exactly n prime factors (counted with multiplicity).", "sequence": "1,2,4,8,88,252,2772,27872,2112,4224,8448,44544,48384,2977792,27011072,405504,4091904,441606144,405909504,886898688,677707776,4285005824,276486684672,21128282112,633498894336,2701312131072,6739855589376,29142024192,65892155129856", "code": "\nfrom sympy import factorint\ndef A076886(n):\n  d = 1\n  while True:\n    half = (d+1)//2\n    for left in range(10**(half-1), 10**half):\n      strleft = str(left)\n      if d%2 == 0:\n        m = int(strleft + strleft[::-1])\n      else:\n        m = int(strleft + (strleft[:-1])[::-1])\n        if sum(list(factorint(m).values())) == n:\n          return m\n    d += 1\nprint([A076886(n) for n in range(17)]) \n"}
{"sequence_id": "A076974", "text": "Increasing sequence where each number is unequal to 2 mod all previous numbers.", "sequence": "2,3,7,13,19,25,31,39,43,49,55,61,69,73,81,85,91,99,103,109,115,123,129,133,139,147,151,159,165,169,175,181,187,193,199,207,213,225,229,235,241,253,259,265,271,279,283,291,295,309,313,319,333,337,349,355", "code": "\ndef A076974():\n    D = {}\n    q = 2\n    while True:\n        if q not in D:\n            yield q\n            D.setdefault(q+2, []).append(q)\n        else:\n            for p in D[q]:\n                D.setdefault(p+q, []).append(p)\n            del D[q]\n        q += 1\na = A076974(); print([next(a) for _ in range(100)])\n"}
{"sequence_id": "A077037", "text": "Largest prime < n^3.", "sequence": "7,23,61,113,211,337,509,727,997,1327,1723,2179,2741,3373,4093,4909,5827,6857,7993,9257,10639,12163,13807,15619,17573,19681,21943,24379,26993,29789,32749,35933,39301,42863,46649,50651,54869,59281,63997", "code": "\nfrom sympy import prevprime\ndef a(n):  return prevprime(n**3)\nprint([a(n) for n in range(2, 41)]) \n"}
{"sequence_id": "A077049", "text": "Left summatory matrix, T, by antidiagonals upwards.", "sequence": "1,1,0,1,1,0,1,0,0,0,1,1,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0", "code": "\ndef T(n, k):\n    return 1 if n%k==0 else 0\nfor n in range(1, 11): print([T(n - k + 1, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A077110", "text": "Nearest integer cube to n^2.", "sequence": "0,1,1,8,8,27,27,64,64,64,125,125,125,125,216,216,216,343,343,343,343,512,512,512,512,729,729,729,729,729,1000,1000,1000,1000,1000,1331,1331,1331,1331,1331,1728,1728,1728,1728,1728,2197,2197,2197", "code": "\nfrom sympy import integer_nthroot\ndef A077110(n):\n    n2 = n**2\n    a = integer_nthroot(n2,3)[0]\n    a2, a3 = a**3, (a+1)**3\n    return a3 if a3+a2-2*n2 < 0 else a2 \n"}
{"sequence_id": "A077138", "text": "a(0) = 0. If n is odd, a(n) = a(n-1) + n, otherwise a(n) = a(n-1) * n.", "sequence": "0,1,2,5,20,25,150,157,1256,1265,12650,12661,151932,151945,2127230,2127245,34035920,34035937,612646866,612646885,12252937700,12252937721,269564629862,269564629885,6469551117240,6469551117265,168208329048890", "code": "\na=0\nfor n in range(1, 33):\n    print(a, end=', ')\n    if n&1:\n        a += n\n    else:\n        a *= n\n"}
{"sequence_id": "A077327", "text": "Smallest number beginning with 2 and having exactly n distinct prime divisors.", "sequence": "2,20,204,210,2310,200970,2012010,20030010,223092870,20090100030,200560490130,20055767721990,2000029432190790,20384767656323070,2000848249650860610,200001648981983238390,2183473617971732996910", "code": "\nfrom sympy import primorial, factorint\ndef a(n, begins_with=2): \n  m, start_digit = primorial(n), str(begins_with)\n  while len(factorint(m)) != n or str(m)[0] != start_digit:\n    m += 1\n    s = str(m)\n    if s[0] == start_digit: continue\n    elif s[0] < start_digit: m = int(start_digit+'0'*(len(s)-1))\n    else: m = int(start_digit+'0'*len(s))\n  return m\nprint([a(n) for n in range(1, 10)]) \n"}
{"sequence_id": "A077441", "text": "In base 4, smallest number that requires n Reverse and Add! steps to reach a palindrome.", "sequence": "0,4,7,26,28,127,306,348,398,301,308,203,311,783,294,350,199,296,4268,16595,5326,4253,17399,8235,6189,4270,3107,1270,1532,511,67816,65975,24670,12395,4282,3119,28799,16861,18164,66268,45087,71164,309234", "code": "\nfrom gmpy2 import digits\ndef A077441(n):\n....if n > 0:\n........k = 0\n........while True:\n............m = k\n............for i in range(n):\n................s = digits(m,4)\n................if s == s[::-1]:\n....................break\n................m += int(s[::-1],4)\n............else:\n................s = digits(m,4)\n................if s == s[::-1]:\n....................return k\n............k += 1\n....else:\n........return 0 \n"}
{"sequence_id": "A077506", "text": "Smallest n-digit triangular number beginning with n.", "sequence": "1,21,300,4005,50086,600060,7003153,80004925,900003951,1000006281,11000078650,120000270151,1300001532378,14000004645256,150000007349286,1600000000287153,17000000065300605,180000000300000000,1900000001049159015,20000000001032428860", "code": "\nfrom sympy import integer_nthroot\ndef a(n):\n  target = 2 * int(str(n) + '0'*(n-len(str(n))))\n  r, exact = integer_nthroot(target, 2)\n  while r*(r+1)//2 >= target//2: r -= 1\n  return (r+1)*(r+2)//2\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A077507", "text": "Largest n-digit triangular number beginning with n.", "sequence": "1,28,378,4950,59685,699153,7998000,89987820,999961560,1099969156,11999870821,129999769851,1399999074540,14999999588925,159999994275696,1699999973850921,17999999979109470,189999999508759300,1999999999000000000,20999999994116393253", "code": "\nfrom sympy import integer_nthroot\ndef a(n):\n  target = 2 * int(str(n) + '9'*(n-len(str(n))))\n  r, exact = integer_nthroot(target, 2)\n  while (r-1)*r//2 <= target//2: r += 1\n  return (r-2)*(r-1)//2\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A077533", "text": "Multiples of 3 using only prime digits (2, 3, 5 and 7).", "sequence": "3,27,33,57,72,75,222,225,237,252,255,273,327,333,357,372,375,522,525,537,552,555,573,723,732,735,753,777,2223,2232,2235,2253,2277,2322,2325,2337,2352,2355,2373,2523,2532,2535,2553,2577,2727,2733,2757,2772,2775", "code": "\ndef pd(n): return set(str(n)) <= set(\"2357\") \ndef aupto(limit): return [m for m in range(0, limit+1, 3) if pd(m)]\nprint(aupto(3000)) \n"}
{"sequence_id": "A077572", "text": "Nonsquarefree numbers obtained by repeating a single digit.", "sequence": "4,8,9,44,88,99,333,444,666,888,999,4444,8888,9999,44444,88888,99999,333333,444444,666666,777777,888888,999999,4444444,8888888,9999999,44444444,88888888,99999999,111111111,222222222,333333333,444444444", "code": "\nfrom sympy.ntheory.factor_ import core\ndef repsthru(maxd):\n  yield from (int(di*d) for d in range(1, maxd+1) for di in \"123456789\")\ndef okrep(r): return r > 3 and core(r, 2) != r\nprint(list(filter(okrep, repsthru(9)))) \n"}
{"sequence_id": "A077654", "text": "Composites k such that 2k+1 is also composite.", "sequence": "4,10,12,16,22,24,25,27,28,32,34,38,40,42,45,46,49,52,55,57,58,60,62,64,66,70,72,76,77,80,82,84,85,87,88,91,92,93,94,100,102,104,106,108,110,112,115,117,118,121,122,123,124,126,129,130,132,133,136,142", "code": "\nfrom sympy import isprime\ndef ok(n): return n >= 4 and not isprime(2*n+1) and not isprime(n)\nprint(list(filter(ok, range(4, 143)))) \n"}
{"sequence_id": "A077664", "text": "Triangle in which the n-th row contains n smallest numbers greater than n and coprime to n.", "sequence": "2,3,5,4,5,7,5,7,9,11,6,7,8,9,11,7,11,13,17,19,23,8,9,10,11,12,13,15,9,11,13,15,17,19,21,23,10,11,13,14,16,17,19,20,22,11,13,17,19,21,23,27,29,31,33,12,13,14,15,16,17,18,19,20,21,23,13,17,19,23,25,29,31,35,37,41,43,47", "code": "\nfrom math import gcd\ndef arow(n):\n    rown, k = [], n + 1\n    while len(rown) < n:\n        if gcd(k, n) == 1: rown.append(k)\n        k += 1\n    return rown\ndef agen(rows):\n    for n in range(1, rows+1): yield from arow(n)\nprint([an for an in agen(12)]) \n"}
{"sequence_id": "A077719", "text": "Primes which can be expressed as sum of distinct powers of 5.", "sequence": "5,31,131,151,631,751,3251,3881,16381,19381,19501,19531,78781,78901,81281,81401,81901,82031,93901,94531,97001,97501,97651,390751,390781,393901,394501,406381,468781,469501,471901,472631,484531,485131,487651,1953151,1953901", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n  k, alst = 0, []\n  while len(alst) < terms:\n    k += 1\n    t = sum(5**i*int(di) for i, di in enumerate((bin(k)[2:])[::-1]))\n    if isprime(t): alst.append(t)\n  return alst\nprint(aupton(37)) \n"}
{"sequence_id": "A077854", "text": "Expansion of 1/((1-x)*(1-2*x)*(1+x^2)).", "sequence": "1,3,6,12,25,51,102,204,409,819,1638,3276,6553,13107,26214,52428,104857,209715,419430,838860,1677721,3355443,6710886,13421772,26843545,53687091,107374182,214748364,429496729,858993459,1717986918,3435973836,6871947673", "code": " print([2**(n+3)//5 for n in range(50)]) \n"}
{"sequence_id": "A078001", "text": "Expansion of (1-x)/(1-2*x+x^2+x^3).", "sequence": "1,1,1,0,-2,-5,-8,-9,-5,7,28,54,73,64,1,-135,-335,-536,-602,-333,472,1879,3619,4887,4276,46,-9071,-22464,-35903,-40271,-22175,31824,126094,242539,327160,285687,1675,-609497,-1506356,-2404890,-2693927,-1476608,2145601,8461737,16254481,21901624", "code": "\na = [1]*1000\nfor n in range(55):\n    print(a[n], end=',')\n    sum=0\n    for k in range(n-1):\n        sum+=a[k]\n    a[n+1] = a[n]-sum\n\n"}
{"sequence_id": "A078226", "text": "a(1) = 1, a(n+1) is the smallest odd multiple of a(n) (other than a(n) itself) in which the digits are alternately even and odd.", "sequence": "1,3,9,27,81,567,8505,76545,9874305,6763898925,41672381276925,25432529276163496725,6947294789656341278149816125,2341412581496361870123890149638785410125", "code": "\nA078226_list = [1]\nfor _ in range(20):\n....x = A078226_list[-1]\n....y, x2 = x, 2*x\n....while True:\n........y += x2\n........s = str(y)\n........for j in range(len(s)-1,-1,-2):\n............if not s[j] in ('1','3','5','7','9'):\n................break\n........else:\n............for k in range(len(s)-2,-1,-2):\n................if not s[k] in ('0','2','4','6','8'):\n....................break\n............else:\n................A078226_list.append(y)\n................break\n\n"}
{"sequence_id": "A078227", "text": "a(1) = 2, a(n+1) is the smallest multiple of a(n) such that the digits are alternately odd and even. The unit digit is always even and parity alternates.", "sequence": "2,4,8,16,32,96,672,45696,2787456,270383232,507238943232,27274745216527872,141232121898569036783616,216567470725252501672125832323072", "code": "\nA078227_list = [2]\nfor _ in range(20):\n....x = A078227_list[-1]\n....y = x\n....while True:\n........y += x\n........s = str(y)\n........for j in range(len(s)-1,-1,-2):\n............if not s[j] in ('0','2','4','6','8'):\n................break\n........else:\n............for k in range(len(s)-2,-1,-2):\n................if not s[k] in ('1','3','5','7','9'):\n....................break\n............else:\n................A078227_list.append(y)\n................break\n\n"}
{"sequence_id": "A078234", "text": "a(1) = 5, a(n+1) is the smallest multiple of a(n) using only prime digits (2,3,5,7).", "sequence": "5,25,75,225,3375,57375,2352375,322275375,27757255773375,23322552325375373733375,5272277223223332755233325327375733375", "code": "\ndef pd(n): return set(str(n)) <= set(\"2357\")  \ndef aupton(terms, startat=5):\n  alst = [startat]\n  for n in range(2, terms+1):\n    m = alst[-1]; km = 2*m\n    while not pd(km): km += m\n    alst.append(km)\n  return alst\nprint(aupton(9)) \n"}
{"sequence_id": "A078241", "text": "Smallest multiple of n using only digits 0 and 2.", "sequence": "2,2,222,20,20,222,2002,200,222222222,20,22,2220,2002,2002,2220,2000,22202,222222222,22002,20,20202,22,220202,22200,200,2002,2202222222,20020,2202202,2220,222022,20000,222222,22202,20020,2222222220,222", "code": "\ndef A078241(n):\n    if n > 0:\n        for i in range(1,2**n):\n            x = 2*int(bin(i)[2:])\n            if not x % n:\n                return x\n    return 0 \n"}
{"sequence_id": "A078242", "text": "Smallest multiple of n using only digits 0 and 3.", "sequence": "3,30,3,300,30,30,3003,3000,333,30,33,300,3003,30030,30,30000,33303,3330,33003,300,3003,330,330303,3000,300,30030,333333333,300300,3303303,30,333033,300000,33,333030,30030,33300,333,330030,3003,3000,33333", "code": "\ndef A078242(n):\n....if n > 0:\n........for i in range(1,2**n):\n............x = 3*int(bin(i)[2:])\n............if not x % n:\n................return x\n....return 0 \n"}
{"sequence_id": "A078245", "text": "Smallest multiple of n using only digits 0 and 6.", "sequence": "6,6,6,60,60,6,6006,600,666,60,66,60,6006,6006,60,6000,66606,666,66006,60,6006,66,660606,600,600,6006,666666666,60060,6606606,60,666066,60000,66,66606,60060,6660,666,66006,6006,600,66666,6006,6606606,660,6660,660606", "code": "\ndef A204093(n): return int(bin(n)[2:].replace('1', '6'))\ndef a(n):\n    k = 1\n    while A204093(k)%n: k += 1\n    return A204093(k)\nprint([a(n) for n in range(1, 47)]) \n"}
{"sequence_id": "A078247", "text": "Smallest multiple of n using only digits 0 and 8.", "sequence": "8,8,888,8,80,888,8008,8,888888888,80,88,888,8008,8008,8880,80,88808,888888888,88008,80,80808,88,880808,888,800,8008,8808888888,8008,8808808,8880,888088,800,888888,88808,80080,888888888,888,88008,80808,80,88888,80808", "code": "\ndef a(n):\n    k = 1\n    while  8*int(bin(k)[2:])%n: k += 1\n    return 8*int(bin(k)[2:])\nprint([a(n) for n in range(1, 43)]) \n"}
{"sequence_id": "A078266", "text": "Integer part of the arithmetic mean of all the distinct numbers formed by permuting the digits of concatenation of numbers from 1 to n.", "sequence": "1,16,222,2777,33333,388888,4444444,49999999,555555555,46464646464,4102564102563,377777777777777,35947712418300653,3508771929824561403,349206349206349206348,35265700483091787439613,3599999999999999999999999", "code": "\ndef A078266(n):\n    s = ''.join(str(i) for i in range(1,n+1))\n    return sum(int(d) for d in s)*(10**len(s)-1)//(9*len(s)) \n"}
{"sequence_id": "A078267", "text": "Smallest k such that k*N is an integer where N is obtained by placing the string \"n\" after a decimal point.", "sequence": "10,5,10,5,2,5,10,5,10,10,100,25,100,50,20,25,100,50,100,5,100,50,100,25,4,50,100,25,100,10,100,25,100,50,20,25,100,50,100,5,100,50,100,25,20,50,100,25,100,2,100,25,100,50,20,25,100,50,100,5,100,50,100,25,20", "code": "\nfrom math import gcd\ndef a(n): b = 10**len(str(n)); return b//gcd(n, b)\nprint([a(n) for n in range(1, 103)]) \n"}
{"sequence_id": "A078290", "text": "Least nontrivial multiple of the n-th prime beginning with 6.", "sequence": "6,6,60,63,66,65,68,608,69,609,62,629,615,602,611,636,649,610,603,639,657,632,664,623,679,606,618,642,654,678,635,655,685,695,6109,604,628,652,668,692,6086,6154,6112,6176,6107,6169,633,669,681,687,699,6214", "code": "\nfrom sympy import prime\ndef a(n):\n    pn = prime(n)\n    m = 2*pn\n    while str(m)[0] != '6': m += pn\n    return m\nprint([a(n) for n in range(1, 53)]) \n"}
{"sequence_id": "A078306", "text": "a(n) = Sum_{d divides n} (-1)^(n/d+1)*d^2.", "sequence": "1,3,10,11,26,30,50,43,91,78,122,110,170,150,260,171,290,273,362,286,500,366,530,430,651,510,820,550,842,780,962,683,1220,870,1300,1001,1370,1086,1700,1118,1682,1500,1850,1342,2366,1590,2210,1710,2451,1953", "code": "\nfrom sympy import divisors\nprint([sum((-1)**(n//d + 1)*d**2 for d in divisors(n)) for n in range(1, 51)]) \n"}
{"sequence_id": "A078307", "text": "a(n) = Sum_{d divides n} (-1)^(n/d+1)*d^3.", "sequence": "1,7,28,55,126,196,344,439,757,882,1332,1540,2198,2408,3528,3511,4914,5299,6860,6930,9632,9324,12168,12292,15751,15386,20440,18920,24390,24696,29792,28087,37296,34398,43344,41635,50654,48020,61544,55314,68922,67424", "code": "\nfrom sympy import divisors\nprint([sum((-1)**(n//d + 1)*d**3 for d in divisors(n)) for n in range(1, 51)]) \n"}
{"sequence_id": "A078359", "text": "Number of ways to write n as sum of a positive square and a positive cube.", "sequence": "0,1,0,0,1,0,0,0,1,1,0,1,0,0,0,0,2,0,0,0,0,0,0,1,0,1,0,1,0,0,1,0,1,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,1,0,2,0,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,2,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0", "code": "\nfrom collections import Counter\nfrom itertools import count, takewhile, product\ndef aupto(lim):\n  sqs = list(takewhile(lambda x: x<=lim-1, (i**2 for i in count(1))))\n  cbs = list(takewhile(lambda x: x<=lim-1, (i**3 for i in count(1))))\n  cts = Counter(sum(p) for p in product(sqs, cbs))\n  return [cts[i] for i in range(1, lim+1)]\nprint(aupto(105)) \n"}
{"sequence_id": "A078370", "text": "a(n) = 4*(n+1)*n + 5.", "sequence": "5,13,29,53,85,125,173,229,293,365,445,533,629,733,845,965,1093,1229,1373,1525,1685,1853,2029,2213,2405,2605,2813,3029,3253,3485,3725,3973,4229,4493,4765,5045,5333,5629,5933,6245,6565,6893,7229,7573,7925,8285", "code": " a= lambda n: 4*n**2+4*n+5 \n"}
{"sequence_id": "A078431", "text": "Number of permutations p of 1,2,...,n such that both numerator and denominator of the continued fraction [p(1); p(2),...,p(n)] are primes.", "sequence": "0,1,1,3,3,20,126,694,2874,25059,218517,2054986,21050226", "code": "\nfrom itertools import permutations\nfrom sympy import isprime\nfrom sympy.ntheory.continued_fraction import continued_fraction_reduce\ndef A078431(n): return sum(1 for p in permutations(range(1,n+1)) if (lambda x: isprime(x.p) and isprime(x.q))(continued_fraction_reduce(p))) \n"}
{"sequence_id": "A078432", "text": "Number of permutations p of 1,2,...,n such that the denominator of the continued fraction [p(1); p(2),...,p(n)] is prime.", "sequence": "0,1,4,14,32,204,994,7526,48636,421392,4018976,41304726,490878388", "code": "\nfrom itertools import permutations\nfrom sympy import isprime\nfrom sympy.ntheory.continued_fraction import continued_fraction_reduce\ndef A078432(n): return sum(1 for p in permutations(range(1,n+1)) if isprime(continued_fraction_reduce(p).q)) \n"}
{"sequence_id": "A078433", "text": "Number of permutations p of 1,2,...,n such that the numerator of the continued fraction [p(1); p(2),...,p(n)] is prime.", "sequence": "0,2,2,10,30,124,992,5700,39844,366172,3587856,38861778,435816838", "code": "\nfrom itertools import permutations\nfrom sympy import isprime\nfrom sympy.ntheory.continued_fraction import continued_fraction_reduce\ndef A078433(n): return sum(1 for p in permutations(range(1,n+1)) if isprime(continued_fraction_reduce(p).p)) \n"}
{"sequence_id": "A078514", "text": "Smallest prime is the largest exponent in k's factorization.", "sequence": "4,12,18,20,27,28,36,44,50,52,60,68,76,84,90,92,98,100,116,124,126,132,135,140,148,150,156,164,172,180,188,189,196,198,204,212,220,228,234,236,242,244,252,260,268,276,284,292,294,297,300,306,308,316,332,338", "code": "\nfrom sympy import factorint\ndef aupto(limit):\n  alst = []\n  for k in range(4, limit+1):\n    f = factorint(k)\n    if min(f) == max(f[p] for p in f): alst.append(k)\n  return alst\nprint(aupto(338)) \n"}
{"sequence_id": "A078565", "text": "Number of zeros in the binary expansion of n!.", "sequence": "0,0,1,1,3,3,6,7,10,13,11,19,17,21,25,23,27,27,30,40,40,41,42,44,51,54,54,56,56,63,60,71,76,77,77,77,88,86,90,90,97,99,106,105,107,117,115,117,114,122,126,130,138,138,151,144,146,157,160,158,160,176", "code": "\nimport math\ndef a(n):\n    return bin(math.factorial(n))[2:].count(\"0\")\n\n"}
{"sequence_id": "A078567", "text": "Number of arithmetic subsequences of [1..n] with length > 1.", "sequence": "0,1,4,9,17,27,41,57,77,100,127,156,191,228,269,314,364,416,474,534,600,670,744,820,904,991,1082,1177,1278,1381,1492,1605,1724,1847,1974,2105,2245,2387,2533,2683,2841,3001,3169,3339,3515,3697,3883,4071,4269,4470", "code": "\nfrom math import isqrt\ndef A078567(n):\n    m = isqrt(n-1)\n    return m**2*(1+m)**2//4-m**2*n+sum((n-1)//i*(2*n-i*(1+(n-1)//i)) for i in range(1,m+1)) \n"}
{"sequence_id": "A078612", "text": "Number of transitions necessary for a Turing machine to compute the differences between consecutive primes (primes written in unary), when using the instruction table below.", "sequence": "22,38,80,140,302,410,668,824,1182,1832,2086,2930,3572,3920,4662,5892,7262,7756,9320,10442,11032,12884,14202,16298,19310,20912,21740,23438,24314,26120,32900,34986,38228,39350,45152,46366,50092,53960,56622,60732,64982,66440", "code": " \n"}
{"sequence_id": "A078836", "text": "a(n) = n*2^(n-6).", "sequence": "6,14,32,72,160,352,768,1664,3584,7680,16384,34816,73728,155648,327680,688128,1441792,3014656,6291456,13107200,27262976,56623104,117440512,243269632,503316480,1040187392,2147483648,4429185024,9126805504,18790481920,38654705664", "code": "\ndef a(n): return n << (n-6)\nprint([a(n) for n in range(6, 37)]) \n"}
{"sequence_id": "A078971", "text": "Numbers n such that C(4n,n)/(3n+1) (A002293) is not divisible by 4.", "sequence": "0,1,3,5,11,13,21,43,45,53,85,171,173,181,213,341,683,685,693,725,853,1365,2731,2733,2741,2773,2901,3413,5461,10923,10925,10933,10965,11093,11605,13653,21845,43691,43693,43701,43733,43861,44373,46421,54613", "code": "\nfrom __future__ import division\nA078971_list = []\nfor t in range(100):\n    A078971_list.append((2**(2*t)-1)//3)\n    for j in range(t):\n        A078971_list.append((2**(2*t+1)+2**(2*j+1)-1)//3) \n"}
{"sequence_id": "A078972", "text": "Brilliant numbers: semiprimes (products of two primes, A001358) whose prime factors have the same number of decimal digits.", "sequence": "4,6,9,10,14,15,21,25,35,49,121,143,169,187,209,221,247,253,289,299,319,323,341,361,377,391,403,407,437,451,473,481,493,517,527,529,533,551,559,583,589,611,629,649,667,671,689,697,703,713,731,737,767,779,781", "code": "\nfrom sympy import sieve\nA078972 = []\nfor n in range(3):\n    pr = list(sieve.primerange(10**n,10**(n+1)))\n    for i,p in enumerate(pr):\n        for q in pr[i:]:\n            A078972.append(p*q)\nA078972 = sorted(A078972)\n\n"}
{"sequence_id": "A079079", "text": "a(n) = (prime(n)+1)*(prime(n+1)+1)/4.", "sequence": "3,6,12,24,42,63,90,120,180,240,304,399,462,528,648,810,930,1054,1224,1332,1480,1680,1890,2205,2499,2652,2808,2970,3135,3648,4224,4554,4830,5250,5700,6004,6478,6888,7308,7830,8190,8736,9312,9603,9900,10600", "code": "\nfrom sympy import prime\ndef a(n): return (prime(n) + 1)*(prime(n + 1) + 1)/4 \n"}
{"sequence_id": "A079155", "text": "The number of primes less than 10^n whose digital root (A038194) is also prime.", "sequence": "4,15,85,619,4800,39266,332276,2880818,25423985,227527467", "code": "\n\nfrom sympy import isprime, sieve\ndef afind(terms):\n  s = 0\n  for n in range(1, terms+1):\n    s += sum(isprime(p%9) for p in sieve.primerange(10**(n-1), 10**n))\n    print(s, end=\", \")\nafind(7) \n"}
{"sequence_id": "A079277", "text": "Largest integer k < n such that any prime factor of k is also a prime factor of n.", "sequence": "1,1,2,1,4,1,4,3,8,1,9,1,8,9,8,1,16,1,16,9,16,1,18,5,16,9,16,1,27,1,16,27,32,25,32,1,32,27,32,1,36,1,32,27,32,1,36,7,40,27,32,1,48,25,49,27,32,1,54,1,32,49,32,25,64,1,64,27,64,1,64,1,64,45,64,49,72,1,64,27", "code": "\nfrom sympy import divisors\nfrom sympy.ntheory.factor_ import core\ndef a007947(n): return max(d for d in divisors(n) if core(d) == d)\ndef a(n):\n    k=n - 1\n    while True:\n        if a007947(k*n) == a007947(n): return k\n        else: k-=1\nprint([a(n) for n in range(2, 101)]) \n"}
{"sequence_id": "A079320", "text": "CATS sequence: cube-add-then-sort variation of RATS (reverse, add then sort) sequence.", "sequence": "1,3,68,13,222,35,25,378,11,1234,147,122,2578,339,1124,349,558,6788,28,2289,167,1129,13488,1556,1267,1179,1289,12448,237,22289,238,3579,33389,1249,24669,569,1459,35589,446,26689,1347,5579,22588,1179,23789,1378", "code": "\ndef A079320(n):\n....x=str(n+n**3)\n....return int(\"\".join(sorted(x))) \n"}
{"sequence_id": "A079399", "text": "Number of dots in Braille representation of n.", "sequence": "3,1,2,2,3,2,3,4,3,2,4,2,3,3,4,3,4,5,4,3,5,3,4,4,5,4,5,6,5,4,5,3,4,4,5,4,5,6,5,4,6,4,5,5,6,5,6,7,6,5,5,3,4,4,5,4,5,6,5,4,6,4,5,5,6,5,6,7,6,5,7,5,6,6,7,6,7,8,7,6,6,4,5,5,6,5,6,7,6,5,5,3,4,4,5,4,5,6,5,4", "code": "\nb = [3, 1, 2, 2, 3, 2, 3, 4, 3, 2]\ndef a(n): return sum(b[d] for d in map(int, str(n)))\nprint([a(n) for n in range(100)]) \n"}
{"sequence_id": "A079427", "text": "Least m > n having the same number of divisors as n, a(1) = 1.", "sequence": "1,3,5,9,7,8,11,10,25,14,13,18,17,15,21,81,19,20,23,28,22,26,29,30,49,27,33,32,31,40,37,44,34,35,38,100,41,39,46,42,43,54,47,45,50,51,53,80,121,52,55,63,59,56,57,66,58,62,61,72,67,65,68,729,69,70,71,75,74,78,73", "code": "\nfrom sympy import divisors\ndef a(n):\n    if n == 1: return 1\n    divisorsn, m = len(divisors(n)), n + 1\n    while len(divisors(m)) != divisorsn: m += 1\n    return m\nprint([a(n) for n in range(1, 72)]) \n"}
{"sequence_id": "A079475", "text": "Number described by n using the \"Look and Say\" rule.", "sequence": "0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,11,22,33,44,55,66,77,88,99,0,111,222,333,444,555,666,777,888,999,0,1111,2222,3333,4444,5555,6666,7777,8888,9999,0", "code": "\ndef A079475(n):\n    s = str(n)\n    l = len(s)\n    if l % 2:\n        s = s[:-1]+'1'+s[-1]\n    return int(''.join(s[i+1]*int(s[i]) for i in range(0,l,2))) \n"}
{"sequence_id": "A079559", "text": "Number of partitions of n into distinct parts of the form 2^j-1, j=1,2,....", "sequence": "1,1,0,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,1,0,0,1,1,0,1", "code": "\ndef a053644(n): return 0 if n==0 else 2**(len(bin(n)[2:]) - 1)\ndef a043545(n):\n    x=bin(n)[2:]\n    return int(max(x)) - int(min(x))\nl=[1]\nfor n in range(1, 101): l+=[a043545(n + 1)*l[n + 1 - a053644(n + 1)], ]\nprint(l) \n"}
{"sequence_id": "A079584", "text": "Number of ones in the binary expansion of n!.", "sequence": "1,1,2,2,4,4,6,6,6,11,7,12,12,12,18,18,22,23,17,22,25,28,31,29,30,35,38,42,40,48,42,42,46,51,56,51,58,59,64,63,66,64,71,74,70,77,81,89,87,89,90,88,94,87,99,103,98,101,109,113,103,113,120,120,109,123,121,130,121", "code": "\nimport math\ndef a(n):\n    return bin(math.factorial(n))[2:].count(\"1\") \n"}
{"sequence_id": "A079756", "text": "Operation count to create all permutations of n distinct elements using the \"streamlined\" version of Algorithm L (lexicographic permutation generation) from Knuth's The Art of Computer Programming, Vol. 4, chapter 7.2.1.2. Sequence gives number of interchanges in reversal step.", "sequence": "0,0,4,29,215,1734,15630,156327,1719637,20635688,268264004,3755696121,56335441899,901367070474,15323240198170,275818323567179,5240548147776545,104810962955531052,2201030222066152272", "code": "\nl=[0, 0, 0, 0, 0]\nfor n in range(5, 22):\n    l.append(n*l[n - 1] + (n - 1)*((n - 1)//2 - 1))\nprint(l[3:]) \n"}
{"sequence_id": "A079831", "text": "Numbers n such that floor(reverse(n)/n) = 2.", "sequence": "13,14,25,26,27,28,38,39,103,113,123,133,143,153,154,163,164,173,174,183,184,193,194,205,206,215,216,225,226,235,236,245,246,255,256,257,265,266,267,275,276,277,285,286,287,295,296,297,298,307,308,309,317", "code": "\nfrom math import floor\nfor i in range(1,1000):\n....if floor(int(str(i)[::-1])/i)==2:\n........print(i)\n\n"}
{"sequence_id": "A079832", "text": "Numbers n such that floor(reverse(n)/n) = 3.", "sequence": "15,16,29,104,114,124,134,135,144,145,155,165,166,175,176,185,186,195,196,207,208,217,218,227,228,237,238,239,247,248,249,258,259,268,269,278,279,288,289,299,1004,1013,1023,1033,1043,1053,1063,1073,1083,1093", "code": "\nfrom math import floor\nfor i in range(1,1100):\n....if floor(int(str(i)[::-1])/i)==3:\n........print(i)\n\n"}
{"sequence_id": "A079873", "text": "Number of positions that are exactly n moves from the starting position in the Classic Lights Out puzzle.", "sequence": "1,25,300,2300,12650,53130,176176,476104,982335,1596279,1935294,1684446,1004934,383670,82614,7350", "code": " \ndef moves(p, shape, states):\n  nxt, (n, m), k = set(), shape, states\n  for r in range(n):\n    for c in range(m):\n      new = list(p[:])\n      for ro, co in [(r,c), (r+1, c), (r, c+1), (r-1, c), (r, c-1)]:\n        if 0 <= ro < n and 0 <= co < m:\n          new[ro*m + co] = (new[ro*m + co]+1)%k\n      nxt.add(tuple(new))\n  return nxt\ndef alst(start, shape, states, v=False, maxd=float('inf')):\n  alst, d, expanded, frontier = [], 0, set(), {start}\n  alst.append(len(frontier))\n  if v: print(len(frontier), end=\", \")\n  while len(frontier) > 0 and d < maxd:\n    reach1 = set(m for p in frontier for m in moves(p, shape, states) if m not in expanded)\n    expanded |= frontier\n    if len(reach1):\n      alst.append(len(reach1))\n      if v: print(len(reach1), end=\", \")\n    frontier = reach1\n    d += 1\n  return alst\nshape, states = (5, 5), 2  \nstart = tuple([0 for i in range(shape[0]*shape[1])])\nprint(alst(start, shape, states, v=True)) \n"}
{"sequence_id": "A079875", "text": "Number of positions that are exactly n moves from the starting position in the Lights Out 2000 puzzle.", "sequence": "1,25,325,2900,19850,110630,520948,2125078,7644164,24561916,71147752,186876765,446015084,964537892,1872111656,3203446007,4709112417,5767439109,5710406148,4433675458,2590026921,1073252214,279734731,36143633,2147985", "code": " \nshape, states = (5, 5), 3  \nstart = tuple([0 for i in range(shape[0]*shape[1])])\nprint(alst(start, shape, states, v=True)) \n"}
{"sequence_id": "A080029", "text": "a(n) is taken to be the smallest positive integer not already present which is consistent with the condition \"n is a member of the sequence if and only if a(n) is a multiple of 3\".", "sequence": "0,2,3,6,5,9,12,8,15,18,11,21,24,14,27,30,17,33,36,20,39,42,23,45,48,26,51,54,29,57,60,32,63,66,35,69,72,38,75,78,41,81,84,44,87,90,47,93,96,50,99,102,53,105,108,56,111,114,59,117,120,62,123,126,65,129,132,68", "code": "\ndef a(n): m, r = divmod(n, 3); return 3*(2-r%2)*m + (r > 0)*(r+1)\nprint([a(n) for n in range(68)]) \n"}
{"sequence_id": "A080343", "text": "a(n) = round(sqrt(2*n)) - floor(sqrt(2*n)).", "sequence": "0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0", "code": "\nfrom gmpy2 import isqrt_rem\ndef A080343(n):\n    i, j = isqrt_rem(2*n)\n    return int(4*(j-i) >= 1) \n"}
{"sequence_id": "A080346", "text": "First card number to reach the top of the deck n times in Guy's shuffle (see A035485).", "sequence": "2,1,14,14,38,14,38,157,1,16929,170,170,170,170", "code": " \nfrom collections import Counter\ndef find_terms(max_shuffles):\n  deck, times_on_top = [i for i in range(1, 2*max_shuffles+1)], Counter()\n  alst, shuffles, n = [1], 0, 1\n  while shuffles < max_shuffles:\n    shuffles += 1\n    first, next = deck[:shuffles], deck[shuffles:2*shuffles]\n    deck[0:2*shuffles:2], deck[1:2*shuffles:2] = next, first\n    times_on_top[deck[0]] += 1\n    if times_on_top[deck[0]] == n: print(n, deck[0], shuffles); n += 1\nfind_terms(35000) \n"}
{"sequence_id": "A080347", "text": "Number of shuffles in Guy's shuffle (A035485) corresponding to the terms in A080346.", "sequence": "1,7,41,80,219,313,1579,4250,32327,96057,203774,321975,394664,1430433", "code": " \n"}
{"sequence_id": "A080368", "text": "a(n) is the least unitary prime divisor of n, or 0 if no such prime divisor exists.", "sequence": "0,2,3,0,5,2,7,0,0,2,11,3,13,2,3,0,17,2,19,5,3,2,23,3,0,2,0,7,29,2,31,0,3,2,5,0,37,2,3,5,41,2,43,11,5,2,47,3,0,2,3,13,53,2,5,7,3,2,59,3,61,2,7,0,5,2,67,17,3,2,71,0,73,2,3,19,7,2,79,5,0,2,83,3,5,2,3,11,89,2,7,23,3,2", "code": "\nfrom sympy import factorint, prime, primepi, isprime, primefactors\ndef a049084(n): return primepi(n)*(1*isprime(n))\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef a028234(n):\n    f = factorint(n)\n    return 1 if n==1 else n/(min(f)**f[min(f)])\ndef a067029(n):\n    f=factorint(n)\n    return 0 if n==1 else f[min(f)]\ndef a277697(n): return 0 if n==1 else a055396(n) if a067029(n)==1 else a277697(a028234(n))\ndef a(n): return 0 if a277697(n)==0 else prime(a277697(n)) \n"}
{"sequence_id": "A080478", "text": "a(n) = smallest k>a(n-1) such that k^2+a(n-1)^2 is prime, starting with a(1)=1. Square roots of A062067(n).", "sequence": "1,2,3,8,13,20,23,30,31,44,49,74,79,80,89,96,101,104,105,116,119,124,131,134,139,140,149,150,157,158,165,172,173,178,183,202,203,230,231,250,257,260,261,274,289,290,291,296,311,334,335,342,343,360,367,372", "code": "\nfrom sympy import isprime\nA080478, a = [1], 1\nfor _ in range(1,10000):\n....a += 1\n....b = 2*a*(a-1) + 1\n....while not isprime(b):\n........b += 4*(a+1)\n........a += 2\n....A080478.append(a) \n"}
{"sequence_id": "A080479", "text": "Smallest number formed by using all the digits (with multiplicity) of next n numbers.", "sequence": "1,23,456,10789,1111112345,101111226789,22222222345678,1022333333334569,102333344444445789,10234444455555556789,1023455555666666666789,102345666677777777777889,10012345677888888888889999,1000000011111122334455678999999999", "code": "\ndef a(n):\n  s = \"\".join(sorted(\"\".join(map(str, range((n-1)*n//2+1, n*(n+1)//2+1)))))\n  if '0' not in s: return int(s)\n  rz = s.rfind('0')\n  return int(s[rz+1] + s[:rz+1] + s[rz+2:])\nprint([a(n) for n in range(1, 15)]) \n"}
{"sequence_id": "A080480", "text": "Largest number formed by using all the digits (with multiplicity) of next n numbers.", "sequence": "1,32,654,98710,5432111111,987622111110,87654322222222,9654333333332210,987544444443333210,98765555555444443210,9876666666665555543210,988777777777776666543210,99998888888888877654321100,9999999998765544332211111110000000", "code": "\ndef a(n):\n  s = \"\".join(sorted(\"\".join(map(str, range((n-1)*n//2+1, n*(n+1)//2+1)))))\n  return int(\"\".join(sorted(s, reverse=True)))\nprint([a(n) for n in range(1, 15)]) \n"}
{"sequence_id": "A080578", "text": "a(1)=1; for n > 1, a(n) = a(n-1) + 1 if n is already in the sequence, a(n) = a(n-1) + 3 otherwise.", "sequence": "1,4,7,8,11,14,15,16,19,22,23,26,29,30,31,32,35,38,39,42,45,46,47,50,53,54,57,60,61,62,63,64,67,70,71,74,77,78,79,82,85,86,89,92,93,94,95,98,101,102,105,108,109,110,113,116,117,120,123,124,125,126", "code": "\nl=[1]\na=1\nfor n in range(2, 101):\n    a += 3 if n not in l else 1\n    l.append(a)\nprint(l) \n"}
{"sequence_id": "A080649", "text": "Sum of prime factors of sigma(n).", "sequence": "3,2,7,5,5,2,8,13,5,5,9,9,5,5,31,5,16,7,12,2,5,5,10,31,12,7,9,10,5,2,10,5,5,5,20,21,10,9,10,12,5,13,12,18,5,5,33,22,34,5,9,5,10,5,10,7,10,10,12,33,5,15,127,12,5,19,12,5,5,5,21,39,24,33,14,5,12,7,36,11,12,12,9,5", "code": "\nfrom sympy import isprime\ndef sigma(n):\n    return sum(i for i in range(1,n+1) if n % i == 0)\ndef sopf(n):\n    return sum(i for i in range(1,n+1) if n % i == 0 and isprime(i))\ndef A080649(n):\n    return sopf(sigma(n))\nfor i in range(2,101):\n    print(str(i)+\" \"+str(A080649(i))) \n"}
{"sequence_id": "A080670", "text": "Literal reading of the prime factorization of n.", "sequence": "1,2,3,22,5,23,7,23,32,25,11,223,13,27,35,24,17,232,19,225,37,211,23,233,52,213,33,227,29,235,31,25,311,217,57,2232,37,219,313,235,41,237,43,2211,325,223,47,243,72,252,317,2213,53,233,511,237,319,229,59,2235", "code": "\nimport sympy\n[int(''.join([str(y) for x in sorted(sympy.ntheory.factorint(n).items()) for y in x if y != 1])) for n in range(2,100)] \n\n"}
{"sequence_id": "A080696", "text": "Piptorial numbers = product of first n pips or prime-indexed primes.", "sequence": "3,15,165,2805,86955,3565155,210344145,14093057715,1169723790345,127499893147605,16192486429745835,2542220369470096095,455057446135147201005,86915972211813115391955,18339270136692567347702505,4419764102942908730796303705", "code": "\nfrom sympy import prime, nextprime\ndef aupton(terms):\n  prod, p, alst = 1, 2, []\n  while len(alst) < terms:\n    p, prod = nextprime(p), prod * prime(p)\n    alst.append(prod)\n  return alst\nprint(aupton(16)) \n"}
{"sequence_id": "A080719", "text": "Replace decimal digits with their binary values and convert back to decimal representation.", "sequence": "0,1,2,3,4,5,6,7,8,9,2,3,6,7,12,13,14,15,24,25,4,5,10,11,20,21,22,23,40,41,6,7,14,15,28,29,30,31,56,57,8,9,18,19,36,37,38,39,72,73,10,11,22,23,44,45,46,47,88,89,12,13,26,27,52,53,54,55,104,105,14,15,30,31,60,61,62", "code": "\ndef A080719(n):\n....return int(''.join((format(int(d),'b') for d in str(n))),2)\n\n"}
{"sequence_id": "A080791", "text": "Number of nonleading 0's in binary expansion of n.", "sequence": "0,0,1,0,2,1,1,0,3,2,2,1,2,1,1,0,4,3,3,2,3,2,2,1,3,2,2,1,2,1,1,0,5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,4,3,3,2,3,2,2,1,3,2,2,1,2,1,1,0,6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,5,4,4,3,4,3,3,2,4", "code": " def a(n): return bin(n)[2:].count(\"0\") if n>0 else 0 \n"}
{"sequence_id": "A080837", "text": "Jouka numbers: either the number is divisible by 7 or 11 or has a 7 in its decimal representation.", "sequence": "7,11,14,17,21,22,27,28,33,35,37,42,44,47,49,55,56,57,63,66,67,70,71,72,73,74,75,76,77,78,79,84,87,88,91,97,98,99,105,107,110,112,117,119,121,126,127,132,133,137,140,143,147,154,157,161,165,167,168,170", "code": "\ndef ok(n): return n%7 == 0 or n%11 == 0 or '7' in str(n)\nprint(list(filter(ok, range(1, 171)))) \n"}
{"sequence_id": "A081015", "text": "a(n) = Lucas(4n+3) + 1, or 5*Fibonacci(2n+1)*Fibonacci(2n+2).", "sequence": "5,30,200,1365,9350,64080,439205,3010350,20633240,141422325,969323030,6643838880,45537549125,312119004990,2139295485800,14662949395605,100501350283430,688846502588400,4721424167835365,32361122672259150,221806434537978680,1520283919093591605", "code": "\nfrom sympy import lucas\ndef a(n): return lucas(4*n+3) + 1\nprint([a(n) for n in range(22)]) \n"}
{"sequence_id": "A081134", "text": "Distance to nearest power of 3.", "sequence": "0,1,0,1,2,3,2,1,0,1,2,3,4,5,6,7,8,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7", "code": "\ndef A081134(n):\n    kmin, kmax = 0,1\n    while 3**kmax <= n:\n        kmax *= 2\n    while True:\n        kmid = (kmax+kmin)//2\n        if 3**kmid > n:\n            kmax = kmid\n        else:\n            kmin = kmid\n        if kmax-kmin <= 1:\n            break\n    return min(n-3**kmin, 3*3**kmin-n) \n"}
{"sequence_id": "A081145", "text": "a(1)=1; thereafter, a(n) is the least positive integer which has not already occurred and is such that |a(n)-a(n-1)| is different from any |a(k)-a(k-1)| which has already occurred.", "sequence": "1,2,4,7,3,8,14,5,12,20,6,16,27,9,21,34,10,25,41,11,28,47,13,33,54,15,37,60,17,42,68,18,45,73,19,48,79,22,55,23,58,94,24,61,99,26,66,107,29,71,115,30,75,121,31,78,126,32,81,132,35,87,140,36,91,147,38,96,155,39", "code": "\nA081145_list, l, s, b1, b2 = [1,2], 2, 3, set(), set([1])\nfor n in range(3, 10**2):\n    i = s\n    while True:\n        m = abs(i-l)\n        if not (i in b1 or m in b2):\n            A081145_list.append(i)\n            b1.add(i)\n            b2.add(m)\n            l = i\n            while s in b1:\n                b1.remove(s)\n                s += 1\n            break\n        i += 1 \n"}
{"sequence_id": "A081288", "text": "a(n) is the minimal i such that A000108(i) > n.", "sequence": "0,2,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6", "code": "\nfrom sympy import catalan\ndef a(n):\n    if n==0: return 0\n    i=1\n    while True:\n        if catalan(i)>n: return i\n        else: i+=1\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A081297", "text": "Array T(k,n), read by antidiagonals: T(k,n) = ((k+1)^(n+1)-(-k)^(n+1))/(2k+1).", "sequence": "1,1,1,1,1,1,1,1,3,1,1,1,7,5,1,1,1,13,13,11,1,1,1,21,25,55,21,1,1,1,31,41,181,133,43,1,1,1,43,61,461,481,463,85,1,1,1,57,85,991,1281,2653,1261,171,1,1,1,73,113,1891,2821,10501,8425,4039,341,1,1,1,91,145,3305", "code": "\ndef T(n, k): return ((n + 1)**(k + 1) - (-n)**(k + 1)) // (2*n + 1)\nfor n in range(11):\n    print([T(n - k, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A081344", "text": "Natural numbers in square maze arrangement, read by antidiagonals.", "sequence": "1,2,4,9,3,5,10,8,6,16,25,11,7,15,17,26,24,12,14,18,36,49,27,23,13,19,35,37,50,48,28,22,20,34,38,64,81,51,47,29,21,33,39,63,65,82,80,52,46,30,32,40,62,66,100,121,83,79,53,45,31,41,61,67,99,101,122,120,84,78,54", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nif j >= i:\n     m=(j-1)**2 + j + (j-i)*(-1)**(j-1)\nelse:\n     m=(i-1)**2 + i - (i-j)*(-1)**(i-1)\n\n"}
{"sequence_id": "A081400", "text": "a(n) = d(n) - bigomega(n) - A005361(n).", "sequence": "0,0,0,-1,0,1,0,-2,-1,1,0,1,0,1,1,-3,0,1,0,1,1,1,0,1,-1,1,-2,1,0,4,0,-4,1,1,1,1,0,1,1,1,0,4,0,1,1,1,0,1,-1,1,1,1,0,1,1,1,1,1,0,6,0,1,1,-5,1,4,0,1,1,4,0,1,0,1,1,1,1,4,0,1,-3,1,0,6,1,1,1,1,0,6,1,1,1,1,1,1,0,1,1,1,0,4,0,1,4,1,0,1,0,4,1,1,0,4,1,1,1,1,1,8,-1,1", "code": "\nfrom sympy import primefactors, factorint, divisor_count\nfrom operator import mul\ndef bigomega(n): return 0 if n==1 else bigomega(n/primefactors(n)[0]) + 1\ndef a005361(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [f[i] for i in f])\ndef a(n): return divisor_count(n) - bigomega(n) - a005361(n) \n"}
{"sequence_id": "A081567", "text": "Second binomial transform of F(n+1).", "sequence": "1,3,10,35,125,450,1625,5875,21250,76875,278125,1006250,3640625,13171875,47656250,172421875,623828125,2257031250,8166015625,29544921875,106894531250,386748046875,1399267578125,5062597656250", "code": "\ndef a(n, adict={0:1, 1:3}):\n    if n in adict:\n        return adict[n]\n    adict[n]=5*a(n-1) - 5*a(n-2)\n    return adict[n] \n"}
{"sequence_id": "A081762", "text": "Primes p such that p*(p-2) divides 2^(p-1)-1.", "sequence": "3,5,17,37,257,457,1297,2557,4357,6481,8009,11953,26321,44101,47521,47881,49681,57241,65537,74449,84421,97813,141157,157081,165601,225457,278497,310591,333433,365941,403901,419711,476737,557041,560737,576721,1011961,1033057", "code": "\nfrom sympy import prime\nfrom gmpy2 import powmod\nA081762_list = [p for p in (prime(n) for n in range(2,10**5)) if powmod(2,p-1,p*(p-2)) == 1] \n"}
{"sequence_id": "A081849", "text": "Consider recurrence b(0) = (2n+1)/2, b(n) = b(0)*ceiling(b(n-1)); sequence gives first integer reached.", "sequence": "3,20,14,468,33,299,60,47328,95,1218,138,25475,189,3161,248,20830128,315,6512,390,181138,473,11655,564,9015167,663,18974,770,671745,885,28853,1008,38906570560,1139,41676,1278,1799888,1425,57827,1580,110341278,1743,77690", "code": "\nfrom math import ceil\nfrom fractions import Fraction\ndef a(n):\n  b0 = b = Fraction((2*n+1), 2)\n  while b.denominator != 1: b = b0*ceil(b)\n  return b.numerator\nprint([a(n) for n in range(1, 43)]) \n"}
{"sequence_id": "A081957", "text": "Triangle whose n-th row contains the n smallest numbers that are products of n distinct integers > 1, read by rows.", "sequence": "2,6,8,24,30,36,120,144,168,180,720,840,960,1008,1080,5040,5760,6480,6720,7200,7560,40320,45360,50400,51840,55440,57600,60480,362880,403200,443520,453600,483840,498960,518400,524160,3628800,3991680,4354560,4435200,4717440,4838400,4989600,5080320,5241600", "code": " \n"}
{"sequence_id": "A081958", "text": "Diagonal of A081957.", "sequence": "2,8,36,180,1080,7560,60480,524160,5241600,56609280,670602240,8622028800,118879488000,1793381990400,28158588057600,474249904128000,8447576417280000,159659194286592000,3162772610629632000,66117689869271040000,1445143792856924160000", "code": " def a(n): return row(n)[-1] \n"}
{"sequence_id": "A081959", "text": "Row sums of A081957.", "sequence": "2,14,90,612,4608,38760,361440,3688560,41277600,501379200,6576837120,92697696000,1397414592000,22498705152000,382873642905600,6908854669516800,131496596027596800,2633684945988096000", "code": " def a(n): return sum(row(n)) \n"}
{"sequence_id": "A081960", "text": "Row products of A081957.", "sequence": "2,48,25920,522547200,632073093120000,68810005209415680000000,922882872556916481982464000000000,1930928443374224487368323197252403200000000000,848408612299117898787190662782756632189835673600000000000000", "code": "\nfrom functools import reduce\nimport operator\ndef a(n): return reduce(operator.mul, row(n), 1) \n"}
{"sequence_id": "A082007", "text": "Triangle (an infinite binary tree) read by rows; see Comments lines for definition.", "sequence": "0,1,2,3,6,9,12,4,5,7,8,10,11,13,14,15,30,45,60,75,90,105,120,135,150,165,180,195,210,225,240,16,17,31,32,46,47,61,62,76,77,91,92,106,107,121,122,136,137,151,152,166,167,181,182,196,197", "code": "\ndef A082007( n ):\n..if n == 0: return 0\n..\n..y = 2 ** int( log( n + 1, 2 ) )\n..yc = 2 ** 2 ** int( log( log( y, 2 ), 2 ) )\n..yr = y / yc\n..return (yc-1) * int( (n+1-y)/yr + 1 ) + A082007( yr + (n+1)%yr - 1 )\n\n"}
{"sequence_id": "A082008", "text": "a(n) = A082007(n-1) + 1.", "sequence": "1,2,3,4,7,10,13,5,6,8,9,11,12,14,15,16,31,46,61,76,91,106,121,136,151,166,181,196,211,226,241,17,18,32,33,47,48,62,63,77,78,92,93,107,108,122,123,137,138,152,153,167,168,182,183,197,198", "code": "\ndef A082008( n ):\n    if n == 1: return 1\n    y = 2 ** int( log( n, 2 ) )\n    yc = 2 ** 2 ** int( log( log( y, 2 ), 2 ) )\n    yr = y // yc\n    return (yc-1) * int( (n-y) / yr + 1 ) + A082008( yr + n % yr )\n\n"}
{"sequence_id": "A082060", "text": "Numbers n such that n and phi(n) have the same distinct decimal digits.", "sequence": "1,21,63,101,233,291,502,677,1021,1031,1051,1061,1091,1201,1226,1301,1601,1801,1901,2011,2201,2333,2383,2393,2518,2633,2677,2700,2767,2817,2833,2991,3011,3023,3122,3203,3253,3323,3623,3677,3767,3823,3923,3989", "code": "\nfrom sympy import totient\nA082060_list = [n for n in range(1,10**4) if set(str(totient(n))) == set(str(n))] \n"}
{"sequence_id": "A082066", "text": "Greatest common prime-divisor of sigma_1(n)=A000203(n) and sigma_2(n)=A001157(n); a(n)=1 if no common prime-divisor was found.", "sequence": "1,1,2,7,2,2,2,5,13,2,2,7,2,2,2,31,2,13,2,7,2,2,2,5,31,2,5,7,2,2,2,7,2,2,2,13,2,5,2,5,2,2,2,7,13,2,2,31,19,31,2,7,2,5,2,5,5,5,2,7,2,2,13,127,2,2,2,7,2,2,2,13,2,2,31,7,2,2,2,31,11,2,2,7,2,2,5,5,2,13,2,7,2,2,2,7,2", "code": "\nfrom sympy import primefactors, gcd, divisor_sigma\ndef a006530(n): return 1 if n==1 else primefactors(n)[-1]\ndef a(n): return a006530(gcd(divisor_sigma(n), divisor_sigma(n, 2))) \n"}
{"sequence_id": "A082183", "text": "Smallest k > 0 such that T(n) + T(k) = T(m), for some m, T(i) being the triangular numbers, n > 1.", "sequence": "2,5,9,3,5,27,10,4,8,14,17,9,5,21,135,12,14,35,6,9,17,30,12,18,10,7,54,21,23,495,42,14,26,8,49,27,15,20,98,30,32,80,9,19,35,62,45,17,20,14,99,39,10,18,54,24,44,78,81,45,25,85,153,11,50,125,20,29,53,94,97", "code": "\nfrom __future__ import division\nfrom sympy import divisors\ndef A082183(n):\n    t = n*(n+1)\n    ds = divisors(t)\n    for i in range(len(ds)//2-2,-1,-1):\n        x = ds[i]\n        y = t//x\n        a, b = divmod(y-x,2)\n        if b:\n            return a\n    return -1 \n"}
{"sequence_id": "A082216", "text": "Smallest palindrome beginning with n.", "sequence": "0,1,2,3,4,5,6,7,8,9,101,11,121,131,141,151,161,171,181,191,202,212,22,232,242,252,262,272,282,292,303,313,323,33,343,353,363,373,383,393,404,414,424,434,44,454,464,474,484,494,505", "code": "\ndef A082216(n):\n    s = str(n)\n    t = s[::-1]\n    if s == t:\n        return n\n    for i in range(1,len(s)):\n        if s[i:] == t[:-i]:\n            return int(s+t[-i:]) \n"}
{"sequence_id": "A082232", "text": "Palindromes divisible by their digit sum.", "sequence": "1,2,3,4,5,6,7,8,9,111,171,222,252,333,414,444,555,666,777,828,888,999,2112,2772,2992,4224,4554,4774,6336,6556,8118,8338,8448,10101,10701,10901,11511,12321,13131,15751,18981,19791,20202,20502,20702,21012,21112", "code": "\nA082232 = sorted([int(str(x)+str(x)[::-1]) for x in range(1,10**5) if not\n....int(str(x)+str(x)[::-1]) % sum((int(d) for d in str(x)+str(x)[::-1]))]\n....+ [int(str(x)+str(x)[-2::-1]) for x in range(1,10**5) if not\n....int(str(x)+str(x)[-2::-1]) % sum((int(d) for d in str(x)+str(x)[-2::-1]))]) \n"}
{"sequence_id": "A082277", "text": "Smallest prime that is the sum of prime(n) consecutive primes.", "sequence": "5,23,53,197,233,691,499,857,1151,2099,2399,2909,3821,4217,5107,6079,10091,8273,12281,11597,12713,15527,22741,26041,25759,37447,28087,36607,36067,35527,42463,46181,49279,65033,67271,71011,71167,76099,78139,96001,95107", "code": "\nfrom sympy import isprime, nextprime, prime, primerange\ndef a(n):\n  pn = prime(prime(n))\n  smallest = list(primerange(2, pn+1))\n  while not isprime(sum(smallest)):\n    pn = nextprime(pn)\n    smallest = smallest[1:] + [pn]\n  return sum(smallest)\nprint([a(n) for n in range(1, 42)]) \n"}
{"sequence_id": "A082410", "text": "a(1)=0. Thereafter, the sequence is constructed using the rule: for any k >= 0, if a(1), a(2), ..., a(2^k+1) are known, the next 2^k terms are given as follows: a(2^k+1+i) = 1 - a(2^k+1-i) for 1 <= i <= 2^k.", "sequence": "0,1,1,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,1,1,0,0,0,1,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,1,0,0,1,0,0,0,1,1,0,1,1,0,0,0,1,1,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,1,1,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,0,1", "code": "\ndef A082410(n):\n    if n == 1:\n        return 0\n    s = bin(n-1)[2:]\n    m = len(s)\n    i = s[::-1].find('1')\n    return 1-int(s[m-i-2]) if m-i-2 >= 0 else 1 \n"}
{"sequence_id": "A082433", "text": "a(n) = A072181(n) - p, where p is the largest prime < A072181(n) - 1.", "sequence": "3,5,7,7,11,11,11,11,13,23,17,17,17,41,191,47,31,53,53,53,31,179,61,61,337,131,523,523,419,223,223,223,223,79,3821,3821,3821,23399,21269,21269,3607", "code": "\nfrom sympy import factorint, isprime\ndef afindn(terms):\n    prev_factors, prevan, prevk, n = dict(), 1, None, 2\n    for n in range(2, terms+1):\n        n_factors, an = factorint(n), 1\n        for pi in set(prev_factors.keys()) | set(n_factors.keys()):\n            ei = prev_factors[pi] if pi in prev_factors else 1\n            fi = n_factors[pi] if pi in n_factors else 1\n            an *= pi**(ei*fi)\n        if n >= 3:\n            if an != prevan:\n                k = 3\n                while not isprime(an - k): k += 2\n            else:\n                k = prevk\n            print(k, end=\", \")\n            prevk = k\n        prev_factors, prevan = factorint(an), an\nafindn(36) \n"}
{"sequence_id": "A082439", "text": "Palindromic primes with middle digit 3.", "sequence": "3,131,10301,11311,13331,14341,16361,19391,32323,35353,71317,76367,77377,79397,94349,97379,98389,1003001,1043401,1093901,1123211,1153511,1163611,1183811,1193911,1243421,1253521,1273721,1303031,1333331,1343431,1363631,1463641", "code": "\nfrom gmpy2 import is_prime\nA082439_list = [3]\nfor i in range(1,10**6):\n    s = str(i)\n    n = int(s+'3'+s[::-1])\n    if is_prime(n):\n        A082439_list.append(n) \n"}
{"sequence_id": "A082491", "text": "a(n) = n! * d(n), where n! = factorial numbers (A000142), d(n) = subfactorial numbers (A000166).", "sequence": "1,0,2,12,216,5280,190800,9344160,598066560,48443028480,4844306476800,586161043776000,84407190782745600,14264815236056985600,2795903786354347468800,629078351928420506112000,161044058093696572354560000,46541732789077953723039744000", "code": "\nA082491_list, m, x = [], 1, 1\nfor n in range(10*2):\n....x, m = x*n**2 + m, -(n+1)*m\n....A082491_list.append(x) \n"}
{"sequence_id": "A082511", "text": "a(n) = 3^n mod 2n.", "sequence": "1,1,3,1,3,9,3,1,9,9,3,9,3,9,27,1,3,9,3,1,27,9,3,33,43,9,27,25,3,9,3,1,27,9,47,9,3,9,27,1,3,57,3,81,63,9,3,33,31,49,27,81,3,81,67,65,27,9,3,81,3,9,27,1,113,69,3,81,27,109,3,81,3,9,57,81,75,105,3,1,81,9,3,57,73", "code": " for n in range(1, 80): print(pow(3, n, 2*n), end=\" \") \n"}
{"sequence_id": "A082540", "text": "Number of ordered quadruples (a,b,c,d) with gcd(a,b,c,d)=1 (1 <= {a,b,c,d} <= n).", "sequence": "1,15,79,239,607,1199,2303,3823,6223,9279,13919,19183,27007,35743,47519,60735,78719,97103,122447,148527,181839,216959,262543,306863,365343,423855,495855,569055,661679,748527,862047,972191,1104831,1237247", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A082540(n):\n    if n == 0:\n        return 0\n    c, j = 1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A082540(k1)\n        j, k1 = j2, n//j2\n    return n*(n**3-1)-c+j \n"}
{"sequence_id": "A082544", "text": "Number of ordered quintuples (a,b,c,d,e) with gcd(a,b,c,d,e)=1 (1<= {a,b,c,d,e} <= n).", "sequence": "1,31,241,991,3091,7501,16531,31711,57781,96601,157651,240031,362491,519961,739201,1012441,1383721,1822711,2409241,3091441,3966301,4974751,6257461,7680781,9481681,11474941,13916191,16610371,19911151,23435191", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A082544(n):\n    if n == 0:\n        return 0\n    c, j = 1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A082544(k1)\n        j, k1 = j2, n//j2\n    return n*(n**4-1)-c+j \n"}
{"sequence_id": "A082553", "text": "Number of sets of distinct positive integers whose geometric mean is an integer, the largest integer of a set is n.", "sequence": "1,1,1,3,1,1,1,3,7,1,1,7,1,1,1,9,1,29,1,3,1,1,1,31,15,1,87,3,1,1,1,115,1,1,1,257,1,1,1,17,1,1,1,3,21,1,1,519,23,141,1,3,1,847,1,19,1,1,1,215,1,1,27,1557,1,1,1,3,1,1,1,2617,1,1,3125,3,1,1", "code": "\nfrom sympy import factorint, factorial\ndef make_product(p, n, k):\n    '''\n    Find all k-element subsets of {1, ..., n} whose product is p.\n    Returns: list of lists\n    '''\n    if n**k < p:\n        return []\n    if k == 1:\n        return [[p]]\n    if p%n == 0:\n        l = [s + [n] for s in make_product(p//n, n - 1, k - 1)]\n    else:\n        l = []\n    return l + make_product(p, n - 1, k)\ndef integral_geometric_mean(n):\n    '''\n    Find all subsets of {1, ..., n} that contain n and whose\n    geometric mean is an integer.\n    '''\n    f = factorial(n)\n    l = [[n]]\n    \n    c = 1\n    for p in factorint(n):\n        c *= p\n    \n    for gm in range(c, n, c):\n        k = 2\n        while not (gm**k%n == 0):\n            k += 1\n        while gm**k <= f:\n            l += [s + [n] for s in make_product(gm**k//n, n - 1, k - 1)]\n            k += 1\n    return l\ndef A082553(n):\n    return len(integral_geometric_mean(n)) \n"}
{"sequence_id": "A082588", "text": "a(1) = 1, a(n) = Sum_{d | n and d < n} a(d)^2 for n > 1.", "sequence": "1,1,1,2,1,3,1,6,2,3,1,16,1,3,3,42,1,16,1,16,3,3,1,308,2,3,6,16,1,31,1,1806,3,3,3,532,1,3,3,308,1,31,1,16,16,3,1,96936,2,16,3,16,1,308,3,308,3,3,1,1508,1,3,16,3263442,3,31,1,16,3,31,1,378456", "code": "\na = [1]\nfor n in range(2, 10001):\n   a.append(sum(a[d-1]**2 for d in range(1, n) if n%d == 0))\nprint(a)\n\n"}
{"sequence_id": "A082617", "text": "a(1) = 1, then squarefree palindromes such that a(n+1) = p*a(n) where p is a prime not dividing any previous term.", "sequence": "1,2,6,66,858,6006,222222,22444422,204042240402,2010020110200102,263312634436213362,205221063132933339231360122502", "code": "\nfrom sympy import factorint, nextprime\nA082617_list, a = [1], 1\nfor _ in range(10):\n....p = 2\n....b = p*a\n....bs = str(b)\n....while bs != bs[::-1] or max(factorint(b).values()) > 1:\n........p = nextprime(p)\n........b = p*a\n........bs = str(b)\n....A082617_list.append(b)\n....a = b \n"}
{"sequence_id": "A082646", "text": "Primes whose decimal expansions contain equal numbers of each of their digits.", "sequence": "2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,103,107,109,127,137,139,149,157,163,167,173,179,193,197,239,241,251,257,263,269,271,281,283,293,307,317,347,349,359,367,379,389,397,401", "code": "\nfrom sympy import prime\nA082646_list = []\nfor i in range(1,10**5):\n    p = str(prime(i))\n    h = [p.count(d) for d in '0123456789' if d in p]\n    if min(h) == max(h):\n        A082646_list.append(int(p)) \n"}
{"sequence_id": "A082721", "text": "There exist no palindromic hexagonals of length n.", "sequence": "3,8,9,12,22,24,27,30,36,38,40", "code": "\ndef ispal(n): s = str(n); return s == s[::-1]\ndef hexpals(limit):\n  yield from (k*(2*k-1) for k in range(limit+1) if ispal(k*(2*k-1)))\ndef aupto(limit):\n  lengths = set(range(1, limit+1))\n  for h in hexpals(10**limit):\n    if len(lengths) == 0: return\n    lh, minlen = len(str(h)), min(lengths)\n    if lh > minlen: print(minlen, \"in A082721\"); lengths.discard(minlen)\n    if lh in lengths: lengths.discard(lh); print(\"... discarding\", lh)\naupto(14) \n"}
{"sequence_id": "A082792", "text": "Smallest multiple of n beginning with 3.", "sequence": "3,30,3,32,30,30,35,32,36,30,33,36,39,308,30,32,34,36,38,300,315,308,322,312,300,312,324,308,319,30,31,32,33,34,35,36,37,38,39,320,328,336,301,308,315,322,329,336,343,300,306,312,318,324,330,336,342,348,354", "code": "\ndef a(n):\n  kn = n\n  while str(kn)[0] != '3': kn += n\n  return kn\nprint([a(n) for n in range(1, 60)]) \n"}
{"sequence_id": "A082794", "text": "Smallest multiple of n beginning with 4.", "sequence": "4,4,42,4,40,42,42,40,45,40,44,48,403,42,45,48,408,414,418,40,42,44,46,48,400,416,405,420,406,420,403,416,429,408,420,432,407,418,429,40,41,42,43,44,45,46,47,48,49,400,408,416,424,432,440,448,456,406,413", "code": "\ndef a(n):\n  kn = n\n  while str(kn)[0] != '4': kn += n\n  return kn\nprint([a(n) for n in range(1, 57)]) \n"}
{"sequence_id": "A082796", "text": "Smallest multiple of n beginning with 6.", "sequence": "6,6,6,60,60,6,63,64,63,60,66,60,65,602,60,64,68,612,608,60,63,66,69,600,600,624,621,616,609,60,62,64,66,68,630,612,629,608,624,600,615,630,602,616,630,644,611,624,637,600,612,624,636,648,605,616,627,638", "code": "\ndef a(n):\n    m = n\n    while str(m)[0] != '6': m += n\n    return m\nprint([a(n) for n in range(1, 59)]) \n"}
{"sequence_id": "A082798", "text": "Smallest multiple of n beginning with 8.", "sequence": "8,8,81,8,80,84,84,8,81,80,88,84,806,84,810,80,85,810,817,80,84,88,805,816,800,806,81,84,87,810,806,800,825,816,805,828,814,836,819,80,82,84,86,88,810,828,846,816,833,800,816,832,848,810,825,840,855,812", "code": "\ndef a(n):\n    m = n\n    while str(m)[0] != '8': m += n\n    return m\nprint([a(n) for n in range(1, 59)]) \n"}
{"sequence_id": "A082806", "text": "Palindromes which are prime and the sum of the digits is also prime.", "sequence": "2,3,5,7,11,101,131,151,191,313,353,373,757,797,919,10301,10501,11311,12721,13331,13931,14341,14741,15551,16361,16561,18181,19391,19991,30103,30703,31513,32323,33533,34543,35153,35353,35753,36563,38183", "code": "\nfrom sympy import isprime\nA082806 = sorted([n for n in chain(map(lambda x:int(str(x)+str(x)[::-1]),range(1,10**5)),map(lambda x:int(str(x)+str(x)[-2::-1]), range(1,10**5))) if isprime(n) and isprime(sum([int(d) for d in str(n)]))])\n\n"}
{"sequence_id": "A082916", "text": "Numbers k such that k and binomial(2*k, k) are relatively prime.", "sequence": "0,1,3,5,7,9,11,13,17,19,23,25,27,29,31,37,39,41,43,47,49,53,55,59,61,67,71,73,79,81,83,89,93,97,101,103,107,109,111,113,119,121,125,127,131,137,139,149,151,155,157,161,163,167,169,173,179,181,185,191,193,197", "code": "\nfrom __future__ import division\nfrom fractions import gcd\nA082916_list, b = [], 1\nfor n in range(10**5):\n    if gcd(n,b) == 1:\n        A082916_list.append(n)\n    b = b*(4*n+2)//(n+1) \n"}
{"sequence_id": "A082997", "text": "a(n) = card{ x <= n : omega(x) = 2 }.", "sequence": "0,0,0,0,0,1,1,1,1,2,2,3,3,4,5,5,5,6,6,7,8,9,9,10,10,11,11,12,12,12,12,12,13,14,15,16,16,17,18,19,19,19,19,20,21,22,22,23,23,24,25,26,26,27,28,29,30,31,31,31,31,32,33,33,34,34,34,35,36,36,36,37,37,38,39,40,41", "code": "\nfrom sympy import factorint\nfrom itertools import accumulate\ndef cond(n): return int(len(factorint(n))==2)\ndef aupto(nn): return list(accumulate(map(cond, range(1, nn+1))))\nprint(aupto(77)) \n"}
{"sequence_id": "A082998", "text": "a(n) = card{ x <= n : omega(x) = 3 }.", "sequence": "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,10", "code": "\nfrom sympy import factorint\nfrom itertools import accumulate\ndef cond(n): return int(len(factorint(n))==3)\ndef aupto(nn): return list(accumulate(map(cond, range(1, nn+1))))\nprint(aupto(105)) \n"}
{"sequence_id": "A083093", "text": "Triangle formed by reading Pascal's triangle (A007318) mod 3.", "sequence": "1,1,1,1,2,1,1,0,0,1,1,1,0,1,1,1,2,1,1,2,1,1,0,0,2,0,0,1,1,1,0,2,2,0,1,1,1,2,1,2,1,2,1,2,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,2,1,0,0,0,0,0,0,1,2,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,0,1,1", "code": "\nfrom sympy import binomial\ndef T(n, k):\n    return binomial(n, k) % 3\nfor n in range(21): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A083178", "text": "Numbers with a digit sum of n and a maximum product of digits. In case of two identical products choose the largest number.", "sequence": "1,2,3,22,32,33,322,332,333,3322,3332,3333,33322,33332,33333,333322,333332,333333,3333322,3333332,3333333,33333322,33333332,33333333,333333322,333333332,333333333,3333333322,3333333332,3333333333", "code": "\nfrom __future__ import division\ndef A083178(n):\n    return 1 if n == 1 else (2*10**((n+2)//3)+(63*(n%3)**2-129*(n%3)-2))//6 \n"}
{"sequence_id": "A083207", "text": "Zumkeller or integer-perfect numbers: numbers n whose divisors can be partitioned into two disjoint sets with equal sum.", "sequence": "6,12,20,24,28,30,40,42,48,54,56,60,66,70,78,80,84,88,90,96,102,104,108,112,114,120,126,132,138,140,150,156,160,168,174,176,180,186,192,198,204,208,210,216,220,222,224,228,234,240,246,252,258,260,264,270,272", "code": "\nfrom sympy import divisors\nimport numpy as np\nA083207 = []\nfor n in range(2,10**3):\n    d = divisors(n)\n    s = sum(d)\n    if not s % 2 and 2*n <= s:\n        d.remove(n)\n        s2, ld = int(s/2-n), len(d)\n        z = np.zeros((ld+1,s2+1),dtype=int)\n        for i in range(1,ld+1):\n            y = min(d[i-1],s2+1)\n            z[i,range(y)] = z[i-1,range(y)]\n            z[i,range(y,s2+1)] = np.maximum(z[i-1,range(y,s2+1)],z[i-1,range(0,s2+1-y)]+y)\n            if z[i,s2] == s2:\n                A083207.append(n)\n                break\n\n"}
{"sequence_id": "A083286", "text": "Decimal expansion of K(3), a constant related to the Josephus problem.", "sequence": "1,6,2,2,2,7,0,5,0,2,8,8,4,7,6,7,3,1,5,9,5,6,9,5,0,9,8,2,8,9,9,3,2,4,1,1,3,0,6,6,1,0,5,5,6,2,3,1,3,0,3,7,4,3,2,1,8,5,4,4,3,3,8,7,3,7,8,4,3,3,9,9,9,7,2,7,4,8,4,4,7,6,3,8,3,6,1,6,5,3,9,8,3,3,2,3,3,4,1,1,0,0", "code": "\nd, a, n, nmax = 3, 0, 0, 150000\nwhile n < nmax:\n    n, a = n+1, (a*d)//(d-1)+1\nnom, den, pos = a*(d-1)**n, d**n, 0\nwhile pos < 20000:\n    dig, nom, pos = nom//den, (nom%den)*10, pos+1\n    print(pos,dig) \n"}
{"sequence_id": "A083289", "text": "Least k such that 10^n+k is a brilliant number (cf. A078972).", "sequence": "3,0,21,3,201,13,18081,43,140049,81,600009,147,6000009,73,380000361,3,1400000049,831,14000000049,49,380000000361,987,600000000009,691,78000000001521,183,740000000001369,4153,6200000000000961,279", "code": "\nfrom sympy import nextprime, factorint\ndef A083289(n):\n    a, b = divmod(n,2)\n    c, d = 10**n, 10**a\n    if b == 0: return nextprime(d)**2-c\n    k = 0\n    while True:\n        fs = factorint(c+k,multiple=True)\n        if len(fs) == 2 and min(fs) >= d:\n            return k\n        k += 1 \n"}
{"sequence_id": "A083652", "text": "Sum of lengths of binary expansions of 0 through n.", "sequence": "1,2,4,6,9,12,15,18,22,26,30,34,38,42,46,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,136,142,148,154,160,166,172,178,184,190,196,202,208,214,220,226,232,238,244,250,256,262,268,274,280,286,292", "code": "\ndef A083652(n):\n    s, i, z = 1, n, 1\n    while 0 <= i: s += i; i -= z; z += z\n    return s\nprint([A083652(n) for n in range(0, 59)]) \n"}
{"sequence_id": "A083687", "text": "Numerator of B(2n)*H(2n)/n*(-1)^(n+1) where B(k) is the k-th Bernoulli number and H(k) the k-th harmonic number.", "sequence": "1,5,7,761,671,4572347,1171733,518413759,32956355893,1949885751497,21495895979,63715389517501781,22630025105469577,36899945775958445129,517210776697519633301437,4518133367201930332907311663", "code": "\nfrom sympy import bernoulli, harmonic, numer\ndef a(n):\n    return numer(bernoulli(2 * n) * harmonic(2 * n) * (-1)**(n + 1) / n)\n[a(n) for n in range(1, 31)]  \n"}
{"sequence_id": "A083688", "text": "Denominator of B(2n)*H(2n)/n where B(k) is the k-th Bernoulli number and H(k) the k-th harmonic number.", "sequence": "4,144,360,33600,15120,34927200,2162160,172972800,1543782240,10242872640,10346336,2338727174784,53542288800,4818805992000,3228118134040800,1178332991611776000,78765574305600,12256711017694416000,2914326249307200,3205758874237920000,358462128664785600", "code": "\nfrom sympy import bernoulli, harmonic\ndef a(n): return (bernoulli(2*n) * harmonic(2*n) / n).denominator()\nprint([a(n) for n in range(1, 22)]) \n"}
{"sequence_id": "A083705", "text": "a(n) = 2*a(n-1) - 1 with a(0) = 10.", "sequence": "10,19,37,73,145,289,577,1153,2305,4609,9217,18433,36865,73729,147457,294913,589825,1179649,2359297,4718593,9437185,18874369,37748737,75497473,150994945,301989889,603979777,1207959553,2415919105,4831838209,9663676417,19327352833", "code": "\nfrom itertools import accumulate\ndef f(an, _): return 2*an - 1\nprint(list(accumulate([10]*32, f))) \n"}
{"sequence_id": "A083833", "text": "Palindromes p such that 5p + 1 is also a palindrome.", "sequence": "1,2,22,121,131,222,2222,12021,12121,13031,13131,22222,222222,1202021,1203021,1212121,1213121,1302031,1303031,1312131,1313131,2222222,22222222,120202021,120212021,120303021,120313021,121202121,121212121", "code": "\nfrom itertools import product\ndef ispal(n): s = str(n); return s == s[::-1]\ndef pals(d, base=10): \n    digits = \"\".join(str(i) for i in range(base))\n    for p in product(digits, repeat=d//2):\n        if d > 1 and p[0] == \"0\": continue\n        left = \"\".join(p); right = left[::-1]\n        for mid in [[\"\"], digits][d%2]:\n            t = int(left + mid + right)\n            if t > 0: yield t\ndef ok(pal): return ispal(5*pal+1)\nprint([p for d in range(1, 10) for p in pals(d) if ok(p)]) \n"}
{"sequence_id": "A083834", "text": "Palindromes of the form 5p + 1 where p is also a palindrome. Palindromes arising in A083833.", "sequence": "6,11,111,606,656,1111,11111,60106,60606,65156,65656,111111,1111111,6010106,6015106,6060606,6065606,6510156,6515156,6560656,6565656,11111111,111111111,601010106,601060106,601515106,601565106,606010606", "code": "\nfrom itertools import product\ndef ispal(n): s = str(n); return s == s[::-1]\ndef pals(d, base=10): \n    digits = \"\".join(str(i) for i in range(base))\n    for p in product(digits, repeat=d//2):\n        if d > 1 and p[0] == \"0\": continue\n        left = \"\".join(p); right = left[::-1]\n        for mid in [[\"\"], digits][d%2]:\n            t = int(left + mid + right)\n            if t > 0: yield t\ndef ok(pal): return ispal(5*pal+1)\nprint([5*p+1 for d in range(1, 10) for p in pals(d) if ok(p)]) \n"}
{"sequence_id": "A083969", "text": "Numbers n such that 2.n.3.n.5.n.7.n.11 is prime (dot means concatenation).", "sequence": "4,18,33,42,43,57,73,76,78,87,91,93,97,102,112,114,120,141,151,177,186,193,196,219,261,267,276,280,300,307,318,322,342,352,364,366,402,435,438,445,457,462,468,484,511,580,582,633,646,651,679,706,745,774,783", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n  n, alst = 1, []\n  while len(alst) < terms:\n    s = str(n)\n    t = int('2'+s+'3'+s+'5'+s+'7'+s+'11')\n    if isprime(t): alst.append(n)\n    n += 1\n  return alst\nprint(aupton(55)) \n"}
{"sequence_id": "A084002", "text": "a(1) = 9; then numbers such that the concatenation a(n)a(n-1)...a(2)a(1)a(2)...a(n-1)a(n) is a prime for n>1.", "sequence": "9,1,7,17,9,9,1,51,29,21,49,107,37,63,329,69,93,1,53,9,79,219,267,59,457,189,599,277,743,67,59,379,33,231,83,381,451,11,451,791,289,323,87,241,447,189,189,1107,903,393,219,629,931,797,49,261,233,93,1239,663", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n    alst, astr = [9], \"9\"\n    for n in range(2, terms+1):\n        an = 1\n        while not isprime(int(str(an) + astr + str(an))): an += 1\n        alst.append(an); astr = str(an) + astr + str(an)\n    return alst\nprint(aupton(60)) \n"}
{"sequence_id": "A084011", "text": "Digit reversal of 11*n, divided by 11.", "sequence": "1,2,3,4,5,6,7,8,9,1,11,21,31,41,51,61,71,81,82,2,12,22,32,42,52,62,72,73,83,3,13,23,33,43,53,63,64,74,84,4,14,24,34,44,54,55,65,75,85,5,15,25,35,45,46,56,66,76,86,6,16,26,36,37,47,57,67,77,87,7,17,27,28,38,48,58", "code": "\ndef A084011(n):\n     return int(str(11*n)[::-1])/11 \n"}
{"sequence_id": "A084019", "text": "a(n) = 9's complement of n-th palindrome (A002113).", "sequence": "9,8,7,6,5,4,3,2,1,0,88,77,66,55,44,33,22,11,0,898,888,878,868,858,848,838,828,818,808,797,787,777,767,757,747,737,727,717,707,696,686,676,666,656,646,636,626,616", "code": "\n\ndef a(n):\n    return 10**len(str(n))-n-1\ni=0\nj=1\nwhile j<=250:\n    if i==int(str(i)[::-1]):\n        print(str(j)+\" \"+str(a(i)))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A084370", "text": "Convolution of odd primes with themselves.", "sequence": "9,30,67,136,237,386,587,852,1213,1658,2227,2932,3765,4766,5939,7324,8917,10746,12851,15200,17845,20794,24083,27748,31785,36250,41107,46376,52113,58350,65111,72444,80353,88858,98003,107744,118201,129410,141355,154080", "code": "\nfrom numpy import convolve\nfrom sympy import prime, primerange\ndef aupton(terms):\n    p = list(primerange(3, prime(terms+1)+1))\n    return list(convolve(p, p))[:terms]\nprint(aupton(40)) \n"}
{"sequence_id": "A084473", "text": "Replace 0 with 0000 in binary representation of n.", "sequence": "1,16,3,256,33,48,7,4096,513,528,67,768,97,112,15,65536,8193,8208,1027,8448,1057,1072,135,12288,1537,1552,195,1792,225,240,31,1048576,131073,131088,16387,131328,16417,16432,2055,135168,16897,16912,2115,17152,2145", "code": "\ndef a(n): return int(bin(n)[2:].replace('0', '0000'), 2)\nprint([a(n) for n in range(1, 46)]) \n"}
{"sequence_id": "A084558", "text": "a(0) = 0; for n >= 1: a(n) = largest m such that n >= m!.", "sequence": "0,1,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5", "code": "\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a(n): return 0 if n==0 else len(str(a007623(n)))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A084670", "text": "Numbers k such that concatenation of prime(k) and k is prime.", "sequence": "3,9,19,21,37,63,77,81,87,107,121,133,177,201,211,213,217,281,293,303,321,327,329,333,351,391,393,439,481,503,507,519,543,547,551,561,579,581,599,621,639,657,663,667,711,721,727,743,793,813,819,827,829,831,837", "code": "\nfrom sympy import isprime, prime\ndef aupto(lim):\n  return [k for k in range(1, lim+1) if isprime(int(str(prime(k))+str(k)))]\nprint(aupto(837)) \n"}
{"sequence_id": "A084832", "text": "Numbers k such that 2*R_k - 1 is prime, where R_k = 11...1 is the repunit (A002275) of length k.", "sequence": "4,18,100,121,244,546,631,1494,2566,8088", "code": "\nfrom sympy import isprime\ndef afind(limit):\n  n, twoRn = 1, 2\n  for n in range(1, limit+1):\n    if isprime(twoRn-1): print(n, end=\", \")\n    twoRn = 10*twoRn + 2\nafind(700) \n"}
{"sequence_id": "A084844", "text": "Denominators of the continued fraction n + 1/(n + 1/...) [n times].", "sequence": "1,2,10,72,701,8658,129949,2298912,46866034,1082120050,27916772489,795910114440,24851643870041,843458630403298,30918112619119426,1217359297034666112,51240457936070359069,2296067756927144738850,109127748348241605689981", "code": "\nfrom sympy import fibonacci\ndef a(n):\n    return fibonacci(n, n)\nprint([a(n) for n in range(1, 31)]) \n"}
{"sequence_id": "A084845", "text": "Numerators of the continued fraction n+1/(n+1/...) [n times].", "sequence": "1,5,33,305,3640,53353,927843,18674305,426938895,10928351501,309601751184,9616792908241,324971855514293,11868363584907985,465823816409224245,19553538801258341377,874091571490181406680", "code": "\nfrom sympy import fibonacci\ndef a117715(n, m): return 0 if n==0 else fibonacci(n, m)\ndef a(n): return a117715(n + 1, n)\nprint([a(n) for n in range(1, 31)]) \n"}
{"sequence_id": "A084891", "text": "Multiples of 2, 3, 5, or 7, but not 7-smooth.", "sequence": "22,26,33,34,38,39,44,46,51,52,55,57,58,62,65,66,68,69,74,76,77,78,82,85,86,87,88,91,92,93,94,95,99,102,104,106,110,111,114,115,116,117,118,119,122,123,124,129,130,132,133,134,136,138,141,142,145,146", "code": "\nfrom sympy import primefactors\ndef ok(n):\n    pf = set(primefactors(n))\n    return pf & {2, 3, 5, 7} and pf - {2, 3, 5, 7}\nprint(list(filter(ok, range(147)))) \n"}
{"sequence_id": "A084937", "text": "Smallest number which is coprime to the last two predecessors and has not yet appeared; a(1)=1, a(2)=2.", "sequence": "1,2,3,5,4,7,9,8,11,13,6,17,19,10,21,23,16,15,29,14,25,27,22,31,35,12,37,41,18,43,47,20,33,49,26,45,53,28,39,55,32,51,59,38,61,63,34,65,57,44,67,69,40,71,73,24,77,79,30,83,89,36,85,91,46,75,97,52,81", "code": "\nfrom fractions import gcd\nA084937_list, l1, l2, s, b = [1,2], 2, 1, 3, set()\nfor _ in range(10**3):\n    i = s\n    while True:\n        if not i in b and gcd(i,l1) == 1 and gcd(i,l2) == 1:\n            A084937_list.append(i)\n            l2, l1 = l1, i\n            b.add(i)\n            while s in b:\n                b.remove(s)\n                s += 1\n            break\n        i += 1 \n"}
{"sequence_id": "A085154", "text": "a(n+1) = smallest number >a(n) having more prime factors than a(n), with or without repetitions; a(1)=1.", "sequence": "1,2,4,6,8,10,12,16,18,24,30,32,33,36,42,48,60,64,65,66,72,78,80,84,96,102,104,105,108,110,112,114,120,128,129,130,132,144,150,160,165,168,192,195,196,198,200,204,208,210,216,220,224,228,240,256,258,260", "code": "\nfrom sympy import factorint\ndef aupton(terms):\n    alst, wn, Wn, k = [1], 0, 0, 1\n    while len(alst) < terms:\n        while True:\n            k += 1\n            pf = factorint(k, multiple=True)\n            wk, Wk = len(pf), len(set(pf))\n            if wk > wn or Wk > Wn:\n                break\n        alst.append(k)\n        wn, Wn = wk, Wk\n    return alst\nprint(aupton(58)) \n"}
{"sequence_id": "A085157", "text": "Quintuple factorials, 5-factorials, n!!!!!, n!5.", "sequence": "1,1,2,3,4,5,6,14,24,36,50,66,168,312,504,750,1056,2856,5616,9576,15000,22176,62832,129168,229824,375000,576576,1696464,3616704,6664896,11250000,17873856,54286848,119351232,226606464,393750000,643458816", "code": "\ndef A085157(n):\n    if n <= 0:\n        return 1\n    else:\n        return n*A085157(n-5)\nn = 0\nwhile n <= 40:\n    print(n,A085157(n))\n    n = n+1 \n"}
{"sequence_id": "A085300", "text": "a(n) is the least prime x such that when reversed it is a power of prime(n).", "sequence": "2,3,5,7,11,31,71,163,18258901387,90367894271,13,73,1861,344800741,34351783286302805384336021,940315563074788471,1886172359328147919771,14854831", "code": "\nfrom sympy import prime, isprime\ndef A085300(n):\n    p = prime(n)\n    q = p\n    while True:\n        m = int(str(q)[::-1])\n        if isprime(m):\n            return(m)\n        q *= p \n"}
{"sequence_id": "A085375", "text": "a(n) = binomial(2*n+1, n+1)*binomial(n+4, 4).", "sequence": "1,15,150,1225,8820,58212,360360,2123550,12033450,66050270,353068716,1845586470,9464546000,47738754000,237329805600,1164893795820,5653161067950,27157342385250,129275302348500,610315506350550,2859764086899720,13308425945529000", "code": "\nfrom __future__ import division\nA085375_list, b = [], 1\nfor n in range(501):\n    A085375_list.append(b)\n    b = b*2*(n+5)*(2*n+3)//((n+1)*(n+2)) \n"}
{"sequence_id": "A085410", "text": "Total number of parts in all partitions of n into relatively prime parts.", "sequence": "1,2,5,9,19,27,53,74,122,170,274,355,555,724,1043,1377,1964,2487,3497,4429,5993,7622,10205,12701,16831,20964,27166,33756,43452,53296,68134,83464,105086,128495,160803,195006,242811,293701,362026,436842,536103", "code": "\nfrom sympy import divisors, divisor_count, npartitions, mobius\ndef a006128(n): return sum([divisor_count(m)*npartitions(n - m) for m in range(1, n + 1)])\ndef a(n): return sum([mobius(n/d)*a006128(d) for d in divisors(n)]) \n"}
{"sequence_id": "A085513", "text": "Number of \"e\"s in n (in English).", "sequence": "1,1,0,2,0,1,0,2,1,1,1,3,2,2,2,2,2,4,3,3,1,2,1,3,1,2,1,3,2,2,0,1,0,2,0,1,0,2,1,1,0,1,0,2,0,1,0,2,1,1,0,1,0,2,0,1,0,2,1,1,0,1,0,2,0,1,0,2,1,1,2,3,2,4,2,3,2,4,3,3,1,2,1,3,1,2,1,3,2,2,1,2,1,3,1,2,1,3,2,2", "code": "\nfrom num2words import num2words\ndef A085513(n):\n    return num2words(n).count('e') \n"}
{"sequence_id": "A085647", "text": "Semiprimes whose prime factors p*q have an equal number of decimal digits and p is not equal to q.", "sequence": "6,10,14,15,21,35,143,187,209,221,247,253,299,319,323,341,377,391,403,407,437,451,473,481,493,517,527,533,551,559,583,589,611,629,649,667,671,689,697,703,713,731,737,767,779,781,793,799,803,817,851,869,871", "code": "\nfrom sympy import sieve\nA085647 = []\nfor n in range(3):\n....pr = list(sieve.primerange(10**n,10**(n+1)))\n....for i,p in enumerate(pr,start=1):\n........for q in pr[i:]:\n............A085647.append(p*q)\nA085647 = sorted(A085647)\n\n"}
{"sequence_id": "A085763", "text": "Number of palindromes between n and 2n (inclusive).", "sequence": "2,3,4,5,5,5,4,3,2,1,2,1,1,1,1,1,2,2,2,2,2,3,2,2,2,2,2,3,3,3,3,3,4,3,3,3,3,3,4,4,4,4,4,5,4,4,4,4,4,5,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,8,7,7,7,7,8,8,8,8,8,9,9,8,8,8,9,9,9,9,9,10,10,10,9,9,10,10,10,10,10,11,11,11,11", "code": "\ndef ispal(s): return s == s[::-1]\ndef a(n): return sum(ispal(str(i)) for i in range(n, 2*n+1))\nprint([a(n) for n in range(1, 100)]) \n"}
{"sequence_id": "A085764", "text": "Least integer m such that between m and 2m there are n palindromes.", "sequence": "10,1,2,3,4,51,61,66,76,86,96,111,121,131,141,157,167,177,187,197,202,212,222,232,242,258,268,278,288,298,303,313,323,333,343,359,369,379,389,399,404,414,424,434,444,460,470,480,490,500,501,5101,5201,5301", "code": "\ndef ispal(n): s = str(n); return s == s[::-1]\ndef a(n):\n    m, cm = 1, 2\n    while cm != n:\n        cm = cm - ispal(m) + ispal(2*m+1) + ispal(2*m+2)\n        m += 1\n    return m\nprint([a(n) for n in range(1, 55)]) \n"}
{"sequence_id": "A085807", "text": "Permanent of the symmetric n X n matrix A defined by A[i,j] = |i-j| for 1 <= i,j <= n.", "sequence": "1,0,1,4,64,1152,34372,1335008,69599744,4577345152,374491314176,37154032517376,4402467119882240,613680867638476800,99443966100565999872,18534733913629064343552,3937496200758879526977536,945776134421421651222708224,255043190756805184245158084608", "code": "\nfrom sympy import Matrix\ndef A085807(n): return Matrix(n,n,[abs(j-k) for j in range(n) for k in range(n)]).per() \n"}
{"sequence_id": "A085831", "text": "a(n) = Sum_{k=1..2^n} d(k) where d(n) = number of divisors of n (A000005).", "sequence": "1,3,8,20,50,119,280,645,1466,3280,7262,15937,34720,75108,161552,345785,736974,1564762,3311206,6985780,14698342,30850276,64607782,135030018,281689074,586636098,1219788256,2532608855,5251282902,10874696106,22493653324,46475828418", "code": "\nfrom math import isqrt\ndef A085831(n): return (lambda m, r: 2*sum(r//k for k in range(1, m+1))-m*m)(isqrt(2**n),2**n) \n"}
{"sequence_id": "A085844", "text": "Numbers equal to a permutation (or rearrangement) of the digits of the sum of their proper divisors. Rearrangements which cause leading zeros are excluded.", "sequence": "6,28,411,496,604,1305,3664,4086,4672,4896,5046,7785,8128,8739,9331,14535,16012,18342,18585,19648,20634,21534,21628,22365,25911,27568,28108,29160,29188,31185,32091,32271,34956,35898,35925,36172,37698,40182,54945,56970", "code": "\nfrom sympy import divisors\ndef ok(n):\n    divs = divisors(n)[:-1]\n    return sorted(str(n)) == sorted(str(sum(divs)))\nprint(list(filter(ok, range(1, 57000)))) \n"}
{"sequence_id": "A085927", "text": "a(n) is the digitwise absolute difference between the n-th palindrome and its 9's complement.", "sequence": "7,5,3,1,1,3,5,7,9,77,55,33,11,11,33,55,77,99,797,777,757,737,717,717,737,757,777,797,595,575,555,535,515,515,535,555,575,595,393,373,353,333,313,313,333,353,373,393,191,171,151,131,111,111,131,151,171,191", "code": "\nfrom sympy import isprime\nfrom itertools import count, product\ndef f(s): return int(\"\".join(str(abs(9 - 2*int(c))) for c in s))\ndef pals(base=10): \n    digits = \"\".join(str(i) for i in range(base))\n    for d in count(1):\n        for p in product(digits, repeat=d//2):\n            if d > 1 and p[0] == \"0\": continue\n            left = \"\".join(p); right = left[::-1]\n            for mid in [[\"\"], digits][d%2]:\n                t = left + mid + right\n                if t != '0': yield t\ndef aupton(nn): p = pals(); return [f(next(p)) for i in range(nn)]\nprint(aupton(58)) \n"}
{"sequence_id": "A086204", "text": "Decimal equivalents of strings in A086884.", "sequence": "2,2,47,151,4001,4001,100207,41532851,447045215857,282607273285049", "code": "\nfrom sympy import isprime\ndef conv(s, b): return sum(b**k for k, bk in enumerate(s[::-1]) if bk=='1')\ndef ok(s, n): return all(isprime(conv(s, b)) for b in range(2, n+1))\ndef a(n):\n    if n < 4: return 2\n    k = 3\n    while not ok(bin(k)[2:], n): k += 2\n    return int(bin(k)[2:], 2)\nprint([a(n) for n in range(2, 9)]) \n"}
{"sequence_id": "A086320", "text": "a(n) is the depth of the prime tree formed when 4p +- 3 is applied to the n-th prime and repeatedly to any primes generated from the n-th prime via this process.", "sequence": "11,1,6,3,10,1,3,6,5,3,2,3,2,1,9,1,6,3,3,2,1,5,1,4,1,3,2,3,4,2,1,3,1,1,3,2,3,1,1,1,5,2,8,3,1,1,1,1,2,3,5,2,2,1,3,2,1,2,1,1,4,1,2,1,4,1,5,1,1,2,3,2,3,3,1,1,2,1,2,1,1,1,2,1,3,1,1,4,2,1,5,4,2,1,3,1,2,2,6,4,1,1,1,2", "code": "\nfrom functools import cache\nfrom sympy import isprime, prime\n@cache\ndef b(p): return 1 + max(b(4*p+3), b(4*p-3)) if isprime(p) else 0\ndef a(n): return b(prime(n))\nprint([a(n) for n in range(1, 105)]) \n"}
{"sequence_id": "A086399", "text": "Even digits of Pi.", "sequence": "4,2,6,8,2,8,4,6,2,6,4,8,2,0,2,8,8,4,6,0,8,2,0,4,4,4,2,0,8,6,4,0,6,2,8,6,2,0,8,8,6,2,8,0,4,8,2,4,2,0,6,8,2,4,8,0,8,6,2,8,2,0,6,6,4,0,8,4,4,6,0,0,8,2,2,2,4,0,8,2,8,4,8,4,0,2,8,4,0,2,0,8,2,0,6,4,4,6,2,2,4,8,4,0,8", "code": "\nfrom sympy import S\ndef auptodigs(lim):\n  return [int(d) for d in str(S.Pi.n(lim+1)) if d not in \".13579\"]\nprint(auptodigs(197)) \n"}
{"sequence_id": "A086405", "text": "Row T(n,3) of number array A086404.", "sequence": "1,4,18,84,396,1872,8856,41904,198288,938304,4440096,21010752,99423936,470479104,2226331008,10535111424,49852682496,235905426432,1116316463616,5282466223104,24996898556928,118286594002944", "code": "\ndef a(n, adict={0:1, 1:4}):\n    if n in adict:\n        return adict[n]\n    adict[n]=6*a(n-1)-6*a(n-2)\n    return adict[n] \n"}
{"sequence_id": "A086491", "text": "Group the natural numbers such that the n-th group sum is divisible by prime(n): (1, 2, 3), (4, 5), (6, 7, 8, 9), (10, 11), (12, 13, 14, 15, 16, 17, 18, 19, 20, 21), ... Sequence contains the sum of the terms in the n-th group.", "sequence": "6,9,30,21,165,234,238,38,690,522,2325,4107,4018,4988,564,9540,708,3172,9380,21726,8395,14615,1245,25365,11155,8585,1545,19795,55154,44070,78486,64714,1781,21684,102661,75047,14287,81011,190380,153624,249526,83079", "code": "\nfrom itertools import count\nfrom sympy import prime, primerange\ndef aupton(terms):\n    alst, naturals = [], count(1)\n    for p in primerange(1, prime(terms)+1):\n        s = next(naturals)\n        while s%p: s += next(naturals)\n        alst.append(s)\n    return alst\nprint(aupton(42)) \n"}
{"sequence_id": "A086492", "text": "Group the natural numbers such that the n-th group sum is divisible by prime(n): (1, 2, 3), (4, 5), (6, 7, 8, 9), (10, 11), (12, 13, 14, 15, 16, 17, 18, 19, 20, 21), ... Sequence contains the sum of the terms in the n-th group}/prime(n): a(n) = A086491(n)/prime(n).", "sequence": "3,3,6,3,15,18,14,2,30,18,75,111,98,116,12,180,12,52,140,306,115,185,15,285,115,85,15,185,506,390,618,494,13,156,689,497,91,497,1140,888,1394,459,1161,950,1730,693,1953,693,189,252,630,693,2387,33,1419,33,1419", "code": "\nfrom itertools import count\nfrom sympy import prime, primerange\ndef aupton(terms):\n    alst, naturals = [], count(1)\n    for p in primerange(1, prime(terms)+1):\n        s = next(naturals)\n        while s%p: s += next(naturals)\n        alst.append(s//p)\n    return alst\nprint(aupton(57)) \n"}
{"sequence_id": "A086493", "text": "Group the natural numbers such that the n-th group sum is divisible by prime(n): (1, 2, 3), (4, 5), (6, 7, 8, 9), (10, 11), (12, 13, 14, 15, 16, 17, 18, 19, 20, 21), ... Sequence contains the first term of every group.", "sequence": "1,4,6,10,12,22,31,38,39,54,63,93,130,158,187,190,235,238,251,286,354,377,414,417,474,497,514,517,554,646,711,814,890,892,916,1022,1093,1106,1177,1329,1440,1604,1655,1784,1884,2057,2123,2309,2375,2393,2417,2477", "code": "\nfrom itertools import count\nfrom sympy import prime, primerange\ndef aupton(terms):\n    alst, naturals = [], count(1)\n    for p in primerange(1, prime(terms)+1):\n        s = start = next(naturals)\n        while s%p: s += next(naturals)\n        alst.append(start)\n    return alst\nprint(aupton(52)) \n"}
{"sequence_id": "A086638", "text": "Numbers with no 11 or 000 in their binary expansion.", "sequence": "0,1,2,4,5,9,10,18,20,21,36,37,41,42,73,74,82,84,85,146,148,149,164,165,169,170,292,293,297,298,329,330,338,340,341,585,586,594,596,597,658,660,661,676,677,681,682,1170,1172,1173", "code": "\ndef A086638():\n    yield 0\n    for x in A086638():\n        if x & 3:\n            yield 2*x\n        if not (x & 1):\n            yield 2*x + 1\na = A086638(); print([next(a) for _ in range(100)])\n"}
{"sequence_id": "A086747", "text": "Baum-Sweet sequence: a(n) = 1 if binary representation of n contains no block of consecutive zeros of odd length; otherwise a(n) = 0.", "sequence": "0,1,0,1,1,0,0,1,0,1,0,0,1,0,0,1,1,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0", "code": "\nfrom itertools import groupby\ndef a(n): return int(all(len(list(g))%2 == 0 or k == '1' for k, g in groupby(bin(n)[2:])))\nprint([a(n) for n in range(105)]) \n"}
{"sequence_id": "A086884", "text": "Smallest string of 1's and 0's which is prime in every base from 2 to n.", "sequence": "10,10,101111,10010111,111110100001,111110100001,11000011101101111,10011110011011110110110011,110100000010101111110001010011001110001,1000000010000011110100010001000101001010110111001", "code": "\nfrom sympy import isprime\ndef conv(s, b): return sum(b**k for k, bk in enumerate(s[::-1]) if bk=='1')\ndef ok(s, n): return all(isprime(conv(s, b)) for b in range(2, n+1))\ndef a(n):\n    if n < 4: return 10\n    k = 3\n    while not ok(bin(k)[2:], n): k += 2\n    return int(bin(k)[2:])\nprint([a(n) for n in range(2, 9)]) \n"}
{"sequence_id": "A087062", "text": "Array T(n,k) = lunar product n*k (n >= 1, k >= 1) read by antidiagonals.", "sequence": "1,1,1,1,2,1,1,2,2,1,1,2,3,2,1,1,2,3,3,2,1,1,2,3,4,3,2,1,1,2,3,4,4,3,2,1,1,2,3,4,5,4,3,2,1,10,2,3,4,5,5,4,3,2,10,11,10,3,4,5,6,5,4,3,10,11,11,11,10,4,5,6,6,5,4,10,11,11,11,12,11,10,5,6,7,6,5,10,11,12,11,11,12,12", "code": "\ndef lunar_add(n,m):\n    sn, sm = str(n), str(m)\n    l = max(len(sn),len(sm))\n    return int(''.join(max(i,j) for i,j in zip(sn.rjust(l,'0'),sm.rjust(l,'0'))))\ndef lunar_mul(n,m):\n    sn, sm, y = str(n), str(m), 0\n    for i in range(len(sm)):\n        c = sm[-i-1]\n        y = lunar_add(y,int(''.join(min(j,c) for j in sn))*10**i)\n    return y \n"}
{"sequence_id": "A087116", "text": "Number of maximal groups of consecutive zeros in binary representation of n.", "sequence": "1,0,1,0,1,1,1,0,1,1,2,1,1,1,1,0,1,1,2,1,2,2,2,1,1,1,2,1,1,1,1,0,1,1,2,1,2,2,2,1,2,2,3,2,2,2,2,1,1,1,2,1,2,2,2,1,1,1,2,1,1,1,1,0,1,1,2,1,2,2,2,1,2,2,3,2,2,2,2,1,2,2,3,2,3,3,3,2,2,2,3,2,2,2,2,1,1,1,2,1,2,2", "code": "\ndef A087116(n):\n    return sum(1 for d in bin(n)[2:].split('1') if len(d)) \n"}
{"sequence_id": "A087141", "text": "Numbers divisible by the sum of their digits, but not by all their individual digits.", "sequence": "10,18,20,21,27,30,40,42,45,50,54,60,63,70,72,80,81,84,90,100,102,108,110,114,117,120,133,140,150,152,153,156,171,180,190,192,195,198,200,201,204,207,209,210,220,225,228,230,234,240,243,247,252,261,266,270", "code": "\ndef ok(n):\n    d = list(map(int, str(n)))\n    if n == 0 or n%sum(d): return False\n    return 0 in d or any(n%di for di in set(d))\nprint([k for k in range(271) if ok(k)]) \n"}
{"sequence_id": "A087207", "text": "A binary representation of the primes that divide a number, shown in decimal.", "sequence": "0,1,2,1,4,3,8,1,2,5,16,3,32,9,6,1,64,3,128,5,10,17,256,3,4,33,2,9,512,7,1024,1,18,65,12,3,2048,129,34,5,4096,11,8192,17,6,257,16384,3,8,5,66,33,32768,3,20,9,130,513,65536,7,131072,1025,10,1,36,19,262144,65,258", "code": "\nfrom sympy import factorint, primepi\ndef a(n):\n    return sum(2**primepi(i - 1) for i in factorint(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A087230", "text": "Exponent of p=2 in 6*n + 4 = 3*(2*n+1) + 1 (2-adic valuation of 6*n + 4).", "sequence": "1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,8,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1", "code": "\nn=100; N=3*n+2; val=[1]*(N+1); exp=2\nwhile exp <= N:\n    for j in range(exp,N+1,exp): val[j] += 1\n    exp *= 2\nfor i in range(1,n+1): print(i,val[3*i+2])\n\n"}
{"sequence_id": "A087244", "text": "Nonsquarefree deficient numbers.", "sequence": "4,8,9,16,25,27,32,44,45,49,50,52,63,64,68,75,76,81,92,98,99,116,117,121,124,125,128,135,136,147,148,152,153,164,169,171,172,175,184,188,189,207,212,225,232,236,242,243,244,245,248,250,256,261,268,275,279", "code": "\nfrom sympy import divisor_sigma\nfrom sympy.ntheory.factor_ import core\nprint([n for n in range(1,301) if core(n) != n and divisor_sigma(n)<2*n]) \n"}
{"sequence_id": "A087304", "text": "Smallest nontrivial multiple of n whose nonzero digit product is the same as that of the nonzero digit product of n. By nontrivial one means a(n) is not equal to n or (10^k)*n. 0 if no such number exists.", "sequence": "11,12,1113,104,15,132,1071,24,11133,110,1001,1020,1131,1022,105,32,1071,108,133,120,100002,1122,161,1008,125,1430,702,224,3016,11130,10013,160,3003,612,315,1332,703,342,11193,1040,10004,1008,602,1144,225", "code": "\nfrom functools import reduce\nfrom operator import mul\ndef A087304(n):\n    i, p = 2, reduce(mul,(int(d) for d in str(n) if d != '0'))\n    while (max(str(i)) == '1' and str(i).count('1') == 1) or reduce(mul,(int(d) for d in str(i*n) if d != '0')) != p:\n        i += 1\n    return i*n \n"}
{"sequence_id": "A087316", "text": "a(n) = Sum_{k=1..n} prime(k)^prime(n-k+1).", "sequence": "4,17,84,545,7824,281771,51540600,3347558057,1146374959980,288113965730819,529172633067826888,283453407513524913023,4122282265785671687518812,1586581830624893452605127040309,412109111737176949907195758658736", "code": "\nfrom sympy import prime\ndef a(n): return sum(prime(k)**prime(n-k+1) for k in range(1, n+1))\nprint([a(n) for n in range(1, 16)]) \n"}
{"sequence_id": "A087665", "text": "Consider recurrence b(0) = n/4, b(k) = b(k-1)*floor(b(k-1)); sequence gives first integer reached, or -1 if no integer is ever reached.", "sequence": "2,18,5,550935,3,3396542576998428,105", "code": "\nfrom fractions import Fraction\ndef a(n):\n  b = Fraction(n, 4)\n  while b.denominator != 1: b *= int(b)\n  return b\nfor n in range(8, 15): print(a(n)) \n"}
{"sequence_id": "A087666", "text": "Consider recurrence b(0) = n/3, b(k+1) = b(k)*floor(b(k)); a(n) is the least k such that b(k) is an integer, or -1 if no integer is ever reached.", "sequence": "0,3,4,0,1,1,0,3,2,0,3,7,0,1,1,0,2,3,0,2,2,0,1,1,0,5,5,0,5,6,0,1,1,0,9,2,0,8,3,0,1,1,0,2,5,0,2,2,0,1,1,0,3,3,0,6,3,0,1,1,0,4,2,0,6,4,0,1,1,0,2,4,0,2,2,0,1,1,0,6,4,0,3,6,0,1,1,0,3,2,0,3,4,0,1,1,0,2,3,0,2,2,0,1,1,0,4,7,0,6,6,0,1,1,0,5,2,0,4,3,0,1,1,0,2", "code": "\ndef A087666(n):\n    c, x = 0, n\n    a, b = divmod(x,3)\n    while b != 0:\n        x *= a\n        c += 1\n        a, b = divmod(x,3)\n    return c \n"}
{"sequence_id": "A087669", "text": "The smallest index m such that b(m) is an integer, where b(0)=(2n+1)/n and b(k+1)=b(k)*floor(b(k)) for k>=0.", "sequence": "0,1,3,2,5,4,5,2,4,9,19,7,16,7,8,3,27,9,5,25,10,11,32,4,13,4,17,6,17,6,78,3,23,47,13,6,4,6,27,9,20,6,4,17,9,28,106,4,24,28,37,20,27,10,12,13,7,83,108,10,16,9,6,3,10,11,15,8,11,6,156,15,38,46,7", "code": "\ndef A087669(n):\n    c, x = 0, 2*n+1\n    a, b = divmod(x,n)\n    while b != 0:\n        x *= a\n        c += 1\n        a, b = divmod(x,n)\n    return c \n"}
{"sequence_id": "A087725", "text": "Maximal number of moves required for the n X n generalization of the sliding block 15-puzzle (or fifteen-puzzle).", "sequence": "0,6,31,80", "code": " \nfor n in range(1, 4): \n  start, shape = \"\".join(chr(45+i) for i in range(n**2)), (n, n)\n  print(len(alst(start, shape))-1, end=\", \") \n"}
{"sequence_id": "A087990", "text": "Number of palindromic divisors of n.", "sequence": "1,2,2,3,2,4,2,4,3,3,2,5,1,3,3,4,1,5,1,4,3,4,1,6,2,2,3,4,1,5,1,4,4,2,3,6,1,2,2,5,1,5,1,6,4,2,1,6,2,3,2,3,1,5,4,5,2,2,1,6,1,2,4,4,2,8,1,3,2,4,1,7,1,2,3,3,4,4,1,5,3,2,1,6,2,2,2,8,1,6,2,3,2,2,2,6,1,3,6,4,2,4,1,4,4", "code": "\ndef ispal(n):\n    t = str(n)\n    return t == t[::-1]\ndef A087990(n):\n    s=0\n    for i in range(1,n+1):\n        if n%i==0 and ispal(i):\n            s+=1\n    return s \n"}
{"sequence_id": "A087991", "text": "Number of non-palindromic divisors of n.", "sequence": "0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,2,1,0,1,2,1,2,1,2,1,3,1,2,0,2,1,3,1,2,2,3,1,3,1,0,2,2,1,4,1,3,2,3,1,3,0,3,2,2,1,6,1,2,2,3,2,0,1,3,2,4,1,5,1,2,3,3,0,4,1,5,2,2,1,6,2,2,2,0,1,6,2,3,2,2,2,6,1,3,0,5,0,4,1,4,4", "code": "\ndef ispal(n):\n    w=str(n)\n    return w==w[::-1]\ndef A087991(n):\n    s = 0\n    for i in range(1, n+1):\n        if n%i==0 and not ispal(i):\n            s+=1\n    return s\nprint([A087991(n) for n in range(1,60)]) \n"}
{"sequence_id": "A088000", "text": "a(n) is the sum of the palindromic divisors of n.", "sequence": "1,3,4,7,6,12,8,15,13,8,12,16,1,10,9,15,1,21,1,12,11,36,1,24,6,3,13,14,1,17,1,15,48,3,13,25,1,3,4,20,1,19,1,84,18,3,1,24,8,8,4,7,1,21,72,22,4,3,1,21,1,3,20,15,6,144,1,7,4,15,1,33,1,3,9,7,96,12,1,20,13,3,1,23,6,3", "code": "\ndef ispal(n):\n    return n==int(str(n)[::-1])\ndef A088000(n):\n    s=0\n    for i in range(1, n+1):\n        if n%i==0 and ispal(i):\n             s+=i\n    return s\nprint([A088000(n) for n in range(1,30)]) \n"}
{"sequence_id": "A088001", "text": "a(n) is the sum of non-palindromic divisors of n.", "sequence": "0,0,0,0,0,0,0,0,0,10,0,12,13,14,15,16,17,18,19,30,21,0,23,36,25,39,27,42,29,55,31,48,0,51,35,66,37,57,52,70,41,77,43,0,60,69,47,100,49,85,68,91,53,99,0,98,76,87,59,147,61,93,84,112,78,0,67,119,92,129,71,162,73", "code": "\ndef ispal(n):\n    return n==int(str(n)[::-1])\ndef A088001(n):\n    s=0\n    for i in range(1, n+1):\n        if n%i==0 and not ispal(i):\n             s+=i\n    return s \n"}
{"sequence_id": "A088036", "text": "Numbers k such that k^3 - 1 is divisible by a cube other than 1.", "sequence": "9,10,17,18,19,25,28,33,37,41,46,49,55,57,64,65,73,81,82,89,91,97,100,105,109,113,118,121,126,127,129,136,137,145,153,154,161,163,169,172,177,181,185,190,193,199,201,208,209,217,225,226,233,235,241,244,249", "code": "\nfrom sympy import factorint\ndef ok(n): return max(factorint(n**3 - 1).values()) >= 3\nprint(list(filter(ok, range(1, 250)))) \n"}
{"sequence_id": "A088104", "text": "Smallest n-digit prime beginning with prime(n), or 0 if no such prime exists.", "sequence": "2,31,503,7001,11003,130003,1700021,19000013,230000003,2900000017,31000000027,370000000003,4100000000003,43000000000063,470000000000023,5300000000000129,59000000000000011,610000000000000031,6700000000000000021,71000000000000000047,730000000000000000001", "code": "\nfrom sympy import prime, nextprime\ndef A088104(n):\n    p = prime(n)\n    return nextprime(p*10**(n-len(str(p)))-1) \n"}
{"sequence_id": "A088177", "text": "a(1)=1, a(2)=1; for n>2, a(n) is the smallest positive integer such that the products a(i)*a(i+1), i=1..n-1, are all distinct.", "sequence": "1,1,2,2,3,1,5,2,4,3,3,5,4,4,6,3,7,1,11,2,7,4,8,5,5,6,6,7,5,9,3,11,4,12,5,10,7,7,8,8,9,6,11,5,13,1,17,2,13,3,17,4,13,6,14,7,9,9,10,8,11,7,13,8,12,9,11,10,10,12,11,11,13,9,14,8,16,9", "code": "\nfrom itertools import islice\ndef A088177(): \n    yield 1\n    yield 1\n    p, a = {1}, 1\n    while True:\n        n = 1\n        while n*a in p:\n            n += 1\n        p.add(n*a)\n        a = n\n        yield n\nA088177_list = list(islice(A088177(),20)) \n"}
{"sequence_id": "A088178", "text": "Sequence of distinct products b(n)*b(n+1), n=1,2,3,..., of the terms b(n) of A088177.", "sequence": "1,2,4,6,3,5,10,8,12,9,15,20,16,24,18,21,7,11,22,14,28,32,40,25,30,36,42,35,45,27,33,44,48,60,50,70,49,56,64,72,54,66,55,65,13,17,34,26,39,51,68,52,78,84,98,63,81,90,80,88,77,91,104,96,108,99,110,100,120,132", "code": "\nfrom itertools import islice\ndef A088178(): \n    yield 1\n    p, a = {1}, 1\n    while True:\n        n, na = 1, a\n        while na in p:\n            n += 1\n            na += a\n        p.add(na)\n        a = n\n        yield na\nA088178_list = list(islice(A088178(),20)) \n"}
{"sequence_id": "A088305", "text": "a(0) = 1, a(n) = Fibonacci(2*n). It has the property: a(n) = 1*a(n-1) + 2*a(n-2) + 3*a(n-3) + 4*a(n-4) + ...", "sequence": "1,1,3,8,21,55,144,377,987,2584,6765,17711,46368,121393,317811,832040,2178309,5702887,14930352,39088169,102334155,267914296,701408733,1836311903,4807526976,12586269025,32951280099,86267571272,225851433717", "code": "\ndef a(n, adict={0:1, 1:1, 2:3}):\n    if n in adict:\n        return adict[n]\n    adict[n]=3*a(n-1)-a(n-2)\n    return adict[n]\n\n"}
{"sequence_id": "A088462", "text": "a(1)=1, a(n) = ceiling((n - a(a(n-1)))/2).", "sequence": "1,1,1,2,2,3,3,4,4,4,5,5,6,6,6,7,7,8,8,8,9,9,10,10,11,11,11,12,12,13,13,13,14,14,15,15,16,16,16,17,17,18,18,18,19,19,20,20,21,21,21,22,22,23,23,23,24,24,25,25,25,26,26,27,27,28,28,28,29,29,30,30,30,31,31,32,32", "code": "\nl=[0, 1, 1]\nfor n in range(3, 101): l.append(n - l[n - 1] - l[l[n - 2]])\nprint(l[1:]) \n"}
{"sequence_id": "A088529", "text": "Numerator of Bigomega(n)/Omega(n).", "sequence": "1,1,2,1,1,1,3,2,1,1,3,1,1,1,4,1,3,1,3,1,1,1,2,2,1,3,3,1,1,1,5,1,1,1,2,1,1,1,2,1,1,1,3,3,1,1,5,2,3,1,3,1,2,1,2,1,1,1,4,1,1,3,6,1,1,1,3,1,1,1,5,1,1,3,3,1,1,1,5,4,1,1,4,1,1,1,2,1,4,1,3,1,1,1,3,1,3,3,2", "code": "\nfrom sympy import primefactors, Integer\ndef bigomega(n): return 0 if n==1 else bigomega(Integer(n)/primefactors(n)[0]) + 1\ndef omega(n): return Integer(len(primefactors(n)))\ndef a(n): return (bigomega(n)/omega(n)).numerator()\nprint([a(n) for n in range(2, 51)]) \n"}
{"sequence_id": "A088530", "text": "Denominator of Bigomega(n)/Omega(n).", "sequence": "1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,2,1,2,1,2,1,1,1,1,1,1,1,3,1,1,2,1,1,1,1,2,1,1,1,2,1,1,2,2,1,1,1,2,1,1,1,3,1,1,1,1,1,3,1,2,1,1,1,1,1,2,2,1", "code": "\nfrom sympy import primefactors, Integer\ndef bigomega(n): return 0 if n==1 else bigomega(Integer(n)/primefactors(n)[0]) + 1\ndef omega(n): return Integer(len(primefactors(n)))\ndef a(n): return (bigomega(n)/omega(n)).denominator()\nprint([a(n) for n in range(2, 51)]) \n"}
{"sequence_id": "A088548", "text": "Primes of the form  k^4 + k^3 + k^2 + k + 1.", "sequence": "5,31,2801,22621,30941,88741,245411,292561,346201,637421,732541,837931,2625641,3500201,3835261,6377551,15018571,16007041,21700501,28792661,30397351,35615581,39449441,48037081,52822061,78914411,97039801,147753211,189004141,195534851", "code": "\nfrom sympy import isprime\nprint(list(filter(isprime, (k**4+k**3+k**2+k+1 for k in range(120))))) \n"}
{"sequence_id": "A088601", "text": "Number of steps to reach 0 when iterating A261424(x) = x - (the largest palindrome less than x), starting at n.", "sequence": "1,1,1,1,1,1,1,1,1,2,1,2,2,2,2,2,2,2,2,2,3,1,2,2,2,2,2,2,2,2,2,3,1,2,2,2,2,2,2,2,2,2,3,1,2,2,2,2,2,2,2,2,2,3,1,2,2,2,2,2,2,2,2,2,3,1,2,2,2,2,2,2,2,2,2,3,1,2,2,2,2,2,2,2,2,2,3,1,2,2,2,2,2,2,2,2,2,3,1,2,1,2,2,2,2", "code": "\ndef P(n):\n    s = str(n); h = s[:(len(s)+1)//2]; return int(h + h[-1-len(s)%2::-1])\ndef A261423(n):\n    s = str(n)\n    if s == '1'+'0'*(len(s)-1) and n > 1: return n - 1\n    Pn = P(n)\n    return Pn if Pn <= n else P(n - 10**(len(s)//2))\ndef A088601(n): return 0 if n == 0 else 1 + A088601(n - A261423(n))\nprint([A088601(n) for n in range(1, 106)]) \n"}
{"sequence_id": "A088639", "text": "Smallest prime beginning with at least n n's (in decimal notation).", "sequence": "2,11,223,3331,44449,555557,66666629,777777701,888888883,99999999907,1010101010101010101039,11111111111111111111111,12121212121212121212121223,1313131313131313131313131301,141414141414141414141414141497,15151515151515151515151515151501", "code": "\nfrom sympy import isprime\ndef a(n):\n  if n == 0: return 2\n  nns, i, pow10 = int(str(n)*n), 1, 1\n  while True:\n    i = 1\n    while i < pow10:\n      t = nns * pow10 + i\n      if isprime(t): return t\n      i += 2\n    pow10 *= 10\nprint([a(n) for n in range(16)]) \n"}
{"sequence_id": "A088658", "text": "Number of triangles in an n X n unit grid that have minimal possible area (of 1/2).", "sequence": "0,4,32,124,320,716,1328,2340,3792,5852,8544,12260,16864,22916,30272,39188,49824,62948,78080,96348,117232,141260,168480,200292,235680,276100,321056,371484,427024,489900,558112,634724,718432,810116,909600,1018388,1135136,1263828,1402304,1551908", "code": "\nfrom sympy import totient\ndef A088658(n): return 4*(n-1)**2 + 4*sum(totient(i)*(n-i)*(2*n-i) for i in range(2,n)) \n"}
{"sequence_id": "A088685", "text": "Records for the sum-of-primes function sopfr(n) if sopfr(prime) is taken to be 0.", "sequence": "0,4,5,6,7,9,10,13,15,19,21,25,31,33,39,43,45,49,55,61,63,69,73,75,81,85,91,99,103,105,109,111,115,129,133,139,141,151,153,159,165,169,175,181,183,193,195,199,201,213,225,229,231,235,241,243,253,259,265,271", "code": "\nfrom sympy import factorint, isprime\ndef sopfr(n):\n    f=factorint(n)\n    return sum([i*f[i] for i in f])\nl=[]\nrecord=-1\nfor n in range(1, 501):\n    if not isprime(n):\n        x=sopfr(n)\n        if x>record:\n            record=x\n            l.append(record)\nprint(l) \n"}
{"sequence_id": "A088686", "text": "Positions of the records in the sum-of-primes function sopfr(n) if sopfr(prime) is taken to be 0.", "sequence": "1,4,6,8,10,14,21,22,26,34,38,46,58,62,74,82,86,94,106,118,122,134,142,146,158,166,178,194,202,206,214,218,226,254,262,274,278,298,302,314,326,334,346,358,362,382,386,394,398,422,446,454,458,466,478,482", "code": "\nfrom sympy import factorint, isprime\ndef sopfr(n):\n    f=factorint(n)\n    return sum([i*f[i] for i in f])\nl=[]\nrecord=-1\nfor n in range(1, 501):\n    if not isprime(n):\n        x=sopfr(n)\n        if x>record:\n            record=x\n            l.append(n)\nprint(l) \n"}
{"sequence_id": "A088696", "text": "Triangle read by rows, giving number of partial quotients in continued fraction representation of terms in the left branch of the infinite Stern-Brocot tree.", "sequence": "1,1,2,1,2,3,2,1,2,3,2,3,4,3,2,1,2,3,2,3,4,3,2,3,4,5,4,3,4,3,2,1,2,3,2,3,4,3,2,3,4,5,4,3,4,3,2,3,4,5,4,5,6,5,4,3,4,5,4,3,4,3,2,1,2,3,2,3,4,3,2,3,4,5,4,3,4,3,2,3,4,5,4,5,6,5,4,3,4,5,4,3,4,3,2,3,4,5,4,5,6,5,4,5,6", "code": "\na = [[1]]\nfor n in range(6):\n    a.append(a[-1] + [x+1 for x in a[-1][::-1]])\nprint(sum(a, []))\n\n"}
{"sequence_id": "A088698", "text": "Replace 1 with 11 in binary representation of n.", "sequence": "0,3,6,15,12,27,30,63,24,51,54,111,60,123,126,255,48,99,102,207,108,219,222,447,120,243,246,495,252,507,510,1023,96,195,198,399,204,411,414,831,216,435,438,879,444,891,894,1791,240,483,486,975,492,987,990", "code": "\ndef a(n): return int(bin(n)[2:].replace('1', '11'), 2)\nprint([a(n) for n in range(55)]) \n"}
{"sequence_id": "A088754", "text": "Number of n-digit primes beginning with prime(n).", "sequence": "1,2,14,107,103,851,6931,59557,518971,4585526,41368791,375232730,3441863700,31843327587,295907384843,2761221438054,25890141962275,244138314690159,2306482418751769,21874074143081175,208132164249925671,1983046852246630734,18946883921641542673", "code": "\nfrom sympy import prime, primepi\ndef A088754(n):\n    p = prime(n)\n    m = n-len(str(p))\n    return primepi((p+1)*10**m)-primepi(p*10**m) \n"}
{"sequence_id": "A088976", "text": "Breadth-first traversal of the Collatz tree, with the even child of each node traversed prior to its odd child. If the Collatz 3n+1 conjecture is true, this is a permutation of all positive integers.", "sequence": "1,2,4,8,16,32,5,64,10,128,21,20,3,256,42,40,6,512,85,84,80,13,12,1024,170,168,160,26,24,2048,341,340,336,320,53,52,48,4096,682,680,113,672,640,106,104,17,96,8192,1365,1364,227,1360,226,1344,1280,213,212,35,208", "code": "\ndef A088976():\n    yield 1\n    for x in A088976():\n        yield 2*x\n        if x > 4 and x % 6 == 4:\n            yield (x - 1)//3\na = A088976(); print([next(a) for _ in range(100)])\n"}
{"sequence_id": "A088986", "text": "Numbers n such that each of n through n+4 are divisible by exactly two primes.", "sequence": "54,91,92,115,141,142,143,144,158,205,212,213,214,215,295,301,323,324,325,391,535,685,721,799,1135,1345,1465,1535,1711,1941,1981,2101,2215,2302,2303,2304,2425,2641,3865,4411,5461,6505,6625,6925,7165,7231,7261", "code": "\nfrom sympy import primefactors\ndef ok(n):\n    return all(len(primefactors(n + i))==2 for i in range(5))\nprint([n for n in range(1, 8001) if ok(n)]) \n"}
{"sequence_id": "A088999", "text": "Flip 6,9 numbers: if number k contains decimal digit '6' or '9', then flip all occurrences of '6' to '9' and vice versa.", "sequence": "9,6,19,16,29,26,39,36,49,46,59,56,90,91,92,93,94,95,99,97,98,96,79,76,89,86,60,61,62,63,64,65,69,67,68,66,109,106,119,116,129,126,139,136,149,146,159,156,190,191,192,193,194,195,199,197,198,196,179,176,189", "code": "\ndef has69(s): return '6' in s or '9' in s\ndef flp69(s): return s.replace(\"6\", \"-\").replace(\"9\", \"6\").replace(\"-\", \"9\")\ndef aupto(lim):\n    return [int(flp69(s)) for s in map(str, range(lim+1)) if has69(s)]\nprint(aupto(186)) \n"}
{"sequence_id": "A089091", "text": "a(n) is the smallest composite number coprime to n and n+1.", "sequence": "9,25,25,9,49,25,9,25,49,9,25,25,9,121,49,9,25,25,9,121,25,9,25,49,9,25,25,9,49,49,9,25,25,9,121,25,9,25,49,9,25,25,9,49,49,9,25,25,9,49,25,9,25,49,9,25,25,9,49,49,9,25,25,9,49,25,9,25,121,9,25,25,9,49,49,9,25,25", "code": "\nfrom math import gcd\ndef a(n):\n    k, m = 3, n*(n+1)\n    while gcd(k, m) != 1: k += 2\n    return k*k\nprint([a(n) for n in range(1, 79)]) \n"}
{"sequence_id": "A089386", "text": "Smallest number with digital product = 10^n.", "sequence": "1,25,455,5558,255558,4555558,55555588,2555555588,45555555588,555555555888,25555555555888,455555555555888,5555555555558888,255555555555558888,4555555555555558888,55555555555555588888,2555555555555555588888,45555555555555555588888", "code": "\ndef a(n):\n  if n == 0: return 1\n  pow10, s = 10**n, \"\"\n  for d in [8, 5, 4, 2]:\n    while pow10%d == 0: pow10//=d; s += str(d)\n  return int(s[::-1])\nprint([a(n) for n in range(18)]) \n"}
{"sequence_id": "A089408", "text": "Number of fixed points in range [A014137(n-1)..A014138(n-1)] of permutation A089864.", "sequence": "1,1,2,1,2,2,4,5,10,14,28,42,84,132,264,429,858,1430,2860,4862,9724,16796,33592,58786,117572,208012,416024,742900,1485800,2674440,5348880,9694845,19389690,35357670,70715340,129644790,259289580,477638700", "code": "\nfrom sympy import catalan\ndef a(n): return 1 if n==0 else 2*catalan(n//2 - 1) if n%2==0 else catalan((n - 1)//2) \n"}
{"sequence_id": "A089473", "text": "Number of configurations of the sliding block 8-puzzle that require a minimum of n moves to be reached, starting with the empty square in one of the corners.", "sequence": "1,2,4,8,16,20,39,62,116,152,286,396,748,1024,1893,2512,4485,5638,9529,10878,16993,17110,23952,20224,24047,15578,14560,6274,3910,760,221,2", "code": " \ndef swap(p, z, nz):\n  lp = list(p)\n  lp[z], lp[nz] = lp[nz], \"-\"\n  return \"\".join(lp)\ndef moves(p, shape): \n  nxt, (n, m), z = [], shape, p.find(\"-\") \n  if z > n - 1:  nxt.append(swap(p, z, z-n)) \n  if z < n*m-n:  nxt.append(swap(p, z, z+n)) \n  if z%n != 0:   nxt.append(swap(p, z, z-1)) \n  if z%n != n-1: nxt.append(swap(p, z, z+1)) \n  return nxt\ndef alst(start, shape, v=False, maxd=float('inf')):\n  alst, d, expanded, frontier = [], 0, set(), {start}\n  alst.append(len(frontier))\n  if v: print(len(frontier), end=\", \")\n  while len(frontier) > 0 and d < maxd:\n    reach1 = set(m for p in frontier for m in moves(p, shape) if m not in expanded)\n    expanded |= frontier \n    if len(reach1):\n      alst.append(len(reach1))\n      if v: print(len(reach1), end=\", \")\n    frontier = reach1\n    d += 1\n  return alst\nprint(alst(\"-12345678\", (3, 3))) \n"}
{"sequence_id": "A089474", "text": "Number of configurations of the sliding block 8-puzzle that require a minimum of n moves to be reached, starting with the empty square in the center.", "sequence": "1,4,8,8,16,32,60,72,136,200,376,512,964,1296,2368,3084,5482,6736,11132,12208,18612,18444,24968,19632,22289,13600,11842,4340,2398,472,148", "code": " \nprint(alst(\"1234-5678\", (3, 3))) \n"}
{"sequence_id": "A089483", "text": "Number of configurations of the sliding block 8-puzzle that require a minimum of n moves to be reached, starting with the empty square at mid-side.", "sequence": "1,3,5,10,14,28,42,80,108,202,278,524,726,1348,1804,3283,4193,7322,8596,13930,14713,21721,19827,25132,18197,18978,9929,7359,2081,878,126,2", "code": " \nprint(alst(\"1-2345678\", (3, 3))) \n"}
{"sequence_id": "A089484", "text": "Number of configurations of the sliding block 15-puzzle that require a minimum of n moves to be reached, starting with the empty square in one of the corners.", "sequence": "1,2,4,10,24,54,107,212,446,946,1948,3938,7808,15544,30821,60842,119000,231844,447342,859744,1637383,3098270,5802411,10783780,19826318,36142146,65135623,116238056,204900019,357071928,613926161,1042022040", "code": " \nstart, shape = \"-123456789ABCDEF\", (4, 4)\nalst(start, shape, v=True) \n"}
{"sequence_id": "A089643", "text": "3^a(n) divides C(3n,n); 3-adic valuation of A005809.", "sequence": "0,1,1,1,2,1,1,2,2,1,2,2,2,3,1,1,2,2,1,2,2,2,3,2,2,3,3,1,2,2,2,3,2,2,3,3,2,3,3,3,4,1,1,2,2,1,2,2,2,3,2,2,3,3,1,2,2,2,3,2,2,3,3,2,3,3,3,4,2,2,3,3,2,3,3,3,4,3,3,4,4,1,2,2,2,3,2,2,3,3,2,3,3,3,4,2,2,3,3,2,3,3,3,4,3", "code": "\nfrom sympy import binomial\ndef a007949(n): return 0 if n%3 else a007949(n//3) + 1\ndef a(n): return a007949(binomial(3*n, n))\nprint([a(n) for n in range(151)]) \n"}
{"sequence_id": "A089723", "text": "a(1)=1; for n>1, a(n) gives number of ways to write n as n = x^y, 2 <= x, 1 <= y.", "sequence": "1,1,1,2,1,1,1,2,2,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,2,1,2,1,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1", "code": "\nfrom math import gcd\nfrom sympy import factorint, divisor_sigma\ndef a(n):\n    if n == 1: return 1\n    e = list(factorint(n).values())\n    g = e[0]\n    for ei in e[1:]: g = gcd(g, ei)\n    return divisor_sigma(g, 0)\nprint([a(n) for n in range(1, 105)]) \n"}
{"sequence_id": "A089748", "text": "Numbers k that divide (sum of proper divisors of k + product of proper divisors of k).", "sequence": "2,6,28,120,496,672,8128,30240,32760,523776,2178540,23569920,33550336,45532800,142990848,459818240", "code": "\nfrom math import prod\nfrom sympy import divisors\ndef ok(n): d = divisors(n)[:-1]; return n > 1 and (sum(d) + prod(d))%n == 0\nprint([k for k in range(10**5) if ok(k)]) \n"}
{"sequence_id": "A089971", "text": "Primes whose decimal representation also represents a prime in base 2.", "sequence": "11,101,10111,101111,1011001,1100101,10010101,10011101,10100011,10101101,10110011,11000111,11100101,100111001,101001011,101101111,101111011,101111111,110111011,111001001,1000001011,1001001011", "code": "\nfrom sympy import isprime, primerange\ndef aupto(limit):\n    alst = []\n    for p in primerange(2, limit+1):\n        t = int(bin(p)[2:])\n        if isprime(t): alst.append(t)\n    return alst\nprint(aupto(2**11)) \n"}
{"sequence_id": "A089975", "text": "Array read by ascending antidiagonals: T(n,k) is the number of n-letter words from a k-letter alphabet such that no letter appears more than twice.", "sequence": "1,0,1,0,1,1,0,1,2,1,0,0,4,3,1,0,0,6,9,4,1,0,0,6,24,16,5,1,0,0,0,54,60,25,6,1,0,0,0,90,204,120,36,7,1,0,0,0,90,600,540,210,49,8,1,0,0,0,0,1440,2220,1170,336,64,9,1,0,0,0,0,2520,8100,6120,2226,504,81,10,1", "code": "\nfrom math import factorial as f\ndef T(n,k):\n    return sum(f(n)*f(k)//f(n-2*i)//f(i)//f(k-n+i)//2**i for i in range(max(0,n-k),n//2+1))\n[T(n-k,k) for n in range(21) for k in range(n+1)]\n\n"}
{"sequence_id": "A089982", "text": "Triangular numbers that can be expressed as the sum of 2 positive triangular numbers.", "sequence": "6,21,36,55,66,91,120,136,171,210,231,276,351,378,406,496,561,666,703,741,820,861,946,990,1035,1081,1176,1225,1326,1378,1431,1485,1540,1596,1653,1711,1770,1891,1953,2016,2080,2211,2278,2346,2556,2701,2775,2850", "code": "\nfrom itertools import count, takewhile\ndef aupto(lim):\n    t = list(takewhile(lambda x: x<=lim, (i*(i+1)//2 for i in count(1))))\n    s = set(a+b for i, a in enumerate(t) for b in t[i:])\n    return sorted(s & set(t))\nprint(aupto(3000)) \n"}
{"sequence_id": "A090012", "text": "Permanent of (0,1)-matrix of size n X (n+d) with d=2 and n-1 zeros not on a line.", "sequence": "3,9,39,213,1395,10617,91911,890901,9552387,112203465,1432413063,19743404469,292164206259,4619383947513,77708277841575,1385712098571957,26108441941918851,518231790473609481,10808479322484810087", "code": "\n\nprint(\"1 3\")\nprint(\"2 9\")\na=3\nb=9\nc=(3+1)*b+(3-2)*a\nfor i in range(4, 40):\n    print(str(i - 1)+\" \"+str(c))\n    a=b\n    b=c\n    c=(i+1)*b+(i-2)*a \n"}
{"sequence_id": "A090020", "text": "Number of distinct lines through the origin in the n-dimensional lattice of side length 4.", "sequence": "0,1,13,91,529,2851,14833,75811,383809,1932931,9705553,48648931,243605089,1219100611,6098716273,30503196451,152544778369,762810181891,3814309582993,19072323542371,95363943807649,476826695752771", "code": " def A090020(n): return 5**n-3**n-2**n+1 \n"}
{"sequence_id": "A090025", "text": "Number of distinct lines through the origin in 3-dimensional cube of side length n.", "sequence": "0,7,19,49,91,175,253,415,571,805,1033,1423,1723,2263,2713,3313,3913,4825,5491,6625,7513,8701,9811,11461,12637,14497,16045,18043,19807,22411,24163,27133,29485,32425,35065,38593,41221,45433,48727,52831", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A090025(n):\n    if n == 0:\n        return 0\n    c, j = 1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A090025(k1)\n        j, k1 = j2, n//j2\n    return (n+1)**3-c+7*(j-n-1) \n"}
{"sequence_id": "A090026", "text": "Number of distinct lines through the origin in 4-dimensional cube of side length n.", "sequence": "0,15,65,225,529,1185,2065,3745,5841,9105,13025,19105,25521,35361,45825,59905,75425,96865,117841,147505,177041,214961,254401,306321,355249,420929,485489,565265,645377,748081,841841,966881,1086241,1230401,1373185,1549825", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A090026(n):\n    if n == 0:\n        return 0\n    c, j = 1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A090026(k1)\n        j, k1 = j2, n//j2\n    return (n+1)**4-c+15*(j-n-1) \n"}
{"sequence_id": "A090027", "text": "Number of distinct lines through the origin in 5-dimensional cube of side length n.", "sequence": "0,31,211,961,2851,7471,15541,31471,55651,95821,152041,239791,351331,517831,723241,1007041,1352041,1821721,2359051,3082921,3904081,4956901,6151651,7677901,9334261,11445361,13746181,16566691,19644031,23432851,27408331,32333581", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A090027(n):\n    if n == 0:\n        return 0\n    c, j = 1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A090027(k1)\n        j, k1 = j2, n//j2\n    return (n+1)**5-c+31*(j-n-1) \n"}
{"sequence_id": "A090028", "text": "Number of distinct lines through the origin in 6-dimensional cube of side length n.", "sequence": "0,63,665,3969,14833,45801,112825,257257,515025,980217,1720145,2934505,4693473,7396137,11112129,16464385,23555441,33430033,45927505,62881561,83865257,111331241,144772201,187839225,238778281,303522401,379323785", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A090028(n):\n    if n == 0:\n        return 0\n    c, j = 1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A090028(k1)\n        j, k1 = j2, n//j2\n    return (n+1)**6-c+63*(j-n-1) \n"}
{"sequence_id": "A090029", "text": "Number of distinct lines through the origin in 7-dimensional cube of side length n.", "sequence": "0,127,2059,16129,75811,277495,804973,2078455,4702531,9905365,19188793,35533303,61846723,104511583,168681913,266042113,405259513,607140745,883046011,1269174145,1780715833,2472697501,3366818491,4548464341", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A090029(n):\n    if n == 0:\n        return 0\n    c, j = 1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A090029(k1)\n        j, k1 = j2, n//j2\n    return (n+1)**7-c+127*(j-n-1) \n"}
{"sequence_id": "A090031", "text": "Number of configurations of the 5 X 5 variant of sliding block 15-puzzle (\"24-puzzle\") that require a minimum of n moves to be reached, starting with the empty square in one of the corners.", "sequence": "1,2,4,10,26,64,159,366,862,1904,4538,10238,24098,53186,123435,268416,616374,1326882,3021126,6438828,14524718,30633586,68513713,143106496,317305688,656178756,1442068376,2951523620,6427133737,13014920506,28070588413,56212979470,120030667717", "code": " \nstart, shape = \"-123456789ABCDEFGHIJKLMNO\", (5, 5)\nalst(start, shape, v=True) \n"}
{"sequence_id": "A090032", "text": "Number of configurations of the 6 X 6 variant of Sam Loyd's sliding block 15-puzzle (\"35-puzzle\") that require a minimum of n moves to be reached, starting with the empty square in one of the corners.", "sequence": "1,2,4,10,26,66,171,440,1112,2786,6820,16720,41106,100856,245793,597030,1441292,3469486,8304526,19832076,47110238,111669014", "code": " \nstart, shape = \"-123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\", (6, 6)\nprint(alst(start, shape, maxd=16)) \n"}
{"sequence_id": "A090033", "text": "Triangle T(j,k) read by rows, where T(j,k) is the number of single tile moves in the longest optimal solution of the j X k generalization of the sliding block 15-puzzle, starting with the empty square in a corner.", "sequence": "0,1,6,2,21,31,3,36,53,80,4,55,84", "code": " \ndef T(j, k):  \n    start, shape = \"\".join(chr(45+i) for i in range(j*k)), (j, k)\n    return len(alst(start, shape))-1\nfor j in range(1, 5):\n    for k in range(1, j+1):\n        print(T(j,k), end=\", \") \n"}
{"sequence_id": "A090034", "text": "Number of configurations of the 3 X 2 variant of Sam Loyd's sliding block 15-puzzle that require a minimum of n moves to be reached, starting with the empty square in one of the corners.", "sequence": "1,2,3,5,6,7,10,12,12,16,23,25,28,39,44,40,29,21,18,12,6,1", "code": " \nprint(alst(\"-12345\", (3, 2))) \n"}
{"sequence_id": "A090035", "text": "Number of configurations of the 4 X 2 variant of Sam Loyd's sliding block 15-puzzle that require a minimum of n moves to be reached, starting with the empty square in one of the corners.", "sequence": "1,2,3,6,10,14,19,28,42,61,85,119,161,215,293,396,506,632,788,985,1194,1414,1664,1884,1999,1958,1770,1463,1076,667,361,190,88,39,19,7,1", "code": " \nprint(alst(\"-1234567\", (4, 2))) \n"}
{"sequence_id": "A090036", "text": "Number of configurations of the 5 X 2 variant of Sam Loyd's sliding block 15-puzzle that require a minimum of n moves to be reached, starting with the empty square in one of the corners.", "sequence": "1,2,3,6,11,19,30,44,68,112,176,271,411,602,851,1232,1783,2530,3567,4996,6838,9279,12463,16597,21848,28227,35682,44464,54597,65966,78433,91725,104896,116966,126335,131998,133107,128720,119332,106335,91545,75742,60119,45840,33422,23223,15140,9094,5073,2605,1224,528,225,75,20,2", "code": " \nprint(alst(\"-123456789\", (5, 2))) \n"}
{"sequence_id": "A090081", "text": "Cube root-smooth numbers: numbers n such that largest prime factor of n does not exceed cube root of n.", "sequence": "1,8,16,27,32,36,48,54,64,72,81,96,108,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,343,350,360,375,378,384,392,400,405,420,432,441,448,450,480,486,490,500,504,512,525", "code": "\nfrom sympy import primefactors\ndef ok(n):\n    if n==1 or max(primefactors(n))**3<=n: return True\n    else: return False\nprint([n for n in range(1, 1001) if ok(n)]) \n"}
{"sequence_id": "A090151", "text": "Primes of the form identical digits preceded by a 3.", "sequence": "3,31,37,311,311111,31111111111,311111111111,377777777777,31111111111111,377777777777777777,31111111111111111111111111111111111,311111111111111111111111111111111111111111111111", "code": "\nfrom sympy import isprime\ndef afind(terms):\n  print(3, end=\", \")\n  digits, n = 1, 1\n  while n < terms:\n    for id in \"17\":\n      t = int('3' + id*digits)\n      if isprime(t): print(t, end=\", \"); n += 1\n    digits += 1\nafind(12) \n"}
{"sequence_id": "A090164", "text": "Number of configurations of Sam Loyd's sliding block 15-puzzle that require a minimum of n moves to be reached, starting with the empty square at one of the 4 central squares.", "sequence": "1,4,10,20,38,80,174,372,762,1540,3072,6196,12356,24516,48179,94356,183432,355330,682250,1301874,2460591,4617322,8580175,15815664,28854386,52154316,93214030", "code": " \nstart, shape = \"12345-6789ABCDEF\", (4, 4)\nprint(alst(start, shape, maxd=15)) \n"}
{"sequence_id": "A090165", "text": "Number of configurations of Sam Loyd's sliding block 15-puzzle that require a minimum of n moves to be reached, starting with the empty square at one of the 8 non-corner boundary squares.", "sequence": "1,3,6,14,32,66,134,280,585,1214,2462,4946,9861,19600,38688,76086,148435,288098,554970,1062628,2016814,3800682,7093209,13127364,24053454,43657576,78382622,139237375", "code": " \nstart, shape = \"1-23456789ABCDEF\", (4, 4)\nprint(alst(start, shape, maxd=16)) \n"}
{"sequence_id": "A090166", "text": "Number of configurations of the 4 X 3 variant of Sam Loyd's sliding block 15-puzzle that require a minimum of n moves to be reached, starting with the empty square in one of the corners.", "sequence": "1,2,4,9,20,37,63,122,232,431,781,1392,2494,4442,7854,13899,24215,41802,71167,119888,198363,323206,515778,811000,1248011,1885279,2782396,4009722,5621354,7647872,10065800,12760413,15570786,18171606,20299876,21587248,21841159,20906905,18899357,16058335,12772603,9515217,6583181,4242753,2503873,1350268,643245,270303,92311,27116,5390,1115,86,18", "code": " \nalst(\"-123456789AB\", (4, 3), v=True) \n"}
{"sequence_id": "A090167", "text": "Number of configurations of the 6 X 2 variant of the so-called \"Sam Loyd\" sliding block 15-puzzle that require a minimum of n moves to be reached, starting with the empty square in one of the corners.", "sequence": "1,2,3,6,11,20,36,60,95,155,258,426,688,1106,1723,2615,3901,5885,8851,13205,19508,28593,41179,58899,83582,118109,165136,228596,312542,423797,568233,755727,994641,1296097,1667002,2119476,2660415,3300586,4038877", "code": " \nalst(\"-123456789AB\", (6, 2), v=True) \n"}
{"sequence_id": "A090248", "text": "a(n) = 27a(n-1) - a(n-2), starting with a(0) = 2 and a(1) = 27.", "sequence": "2,27,727,19602,528527,14250627,384238402,10360186227,279340789727,7531841136402,203080369893127,5475638145978027,147639149571513602,3980781400284889227,107333458658120495527,2894022602368968490002,78031276805304028734527", "code": "\ndef aupton(idx):\n  alst = [2, 27]\n  for n in range(2, idx+1): alst.append(27*alst[-1] - alst[-2])\n  return alst\nprint(aupton(16)) \n"}
{"sequence_id": "A090266", "text": "Least k such that concatenation k, prime(n), k is a prime.", "sequence": "7,1,1,3,13,17,1,9,1,1,3,3,3,3,1,1,3,3,3,7,3,3,1,57,17,3,3,1,9,1,33,1,19,3,1,3,3,9,57,1,3,21,7,9,1,21,9,3,7,21,7,1,3,1,3,3,3,3,9,7,3,3,3,3,9,1,9,41,7,3,3,1,29,9,11,1,3,9,1,9,7,3,3,17,9,1,31,17,3,17,3,7,27,3,9,1", "code": "\nfrom sympy import prime, isprime\ndef a(n):\n    spn = str(prime(n)); k = 1; sk = str(k)\n    while not isprime(int(sk + spn + sk)): k += 1; sk = str(k)\n    return k\nprint([a(n) for n in range(1, 97)]) \n"}
{"sequence_id": "A090269", "text": "Least k made of identical digits such that the concatenation k, prime(n), k is prime. a(5) = 0.", "sequence": "7,1,1,3,0,33,1,9,1,1,3,3,3,3,1,1,3,3,3,7,3,3,1,1111,111,3,3,1,9,1,33,1,111,3,1,3,3,9,777,1,3,77,7,9,1,777,9,3,7,333,7,1,3,1,3,3,3,3,9,7,3,3,3,3,9,1,9,777,7,3,3,1,77,9,11,1,3,9,1,9", "code": "\nfrom sympy import prime, isprime\ndef a(n):\n    if n == 5: return 0\n    spn, digits = str(prime(n)), 1\n    while True:\n        for sk in [d*digits for d in \"1379\"]:\n            if isprime(int(sk + spn + sk)): return int(sk)\n        digits += 1\nprint([a(n) for n in range(1, 81)]) \n"}
{"sequence_id": "A090287", "text": "Smallest prime obtained by sandwiching n between a number with identical digits, or 0 if no such prime exists. Primes of the form k n k where all the digits of k are identical.", "sequence": "101,313,727,131,11411,151,777767777,373,181,191,9109,0,7127,331333,991499,1151,3163,1171,1181,9199,1201,112111,0,1231,7247,3253,7777777777267777777777,1111271111,11128111,1291,1301,3313,1321,0,3343,333533,1361,3373,1381", "code": "\nfrom gmpy2 import is_prime, mpz, digits\ndef A090287(n,limit=2000):\n....sn = str(n)\n....if n in (231, 420, 759) or not (len(sn) % 2 or n % 11):\n........return 0\n....for i in range(1,limit+1):\n........for j in range(1,10,2):\n............si = digits(j,10)*i\n............p = mpz(si+sn+si)\n............if is_prime(p):\n................return int(p)\n....else:\n........return 'search limit reached.' \n"}
{"sequence_id": "A090292", "text": "Least square k^2 > n^2 whose decimal expansion ends in n^2.", "sequence": "100,81,64,49,2116,225,1936,1849,1764,1681,8100,57121,238144,56169,236196,1225,234256,54289,232324,53361,6400,52441,228484,51529,226576,5625,224676,49729,222784,48841,4900,47961,6091024,1481089,6081156,81225,6071296,1471369", "code": "\ndef a(n):\n    k, target = n + 1, str(n*n)\n    while not str(k*k).endswith(target): k += 1\n    return k*k\nprint([a(n) for n in range(38)]) \n"}
{"sequence_id": "A090292", "text": "Least square k^2 > n^2 whose decimal expansion ends in n^2.", "sequence": "100,81,64,49,2116,225,1936,1849,1764,1681,8100,57121,238144,56169,236196,1225,234256,54289,232324,53361,6400,52441,228484,51529,226576,5625,224676,49729,222784,48841,4900,47961,6091024,1481089,6081156,81225,6071296,1471369", "code": " \nfrom math import isqrt\ndef issquare(n): return isqrt(n)**2 == n\ndef a(n):\n    k, target = 1, str(n*n)\n    while not issquare(int(str(k)+target)): k += 1\n    return int(str(k)+target)\nprint([a(n) for n in range(38)]) \n"}
{"sequence_id": "A090293", "text": "Least k > n such that the decimal expansion of k^2 ends in n^2.", "sequence": "10,9,8,7,46,15,44,43,42,41,90,239,488,237,486,35,484,233,482,231,80,229,478,227,476,75,474,223,472,221,70,219,2468,1217,2466,285,2464,1213,2462,1289,460,1209,2458,1293,2456,205,2454,1297,2452,1201,150,1301", "code": "\ndef a(n):\n    k, target = n + 1, str(n*n)\n    while not str(k*k).endswith(target): k += 1\n    return k\nprint([a(n) for n in range(52)]) \n"}
{"sequence_id": "A090293", "text": "Least k > n such that the decimal expansion of k^2 ends in n^2.", "sequence": "10,9,8,7,46,15,44,43,42,41,90,239,488,237,486,35,484,233,482,231,80,229,478,227,476,75,474,223,472,221,70,219,2468,1217,2466,285,2464,1213,2462,1289,460,1209,2458,1293,2456,205,2454,1297,2452,1201,150,1301", "code": " \nfrom math import isqrt\ndef issquare(n): return isqrt(n)**2 == n\ndef a(n):\n    k, target = 1, str(n*n)\n    while not issquare(int(str(k)+target)): k += 1\n    return isqrt(int(str(k)+target))\nprint([a(n) for n in range(52)]) \n"}
{"sequence_id": "A090377", "text": "Number of configurations that require a minimum of n moves to be reached, starting with the empty square in one of the corners of an infinitely large extension of Sam Loyd's sliding block 15-puzzle.", "sequence": "1,2,4,10,26,66,173,456,1230,3318,9066,24768,68304,188370,523083,1452560,4054708,11318926", "code": " \nnn = 13\nstart = \"\".join([chr(i) for i in range(45, 45+(nn+1)**2)]) \nprint(alst(start, (nn+1, nn+1), maxd=nn)) \n"}
{"sequence_id": "A090378", "text": "Number of configurations that require a minimum of n moves to be reached, starting with the empty square at mid-side of a boundary of an infinitely large extension of Sam Loyd's sliding block 15-puzzle.", "sequence": "1,3,7,19,53,147,409,1151,3255,9241,26267,74895,213775,611463,1750277,5017901", "code": " \nnn = 24\nmid = (nn-1)//2\nstartlst = [chr(i) for i in range(45, 45+nn**2)] \nstartlst[0], startlst[mid] = startlst[mid], startlst[0]\nstart = \"\".join(startlst)\nprint(alst(start, (nn, nn), maxd=mid)) \n"}
{"sequence_id": "A090392", "text": "Seventh diagonal (m=6) of triangle A084938; a(n) = A084938(n+6,n) = (n^6 + 45*n^5 + 925*n^4 + 11475*n^3 + 92314*n^2 + 413640*n)/720.", "sequence": "0,720,1812,3428,5768,9090,13721,20069,28636,40032,54990,74382,99236,130754,170331,219575,280328,354688,445032,554040,684720,840434,1024925,1242345,1497284,1794800,2140450,2540322,3001068,3529938,4134815", "code": "\nA090392_list, m = [], [1, 5, 18, 58, 177, 461, 0]\nfor _ in range(1001):\n    A090392_list.append(m[-1])\n    print(m[-1])\n    for i in range(6):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A090393", "text": "Eighth diagonal (m=7) of triangle A084938; a(n) = A084938(n+7,n) = (n^7 + 63*n^6 + 1855*n^5 + 34125*n^4 + 438424*n^3 + 3980172*n^2 + 20946960*n)/5040.", "sequence": "0,5040,12288,22572,36992,56990,84432,121703,171816,238536,326520,441474,590328,781430,1024760,1332165,1717616,2197488,2790864,3519864,4410000,5490558,6795008,8361443,10233048,12458600,15093000,18197838", "code": "\nA090393_list, m = [], [1, 6, 25, 92, 327, 1142, 3447, 0]\nfor _ in range(1001):\n    A090393_list.append(m[-1])\n    print(m[-1])\n    for i in range(7):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A090394", "text": "Ninth diagonal (m=8) of triangle A084938; a(n) = A084938(n+8,n) = (n^8 + 84*n^7 + 3346*n^6 + 84840*n^5 + 1550689*n^4 + 21632436*n^3 + 224782284*n^2 + 1377648720*n)/40320.", "sequence": "0,40320,95616,170856,272584,409360,592296,835702,1157857,1581921,2137005,2859417,3794103,4996303,6533443,8487285,10956358,14058694,17934894,22751550,28705050,36025794,44982850,55889080,69106767", "code": "\nfrom itertools import islice\ndef A090394_generator():\n....m = [1, 7, 33, 135, 531, 2109, 8411, 29093, 0]\n....yield m[-1]\n....while True:\n........for i in range(8):\n............m[i+1]+= m[i]\n........yield m[-1]\nlist(islice(A090394_generator(),0,50,1)) \n"}
{"sequence_id": "A090405", "text": "a(n) = PrimePi(n+2) - PrimePi(n).", "sequence": "2,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,1", "code": "\nfrom sympy import primepi\nprint([primepi(n + 2) - primepi(n) for n in range(1, 101)])\n\n"}
{"sequence_id": "A090405", "text": "a(n) = PrimePi(n+2) - PrimePi(n).", "sequence": "2,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,1", "code": "\nfrom sympy import isprime\ndef a(n):\n    if n<2: return 2\n    else:\n        if isprime(n + 1 + (n%2 == 1) + (n==1)): return 1\n        else: return 0 \n"}
{"sequence_id": "A090422", "text": "Primes that cannot be written in binary representation as concatenation of other primes.", "sequence": "2,3,5,7,13,17,19,37,41,53,67,73,89,97,101,103,107,131,137,139,149,163,193,197,199,211,227,257,263,269,277,281,293,307,311,313,331,389,397,401,409,419,421,443,449,461,521,523,547,557,569,571,577,587,593", "code": "\nfrom sympy import isprime, primerange\ndef ok(p):\n  b = bin(p)[2:]\n  for i in range(2, len(b)-1):\n    if isprime(int(b[:i], 2)) and b[i] != '0':\n      if isprime(int(b[i:], 2)) or not ok(int(b[i:], 2)): return False\n  return True\ndef aupto(lim): return [p for p in primerange(2, lim+1) if ok(p)]\nprint(aupto(593)) \n"}
{"sequence_id": "A090423", "text": "Primes that can be written in binary representation as concatenation of other primes.", "sequence": "11,23,29,31,43,47,59,61,71,79,83,109,113,127,151,157,167,173,179,181,191,223,229,233,239,241,251,271,283,317,337,347,349,353,359,367,373,379,383,431,433,439,457,463,467,479,487,491,499,503,509,541,563,599,607", "code": "\n\nfrom sympy import sieve\nprimes = list(sieve.primerange(1, 608))\ndef tryPartioning(binString):   \n    l = len(binString)\n    for t in range(2, l-1):\n        substr1 = binString[:t]\n        if (int('0b'+substr1,2) in primes) or (t>=4 and tryPartioning(substr1)):\n            substr2 = binString[t:]\n            if substr2[0]!='0':\n                if (int('0b'+substr2,2) in primes) or (l-t>=4 and tryPartioning(substr2)):\n                    return 1\n    return 0\nfor p in primes:\n    if tryPartioning(bin(p)[2:]):\n        print(p, end=',')\n"}
{"sequence_id": "A090423", "text": "Primes that can be written in binary representation as concatenation of other primes.", "sequence": "11,23,29,31,43,47,59,61,71,79,83,109,113,127,151,157,167,173,179,181,191,223,229,233,239,241,251,271,283,317,337,347,349,353,359,367,373,379,383,431,433,439,457,463,467,479,487,491,499,503,509,541,563,599,607", "code": "\nfrom sympy import isprime, primerange\ndef ok(p):\n  b = bin(p)[2:]\n  for i in range(2, len(b)-1):\n    if isprime(int(b[:i], 2)) and b[i] != '0':\n      if isprime(int(b[i:], 2)) or ok(int(b[i:], 2)): return True\n  return False\ndef aupto(lim): return [p for p in primerange(2, lim+1) if ok(p)]\nprint(aupto(607)) \n"}
{"sequence_id": "A090493", "text": "Least k such that n^k contains all the digits from 0 through 9, or 0 if no such k exists.", "sequence": "0,68,39,34,19,20,18,28,24,0,23,22,22,21,12,17,14,21,17,51,17,18,14,19,11,18,13,11,12,39,11,14,16,14,19,10,13,14,17,34,11,17,13,16,15,11,12,12,9,18,16,11,13,10,12,7,13,11,11,20,14,18,13,14,10,13,10,9,11,18,15", "code": "\ndef a(n):\n  s = str(n)\n  if n == 1 or (s.count('0')==len(s)-1 and s.startswith('1')):\n    return 0\n  k = 1\n  count = 0\n  while count != 10:\n    count = 0\n    for i in range(10):\n      if str(n**k).count(str(i)) == 0:\n        count += 1\n        break\n    if count:\n      k += 1\n    else:\n      return k\nn = 1\nwhile n < 100:\n  print(a(n), end=', ')\n  n += 1\n\n"}
{"sequence_id": "A090497", "text": "Smallest prime p such that the concatenation 2,3,5,7, ... (primes) ... p is a multiple of prime(n).", "sequence": "2,29,5,11,17,61,31,271,3,13,107,1051,439,211,5,1153,149,23,37,173,593,173,281,347,191,433,2083,109,389,1453,277,383,227,443,1879,11,233,353,191,1723,547,241,397,181,199,7549,79,11,547,877,313,1213,409,79,2969", "code": "\nfrom sympy import prime, nextprime\ndef a(n):\n    pstr, pn, p = \"2\", prime(n), 2\n    while int(pstr)%pn != 0:\n        p = nextprime(p)\n        pstr += str(p)\n    return p\nprint([a(n) for n in range(1, 56)]) \n"}
{"sequence_id": "A090537", "text": "Least n-digit prime using digit 3 once and rest all 1, or 0 if no such prime exists.", "sequence": "3,13,113,0,11113,113111,0,11111131,111111113,0,11111111113,111113111111,0,31111111111111,0,0,11111111113111111,111111111111111131,0,11111111111111111131,131111111111111111111,0,11111111111111111311111", "code": "\nfrom sympy import isprime\ndef agen():\n  digits = 0\n  while True:\n    for i in range(digits+1):\n      t = int(\"1\"*(digits-i) + \"3\" + \"1\"*i)\n      if isprime(t): yield t; break\n    else: yield 0\n    digits += 1\ng = agen()\nprint([next(g) for i in range(23)]) \n"}
{"sequence_id": "A090572", "text": "Number of configurations of the 3-dimensional 2 X 2 X 2 sliding cube puzzle that require a minimum of n moves to be reached.", "sequence": "1,3,6,12,24,48,93,180,351,675,1191,1963,3015,3772,3732,2837,1589,572,78,18", "code": " \nmoves = lambda p, shape: moves3d(p, shape)\nprint(alst(\"-1234567\", (2, 2, 2))) \n"}
{"sequence_id": "A090573", "text": "Number of configurations of the 3-dimensional 3 X 3 X 3 sliding cube puzzle that require a minimum of n moves to be reached, starting with the empty space at one of the enclosing cube corners.", "sequence": "1,3,9,30,102,324,1029,3096,9960,30732,97932,295924,929202,2766958,8590731,25271897,77575820", "code": " \ndef moves3d(p, shape, fixed=None): \n  nxt, (n, m, r) = [], shape\n  L, z = n*m, p.find(\"-\") \n  zq, zr = divmod(z, L)\n  if zr > n - 1:  nxt.append(swap(p, z, z-n)) \n  if zr < n*m-n:  nxt.append(swap(p, z, z+n)) \n  if zr%n != 0:   nxt.append(swap(p, z, z-1)) \n  if zr%n != n-1: nxt.append(swap(p, z, z+1)) \n  if zq > 0:      nxt.append(swap(p, z, z-L)) \n  if zq < r - 1:  nxt.append(swap(p, z, z+L)) \n  return [m for m in nxt if m.find(\"-\") != fixed]\nmoves = lambda p, shape: moves3d(p, shape)\nstart, shape = \"-123456789ABCDEFGHIJKLMNOPQ\", (3, 3, 3)\nprint(alst(start, shape, maxd=12)) \n"}
{"sequence_id": "A090574", "text": "Number of configurations of the 3-dimensional 3 X 3 X 3 sliding cube puzzle that require a minimum of n moves to be reached, starting with the empty space in the center of the combination cube.", "sequence": "1,6,24,72,192,624,2004,6504,19776,62760,186000,583712,1720972,5344088,15565416,47816092,137916958", "code": " \nmoves = lambda p, shape: moves3d(p, shape)\nstart, shape = \"123456789ABCD-EFGHIJKLMNOPQ\", (3, 3, 3)\nprint(alst(start, shape, maxd=12)) \n"}
{"sequence_id": "A090575", "text": "Number of configurations of the 3-dimensional 3 X 3 X 3 sliding cube puzzle that require a minimum of n moves to be reached, starting with the empty space at the center of one of the 6 faces of the combination cube.", "sequence": "1,5,17,52,164,496,1608,5008,16024,48732,153564,460984,1437632,4263236,13150544,38498798,117497284", "code": " \nmoves = lambda p, shape: moves3d(p, shape)\nstart, shape = \"1234-56789ABCDEFGHIJKLMNOPQ\", (3, 3, 3)\nprint(alst(start, shape, maxd=12)) \n"}
{"sequence_id": "A090576", "text": "Number of configurations of the 3-dimensional 3 X 3 X 3 sliding cube puzzle that require a minimum of n moves to be reached, starting with the empty space at mid-side of one of the 12 edges of the combination cube.", "sequence": "1,4,12,40,128,412,1251,4026,12362,39624,120012,379132,1130914,3530916,10402781,32112656,93427431", "code": " \nmoves = lambda p, shape: moves3d(p, shape)\nstart, shape = \"1-23456789ABCDEFGHIJKLMNOPQ\", (3, 3, 3)\nprint(alst(start, shape, maxd=12)) \n"}
{"sequence_id": "A090577", "text": "Number of configurations of a variant of the 3-dimensional 3 X 3 X 3 sliding cube puzzle that require a minimum of n moves to be reached, starting with the empty space at one of the enclosing cube corners.", "sequence": "1,3,9,24,72,174,519,1284,3813,9300,27462,66666,195674,470886,1372946,3280224,9495005,22487511,64615934,151714911", "code": " \nmoves = lambda p, shape: moves3d(p, shape, fixed=13)\nstart, shape = \"-123456789ABCDEFGHIJKLMNOPQ\", (3, 3, 3)\nprint(alst(start, shape, maxd=14)) \n"}
{"sequence_id": "A090578", "text": "Number of configurations of a variant of the 3-dimensional 3 X 3 X 3 sliding cube puzzle that require a minimum of n moves to be reached, starting with the empty space at mid-edge of one of the 12 edges of the combination cube.", "sequence": "1,4,10,30,74,222,546,1628,3978,11810,28658,84520,203562,596520,1425924,4150232,9838116,28418002,66805554", "code": " \nmoves = lambda p, shape: moves3d(p, shape, fixed=13)\nstart, shape = \"1-23456789ABCDEFGHIJKLMNOPQ\", (3, 3, 3)\nprint(alst(start, shape, maxd=13)) \n"}
{"sequence_id": "A090693", "text": "Positive numbers n such that n^2 - 2n + 2 is a prime.", "sequence": "2,3,5,7,11,15,17,21,25,27,37,41,55,57,67,75,85,91,95,111,117,121,125,127,131,135,147,151,157,161,171,177,181,185,205,207,211,225,231,237,241,251,257,261,265,271,281,285,301,307,315,327,341,351,385,387,397", "code": "\n\nfrom itertools import accumulate\nfrom sympy import isprime\nA090693_list = [i for i,n in enumerate(accumulate(range(10**5),lambda x,y:x+2*y-3)) if i > 0 and isprime(n+2)] \n"}
{"sequence_id": "A090709", "text": "Primes whose decimal representation is a valid number in base 6 and interpreted as such is again a prime.", "sequence": "2,3,5,11,31,101,151,211,241,251,331,421,431,521,1021,1151,1231,1321,2011,2131,2311,2351,2441,2531,2551,3041,3221,3251,3301,3541,4021,4111,4201,4421,4441,4451,5011,5021,5101,5231,5441,5531,10331,11131,11311", "code": "\nfrom gmpy2 import digits, is_prime\nA090709_list = [n for n in (int(digits(d,6)) for d in range(10**6) if is_prime(d)) if is_prime(n)] \n"}
{"sequence_id": "A090781", "text": "Numbers that can be expressed as the difference of the squares of primes in just one distinct way.", "sequence": "5,16,21,24,40,45,48,96,112,117,144,160,165,192,264,280,285,288,336,352,357,504,520,525,648,816,832,837,936,952,957,1152,1344,1360,1365,1368,1440,1656,1672,1677,1752,1824,1840,1845,1872,1968,2184,2200,2205,2328", "code": "\nfrom sympy import primerange\nfrom collections import Counter\ndef aupto(limit):\n  sqps = [p*p for p in primerange(1, limit//2+1)]\n  ways = Counter(b-a for i, a in enumerate(sqps) for b in sqps[i+1:])\n  return sorted(k for k in ways if k <= limit and ways[k] == 1)\nprint(aupto(2328)) \n"}
{"sequence_id": "A090785", "text": "Numbers that can be expressed as the difference of the squares of consecutive primes in just one way.", "sequence": "5,16,24,48,240,288,360,432,648,672,720,840,888,960,1080,1128,1248,1320,1392,1488,1560,1608,1680,1728,1800,1920,2040,2088,2112,2232,2280,2400,2520,2568,2640,2808,2832,2880,3120,3240,3312,3360,3432,3672,3912,4080", "code": "\nfrom sympy import primerange\nfrom collections import Counter\ndef aupto(limit):\n  sqps = [p*p for p in primerange(1, limit//2+1)]\n  ways = Counter(sqps[i+1]-sqps[i] for i in range(len(sqps)-1))\n  return sorted(k for k in ways if k <= limit and ways[k] == 1)\nprint(aupto(4080)) \n"}
{"sequence_id": "A090850", "text": "Clark's triangle with f=6 read by row.", "sequence": "0,6,1,12,7,1,18,19,8,1,24,37,27,9,1,30,61,64,36,10,1,36,91,125,100,46,11,1,42,127,216,225,146,57,12,1,48,169,343,441,371,203,69,13,1,54,217,512,784,812,574,272,82,14,1,60,271,729,1296,1596,1386,846,354,96,15,1", "code": "\nfrom operator import add\nf = 6\nA090850_list = blist = [0]\nfor _ in range(20):\n    blist = [blist[0]+f]+list(map(add,blist[:-1],blist[1:]))+[1]\n    A090850_list.extend(blist) \n"}
{"sequence_id": "A091049", "text": "a(n) = first term which reduces to an unchanging value in n steps via repeated interpretation of a(n) as a base b+1 number where b is the largest digit of a(n).", "sequence": "1,10,15,17,18,58,72,80,88,507,683,838,1384,1807,3417,12651,18316,41841,80852,132815,388315,1182482,2202048,6408851,15438855,34630248,72141683,332386516,764388521,1867287828,5451218338,24187765577,68380483575,215445843883,677083325011", "code": "\ndef A091049(n):\n    k = 1\n    while True:\n        m1 = k\n        for i in range(n+1):\n            m2 = int(str(m1),1+max(int(d) for d in str(m1)))\n            if m1 == m2:\n                if i == n:\n                    return k\n                else:\n                    break\n            m1 = m2\n        k += 1 \n"}
{"sequence_id": "A091052", "text": "Record values in A091023.", "sequence": "1,2,13,26,205,410,3277,6554,52429,104858,838861,1677722,13421773,26843546,214748365,429496730,3435973837,6871947674,54975581389,109951162778,879609302221,1759218604442,14073748835533,28147497671066", "code": " def A091052(n): return (3*4**n-(-4)**n+2*(-1)**n+6)/20 \n"}
{"sequence_id": "A091068", "text": "a(0) = 0; for n>0, a(n) = a(n-1) - n if that is >= 0, else a(n) = a(n-1) + n - 1.", "sequence": "0,0,1,3,6,1,6,12,4,12,2,12,0,12,25,10,25,8,25,6,25,4,25,2,25,0,25,51,23,51,21,51,19,51,17,51,15,51,13,51,11,51,9,51,7,51,5,51,3,51,1,51,102,49,102,47,102,45,102,43,102,41,102,39,102,37,102,35,102,33", "code": "\nprint(\"0 0\")\ni=1\na=0\nif a-i>=0:b=a-i\nelse:b=a+i-1\nwhile i<=100:\n    print(str(i)+\" \"+str(b))\n    a=b\n    i+=1\n    if a-i>=0:b=a-i\n    else:b=a+i-1 \n"}
{"sequence_id": "A091333", "text": "Number of 1's required to build n using +, -, *, and parentheses.", "sequence": "1,2,3,4,5,5,6,6,6,7,8,7,8,8,8,8,9,8,9,9,9,10,10,9,10,10,9,10,11,10,11,10,11,11,11,10,11,11,11,11,12,11,12,12,11,12,12,11,12,12,12,12,12,11,12,12,12,13,13,12,13,13,12,12,13,13,14,13,13,13,13,12,13,13,13,13,14", "code": "\nfrom functools import cache\n@cache\ndef f(m):\n    if m == 0: return set()\n    if m == 1: return {1}\n    out = set()\n    for j in range(1, m//2+1):\n        for x in f(j):\n            for y in f(m-j):\n                out.update([x + y, x * y])\n                if x != y: out.add(abs(x-y))\n    return out\ndef aupton(terms):\n    tocover, alst, n = set(range(1, terms+1)), [0 for i in range(terms)], 1\n    while len(tocover) > 0:\n        for k in f(n) - f(n-1):\n            if k <= terms:\n                alst[k-1] = n\n                tocover.discard(k)\n        n += 1\n    return alst\nprint(aupton(77)) \n"}
{"sequence_id": "A091369", "text": "a(n) = Sum_{i=1..n} phi(i)*ceiling(n/i).", "sequence": "1,3,7,12,20,27,39,50,64,77,97,112,136,155,177,200,232,255,291,318,350,381,425,456,500,537,581,620,676,713,773,820,872,921,979,1026,1098,1153,1215,1270,1350,1403,1487,1550,1618,1685,1777,1840,1930,1999,2081,2156", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A091369(n):\n    if n == 0:\n        return 0\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(2*A091369(k1)-(k1*(k1-1)+1))\n        j, k1 = j2, n//j2\n    return n*(n-1)-(c-j)//2 \n"}
{"sequence_id": "A091444", "text": "Concatenate binary vectors ordered first by length, then by the number of 1's and finally lexicographically.", "sequence": "0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1", "code": "\nfrom itertools import product\ndef sortby(x): return (len(x), x.count(1), x)\ndef agen(maxvecdigits):\n    for i in range(1, maxvecdigits+1):\n        for t in sorted([p for p in product([0, 1], repeat=i)], key=sortby):\n            yield from t\nprint([an for an in agen(4)]) \n"}
{"sequence_id": "A091507", "text": "Product of the anti-divisors of n.", "sequence": "2,3,6,4,30,15,12,84,42,40,270,108,120,33,2310,1680,78,312,168,8100,4050,112,7140,204,11880,25080,114,960,7938,257985,17160,276,19320,192,11250,1732500,24024,11664,1458,114240,14790,696,5896800,33852,17670", "code": "\nfrom operator import mul\ndef A091507(n):\n....return reduce(mul,[d for d in range(2,n) if n%d and 2*n%d in [d-1,0,1]]) \n"}
{"sequence_id": "A091521", "text": "Number of configurations of a variant of the 3-dimensional 3 X 3 X 3 sliding cube puzzle that require a minimum of n moves to be reached, starting with the empty space at the center of one of the 6 faces of the combination cube.", "sequence": "1,4,12,28,84,212,632,1544,4584,11220,33060,80152,234648,565192,1643552,3926832,11337422,26852656,76981660", "code": " \nmoves = lambda p, shape: moves3d(p, shape, fixed=13)\nstart, shape = \"1234-56789ABCDEFGHIJKLMNOPQ\", (3, 3, 3)\nprint(alst(start, shape, maxd=13)) \n"}
{"sequence_id": "A091579", "text": "Lengths of suffix blocks associated with A090822.", "sequence": "1,3,1,9,4,24,1,3,1,9,4,67,1,3,1,9,4,24,1,3,1,9,4,196,3,1,9,4,24,1,3,1,9,4,68,3,1,9,4,24,1,3,1,9,4,581,3,1,9,4,25,3,1,9,4,67,1,3,1,9,4,24,1,3,1,9,4,196,3,1,9,4,24,1,3,1,9,4,68,3,1,9,4,24,1,3,1,9,4,1731,3,1,9,4,24", "code": "\n\ndef curl(L):\n    n = len(L)\n    m = 1 \n    k = 1 \n    while(k*(m+1) <= n):\n        good = True\n        i = 1\n        while(i <= k and good):\n            for t in range(1, m+1):\n                if L[-i-t*k] != L[-i]:\n                    good = False\n            i = i+1\n        if good:\n            m = m+1\n        else:\n            k = k+1\n    return m\n\ndef A091579_list(n):\n    Promote = [1] \n    L = [2]\n    while len(Promote) <= n:\n        c = curl(L)\n        if c < 2:\n            Promote = Promote+[len(L)+1]\n            c = 2\n        L = L+[c]\n    return [Promote[i+1]-Promote[i] for i in range(n)]\n\n"}
{"sequence_id": "A091626", "text": "Number of ordered integer pairs (b,c) with 0 <= b, c <= n such that both roots of x^2+bx+c=0 are integers.", "sequence": "1,2,4,6,9,11,14,16,19,22,25,27,31,33,36,39,43,45,49,51,55,58,61,63,68,71,74,77,81,83,88,90,94,97,100,103,109,111,114,117,122,124,129,131,135,139,142,144,150,153,157,160,164,166,171,174,179,182,185,187", "code": "\nfrom math import isqrt\ndef A091626(n):\n    m = isqrt(n)\n    return 1 if n == 0 else n+sum(n//k for k in range(1, m+1))-m*(m-1)//2 \n"}
{"sequence_id": "A091627", "text": "Number of ordered integer pairs (b,c) with 1 <= b,c <= n such that both roots of x^2+bx+c=0 are integers.", "sequence": "0,0,1,2,4,5,7,8,10,12,14,15,18,19,21,23,26,27,30,31,34,36,38,39,43,45,47,49,52,53,57,58,61,63,65,67,72,73,75,77,81,82,86,87,90,93,95,96,101,103,106,108,111,112,116,118,122,124,126,127,133,134,136,139,143", "code": "\nfrom math import isqrt\ndef A091627(n):\n    m = isqrt(n)\n    return 0 if n == 0 else sum(n//k for k in range(1, m+1))-m*(m-1)//2-1 \n"}
{"sequence_id": "A091634", "text": "Number of primes less than 10^n which do not contain the digit 0.", "sequence": "4,25,153,1010,7122,52313,397866,3103348,24649318,198536215,1616808581,13287264748,110033428309,917072930187", "code": "\nfrom sympy import sieve \ndef nodigs0(n): return '0' not in str(n)\ndef aupton(terms):\n  ps, alst = 0, []\n  for n in range(1, terms+1):\n    ps += sum(nodigs0(p) for p in sieve.primerange(10**(n-1), 10**n))\n    alst.append(ps)\n  return alst\nprint(aupton(7)) \n"}
{"sequence_id": "A091635", "text": "Number of primes less than 10^n which do not contain the digit 1.", "sequence": "4,17,101,670,4675,34425,262549,2051466,16312743,131464721,1071368863,8809580516,72986908554,608542410004", "code": "\nfrom sympy import sieve \ndef a(n): return sum('1' not in str(p) for p in sieve.primerange(1, 10**n))\nprint([a(n) for n in range(1, 8)]) \n"}
{"sequence_id": "A091636", "text": "Number of primes less than 10^n which do not contain the digit 2.", "sequence": "3,22,139,877,6235,46105,352155,2747284,21831323,175881412,1432781905,11778245565,97558533214,813253056497", "code": "\nfrom sympy import primerange\ndef a(n): return sum('2' not in str(p) for p in primerange(2, 10**n))\nprint([a(n) for n in range(1, 7)]) \n"}
{"sequence_id": "A091637", "text": "Number of primes less than 10^n which do not contain the digit 3.", "sequence": "3,16,102,668,4715,34813,265015,2067152,16413535,132200223,1076692515,8849480283,73288053795,610860050965", "code": "\nfrom sympy import primerange\ndef a(n): return sum('3' not in str(p) for p in primerange(2, 10**n))\nprint([a(n) for n in range(1, 7)]) \n"}
{"sequence_id": "A091639", "text": "Number of primes less than 10^n which do not contain the digit 5.", "sequence": "3,22,136,905,6310,46549,354910,2765749,21955845,176781643,1439380189,11827571824,97933795005,816144146010", "code": "\nfrom sympy import primerange\ndef a(n): return sum('5' not in str(p) for p in primerange(2, 10**n))\nprint([a(n) for n in range(1, 7)]) \n"}
{"sequence_id": "A091640", "text": "Number of primes less than 10^n which do not contain the digit 6.", "sequence": "4,23,136,897,6367,46706,355148,2770239,21984207,176966593,1440765209,11838096715,98014747908,816769206831", "code": "\nfrom sympy import sieve \ndef a(n): return sum('6' not in str(p) for p in sieve.primerange(2, 10**n))\nprint([a(n) for n in range(1, 8)]) \n"}
{"sequence_id": "A091641", "text": "Number of primes less than 10^n which do not contain the digit 7.", "sequence": "3,16,100,680,4773,34992,266823,2079512,16503238,132852644,1081509855,8885472675,73563855306,612982476612", "code": "\nfrom sympy import primerange\ndef a(n): return sum('7' not in str(p) for p in primerange(2, 10**n))\nprint([a(n) for n in range(1, 7)]) \n"}
{"sequence_id": "A091642", "text": "Number of primes less than 10^n which do not contain the digit 8.", "sequence": "4,23,141,915,6375,46799,355805,2774348,22023132,177273427,1443074791,11855541525,98146301284,817786989282", "code": "\nfrom sympy import sieve \ndef a(n): return sum('8' not in str(p) for p in sieve.primerange(2, 10**n))\nprint([a(n) for n in range(1, 8)]) \n"}
{"sequence_id": "A091644", "text": "Number of primes less than 10^n which have at least one digit 0.", "sequence": "0,0,15,219,2470,26185,266713,2658107,26198216,256516296,2501246232,24320647270,236032108530,2287868820615", "code": "\nfrom sympy import sieve \ndef digs0(n): return '0' in str(n)\ndef aupton(terms):\n  ps, alst = 0, []\n  for n in range(1, terms+1):\n    ps += sum(digs0(p) for p in sieve.primerange(10**(n-1), 10**n))\n    alst.append(ps)\n  return alst\nprint(aupton(7)) \n"}
{"sequence_id": "A091685", "text": "Sieve out 6n+1 and 6n-1.", "sequence": "0,1,0,0,0,5,0,7,0,0,0,11,0,13,0,0,0,17,0,19,0,0,0,23,0,25,0,0,0,29,0,31,0,0,0,35,0,37,0,0,0,41,0,43,0,0,0,47,0,49,0,0,0,53,0,55,0,0,0,59,0,61,0,0,0,65,0,67,0,0,0,71,0,73,0,0,0,77,0,79,0,0,0,83,0,85,0,0,0,89,0", "code": "\nfrom sympy import gcd\ndef a(n): return n if gcd(n, 6) == 1 else 0\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A091707", "text": "Number of primes less than 10^n having at least one digit 6.", "sequence": "0,2,32,332,3225,31792,309431,2991216,28863327,278085918,2677289604,25769815303,248050788931,2388172543971", "code": "\nfrom sympy import sieve \ndef a(n): return sum('6' in str(p) for p in sieve.primerange(2, 10**n))\nprint([a(n) for n in range(1, 8)]) \n"}
{"sequence_id": "A091709", "text": "Number of primes less than 10^n having at least one digit 8.", "sequence": "0,2,27,314,3217,31699,308774,2987107,28824402,277779084,2674980022,25752370493,247919235555,2387154761520", "code": "\nfrom sympy import sieve \ndef a(n): return sum('8' in str(p) for p in sieve.primerange(2, 10**n))\nprint([a(n) for n in range(1, 8)]) \n"}
{"sequence_id": "A091818", "text": "Sum of even proper divisors of 2n. Sum of the even divisors of 2n that are less than 2n.", "sequence": "0,2,2,6,2,12,2,14,8,16,2,32,2,20,18,30,2,42,2,44,22,28,2,72,12,32,26,56,2,84,2,62,30,40,26,110,2,44,34,100,2,108,2,80,66,52,2,152,16,86,42,92,2,132,34,128,46,64,2,216,2,68,82,126,38,156,2,116", "code": "\nfrom sympy import divisors\ndef a(n): return sum(d for d in divisors(2*n) if d%2==0) - 2*n\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A091932", "text": "Primes that remain prime when their leading digit in binary representation is replaced by 0.", "sequence": "7,11,13,19,23,29,37,43,61,67,71,83,101,107,131,139,151,157,181,199,211,229,241,263,269,293,317,353,359,383,419,449,467,479,523,541,571,601,613,619,643,661,691,709,739,751,769,823,829,859,991,1021,1031,1061", "code": "\nfrom sympy import isprime, primerange\ndef ok(p): return isprime((1 << (p.bit_length()-1)) ^ p)\ndef aupto(lim): return [p for p in primerange(1, lim+1) if ok(p)]\nprint(aupto(1061)) \n"}
{"sequence_id": "A091938", "text": "Smallest prime between 2^n and 2^(n+1), having a maximal number of 1's in binary representation.", "sequence": "3,7,11,31,47,127,191,383,991,2039,3583,8191,15359,20479,63487,131071,245759,524287,786431,1966079,4128767,7323647,14680063,33546239,67108351,100646911,260046847,536739839,1073479679,2147483647", "code": "\nfrom sympy import isprime\nfrom sympy.utilities.iterables import multiset_permutations\ndef A091938(n):\n    for i in range(n,-1,-1):\n        q = 2**n\n        for d in multiset_permutations('0'*(n-i)+'1'*i):\n            p = q+int(''.join(d),2)\n            if isprime(p):\n                return p \n"}
{"sequence_id": "A092149", "text": "Partial sums of A092673.", "sequence": "1,-1,-2,-1,-2,0,-1,-1,-1,1,0,-1,-2,0,1,1,0,0,-1,-2,-1,1,0,0,0,2,2,1,0,-2,-3,-3,-2,0,1,1,0,2,3,3,2,0,-1,-2,-2,0,-1,-1,-1,-1,0,-1,-2,-2,-1,-1,0,2,1,2,1,3,3,3,4,2,1,0,1,-1,-2,-2,-3,-1,-1,-2,-1,-3,-4,-4,-4,-2,-3,-2,-1,1,2,2,1,1,2,1,2,4,5,5,4,4,4,4,3,1,0,0,-1,1", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A092149(n):\n    if n == 1:\n        return 1\n    c, j = n+1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A092149(k1)\n        j, k1 = j2, n//j2\n    return j-c \n"}
{"sequence_id": "A092221", "text": "Numbers k such that numerator of Bernoulli(2*k) is divisible by 59, the second irregular prime.", "sequence": "22,51,59,80,109,118,138,167,177,196,225,236,254,283,295,312,341,354,370,399,413,428,457,472,486,515,531,544,573,590,602,631,649,660,689,708,718,747,767,776,805,826,834,863,885,892,921,944,950,979,1003,1008", "code": "\nfrom sympy import bernoulli\nA092221_list = [n for n in range(10**3) if not bernoulli(2*n).p % 59] \n"}
{"sequence_id": "A092245", "text": "Lesser of the first twin prime pair with n digits.", "sequence": "3,11,101,1019,10007,100151,1000037,10000139,100000037,1000000007,10000000277,100000000817,1000000000061,10000000001267,100000000000097,1000000000002371,10000000000001549,100000000000000019", "code": "\nimport sympy\nfor i in range(100):\n    p=sympy.nextprime(10**i)\n    while not sympy.isprime(p+2):\n        p=sympy.nextprime(p)\n    print(p)\n\n"}
{"sequence_id": "A092248", "text": "Parity of number of distinct primes dividing n (function omega(n)) parity of A001221.", "sequence": "0,1,1,1,1,0,1,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,0,1,0,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1", "code": "\nfrom sympy import primefactors\ndef a(n): return 0 if n==1 else 1*(len(primefactors(n))%2==1) \n"}
{"sequence_id": "A092679", "text": "Numbers k such that 3*2^k has only one anti-divisor.", "sequence": "0,1,5,17", "code": "\nA092679 = [i for i,n in enumerate(map(lambda x:3*2**x,range(20))) if len([d for d in range(2,n,2) if n%d and not 2*n%d]+[d for d in range(3,n,2) if n%d and 2*n%d in [d-1,1]])==1] \n"}
{"sequence_id": "A092911", "text": "Numbers all of whose divisors can be formed using their digits. Divisor digits are a subset of the digits of the number.", "sequence": "1,11,13,17,19,31,41,61,71,101,103,107,109,113,121,125,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,241,251,271,281,311,313,317,331,401,419,421,431,461,491,521,541,571", "code": "\nfrom sympy import divisors\nfrom collections import Counter\ndef ok(n):\n  ncounts = Counter(str(n))\n  for d in divisors(n)[:-1]:\n    divcounts = Counter(str(d))\n    if any(ncounts[c] < divcounts[c] for c in divcounts): return False\n  return True\nprint(list(filter(ok, range(1, 630)))) \n"}
{"sequence_id": "A093005", "text": "a(n) = n * ceiling(n/2).", "sequence": "1,2,6,8,15,18,28,32,45,50,66,72,91,98,120,128,153,162,190,200,231,242,276,288,325,338,378,392,435,450,496,512,561,578,630,648,703,722,780,800,861,882,946,968,1035,1058,1128,1152,1225,1250,1326,1352,1431,1458", "code": "\nfor n in range(1,55):\n    print(n*((n+1)//2), end=\",\")   \n"}
{"sequence_id": "A093324", "text": "a(n) is the smallest natural number m such that n^m + m is prime.", "sequence": "2,1,1,2,1,7954,1,34,101,2,1", "code": "\nfrom sympy import isprime\ndef a(n):\n  m = 0\n  while not isprime(n**m + m): m += 1\n  return m\nfor n in range(11):\n  print(a(n), end=\", \") \n"}
{"sequence_id": "A093502", "text": "a(1) = 2; for n > 0, a(n+1) is the a(n)-th prime after a(n).", "sequence": "2,5,19,103,733,6691,76831,1081429,18242699,361919671,8309068723,217809953467,6445388418589,213232943658197,7821073506524401,315743571062703689", "code": "\nfrom sympy import prime\np, q = 2, 1\nA093502_list = [p]\nfor _ in range(15):\n    r = p + q\n    p, q = prime(r), r\n    A093502_list.append(p) \n"}
{"sequence_id": "A093515", "text": "Numbers k such that either k or k-1 is a prime.", "sequence": "2,3,4,5,6,7,8,11,12,13,14,17,18,19,20,23,24,29,30,31,32,37,38,41,42,43,44,47,48,53,54,59,60,61,62,67,68,71,72,73,74,79,80,83,84,89,90,97,98,101,102,103,104,107,108,109,110,113,114,127,128,131,132,137,138,139", "code": "\nfrom sympy import isprime\ndef ok(n): return isprime(n) or isprime(n-1)\nprint(list(filter(ok, range(140)))) \n"}
{"sequence_id": "A093548", "text": "a(n) is the smallest number m such that each of the numbers m and m+1 has n distinct prime divisors.", "sequence": "2,14,230,7314,254540,11243154,965009045,65893166030,5702759516090,490005293940084,76622240600506314", "code": "\nfrom sympy import primefactors, primorial\ndef a(n):\n  m = primorial(n)\n  while True:\n    if len(primefactors(m)) == n:\n      if len(primefactors(m+1)) == n: return m\n      else: m += 2\n    else: m += 1\nfor n in range(1, 6):\n  print(a(n), end=\", \") \n"}
{"sequence_id": "A093683", "text": "Number of pairs of twin primes <= 10^n-th prime.", "sequence": "4,25,174,1270,10250,86027,738597,6497407,58047180,524733511", "code": "\nfrom sympy import prime, sieve \ndef afind(terms):\n  c, prevp = 0, 1\n  for n in range(1, terms+1):\n    for p in sieve.primerange(prevp+1, prime(10**n)+1):\n      if prevp == p - 2: c += 1\n      prevp = p\n    print(c, end=\", \")\nafind(6) \n"}
{"sequence_id": "A093685", "text": "In binary representation: numbers not occurring in their factorial.", "sequence": "0,5,11,13,15,17,31,37,55,81,164,395,513,517,619,1041,1287,1538,2108,2116,2137,2138,2282,2352,2363,2432,2466,2524,4278,4511,4758,4766,4852,4854,5136,5586,8396,8463,8883,9707,10351,16528,17279,19469,21244,24472", "code": "\ndef aupto(limit):\n  kfact, alst = 1, [0]\n  for k in range(1, limit+1):\n    kb, kfact = bin(k)[2:], kfact * k\n    kfactb = bin(kfact)[2:]\n    if kb not in kfactb: alst.append(k)\n  return alst\nprint(aupto(25000)) \n"}
{"sequence_id": "A093694", "text": "Number of one-element transitions from the partitions of n to the partitions of n+1 for labeled parts.", "sequence": "1,2,5,9,17,27,46,69,108,158,234,331,476,657,915,1244,1694,2262,3029,3988,5257,6844,8901,11461,14749,18809,23958,30304,38263,48018,60167,74977,93276,115509,142772,175759,215991,264449,323216,393772,478884", "code": "\nfrom sympy import divisor_count, npartitions\ndef a(n): return npartitions(n) + sum([divisor_count(m)*npartitions(n - m) for m in range(1, n + 1)]) \n"}
{"sequence_id": "A093826", "text": "In binary representation: least number, k, which occurs n times in its factorial.", "sequence": "5,1,16,12,49,58,60,110,209,117,240,430,255,1423,921,980,511,1847,3737,3692,3998,7265,15267,15651,15722,31457,32659,64248,57927,64448,64171,250068,129013,501578,256159,510732,980930,979883", "code": "\nfrom itertools import count, takewhile\ndef count_overlaps(subs, s):\n  c = i = 0\n  while i != -1:\n    i = s.find(subs, i)\n    if i != -1: c += 1; i += 1\n  return c\ndef afind(limit):\n  kfact, adict = 1, dict()\n  for k in range(1, limit+1):\n    kb, kfact = bin(k)[2:], kfact * k\n    kfactb = bin(kfact)[2:]\n    n = count_overlaps(kb, kfactb)\n    if n not in adict: adict[n] = k\n  return [adict[n] for n in takewhile(lambda i: i in adict, count(0))]\nprint(afind(16000))  \n"}
{"sequence_id": "A093914", "text": "a(1) = 1; for n > 1, a(n) = curling number of (b(1),...,b(n-1)), where b() = Thue-Morse sequence A010060 (with offset changed to 1).", "sequence": "1,1,1,2,1,1,2,2,1,2,1,2,2,1,2,2,1,2,2,2,1,2,2,2,2,2,1,2,2,1,2,2,1,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,1,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,2,2", "code": "\np, tm, s = 8, 0, 1\nfor i in range(p):\n    tm += (tm^((1<<s)-1))<<s\n    s *= 2\nprint(1)\nfor i in range(1, 1<<p):\n    a = any(((tm>>(i-j))&((1<<j)-1)) == ((tm>>(i-2*j))&((1<<j)-1)) for j in range(1, i//2+1))\n    print(2 if a else 1)\n\n"}
{"sequence_id": "A094186", "text": "Taking a(1)=0 and a(2)=1, sequence (a(n))n>1 is defined as follows : letting w(k)=a(1)a(2)...a(k) and w(infinity)= limit k ->infinity a(1)a(2)w(1)w(2)...w(k) we have w(infinity)=a(1)a(2)a(3)a(4)...", "sequence": "0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,1,0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,0,1,0,0,1,0,1,0,0,1,0,0", "code": "\nTOP = 1000\na = [0]*TOP\na[1] = 1\nn = 2\nk = 1\nwhile n+k < TOP:\n  a[n:] = a[:k]\n  n += k\n  k += 1\nfor k in range(n):\n  print(a[k], end=\", \")\n\n"}
{"sequence_id": "A094202", "text": "Integers k whose Zeckendorf representation A014417(k) is palindromic.", "sequence": "0,1,4,6,9,12,14,22,27,33,35,51,56,64,74,80,88,90,116,127,145,158,174,184,197,203,216,232,234,276,294,326,368,378,399,425,441,462,472,493,519,525,546,572,588,609,611,679,708,760,828,847,915,944,988,1022,1064,1090", "code": "\nfrom sympy import fibonacci\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef ok(n):\n    x=str(a(n))\n    return x==x[::-1]\nprint([n for n in range(1101) if ok(n)]) \n"}
{"sequence_id": "A094577", "text": "Central Peirce numbers. Number of set partitions of {1,2,..,2n+1} in which n+1 is the smallest of its block.", "sequence": "1,3,27,409,9089,272947,10515147,501178937,28773452321,1949230218691,153281759047387,13806215066685433,1408621900803060705,161278353358629226675,20555596673435403499083,2896227959507289559616217,448371253145121338801335489", "code": "\n\nfrom itertools import accumulate\nA094577_list, blist, b = [1], [1], 1\nfor n in range(2,502):\n....blist = list(accumulate([b]+blist))\n....b = blist[-1]\n....blist = list(accumulate([b]+blist))\n....b = blist[-1]\n....A094577_list.append(blist[-n])\n\n"}
{"sequence_id": "A094591", "text": "a(0) = 1; a(n) = n + (largest element of {a} <= n).", "sequence": "1,2,4,5,8,10,11,12,16,17,20,22,24,25,26,27,32,34,35,36,40,41,44,45,48,50,52,54,55,56,57,58,64,65,68,70,72,73,74,75,80,82,83,84,88,90,91,92,96,97,100,101,104,105,108,110,112,114,116,117,118,119,120,121,128,130", "code": "\ndef aupton(nn):\n    alst = [1]\n    for n in range(1, nn+1):\n        alst.append(n + max(k for k in alst if k <= n))\n    return alst\nprint(aupton(65)) \n"}
{"sequence_id": "A094593", "text": "a(n) = (p-1)/x, where p = prime(n) and x = ord(3,p), the smallest positive integer such that 3^x == 1 mod p.", "sequence": "1,1,2,4,1,1,2,1,1,2,5,1,2,1,2,6,3,2,6,1,2,1,2,1,3,2,4,1,1,2,1,1,1,3,2,1,2,1,2,4,2,12,1,1,1,1,2,4,1,2,2,2,1,2,1,9,4,1,1,1,9,2,8,1,1,2,2,2,1,2,3,2,1,2,1,2,1,2,2,4,10,16,3,2,1,2", "code": "\nfrom sympy import prime, n_order\ndef A094593(n):\n    p = prime(n)\n    return 1 if n == 3 else (p-1)//n_order(3,p) \n"}
{"sequence_id": "A094669", "text": "Number of halving and tripling steps for 10^n to reach 1 in '3x+1' problem.", "sequence": "6,25,111,29,128,152,145,107,100,124,347,146,289,194,275,255,235,303,340,470,357,324,454,266,564,433,470,331,492,467,584,515,614,550,711,497,653,1039,577,694,749,755,779,666,752,913,769,754,724,691,883,827,683", "code": "\ndef f(x): return x//2 if x%2 == 0 else 3*x + 1\ndef a(n):\n    i, c = 10**n, 0\n    while i != 1: i, c = f(i), c+1\n    return c\nprint([a(n) for n in range(1, 54)]) \n"}
{"sequence_id": "A094683", "text": "Juggler sequence: if n mod 2 = 0 then floor(sqrt(n)) else floor(n^(3/2)).", "sequence": "0,1,1,5,2,11,2,18,2,27,3,36,3,46,3,58,4,70,4,82,4,96,4,110,4,125,5,140,5,156,5,172,5,189,5,207,6,225,6,243,6,262,6,281,6,301,6,322,6,343,7,364,7,385,7,407,7,430,7,453,7,476,7,500,8,524,8,548,8,573,8,598,8,623,8,649", "code": "\nimport math\nfrom sympy import sqrt\ndef a(n): return int(math.floor(sqrt(n))) if n%2 == 0 else int(math.floor(n**(3/2)))\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A094685", "text": "Modified juggler sequence: if n mod 2 = 0 then round(sqrt(n)) else round(n^(3/2)).", "sequence": "0,1,1,5,2,11,2,19,3,27,3,36,3,47,4,58,4,70,4,83,4,96,5,110,5,125,5,140,5,156,5,173,6,190,6,207,6,225,6,244,6,263,6,282,7,302,7,322,7,343,7,364,7,386,7,408,7,430,8,453,8,476,8,500,8,524,8,548,8,573,8,598,8,624,9,650", "code": "\nfrom gmpy2 import isqrt_rem\ndef A094685(n):\n    i, j = isqrt_rem(n**3 if n % 2 else n)\n    return int(i+ int(4*(j-i) >= 1)) \n"}
{"sequence_id": "A094709", "text": "Smallest k such that prime(n)# - k and prime(n)# + k are primes, where prime(n)# = A002110(n).", "sequence": "0,1,1,13,1,17,59,23,79,101,83,239,71,149,367,73,911,313,373,523,313,331,197,101,1493,523,293,577,2699,1481,1453,5647,647,419,757,4253,509,239,10499,191,4013,2659,617,6733,1297,971", "code": "\nfrom sympy import isprime, prime, primerange\ndef aupton(terms):\n  phash, alst = 2, [0]\n  for p in primerange(3, prime(terms)+1):\n    phash *= p\n    for k in range(1, phash//2):\n      if isprime(phash-k) and isprime(phash+k): alst.append(k); break\n  return alst\nprint(aupton(46)) \n"}
{"sequence_id": "A094710", "text": "Smaller of a pair (p,q) of primes with (p+q)/2=prime(n)# and q-p is minimal.", "sequence": "5,29,197,2309,30013,510451,9699667,223092791,6469693129,200560490047,7420738134571,304250263527139,13082761331669881,614889782588491043,32589158477190044657,1922760350154212638159,117288381359406970982957,7858321551080267055878717,557940830126698960967414867", "code": "\nfrom sympy import isprime, prime, primerange\ndef aupton(terms):\n  phash, alst = 2, []\n  for p in primerange(3, prime(terms)+1):\n    phash *= p\n    for k in range(1, phash//2):\n      if isprime(phash-k) and isprime(phash+k): alst.append(phash-k); break\n  return alst\nprint(aupton(20)) \n"}
{"sequence_id": "A094711", "text": "Larger of a pair (p,q) of primes with (p+q)/2=prime(n)# and q-p is minimal.", "sequence": "7,31,223,2311,30047,510569,9699713,223092949,6469693331,200560490213,7420738135049,304250263527281,13082761331670179,614889782588491777,32589158477190044803,1922760350154212639981,117288381359406970983583", "code": "\nfrom sympy import isprime, prime, primerange\ndef aupton(terms):\n  phash, alst = 2, []\n  for p in primerange(3, prime(terms)+1):\n    phash *= p\n    for k in range(1, phash//2):\n      if isprime(phash-k) and isprime(phash+k): alst.append(phash+k); break\n  return alst\nprint(aupton(18)) \n"}
{"sequence_id": "A095050", "text": "Numbers such that all ten digits are needed to write all positive divisors in decimal representation.", "sequence": "108,216,270,304,306,312,324,360,380,406,432,450,504,540,570,608,612,624,630,648,654,702,708,714,720,728,756,760,780,810,812,864,870,900,910,912,918,924,936,945,954,972,980,1008,1014,1026,1032,1036,1038", "code": "\nfrom sympy import divisors\ndef ok(n):\n    digits_used = set()\n    for d in divisors(n):\n        digits_used |= set(str(d))\n    return len(digits_used) == 10\nprint([k for k in range(1040) if ok(k)]) \n"}
{"sequence_id": "A095070", "text": "One-bit dominant primes, i.e., primes whose binary expansion contains more 1's than 0's.", "sequence": "3,5,7,11,13,19,23,29,31,43,47,53,59,61,71,79,83,89,101,103,107,109,113,127,151,157,167,173,179,181,191,199,211,223,227,229,233,239,241,251,271,283,307,311,313,317,331,347,349,359,367,373,379,383", "code": "\n\nfrom sympy import isprime\ni=1\nj=1\nwhile j<=200:\n    if isprime(i) and bin(i)[2:].count(\"1\")>bin(i)[2:].count(\"0\"):\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A095071", "text": "Zero-bit dominant primes, i.e., primes whose binary expansion contains more 0's than 1's.", "sequence": "17,67,73,97,131,137,193,257,263,269,277,281,293,337,353,389,401,449,521,523,547,577,593,641,643,673,769,773,1031,1033,1039,1049,1051,1061,1063,1069,1091,1093,1097,1109,1123,1129,1153,1163,1171", "code": "\n\nfrom sympy import isprime\ni=1\nj=1\nwhile j<=200:\n    if isprime(i) and bin(i)[2:].count(\"0\")>bin(i)[2:].count(\"1\"):\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A095072", "text": "Primes in whose binary expansion the number of 0-bits is one more than the number of 1-bits.", "sequence": "17,67,73,97,263,269,277,281,293,337,353,389,401,449,1039,1051,1063,1069,1109,1123,1129,1163,1171,1187,1193,1201,1249,1291,1301,1321,1361,1543,1549,1571,1609,1667,1669,1697,1801,4127,4157,4211,4217", "code": "\n\nfrom sympy import isprime\ni=1\nj=1\nwhile j<=200:\n    if isprime(i) and bin(i)[2:].count(\"0\")-bin(i)[2:].count(\"1\")==1:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A095073", "text": "Primes in whose binary expansion the number of 1-bits is one more than the number of 0-bits.", "sequence": "5,19,71,83,89,101,113,271,283,307,313,331,397,409,419,421,433,457,1103,1117,1181,1223,1229,1237,1303,1307,1319,1381,1427,1429,1433,1481,1489,1559,1579,1607,1613,1619,1621,1637,1699,1733,1811,1861", "code": "\nfrom sympy import isprime\ni=1\nj=1\nwhile j<=25000:\n    if isprime(i) and bin(i)[2:].count(\"1\")-bin(i)[2:].count(\"0\")==1:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A095074", "text": "Primes in whose binary expansion the number of 0-bits is less than or equal to number of 1-bits.", "sequence": "2,3,5,7,11,13,19,23,29,31,37,41,43,47,53,59,61,71,79,83,89,101,103,107,109,113,127,139,149,151,157,163,167,173,179,181,191,197,199,211,223,227,229,233,239,241,251,271,283,307,311,313,317,331,347", "code": "\nfrom sympy import isprime\ni=1\nj=1\nwhile j<=25000:\n    if isprime(i) and bin(i)[2:].count(\"0\")<=bin(i)[2:].count(\"1\"):\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A095075", "text": "Primes in whose binary expansion the number of 1-bits is less than or equal to number of 0-bits.", "sequence": "2,17,37,41,67,73,97,131,137,139,149,163,193,197,257,263,269,277,281,293,337,353,389,401,449,521,523,541,547,557,563,569,577,587,593,601,613,617,641,643,647,653,659,661,673,677,709,769,773,787", "code": "\nfrom sympy import isprime\ni=1\nj=1\nwhile j<=250:\n    if isprime(i) and bin(i)[2:].count(\"1\")<=bin(i)[2:].count(\"0\"):\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A095076", "text": "Parity of 1-fibits in Zeckendorf expansion A014417(n).", "sequence": "0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,1,0", "code": "\ndef ok(n): return True if n==0 else n*(2*n & n == 0)\nprint([bin(n)[2:].count(\"1\")%2 for n in range(1001) if ok(n)]) \n"}
{"sequence_id": "A095080", "text": "Fibeven primes, i.e., primes p whose Zeckendorf-expansion A014417(p) ends with zero.", "sequence": "2,3,5,7,11,13,23,29,31,37,41,47,71,73,79,83,89,97,107,109,113,131,139,149,151,157,167,173,181,191,193,199,223,227,233,241,251,257,269,277,283,293,311,317,337,353,359,367,379,397,401,409,419,421", "code": "\nfrom sympy import fibonacci, primerange\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef ok(n):\n    return str(a(n))[-1]==\"0\"\nprint([n for n in primerange(1, 1001) if ok(n)]) \n"}
{"sequence_id": "A095081", "text": "Fibodd primes, i.e., primes p whose Zeckendorf-expansion A014417(p) ends with one.", "sequence": "17,19,43,53,59,61,67,101,103,127,137,163,179,197,211,229,239,263,271,281,307,313,331,347,349,373,383,389,433,449,457,467,491,499,509,569,577,593,601,619,643,653,661,677,739,773,787,797,821,823", "code": "\nfrom sympy import fibonacci, primerange\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef ok(n):\n    return str(a(n))[-1]==\"1\"\nprint([n for n in primerange(1, 1001) if ok(n)]) \n"}
{"sequence_id": "A095082", "text": "Fib00 primes, i.e., primes p whose Zeckendorf-expansion A014417(p) ends with two zeros.", "sequence": "3,5,11,13,29,37,47,71,73,79,89,97,107,113,131,139,149,157,173,181,191,199,223,233,241,251,257,283,293,317,359,367,401,409,419,443,461,479,487,503,521,547,563,571,587,613,631,647,673,683,691,733", "code": "\nfrom sympy import fibonacci, primerange\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef ok(n): return str(a(n))[-2:]==\"00\"\nprint([n for n in primerange(1, 1001) if ok(n)]) \n"}
{"sequence_id": "A095083", "text": "Fibodious primes, i.e., primes p whose Zeckendorf-expansion A014417(p) contains an odd number of 1-fibits.", "sequence": "2,3,5,13,17,19,31,41,43,59,61,71,73,79,89,103,107,113,131,151,167,173,179,181,191,197,211,227,229,233,239,251,257,269,293,307,313,347,349,353,367,383,401,419,431,433,449,457,463,467,479,487,491", "code": "\nfrom sympy import fibonacci, primerange\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef ok(n): return str(a(n)).count(\"1\")%2\nprint([n for n in primerange(1, 1001) if ok(n)]) \n"}
{"sequence_id": "A095085", "text": "Fib000 primes, i.e., primes p whose Zeckendorf-expansion A014417(p) ends with three zeros.", "sequence": "5,13,29,47,73,89,97,107,131,149,157,173,191,199,233,241,251,293,317,419,461,479,487,521,547,563,631,673,683,691,733,751,809,827,877,911,919,937,953,971,1013,1021,1039,1063,1097,1123,1249,1259", "code": "\nfrom sympy import fibonacci, primerange\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef ok(n): return str(a(n))[-3:]==\"000\"\nprint([n for n in primerange(1, 1261) if ok(n)]) \n"}
{"sequence_id": "A095086", "text": "Fib001 primes, i.e., primes p whose Zeckendorf-expansion A014417(p) ends with two zeros and final 1.", "sequence": "19,43,53,61,103,137,163,179,197,229,239,263,281,307,331,349,383,433,467,509,569,577,619,653,739,773,797,823,839,857,883,907,941,967,1009,1051,1061,1069,1103,1129,1153,1171,1187,1213,1229,1289", "code": "\nfrom sympy import fibonacci, primerange\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef ok(n): return str(a(n))[-3:]==\"001\"\nprint([n for n in primerange(1, 1301) if ok(n)]) \n"}
{"sequence_id": "A095087", "text": "Fib010 primes, i.e., primes p whose Zeckendorf-expansion A014417(p) ends with zero, one and zero.", "sequence": "7,23,31,41,83,109,151,167,193,227,269,277,311,337,353,379,397,421,431,439,463,523,541,557,599,607,617,641,659,701,709,719,727,743,761,769,811,829,853,863,887,929,947,997,1031,1049,1091,1117,1151", "code": "\nfrom sympy import fibonacci, primerange\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef ok(n): return str(a(n))[-3:]==\"010\"\nprint([n for n in primerange(1, 1201) if ok(n)]) \n"}
{"sequence_id": "A095088", "text": "Fib100 primes, i.e., primes p whose Zeckendorf-expansion A014417(p) ends with one and two final zeros.", "sequence": "3,11,37,71,79,113,139,181,223,257,283,359,367,401,409,443,503,571,587,613,647,757,859,977,1019,1087,1163,1181,1223,1231,1291,1307,1367,1409,1451,1511,1553,1579,1613,1621,1663,1697,1723,1867,1901", "code": "\nfrom sympy import fibonacci, primerange\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef ok(n): return str(a(n)).endswith(\"100\")\nprint([n for n in primerange(1, 2001) if ok(n)]) \n"}
{"sequence_id": "A095089", "text": "Fib101 primes, i.e., primes p whose Zeckendorf-expansion A014417(p) ends as one, zero, one.", "sequence": "17,59,67,101,127,211,271,313,347,373,389,449,457,491,499,593,601,643,661,677,787,821,881,983,991,1033,1093,1109,1237,1279,1321,1381,1423,1499,1559,1567,1601,1609,1669,1753,1787,1847,1889,1931,1999", "code": "\nfrom sympy import fibonacci, primerange\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef ok(n): return str(a(n))[-3:]==\"101\"\nprint([n for n in primerange(1, 2001) if ok(n)]) \n"}
{"sequence_id": "A095097", "text": "Fib000 numbers: those n for which the Zeckendorf expansion A014417(n) ends with three zeros.", "sequence": "8,13,18,21,26,29,34,39,42,47,52,55,60,63,68,73,76,81,84,89,94,97,102,107,110,115,118,123,128,131,136,141,144,149,152,157,162,165,170,173,178,183,186,191,196,199,204,207,212,217,220,225,228,233,238,241,246", "code": "\nfrom sympy import fibonacci\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef ok(n): return 1 if str(a(n))[-3:]==\"000\" else 0 \n"}
{"sequence_id": "A095098", "text": "Fib001 numbers: those n for which the Zeckendorf expansion A014417(n) ends with two zeros and a final one.", "sequence": "6,9,14,19,22,27,30,35,40,43,48,53,56,61,64,69,74,77,82,85,90,95,98,103,108,111,116,119,124,129,132,137,142,145,150,153,158,163,166,171,174,179,184,187,192,197,200,205,208,213,218,221,226,229,234,239,242", "code": "\nfrom sympy import fibonacci\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef ok(n): return str(a(n))[-3:]==\"001\"\nprint([n for n in range(1, 501) if ok(n)]) \n"}
{"sequence_id": "A095111", "text": "One minus the parity of 1-fibits in Zeckendorf expansion A014417(n).", "sequence": "1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1", "code": "\ndef ok(n): return 1 if n==0 else n*(2*n & n == 0)\nprint([1 - bin(n)[2:].count(\"1\")%2 for n in range(1001) if ok(n)]) \n"}
{"sequence_id": "A095117", "text": "a(n) = pi(n) + n, where pi(n) = A000720(n) is the number of primes <= n.", "sequence": "0,1,3,5,6,8,9,11,12,13,14,16,17,19,20,21,22,24,25,27,28,29,30,32,33,34,35,36,37,39,40,42,43,44,45,46,47,49,50,51,52,54,55,57,58,59,60,62,63,64,65,66,67,69,70,71,72,73,74,76,77,79,80,81,82,83,84,86,87,88,89,91", "code": "\nfrom sympy import primepi\ndef a(n): return primepi(n) + n\nprint([a(n) for n in range(72)]) \n"}
{"sequence_id": "A095149", "text": "Triangle read by rows: Aitken's array (A011971) but with a leading diagonal before it given by the Bell numbers (A000110), 1, 1, 2, 5, 15, 52, ...", "sequence": "1,1,1,2,1,2,5,2,3,5,15,5,7,10,15,52,15,20,27,37,52,203,52,67,87,114,151,203,877,203,255,322,409,523,674,877,4140,877,1080,1335,1657,2066,2589,3263,4140,21147,4140,5017,6097,7432,9089,11155,13744,17007,21147", "code": "\n\nfrom itertools import accumulate\nA095149_list, blist = [1,1,1], [1]\nfor _ in range(2*10**2):\n....b = blist[-1]\n....blist = list(accumulate([b]+blist))\n....A095149_list += [blist[-1]]+ blist\n\n"}
{"sequence_id": "A095179", "text": "Numbers whose reversed digit representation is prime.", "sequence": "2,3,5,7,11,13,14,16,17,20,30,31,32,34,35,37,38,50,70,71,73,74,76,79,91,92,95,97,98,101,104,106,107,110,112,113,118,119,124,125,128,130,131,133,134,136,140,142,145,146,149,151,152,157,160,164,166,167,170,172", "code": "\nfrom sympy import isprime\ndef ok(n): return isprime(int(str(n)[::-1]))\nprint(list(filter(ok, range(1, 173)))) \n"}
{"sequence_id": "A095286", "text": "Primes in whose binary expansion the number of 1 bits is > 1 + number of 0 bits.", "sequence": "3,7,11,13,23,29,31,43,47,53,59,61,79,103,107,109,127,151,157,167,173,179,181,191,199,211,223,227,229,233,239,241,251,311,317,347,349,359,367,373,379,383,431,439,443,461,463,467,479,487,491,499", "code": "\nfrom sympy import isprime\ni = 1\nj = 1\nwhile j <= 2000:\n    bi = bin(i)[2:]\n    if isprime(i) and bi.count(\"1\") > 1 + bi.count(\"0\"):\n        print(str(j) + \" \" + str(i))\n        j += 1\n    i += 1 \n"}
{"sequence_id": "A095287", "text": "Primes in whose binary expansion the number of 1-bits is <= 1 + number of 0-bits.", "sequence": "2,5,17,19,37,41,67,71,73,83,89,97,101,113,131,137,139,149,163,193,197,257,263,269,271,277,281,283,293,307,313,331,337,353,389,397,401,409,419,421,433,449,457,521,523,541,547,557,563,569,577,587", "code": "\nfrom sympy import isprime\ni=1\nj=1\nwhile j<=250:\n    if isprime(i) and bin(i)[2:].count(\"1\")<=1+bin(i)[2:].count(\"0\"):\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A095315", "text": "Primes in whose binary expansion the number of 1 bits is <= 2 + number of 0 bits.", "sequence": "2,3,5,11,13,17,19,37,41,43,53,67,71,73,83,89,97,101,113,131,137,139,149,151,157,163,167,173,179,181,193,197,199,211,227,229,233,241,257,263,269,271,277,281,283,293,307,313,331,337,353,389,397", "code": "\ni=j=1\nwhile j<=250:\n    if isprime(i) and bin(i)[2:].count(\"1\")<=2+bin(i)[2:].count(\"0\"):\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A095683", "text": "Number of prime power divisors of n. If n = product p_i^r_i then d = product {p_i^s_i, 2 <= s_i <= r_i, s_i is prime} is a prime power divisor of n.", "sequence": "1,0,0,1,0,0,0,2,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1,0,2,0,0,0,0,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0", "code": "\nfrom sympy import factorint, primepi, prod\ndef a(n): return 1 if n==1 else prod(primepi(e) for e in factorint(n).values())\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A095691", "text": "Multiplicative with a(p^e) = A000720(e)+1.", "sequence": "1,1,1,2,1,1,1,3,2,1,1,2,1,1,1,3,1,2,1,2,1,1,1,3,2,1,3,2,1,1,1,4,1,1,1,4,1,1,1,3,1,1,1,2,2,1,1,3,2,2,1,2,1,3,1,3,1,1,1,2,1,1,2,4,1,1,1,2,1,1,1,6,1,1,2,2,1,1,1,3,3,1,1,2,1,1,1,3,1,2,1,2,1,1,1,4,1,2,2,4,1,1,1,3,1", "code": "\nfrom sympy import factorint, primepi, prod\ndef a(n): return 1 if n==1 else prod(primepi(e) + 1 for e in factorint(n).values())\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A095800", "text": "Triangle T(n,k) = abs( k *( (2*n+1)*(-1)^(n+k)+2*k-1) /4 ) read by rows, 1<=k<=n.", "sequence": "1,1,4,2,2,9,2,6,3,16,3,4,12,4,25,3,8,6,20,5,36,4,6,15,8,30,6,49,4,10,9,24,10,42,7,64,5,8,18,12,35,12,56,8,81,5,12,12,28,15,48,14,72,9,100,6,10,21,16,40,18,63,16,90,10,121,6,14,15,32,20,54,21,80,18,110,11,144,7,12,24,20,45,24,70,24,99,20,132", "code": "\n\ni=1\nfor n in range(1,126):\n    for k in range(1,n+1):\n        print(str(i)+\" \"+str(abs(k*((2*n+1)*(-1)**(n+k)+2*k-1)//4)))\n        i+=1 \n"}
{"sequence_id": "A096037", "text": "Triangle T(n,m) = (3*n+3*m-2)*(n+1-m)/2 read by rows.", "sequence": "2,7,5,15,13,8,26,24,19,11,40,38,33,25,14,57,55,50,42,31,17,77,75,70,62,51,37,20,100,98,93,85,74,60,43,23,126,124,119,111,100,86,69,49,26,155,153,148,140,129,115,98,78,55,29,187,185,180,172,161,147,130,110,87,61,32", "code": "\ndef A096037(n,m):\n    return (3*n+3*m-2)*(n+1-m)//2\nprint( [A096037(n,m) for n in range(20) for m in range(1,n+1)] )\n\n"}
{"sequence_id": "A096038", "text": "Triangle T(n,m) = (3*n^2-3*m^2+5*m-4+n)/2 read by rows.", "sequence": "1,6,4,14,12,7,25,23,18,10,39,37,32,24,13,56,54,49,41,30,16,76,74,69,61,50,36,19,99,97,92,84,73,59,42,22,125,123,118,110,99,85,68,48,25,154,152,147,139,128,114,97,77,54,28,186,184,179,171,160,146,129,109,86,60,31", "code": "\ndef A096038(n,m):\n    return (3*n**2-3*m**2+5*m-4+n)//2\nprint( [A096038(n,m) for n in range(20) for m in range(1,n+1)] )\n\n"}
{"sequence_id": "A096168", "text": "Number of Abelian cubefree words over a 3-letter alphabet.", "sequence": "1,3,9,24,66,180,468,1206,3150,7998,20124,50520,124044,303906,744870,1790226,4319322,10432044,24926934,59570514,142662384,339247320", "code": "\nfrom itertools import product\ndef anagrams(b1, b2, b3):\n    return sorted(b1) == sorted(b2) == sorted(b3)\ndef acf(s):\n    for l in range(1, len(s)//3 + 1):\n      for i in range(len(s) - 3*l + 1):\n          if anagrams(s[i:i+l], s[i+l:i+2*l], s[i+2*l:i+3*l]): return False\n    return True\ndef a(n):\n    if n == 0: return 1\n    return 3*sum(acf(\"0\"+\"\".join(w)) for w in product(\"012\", repeat=n-1))\nprint([a(n) for n in range(14)]) \n"}
{"sequence_id": "A096168", "text": "Number of Abelian cubefree words over a 3-letter alphabet.", "sequence": "1,3,9,24,66,180,468,1206,3150,7998,20124,50520,124044,303906,744870,1790226,4319322,10432044,24926934,59570514,142662384,339247320", "code": " \ndef anagrams(b1, b2, b3): return sorted(b1) == sorted(b2) == sorted(b3)\ndef iacf(s): \n    for l in range(1, len(s)//3 + 1):\n        if anagrams(s[-3*l:-2*l], s[-2*l:-l], s[-l:]): return False\n    return True\ndef aupton(nn, verbose=False):\n    alst, acfs = [1], set(\"0\")\n    for n in range(1, nn+1):\n        an = 3*len(acfs)\n        acfsnew = set(c+i for c in acfs for i in \"012\" if iacf(c+i))\n        alst, acfs = alst+[an], acfsnew\n        if verbose: print(n, an)\n    return alst\nprint(aupton(14)) \n"}
{"sequence_id": "A096217", "text": "a(n) = sum of terms of {a(1),a(2),a(3),...a(n-1)} which are coprime to n.", "sequence": "1,1,2,2,6,2,14,2,24,2,56,2,114,2,86,2,318,2,524,2,632,2,1798,2,3598,2,6736,2,12138,2,24278,2,37756,2,72308,2,160424,2,308250,2,629102,2,1258120,2,937358,2,3453688,2,3437884,2,9395312,2,18802902,2,36816688,2", "code": "\nfrom gmpy2 import gcd\nA096217 = [1]\nfor n in range(2, 10**4):\n    A096217.append(sum(x for x in A096217 if gcd(x, n) == 1))\n\n"}
{"sequence_id": "A096257", "text": "The least k whose n-th root contains k as a string of digits to the immediate right of the decimal point (excluding leading zeros).", "sequence": "8,2,3,633,19703,89,69,56,46,39,33,29,25,22,20,18,16,14,13,12,11,10,2,2,2,2,2,2,2,2,2,2,2,2,3,3,138,133,128,124,120,116,113,109,106,103,100,97,95,92,90,87,85,83,81,79,77,75,74,72,70,69,67,66,65,63,62,61,59,58,57", "code": "\nimport re\nfrom sympy import perfect_power\nfrom decimal import *\ngetcontext().prec = 24\ndef lzs(s): return len(s) - 2 - len(s[2:].lstrip('0')) \ndef cond(sk, sroot, k, n): \n    if perfect_power(k, [n]): return False \n    assert lzs(sroot) + len(sk) < len(sroot) - 3, (n, \"increase precision\")\n    return re.match(\"0.0*\"+sk, sroot)\ndef a(n):\n    k, power = 1, Decimal(1)/Decimal(n)\n    rootk, sk = Decimal(k)**power, str(k)\n    while not cond(sk, str(rootk - int(rootk)), k, n):\n        k += 1\n        rootk, sk = Decimal(k)**power, str(k)\n    return k\nprint([a(n) for n in range(2, 73)]) \n"}
{"sequence_id": "A096336", "text": "Spin(2n+1) and Spin(2n+2) have torsion index 2^a(n).", "sequence": "0,0,0,1,1,1,2,3,4,4,5,5,6,7,8,9,10,10,11,12,13,14,15,15,16,17,18,19,20,21,22,23,24,25,25,26,27,28,29,30,31,32,33,34,35,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,55,56,57", "code": "\nimport numpy as np\ndef a_typical(n):\n    '''\n    For most n, this is the value of a(n)\n    '''\n    return int(n - np.floor(np.log2( n*(n+1)/2 + 1)))\ndef a(n):\n    '''\n    The torsion index of Spin_{2n+1} and Spin_{2n+2} is 2^a(n)\n    Totaro denotes it by u(ell)\n    '''\n    if n >= 0 and n <= 18:   \n        return [0,0,0,1,1,1,2,3,4,4,5,5,6,7,8,9,10,10,11][n];\n    maxe = int(np.floor(np.log2(n)))\n    for e in range(maxe+1):\n        b = n - 2**e\n        if 2*b - a(b) <= e - 3: \n            return a_typical(n)+1\n    return a_typical(n)\n\n"}
{"sequence_id": "A096357", "text": "Lcm[{ad(n)}], i.e. the least common multiple of the anti-divisors of n.", "sequence": "2,3,6,4,30,15,6,84,42,40,90,36,30,33,2310,420,78,312,42,180,90,112,3570,204,990,25080,114,60,126,4095,4290,276,4830,24,150,23100,6006,432,54,7140,14790,696,8190,33852,17670,3040,1386,1980,102,840,210,36,12210", "code": "\nfrom sympy import lcm\nA096357 = [lcm([d for d in range(2,n,2) if n%d and not 2*n%d]+[d for d in range(3,n,2) if n%d and 2*n%d in [d-1,1]]) for n in range(3,10**5)] \n"}
{"sequence_id": "A096367", "text": "Number of winning paths of length n+1 across an n X n Hex board.", "sequence": "2,14,58,194,578,1602,4226,10754,26626,64514,153602,360450,835586,1916930,4358146,9830402,22020098,49020930,108527618,239075330,524288002,1145044994,2491416578,5402263554,11676942338,25165824002,54089744386,115964116994,248034361346", "code": "\ndef a(n): return (n-2)*(n+1)*2**(n-3) - 2**(n-1) + 2\nprint([a(n) for n in range(3, 32)]) \n"}
{"sequence_id": "A096404", "text": "a(n) = ceiling(e^(e^n)).", "sequence": "3,16,1619,528491312,514843556263457213182266,28511235679461510605581038657982805983853648817939444953417128837", "code": "\nfrom sympy import E\ndef a(n): return int(E**(E**n)) + 1\nprint([a(n) for n in range(6)]) \n"}
{"sequence_id": "A096485", "text": "Period length of continued fraction for square root of n-th decimal repunit.", "sequence": "2,6,2,24,2,622,2,2396,2,21912,2,527718,2,168484,2,13171730,2,359947864,2,52090778,2,16658818532,2,134257065348,2,61403998114,2", "code": "\nfrom sympy.ntheory.continued_fraction import continued_fraction\nfrom sympy import sqrt\ndef A096485(n): return len(continued_fraction(sqrt((10**n-1)//9))[-1]) \n"}
{"sequence_id": "A096488", "text": "Number of different terms in a period of continued fraction for square root of n-th repunit.", "sequence": "2,3,2,8,2,37,2,76,2,217,2,870,2,583,2,5034,2,28494,2,10058,2,187966,2,383291,2,340992,2", "code": "\nfrom sympy.ntheory.continued_fraction import continued_fraction\nfrom sympy import sqrt\ndef A096488(n): return len(set(continued_fraction(sqrt((10**n-1)//9))[-1])) \n"}
{"sequence_id": "A096497", "text": "Prime following n-th repunit.", "sequence": "2,13,113,1117,11113,111119,1111151,11111117,111111113,1111111121,11111111113,111111111149,1111111111139,11111111111123,111111111111229,1111111111111123,11111111111111119,111111111111111131,1111111111111111171,11111111111111111131,111111111111111111157,1111111111111111111189", "code": "\nfrom sympy import nextprime\ndef A096497(n):\n    return nextprime((10**n-1)//9) \n"}
{"sequence_id": "A096599", "text": "Squares k^2 with property that A062892(k^2) = 1.", "sequence": "0,1,4,9,16,25,36,49,64,81,121,225,289,324,361,484,529,576,676,729,784,841,1156,1225,1444,1521,1681,1849,2116,2209,2601,2704,3025,3136,3249,3364,3481,3721,3844,3969,4225,4356,4489,4624,5041,5184,5329,5476", "code": "\nfrom math import isqrt\nfrom sympy.utilities.iterables import multiset_permutations as mp\ndef sqr(n): return isqrt(n)**2 == n\ndef ok(square):\n    s = str(square)\n    perms = (int(\"\".join(p)) for p in mp(s, len(s)))\n    return len(set(p for p in perms if sqr(p))) == 1\ndef aupto(limit): return [k*k for k in range(isqrt(limit)+1) if ok(k*k)]\nprint(aupto(5476)) \n"}
{"sequence_id": "A096654", "text": "Denominators of self-convergents to 1/(e-2).", "sequence": "1,2,8,38,222,1522,11986,106542,1054766,11506538,137119578,1772006854,24681524038,368577425634,5874202721042,99515904921182,1785757627196766,33835407673201882,675016383080377546,14143200407398386678,310507536216973671158", "code": "\nprpr = 1\nprev = 2\nfor n in range(2, 77):\n    print(prpr, end=', ')\n    curr = (n+1)*prev + n*prpr\n    prpr = prev\n    prev = curr\n\n"}
{"sequence_id": "A096681", "text": "Least k such that decimal representation of k*n contains only digits 0 and 2.", "sequence": "2,1,74,5,4,37,286,25,24691358,2,2,185,154,143,148,125,1306,12345679,1158,1,962,1,9574,925,8,77,81563786,715,75938,74,7162,625,6734,653,572,61728395,6,579,518,5,542,481,51214,5,49382716,4787,426,4625,44898,4", "code": "\ndef next02(n):\n  s = str(n)\n  if s > '2'*len(s): return int('2' + '0'*len(s))\n  for i, c in enumerate(s):\n    if c == '1': return int(s[:i] + '2' + '0'*(len(s)-i-1))\n    elif s[i:] > '2'*(len(s)-i): return int(s[:i-1] + '2' + '0'*(len(s)-i))\ndef a(n):\n  k = 1\n  while set(str(k*n)) - set('02') != set(): k = max(k+1, next02(k*n)//n)\n  return k\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A096687", "text": "Least k such that decimal representation of k*n contains only digits 0 and 8.", "sequence": "8,4,296,2,16,148,1144,1,98765432,8,8,74,616,572,592,5,5224,49382716,4632,4,3848,4,38296,37,32,308,326255144,286,303752,296,28648,25,26936,2612,2288,24691358,24,2316,2072,2,2168,1924,204856,2,197530864,19148", "code": "\ndef A096687(n):\n....if n > 0:\n........for i in range(1,2**n):\n............q, r = divmod(8*int(bin(i)[2:]),n)\n............if not r:\n................return q\n....return 1 \n"}
{"sequence_id": "A096713", "text": "Irregular triangle T(n,k) of nonzero coefficients of the modified Hermite polynomials (n >= 0 and 0 <= k <= floor(n/2)).", "sequence": "1,1,-1,1,-3,1,3,-6,1,15,-10,1,-15,45,-15,1,-105,105,-21,1,105,-420,210,-28,1,945,-1260,378,-36,1,-945,4725,-3150,630,-45,1,-10395,17325,-6930,990,-55,1,10395,-62370,51975,-13860,1485,-66,1,135135,-270270,135135,-25740,2145,-78,1", "code": "\nfrom sympy import hermite, Poly, sqrt\ndef a(n): return Poly(hermite(n, x/sqrt(2))/2**(n/2), x).coeffs()[::-1]\nfor n in range(21): print(a(n)) \n"}
{"sequence_id": "A096825", "text": "Maximal size of an antichain in divisor lattice D(n).", "sequence": "1,1,1,1,1,2,1,1,1,2,1,2,1,2,2,1,1,2,1,2,2,2,1,2,1,2,1,2,1,3,1,1,2,2,2,3,1,2,2,2,1,3,1,2,2,2,1,2,1,2,2,2,1,2,2,2,2,2,1,4,1,2,2,1,2,3,1,2,2,3,1,3,1,2,2,2,2,3,1,2,1,2,1,4,2,2,2,2,1,4,2,2,2,2,2,2,1,2,2,3", "code": "\nfrom sympy import factorint\nfrom sympy.utilities.iterables import multiset_combinations\ndef A096825(n):\n    fs = factorint(n)\n    return len(list(multiset_combinations(fs,sum(fs.values())//2))) \n"}
{"sequence_id": "A096844", "text": "Numbers where 0 is the only even decimal digit.", "sequence": "0,10,30,50,70,90,100,101,103,105,107,109,110,130,150,170,190,300,301,303,305,307,309,310,330,350,370,390,500,501,503,505,507,509,510,530,550,570,590,700,701,703,705,707,709,710,730,750,770,790,900,901,903,905", "code": "\nfrom itertools import product\ndef agen(maxdigits):\n    yield 0\n    for digs in range(2, maxdigits+1):\n        for p in product(\"013579\", repeat=digs):\n            if p[0] != '0' and '0' in p: yield int(\"\".join(p))\nprint([an for an in agen(3)]) \n"}
{"sequence_id": "A097227", "text": "Numbers n such that n = prime(d_1) * prime(d_2) * ... * prime(d_k), where d_1 d_2 ... d_k is the decimal expansion of n.", "sequence": "14,154,1196,279174", "code": "\nfrom functools import reduce\nfrom operator import mul\nfrom itertools import combinations_with_replacement\nA097227_list, ptuple = [], (2,3,5,7,11,13,17,19,23)\nfor l in range(1,12):\n    for d in combinations_with_replacement(range(1,10),l):\n        n = reduce(mul,(ptuple[i-1] for i in d))\n        if n < 10**l and tuple(sorted((int(x) for x in str(n)))) == d:\n            A097227_list.append(n) \n"}
{"sequence_id": "A097228", "text": "Numbers n such that the product of digits of n equals the concatenation of pi(d)'s where d runs through the digits of n.", "sequence": "27,38,127,138,289,298,1127,1138,1289,1298,11127,11138,11289,11298,111127,111138,111289,111298,1111127,1111138,1111289,1111298,11111127,11111138,11111289,11111298,111111127,111111138,111111289,111111298", "code": "\nfrom __future__ import division\nA097228_list = [27,38] + [1000*(10**k-1)//9+d for k in range(20) for d in [127,138,289,298]] \n"}
{"sequence_id": "A097246", "text": "Replace factors of n that are squares of a prime with the prime succeeding this prime.", "sequence": "1,2,3,3,5,6,7,6,5,10,11,9,13,14,15,9,17,10,19,15,21,22,23,18,7,26,15,21,29,30,31,18,33,34,35,15,37,38,39,30,41,42,43,33,25,46,47,27,11,14,51,39,53,30,55,42,57,58,59,45,61,62,35,27,65,66,67,51,69,70,71,30,73", "code": "\nfrom sympy import factorint, nextprime\nfrom operator import mul\ndef a(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [(nextprime(i)**int(f[i]/2))*(i**(f[i]%2)) for i in f]) \n"}
{"sequence_id": "A097248", "text": "a(n) is the eventual stable point reached when iterating k -> A097246(k), starting from k = n.", "sequence": "1,2,3,3,5,6,7,6,5,10,11,5,13,14,15,5,17,10,19,15,21,22,23,10,7,26,15,21,29,30,31,10,33,34,35,15,37,38,39,30,41,42,43,33,7,46,47,15,11,14,51,39,53,30,55,42,57,58,59,7,61,62,35,15,65,66,67,51,69,70,71,30,73,74,21", "code": "\nfrom sympy import factorint, nextprime\nfrom operator import mul\ndef a097246(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [(nextprime(i)**int(f[i]/2))*(i**(f[i]%2)) for i in f])\ndef a(n):\n    k=a097246(n)\n    while k!=n:\n        n=k\n        k=a097246(k)\n    return k \n"}
{"sequence_id": "A097326", "text": "Largest integer m such that m*n has the same decimal digit length as n.", "sequence": "9,4,3,2,1,1,1,1,1,9,9,8,7,7,6,6,5,5,5,4,4,4,4,4,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9", "code": "\ndef a(n): return (10**len(str(n))-1)//n\nprint([a(n) for n in range(1, 106)]) \n"}
{"sequence_id": "A097327", "text": "Least positive integer m such that m*n has greater decimal digit length than n.", "sequence": "10,5,4,3,2,2,2,2,2,10,10,9,8,8,7,7,6,6,6,5,5,5,5,5,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,10,10,10", "code": "\ndef a(n): return (10**len(str(n))-1)//n + 1\nprint([a(n) for n in range(1, 103)]) \n"}
{"sequence_id": "A097344", "text": "Numerators in binomial transform of 1/(n+1)^2.", "sequence": "1,5,29,103,887,1517,18239,63253,332839,118127,2331085,4222975,100309579,184649263,1710440723,6372905521,202804884977,381240382217,13667257415003,25872280345103,49119954154463,93501887462903,4103348710010689,7846225754967739,75162749477272151", "code": "\nfrom fractions import Fraction\nA097344_list, tlist = [1], [Fraction(1,1)]\nfor i in range(1,100):\n    for j in range(len(tlist)):\n        tlist[j] *= Fraction(i,i-j)\n    tlist += [Fraction(1,(i+1)**2)]\n    A097344_list.append(sum(tlist).numerator) \n"}
{"sequence_id": "A097383", "text": "Minimum total number of comparisons to find each of the values 1 through n using a binary search with 3-way comparisons (less than, equal and greater than).", "sequence": "0,2,3,6,8,11,13,17,20,24,27,31,34,38,41,46,50,55,59,64,68,73,77,82,86,91,95,100,104,109,113,119,124,130,135,141,146,152,157,163,168,174,179,185,190,196,201,207,212,218,223,229,234,240,245,251,256,262,267,273", "code": "\ndef A097383(n):\n    s, i, z = -n//2, n, 1\n    while 0 <= i: s += i; i -= z; z += z\n    return s\nprint([A097383(n) for n in range(1, 61)]) \n"}
{"sequence_id": "A097706", "text": "Part of n composed of prime factors of form 4k+3.", "sequence": "1,1,3,1,1,3,7,1,9,1,11,3,1,7,3,1,1,9,19,1,21,11,23,3,1,1,27,7,1,3,31,1,33,1,7,9,1,19,3,1,1,21,43,11,9,23,47,3,49,1,3,1,1,27,11,7,57,1,59,3,1,31,63,1,1,33,67,1,69,7,71,9,1,1,3,19,77,3,79,1,81,1,83,21", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef a072436(n):\n    f=factorint(n)\n    return 1 if n == 1 else reduce(mul, [1 if i%4==3 else i**f[i] for i in f])\ndef a(n): return n/a072436(n) \n"}
{"sequence_id": "A097889", "text": "Numbers that are products of (at least two) consecutive primes.", "sequence": "6,15,30,35,77,105,143,210,221,323,385,437,667,899,1001,1147,1155,1517,1763,2021,2310,2431,2491,3127,3599,4087,4199,4757,5005,5183,5767,6557,7387,7429,8633,9797,10403,11021,11663,12317,12673,14351,15015,16637,17017", "code": "\nimport heapq\nfrom sympy import sieve\nsieve.extend(10**6)\nprimes = list(sieve._list)\ndef prime(n): return primes[n-1]\ndef aupton(terms, verbose=False):\n    p = prime(1)*prime(2); h = [(p, 1, 2)]; nextcount = 3; alst = []\n    while len(alst) < terms:\n        (v, s, l) = heapq.heappop(h)\n        alst.append(v)\n        if verbose: print(f\"{v}, [= Prod_{{i = {s}..{l}}} prime(i)]\")\n        if v >= p:\n            p *= prime(nextcount)\n            heapq.heappush(h, (p, 1, nextcount))\n            nextcount += 1\n        v //= prime(s); s += 1; l += 1; v *= prime(l)\n        heapq.heappush(h, (v, s, l))\n    return alst\nprint(aupton(45)) \n"}
{"sequence_id": "A097963", "text": "[\"comma\"], is the first, fifteenth, twenty-sixth, fortieth, ... character in this sentence, including spaces and punctuations.", "sequence": "1,15,26,40,50,60,70,82,97,113,137,165,190,213,237,265,290,313,339,367,396,424,452,479,507,529,556,582,610,629,655,680,703,724,753,780,805,826,854,882,911,934,962,989,1016,1040,1063,1089,1116,1152,1191,1230", "code": "\nfrom itertools import accumulate, repeat\nfrom num2words import num2words\nA097963_list = [1]+list(accumulate(repeat(15,100), lambda x, _: x+2+len(num2words(x,to='ordinal').replace(' and ',' ').replace(', ',' ')))) \n"}
{"sequence_id": "A098007", "text": "Length of aliquot sequence for n, or -1 if aliquot sequence never cycles.", "sequence": "2,3,3,4,3,1,3,4,5,5,3,8,3,6,6,7,3,5,3,8,4,7,3,6,2,8,4,1,3,16,3,4,7,9,4,5,3,8,4,5,3,15,3,6,8,9,3,7,5,4,5,10,3,14,4,6,4,5,3,12,3,10,4,5,4,13,3,6,5,7,3,10,3,6,6,6,4,12,3,8,6,7,3,7,4,10,8,8,3,11,5,7,5,5,3,10,3,4,5,6", "code": "\nfrom sympy import divisor_sigma as sigma\ndef a(n, limit=float('inf')):\n    alst = []; seen = set(); i = n; c = 0\n    while i and i not in seen and c < limit:\n        alst.append(i); seen.add(i); i = sigma(i) - i; c += 1\n    return \"NA\" if c == limit else len(set(alst + [i]))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A098146", "text": "First odd semiprime > 10^n.", "sequence": "9,15,111,1003,10001,100001,1000001,10000001,100000001,1000000013,10000000003,100000000007,1000000000007,10000000000015,100000000000013,1000000000000003,10000000000000003,100000000000000015", "code": "\nfrom sympy import factorint, nextprime\ndef is_semiprime(n): return sum(e for e in factorint(n).values()) == 2\ndef next_odd_semiprime(n):\n    nxt = n + 1 + n%2\n    while not is_semiprime(nxt): nxt += 2\n    return nxt\ndef a(n): return next_odd_semiprime(10**n)\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A098224", "text": "Number of primes <=10^n in which decimal digits are all distinct.", "sequence": "4,24,121,631,3160,13399,47349,137859,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086,283086", "code": "\nfrom sympy import sieve\ndef distinct_digs(n): s = str(n); return len(s) == len(set(s))\ndef aupton(terms):\n  ps, alst = 0, []\n  for n in range(1, terms+1):\n    if n >= 10: alst.append(ps); continue\n    ps += sum(distinct_digs(p) for p in sieve.primerange(10**(n-1), 10**n))\n    alst.append(ps)\n  return alst\nprint(aupton(35)) \n"}
{"sequence_id": "A098385", "text": "Ordered factorizations over hook-type prime signatures with exactly three distinct primes (third column of A098348).", "sequence": "13,44,132,368,976,2496,6208,15104,36096,84992,197632,454656,1036288,2342912,5259264,11730944,26017792,57409536,126091264,275775488,600834048,1304428544,2822766592,6090129408,13103005696,28118614016,60196651008", "code": " def a(n): return 2**n * (n**2 + 8*n + 13) \n"}
{"sequence_id": "A098449", "text": "Smallest n-digit semiprime.", "sequence": "4,10,106,1003,10001,100001,1000001,10000001,100000001,1000000006,10000000003,100000000007,1000000000007,10000000000015,100000000000013,1000000000000003,10000000000000003,100000000000000015,1000000000000000007,10000000000000000001", "code": "\nfrom sympy import factorint\ndef semiprime(n): f = factorint(n); return sum(f[p] for p in f) == 2\ndef a(n):\n  an = max(1, 10**(n-1))\n  while not semiprime(an): an += 1\n  return an\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A098450", "text": "Largest n-digit semiprime.", "sequence": "9,95,998,9998,99998,999997,9999998,99999997,999999991,9999999997,99999999997,999999999997,9999999999989,99999999999997,999999999999998,9999999999999994,99999999999999989,999999999999999993,9999999999999999991,99999999999999999983", "code": "\nfrom sympy import factorint\ndef semiprime(n): f = factorint(n); return sum(f[p] for p in f) == 2\ndef a(n):\n  an = 10**n - 1\n  while not semiprime(an): an -= 1\n  return an\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A098464", "text": "Numbers k such that lcm(1,2,3,...,k) equals the denominator of the k-th harmonic number H(k).", "sequence": "1,2,3,4,5,9,10,11,12,13,14,15,16,17,27,28,29,30,31,32,49,50,51,52,53,88,89,90,91,92,93,94,95,96,97,98,99,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149", "code": "\nfrom fractions import Fraction\nfrom sympy import lcm\nk, l, h, A098464_list = 1, 1, Fraction(1, 1), []\nwhile k < 10**6:\n    if l == h.denominator:\n        A098464_list.append(k)\n    k += 1\n    l = lcm(l,k)\n    h += Fraction(1,k) \n"}
{"sequence_id": "A098479", "text": "Expansion of 1/sqrt((1-x)^2 - 4*x^3).", "sequence": "1,1,1,3,7,13,27,61,133,287,633,1407,3121,6943,15517,34755,77959,175213,394499,889461,2007963,4538485,10269247,23258881,52726599,119627977,271624315,617180533,1403272799,3192557561,7267485523,16552454205", "code": "\nfrom sympy import binomial\ndef a(n): return sum(binomial(n - k, k) * binomial(n - 2*k, k) for k in range(n//2 + 1))\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A098550", "text": "The Yellowstone permutation: a(n) = n if n <= 3, otherwise the smallest number not occurring earlier having at least one common factor with a(n-2), but none with a(n-1).", "sequence": "1,2,3,4,9,8,15,14,5,6,25,12,35,16,7,10,21,20,27,22,39,11,13,33,26,45,28,51,32,17,18,85,24,55,34,65,36,91,30,49,38,63,19,42,95,44,57,40,69,50,23,48,115,52,75,46,81,56,87,62,29,31,58,93,64,99,68,77,54,119,60", "code": "\nfrom fractions import gcd\nA098550_list, l1, l2, s, b = [1,2,3], 3, 2, 4, {}\nfor _ in range(1,10**6):\n    i = s\n    while True:\n        if not i in b and gcd(i,l1) == 1 and gcd(i,l2) > 1:\n            A098550_list.append(i)\n            l2, l1, b[i] = l1, i, 1\n            while s in b:\n                b.pop(s)\n                s += 1\n            break\n        i += 1 \n"}
{"sequence_id": "A098591", "text": "a(k) contains primality information for the numbers in the interval (k*30,...,(k+1)*30) packed into one byte using the fact that only numbers == 1, 7, 11, 13, 17, 19, 23, 29 mod 30 can be prime.", "sequence": "223,239,126,182,219,61,249,213,79,30,243,234,166,237,158,230,12,211,211,59,221,89,165,106,103,146,189,120,30,166,86,86,227,173,45,222,42,76,85,217,163,240,159,3,84,161,248,46,253,68,233,102,246,19,58,184,76", "code": "\nfrom sympy import isprime\nv = [1, 7, 11, 13, 17, 19, 23, 29]\ndef a(n): return sum(2**k for k, vk in enumerate(v) if isprime(n*30+vk))\nprint([a(n) for n in range(1, 58)]) \n"}
{"sequence_id": "A098592", "text": "Number of primes between n*30 and (n+1)*30.", "sequence": "10,7,7,6,5,6,5,6,5,5,4,6,5,4,6,5,5,2,5,5,5,6,4,4,4,5,3,6,4,4,4,4,4,5,5,4,6,3,3,4,5,4,4,6,2,3,3,5,4,7,2,5,4,6,3,4,4,3,4,4,3,2,7,3,3,3,5,5,3,5,3,5,2,3,4,4,5,3,4,7,3,4,3,1,5,3,3,3,4,7,5,4,3,5,3,4,4,3,4,2,4,3,5,2,2,3", "code": "\nfrom sympy import primerange\ndef a(n): return len(list(primerange(n*30, (n+1)*30)))\nprint([a(n) for n in range(106)]) \n"}
{"sequence_id": "A098690", "text": "Number of solutions to rev(x^2)=rev(x)^2 below 10^n.", "sequence": "3,9,24,63,153,362,819,1810,3872,8160,16681,33756,66864,130937,251982,480793,903981,1685563,3106008,5677863,10276935,18464658,32891187,58169964,102136772,178096364,308593319,531191384,909227946,1546356485,2617639292", "code": "\ndef rev(n): return int(str(n)[::-1])\ndef a(n): return sum(k % 10 and rev(k**2) == rev(k)**2 for k in range(10**n)) \n"}
{"sequence_id": "A098780", "text": "First n numbers in binary representation concatenated in reverse order.", "sequence": "1,5,29,157,1437,13725,128413,1176989,20051357,355595677,6261175709,109340390813,1896046785949,32682372363677,560447953696157,9567647208437149,315812421869630877,10692105963331253661", "code": "\ndef A098780(n):\n....s=\"\"\n....for i in range(n,0,-1):\n........s+=bin(i)[2:]\n....return int(s,2) \n"}
{"sequence_id": "A098813", "text": "For a string of letters of length k, say abc...def, let f(k) be the string of length k-1 consisting of the adjacent pairs ab, bc, cd, ..., de, ef. Given n, let U be the string of length 2n consisting of n 1's followed by n 2's: 11...122...2. Then a(n) is the number of the C(2n,n) permutations V of U such that f(U) and f(V) agree in exactly one place.", "sequence": "1,1,4,19,57,178,543,1591,4598,13117,36999,103514,287653,794847,2186054,5988339,16347999,44497490,120804023,327217525,884531586,2386747391,6429784509,17296261734,46465809007,124678595953,334173980818,894778164125", "code": "\ndef find(bits_in, n0, n1, match):\n....global count, U\n....bitsleft = n0 + n1\n....if bitsleft==0:\n........if match:\n............count += 1\n....else:\n........bitsleft -= 1\n........if n0 > 0:\n............bits_out = bits_in<<1\n............new_match = (bits_out&3) == ((U >> bitsleft)&3)\n............if not (match and new_match):\n................find(bits_out, n0-1, n1, match or new_match)\n........if n1 > 0:\n............bits_out = (bits_in<<1)|1;\n............new_match = (bits_out&3) == ((U >> bitsleft)&3)\n............if not (match and new_match):\n................find(bits_out, n0, n1-1, match or new_match)\ndef A098813(n):\n....global count, U\n....count = 0 ; U = (1<<n)-1\n....find(0, n-1, n, False)\n....find(1, n, n-1, False)\n....return count\n\n"}
{"sequence_id": "A098834", "text": "Palindromic Smith numbers.", "sequence": "4,22,121,202,454,535,636,666,1111,1881,3663,7227,7447,9229,10201,17271,22522,24142,28182,33633,38283,45054,45454,46664,47074,50305,51115,51315,54645,55055,55955,72627,81418,82628,83038,83938,90409,95359,96169,164461", "code": "\nfrom sympy import factorint\nfrom itertools import product\ndef sd(n): return sum(map(int, str(n)))\ndef smith(n):\n  f = factorint(n)\n  return sum(f[p] for p in f) > 1 and sd(n) == sum(sd(p)*f[p] for p in f)\ndef palsto(limit):\n  yield from range(min(limit, 9)+1)\n  midrange = [[\"\"], [str(i) for i in range(10)]]\n  for digs in range(2, 10**len(str(limit))):\n    for p in product(\"0123456789\", repeat=digs//2):\n      left = \"\".join(p)\n      if left[0] == '0': continue\n      for middle in midrange[digs%2]:\n        out = int(left + middle + left[::-1])\n        if out > limit: return\n        yield out\nprint(list(filter(smith, palsto(164461)))) \n"}
{"sequence_id": "A098845", "text": "Numbers k such that 4^k - 2^k - 1 is prime.", "sequence": "2,4,5,9,10,18,38,45,50,57,108,161,208,224,225,240,354,597,634,1008,1080,1468,1525,1560,3298,3329,3846,4129,5430,8616,11834,12988,14610,43401,45306,53776,54449,67497,74025,122449,136845,142896,164541,171157,187668,274054,316944,349296", "code": "\nfrom sympy import isprime\nfor n in range(1,1000):\n    if isprime(4**n-2**n-1):\n        print(n, end=', ') \n"}
{"sequence_id": "A098916", "text": "Permanent of the n X n (0,1)-matrices with ij-th entry equal to zero iff (i=1,j=1),(i=1,j=n),(i=n,j=1) and (i=n,j=n).", "sequence": "0,4,36,288,2400,21600,211680,2257920,26127360,326592000,4390848000,63228211200,971415244800,15866448998400,274611617280000,5021469573120000,96746980442112000,1959126353952768000", "code": "\nimport math\ndef a(n):\n    return (n-2)*(n-3)*math.factorial(n-2) \n"}
{"sequence_id": "A098943", "text": "Numbers where 6 is the only even decimal digit.", "sequence": "6,16,36,56,61,63,65,66,67,69,76,96,116,136,156,161,163,165,166,167,169,176,196,316,336,356,361,363,365,366,367,369,376,396,516,536,556,561,563,565,566,567,569,576,596,611,613,615,616,617,619,631,633,635,636", "code": "\nfrom itertools import product\ndef agen(maxdigits):\n    for digs in range(1, maxdigits+1):\n        for p in product(\"135679\", repeat=digs):\n            if '6' in p: yield int(\"\".join(p))\nprint([an for an in agen(3)]) \n"}
{"sequence_id": "A098948", "text": "Numbers where 7 is the only odd decimal digit.", "sequence": "7,27,47,67,70,72,74,76,77,78,87,207,227,247,267,270,272,274,276,277,278,287,407,427,447,467,470,472,474,476,477,478,487,607,627,647,667,670,672,674,676,677,678,687,700,702,704,706,707,708,720,722,724,726", "code": "\ndef ok(n): return set(\"13579\") & set(str(n)) == {'7'}\nprint(list(filter(ok, range(727)))) \n"}
{"sequence_id": "A098949", "text": "Numbers where 9 is the only odd decimal digit.", "sequence": "9,29,49,69,89,90,92,94,96,98,99,209,229,249,269,289,290,292,294,296,298,299,409,429,449,469,489,490,492,494,496,498,499,609,629,649,669,689,690,692,694,696,698,699,809,829,849,869,889,890,892,894,896,898", "code": "\ndef ok(n): return set(str(n)) & set(\"13579\") == set(\"9\")\nprint(list(filter(ok, range(899)))) \n"}
{"sequence_id": "A099004", "text": "First differences of A081145.", "sequence": "1,2,3,-4,5,6,-9,7,8,-14,10,11,-18,12,13,-24,15,16,-30,17,19,-34,20,21,-39,22,23,-43,25,26,-50,27,28,-54,29,31,-57,33,-32,35,36,-70,37,38,-73,40,41,-78,42,44,-85,45,46,-90,47,48,-94,49,51,-97,52,53,-104,55,56,-109,58,59,-116,61,-60,62,63", "code": "\nA099004_list, l, s, b1, b2 = [1], 2, 3, set(), set([1])\nfor n in range(2, 5*10**3+1):\n....i = s\n....while True:\n........m = abs(i-l)\n........if not (i in b1 or m in b2):\n............A099004_list.append(i-l)\n............b1.add(i)\n............b2.add(m)\n............l = i\n............while s in b1:\n................b1.remove(s)\n................s += 1\n............break\n........i += 1 \n"}
{"sequence_id": "A099009", "text": "Fixed points of the Kaprekar mapping f(n) = n' - n'', where in n' the digits of n are arranged in descending, in n'' in ascending order.", "sequence": "0,495,6174,549945,631764,63317664,97508421,554999445,864197532,6333176664,9753086421,9975084201,86431976532,555499994445,633331766664,975330866421,997530864201,999750842001,8643319766532,63333317666664", "code": "\n\ndef extend(base, start, n):\n    if n == 0:\n        yield base\n        return\n    for i in range(start, 10):\n        for x in extend(base + str(i), i, n-1):\n            yield x\ndef drive(n):\n    result = []\n    for lo in extend(\"\", 0, n):\n        ilo = int(lo)\n        if ilo == 0 and n > 1:\n            continue\n        hi = lo[::-1]\n        diff = str(int(hi) - ilo)\n        diff = \"0\" * (n - len(diff)) + diff\n        if sorted(diff) == list(lo):\n            result.append(diff)\n    return sorted(result)\nfor n in range(1, 17):\n    \n    \n    for r in drive(n):\n        print(r, end=', ')\n"}
{"sequence_id": "A099052", "text": "All palindromes of length greater than 1 in the decimal expansion of e, ordered by the ending position of the palindrome. Multiple terms ending at the same position are ordered by the starting position of the palindrome.", "sequence": "828,18281,818,28182,8281828,828,353,747,66,2662,77,757,99,999,99,959,595,66,9669,696,676,77,2772,66,303,353,535,525,66,66,919,39193,99,181,66,33,595,323,232,434,94349,323,33,88,525,101,11,383,99,88,4884,44", "code": "\nfrom sympy import E\ndef ispal(s): return all(s[i] == s[-1-i] for i in range(len(s)//2))\ndef aupto(maxdigs):\n    digits_e = str(E.n(maxdigs+4))[2:]\n    return [int(s) for s in (digits_e[j:k+1] for k in range(1, maxdigs)\n        for j in range(k)) if s[0] != '0' and ispal(s)]\nprint(aupto(240)) \n"}
{"sequence_id": "A099165", "text": "Palindromic in bases 10 and 32.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,22,33,66,99,363,858,1441,2882,5445,6886,9449,15951,19891,21012,29692,32223,54945,369963,477774,564465,585585,609906,672276,717717,780087,804408,912219,1251521,2639362,3825283", "code": "\nfrom gmpy2 import digits\ndef palQ(n,b): \n    s = digits(n,b)\n    return s == s[::-1]\ndef palQgen10(l): \n    if l > 0:\n        yield 0\n        for x in range(1,10**l):\n            s = str(x)\n            yield int(s+s[-2::-1])\n            yield int(s+s[::-1])\nA099165_list = sorted([n for n in palQgen10(6) if palQ(n,32)])\n\n"}
{"sequence_id": "A099174", "text": "Triangle read by rows: coefficients of modified Hermite polynomials.", "sequence": "1,0,1,1,0,1,0,3,0,1,3,0,6,0,1,0,15,0,10,0,1,15,0,45,0,15,0,1,0,105,0,105,0,21,0,1,105,0,420,0,210,0,28,0,1,0,945,0,1260,0,378,0,36,0,1,945,0,4725,0,3150,0,630,0,45,0,1,0,10395,0,17325,0,6930,0,990,0,55", "code": "\nimport sympy\nfrom sympy import Poly\nfrom sympy.abc import x, y\ndef H(n, x): return 1 if n==0 else x if n==1 else x*H(n - 1, x) - (n - 1)*H(n - 2, x)\ndef a(n): return [abs(cf) for cf in Poly(H(n, x), x).all_coeffs()[::-1]]\nfor n in range(21): print(a(n)) \n"}
{"sequence_id": "A099192", "text": "Numbers k such that the string k235711131719 is prime.", "sequence": "5,12,20,23,30,32,38,39,57,62,65,66,72,108,117,120,123,141,143,144,170,176,194,198,207,215,221,225,240,255,269,293,297,305,309,320,321,324,426,446,458,471,480,488,512,521,540,551,557,566,569,570,573,594,599", "code": "\nfrom sympy import isprime\ndef aupto(limit):\n  alst = []\n  for k in range(1, limit+1):\n    if isprime(10**12*k + 235711131719): alst.append(k)\n  return alst\nprint(aupto(500)) \n"}
{"sequence_id": "A099204", "text": "A variation on Flavius's sieve (A000960): Start with the natural numbers; at the k-th sieving step, remove every p-th term of the sequence remaining after the (k-1)-st sieving step, where p is the k-th prime; iterate.", "sequence": "1,3,7,9,15,19,25,31,33,37,45,51,61,63,67,69,81,85,97,105,109,111,123,129,135,141,145,151,159,169,183,189,195,201,211,213,219,225,229,241,261,265,273,277,289,291,307,315,319,321,325,339,351,355,361,375,381", "code": "\nimport sympy\nfrom sympy import prime\ndef a(n):\n..x = 1\n..lst = []\n..lst.extend(range(1, 1000))\n..while x <= n:\n....lst1 = []\n....for i in lst:\n......if (lst.index(i)+1)%prime(x)!=0:\n........lst1.append(i)\n....lst.clear()\n....lst.extend(lst1)\n....x += 1\n..return lst1[n-1]\nn = 1\nwhile n < 100:\n..print(a(n), end=', ')\n..n += 1\n\n"}
{"sequence_id": "A099244", "text": "Greatest common divisor of length of n in binary representation and its number of ones.", "sequence": "1,1,2,1,1,1,3,1,2,2,1,2,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,1,2,2,3,2,3,3,2,2,3,3,2,3,2,2,1,2,3,3,2,3,2,2,1,3,2,2,1,2,1,1,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", "code": "\nfrom math import gcd\ndef a(n): b = bin(n)[2:]; return gcd(len(b), b.count('1'))\nprint([a(n) for n in range(1, 106)]) \n"}
{"sequence_id": "A099254", "text": "Self-convolution of A010892. The g.f. is 1/(Alexander polynomial of granny knot).", "sequence": "1,2,1,-2,-4,-2,3,6,3,-4,-8,-4,5,10,5,-6,-12,-6,7,14,7,-8,-16,-8,9,18,9,-10,-20,-10,11,22,11,-12,-24,-12,13,26,13,-14,-28,-14,15,30,15,-16,-32,-16,17,34,17,-18,-36,-18,19,38,19,-20,-40,-20,21,42,21", "code": "\na0,a1,a2,a3,n = -2,1,2,1,3\nprint(0,a3)\nprint(1,a2)\nprint(2,a1)\nprint(3,a0)\nwhile n < 20000:\n    a0,a1,a2,a3,n = 2*a0-3*a1+2*a2-a3,a0,a1,a2,n+1\n    print(n,a0) \n"}
{"sequence_id": "A099300", "text": "Number of times the digit 9 appears in the first 10^n digits of Pi after the decimal point.", "sequence": "1,14,106,1014,9902,100106,1000040,9999521,100000273,1000036012,9999956635,99999854780", "code": " \nfrom sympy import S\ndef a(n, d=9): return str(S.Pi.n(10**n + 2))[2:-1].count(str(d))\nprint([a(n) for n in range(1, 7)]) \n"}
{"sequence_id": "A099351", "text": "Numbers k such that 5*k! - 1 is prime.", "sequence": "3,5,8,13,20,25,51,97,101,241,266,521,1279,1750,2204,2473", "code": "\nfrom sympy import isprime\nfrom math import factorial\nprint([k for k in range(300) if isprime(5*factorial(k) - 1)]) \n"}
{"sequence_id": "A099377", "text": "Numerators of the harmonic means of the divisors of the positive integers.", "sequence": "1,4,3,12,5,2,7,32,27,20,11,18,13,7,5,80,17,36,19,20,21,22,23,16,75,52,27,3,29,10,31,64,11,68,35,324,37,38,39,32,41,7,43,22,45,23,47,120,49,100,17,156,53,18,55,56,57,116,59,30,61,31,189,448,65,11,67,68,23,35", "code": "\nfrom sympy import gcd, divisor_sigma\ndef A099377(n): return (lambda x, y: y*n//gcd(x,y*n))(divisor_sigma(n),divisor_sigma(n,0)) \n"}
{"sequence_id": "A099378", "text": "Denominators of the harmonic means of the divisors of the positive integers.", "sequence": "1,3,2,7,3,1,4,15,13,9,6,7,7,3,2,31,9,13,10,7,8,9,12,5,31,21,10,1,15,3,16,21,4,27,12,91,19,15,14,9,21,2,22,7,13,9,24,31,19,31,6,49,27,5,18,15,20,45,30,7,31,12,52,127,21,3,34,21,8,9,36,65,37,57,62,35,24,7,40,93", "code": "\nfrom sympy import gcd, divisor_sigma\ndef A099378(n): return (lambda x, y: x//gcd(x,y*n))(divisor_sigma(n),divisor_sigma(n,0)) \n"}
{"sequence_id": "A099442", "text": "Semiprimes of the form 2^k-k-1.", "sequence": "4,26,57,247,502,4083,1073741793,4294967263,8589934558,70368744177617,4503599627370443,4611686018427387841,18889465931478580854709,75557863725914323419059,77371252455336267181195177,316912650057057350374175801245", "code": "\nfrom sympy.ntheory.factor_ import primeomega\ndef ok(n): return primeomega(2**n-n-1) == 2\nprint([2**m-m-1 for m in range(2, 100) if ok(m)]) \n"}
{"sequence_id": "A099563", "text": "a(0) = 0; for n > 0, a(n) = final nonzero number in the sequence n, f(n,2), f(f(n,2),3), f(f(f(n,2),3),4),..., where f(n,d) = floor(n/d); the most significant digit in the factorial base representation of n.", "sequence": "0,1,1,1,2,2,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4", "code": "\ndef a(n):\n    i=2\n    d=0\n    while n:\n        d=n%i\n        n=(n - d)//i\n        i+=1\n    return d\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A099654", "text": "a(n) is the number of n-subsets [n=1,2,...,10] of the 10 decimal digits from which no prime numbers can be constructed. See also A099653.", "sequence": "5,21,24,16,6,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom sympy import binomial\ndef a(n): return binomial(6, n) + binomial(4, n) - 5*(n==1) \n"}
{"sequence_id": "A099884", "text": "XOR difference triangle of the powers of 2, read by rows; Square array A(row,col): A(0,col) = 2^col, A(row,col) = A048724(A(row-1, col)) for row > 0, read by descending antidiagonals.", "sequence": "1,2,3,4,6,5,8,12,10,15,16,24,20,30,17,32,48,40,60,34,51,64,96,80,120,68,102,85,128,192,160,240,136,204,170,255,256,384,320,480,272,408,340,510,257,512,768,640,960,544,816,680,1020,514,771,1024,1536,1280,1920", "code": "\nfrom sympy import binomial\ndef a(n):\n    return sum((binomial(n, i)%2)*2**i for i in range(n + 1))\ndef T(n, k): return 2**(n - k)*a(k)\nfor n in range(21): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A099906", "text": "a(n) = binomial(2n-1,n-1) mod n^2.", "sequence": "0,3,1,3,1,30,1,35,10,78,1,62,1,52,135,35,1,138,1,10,402,124,1,270,126,172,253,476,1,812,1,291,978,870,616,674,1,364,10,410,1,756,1,1124,1260,532,1,1422,1716,1128,2322,1556,1,1920,1941,2172,1815,844,1,3528,1,964", "code": "\nfrom __future__ import division\nA099906_list, b = [], 1\nfor n in range(1,10001):\n    A099906_list.append(b % n**2)\n    b = b*2*(2*n+1)//(n+1) \n"}
{"sequence_id": "A099908", "text": "C(2n-1,n-1) mod n^4.", "sequence": "0,3,10,35,126,462,1716,2339,4627,2378,1332,4238,2198,5148,1260,57635,14740,85026,61732,64410,100509,163716,158172,171918,93876,309780,148969,444220,268280,370712,29792,532771,652200,938386,816466,907874", "code": "\nfrom __future__ import division\nA099908_list, b = [], 1\nfor n in range(1,10001):\n    A099908_list.append(b % n**4)\n    b = b*2*(2*n+1)//(n+1) \n"}
{"sequence_id": "A099946", "text": "a(n) = lcm{1, 2, ..., n}/(n*(n-1)), n >= 2.", "sequence": "1,1,1,3,2,10,15,35,28,252,210,2310,1980,1716,3003,45045,40040,680680,612612,554268,503880,10581480,9699690,44618574,41186376,114406600,106234700,2868336900,2677114440,77636318760,145568097675,136745788725", "code": "\nfrom math import gcd\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\ndef f(lim):\n    l = 1\n    for n in range(2, lim + 1):\n        l = lcm(n, l)\n        print(n, l // (n * (n - 1)))\nf(100) \n"}
{"sequence_id": "A100129", "text": "Numbers k such that 2^k starts with k.", "sequence": "6,10,1542,77075,113939,1122772,2455891300,2830138178,136387767490,2111259099790,3456955336468,4653248164310,10393297007134,321249146279171,972926121017616,72780032758751764", "code": " \nfrom math import log10 as log\nfrac = lambda x: x - int(x)\nis_a100129 = lambda n: 0 <= frac(n * log(2)) - frac(log(n)) < log(n + 1) - log(n) \n"}
{"sequence_id": "A100208", "text": "Minimal permutation of the natural numbers such that the sum of squares of two consecutive terms is a prime.", "sequence": "1,2,3,8,5,4,9,10,7,12,13,20,11,6,19,14,15,22,17,18,23,30,29,16,25,24,35,26,21,34,39,40,33,28,37,32,27,50,31,44,41,46,49,36,65,38,45,52,57,68,43,42,55,58,47,48,53,62,73,60,61,54,59,64,71,66,79,56,51,76,85,72", "code": "\nfrom sympy import isprime\nA100208 = [1]\nfor n in range(1,100):\n    a, b = 1, 1 + A100208[-1]**2\n    while not isprime(b) or a in A100208:\n        b += 2*a+1\n        a += 1\n    A100208.append(a) \n"}
{"sequence_id": "A100223", "text": "G.f. A(x) satisfies: 2^n - 1 = Sum_{k=0..n} [x^k]A(x)^n and also satisfies: (2+z)^n - (1+z)^n + z^n = Sum_{k=0..n} [x^k](A(x)+z*x)^n for all z, where [x^k]A(x)^n denotes the coefficient of x^k in A(x)^n.", "sequence": "1,0,1,1,0,-2,-3,1,11,15,-13,-77,-86,144,595,495,-1520,-4810,-2485,15675,39560,6290,-159105,-324805,87075,1592843,2616757,-2136539,-15726114,-20247800,32296693,152909577,145139491,-417959049,-1460704685,-885536173,4997618808,13658704994,3223741399", "code": "\nA100223 = [1, 0, 1]\nfor n in range(3, 801):\n    A100223.append( ((2*n-3)*A100223[-1]\n      - 5*(n-3)*A100223[-2])//n )  \n"}
{"sequence_id": "A100258", "text": "Triangle of coefficients of normalized Legendre polynomials, with increasing exponents.", "sequence": "1,0,1,-1,0,3,0,-3,0,5,3,0,-30,0,35,0,15,0,-70,0,63,-5,0,105,0,-315,0,231,0,-35,0,315,0,-693,0,429,35,0,-1260,0,6930,0,-12012,0,6435,0,315,0,-4620,0,18018,0,-25740,0,12155,-63,0,3465,0,-30030,0,90090,0,-109395,0,46189", "code": "\nfrom mpmath import *\nmp.dps=20\ndef a007814(n):\n    return 1 + bin(n - 1)[2:].count('1') - bin(n)[2:].count('1')\nfor n in range(11):\n    y=2**sum(a007814(i) for i in range(2, n+1))\n    l=chop(taylor(lambda x: legendre(n, x), 0, n))\n    print([int(i*y) for i in l]) \n"}
{"sequence_id": "A100311", "text": "Modulo 2 binomial transform of 8^n.", "sequence": "1,9,65,585,4097,36873,266305,2396745,16777217,150994953,1090519105,9814671945,68736258049,618626322441,4467856773185,40210710958665,281474976710657,2533274790395913,18295873486192705,164662861375734345", "code": "\na=1\nfor i in range(33):\n    print(a, end=\", \")\n    a = (a*8) ^ a\n\n"}
{"sequence_id": "A100371", "text": "a(n) = 2^phi(n) - 1 = A066781(n) - 1.", "sequence": "1,1,3,3,15,3,63,15,63,15,1023,15,4095,63,255,255,65535,63,262143,255,4095,1023,4194303,255,1048575,4095,262143,4095,268435455,255,1073741823,65535,1048575,65535,16777215,4095,68719476735,262143,16777215,65535", "code": "\nfrom sympy import totient\ndef a(n): return 2**totient(n) - 1 \n"}
{"sequence_id": "A100384", "text": "a(n) = the smallest number x such that for m = x to x + n - 1, A006530(m) increases.", "sequence": "2,2,8,8,90,168,9352,46189,721970,721970,6449639,565062156,11336460025,37151747513,256994754033", "code": "\nfrom sympy import factorint\ndef A100384(n):\n    k, a = 2, [max(factorint(m+2)) for m in range(n)]\n    while True:\n        for i in range(1, n):\n            if a[i-1] >= a[i]:\n                break\n        else:\n            return k\n        a = a[i:] + [max(factorint(k+j+n)) for j in range(i)]\n        k += i \n"}
{"sequence_id": "A100440", "text": "Number of distinct values of i*j + j*k + k*i with 1 <= i <= j <= k <= n.", "sequence": "1,4,10,20,33,50,68,93,123,154,193,233,276,325,377,434,500,568,643,720,804,885,979,1068,1168,1274,1381,1495,1615,1746,1876,2005,2148,2285,2437,2596,2748,2908,3077,3241,3425,3608,3796,3979,4181,4388,4585,4804,5015,5237", "code": "\nfrom numba import njit\n@njit()\ndef aupton(terms):\n  aset, alst = set(), []\n  for n in range(1, terms+1):\n    for i in range(1, n+1):\n      for j in range(i, n+1):\n        aset.add(i*j + j*n + n*i)\n    alst.append(len(aset))\n  return alst\nprint(aupton(50)) \n"}
{"sequence_id": "A100448", "text": "Number of triples (i,j,k) with 1 <= i <= j < k <= n and gcd{i,j,k} = 1.", "sequence": "0,1,4,9,19,30,51,73,106,140,195,241,319,388,480,572,708,813,984,1124,1310,1485,1738,1926,2216,2462,2777,3059,3465,3749,4214,4590,5060,5484,6048,6474,7140,7671,8331,8899,9719,10289,11192,11902,12754,13535,14616", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A100448(n):\n    if n == 0:\n        return 0\n    c, j = 2, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(6*A100448(k1)+1)\n        j, k1 = j2, n//j2\n    return (n*(n**2-1)-c+j)//6 \n"}
{"sequence_id": "A100449", "text": "Number of ordered pairs (i,j) with |i| + |j| <= n and gcd(i,j) <= 1.", "sequence": "1,5,9,17,25,41,49,73,89,113,129,169,185,233,257,289,321,385,409,481,513,561,601,689,721,801,849,921,969,1081,1113,1233,1297,1377,1441,1537,1585,1729,1801,1897,1961,2121,2169,2337,2417,2513,2601,2785,2849,3017", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A100449(n):\n    if n == 0:\n        return 1\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*((A100449(k1)-3)//2)\n        j, k1 = j2, n//j2\n    return 2*(n*(n-1)-c+j)+1 \n"}
{"sequence_id": "A100480", "text": "a(1)=1 and, for n>1, a(n) is the smallest positive integer such that the subset S(c) of {1,2,3,...,n} defined by S(c)={k|1<=k<=n; a(k)=c} does not contain a 3-term arithmetic progression for any integer c.", "sequence": "1,1,2,1,1,2,2,3,3,1,1,2,1,1,2,2,3,3,2,3,3,4,4,5,4,4,5,1,1,2,1,1,2,2,3,3,1,1,2,1,1,2,2,3,3,2,3,3,4,4,5,4,4,5,2,3,3,4,4,5,4,4,5,5,6,6,5,6,6,7,7,8,5,6,6,5,6,6,7,7,8,1,1,2,1,1,2,2,3,3,1,1,2,1,1,2,2,3,3,2,3,3,4,4,5", "code": " \n"}
{"sequence_id": "A100500", "text": "a(n) = prime(3n-2) + prime(3n-1) + prime(3n).", "sequence": "10,31,59,97,131,173,211,251,301,329,395,439,487,533,581,633,689,731,789,829,883,941,1015,1061,1119,1169,1229,1285,1331,1381,1433,1493,1553,1645,1703,1757,1807,1849,1915,1959,2011,2075,2155,2215,2269,2329,2417,2471", "code": "\nfrom sympy import prime, nextprime\ndef a(n):\n    p = prime(3*n - 2); q = nextprime(p); r = nextprime(q)\n    return p + q + r\nprint([a(n) for n in range(1, 49)]) \n"}
{"sequence_id": "A100580", "text": "Palindromic primes containing digits 0 and 1 only. (Palindromic terms in A020449.)", "sequence": "11,101,100111001,110111011,111010111,1100011100011,1100101010011,1101010101011,1110110110111,1110111110111,100110101011001,101000010000101,101011000110101,101110000011101,110011101110011", "code": "\nfrom sympy import isprime\nA100580_list = [11]\nfor i in range(2,2**16):\n....s = format(i,'b')\n....x = int(s+s[-2::-1])\n....if isprime(x):\n........A100580_list.append(x) \n"}
{"sequence_id": "A100613", "text": "Number of elements in the set {(x,y): 1 <= x,y <= n, gcd(x,y) > 1}.", "sequence": "0,1,2,5,6,13,14,21,26,37,38,53,54,69,82,97,98,121,122,145,162,185,186,217,226,253,270,301,302,345,346,377,402,437,458,505,506,545,574,621,622,681,682,729,770,817,818,881,894,953,990,1045,1046,1117,1146,1209", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A100613(n): \n    if n == 0:\n        return 0\n    c, j = 1, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(k1**2-A100613(k1))\n        j, k1 = j2, n//j2\n    return n+c-j \n"}
{"sequence_id": "A100844", "text": "Smallest m greater than n such that m^2 contains n^2 in its decimal representation.", "sequence": "10,4,7,7,13,15,19,43,42,41,90,110,38,130,140,35,160,170,57,190,80,210,220,227,240,75,260,223,279,196,70,219,320,330,340,285,360,370,380,390,400,410,343,136,440,205,460,470,480,490,150,510,520,530,540,305,481", "code": "\ndef a(n):\n    s, m = str(n*n), n+1\n    while s not in str(m*m): m += 1\n    return m\nprint([a(n) for n in range(57)]) \n"}
{"sequence_id": "A100934", "text": "Numbers having more than one representation as the product of consecutive integers.", "sequence": "6,24,120,210,720,5040,40320,175560,362880,3628800,17297280,19958400,39916800,259459200,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,20274183401472000,121645100408832000", "code": "\nimport heapq\ndef aupton(terms, verbose=False):\n    p = 1*2; h = [(p, 1, 2)]; nextcount = 3; alst = []; oldv = None\n    while len(alst) < terms:\n        (v, s, l) = heapq.heappop(h)\n        if v == oldv and v not in alst:\n            alst.append(v)\n            if verbose: print(f\"{v}, [= Prod_{{i = {s}..{l}}} i = Prod_{{i = {olds}..{oldl}}} i]\")\n        if v >= p:\n            p *= nextcount\n            heapq.heappush(h, (p, 1, nextcount))\n            nextcount += 1\n        oldv, olds, oldl = v, s, l\n        v //= s; s += 1; l += 1; v *= l\n        heapq.heappush(h, (v, s, l))\n    return alst\nprint(aupton(20, verbose=True)) \n"}
{"sequence_id": "A101045", "text": "Record size primes in A101044.", "sequence": "2,3,5,7,13,19,31,43,53,67,79,101,149,157,163,181,197,227,307,349,379,409,431,619,631,661,691,751,757,811,829,1093,1117,1217,1279,1423,1453,1481,1531,1549,1579,1759,1877,2239,2273,2287,2383,2447,2659,2671,2707", "code": "\nfrom sympy import isprime, nextprime\nm = p_max = 0\nwhile m >= 0:\n    p = 2\n    while isprime(p + 2*m) == 0:\n        p = nextprime(p)\n    if p > p_max:\n        print(p)\n        p_max = p\n    m += 1 \n"}
{"sequence_id": "A101080", "text": "Table of Hamming distances between binary vectors representing i and j, for i >= 0, j >= 0, read by antidiagonals.", "sequence": "0,1,1,1,0,1,2,2,2,2,1,1,0,1,1,2,2,1,1,2,2,2,1,2,0,2,1,2,3,3,3,3,3,3,3,3,1,2,1,2,0,2,1,2,1,2,2,2,2,1,1,2,2,2,2,2,1,2,1,1,0,1,1,2,1,2,3,3,3,3,2,2,2,2,3,3,3,3,2,2,1,2,2,1,0,1,2,2,1,2,2,3,3,2,2,3,3,1,1,3,3,2,2,3,3", "code": "\nfor n in range(20):\n    print([bin(k^(n - k))[2:].count(\"1\") for k in range(n + 1)]) \n"}
{"sequence_id": "A101211", "text": "Triangle read by rows: n-th row is length of run of leftmost 1's, followed by length of run of 0's, followed by length of run of 1's, etc., in the binary representation of n.", "sequence": "1,1,1,2,1,2,1,1,1,2,1,3,1,3,1,2,1,1,1,1,1,1,1,2,2,2,2,1,1,3,1,4,1,4,1,3,1,1,2,1,1,1,2,2,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,3,2,3,2,2,1,2,1,1,1,2,1,2,3,2,3,1,1,4,1,5,1,5,1,4,1,1,3,1,1,1,3,2,1,2,1,2,1,2,1,1,1,1,2,2,1", "code": "\nfrom itertools import groupby\ndef arow(n): return [len(list(g)) for k, g in groupby(bin(n)[2:])]\ndef auptorow(rows):\n    alst = []\n    for i in range(1, rows+1): alst.extend(arow(i))\n    return alst\nprint(auptorow(38)) \n"}
{"sequence_id": "A101300", "text": "Second-smallest prime larger than n.", "sequence": "3,3,5,7,7,11,11,13,13,13,13,17,17,19,19,19,19,23,23,29,29,29,29,31,31,31,31,31,31,37,37,41,41,41,41,41,41,43,43,43,43,47,47,53,53,53,53,59,59,59,59,59,59,61,61,61,61,61,61,67,67,71,71,71,71,71,71,73,73,73,73", "code": "\nfrom sympy import nextprime\ndef a(n): return nextprime(nextprime(n))\nprint([a(n) for n in range(71)]) \n"}
{"sequence_id": "A101312", "text": "Number of \"Friday the 13ths\" in year n (starting at 1901).", "sequence": "2,1,3,1,2,2,2,2,1,1,2,2,1,3,1,1,2,2,1,2,1,2,2,1,3,1,1,3,2,1,3,1,2,2,2,2,1,1,2,2,1,3,1,1,2,2,1,2,1,2,2,1,3,1,1,3,2,1,3,1,2,2,2,2,1,1,2,2,1,3,1,1,2,2,1,2,1,2,2,1,3,1,1,3,2,1,3,1,2,2,2,2,1,1,2,2,1,3,1,1,2,2,1,2,1", "code": "\nfrom datetime import date\ndef a(n):\n    return sum(date.isoweekday(date(n, m, 13)) == 5 for m in range(1, 13))\nprint([a(n) for n in range(1901, 2006)]) \n"}
{"sequence_id": "A101334", "text": "a(n) = n^n - (n+1)^(n-1).", "sequence": "0,0,1,11,131,1829,29849,561399,11994247,287420489,7642052309,223394306387,7123940054219,246181194216957,9165811757198641,365836296342931439,15584321022199735823,705800730789742512401,33866021217511735389485,1716275655660313589123979", "code": "\nprint([n**n - (n+1)**(n-1) for n in range(33)]) \n"}
{"sequence_id": "A101337", "text": "Sum of (each digit of n raised to the power (number of digits in n)).", "sequence": "1,2,3,4,5,6,7,8,9,1,2,5,10,17,26,37,50,65,82,4,5,8,13,20,29,40,53,68,85,9,10,13,18,25,34,45,58,73,90,16,17,20,25,32,41,52,65,80,97,25,26,29,34,41,50,61,74,89,106,36,37,40,45,52,61,72,85,100,117,49,50,53,58,65", "code": "\ndef A101337(n):\n    s = str(n)\n    l = len(s)\n    return sum(int(d)**l for d in s) \n"}
{"sequence_id": "A101611", "text": "a(n) = n! * Sum_{k=ceiling(n/2)..n} 1/k.", "sequence": "1,3,5,26,94,684,3828,35664,270576,3068640,29400480,392722560,4546558080,69878833920,948550176000,16484477184000,256697973504000,4976250951168000,87435019510272000,1870345490614272000", "code": "\nimport math\nfrom sympy import factorial\ndef a(n): return factorial(n)*sum([1/k for k in range(int(math.ceil(n/2)), n + 1)]) \n"}
{"sequence_id": "A101624", "text": "Stern-Jacobsthal numbers.", "sequence": "1,1,3,1,7,5,11,1,23,21,59,17,103,69,139,1,279,277,827,273,1895,1349,2955,257,5655,5141,14395,4113,24679,16453,32907,1,65815,65813,197435,65809,460647,329029,723851,65793,1512983,1381397,3881019,1118225", "code": "\nprpr = 1\nprev = 1\nprint(\"1, 1\", end=\", \")\nfor i in range(99):\n    current = (prev)^(prpr*2)\n    print(current, end=\", \")\n    prpr = prev\n    prev = current\n\n"}
{"sequence_id": "A101625", "text": "A bisection of the Stern-Jacobsthal numbers.", "sequence": "0,1,1,5,1,21,17,69,1,277,273,1349,257,5141,4113,16453,1,65813,65809,329029,65793,1381397,1118225,4538437,65537,18088213,17826065,88081733,16777473,335549461,268439569,1073758277,1,4295033109,4295033105", "code": "\nprpr = 0\nprev = 1\nfor i in range(99):\n    current = (prev)^(prpr*4)\n    print(prpr, end=',')\n    prpr = prev\n    prev = current\n\n"}
{"sequence_id": "A101701", "text": "Numbers n such that n = sum of the reversals of divisors of n.", "sequence": "1,207321,890827,7591023,18368601,4885292403", "code": "\nfrom sympy import divisors\nA101701_list = [n for n in range(1,10**6) if n == sum([int(d) for d in (str(x)[::-1] for x in divisors(n))])]\n\n"}
{"sequence_id": "A101864", "text": "Wythoff BB numbers.", "sequence": "5,13,18,26,34,39,47,52,60,68,73,81,89,94,102,107,115,123,128,136,141,149,157,162,170,178,183,191,196,204,212,217,225,233,238,246,251,259,267,272,280,285,293,301,306,314,322,327,335,340,348,356,361,369,374,382,390,395", "code": "\nfrom sympy import S\nfor n in range(1,60): print(int(S.GoldenRatio**2*(int(n*S.GoldenRatio**2))), end=', ') \n"}
{"sequence_id": "A102111", "text": "Iccanobirt numbers (1 of 15): a(n) = a(n-1) + a(n-2) + R(a(n-3)), where R is the digit reversal function A004086.", "sequence": "0,0,1,1,2,4,7,13,24,44,99,185,328,612,1521,2956,4693,8900,20185,33049,53332,144483,291848,459666,1135955,2443813,4246722,12285846,19716010,34278280,118852511,154192582,281332336,550783729,1117407516,2301424427", "code": "\ndef R(n):\n  n_str = str(n)\n  reversedn_str = n_str[::-1]\n  reversedn = int(reversedn_str)\n  return reversedn\ndef A(n):\n  if n == 0:\n    return 0\n  elif n == 1:\n    return 0\n  elif n == 2:\n    return 1\n  elif n >= 3:\n    return A(n-1)+A(n-2)+R(A(n-3))\nfor i in range(0,20):\n  print(A(i)) \n"}
{"sequence_id": "A102370", "text": "\"Sloping binary numbers\": write numbers in binary under each other (right-justified), read diagonals in upward direction, convert to decimal.", "sequence": "0,3,6,5,4,15,10,9,8,11,14,13,28,23,18,17,16,19,22,21,20,31,26,25,24,27,30,61,44,39,34,33,32,35,38,37,36,47,42,41,40,43,46,45,60,55,50,49,48,51,54,53,52,63,58,57,56,59,126,93,76,71,66,65,64,67,70,69", "code": "\ndef a(n): return 0 if n<1 else sum([(n + k)&(2**k) for k in range(len(bin(n)[2:]) + 1)]) \n"}
{"sequence_id": "A102371", "text": "Numbers missing from A102370.", "sequence": "1,2,7,12,29,62,123,248,505,1018,2047,4084,8181,16374,32755,65520,131057,262130,524279,1048572,2097133,4194286,8388587,16777192,33554409,67108842,134217711,268435428,536870885", "code": "\na=1\nfor n in range(2,66):\n    print(a, end=\",\")\n    a ^= a+n\n\n"}
{"sequence_id": "A102376", "text": "a(n) = 4^A000120(n).", "sequence": "1,4,4,16,4,16,16,64,4,16,16,64,16,64,64,256,4,16,16,64,16,64,64,256,16,64,64,256,64,256,256,1024,4,16,16,64,16,64,64,256,16,64,64,256,64,256,256,1024,16,64,64,256,64,256,256,1024,64,256,256,1024,256,1024,1024", "code": "\ndef a(n): return 4**bin(n)[2:].count(\"1\") \n"}
{"sequence_id": "A102419", "text": "\"Dropping time\" in 3x+1 problem starting at n (number of steps to reach a lower number than starting value); a(1) = 0 by convention. Also called glide(n).", "sequence": "0,1,6,1,3,1,11,1,3,1,8,1,3,1,11,1,3,1,6,1,3,1,8,1,3,1,96,1,3,1,91,1,3,1,6,1,3,1,13,1,3,1,8,1,3,1,88,1,3,1,6,1,3,1,8,1,3,1,11,1,3,1,88,1,3,1,6,1,3,1,83,1,3,1,8,1,3,1,13,1,3,1,6,1,3,1,8,1,3,1,73,1,3,1,13,1,3,1,6", "code": "\ndef a(n):\n    if n<3: return n - 1\n    N=n\n    x=0\n    while True:\n        if n%2==0: n//=2\n        else: n = 3*n + 1\n        x+=1\n        if n<N: return x\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A102487", "text": "Numbers in base-12 representation that can be written with decimal digits.", "sequence": "0,1,2,3,4,5,6,7,8,9,12,13,14,15,16,17,18,19,20,21,24,25,26,27,28,29,30,31,32,33,36,37,38,39,40,41,42,43,44,45,48,49,50,51,52,53,54,55,56,57,60,61,62,63,64,65,66,67,68,69,72,73,74,75,76,77,78,79,80,81,84,85,86", "code": "\nA102487_list = [int(str(x), 12) for x in range(10**6)] \n"}
{"sequence_id": "A102490", "text": "Numbers in base-16 representation that cannot be written with decimal digits.", "sequence": "10,11,12,13,14,15,26,27,28,29,30,31,42,43,44,45,46,47,58,59,60,61,62,63,74,75,76,77,78,79,90,91,92,93,94,95,106,107,108,109,110,111,122,123,124,125,126,127,138,139,140,141,142,143,154,155,156,157,158,159,160", "code": "\ndef ok(n): return any(hd > '9' for hd in hex(n)[2:])\nprint(list(filter(ok, range(161)))) \n"}
{"sequence_id": "A102491", "text": "Numbers whose base-20 representation can be written with decimal digits.", "sequence": "0,1,2,3,4,5,6,7,8,9,20,21,22,23,24,25,26,27,28,29,40,41,42,43,44,45,46,47,48,49,60,61,62,63,64,65,66,67,68,69,80,81,82,83,84,85,86,87,88,89,100,101,102,103,104,105,106,107,108,109,120,121,122,123,124,125,126", "code": "\nA102491_list = [int(str(x), 20) for x in range(10**6)] \n"}
{"sequence_id": "A102542", "text": "Numbers k such that k333333 is prime.", "sequence": "10,29,31,32,34,46,50,58,62,76,79,82,83,89,100,103,109,113,115,127,137,149,151,157,158,178,184,190,194,199,205,212,218,223,236,241,257,298,302,317,326,328,337,356,358,373,386,388,395,404,409,419,449,460,464,467,479,485,488,491,502,512", "code": "\nfrom sympy import isprime\ndef aupto(limit):\n    return [k for k in range(limit+1) if isprime(int(str(k) + \"333333\"))]\nprint(aupto(512)) \n"}
{"sequence_id": "A103185", "text": "a(n) = Sum_{ k >= 0 such that n + k == 0 mod 2^k } 2^(k-1).", "sequence": "0,1,2,1,0,5,2,1,0,1,2,1,8,5,2,1,0,1,2,1,0,5,2,1,0,1,2,17,8,5,2,1,0,1,2,1,0,5,2,1,0,1,2,1,8,5,2,1,0,1,2,1,0,5,2,1,0,1,34,17,8,5,2,1,0,1,2,1,0,5,2,1,0,1,2,1,8,5,2,1,0,1,2,1,0,5,2,1,0,1,2,17,8,5,2,1,0,1,2,1,0,5,2,1", "code": "\ndef a102370(n): return 0 if n<1 else sum([(n + k)&(2**k) for k in range(len(bin(n)[2:]) + 1)])\ndef a(n): return (a102370(n) - n)/2 \n"}
{"sequence_id": "A103339", "text": "Numerator of the unitary harmonic mean (i.e., the harmonic mean of the unitary divisors) of the positive integer n.", "sequence": "1,4,3,8,5,2,7,16,9,20,11,12,13,7,5,32,17,12,19,8,21,22,23,8,25,52,27,14,29,10,31,64,11,68,35,72,37,38,39,80,41,7,43,44,3,23,47,48,49,100,17,104,53,18,55,28,57,116,59,4,61,31,63,128,65,11,67,136,23,35,71,16,73", "code": "\nfrom sympy import gcd\nfrom sympy.ntheory.factor_ import udivisor_sigma\ndef A103339(n): return (lambda x, y: y*n//gcd(x,y*n))(udivisor_sigma(n),udivisor_sigma(n,0)) \n"}
{"sequence_id": "A103340", "text": "Denominator of the unitary harmonic mean (i.e., the harmonic mean of the unitary divisors) of the positive integer n.", "sequence": "1,3,2,5,3,1,4,9,5,9,6,5,7,3,2,17,9,5,10,3,8,9,12,3,13,21,14,5,15,3,16,33,4,27,12,25,19,15,14,27,21,2,22,15,1,9,24,17,25,39,6,35,27,7,18,9,20,45,30,1,31,12,20,65,21,3,34,45,8,9,36,5,37,57,26,25,24,7,40,51,41,63", "code": "\nfrom sympy import gcd\nfrom sympy.ntheory.factor_ import udivisor_sigma\ndef A103340(n): return (lambda x, y: x//gcd(x,y*n))(udivisor_sigma(n),udivisor_sigma(n,0)) \n"}
{"sequence_id": "A103523", "text": "Concatenations of pairs of primes that differ by 100.", "sequence": "3103,7107,13113,31131,37137,67167,73173,79179,97197,127227,139239,151251,157257,163263,181281,193293,211311,283383,331431,349449,367467,379479,409509,421521,457557,463563,487587,499599,541641,547647,577677", "code": "\nfrom sympy import isprime, primerange as prange\ndef auptop(lim):\n  return [int(str(p)+str(p+100)) for p in prange(2, lim+1) if isprime(p+100)]\nprint(auptop(577)) \n"}
{"sequence_id": "A103529", "text": "Values of A102370 which are >= a new power of 2.", "sequence": "0,3,6,15,28,61,126,251,504,1017,2042,4095,8180,16373,32758,65523,131056,262129,524274,1048567,2097148,4194285,8388590,16777195,33554408,67108841,134217706,268435439,536870884,1073741797,2147483622", "code": "\na=3\nprint(0, end=',')\nfor i in range(2,55):\n    print(a, end= ',')\n    a ^= a+i\n\n"}
{"sequence_id": "A103542", "text": "Binary equivalents of A102370.", "sequence": "0,11,110,101,100,1111,1010,1001,1000,1011,1110,1101,11100,10111,10010,10001,10000,10011,10110,10101,10100,11111,11010,11001,11000,11011,11110,111101,101100,100111,100010,100001,100000,100011,100110,100101", "code": "\ndef a(n): return '0' if n<1 else bin(sum([(n + k)&(2**k) for k in range(len(bin(n)[2:]) + 1)]))[2:] \n"}
{"sequence_id": "A103831", "text": "For even n, a(n) = n*(n+1), for odd n, a(n) = 2*n + 1.", "sequence": "0,3,6,7,20,11,42,15,72,19,110,23,156,27,210,31,272,35,342,39,420,43,506,47,600,51,702,55,812,59,930,63,1056,67,1190,71,1332,75,1482,79,1640,83,1806,87,1980,91,2162,95,2352,99,2550,103,2756,107,2970,111,3192,115", "code": "\nfor n in range(0,10**3):\n    print((n**2+3*n+1+(n**2-n-1)*(-1)**n)/2)\n\n"}
{"sequence_id": "A103832", "text": "For even n, a(n)=2n+1, for odd n, a(n)=n(n+1)", "sequence": "1,2,5,12,9,30,13,56,17,90,21,132,25,182,29,240,33,306,37,380,41,462,45,552,49,650,53,756,57,870,61,992,65,1122,69,1260,73,1406,77,1560,81,1722,85,1892,89,2070,93,2256,97,2450,101,2652,105,2862,109,3080,113", "code": "\nfor n in range(0,10**3):\n    print((int)((n**2+3*n+1-(n**2-n-1)*(-1)**n)/2))\n\n"}
{"sequence_id": "A103835", "text": "Smallest prime p, larger than previous term, such that concatenation of n and p is a prime.", "sequence": "3,11,13,19,23,31,43,53,67,97,113,149,151,173,193,223,239,251,373,389,397,409,431,439,457,479,487,499,569,577,601,647,739,757,797,809,811,821,827,829,863,929,991,1109,1181,1297,1301,1303,1327,1367,1409,1429", "code": "\nfrom sympy import isprime, nextprime\ndef ispal(n): s = str(n); return s == s[::-1]\ndef aupto(lim):\n  n, p, alst = 1, 2, []\n  while p <= lim:\n    if isprime(int(str(n)+str(p))): n, alst = n + 1, alst + [p]\n    p = nextprime(p)\n  return alst\nprint(aupto(1429)) \n"}
{"sequence_id": "A103836", "text": "Smallest palindromic prime p, larger than previous term, such that concatenation of n and p is a prime.", "sequence": "3,11,181,373,12821,14741,32323,72227,74747,77977,78887,79997,90709,94049,94849,98689,1055501,1065601,1114111,1129211,1134311,1177711,1180811,1186811,1190911,1262621,1333331,1338331,1407041,1409041,1411141,1461641,1463641", "code": "\nfrom sympy import isprime, nextprime\ndef ispal(n): s = str(n); return s == s[::-1]\ndef aupto(lim):\n  n, p, alst = 1, 2, []\n  while p <= lim:\n    if ispal(p) and isprime(int(str(n)+str(p))): n, alst = n + 1, alst + [p]\n    p = nextprime(p)\n  return alst\nprint(aupto(1463641)) \n"}
{"sequence_id": "A103897", "text": "a(n) = 3*2^(n-1)*(2^n-1).", "sequence": "3,18,84,360,1488,6048,24384,97920,392448,1571328,6288384,25159680,100651008,402628608,1610563584,6442352640,25769607168,103078821888,412316073984,1649265868800,6597066620928,26388272775168,105553103683584,422212439900160", "code": " b = list(range(0,2**20-1)); a = [sum(b[2**i-1:2**(i+1)-1]) for i in range(1,20)] \n"}
{"sequence_id": "A104166", "text": "Repdigit Smith numbers.", "sequence": "4,22,666,1111,6666666,4444444444,44444444444444444444,555555555555555555555555555,55555555555555555555555555555555,4444444444444444444444444444444444444444444444444444444", "code": "\nfrom sympy import factorint\nfrom itertools import product\ndef sd(n): return sum(map(int, str(n)))\ndef smith(n):\n  f = factorint(n)\n  return sum(f[p] for p in f) > 1 and sd(n) == sum(sd(p)*f[p] for p in f)\ndef repsto(limit):\n  yield from range(min(limit, 9)+1)\n  for rep in range(2, 10**len(str(limit))):\n    for digit in \"123456789\":\n      out = int(digit*rep)\n      if out > limit: return\n      yield out\nprint(list(filter(smith, repsto(10**32)))) \n"}
{"sequence_id": "A104171", "text": "Reversible Smith numbers, i.e., Smith numbers whose reversal is also a Smith number.", "sequence": "4,22,58,85,121,202,265,319,454,535,562,636,666,913,1111,1507,1642,1881,1894,1903,2461,2583,2605,2614,2839,3091,3663,3852,4162,4198,4369,4594,4765,4788,4794,4954,4974,4981,5062,5386,5458,5539,5674,5818,5926,6295", "code": "\nfrom sympy import factorint\ndef sd(n): return sum(map(int, str(n)))\ndef smith(n):\n  f = factorint(n)\n  return sum(f[p] for p in f) > 1 and sd(n) == sum(sd(p)*f[p] for p in f)\ndef ok(n): return smith(n) and smith(int(str(n)[::-1]))\nprint(list(filter(ok, range(6296)))) \n"}
{"sequence_id": "A104174", "text": "Numerator of the fractional part of a harmonic number.", "sequence": "0,1,5,1,17,9,83,201,2089,2341,551,2861,64913,90653,114677,274399,5385503,2022061,42503239,9276623,3338549,3573693,87368107,276977179,7281378067,7624597867,71595952403,74464289303,2239777822987", "code": "\nfrom sympy import harmonic\ndef A104174(n): return (lambda x: x.p % x.q)(harmonic(n)) \n"}
{"sequence_id": "A104175", "text": "From the words to the song \"867-5309/Jenny\" by Tommy Tutone.", "sequence": "8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9", "code": "\ndef a(n): return [8, 6, 7, 5, 3, 0, 9][(n-1)%7]\nprint([a(n) for n in range(1, 85)]) \n"}
{"sequence_id": "A104242", "text": "Primes which are the concatenation of two consecutive square numbers.", "sequence": "6481,144169,324361,400441,784841,16001681,23042401,67246889,77447921,84648649,92169409,96049801,1254412769,1638416641,1742417689,1960019881,2016420449,4752447961,5382454289,5664457121,5760058081,6051661009", "code": "\nfrom sympy import isprime\nA104242_list = []\nfor n in range(1,2000):\n....x = int(str(n**2)+str((n+1)**2))\n....if isprime(x):\n........A104242_list.append(x) \n"}
{"sequence_id": "A104247", "text": "Primes that are the sum of digits of the first k primes for some k.", "sequence": "2,5,17,19,23,31,41,61,71,83,181,269,389,419,449,631,683,727,743,809,929,1039,1061,1069,1091,1277,1381,1481,1567,1613,1747,1873,1951,1993,2039,2129,2281,2297,2339,2381,2549,2579", "code": "\nfrom sympy import isprime, nextprime\ndef sd(n): return sum(map(int, str(n)))\ndef aupto(limit):\n    alst, k, p, s = [], 1, 2, 2\n    while s <= limit:\n        if isprime(s): alst.append(s)\n        k += 1; p = nextprime(p); s += sd(p)\n    return alst\nprint(aupto(2579)) \n"}
{"sequence_id": "A104264", "text": "Number of n-digit squares with no zero digits.", "sequence": "3,6,19,44,136,376,1061,2985,8431,24009,67983,193359,549697,1563545,4446173,12650545,35999714,102439796,291532841,829634988,2360947327,6719171580,19122499510,54423038535,154888366195", "code": "\ndef aupton(terms):\n  c, k, kk = [0 for i in range(terms)], 1, 1\n  while kk < 10**terms:\n    s = str(kk)\n    c[len(s)-1], k, kk = c[len(s)-1] + (s.count('0')==0), k+1, kk + 2*k + 1\n  return c\nprint(aupton(14)) \n"}
{"sequence_id": "A104265", "text": "Smallest n-digit square with no zero digits.", "sequence": "1,16,121,1156,11236,111556,1115136,11115556,111112681,1111155556,11111478921,111111555556,1111118377216,11111115555556,111111226346761,1111111155555556,11111112515384644,111111111555555556,1111111112398242916,11111111115555555556,111111111113333185156,1111111111155555555556", "code": "\nfrom sympy import integer_nthroot\ndef A104265(n):\n    m, a = integer_nthroot((10**n-1)//9,2)\n    if not a:\n        m += 1\n    k = m**2\n    while '0' in str(k):\n        m += 1\n        k += 2*m-1\n    return k \n"}
{"sequence_id": "A104275", "text": "Numbers n such that 2n-1 is not prime.", "sequence": "1,5,8,11,13,14,17,18,20,23,25,26,28,29,32,33,35,38,39,41,43,44,46,47,48,50,53,56,58,59,60,61,62,63,65,67,68,71,72,73,74,77,78,80,81,83,85,86,88,89,92,93,94,95,98,101,102,103,104,105,107,108,109,110,111,113", "code": "\nfrom sympy import isprime\ndef ok(n): return not isprime(2*n-1)\nprint(list(filter(ok, range(1, 114)))) \n"}
{"sequence_id": "A104301", "text": "Primes which are the reverse concatenation of two consecutive square numbers.", "sequence": "41,6449,196169,576529,11561089,14441369,27042601,38443721,51845041,60845929,67246561,84648281,1081610609,2073620449,2190421609,2822427889,3240032041,4000039601,4326442849,5017649729,5290052441,6250062001", "code": "\nfrom sympy import isprime\nA104301_list = []\nfor n in range(1,2000):\n....x = int(str((n+1)**2)+str(n**2))\n....if isprime(x):\n........A104301_list.append(x) \n"}
{"sequence_id": "A104476", "text": "a(n) = binomial(n+7,7)*binomial(n+11,7).", "sequence": "330,6336,61776,411840,2123550,9060480,33372768,109219968,324246780,886828800,2261413440,5427392256,12352970916,26829982080,55895796000,112183843200,217706770710,409800980160,750266946000,1339149240000,2335141487250,3985308138240", "code": "\nA104476_list, m = [], [3432, -1716, 660, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330]\nfor _ in range(10**2):\n    A104476_list.append(m[-1])\n    for i in range(14):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A104496", "text": "Expansion of 2*(2*x+1)/((x+1)*(sqrt(4*x+1)+1)).", "sequence": "1,0,0,-1,5,-19,67,-232,804,-2806,9878,-35072,125512,-452388,1641028,-5986993,21954973,-80884423,299233543,-1111219333,4140813373,-15478839553,58028869153,-218123355523,821908275547,-3104046382351,11747506651599,-44546351423299,169227201341651", "code": "\nfrom itertools import accumulate\ndef A104496_list(size):\n    if size < 1: return []\n    L, accu = [1], [1]\n    for n in range(size-1):\n        accu = list(accumulate(accu + [-accu[0]]))\n        L.append(-(-1)**n*accu[-1])\n    return L\nprint(A104496_list(29)) \n"}
{"sequence_id": "A104675", "text": "a(n) = C(n+1,n) * C(n+6,1).", "sequence": "6,14,24,36,50,66,84,104,126,150,176,204,234,266,300,336,374,414,456,500,546,594,644,696,750,806,864,924,986,1050,1116,1184,1254,1326,1400,1476,1554,1634,1716,1800,1886,1974,2064,2156,2250,2346,2444,2544,2646", "code": "\nfrom sympy import binomial\ndef a(n): return binomial(n + 1, n) * binomial(n + 6, 1) \n"}
{"sequence_id": "A104696", "text": "Rearrangement of positive integers: change odd digits d to 10-d.", "sequence": "9,2,7,4,5,6,3,8,1,90,99,92,97,94,95,96,93,98,91,20,29,22,27,24,25,26,23,28,21,70,79,72,77,74,75,76,73,78,71,40,49,42,47,44,45,46,43,48,41,50,59,52,57,54,55,56,53,58,51,60,69,62,67,64,65,66,63,68,61,30,39,32", "code": "\ndef f(d): return 10 - d if d%2 == 1 else d\ndef a(n): return int(\"\".join(str(f(int(d))) for d in str(n)))\nprint([a(n) for n in range(1, 73)]) \n"}
{"sequence_id": "A104711", "text": "Triangle T(n,m) = sum_{k=m..n} A001263(k,m).", "sequence": "1,2,1,3,4,1,4,10,7,1,5,20,27,11,1,6,35,77,61,16,1,7,56,182,236,121,22,1,8,84,378,726,611,218,29,1,9,120,714,1902,2375,1394,365,37,1,10,165,1254,4422,7667,6686,2885,577,46,1,11,220,2079,9372,21527,26090,16745", "code": "\nfrom sympy import binomial\ndef A001263(n,m):\n    return binomial(n-1,m-1)*binomial(n,m-1)//m\ndef A104711(n,m):\n    a = 0\n    for k in range(m,n+1):\n        a += A001263(k,m)\n    return a\nprint([A104711(n,m) for n in range(20) for m in range(1,n+1)]) \n"}
{"sequence_id": "A104732", "text": "Square array T[i,j]=T[i-1,j]+T[i-1,j-1], T[1,j]=j, T[i,1]=1, read by antidiagonals.", "sequence": "1,2,1,3,3,1,4,5,4,1,5,7,8,5,1,6,9,12,12,6,1,7,11,16,20,17,7,1,8,13,20,28,32,23,8,1,9,15,24,36,48,49,30,9,1,10,17,28,44,64,80,72,38,10,1,11,19,32,52,80,112,129,102,47,11,1,12,21,36,60,96,144,192,201,140,57,12,1", "code": "\ndef A104732_rows(n):\n    \"\"\"Produces n rows of A104732 triangle\"\"\"\n    from operator import iadd\n    a,b,c = [], [1], [1]\n    for i in range(2,n+1):\n            a,b = b, [i]+list(map(iadd,a,b[:-1]))+[1]\n            c+=b\n    return c\n\n"}
{"sequence_id": "A104804", "text": "\"Rounded hypotenuses\": a(n) = round(sqrt(a(n-1)^2 + a(n-2)^2)), a(1)=1, a(2)=3.", "sequence": "1,3,3,4,5,6,8,10,13,16,21,26,33,42,53,68,86,110,140,178,226,288,366,466,593,754,959,1220,1552,1974,2511,3194,4063,5168,6574,8362,10637,13530,17211,21892,27847,35422,45057,57314,72904,92736,117962,150050", "code": "\nfrom gmpy2 import isqrt_rem\nA104804_list = [1,3]\nfor _ in range(1000):\n    i, j = isqrt_rem(A104804_list[-1]**2+A104804_list[-2]**2)\n    A104804_list.append(int(i+ int(4*(j-i) >= 1))) \n"}
{"sequence_id": "A104862", "text": "First differences of A014292.", "sequence": "0,1,1,1,1,0,-2,-5,-9,-13,-15,-12,0,25,65,117,169,196,158,3,-321,-841,-1519,-2200,-2560,-2079,-79,4121,10881,19720,28638,33435,27351,1547,-52895,-140772,-256000,-372775,-436655,-359763,-26871", "code": "\na = [0]*1000\na[1]=1\nfor n in range(1,55):\n    print(a[n-1], end=\", \")\n    s=sum(a[k] for k in range(n-2))\n    a[n+1] = a[n]-s\n\n"}
{"sequence_id": "A104865", "text": "Length of sections with the same initial and final digits in the decimal expansion of Pi.", "sequence": "10,22,19,11,18,21,5,11,2,7,20,14,6,44,4,34,17,10,6,15,8,12,10,4,11,13,21,24,16,5,11,17,19,39,33,17,4,8,7,3,20,10,6,4,21,20,11,12,3,5,4,5,27,2,3,21,7,22,13,7,6,8,4,4,8,2,2,8,4,4,11,3,9,28,7,49,30,3,5,8,24,5,11,3", "code": "\nfrom sympy import S\n\n\npi_digits = str(S.Pi.n(2*10**5))[:-1] \npi_digits = pi_digits.replace(\".\", \"\")\ndef aupton(terms):\n    alst, idx = [], 0\n    for n in range(1, terms+1):\n        digit, idx, c = pi_digits[idx], idx+1, 2\n        while pi_digits[idx] != digit:\n            idx += 1; c += 1\n            assert idx < len(pi_digits), \"increase precision\"\n        alst.append(c); idx += 1\n    return alst\nprint(aupton(84)) \n"}
{"sequence_id": "A104866", "text": "Initial and final digits in the partition of decimal expansion of Pi.", "sequence": "3,5,0,5,9,9,8,0,6,4,4,0,2,7,5,9,0,3,2,1,4,5,5,2,0,9,2,0,9,5,3,8,5,6,7,3,7,7,1,7,5,1,2,6,0,9,0,1,0,7,9,2,3,4,1,5,1,1,0,9,5,9,0,2,5,3,4,6,1,1,7,8,7,5,9,0,5,9,2,0,9,3,3,0,1,8,9,5,9,4,9,1,5,5,7,2,5,0,4,8", "code": "\nfrom sympy import S\n\n\npi_digits = str(S.Pi.n(2*10**5))[:-1] \npi_digits = pi_digits.replace(\".\", \"\")\ndef aupton(terms):\n    alst, idx = [], 0\n    for n in range(1, terms+1):\n        digit, idx, c = pi_digits[idx], idx+1, 2\n        while pi_digits[idx] != digit:\n            idx += 1; c += 1\n            assert idx < len(pi_digits), \"increase precision\"\n        alst.append(int(digit)); idx += 1\n    return alst\nprint(aupton(100)) \n"}
{"sequence_id": "A104867", "text": "Records in A104865.", "sequence": "10,22,44,49,57,70,71,82,98,100,104,119,136,139,140,149,162,163", "code": "\nfrom sympy import S\n\n\npi_digits = str(S.Pi.n(2*10**5))[:-1] \npi_digits = pi_digits.replace(\".\", \"\")\ndef afind():\n    idx, record = 0, -1\n    while idx < len(pi_digits):\n        digit, idx, c = pi_digits[idx], idx+1, 2\n        while idx < len(pi_digits) and pi_digits[idx] != digit:\n            idx += 1; c += 1\n        if c > record:\n            record = c; print(c, end=\", \")\n        idx += 1\nafind() \n"}
{"sequence_id": "A105083", "text": "Trajectory of 1 under the morphism 1 -> 12, 2 -> 3, 3 -> 1.", "sequence": "1,2,3,1,1,2,1,2,3,1,2,3,1,1,2,3,1,1,2,1,2,3,1,1,2,1,2,3,1,2,3,1,1,2,1,2,3,1,2,3,1,1,2,3,1,1,2,1,2,3,1,2,3,1,1,2,3,1,1,2,1,2,3,1,1,2,1,2,3,1,2,3,1,1,2,3,1,1,2,1,2,3,1,1,2,1,2,3,1,2,3,1,1,2,1,2,3,1,2", "code": "\nN_TERMS=10000\ndef a():\n  \n  n = 0\n  \n  \n  places = []\n  \n  yield 0, 1\n  while True:\n    n += 1\n    \n    places.append(0)\n    \n    \n    \n    while len(places) > 1 and places[-2] <= places[-1]+2:\n      places.pop()\n      places[-1] += 1\n    \n    an = 1 if places[-1] > 1 else places[-1]+2\n    yield n, an\n\n\n\nfor n, an in a():\n  print(n, an)\n  if (n >= N_TERMS):\n    break\n\n"}
{"sequence_id": "A105093", "text": "Numbers n such that n = prime(k) + prime(k+3) = prime(k+1) + prime(k+2) for some k.", "sequence": "18,24,30,36,60,84,120,162,204,210,216,240,288,330,372,390,456,520,540,624,726,762,798,840,852,882,924,978,990,1104,1140,1164,1200,1392,1410,1428,1530,1632,1650,1716,1740,1764,1794,1848,1974,2052,2100,2112,2184", "code": "\nfrom sympy import nextprime\nA105093_list, plist = [], [2,3,5,7]\nwhile len(A105093_list) < 10000:\n    m = plist[0]+plist[3]\n    if m == plist[1]+plist[2]:\n        A105093_list.append(m)\n    plist = plist[1:] + [nextprime(plist[-1])] \n"}
{"sequence_id": "A105098", "text": "Minimum number of squares (repeated adjacent nonempty subwords) in a binary string of length n.", "sequence": "0,0,0,1,1,2,2,2,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,11,12,12,13,13,14,15,15,16,16,17,17,18,18,19,20,20", "code": "\nfrom itertools import product\ndef count_overlaps(subs, s):\n  c = i = 0\n  while i != -1:\n    i = s.find(subs, i)\n    if i != -1: c += 1; i += 1\n  return c\ndef a(n):\n  if n == 1: return 0\n  squares = [\"\".join(u) + \"\".join(u)\n    for r in range(1, n//2 + 1) for u in product(\"01\", repeat = r)]\n  words = (\"0\"+\"\".join(w) for w in product(\"10\", repeat=n-1))\n  themin = n*n\n  for w in words:\n    numw = 0\n    for s in squares:\n      numw += count_overlaps(s, w)\n      if numw >= themin: break\n    else: themin = min(themin, numw)\n  return themin\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A105161", "text": "Difference between n and the second-smallest prime larger than n.", "sequence": "3,2,3,4,3,6,5,6,5,4,3,6,5,6,5,4,3,6,5,10,9,8,7,8,7,6,5,4,3,8,7,10,9,8,7,6,5,6,5,4,3,6,5,10,9,8,7,12,11,10,9,8,7,8,7,6,5,4,3,8,7,10,9,8,7,6,5,6,5,4,3,8,7,10,9,8,7,6,5,10,9,8,7,14,13,12,11,10,9,12,11,10,9,8,7,6,5", "code": "\nfrom sympy import nextprime\ndef a(n): return nextprime(nextprime(n)) - n\nprint([a(n) for n in range(97)]) \n"}
{"sequence_id": "A105163", "text": "a(n) = (n^3 - 7*n + 12)/6.", "sequence": "1,1,3,8,17,31,51,78,113,157,211,276,353,443,547,666,801,953,1123,1312,1521,1751,2003,2278,2577,2901,3251,3628,4033,4467,4931,5426,5953,6513,7107,7736,8401,9103,9843,10622,11441,12301,13203,14148,15137,16171", "code": " for n in range(1,45): print((n**3 - 7*n + 12)/6, end=', ') \n"}
{"sequence_id": "A105223", "text": "Number of squares between prime(n) and 2*prime(n) inclusive.", "sequence": "1,1,1,1,1,2,1,2,2,2,2,2,3,3,3,3,3,4,3,3,4,4,3,4,4,4,4,4,4,5,4,5,5,5,5,5,5,6,6,5,5,6,6,6,5,5,6,7,6,6,6,6,6,7,6,6,7,7,7,7,7,7,7,7,8,8,7,7,8,8,8,8,8,8,8,8,8,9,8,8,8,9,9,9,9,8,8,9,9,9,9,9,9,9,9,9,9,10,10,9,10,10,10", "code": "\nfrom math import isqrt\nfrom sympy import prime, primerange\ndef aupton(terms):\n    return [isqrt(2*p) - isqrt(p-1) for p in primerange(1, prime(terms)+1)]\nprint(aupton(103)) \n"}
{"sequence_id": "A105224", "text": "Number of squares between n and 2*n inclusive.", "sequence": "1,1,1,1,1,1,1,2,2,1,1,1,2,2,2,2,1,2,2,2,2,2,2,2,3,2,2,2,2,2,2,3,3,3,3,3,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,4,4,4,4,4", "code": "\nfrom math import isqrt\ndef a(n): return isqrt(2*n) - isqrt(n-1)\nprint([a(n) for n in range(1, 106)]) \n"}
{"sequence_id": "A105252", "text": "a(n) = binomial(n+5,n)*binomial(n+9,n).", "sequence": "1,60,1155,12320,90090,504504,2312310,9060480,31286970,97337240,277411134,733649280,1818838840,4261894560,9502285320,20271542016,41572498275,82281899700,157706974425,293570877600,532097215650,941124327000,1627522854750,2756636064000", "code": "\nA105252_list, m = [], [2002, -4433, 3487, -1133, 127, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nfor _ in range(10**2):\n    A105252_list.append(m[-1])\n    for i in range(14):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A105253", "text": "a(n) = binomial(n+6,n)*binomial(n+10,n).", "sequence": "1,77,1848,24024,210210,1387386,7399392,33372768,131405274,462351890,1479526048,4365213216,12004336344,31040798712,76018282560,177375992640,396324483555,851617661895,1766318113560,3547314771000,6917263803450,13128684361650,24304341297600", "code": "\nA105253_list, m = [], [8008, -22022, 23023, -11297, 2563, -209] + [1]*11\nfor _ in range(10**2):\n    A105253_list.append(m[-1])\n    for i in range(16):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A105421", "text": "Numbers n such that prime(n + 1) == 7 (mod n).", "sequence": "1,2,3,4,8,30,31,33,68,72,180,1052,6471,40083,40087,40090,40113,40120,100348,100360,100362,637334,4124588,10553439,10553442,10553455,10553478,10553505,10553512,10553827,10553849,69709712,69709719,69709728,69709958,21338685404", "code": "\ndef A105421(max) :\n....terms = []\n....p = 3\n....for n in range(1,max+1) :\n........if (p - 7) % n == 0 : terms.append(n)\n........p = next_prime(p)\n....return terms\nend \n"}
{"sequence_id": "A105555", "text": "Let d = number of divisors of n; a(n) = d-th prime.", "sequence": "2,3,3,5,3,7,3,7,5,7,3,13,3,7,7,11,3,13,3,13,7,7,3,19,5,7,7,13,3,19,3,13,7,7,7,23,3,7,7,19,3,19,3,13,13,7,3,29,5,13,7,13,3,19,7,19,7,7,3,37,3,7,13,17,7,19,3,13,7,19,3,37,3,7,13,13,7,19,3,29,11,7,3,37,7,7,7,19,3", "code": "\nfrom sympy import prime, divisor_count\ndef a(n): return prime(divisor_count(n)) \n"}
{"sequence_id": "A105560", "text": "a(1) = 1, and for n >= 2, a(n) = prime(bigomega(n)), where prime(n) = A000040(n) and bigomega(n) = A001222(n).", "sequence": "1,2,2,3,2,3,2,5,3,3,2,5,2,3,3,7,2,5,2,5,3,3,2,7,3,3,5,5,2,5,2,11,3,3,3,7,2,3,3,7,2,5,2,5,5,3,2,11,3,5,3,5,2,7,3,7,3,3,2,7,2,3,5,13,3,5,2,5,3,5,2,11,2,3,5,5,3,5,2,11,7,3,2,7,3,3,3,7,2,7,3,5,3,3,3,13,2,5,5,7", "code": "\nfrom sympy import prime, primefactors\ndef a001222(n): return 0 if n==1 else a001222(n/primefactors(n)[0]) + 1\ndef a(n): return 1 if n==1 else prime(a001222(n)) \n"}
{"sequence_id": "A105561", "text": "a(n) is the m-th prime, where m is the number of distinct prime factors of n (A001221), a(1) = 1.", "sequence": "1,2,2,2,2,3,2,2,2,3,2,3,2,3,3,2,2,3,2,3,3,3,2,3,2,3,2,3,2,5,2,2,3,3,3,3,2,3,3,3,2,5,2,3,3,3,2,3,2,3,3,3,2,3,3,3,3,3,2,5,2,3,3,2,3,5,2,3,3,5,2,3,2,3,3,3,3,5,2,3,2,3,2,5,3,3,3,3,2,5,3,3,3,3,3,3,2,3,3,3,2,5,2,3,5,3,2,3,2,5,3,3,2,5,3,3,3,3,3,5", "code": "\nfrom sympy import prime, primefactors\ndef a(n): return 1 if n==1 else prime(len(primefactors(n))) \n"}
{"sequence_id": "A105870", "text": "Fibonacci sequence (mod 7).", "sequence": "0,1,1,2,3,5,1,6,0,6,6,5,4,2,6,1,0,1,1,2,3,5,1,6,0,6,6,5,4,2,6,1,0,1,1,2,3,5,1,6,0,6,6,5,4,2,6,1,0,1,1,2,3,5,1,6,0,6,6,5,4,2,6,1,0,1,1,2,3,5,1,6,0,6,6,5,4,2,6,1,0,1,1,2,3,5,1,6,0,6,6,5,4,2,6,1,0,1,1,2,3", "code": "\nA105870_list, a, b, = [], 0, 1\nfor _ in range(10**3):\n    A105870_list.append(a)\n    a, b = b, (a+b) % 7 \n"}
{"sequence_id": "A105943", "text": "a(n) = C(n+7,n) * C(n+10,7).", "sequence": "120,2640,28512,205920,1132560,5096520,19631040,66745536,204787440,576438720,1507608960,3700494720,8593371072,19004570640,40244973120,81980500800,161264274600,307350735120,569168028000,1026681084000,1807851474000,3113521983000", "code": "\nA105943_list, m = [], [3432, -3432, 1320, 0]+[120]*11\nfor _ in range(10**2):\n    A105943_list.append(m[-1])\n    for i in range(14):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A106195", "text": "Riordan array (1/(1-2*x), x*(1-x)/(1-2*x)).", "sequence": "1,2,1,4,3,1,8,8,4,1,16,20,13,5,1,32,48,38,19,6,1,64,112,104,63,26,7,1,128,256,272,192,96,34,8,1,256,576,688,552,321,138,43,9,1,512,1280,1696,1520,1002,501,190,53,10,1,1024,2816,4096,4048,2972,1683,743,253,64,11", "code": "\nfrom sympy import Poly, symbols\nx = symbols('x')\ndef u(n, x): return 1 if n==1 else u(n - 1, x) + v(n - 1, x)\ndef v(n, x): return 1 if n==1 else u(n - 1, x) + (x + 1)*v(n - 1, x)\ndef a(n): return Poly(v(n, x), x).all_coeffs()[::-1]\nfor n in range(1, 13): print(a(n)) \n"}
{"sequence_id": "A106195", "text": "Riordan array (1/(1-2*x), x*(1-x)/(1-2*x)).", "sequence": "1,2,1,4,3,1,8,8,4,1,16,20,13,5,1,32,48,38,19,6,1,64,112,104,63,26,7,1,128,256,272,192,96,34,8,1,256,576,688,552,321,138,43,9,1,512,1280,1696,1520,1002,501,190,53,10,1,1024,2816,4096,4048,2972,1683,743,253,64,11", "code": "\nfrom mpmath import hyp2f1, nprint\ndef T(n, k): return hyp2f1(k - n, k + 1, 1, -1)\nfor n in range(13): nprint([int(T(n, k)) for k in range(n + 1)]) \n"}
{"sequence_id": "A106345", "text": "Diagonal sums of number triangle A106344.", "sequence": "1,0,1,1,1,0,2,1,2,1,1,1,2,0,3,2,3,1,3,2,2,1,2,1,3,1,2,2,3,0,5,3,5,2,4,3,4,1,5,3,4,2,3,2,3,1,3,2,4,1,4,3,3,1,4,2,5,2,3,3,5,0,8,5,8,3,7,5,6,2,7,4,7,3,5,4,6,1,8,5,7,3,6,4,5,2,5,3,5,2,4,3,4,1,5,3,6,2,5,4,5,1,7", "code": "\na = [0]*(104*2)\na[1]=1\nfor n in range(1,104):\n    a[2*n  ]=a[n-1]\n    a[2*n+1]=a[n]+a[n+1]\n    print(str(a[n]), end=',')\n\n"}
{"sequence_id": "A106708", "text": "a(n) is the concatenation of its nontrivial divisors.", "sequence": "0,0,0,2,0,23,0,24,3,25,0,2346,0,27,35,248,0,2369,0,24510,37,211,0,2346812,5,213,39,24714,0,23561015,0,24816,311,217,57,234691218,0,219,313,24581020,0,23671421,0,241122,35915,223,0,23468121624,7,251025,317", "code": "\nfrom sympy import divisors\ndef a(n):\n  nontrivial_divisors = [d for d in divisors(n)[1:-1]]\n  if len(nontrivial_divisors) == 0: return 0\n  else: return int(\"\".join(str(d) for d in nontrivial_divisors))\nprint([a(n) for n in range(1, 52)]) \n"}
{"sequence_id": "A106737", "text": "a(n) = Sum_{k=0..n} ({binomial(n+k,n-k)*binomial(n,k)} mod 2).", "sequence": "1,2,2,3,2,4,3,4,2,4,4,6,3,6,4,5,2,4,4,6,4,8,6,8,3,6,6,9,4,8,5,6,2,4,4,6,4,8,6,8,4,8,8,12,6,12,8,10,3,6,6,9,6,12,9,12,4,8,8,12,5,10,6,7,2,4,4,6,4,8,6,8,4,8,8,12,6,12,8,10,4,8,8,12,8,16,12,16,6,12,12,18,8,16,10,12", "code": "\ndef A106737(n):\n    return sum(int(not (~(n+k) & (n-k)) | (~n & k)) for k in range(n+1)) \n(Scheme, two mathematically equal implementations, based on RLT-interpretation)\n;; The first one implements the given recurrence and uses memoization-macro definec:\n(definec (A106737 n) (cond ((zero? n) 1) ((even? n) (A106737 (/ n 2))) ((= 1 (modulo n 4)) (* 2 (A106737 (/ (- n 1) 2)))) (else (- (* 2 (A106737 (/ (- n 1) 2))) (A106737 (/ (- n 3) 4))))))\n;; This one applies the Run Length Transform explicitly to r -> r+1 function:\n(define (A106737 n) (fold-left (lambda (a r) (* a (+ 1 r))) 1 (bisect (reverse (binexp->runcount1list n)) (- 1 (modulo n 2))))) ;; See A227349 for the required other functions.\n;; _Antti Karttunen_, Oct 15 2016\n"}
{"sequence_id": "A107069", "text": "Number of self-avoiding walks of length n on an infinite triangular prism starting at the origin.", "sequence": "1,4,12,34,90,222,542,1302,3058,7186,16714,38670,89358,205710,472906", "code": "\nw = [[[(0, 0)]]]\nfor n in range(1, 15):\n    nw = []\n    for walk in w[-1]:\n        (x, t) = walk[-1]\n        nss = [(x-1, t), (x+1, t), (x, (t+1)%3), (x, (t-1)%3)]\n        for ns in nss:\n            if ns not in walk:\n                nw.append(walk[:] + [ns])\n    w.append(nw)\nprint([len(x) for x in w])\n\n"}
{"sequence_id": "A107108", "text": "Shorthand of n-th smallest n-digit prime, see comments.", "sequence": "2,3,7,21,61,69,117,189,193,181,259,193,303,411,487,513,931,591,861,667,801,1081,711,1027,1321,1753,1581,2109,1527,1951,2613,2053,2533,3171,2653,3073,2769,2899,3201,3133,4089,2859,4447,5367,3819,4923,5251,5109,5127,6721", "code": "\nfrom sympy import nextprime\ndef a(n):  return nextprime(10**(n-1), ith=n) - 10**(n-1) * (n > 1)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A107337", "text": "Substitution 1->{1, 2, 1, 3, 2, 3, 1}, 2->{3}, 3->{1}, starting with 1.", "sequence": "1,2,1,3,2,3,1,3,1,2,1,3,2,3,1,1,3,1,1,2,1,3,2,3,1,1,1,2,1,3,2,3,1,3,1,2,1,3,2,3,1,1,3,1,1,2,1,3,2,3,1,1,2,1,3,2,3,1,1,1,2,1,3,2,3,1,1,2,1,3,2,3,1,3,1,2,1,3,2,3,1,1,3,1,1,2,1,3,2,3,1,1,2,1,3,2,3,1,1,2,1,3,2,3,1", "code": "\nfrom itertools import chain\nA107337 = [1]\nfor _ in range(4):\n....A107337 = list(chain.from_iterable(([1,2,1,3,2,3,1] if d == 1 else [3] if d == 2 else [1] for d in A107337)))\n\n"}
{"sequence_id": "A107587", "text": "Number of Motzkin n-paths with an even number of up steps.", "sequence": "1,1,1,1,3,11,31,71,155,379,1051,2971,8053,21165,56057,152881,425491,1186227,3287971,9102787,25346457,71111377,200425149,565676629,1597672277,4520632981,12827046181,36493762501,104027787451,296947847203,848765305351,2429671858671", "code": "\nA107587 = [1, 1, 1, 1, 3]\nfor n in range(5, 801):\n    A107587.append(((5*n**2+n-3)*A107587[-1]-(10*n**2-16*n+3)*A107587[-2]\n      +(10*n**2-34*n+27)*A107587[-3]+(11*n-5)*(n-3)*A107587[-4]\n      -15*(n-3)*(n-4)*A107587[-5])//(n*n+2*n)) \n"}
{"sequence_id": "A107689", "text": "Primes with digital product = 3.", "sequence": "3,13,31,113,131,311,11113,11131,11311,113111,131111,311111,11111131,11111311,11113111,11131111,111111113,111111131,111113111,131111111,11111111113,11111111131,11113111111,11131111111,31111111111", "code": "\nfrom sympy import isprime\ndef agen():\n  digits = 0\n  while True:\n    for i in range(digits+1):\n      t = int(\"1\"*(digits-i) + \"3\" + \"1\"*i)\n      if isprime(t): yield t\n    digits += 1\ng = agen()\nprint([next(g) for i in range(25)]) \n"}
{"sequence_id": "A107692", "text": "Primes whose product of digits is 6.", "sequence": "23,61,1123,1213,1231,1321,2113,2131,2311,3121,11161,11213,11321,12113,13121,16111,31121,111611,611111,1111213,1112113,1112131,1131121,1211311,2111311,3112111,11111161,11112113,11211131,11231111,11312111", "code": "\nfrom sympy import prod, isprime\nfrom sympy.utilities.iterables import multiset_permutations\ndef agen(maxdigits):\n    for digs in range(1, maxdigits+1):\n        for mp in multiset_permutations(\"1\"*(digs-1) + \"236\", digs):\n            if prod(map(int, mp)) == 6:\n                t = int(\"\".join(mp))\n                if isprime(t): yield t\nprint(list(agen(8))) \n"}
{"sequence_id": "A107693", "text": "Primes with digital product = 7.", "sequence": "7,17,71,1117,1171,11117,11171,1111711,1117111,1171111,11111117,11111171,71111111,1117111111,1711111111,17111111111,1111171111111,11111111111111171,11111111171111111,1111111111111111171,1111171111111111111,1111711111111111111", "code": "\nfrom sympy import isprime\ndef auptod(maxdigits):\n    alst = []\n    for d in range(1, maxdigits+1):\n        if d%3 == 0: continue\n        for i in range(d):\n            t = int('1'*(d-1-i) + '7' + '1'*i)\n            if isprime(t): alst.append(t)\n    return alst\nprint(auptod(20))  \n"}
{"sequence_id": "A107715", "text": "Primes whose decimal representation contains only digits from the set {0,1,2,3}.", "sequence": "2,3,11,13,23,31,101,103,113,131,211,223,233,311,313,331,1013,1021,1031,1033,1103,1123,1201,1213,1223,1231,1301,1303,1321,2003,2011,2111,2113,2131,2203,2213,2221,2311,2333,3001,3011,3023,3121,3203,3221,3301,3313", "code": " from gmpy2 import digits\nfrom sympy import isprime\n[int(digits(n,4)) for n in range(1000) if isprime(int(digits(n,4)))] \n"}
{"sequence_id": "A107908", "text": "a(n) = (n+1)(n+2)^2*(n+3)^2*(n+4)(3n+5)/720.", "sequence": "1,16,110,490,1666,4704,11592,25740,52635,100672,182182,314678,522340,837760,1303968,1976760,2927349,4245360,6042190,8454754,11649638,15827680,21229000,28138500,36891855,47882016,61566246,78473710", "code": "\nfrom itertools import islice\ndef A107908_generator():\n....m = [21, -13, 3]+[1]*5\n....yield m[-1]\n....while True:\n........for i in range(7):\n............m[i+1]+= m[i]\n........yield m[-1]\nlist(islice(A107908_generator(),0,50,1)) \n"}
{"sequence_id": "A108046", "text": "Inverse Moebius transform of Fibonacci numbers 0, 1, 1, 2, 3, 5, 8, ...", "sequence": "0,1,1,3,3,7,8,16,22,38,55,98,144,242,381,626,987,1625,2584,4221,6774,11002,17711,28768,46371,75170,121415,196662,317811,514650,832040,1346895,2178365,3525566,5702898,9229181,14930352,24160402,39088314", "code": "\nfrom sympy import fibonacci, divisors\ndef a(n): return 1 if n<1 else sum([fibonacci(d - 1) for d in divisors(n)]) \n"}
{"sequence_id": "A108116", "text": "Base 10 weak Skolem-Langford numbers.", "sequence": "2002,131003,231213,300131,312132,420024,12132003,14130043,15120025,23121300,23421314,25121005,25320035,30023121,31213200,31413004,34003141,40031413,41312432,45001415,45121425,45300435,50012152,51410054,52002151,52412154,53002352,53400354,61310036", "code": "\ndef SL(d, s):\n  for i1 in range(int(d[0]==\"0\"), len(s)-int(d[0])-1):\n    i2 = i1 + int(d[0]) + 1\n    if not (s[i1] or s[i2]):\n      s[i1] = s[i2] = d[0]\n      r = d[1:]\n      if r: yield from SL(r, s)\n      else: yield int(\"\".join(s))\n      s[i1] = s[i2] = 0\nfrom itertools import chain, combinations as C\ndef A108116gen():\n  for numd in range(1, 11):\n    dset, s = \"0123456789\", [0 for _ in range(2*numd)]\n    for an in sorted(\n      chain.from_iterable(SL(\"\".join(c), s) for c in C(dset, numd))):\n      yield an\nfor n, an in enumerate(A108116gen(), start=1):\n  print(n, an) \n"}
{"sequence_id": "A108314", "text": "Sum of primes p with n^2 < p < (n+1)^2.", "sequence": "5,12,24,59,60,168,173,290,269,533,534,787,917,830,1420,1901,1541,2076,2288,2953,3219,3533,3348,5413,5208,4907,6026,7343,6960,7444,9948,9483,11166,10749,12624,11903,12713,17724,17155,19590,18975,16249,22702,21859,26943", "code": "\nfrom sympy import sieve\ndef a(n): return sum(p for p in sieve.primerange(n**2, (n+1)**2))\nprint([a(n) for n in range(1, 46)]) \n"}
{"sequence_id": "A108559", "text": "Numbers k such that k + prime(k) is divisible by 11.", "sequence": "4,30,36,41,45,56,60,73,84,89,95,127,128,134,156,183,193,194,201,239,244,251,284,302,323,331,348,360,368,372,387,391,409,413,431,432,442,454,463,496,514,516,546,565,568,620,629,636,646,667,684,696,703,705", "code": "\nfrom sympy import prime\ndef ok(n): return (n + prime(n))%11 == 0\nprint(list(filter(ok, range(1, 706)))) \n"}
{"sequence_id": "A108559", "text": "Numbers k such that k + prime(k) is divisible by 11.", "sequence": "4,30,36,41,45,56,60,73,84,89,95,127,128,134,156,183,193,194,201,239,244,251,284,302,323,331,348,360,368,372,387,391,409,413,431,432,442,454,463,496,514,516,546,565,568,620,629,636,646,667,684,696,703,705", "code": " \nfrom sympy import nextprime\ndef aupton(terms):\n  p, p_idx, alst = 1, 0, []\n  while len(alst) < terms:\n    p, p_idx = nextprime(p), p_idx+1\n    if (p_idx + p)%11 == 0: alst.append(p_idx)\n  return alst\nprint(aupton(54)) \n"}
{"sequence_id": "A108560", "text": "a(n) = (A108559(n)+prime(A108559(n)))/11.", "sequence": "1,13,17,20,22,29,31,40,47,50,54,76,77,81,97,116,124,125,130,158,163,168,195,209,224,232,245,253,261,265,278,280,292,296,312,313,321,333,342,367,381,383,407,424,427,473,480,487,495,514,527,539,546,548,549", "code": "\nfrom sympy import nextprime\ndef aupton(terms):\n  p, p_idx, alst = 1, 0, []\n  while len(alst) < terms:\n    p, p_idx = nextprime(p), p_idx+1\n    if (p_idx + p)%11 == 0: alst.append((p_idx + p)//11)\n  return alst\nprint(aupton(55)) \n"}
{"sequence_id": "A108571", "text": "Any digit d in the sequence says: \"I am part of an integer in which you'll find d digits d\".", "sequence": "1,22,122,212,221,333,1333,3133,3313,3331,4444,14444,22333,23233,23323,23332,32233,32323,32332,33223,33232,33322,41444,44144,44414,44441,55555,122333,123233,123323,123332,132233,132323,132332,133223,133232,133322,155555", "code": "\ndef ok(n): s = str(n); return all(s.count(d) == int(d) for d in set(s))\ndef aupto(limit): return [m for m in range(1, limit+1) if ok(m)]\nprint(aupto(155555)) \n"}
{"sequence_id": "A108580", "text": "Numbers whose sum of bits when written in binary > sum of decimal digits.", "sequence": "10,11,30,31,100,101,102,103,110,111,120,121,200,201,210,211,220,221,300,301,310,311,500,501,510,511,1000,1001,1002,1003,1004,1005,1006,1007,1010,1011,1012,1013,1014,1015,1020,1021,1022,1023,1100,1101,1102,1103", "code": "\ndef ok(n): return sum(map(int, str(n))) < bin(n).count('1')\nprint(list(filter(ok, range(1104)))) \n"}
{"sequence_id": "A108646", "text": "a(n) = (n+1)(n+2)^2*(n+3)(11n^3 + 58n^2 + 101n + 60)/720.", "sequence": "1,23,194,985,3668,11074,28728,66438,140415,276001,511082,900263,1519882,2473940,3901024,5982300,8950653,13101051,18802210,26509637,36780128,50287798,67841720,90405250,119117115,155314341,200557098", "code": "\nA108646_list, m = [], [77, -85, 28, -1, 1, 1, 1, 1]\nfor _ in range(10001):\n    A108646_list.append(m[-1])\n    for i in range(7):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A108767", "text": "Triangle read by rows: T(n,k) is number of paths from (0,0) to (3n,0) that stay in the first quadrant (but may touch the horizontal axis), consisting of steps u=(1,1), d=(1,-2) and have k peaks (i.e., ud's).", "sequence": "1,1,2,1,6,5,1,12,28,14,1,20,90,120,42,1,30,220,550,495,132,1,42,455,1820,3003,2002,429,1,56,840,4900,12740,15288,8008,1430,1,72,1428,11424,42840,79968,74256,31824,4862,1,90,2280,23940,122094,325584,465120", "code": "\nfrom sympy import binomial\ndef T(n, k): return binomial(n, k)*binomial(2*n, k - 1)//n\nfor n in range(1, 21): print([T(n, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A108860", "text": "Numbers k that divide the sum of the digits of (2k)^k.", "sequence": "1,3,9,12,16,18,22,27,29,33,48,54,80,127,133,149,171,335,888,1038,1137,1435,1465,1647,13921,14256,22467,22872,23514,23709,39564,108708,108777,109308,230115", "code": "\nA108860_list = [n for n in range(1,1000) if not sum(int(d) for d in str((2*n)**n)) % n] \n"}
{"sequence_id": "A108861", "text": "Numbers k that divide the sum of the digits of 2^k * k!.", "sequence": "1,2,3,5,6,9,27,81,126,159,205,252,254,267,285,675,1053,1086,1125,1146,2007,5088,5382,5448,14652,23401,23574,24009,41004,66789,67482,111480,866538,1447875,2413152,2414019,2417828,2421360", "code": "\nfrom itertools import islice\ndef A108861(): \n    k, k2, kf = 1, 2, 1\n    while True:\n        c = sum(int(d) for d in str(k2*kf))\n        if not c % k: yield k\n        k += 1\n        k2 *= 2\n        kf *= k\nA108861_list = list(islice(A108861(),10)) \n"}
{"sequence_id": "A108951", "text": "Primorial inflation of n: Fully multiplicative with a(p) = p# for prime p, where x# is the primorial A034386(x).", "sequence": "1,2,6,4,30,12,210,8,36,60,2310,24,30030,420,180,16,510510,72,9699690,120,1260,4620,223092870,48,900,60060,216,840,6469693230,360,200560490130,32,13860,1021020,6300,144,7420738134810,19399380,180180,240,304250263527210,2520", "code": "\nfrom sympy import primerange, factorint\nfrom operator import mul\ndef P(n): return reduce(mul, [i for i in primerange(2, n + 1)])\ndef a(n):\n    f = factorint(n)\n    return 1 if n==1 else reduce(mul, [P(i)**f[i] for i in f])\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A109012", "text": "a(n) = gcd(n,9).", "sequence": "9,1,1,3,1,1,3,1,1,9,1,1,3,1,1,3,1,1,9,1,1,3,1,1,3,1,1,9,1,1,3,1,1,3,1,1,9,1,1,3,1,1,3,1,1,9,1,1,3,1,1,3,1,1,9,1,1,3,1,1,3,1,1,9,1,1,3,1,1,3,1,1,9,1,1,3,1,1,3,1,1,9,1,1,3,1,1,3,1,1,9,1,1,3,1,1,3,1,1,9,1", "code": "\nfrom math import gcd\ndef a(n): return gcd(n, 9)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A109014", "text": "a(n) = gcd(n,11).", "sequence": "11,1,1,1,1,1,1,1,1,1,1,11,1,1,1,1,1,1,1,1,1,1,11,1,1,1,1,1,1,1,1,1,1,11,1,1,1,1,1,1,1,1,1,1,11,1,1,1,1,1,1,1,1,1,1,11,1,1,1,1,1,1,1,1,1,1,11,1,1,1,1,1,1,1,1,1,1,11,1,1,1,1,1,1,1,1,1,1,11,1,1,1,1,1,1,1,1,1,1", "code": "\nfrom math import gcd\ndef a(n): return gcd(n, 11)\nprint([a(n) for n in range(99)]) \n"}
{"sequence_id": "A109137", "text": "Numbers k such that k * (10^k - 1) + 1 is prime.", "sequence": "2,14,42,144,200,302,7242,8718,10568", "code": "\nfrom sympy import isprime\ndef afind(limit, startk=1):\n    k, pow10 = startk, 10**startk\n    for k in range(startk, limit+1):\n        if isprime(k*(pow10 - 1) + 1): print(k, end=\", \")\n        k += 1\n        pow10 *= 10\nafind(500) \n"}
{"sequence_id": "A109306", "text": "Numbers k such that k^2 + (k-1)^2 and k^2 + (k+1)^2 are both primes.", "sequence": "2,5,25,30,35,70,85,100,110,225,230,260,285,290,320,390,410,475,490,495,515,590,680,695,710,750,760,845,950,1080,1100,1135,1175,1190,1195,1270,1295,1305,1330,1365,1410,1475,1715,1750,1785,1845,1855,1925,2015,2060", "code": "\nfrom sympy import isprime\ndef aupto(limit):\n  alst, is2 = [], False\n  for k in range(1, limit+1):\n    is1, is2 = is2, isprime(k**2 + (k+1)**2)\n    if is1 and is2: alst.append(k)\n  return alst\nprint(aupto(2060)) \n"}
{"sequence_id": "A109308", "text": "Lesser emirps (primes whose digit reversal is a larger prime).", "sequence": "13,17,37,79,107,113,149,157,167,179,199,337,347,359,389,709,739,769,1009,1021,1031,1033,1061,1069,1091,1097,1103,1109,1151,1153,1181,1193,1213,1217,1223,1229,1231,1237,1249,1259,1279,1283,1381,1399,1409,1429", "code": "\nfrom sympy import isprime, primerange\ndef ok(p): revp = int(str(p)[::-1]); return p < revp and isprime(revp)\nprint(list(filter(ok, primerange(1, 1430)))) \n"}
{"sequence_id": "A109326", "text": "Smallest positive number that requires n steps to be represented as a sum of palindromes using the greedy algorithm.", "sequence": "1,10,21,1022,101023,1000101024", "code": " \ndef afind(limit):\n    record = 0\n    for i in range(1, limit+1):\n        steps = A088601(i)\n        if steps > record: print(i, end=\", \"); record = steps\nafind(10**6) \n"}
{"sequence_id": "A109350", "text": "Numbers whose anti-divisors sum to a prime.", "sequence": "3,4,5,12,13,24,41,60,84,113,144,180,264,265,312,480,761,1012,1104,1105,1201,1405,1624,1740,1741,1861,2112,2113,3281,4140,4141,5304,5512,5724,5940,6385,6612,7320,7564,7565,8580,8845,9385,9660,9661,9941", "code": "\nfrom sympy import isprime, divisors\nA109350 = [n for n in range(1,10**6) if isprime(sum([2*d for d in divisors(n) if n > 2*d and n%(2*d)] + [d for d in divisors(2*n-1) if n > d >=2 and n%d] + [d for d in divisors(2*n+1) if n > d >=2 and n%d]))]\n\n"}
{"sequence_id": "A109351", "text": "Numbers whose anti-divisors sum to a perfect cube.", "sequence": "2,8,9,89,96,204,224,296,541,576,1537,1701,4496,6124,6611,7685,7789,8381,8741,9025,12048,12105,12513,13711,15924,16160,17180,21486,21998,24657,26264,26354,29864,32477,43791,52518,53662,54018,56189,81281", "code": "\nfrom sympy import integer_nthroot\nfrom sympy.ntheory.factor_ import antidivisors\nA109351_list = [n for n in range(2,10**4) if integer_nthroot(sum(antidivisors(n)),3)[1]] \n"}
{"sequence_id": "A109608", "text": "Numbers n such that the number of digits required to write the prime factors of n equals the number of digits of n.", "sequence": "2,3,5,7,10,11,13,14,15,17,19,21,23,25,29,31,35,37,41,43,47,49,53,59,61,67,71,73,79,83,89,97,101,103,105,106,107,109,111,113,115,118,119,122,123,125,127,129,131,133,134,137,139,141,142,145,146,147,149,151,155", "code": "\nfrom sympy import factorint\ndef ok(n):\n    s, f = str(n), factorint(n)\n    return n and len(s) == sum(len(str(p))*f[p] for p in f)\nprint(list(filter(ok, range(156)))) \n"}
{"sequence_id": "A109611", "text": "Chen primes: primes p such that p + 2 is either a prime or a semiprime.", "sequence": "2,3,5,7,11,13,17,19,23,29,31,37,41,47,53,59,67,71,83,89,101,107,109,113,127,131,137,139,149,157,167,179,181,191,197,199,211,227,233,239,251,257,263,269,281,293,307,311,317,337,347,353,359,379,389,401,409", "code": "\nfrom sympy import isprime, primeomega\ndef ok(n): return isprime(n) and (primeomega(n+2) < 3)\nprint(list(filter(ok, range(1, 410)))) \n"}
{"sequence_id": "A109675", "text": "Numbers n such that the sum of the digits of (n^n - 1) is divisible by n.", "sequence": "1,4,5,10,25,50,100,446,1000,9775,10000,100000", "code": "\nA109675_list = [n for n in range(1,10**4) if not sum([int(d) for d in str(n**n-1)]) % n]\n\n"}
{"sequence_id": "A109689", "text": "Smallest cube that contains exactly n occurrences of the string n.", "sequence": "1,1,21952,5735339,4410944,3553559576,66676466375,7707245470777,148388768680888,999970000299999,310810243810243102106210518101010107767,1115341111117511141118670443456", "code": " \nprint([a(n, POW=3) for n in range(10)]) \n"}
{"sequence_id": "A109690", "text": "Smallest 4th power that contains exactly n occurrences of the string n.", "sequence": "1,1,234256,33362176,4640470641,5035553952016,4396167663616,4777933277779216,3588188855118837841,999395939249909776", "code": " \nprint([a(n, POW=4) for n in range(10)]) \n"}
{"sequence_id": "A109691", "text": "Smallest 5th power that contains exactly n occurrences of the string n.", "sequence": "1,1,248832,6436343,45435424,15575653771875,616132666368,778890712975487707,6648881538818884375,99900039992000799968,10610441011074322410255643277715061010710106439101,11311111984777108548801111731222111251108343", "code": "\ndef count_overlaps(subs, s):\n  c = i = 0\n  while i != -1:\n    i = s.find(subs, i)\n    if i != -1: c += 1; i += 1\n  return c\ndef a(n, POW=5): \n  strn = str(n)\n  k = int((10**(len(set(strn))*n-1))**(1/POW)) \n  while True:\n    \n    if count_overlaps(strn, str(pow(k, POW))) == n: break\n    k += 1\n  return k**POW\nprint([a(n) for n in range(10)]) \n"}
{"sequence_id": "A109725", "text": "Divide primes in groups with 2n+1 elements and add together.", "sequence": "2,15,83,281,679,1367,2461,4005,6223,9017,12755,17281,22967,29597,37793,47229,57993,70957,85343,101777,119469,141079,163313,188201,216203,247203,280897,316551,355905,398825,445509,494953,549737,605711,665185,730353,801481", "code": "\nfrom sympy import prime\ndef a(n): return sum(prime(i) for i in range(n*n+1, (n+1)**2+1))\nprint([a(n) for n in range(37)]) \n"}
{"sequence_id": "A109805", "text": "a(n) = prime(n+2)*prime(n+1) - prime(n)*prime(n+1).", "sequence": "9,20,42,66,78,102,114,230,232,248,370,246,258,470,636,472,488,670,426,584,790,830,1246,1164,606,618,642,654,2034,2286,1310,1096,1668,1788,1208,1884,1630,1670,2076,1432,2172,2292,1158,1182,2786,5064,3568,1362", "code": "\nfrom sympy import prime, primerange\ndef aupton(nn):\n    alst, prevp, prev_prod = [], 2, 6\n    for p in primerange(3, prime(nn+2)+1):\n        cur_prod = prevp * p\n        alst.append(cur_prod - prev_prod)\n        prevp = p\n        prev_prod = cur_prod\n    return alst[1:]\nprint(aupton(48)) \n"}
{"sequence_id": "A109812", "text": "a(1)=1; thereafter a(n) = smallest positive integer not among the earlier terms of the sequence such that a(n) and a(n-1) have no common 1-bits in their binary representations.", "sequence": "1,2,4,3,8,5,10,16,6,9,18,12,17,14,32,7,24,33,20,11,36,19,40,21,34,13,48,15,64,22,41,66,25,38,65,26,37,72,23,96,27,68,35,28,67,44,80,39,88,128,29,98,129,30,97,130,45,82,132,42,69,50,73,52,74,49,70,56,71,136,51", "code": "\nA109812_list, l1, s, b = [1], 1, 2, set()\nfor _ in range(10**6):\n    i = s\n    while True:\n        if not (i in b or i & l1):\n            A109812_list.append(i)\n            l1 = i\n            b.add(i)\n            while s in b:\n                b.remove(s)\n                s += 1\n            break\n        i += 1 \n"}
{"sequence_id": "A109827", "text": "Numbers written in an alternating binary-then-ternary base.", "sequence": "0,1,10,11,20,21,100,101,110,111,120,121,1000,1001,1010,1011,1020,1021,1100,1101,1110,1111,1120,1121,2000,2001,2010,2011,2020,2021,2100,2101,2110,2111,2120,2121,10000,10001,10010,10011,10020,10021,10100,10101", "code": " a109827 = lambda n: 100 * a109827(n // 6) + 10 * ((n % 6) // 2) + n % 2 if n else 0 \n"}
{"sequence_id": "A109862", "text": "Palindromic primes p such that p's 10's complement is also a prime.", "sequence": "3,5,7,11,191,353,383,929,10601,11411,12821,13931,14741,15551,16061,16361,16661,17471,30803,32423,33533,36263,72227,74747,75557,76367,76667,93239,94349,94649,94949,97379,1028201,1074701,1082801,1300031,1328231,1456541,1508051", "code": "\nfrom sympy import isprime\nfrom itertools import product\ndef tc(n): return 10**len(str(n)) - n\ndef cond(p): return isprime(p) and isprime(tc(p))\ndef palcands(digs):\n    if digs == 1:   yield from [2, 3, 5, 7]; return\n    if digs%2 == 0: yield from [[], [11]][digs==2]; return\n    for first in \"1379\":\n        for p in product(\"0123456789\", repeat=(digs-2)//2):\n            left = first + \"\".join(p)\n            for mid in \"0123456789\": yield int(left + mid + left[::-1])\ndef auptod(digs):\n    return [p for d in range(1, digs+1) for p in palcands(d) if cond(p)]\nprint(auptod(7)) \n"}
{"sequence_id": "A109863", "text": "Primes arising as the 10's complement of A109862(n).", "sequence": "7,5,3,89,809,647,617,71,89399,88589,87179,86069,85259,84449,83939,83639,83339,82529,69197,67577,66467,63737,27773,25253,24443,23633,23333,6761,5651,5351,5051,2621,8971799,8925299,8917199,8699969,8671769,8543459,8491949", "code": "\nfrom sympy import isprime\nfrom itertools import product\ndef tc(n): return 10**len(str(n)) - n\ndef cond(p): return isprime(p) and isprime(tc(p))\ndef palcands(digs):\n    if digs == 1:   yield from [2, 3, 5, 7]; return\n    if digs%2 == 0: yield from [[], [11]][digs==2]; return\n    for first in \"1379\":\n        for p in product(\"0123456789\", repeat=(digs-2)//2):\n            left = first + \"\".join(p)\n            for mid in \"0123456789\": yield int(left + mid + left[::-1])\ndef auptod(digs):\n    return [tc(p) for d in range(1, digs+1) for p in palcands(d) if cond(p)]\nprint(auptod(7)) \n"}
{"sequence_id": "A109890", "text": "a(1)=1; for n>1, a(n) is the smallest number not already present which is a divisor or a multiple of a(1)+...+a(n-1).", "sequence": "1,2,3,6,4,8,12,9,5,10,15,25,20,24,16,32,48,30,18,36,27,13,7,53,106,265,159,318,212,14,107,321,214,428,642,535,35,21,181,11,33,22,23,59,70,28,151,29,19,233,466,2563,699,932,40,26,38,31,61,39,49,98,42", "code": "\nfrom sympy import divisors\nA109890_list, s, y, b = [1, 2], 3, 3, set()\nfor _ in range(1,10**3):\n    for i in divisors(s):\n        if i >= y and i not in b:\n            A109890_list.append(i)\n            s += i\n            b.add(i)\n            while y in b:\n                b.remove(y)\n                y += 1\n            break \n"}
{"sequence_id": "A109910", "text": "a(n) = 9's complement of digit reversal of n.", "sequence": "9,8,7,6,5,4,3,2,1,0,8,88,78,68,58,48,38,28,18,8,7,87,77,67,57,47,37,27,17,7,6,86,76,66,56,46,36,26,16,6,5,85,75,65,55,45,35,25,15,5,4,84,74,64,54,44,34,24,14,4,3,83,73,63,53,43,33,23,13,3,2", "code": "\ndef A109910(n):\n....x=int(str(n)[::-1])\n....return 10**len(str(x))-1-x \n"}
{"sequence_id": "A109938", "text": "Largest k-digit prime == 1 (mod prime(n)) where k is the number of digits in prime(n), or 0 if no such prime exists.", "sequence": "7,7,0,0,89,79,0,0,47,59,0,0,83,0,0,0,0,0,0,0,0,0,0,0,0,809,619,857,0,227,509,787,823,557,0,907,0,653,0,347,359,0,383,773,0,797,0,0,0,0,467,479,0,503,0,0,0,0,0,563,0,587,0,0,0,0,0,0,0,0,0,719,0,0,0,0,0,0,0,0", "code": "\nfrom sympy import prime, prevprime\ndef a(n):\n    pn = prime(n); k = len(str(pn))\n    p = prevprime(10**k); lb = max(10**(k-1), 2)\n    while p > lb and p%pn != 1: p = prevprime(p)\n    return p if p > lb else 0\nprint([a(n) for n in range(1, 81)]) \n"}
{"sequence_id": "A109938", "text": "Largest k-digit prime == 1 (mod prime(n)) where k is the number of digits in prime(n), or 0 if no such prime exists.", "sequence": "7,7,0,0,89,79,0,0,47,59,0,0,83,0,0,0,0,0,0,0,0,0,0,0,0,809,619,857,0,227,509,787,823,557,0,907,0,653,0,347,359,0,383,773,0,797,0,0,0,0,467,479,0,503,0,0,0,0,0,563,0,587,0,0,0,0,0,0,0,0,0,719,0,0,0,0,0,0,0,0", "code": " \nfrom sympy import prime, primerange\ndef aupto(limit):\n    alst, primeswithkdigs, plimit = [], dict(), prime(limit)\n    for k in range(1, len(str(plimit))+1):\n        primeswithkdigs[k] = list(primerange(10**(k-1), 10**k))[::-1]\n    for pn in primerange(1, plimit+1):\n        k, found = len(str(pn)), False\n        for pk in primeswithkdigs[k]:\n            if pk%pn == 1: alst.append(pk); found = True; break\n        if not found: alst.append(0)\n    return alst\nprint(aupto(80)) \n"}
{"sequence_id": "A109939", "text": "Largest k-digit prime == 1 (mod n) where k is the number of digits in n, or 0 if no such prime exists.", "sequence": "0,7,7,5,0,7,0,0,0,71,89,97,79,71,61,97,0,73,0,61,43,89,47,97,0,79,0,29,59,61,0,97,67,0,71,73,0,0,79,41,83,43,0,89,0,47,0,97,0,0,0,53,0,0,0,0,0,59,0,61,0,0,0,0,0,67,0,0,0,71,0,73,0,0,0,0", "code": "\nfrom sympy import prime, prevprime\ndef a(n):\n    k = len(str(n)); p = prevprime(10**k); lb = max(10**(k-1), 2)\n    while p > lb and p%n != 1: p = prevprime(p)\n    return p if p > lb else 0\nprint([a(n) for n in range(1, 40)]) \n"}
{"sequence_id": "A109939", "text": "Largest k-digit prime == 1 (mod n) where k is the number of digits in n, or 0 if no such prime exists.", "sequence": "0,7,7,5,0,7,0,0,0,71,89,97,79,71,61,97,0,73,0,61,43,89,47,97,0,79,0,29,59,61,0,97,67,0,71,73,0,0,79,41,83,43,0,89,0,47,0,97,0,0,0,53,0,0,0,0,0,59,0,61,0,0,0,0,0,67,0,0,0,71,0,73,0,0,0,0", "code": " \nfrom sympy import prime, primerange\ndef aupto(limit):\n    alst, primeswithkdigs = [], dict()\n    for k in range(1, len(str(limit))+1):\n        primeswithkdigs[k] = list(primerange(10**(k-1), 10**k))[::-1]\n    for n in range(1, limit+1):\n        k, found = len(str(n)), False\n        for pk in primeswithkdigs[k]:\n            if pk%n == 1: alst.append(pk); found = True; break\n        if not found: alst.append(0)\n    return alst\nprint(aupto(39)) \n"}
{"sequence_id": "A110065", "text": "Numbers k such that 10^k - k is prime.", "sequence": "3,23,171,903,9911,48107,48449,60959", "code": "\nfrom sympy import isprime\ndef afind(limit):\n  m, pow10 = 0, 1\n  while m <= limit:\n    if isprime(pow10 - m): print(m, end=\", \")\n    m, pow10 =  m + 1, pow10 * 10\nafind(1000) \n"}
{"sequence_id": "A110068", "text": "Numbers n such that 10^(n-1) + pi(n) is the smallest n-digit prime.", "sequence": "2,6,23,78,5997", "code": "\nfrom sympy import nextprime, primepi\nA110068_list = [n for n in range(1,100) if nextprime(10**(n-1))-10**(n-1) == primepi(n)] \n"}
{"sequence_id": "A110240", "text": "Decimal form of binary integer produced by the ON cells at n-th generation following Wolfram's Rule 30 cellular automaton starting from a single ON-cell represented as 1.", "sequence": "1,7,25,111,401,1783,6409,28479,102849,456263,1641433,7287855,26332369,116815671,420186569,1865727615,6741246849,29904391303,107568396185,477630335215,1725755276049,7655529137527,27537575631497", "code": "\ndef A269160(n): return(n^((n<<1)|(n<<2)))\ndef genA110240():\n    '''Yield successive terms of A110240 (Rule 30) starting from A110240(0)=1.'''\n    s = 1\n    while True:\n       yield s\n       s = A269160(s)\ndef take(n, g):\n    '''Returns a list composed of the next n elements returned by generator g.'''\n    z = []\n    if 0 == n: return(z)\n    for x in g:\n        z.append(x)\n        if n > 1: n = n-1\n        else: return(z)\ntake(30, genA110240())\n\n"}
{"sequence_id": "A110374", "text": "a(n) = Sum_{composite c <= n} n!/c.", "sequence": "6,30,300,2100,21840,236880,2731680,30048480,400498560,5206481280,79117758720,1273944672000,21690789120000,368743415040000,6993068898816000,132868309077504000,2779011281958912000,60792138929313792000,1388517998616612864000", "code": "\nfrom sympy import factorial, isprime, Rational\ndef a(n): return factorial(n) * sum(Rational(1, c) for c in range(4, n+1) if not isprime(c))\nprint([a(n) for n in range(4, 23)]) \n"}
{"sequence_id": "A110502", "text": "Numbers n such that n in binary representation has a block of exactly a nontrivial square number of zeros.", "sequence": "16,33,48,66,67,80,97,112,132,133,134,135,144,161,176,194,195,208,225,240,264,265,266,267,268,269,270,271,272,289,304,322,323,336,353,368,388,389,390,391,400,417,432,450,451,464,481,496,512,528,529,530,531", "code": "\nfrom math import isqrt\nfrom itertools import groupby\ndef is_nt_sqr(n): \n    return n > 1 and isqrt(n)**2 == n\ndef ok(n):\n    b = bin(n)[2:]\n    return any(k == '0' and is_nt_sqr(len(list(g))) for k, g in groupby(b))\nprint(list(filter(ok, range(532)))) \n"}
{"sequence_id": "A110529", "text": "Numbers n such that n in ternary representation (A007089) has a block of exactly a prime number of consecutive zeros.", "sequence": "9,18,27,28,29,36,45,54,55,56,63,72,82,83,84,85,86,87,88,89,90,99,108,109,110,117,126,135,136,137,144,153,163,164,165,166,167,168,169,170,171,180,189,190,191,198,207,216,217,218,225,234,243,246,247,248,249", "code": "\nfrom re import split\nfrom sympy import isprime\ndef ternary (n):\n    if n == 0:\n        return '0'\n    nums = []\n    while n:\n        n, r = divmod(n, 3)\n        nums.append(str(r))\n    return ''.join(reversed(nums))\nseq_list, n = [],1\nwhile len(seq_list) < 10000:\n    for d in split('1+|2+', ternary(n)[1:]):\n        if isprime(len(d)):\n            seq_list.append(n)\n    n += 1\n\n"}
{"sequence_id": "A110534", "text": "Number of ways of writing 8n+5 as a sum of 5 odd squares.", "sequence": "1,1,1,2,2,2,3,3,2,4,4,3,5,5,4,6,6,4,7,7,5,8,8,7,9,9,6,10,10,8,11,11,10,12,13,8,13,14,11,14,14,12,15,16,12,16,18,14,18,18,14,20,20,14,19,20,16,21,24,19,21,24,18,23,24,20,24,27,23,26,25,20,29,30,23,25,31,26", "code": "\nf = open('b110534.txt', 'w')\nN = 20000\nn = 1\nt = [0]  \nwhile t[-1] <= N:\n....t += [t[-1]+n]\n....n += 1\nt = t[:-1]\na = [0]*(N+1)  \nlength = len(t)\nfor i in range(length):\n....for j in range(i,length):\n........p = t[i] + t[j]\n........if p > N: continue\n........for k in range(j,length):\n............q = p + t[k]\n............if q > N: continue\n............for l in range(k,length):\n................r = q + t[l]\n................if r > N: continue\n................for m in range(l,length):\n....................s = r + t[m]\n....................if s > N: break\n....................else: a[s] += 1\nfor index,value in enumerate(a):\n....f.write(str(index)+\" \"+str(value)+\"\\n\")\nf.close()\n\n"}
{"sequence_id": "A110566", "text": "a(n) = lcm{1,2,...,n}/denominator of harmonic number H(n).", "sequence": "1,1,1,1,1,3,3,3,1,1,1,1,1,1,1,1,1,3,3,15,45,45,45,15,3,3,1,1,1,1,1,1,11,11,11,11,11,11,11,11,11,77,77,7,7,7,7,7,1,1,1,1,1,3,3,3,3,3,3,3,3,3,9,9,9,27,27,27,9,9,9,3,3,3,3,3,33,33,33,33,11,11,11,11,11,11,11,1,1,1", "code": "\nfrom sympy import lcm, harmonic\ndef A110566(n): return lcm([k for k in range(1,n+1)])//harmonic(n).q \n"}
{"sequence_id": "A110690", "text": "Kekul\u00e9 numbers for certain benzenoids.", "sequence": "1,22,193,1045,4180,13566,37764,93456,210705,440440,864721,1610401,2866864,4908580,8123280,13046616,20404233,31162242,46587145,68316325,98440276,139597810,195085540,268983000,366294825,493111476,656790057", "code": "\nA110690_list, m = [], [62, -65, 20, 0, 1, 1, 1, 1, 1]\nfor _ in range(10001):\n    A110690_list.append(m[-1])\n    for i in range(8):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A110693", "text": "Kekul\u00e9 numbers for certain benzenoids.", "sequence": "1,36,448,3175,15786,61446,199872,566676,1441275,3356782,7268976,14805583,28621684,52892100,93977088,161303616,268510869,434915472,687359200,1062509679,1609692766,2394343930,3502175040,5044162500", "code": "\nA110693_list, m = [], [450, -816, 508, -121, 10, 1, 1, 1, 1, 1]\nfor _ in range(10001):\n    A110693_list.append(m[-1])\n    for i in range(9):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A110713", "text": "a(n) is the number of distinct products b_1*b_2*...*b_n where 1 <= b_i <= n.", "sequence": "1,3,10,25,91,196,750,1485,3025,5566,23387,38402,163268,284376,500004,795549,3575781,5657839,25413850,40027130,66010230,105164280,490429875,713491350,1232253906", "code": "\nfrom math import prod\nfrom itertools import combinations_with_replacement\ndef A110713(n): return len({prod(d) for d in combinations_with_replacement(list(range(1,n+1)),n)}) \n"}
{"sequence_id": "A110751", "text": "Numbers n such that n and its digital reversal have the same prime divisors.", "sequence": "1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,141,151,161,171,181,191,202,212,222,232,242,252,262,272,282,292,303,313,323,333,343,353,363,373,383,393,404,414,424,434,444,454,464,474,484,494", "code": "\nfrom sympy import primefactors\nA110751 = [n for n in range(1,10**5) if primefactors(n) == primefactors(int(str(n)[::-1]))] \n"}
{"sequence_id": "A110765", "text": "Let n in binary be a k-digit number say abbaaa... where a = 1 and b = 0. a(n) = 2^a*3^b*5^b*7*a... primes in increasing order raised to the powers starting from the MSB.", "sequence": "2,2,6,2,10,6,30,2,14,10,70,6,42,30,210,2,22,14,154,10,110,70,770,6,66,42,462,30,330,210,2310,2,26,22,286,14,182,154,2002,10,130,110,1430,70,910,770,10010,6,78,66,858,42,546,462,6006,30,390,330,4290,210,2730", "code": "\nfrom sympy import prime\nfrom operator import mul\nfrom functools import reduce\ndef A110765(n):\n....return reduce(mul, (prime(i) for i,d in enumerate(bin(n)[2:],start=1) if int(d)))\n\ndef _A110765(n):\n....nlen = len(n)\n....return _A110765(n[:-1])*(prime(nlen) if int(n[-1]) else 1) if nlen > 1 else int(n) + 1\ndef A110765(n):\n....return _A110765(bin(n)[2:])\n\n"}
{"sequence_id": "A110803", "text": "n times the number of digits in the decimal expansion of n.", "sequence": "1,2,3,4,5,6,7,8,9,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102", "code": "\ndef A110803(n):\n     return n*len(str(n)) \n"}
{"sequence_id": "A110815", "text": "Least n-digit number m whose square contains only digits not appearing in m.", "sequence": "2,17,144,1447,14144,141494,1414414,14144134,141431114,1414411113,14143143413,141431113114,1414311131114,14143111141813,141431113114113,1414311344113314,14143111141141113,141431113114331413", "code": "\nfrom math import isqrt\ndef a(n):\n  m = isqrt(int('2'+'0'*(2*n-2)))\n  while set(str(m*m)) & set(str(m)) != set(): m += 1\n  return m\nprint([a(n) for n in range(1, 12)]) \n"}
{"sequence_id": "A110819", "text": "Non-palindromes in A110751; that is, non-palindromic numbers n such that n and R(n) have the same prime divisors, where R(n) = digit reversal of n.", "sequence": "1089,2178,4356,6534,8712,9801,10989,21978,24024,26208,42042,43956,48048,61248,65934,80262,84084,84216,87912,98901,109989,219978,231504,234234,242424,253344,255528,264264,272646,275184,277816,288288,405132,424242,432432,439956", "code": "\nfrom sympy import primefactors\nA110819 = [n for n in range(1,10**6) if str(n) != str(n)[::-1] and primefactors(n) == primefactors(int(str(n)[::-1]))] \n"}
{"sequence_id": "A110833", "text": "a(n) = (prime(n)+1)^2.", "sequence": "9,16,36,64,144,196,324,400,576,900,1024,1444,1764,1936,2304,2916,3600,3844,4624,5184,5476,6400,7056,8100,9604,10404,10816,11664,12100,12996,16384,17424,19044,19600,22500,23104,24964,26896,28224,30276,32400,33124,36864", "code": "\nfrom sympy import primerange\nprint([(p+1)**2 for p in primerange(1, 192)]) \n"}
{"sequence_id": "A110835", "text": "Smallest m > 0 such that there are no primes between n*m and n*(m+1) inclusive.", "sequence": "8,4,8,6,18,15,17,25,13,20,29,44,87,81,35,83,79,74,70,67,118,330,58,223,172,229,179,471,292,360,506,367,586,577,645,545,424,743,503,637,766,467,937,579,698,683,542,1443,641,628,616,604,2026,1661,571,1834,551", "code": "\nfrom sympy import nextprime\ndef a(n):\n    m = 1\n    while nextprime(n*m-1) <= n*(m+1): m += 1\n    return m\nprint([a(n) for n in range(1, 58)]) \n"}
{"sequence_id": "A110904", "text": "Integers that can be expressed as a product of triangular numbers in 3 different ways.", "sequence": "630,3780,14850,16380,21420,114660,131670,159390,178200,234360,401940,478800,523260,556920,582120,712530,749700,835380,1455300,1753290,1936935,2086920,2162160,2633400,2841300,3828825,4791150,5821200,6056820,6380010,6396390,6486480", "code": "\nfrom __future__ import division\nmmax = 10**3\ntmax, A110904_dict = mmax*(mmax+1)//2, {}\nti = 0\nfor i in range(1,mmax+1):\n    ti += i\n    p = ti*i*(i-1)//2\n    for j in range(i,mmax+1):\n        p += ti*j\n        if p <= tmax:\n            A110904_dict[p] = A110904_dict[p]+1 if p in A110904_dict else 1\n        else:\n            break\nA110904_list = sorted([i for i in A110904_dict if A110904_dict[i] == 3]) \n"}
{"sequence_id": "A111116", "text": "Numbers n such that digits of n are not present in n^4.", "sequence": "2,3,4,7,8,9,24,27,28,32,33,42,52,53,58,59,67,77,88,89,93,202,203,258,284,303,324,329,377,383,422,669,818,832,843,878,882,887,949,2027,2042,2673,3144,3222,3253,3302,3308,3737,3773,3953,3979,3983,4779,5353,5669", "code": "\nA111116_list = [n for n in range(1,10**6) if set(str(n)) & set(str(n**4)) == set()]\n\n"}
{"sequence_id": "A111163", "text": "Triangular numbers that are sums of two consecutive primes.", "sequence": "36,78,120,210,276,300,630,946,990,1770,1830,2556,2850,3240,3570,4278,4950,5460,8256,9870,10878,11026,12090,12720,20100,20910,23436,26796,31626,34980,41616,43660,46056,55278,56616,57630,59340,66066,73920", "code": "\nfrom sympy import nextprime as np\nfrom sympy import prevprime as pp\nn=1\nt=n*(n+1)//2\nwhile t>0:\n....if t%2==0 and t>3:\n........i=int(t//2)\n........p=pp(i); q=np(p)\n........if p+q==t :\n............print(int(t))\n....n=n+1\n....t=n*(n+1)//2 \n"}
{"sequence_id": "A111163", "text": "Triangular numbers that are sums of two consecutive primes.", "sequence": "36,78,120,210,276,300,630,946,990,1770,1830,2556,2850,3240,3570,4278,4950,5460,8256,9870,10878,11026,12090,12720,20100,20910,23436,26796,31626,34980,41616,43660,46056,55278,56616,57630,59340,66066,73920", "code": "\nfrom __future__ import division\nfrom sympy import prevprime,nextprime,isprime\nA111163_list = [n*(n+1)//2 for n in range(3,10**4) if not isprime(n*(n+1)//4) and prevprime(n*(n+1)//4)+nextprime(n*(n+1)//4) == n*(n+1)//2] \n"}
{"sequence_id": "A111234", "text": "a(1)=2; thereafter a(n) = (largest proper divisor of n) + (smallest prime divisor of n).", "sequence": "2,3,4,4,6,5,8,6,6,7,12,8,14,9,8,10,18,11,20,12,10,13,24,14,10,15,12,16,30,17,32,18,14,19,12,20,38,21,16,22,42,23,44,24,18,25,48,26,14,27,20,28,54,29,16,30,22,31,60,32,62,33,24,34,18,35,68,36,26,37,72,38,74,39", "code": "\nfrom sympy import factorint\nA111234_list = [2] + [a+b//a for a, b in ((min(factorint(n)), n) for n in range(2,10001))] \n"}
{"sequence_id": "A111325", "text": "Numbers k such that 11 divides prime(1)+...+prime(k).", "sequence": "8,17,53,69,76,84,87,91,167,175,179,181,188,196,201,217,219,224,240,260,275,297,312,317,319,324,340,346,376,382,386,393,417,470,503,514,526,528,542,550,562,564,584,590,607,613,615,629,637,649,691,693,732,749,752,759", "code": "\nfrom sympy import nextprime\ndef aupto(limit):\n    p, s, alst = 2, 2, []\n    for k in range(1, limit+1):\n        if s == 0: alst.append(k)\n        p = nextprime(p); s = (s + p)%11\n    return alst\nprint(aupto(759)) \n"}
{"sequence_id": "A111371", "text": "A number k is included if at least one prime dividing k is equal to an exponent of the highest power of any prime dividing k.", "sequence": "4,12,18,20,24,27,28,36,44,50,52,54,60,68,72,76,84,90,92,98,100,108,116,120,124,126,132,135,140,144,148,150,156,160,164,168,172,180,188,189,196,198,200,204,212,216,220,228,234,236,242,244,252,260,264,268,270", "code": "\nfrom sympy import factorint\ndef aupto(limit):\n  alst = []\n  for k in range(4, limit+1):\n    f = factorint(k)\n    \n    if set(f[p] for p in f) & set(f) != set(): alst.append(k)\n  return alst\nprint(aupto(270)) \n"}
{"sequence_id": "A111456", "text": "Pandigitals in some base (A061845) with an extra property: each number formed by the first i digits is divisible by i (digits in the pandigital base).", "sequence": "2,108,228,13710,44790,6996920,11128712,12306056,3816547290,7838911147538198", "code": "\ndef dgen(n, b):\n    if n == 1:\n        t = list(range(b))\n        for i in range(1, b):\n            u = list(t)\n            u.remove(i)\n            yield i, u\n    else:\n        for d, v in dgen(n-1, b):\n            for g in v:\n                k = d*b+g\n                if not k % n:\n                    u = list(v)\n                    u.remove(g)\n                    yield k, u\nprint([a for n in range(2, 15, 2) for a, b in dgen(n, n)]) \n"}
{"sequence_id": "A111524", "text": "a(1) = 10; a(n) is smallest number >= a(n-1) such that the juxtaposition a(1)a(2)...a(n) is a prime.", "sequence": "10,13,23,49,111,113,171,211,293,309,309,469,639,759,951,1037,1057,1083,1257,1269,1287,1341,1551,1637,1677,1981,1989,2021,2059,2357,2583,2697,2967,3289,6789,7073,7323,7369,7463,7501,7709,7869,8029,8069,8077,8519", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n    alst, astr = [10], \"10\"\n    while len(alst) < terms:\n        k = alst[-1] + (1 - alst[-1]%2)\n        while not isprime(int(astr+str(k))): k += 2\n        alst.append(k)\n        astr += str(k)\n    return alst\nprint(aupton(46)) \n"}
{"sequence_id": "A111578", "text": "Triangle T(n, m) = T(n-1, m-1) + (4m-3)*T(n-1, m) read by rows 1<=m<=n.", "sequence": "1,1,1,1,6,1,1,31,15,1,1,156,166,28,1,1,781,1650,530,45,1,1,3906,15631,8540,1295,66,1,1,19531,144585,126651,30555,2681,91,1,1,97656,1320796,1791048,646086,86856,4956,120,1,1,488281,11984820,24604420,12774510", "code": "\ndef A096038(n,m):\n    if n < 1 or m < 1 or m > n:\n        return 0\n    elif n <=2:\n        return 1\n    else:\n        return A096038(n-1,m-1)+(4*m-3)*A096038(n-1,m)\nprint( [A096038(n,m) for n in range(20) for m in range(1,n+1)] )\n\n"}
{"sequence_id": "A111595", "text": "Triangle of coefficients of square of Hermite polynomials divided by 2^n with argument sqrt(x/2).", "sequence": "1,0,1,1,-2,1,0,9,-6,1,9,-36,42,-12,1,0,225,-300,130,-20,1,225,-1350,2475,-1380,315,-30,1,0,11025,-22050,15435,-4620,651,-42,1,11025,-88200,220500,-182280,67830,-12600,1204,-56,1,0,893025,-2381400,2302020,-1020600,235494,-29736,2052,-72", "code": "\nfrom sympy import hermite, Poly, sqrt, symbols\nx = symbols('x')\ndef a(n): return Poly(1/2**n*hermite(n, sqrt(x/2))**2, x).all_coeffs()[::-1]\nfor n in range(11): print(a(n)) \n"}
{"sequence_id": "A111723", "text": "Number of partitions of an n-set with an odd number of blocks of size 1.", "sequence": "1,0,4,4,31,86,449,1968,10420,56582,333235,2069772,13606113,94065232,682242552,5175100432,40954340995,337362555010,2886922399649,25616738519384,235313456176512,2234350827008170,21899832049913999,221292603495494488,2302631998398438321", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, t):\n    return t if n==0 else sum(b(n - j, (1 - t if j==1 else t))*binomial(n - 1, j - 1) for j in range(1, n + 1))\ndef a(n):\n    return b(n, 0)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A111724", "text": "Number of partitions of an n-set with an even number of blocks of size 1.", "sequence": "0,2,1,11,21,117,428,2172,10727,59393,345335,2143825,14038324,96834090,700715993,5305041715,41910528809,344714251149,2945819805408,26107419715988,239556359980239,2272364911439153,22252173805170347,224666265799310801,2335958333831561032", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, t): return t if n==0 else sum(b(n - j, (1 - t if j==1 else t))*binomial(n - 1, j - 1) for j in range(1, n + 1))\ndef a(n): return b(n, 1)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A111752", "text": "Number of partitions of {1,..,n} into lists with an even number of lists of size 1, where a list means an ordered subset (cf. A000262).", "sequence": "1,0,3,6,49,300,2491,22890,239457,2782584,35595091,496577070,7499663953,121855323876,2118793593099,39245026343250,771255810671041,16025261292247920,350956070419872547,8078570913162379734,194969375055353840241,4922311437793379501340", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial, factorial as f\n@cacheit\ndef b(n, t): return t if n==0 else sum(b(n - j, (1 - t if j==1 else t))*binomial(n - 1, j - 1)*f(j) for j in range(1, n + 1))\ndef a(n): return b(n, 1)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A111753", "text": "Number of partitions of {1,..,n} into lists with an odd number of lists of size 1, where a list means an ordered subset, cf. A000262.", "sequence": "0,1,0,7,24,201,1560,14743,154896,1813969,23346000,327496071,4970498280,81121077337,1416223931304,26328776843671,519178407998880,10821355158998433,237677397895531296,5485802780426178439,132728552830731814200,3358841601972480225001", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial, factorial as f\n@cacheit\ndef b(n, t): return t if n==0 else sum([b(n - j, (1 - t if j==1 else t))*binomial(n - 1, j - 1)*f(j) for j in range(1, n + 1)])\ndef a(n): return b(n, 0)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A111882", "text": "Row sums of triangle A111595 (normalized rescaled squared Hermite polynomials).", "sequence": "1,1,0,4,4,36,256,400,17424,784,1478656,876096,154753600,560363584,19057250304,220388935936,2564046397696,83038749753600,327933273309184,33173161139160064,26222822450021376,14475245839622726656", "code": "\nfrom sympy import hermite, Poly, sqrt\ndef a(n): return sum(Poly(1/2**n*hermite(n, sqrt(x/2))**2, x).all_coeffs()) \n"}
{"sequence_id": "A111883", "text": "Unsigned row sums of triangle A111595 (normalized rescaled squared Hermite polynomials).", "sequence": "1,1,4,16,100,676,5776,53824,583696,6864400,90174016,1274204416,19642583104,323196798016,5714394630400,107112895415296,2135062451773696,44858948563673344,994634863541502976,23133227941938073600,564474119626559497216,14388648533002088866816", "code": "\nfrom sympy import hermite, Poly, sqrt, I\ndef a(n): return abs(Poly(hermite(n, I/sqrt(2)), x))**2/2**n \n"}
{"sequence_id": "A112046", "text": "a(n) = the least k >= 1 for which the Jacobi symbol J(k,2n+1) is not +1 (thus is either 0 or -1).", "sequence": "2,2,3,3,2,2,3,3,2,2,5,5,2,2,3,3,2,2,3,3,2,2,5,7,2,2,3,3,2,2,3,3,2,2,7,5,2,2,3,3,2,2,3,3,2,2,5,5,2,2,3,3,2,2,3,3,2,2,7,11,2,2,3,3,2,2,3,3,2,2,5,5,2,2,3,3,2,2,3,3,2,2,5,13,2,2,3,3,2,2,3,3,2,2,7,5,2,2,3,3,2,2", "code": "\nfrom sympy import jacobi_symbol as J\ndef a(n):\n    i=1\n    while True:\n        if J(i, 2*n + 1)!=1: return i\n        else: i+=1\nprint([a(n) for n in range(1, 103)]) \n"}
{"sequence_id": "A112047", "text": "Bisection of A112046.", "sequence": "2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,7,2,3,2,3,2,5,2,3,2,3,2,7,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,7,2,3,2,3,2,5,2,3,2,3,2,7,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,11,2,3,2,3,2,5,2,3,2,3,2,7,2,3,2,3,2,5,2,3,2,3,2,5", "code": "\nfrom sympy import jacobi_symbol as J\ndef a112046(n):\n    i=1\n    while True:\n        if J(i, 2*n + 1)!=1: return i\n        else: i+=1\nprint([a112046(2*n - 1) for n in range(1, 103)]) \n"}
{"sequence_id": "A112048", "text": "Bisection of A112046.", "sequence": "2,3,2,3,2,5,2,3,2,3,2,7,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,11,2,3,2,3,2,5,2,3,2,3,2,13,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,7,2,3,2,3,2,5,2,3,2,3,2,17,2,3,2,3,2,5,2,3,2,3,2,5,2,3,2,3,2,19,2,3,2,3,2,5,2,3,2,3,2", "code": "\nfrom sympy import jacobi_symbol as J\ndef a112046(n):\n    i=1\n    while True:\n        if J(i, 2*n + 1)!=1: return i\n        else: i+=1\ndef a(n): return a112046(2*n)\nprint([a(n) for n in range(1, 102)])  \n"}
{"sequence_id": "A112049", "text": "a(n) = position of A112046(n) in A000040.", "sequence": "1,1,2,2,1,1,2,2,1,1,3,3,1,1,2,2,1,1,2,2,1,1,3,4,1,1,2,2,1,1,2,2,1,1,4,3,1,1,2,2,1,1,2,2,1,1,3,3,1,1,2,2,1,1,2,2,1,1,4,5,1,1,2,2,1,1,2,2,1,1,3,3,1,1,2,2,1,1,2,2,1,1,3,6,1,1,2,2,1,1,2,2,1,1,4,3,1,1,2,2,1,1", "code": "\nfrom sympy import jacobi_symbol as J, isprime, primepi\ndef a049084(n):\n    return primepi(n) if isprime(n) else 0\ndef a112046(n):\n    i=1\n    while True:\n        if J(i, 2*n + 1)!=1: return i\n        else: i+=1\ndef a(n): return a049084(a112046(n))\nprint([a(n) for n in range(1, 103)]) \n"}
{"sequence_id": "A112050", "text": "Length of the longest prefix of 1's in the Jacobi-vector {J(2n+1,1),J(2n+1,2),...,J(2n+1,2n)}.", "sequence": "1,1,2,2,1,1,2,2,1,1,4,4,1,1,2,2,1,1,2,2,1,1,4,6,1,1,2,2,1,1,2,2,1,1,6,4,1,1,2,2,1,1,2,2,1,1,4,4,1,1,2,2,1,1,2,2,1,1,6,10,1,1,2,2,1,1,2,2,1,1,4,4,1,1,2,2,1,1,2,2,1,1,4,12,1,1,2,2,1,1,2,2,1,1,6,4,1,1,2,2,1,1", "code": "\nfrom sympy import jacobi_symbol as J\ndef a112046(n):\n    i=1\n    while True:\n        if J(i, 2*n + 1)!=1: return i\n        else: i+=1\ndef a(n): return a112046(n) - 1\nprint([a(n) for n in range(1, 103)]) \n"}
{"sequence_id": "A112053", "text": "a(n) = A112046(2n) - A112046(2n-1) = A112048(n) - A112047(n).", "sequence": "0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,-2,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,-6,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom sympy import jacobi_symbol as J\ndef a112046(n):\n    i=1\n    while True:\n        if J(i, 2*n + 1)!=1: return i\n        else: i+=1\ndef a(n): return a112046(2*n) - a112046(2*n - 1)\nprint([a(n) for n in range(1, 102)]) \n"}
{"sequence_id": "A112054", "text": "Indices where A112053 is not zero.", "sequence": "12,18,30,42,48,72,78,90,102,108,120,132,138,162,168,180,192,198,210,222,228,240,252,258,282,288,300,312,318,330,342,348,372,378,390,402,408,420,432,438,450,462,468,492,498,510,522,528,540,552,558,582,588", "code": "\nfrom sympy import jacobi_symbol as J\ndef a112046(n):\n    i=1\n    while True:\n        if J(i, 2*n + 1)!=1: return i\n        else: i+=1\ndef a(n): return a112046(2*n) - a112046(2*n - 1)\nprint([n for n in range(1, 1001) if a(n)!=0]) \n"}
{"sequence_id": "A112055", "text": "a(n) = A112054(n)/6.", "sequence": "2,3,5,7,8,12,13,15,17,18,20,22,23,27,28,30,32,33,35,37,38,40,42,43,47,48,50,52,53,55,57,58,62,63,65,67,68,70,72,73,75,77,78,82,83,85,87,88,90,92,93,97,98,100,102,103,107,108,110,112,113,117,118,120,122", "code": "\nfrom sympy import jacobi_symbol as J\ndef a112046(n):\n    i=1\n    while True:\n        if J(i, 2*n + 1)!=1: return i\n        else: i+=1\ndef a(n): return a112046(2*n) - a112046(2*n - 1)\nprint([n//6 for n in range(1, 201) if a(n)!=0]) \n"}
{"sequence_id": "A112056", "text": "Odd numbers of the form 4n-1 for which Jacobi-first-non-one(4n-1) differs from Jacobi-first-non-one(4n+1).", "sequence": "47,71,119,167,191,287,311,359,407,431,479,527,551,647,671,719,767,791,839,887,911,959,1007,1031,1127,1151,1199,1247,1271,1319,1367,1391,1487,1511,1559,1607,1631,1679,1727,1751,1799,1847,1871,1967", "code": "\nfrom sympy import jacobi_symbol as J\ndef a112046(n):\n    i=1\n    while True:\n        if J(i, 2*n + 1)!=1: return i\n        else: i+=1\ndef a(n): return a112046(2*n) - a112046(2*n - 1)\nprint([4*n - 1 for n in range(1, 1001) if a(n)!=0]) \n"}
{"sequence_id": "A112058", "text": "Mean of A112056 and A112057.", "sequence": "48,72,120,168,192,288,312,360,408,432,480,528,552,648,672,720,768,792,840,888,912,960,1008,1032,1128,1152,1200,1248,1272,1320,1368,1392,1488,1512,1560,1608,1632,1680,1728,1752,1800,1848,1872,1968", "code": "\nfrom sympy import jacobi_symbol as J\ndef a112046(n):\n    i=1\n    while True:\n        if J(i, 2*n + 1)!=1: return i\n        else: i+=1\ndef a(n): return a112046(2*n) - a112046(2*n - 1)\nprint([4*n for n in range(1, 1001) if a(n)!=0]) \n"}
{"sequence_id": "A112059", "text": "Nonzero terms of A112053 and A112080.", "sequence": "2,-2,4,8,-2,12,-6,12,2,-2,-6,18,-6,2,-6,-4,2,-2,18,2,-2,24,6,-2,6,-8,4,2,-2,-6,32,-6,2,-6,-10,2,-2,28,2,-2,4,38,-2,6,-6,4,2,-2,-4,42,-6,2,-8,-4,2,-2,2,-2,6,8,-2,48,-6,4,2,-2,-10,6,-12,2,-6,-4,2,-2,2,-2,52,8", "code": "\nfrom sympy import jacobi_symbol as J\ndef a112046(n):\n    i=1\n    while True:\n        if J(i, 2*n + 1)!=1: return i\n        else: i+=1\ndef a(n): return a112046(2*n) - a112046(2*n - 1)\nprint([a(n) for n in range(1, 201) if a(n)!=0]) \n"}
{"sequence_id": "A112141", "text": "Product of the first n semiprimes.", "sequence": "4,24,216,2160,30240,453600,9525600,209563200,5239080000,136216080000,4495130640000,152834441760000,5349205461600000,203269807540800000,7927522494091200000,364666034728195200000,17868635701681564800000,911300420785759804800000", "code": "\nfrom sympy import factorint\ndef aupton(terms):\n    alst, k, p = [], 1, 1\n    while len(alst) < terms:\n        if sum(factorint(k).values()) == 2:\n            p *= k\n            alst.append(p)\n        k += 1\n    return alst\nprint(aupton(18)) \n"}
{"sequence_id": "A112258", "text": "Numbers n not divisible by 10 such that the decimal representation of n^26 does not use every nonzero digit.", "sequence": "1,2,3,4,6,7,8,9,12,13,14,17,23,29,39,61,81,95,119,164,242,5193,9004,23432,246968,8876708,32886598,2141194665", "code": "\nA112258_list = [n for n in range(1,10**6) if n % 10 and len(set(str(n**26))) < 10] \n"}
{"sequence_id": "A112296", "text": "Smret suoiverp eht fo mus fo esrever.", "sequence": "9,9,81,99,891,9801,9801,19602,39204,79497,499851,548856,1077021,2274822,4459554,8909109,70282971,87111288,664223571,730645938,5791910751,6272012637,36351143631,49985258994,88971507999,789520249881,868572264879,7470454307481", "code": "\ndef aupton(terms):\n    alst, s = [9], 9\n    for n in range(2, terms+1):\n        alst.append(int(str(s)[::-1]))\n        s += alst[-1]\n    return alst\nprint(aupton(28)) \n"}
{"sequence_id": "A112388", "text": "a(n) is the smallest prime p such that p^n contains every digit.", "sequence": "10123457689,101723,5437,2339,1009,257,139,173,83,67,31,29,37,17,17,47,19,7,5,23,23,5,11,11,17,5,5,5,5,11,5,11,11,5,5,7,5,7,3,5,5,7,7,7,3,7,3,3,5,5,5,5,3,7,7,5,3,7,5,3,3,3,3,3,3,5,3,2,3,2,3,3,3,3,5,3,3,3,2,3,5,2", "code": "\nfrom sympy import nextprime\ndef a(n):\n    if n == 1: return 10123457689\n    p = 2\n    while not(len(set(str(p**n))) == 10): p = nextprime(p)\n    return p\nprint([a(n) for n in range(1, 83)]) \n"}
{"sequence_id": "A112456", "text": "Least triangular number divisible by n-th prime.", "sequence": "6,3,10,21,55,78,136,171,253,406,465,666,820,903,1081,1378,1711,1830,2211,2485,2628,3081,3403,3916,4656,5050,5253,5671,5886,6328,8001,8515,9316,9591,11026,11325,12246,13203,13861,14878,15931,16290,18145,18528,19306", "code": "\nfrom sympy import prime\ndef a(n):\n    if n == 1: return 6\n    p = prime(n)\n    return p*(p-1)//2\nprint([a(n) for n in range(1, 46)]) \n"}
{"sequence_id": "A112484", "text": "Array where n-th row contains the primes < n and coprime to n.", "sequence": "2,3,2,3,5,2,3,5,3,5,7,2,5,7,3,7,2,3,5,7,5,7,11,2,3,5,7,11,3,5,11,13,2,7,11,13,3,5,7,11,13,2,3,5,7,11,13,5,7,11,13,17,2,3,5,7,11,13,17,3,7,11,13,17,19,2,5,11,13,17,19,3,5,7,13,17,19,2,3,5,7,11,13,17,19,5,7,11,13", "code": "\nfrom sympy import primerange, gcd\ndef a(n): return [i for i in primerange(1, n) if gcd(i, n)==1]\nfor n in range(3, 24): print(a(n)) \n"}
{"sequence_id": "A112540", "text": "Numbers m such that (15m-4, 15m-2, 15m+2, 15m+4) is a prime quadruple.", "sequence": "1,7,13,55,99,125,139,217,231,377,629,867,1043,1049,1071,1203,1261,1295,1401,1485,1687,2115,2323,2919,3423,3689,4199,4481,4633,4815,5151,5313,5403,5515,5921,6523,6609,6741,7323,7769,7953,8147,9031,9611,10485,11047", "code": "\nfrom sympy import isprime\ndef ok(m): return all(isprime(15*m+k) for k in [-4, -2, 2, 4])\nprint(list(filter(ok, range(11111)))) \n"}
{"sequence_id": "A112676", "text": "Number of (undirected) Hamiltonian cycles on a triangular grid, n vertices on each side.", "sequence": "1,1,1,3,26,474,17214,1371454,231924780,82367152914,61718801166402,97482824713311442,323896536556067453466,2262929852279448821099932,33231590982432936619392054662,1025257090790362187626154669771934,66429726878393651076826663971376589034", "code": "\n\nfrom graphillion import GraphSet\ndef make_n_triangular_grid_graph(n):\n    s = 1\n    grids = []\n    for i in range(n + 1, 1, -1):\n        for j in range(i - 1):\n            a, b, c = s + j, s + j + 1, s + i + j\n            grids.extend([(a, b), (a, c), (b, c)])\n        s += i\n    return grids\ndef A112676(n):\n    if n == 1: return 1\n    universe = make_n_triangular_grid_graph(n - 1)\n    GraphSet.set_universe(universe)\n    cycles = GraphSet.cycles(is_hamilton=True)\n    return cycles.len()\nprint([A112676(n) for n in range(1, 12)])  \n"}
{"sequence_id": "A112765", "text": "Exponent of highest power of 5 dividing n. Or, 5-adic valuation of n.", "sequence": "0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,2,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,2,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,2,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,2,0,0,0,0,1", "code": "\ndef a(n):\n    k = 0\n    while n > 0 and n%5 == 0: n //= 5; k += 1\n    return k\nprint([a(n) for n in range(1, 106)]) \n"}
{"sequence_id": "A112774", "text": "Semiprimes of the form 6n+4.", "sequence": "4,10,22,34,46,58,82,94,106,118,142,166,178,202,214,226,262,274,298,334,346,358,382,394,454,466,478,502,514,526,538,562,586,622,634,694,706,718,766,778,802,838,862,886,898,922,934,958,982,1006,1018,1042,1114", "code": "\nfrom sympy import factorint\ndef semiprime(n): f = factorint(n); return sum(f[p] for p in f) == 2\nprint(list(filter(semiprime, range(4, 1115, 6)))) \n"}
{"sequence_id": "A112822", "text": "Least number k such that lcm{1,2,...,k}/denominator of harmonic number H(k) = 2n-1.", "sequence": "1,6,105,44,63,33,156,20,272,343,38272753,11881,100,66,822,28861,77", "code": "\nfrom fractions import Fraction\nfrom sympy import lcm\ndef A112822(n):\n    k, l, h = 1, 1, Fraction(1,1)\n    while l != h.denominator*(2*n-1):\n        k += 1\n        l = lcm(l,k)\n        h += Fraction(1,k)\n    return k \n"}
{"sequence_id": "A112983", "text": "2^(n+1) mod n.", "sequence": "0,0,1,0,4,2,4,0,7,8,4,8,4,8,1,0,4,2,4,12,16,8,4,8,14,8,25,4,4,8,4,0,16,8,1,20,4,8,16,32,4,2,4,32,34,8,4,32,11,48,16,32,4,2,31,8,16,8,4,32,4,8,16,0,64,62,4,32,16,18,4,56,4,8,61,32,36,50,4", "code": "\nprint([2**(n+1) % n for n in range(1,77)])\n\n"}
{"sequence_id": "A112993", "text": "Exclusionary cubes: cubes of the terms in A112994.", "sequence": "8,27,343,512,19683,79507,103823,110592,140608,148877,250047,314432,778688,3869893,5088448,6539203,7077888,18191447,54010152,67917312,75686967,96071912,102503232,109215352,115501303,146363183,202262003,224755712", "code": "\ndef ok(n):\n    s = str(n)\n    return len(s) == len(set(s)) and set(s) & set(str(n**3)) == set()\nprint([k**3 for k in range(7659) if ok(k)]) \n"}
{"sequence_id": "A112993", "text": "Exclusionary cubes: cubes of the terms in A112994.", "sequence": "8,27,343,512,19683,79507,103823,110592,140608,148877,250047,314432,778688,3869893,5088448,6539203,7077888,18191447,54010152,67917312,75686967,96071912,102503232,109215352,115501303,146363183,202262003,224755712", "code": " \nfrom itertools import permutations\ndef no_repeated_digits():\n    for d in range(1, 11):\n        for p in permutations(\"0123456789\", d):\n            if p[0] == '0': continue\n            yield int(\"\".join(p))\ndef afull():\n    alst = []\n    for k in no_repeated_digits():\n        if set(str(k)) & set(str(k**3)) == set():\n            alst.append(k**3)\n    return alst\nprint(afull()) \n"}
{"sequence_id": "A112994", "text": "Numbers whose cubes are exclusionary: numbers k such that k has no repeated digits and k and k^3 have no digits in common.", "sequence": "2,3,7,8,27,43,47,48,52,53,63,68,92,157,172,187,192,263,378,408,423,458,468,478,487,527,587,608,648,692,823,843,918,1457,1587,1592,4657,4732,5692,6058,6378,7658", "code": "\ndef ok(n):\n    s = str(n)\n    return len(s) == len(set(s)) and set(s) & set(str(n**3)) == set()\nprint([k for k in range(7659) if ok(k)]) \n"}
{"sequence_id": "A112994", "text": "Numbers whose cubes are exclusionary: numbers k such that k has no repeated digits and k and k^3 have no digits in common.", "sequence": "2,3,7,8,27,43,47,48,52,53,63,68,92,157,172,187,192,263,378,408,423,458,468,478,487,527,587,608,648,692,823,843,918,1457,1587,1592,4657,4732,5692,6058,6378,7658", "code": " \nfrom itertools import permutations\ndef no_repeated_digits():\n    for d in range(1, 11):\n        for p in permutations(\"0123456789\", d):\n            if p[0] == '0': continue\n            yield int(\"\".join(p))\ndef afull():\n    alst = []\n    for k in no_repeated_digits():\n        if set(str(k)) & set(str(k**3)) == set():\n            alst.append(k)\n    return alst\nprint(afull()) \n"}
{"sequence_id": "A113009", "text": "{Sum of the digits of n} raised to the power {number of digits of n}.", "sequence": "0,1,2,3,4,5,6,7,8,9,1,4,9,16,25,36,49,64,81,100,4,9,16,25,36,49,64,81,100,121,9,16,25,36,49,64,81,100,121,144,16,25,36,49,64,81,100,121,144,169,25,36,49,64,81,100,121,144,169,196,36,49,64,81,100,121,144,169,196", "code": "\ndef A113009(n):\n    return sum(int(d) for d in str(n))**len(str(n)) \n"}
{"sequence_id": "A113010", "text": "{Number of digits of n} raised to the power of {the sum of the digits of n}.", "sequence": "1,1,1,1,1,1,1,1,1,1,2,4,8,16,32,64,128,256,512,1024,4,8,16,32,64,128,256,512,1024,2048,8,16,32,64,128,256,512,1024,2048,4096,16,32,64,128,256,512,1024,2048,4096,8192,32,64,128,256,512,1024,2048,4096,8192", "code": "\ndef A113010(n):\n    return len(str(n))**sum(int(d) for d in str(n)) \n"}
{"sequence_id": "A113022", "text": "a(n) = size of union of 2^k (mod 10^n), 0 < k <= 5^n.", "sequence": "4,21,102,503,2504,12505,62506,312507,1562508,7812509,39062510,195312511,976562512,4882812513,24414062514,122070312515,610351562516,3051757812517,15258789062518,76293945312519,381469726562520,1907348632812521,9536743164062522,47683715820312523,238418579101562524", "code": "\ndef a(n):\n  modder = 10**n\n  return len(set(pow(2, k, modder) for k in range(1, 5**n+1)))\nprint([a(n) for n in range(1, 10)]) \n"}
{"sequence_id": "A113172", "text": "Scrabble value of English word for the number n.", "sequence": "13,3,6,8,7,10,10,8,9,4,3,9,12,11,11,13,14,12,12,8,12,15,18,20,19,22,22,20,21,16,12,15,18,20,19,22,22,20,21,16,11,14,17,19,18,21,21,19,20,15,14,17,20,22,21,24,24,22,23,18,15,18,21,23,22,25,25,23,24,19,13,16,19", "code": "\nfrom num2words import num2words\ntp = {\"aeilnorstu\": 1, \"dg\": 2, \"bcmp\":3, \"fhvwy\":4, \"k\":5, \"jx\":8, \"qz\":10}\ndef pts(c): return ([tp[s] for s in tp if c in s]+[0])[0]\ndef a(n): return sum(map(pts, num2words(n).replace(\" and\", \"\")))\nprint([a(n) for n in range(73)]) \n"}
{"sequence_id": "A113484", "text": "a(n) = smallest composite integer > n and coprime to n.", "sequence": "4,9,4,9,6,25,8,9,10,21,12,25,14,15,16,21,18,25,20,21,22,25,24,25,26,27,28,33,30,49,32,33,34,35,36,49,38,39,40,49,42,55,44,45,46,49,48,49,50,51,52,55,54,55,56,57,58,63,60,77,62,63,64,65,66,85,68,69,70,81,72,77", "code": "\nfrom sympy import isprime, gcd\ndef A113484(n):\n    k = n+1\n    while gcd(k,n) != 1 or isprime(k):\n        k += 1\n    return k \n"}
{"sequence_id": "A113496", "text": "a(n) = smallest composite integer > c(n) and coprime to c(n), where c(n) is the n-th composite integer.", "sequence": "9,25,9,10,21,25,15,16,21,25,21,22,25,25,26,27,28,33,49,33,34,35,36,49,39,40,49,55,45,46,49,49,50,51,52,55,55,56,57,58,63,77,63,64,65,66,85,69,70,81,77,75,76,77,78,85,81,82,85,85,86,87,88,91,91,92,93,94,95,96", "code": "\nfrom sympy import isprime, gcd, composite\ndef A113496(n):\n    m = composite(n)\n    k = m+1\n    while gcd(k,m) != 1 or isprime(k):\n        k += 1\n    return k \n"}
{"sequence_id": "A113574", "text": "a(n) is the least n-digit number whose k-th digit is prime if k is prime, composite if k is composite, and 1 if k=1.", "sequence": "1,12,122,1224,12242,122424,1224242,12242424,122424244,1224242444,12242424442,122424244424,1224242444242,12242424442424,122424244424244,1224242444242444,12242424442424442,122424244424244424", "code": "\nfrom sympy import isprime\ndef a(n): return 1 if n<2 else int(str(a(n - 1)) + \"2\") if isprime(n) else int(str(a(n - 1)) + \"4\")\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A113630", "text": "1 + 2*n + 3*n^2 + 4*n^3 + 5*n^4 + 6*n^5 + 7*n^6 + 8*n^7 + 9*n^8.", "sequence": "1,45,4097,83653,757305,4272461,17736745,59409477,169826513,429794605,987654321,2098573445,4178995657,7879732173,14181546905,24517448581,40926266145,66242446637,104327377633,160347899205,241108033241", "code": "\nA113630_list, m = [1], [362880, -1229760, 1607760, -1011480, 309816, -40752, 1584, -4, 1]\nfor _ in range(10**3):\n....for i in range(8):\n........m[i+1]+= m[i]\n....A113630_list.append(m[-1]) \n"}
{"sequence_id": "A113646", "text": "a(n) is the smallest composite integer which is >= n.", "sequence": "4,4,4,4,6,6,8,8,9,10,12,12,14,14,15,16,18,18,20,20,21,22,24,24,25,26,27,28,30,30,32,32,33,34,35,36,38,38,39,40,42,42,44,44,45,46,48,48,49,50,51,52,54,54,55,56,57,58,60,60,62,62,63,64,65,66,68,68,69,70,72,72", "code": "\nfrom sympy import isprime\ndef a(n):\n  an = max(4, n)\n  while isprime(an): an += 1\n  return an\nprint([a(n) for n in range(1, 73)]) \n"}
{"sequence_id": "A113754", "text": "Number of possible squares on an n^2 X n^2 grid.", "sequence": "1,30,285,1496,5525,16206,40425,89440,180441,338350,597861,1005720,1623245,2529086,3822225,5625216,8087665,11389950,15747181,21413400,28686021,37910510,49485305,63866976,81575625,103200526,129406005,160937560,198628221,243405150", "code": "\ndef a(n): return n**2 * (n**2+1) * (2*n**2+1) // 6\nprint([a(n) for n in range(1, 31)]) \n"}
{"sequence_id": "A113878", "text": "a(1)=0; a(n+1) is the least number > a(n) such that Sum_{k=1..n+1} 2^a(k) is not composite.", "sequence": "0,1,2,4,7,16,53,66,207,1752,5041,6310", "code": "\nfrom sympy import isprime\ndef afind(limit):\n    print(\"0, 1\", end=\", \")\n    s, pow2 = 2**0 + 2**1, 2**2\n    for m in range(2, limit+1):\n        if isprime(s+pow2): print(m, end=\", \"); s += pow2\n        pow2 *= 2\nafind(2000) \n"}
{"sequence_id": "A113951", "text": "Largest number whose n-th power is exclusionary (or 0 if no such number exists).", "sequence": "639172,7658,2673,0,92,93,712,0,18,12,4,0,37,0,9,0,0,3,4,0,7,2,7,0,8,3,9,0,0,0,0,0,3,2,2,0,0,7,3,0,2,0,0,0,2,0,0,0,3,0,0,0,2,3,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,2,3", "code": "\nfrom itertools import combinations, permutations\ndef no_repeated_digits():\n    for d in range(1, 11):\n        for p in permutations(\"0123456789\", d):\n            if p[0] == '0': continue\n            yield int(\"\".join(p))\ndef a(n):\n    m = 0\n    for k in no_repeated_digits():\n        if set(str(k)) & set(str(k**n)) == set():\n            m = max(m, k)\n    return m\nfor n in range(2, 4): print(a(n), end=\", \") \n"}
{"sequence_id": "A113963", "text": "a(1)=1; for n>1, a(n) is the smallest positive integer not occurring earlier in the sequence where |a(n)-a(n-1)| does not divide (a(n)+a(n-1)).", "sequence": "1,4,7,2,5,8,3,10,13,6,11,14,9,16,19,12,17,20,23,15,22,25,18,26,21,29,24,31,27,32,35,38,28,33,37,30,39,34,40,43,36,41,44,47,42,50,53,45,49,46,51,55,48,57,52,58,61,54,59,56,62,65,68,63,67,60,69,64,70,73,66,71", "code": "\nA113963 = [1]\nfor n in range(1,10**2):\n....a, b = 1, A113963[-1]\n....while a in A113963 or not (a+b) % (a-b):\n........a += 1\n....A113963.append(a) \n"}
{"sequence_id": "A114043", "text": "Take an n X n square grid of points in the plane; a(n) = number of ways to divide the points into two sets using a straight line.", "sequence": "1,7,29,87,201,419,749,1283,2041,3107,4493,6395,8745,11823,15557,20075,25457,32087,39725,48935,59457,71555,85253,101251,119041,139351,161933,187255,215137,246691,280917,319347,361329,407303", "code": "\nfrom sympy import totient\ndef A114043(n): return 4*n**2-6*n+3 + 2*sum(totient(i)*(n-i)*(2*n-i) for i in range(2,n)) \n"}
{"sequence_id": "A114065", "text": "Numbers k such that the digits of phi(k) and sigma(k) are permutations of those of k.", "sequence": "1,3014685,21638943,170726121,207380169,215341083,233559801,234511083,321634251,1620475083,1982243007,2019804093,2084013063,2185499607,2410658685,2653713819,2741018409,2859457041,3018792645,3075268041,3148920504,3701484126,4071408255", "code": "\nfrom sympy import totient, divisor_sigma\nA114065_list = [n for n in range(1,10**7) if sorted(str(divisor_sigma(n))) == sorted(str(totient(n))) == sorted(str(n))] \n"}
{"sequence_id": "A114146", "text": "Number of threshold functions on n X n grid.", "sequence": "1,2,14,58,174,402,838,1498,2566,4082,6214,8986,12790,17490,23646,31114,40150,50914,64174,79450,97870,118914,143110,170506,202502,238082,278702,323866,374510,430274,493382,561834,638694,722658,814606,914362,1023430,1140466", "code": "\nfrom sympy import totient\ndef A114146(n): return 1 if n == 0 else 8*n**2-12*n+6 + 4*sum(totient(i)*(n-i)*(2*n-i) for i in range(2,n)) \n"}
{"sequence_id": "A114429", "text": "Larger of the greatest twin prime pair with n digits.", "sequence": "7,73,883,9931,99991,999961,9999973,99999589,999999193,9999999703,99999999763,999999999961,9999999998491,99999999999973,999999999997969,9999999999999643,99999999999998809,999999999999998929", "code": "\nimport sympy\nfor i in range(1,100):\n    p=sympy.prevprime(10**i)\n    while not sympy.isprime(p-2):\n        p=sympy.prevprime(p)\n    print(p)\n\n"}
{"sequence_id": "A114433", "text": "Last digit (the checksum) of 10-digit ISBN numbers, 10 is represented as \"X\".", "sequence": "9,7,5,3,1,10,8,6,4,8,6,4,2,0,9,7,5,3,1,5,3,1,10,8,6,4,2,0,9,2,0,9,7,5,3,1,10,8,6,10,8,6,4,2,0,9,7,5,3,7,5,3,1,10,8,6,4,2,0,4,2,0,9,7,5,3,1,10,8,1,10,8,6,4,2,0,9,7,5,9,7,5,3,1,10,8,6,4,2,6,4,2,0,9,7,5,3,1,10", "code": "\ndef a(n): return sum((i+1)*int(s) for i, s in enumerate(str(n).zfill(9)))%11\nprint([a(n) for n in range(1, 100)]) \n"}
{"sequence_id": "A114574", "text": "a(n) = p*p! where p = prime(n).", "sequence": "4,18,600,35280,439084800,80951270400,6046686277632000,2311256907767808000,594596384994354462720000,256411097818451356681764864000000,254907998279515607349492449280000000,509258864375374766713691244518493388800000000,1371553591139716091434972544191070818271232000000000", "code": "\nfrom sympy import factorial, prime\ndef a(n): p = prime(n); return p * factorial(p)\nprint([a(n) for n in range(1, 14)]) \n"}
{"sequence_id": "A114793", "text": "a(1) = a(2) = 1; for n>2, a(n) = a(n-2)^3 + a(n-1)^2.", "sequence": "1,1,2,5,33,1214,1509733,2281082919633,5203342727366374356990526,27074775538448408469117040958804384971249439965813,733043470457364306745565389055274337169526356099299839341244874661931850021760795731279812250002545", "code": "\na,b = 0,1\nfor k in range(8):\n    print(b, end=\", \")\n    a,b = b, a*a*a + b*b\n"}
{"sequence_id": "A114795", "text": "{concatenation n, n-1, n-2, ...3,2,1} mod n.", "sequence": "0,1,0,1,1,3,3,1,0,1,6,9,2,1,6,1,4,9,0,1,12,17,4,9,21,21,0,13,11,21,20,17,6,29,1,9,8,25,36,1,0,33,41,17,36,23,26,33,34,21,30,41,38,27,6,1,36,39,7,21,31,59,54,49,21,39,57,45,60,41,31,9,37,41,21", "code": "\ndef A114795(n):\n    s=\"\"\n    for i in range(n,0,-1):\n        s+=str(i)\n    return int(s)%n \n"}
{"sequence_id": "A115004", "text": "a(n) = Sum_{i=1..n, j=1..n, gcd(i,j)=1} (n+1-i)*(n+1-j).", "sequence": "1,8,31,80,179,332,585,948,1463,2136,3065,4216,5729,7568,9797,12456,15737,19520,24087,29308,35315,42120,50073,58920,69025,80264,92871,106756,122475,139528,158681,179608,202529,227400,254597,283784,315957,350576,387977", "code": "\nfrom math import gcd\ndef a115004(n):\n    r=0\n    for a in range(1, n + 1):\n        for b in range(1, n + 1):\n            if gcd(a, b)==1:\n                r+=(n + 1 - a)*(n + 1 - b)\n    return r\nprint([a115004(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A115004", "text": "a(n) = Sum_{i=1..n, j=1..n, gcd(i,j)=1} (n+1-i)*(n+1-j).", "sequence": "1,8,31,80,179,332,585,948,1463,2136,3065,4216,5729,7568,9797,12456,15737,19520,24087,29308,35315,42120,50073,58920,69025,80264,92871,106756,122475,139528,158681,179608,202529,227400,254597,283784,315957,350576,387977", "code": "\nfrom sympy import totient\ndef A115004(n): return n**2 + sum(totient(i)*(n+1-i)*(2*n+2-i) for i in range(2,n+1)) \n"}
{"sequence_id": "A115005", "text": "a(n) = (A114043(n) - 1)/2.", "sequence": "0,3,14,43,100,209,374,641,1020,1553,2246,3197,4372,5911,7778,10037,12728,16043,19862,24467,29728,35777,42626,50625,59520,69675,80966,93627,107568,123345,140458,159673,180664,203651,228590,255857,285116,317363,352058", "code": "\nfrom sympy import totient\ndef A115005(n): return (n-1)*(2*n-1) + sum(totient(i)*(n-i)*(2*n-i) for i in range(2,n)) \n"}
{"sequence_id": "A115060", "text": "Maximum peak of aliquot sequence starting at n.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,16,13,14,15,16,17,21,19,22,21,22,23,55,25,26,27,28,29,259,31,32,33,34,35,55,37,38,39,50,41,259,43,50,45,46,47,76,49,50,51,52,53,259,55,64,57,58,59,172,61,62,63,64,65,259", "code": "\nfrom sympy import divisor_sigma as sigma\ndef aliquot(n):\n    alst = []; seen = set(); i = n\n    while i and i not in seen: alst.append(i); seen.add(i); i = sigma(i) - i\n    return alst\ndef aupton(terms): return [max(aliquot(n)) for n in range(1, terms+1)]\nprint(aupton(66)) \n"}
{"sequence_id": "A115167", "text": "Odd numbers k such that k-1 and k+1 have the same number of prime divisors with multiplicity.", "sequence": "5,19,29,43,51,55,67,69,77,89,115,151,171,173,187,189,197,233,237,243,245,249,267,271,283,285,291,295,307,317,329,341,343,349,355,403,405,411,427,429,435,437,461,489,491,507,569,571,593,597,603,605,653,665", "code": "\nfrom sympy import primeomega\ndef aupto(limit):\n  prv, nxt, alst = 1, 2, []\n  for n in range(3, limit+1, 2):\n    if prv == nxt: alst.append(n)\n    prv, nxt = nxt, primeomega(n+3)\n  return alst\nprint(aupto(665)) \n"}
{"sequence_id": "A115286", "text": "a(n) = (1/6)*(n^6+3*n^4+12*n^3+8*n^2).", "sequence": "0,4,40,228,960,3200,8904,21560,46848,93420,173800,305404,511680,823368,1279880,1930800,2837504,4074900,5733288,7920340,10763200,14410704,19035720,24837608,32044800,40917500,51750504,64876140,80667328,99540760,121960200", "code": "\nA115286_list, m = [], [120, -300, 272, -96, 8, 0, 0]\nfor _ in range(1001):\n    A115286_list.append(m[-1])\n    for i in range(6):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A115343", "text": "Products of 9 distinct primes.", "sequence": "223092870,281291010,300690390,340510170,358888530,363993630,380570190,397687290,406816410,417086670,434444010,455885430,458948490,481410930,485555070,497668710,504894390,512942430,514083570,531990690,538047510,547777230,551861310", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import nextprime, sieve\nfrom itertools import combinations\nn = 190\nm = 9699690*nextprime(n-1)\nA115343 = []\nfor x in combinations(sieve.primerange(1,n),9):\n....y = reduce(mul,(d for d in x))\n....if y < m:\n........A115343.append(y)\nA115343 = sorted(A115343) \n"}
{"sequence_id": "A115510", "text": "a(1)=1. a(n) is smallest positive integer not occurring earlier in the sequence such that a(n) and a(n-1) have at least one 1-bit in the same position when they are written in binary.", "sequence": "1,3,2,6,4,5,7,9,8,10,11,12,13,14,15,17,16,18,19,20,21,22,23,24,25,26,27,28,29,30,31,33,32,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,65,64,66,67,68,69,70,71,72", "code": "\nA115510_list, l1, s, b = [1], 1, 2, set()\nfor _ in range(10**6):\n    i = s\n    while True:\n        if not i in b and i & l1:\n            A115510_list.append(i)\n            l1 = i\n            b.add(i)\n            while s in b:\n                b.remove(s)\n                s += 1\n            break\n        i += 1 \n"}
{"sequence_id": "A115561", "text": "a(n) = lpf((n/lpf(n))/lpf(n/lpf(n))), where lpf=A020639, least prime factor.", "sequence": "1,1,1,1,1,1,1,2,1,1,1,3,1,1,1,2,1,3,1,5,1,1,1,2,1,1,3,7,1,5,1,2,1,1,1,3,1,1,1,2,1,7,1,11,5,1,1,2,1,5,1,13,1,3,1,2,1,1,1,3,1,1,7,2,1,11,1,17,1,7,1,2,1,1,5,19,1,13,1,2,3,1,1,3,1,1,1,2,1,3,1,23,1,1,1,2,1,7,11,5,1", "code": "\nfrom sympy import divisors, primefactors\ndef a032752(n): return 1 if n==1 else divisors(n)[-2]\ndef a020639(n): return 1 if n==1 else primefactors(n)[0]\ndef a(n): return a020639(a032752(a032752(n)))\nprint([a(n) for n in range(1, 102)]) \n"}
{"sequence_id": "A115607", "text": "Sum of odd divisors of n times (-1)^(n+1).", "sequence": "1,-1,4,-1,6,-4,8,-1,13,-6,12,-4,14,-8,24,-1,18,-13,20,-6,32,-12,24,-4,31,-14,40,-8,30,-24,32,-1,48,-18,48,-13,38,-20,56,-6,42,-32,44,-12,78,-24,48,-4,57,-31,72,-14,54,-40,72,-8,80,-30,60,-24,62,-32,104,-1,84,-48,68,-18,96,-48,72,-13,74,-38,124", "code": "\nfrom sympy import divisors\ndef a(n): return 0 if n<1 else -(-1)**n * sum([d%2*d for d in divisors(n)]) \n"}
{"sequence_id": "A115920", "text": "Numbers k such that the digits of sigma(k) are a permutation of those of k, in base 10.", "sequence": "1,69,258,270,276,609,639,2391,2556,2931,3409,3678,3679,4291,5092,6937,8251,10231,12087,12931,15480,16387,20850,22644,22893,24369,26145,26442,27846,28764,29880,29958,30823,31812,32658,34207,34758", "code": "\nfrom sympy import divisor_sigma\nA115920_list = [n for n in range(1,10**4) if sorted(str(divisor_sigma(n))) == sorted(str(n))] \n"}
{"sequence_id": "A115921", "text": "Numbers k such that the decimal digits of phi(k) are a permutation of those of k.", "sequence": "1,21,63,291,502,2518,2817,2991,4435,5229,5367,5637,6102,6174,6543,6822,7236,7422,8022,8541,8982,17631,18231,18261,20301,20518,20617,21058,22471,22851,25196,25918,27615,29817,34816,35683,43218,44305", "code": "\nfrom sympy import totient\nA115921_list = [n for n in range(1,10**4) if sorted(str(totient(n))) == sorted(str(n))] \n"}
{"sequence_id": "A115927", "text": "a(n) is the number of k such that k and n*k, taken together, are pandigital.", "sequence": "0,48,6,8,12,0,1,16,3,0,0,1,1,6,3,1,19,6,4,12,0,3,3,4,3,9,2,1,8,2,0,16,1,3,14,0,3,7,3,4,0,3,1,13,4,1,6,0,1,12,0,2,28,1,4,6,1,3,6,3,0,28,1,1,10,1,1,4,5,7,0,3,3,11,0,2,8,1,1,46,0,0,5,3,1,7,5,6,8,3,0,13,2,3", "code": "\nfrom itertools import permutations\nl = {}\nfor d in permutations('0123456789', 10):\n....if d[0] != '0':\n........for i in range(9):\n............if d[i+1] != '0':\n................q, r = divmod(int(''.join(d[:i+1])),int(''.join(d[i+1:])))\n................if not r:\n....................if q in l:\n........................l[q] += 1\n....................else:\n........................l[q] = 1\nA115927_list = [0]*max(l)\nfor d in l:\n....A115927_list[d-1] = l[d] \n"}
{"sequence_id": "A115933", "text": "Numbers k such that k^3 contains a pandigital substring.", "sequence": "2326,3909,5196,5402,7061,7616,8402,8496,8499,9048,13565,15194,15298,15841,19304,19429,20516,21669,23260,23572,23875,23936,24299,24772,24952,25182,25281,26139,26499,26602,26818,26832,27287,27433,27757", "code": "\ndef haspan(s): return any(len(set(s[i:i+10]))==10 for i in range(len(s)-9))\nprint([m for m in range(30000) if haspan(str(m**3))]) \n"}
{"sequence_id": "A115934", "text": "Numbers k such that k^4 contains a pandigital substring.", "sequence": "767,1839,1975,2358,2813,3089,3495,3824,4052,5596,5877,6292,6311,6386,6633,6666,6839,6886,7142,7670,8007,8241,9396,9796,10817,10839,11076,11644,14675,15069,15198,15923,16611,16615,16894,17179,17269,17751", "code": "\ndef haspan(s): return any(len(set(s[i:i+10]))==10 for i in range(len(s)-9))\nprint([m for m in range(20000) if haspan(str(m**4))]) \n"}
{"sequence_id": "A115935", "text": "Numbers k such that 2^k contains a pandigital substring.", "sequence": "105,136,137,237,268,275,336,397,409,418,423,426,456,457,486,530,540,541,585,620,674,675,693,727,787,791,792,809,831,848,853,864,881,936,939,945,946,955,967,974,983,1001,1011,1020,1022,1024,1029,1050,1064", "code": "\ndef haspan(s): return any(len(set(s[i:i+10]))==10 for i in range(len(s)-9))\nprint([m for m in range(1065) if haspan(str(2**m))]) \n"}
{"sequence_id": "A115936", "text": "Numbers k such that k! contains a pandigital substring.", "sequence": "53,67,78,105,106,114,156,160,161,164,192,205,215,220,222,225,236,243,251,257,268,278,279,282,287,306,320,338,343,345,353,367,377,386,395,398,408,409,420,423,434,443,444,448,451,455,458,459,463,467,468,469", "code": "\nfrom math import factorial\ndef haspan(s): return any(len(set(s[i:i+10]))==10 for i in range(len(s)-9))\nprint([m for m in range(500) if haspan(str(factorial(m)))]) \n"}
{"sequence_id": "A115937", "text": "Numbers k such that the k-th Fibonacci number contains a pandigital substring.", "sequence": "130,190,309,348,374,381,382,387,394,431,447,482,496,513,516,522,540,543,562,573,590,600,603,667,672,738,761,768,827,843,849,856,873,888,907,912,923,937,958,963,982,990,993,1009,1021,1027,1054,1087,1090", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef fib(n): return n if n < 2 else fib(n-1) + fib(n-2)\ndef haspan(s): return any(len(set(s[i:i+10]))==10 for i in range(len(s)-9))\nprint([m for m in range(1111) if haspan(str(fib(m)))]) \n"}
{"sequence_id": "A115938", "text": "Numbers k such that k^k contains a pandigital substring.", "sequence": "125,132,147,162,163,167,169,176,186,188,192,197,209,215,218,222,223,237,247,258,259,269,270,273,274,275,277,284,288,294,297,301,302,309,316,332,359,361,362,377,382,390,393,396,398,401,404,407,413,419,425", "code": "\ndef haspan(s): return any(len(set(s[i:i+10]))==10 for i in range(len(s)-9))\nprint([m for m in range(500) if haspan(str(m**m))]) \n"}
{"sequence_id": "A115941", "text": "a(n) is the least prime whose representation contains a palindromic substring of length n.", "sequence": "2,11,101,11113,10301,1011013,1003001,100110013,100030001,10000000019,10000500001,1000011000017,1000008000001,100000440000011,100000323000001,10000001100000011,10000000500000001,1000000011000000019,1000000008000000001,100000000660000000013", "code": "\nfrom sympy import isprime\nfrom itertools import product\ndef pals_to_test(n, odd=True):\n  if n <= 2: yield [2, 11][n-1]\n  if odd: ruled_out = \"024568\" \n  else: ruled_out = \"0\"\n  midrange = [[\"\"], [str(i) for i in range(10)]]\n  for p in product(\"0123456789\", repeat=n//2):\n    left = \"\".join(p)\n    if len(left):\n      if left[0] in ruled_out: continue\n    for middle in midrange[n%2]:\n        out = left+middle+left[::-1]\n        if odd: yield out\n        else:\n          for last in \"1379\": yield out+last\ndef a(n):\n  palsgen = pals_to_test(n, n%2 == 1)\n  while True:\n    strpal = next(palsgen)\n    pal = int(strpal)\n    if isprime(pal): return pal\nprint([a(n) for n in range(1, 18)]) \n"}
{"sequence_id": "A116017", "text": "Numbers n such that n + sigma(n) is a repdigit.", "sequence": "1,2,3,4,5,9,34,141,198,277,297,375,499,1420,2651,2777,3554,4999,19050,28660,29128,49999,131061,506311,3844863,3852517,4761903,4999999,22222218,37560831,133878933,506767303,872011214,1381799253,1427435733,2777777777,3018915632,3555555554", "code": "\nfrom sympy import divisors\nA116017 = [n for n in range(1,10**5) if len(set(str(n+sum(divisors(n))))) == 1] \n"}
{"sequence_id": "A116018", "text": "Numbers n such that n + phi(n) is a repdigit.", "sequence": "1,2,3,4,5,6,17,21,63,167,201,389,603,1667,3795,3889,4465,5926,50394,166667,510042,2000001,3888889,5185194,5798663,5925926,6000003,32050435,200000001,335447667,365110755,444766346,600000003,1558138862,1565408702,1587424430", "code": "\nfrom sympy import totient\nA116018 = [n for n in range(1,10**6) if len(set(str(n+totient(n)))) == 1] \n"}
{"sequence_id": "A116054", "text": "n times pi(n) is a palindrome, where pi(n) = PrimePi(n) = A000720(n).", "sequence": "1,2,3,4,11,28,33,37,44,53,132,138,279,378,458,474,482,504,674,1628,1696,2002,2332,3117,4183,5518,6341,6623,7094,19261,25971,28402,28831,33827,39119,51387,65621,85997,87843,174944,178926,212212,258357", "code": "\nfrom sympy import nextprime\nn, k, m, A116054_list = 0, 1, 2, []\nwhile len(A116054_list) < 100:\n    for i in range(k,m):\n        s = str(i*n)\n        if s == s[::-1]:\n            A116054_list.append(i)\n    n += 1\n    k, m = m, nextprime(m) \n"}
{"sequence_id": "A116283", "text": "k times k+7 gives the concatenation of two numbers m and m-1.", "sequence": "7,30,64,42753,57241,75423,425072,574922,979528,4301393,5698601,7028666,4925000747,5074999247,7748266574,8511881484,8814851184,7059602159672,7106167933828,7439286611621,7485852385777", "code": "\ndef ok(n):\n    s = str(n*(n+7)); h = (len(s)+1)//2; return int(s[:h])-1 == int(s[h:])\nprint(list(filter(ok, range(2, 10**6)))) \n"}
{"sequence_id": "A116369", "text": "Day of the week corresponding to Jan 01 of a given year (n=0 for the year 2000).", "sequence": "7,2,3,4,5,7,1,2,3,5,6,7,1,3,4,5,6,1,2,3,4,6,7,1,2,4,5,6,7,2,3,4,5,7,1,2,3,5,6,7,1,3,4,5,6,1,2,3,4,6,7,1,2,4,5,6,7,2,3,4,5,7,1,2,3,5,6,7,1,3,4,5,6,1,2,3,4,6,7,1,2,4,5,6,7,2,3,4,5,7,1,2,3,5,6,7,1,3,4,5,6,7,1,2,3", "code": "\nfrom datetime import date\ndef a(n): return (date(2000+n, 1, 1).isoweekday())%7 + 1\nprint([a(n) for n in range(105)]) \n"}
{"sequence_id": "A116469", "text": "Square array read by antidiagonals: T(m,n) = number of spanning trees in an m X n grid.", "sequence": "1,1,1,1,4,1,1,15,15,1,1,56,192,56,1,1,209,2415,2415,209,1,1,780,30305,100352,30305,780,1,1,2911,380160,4140081,4140081,380160,2911,1,1,10864,4768673,170537640,557568000,170537640,4768673,10864,1", "code": "\n\nfrom graphillion import GraphSet\nimport graphillion.tutorial as tl\ndef A116469(n, k):\n    if n == 1 or k == 1: return 1\n    universe = tl.grid(n - 1, k - 1)\n    GraphSet.set_universe(universe)\n    spanning_trees = GraphSet.trees(is_spanning=True)\n    return spanning_trees.len()\nprint([A116469(j + 1, i - j + 1) for i in range(9) for j in range(i + 1)])  \n"}
{"sequence_id": "A116581", "text": "Primes of the form k^3-k-1.", "sequence": "5,23,59,503,719,1319,2729,3359,4079,5813,9239,12143,13799,24359,29759,42839,46619,54833,68879,91079,110543,166319,195053,205319,215939,262079,328439,342929,357839,438899,531359,635969,941093,1124759,1259603,1367519,1442783", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n  k, alst = 2, []\n  while len(alst) < terms:\n    if isprime(k**3-k-1): alst.append(k**3-k-1)\n    k += 1\n  return alst\nprint(aupton(37)) \n"}
{"sequence_id": "A116607", "text": "Sum of the divisors of n which are not divisible by 9.", "sequence": "1,3,4,7,6,12,8,15,4,18,12,28,14,24,24,31,18,12,20,42,32,36,24,60,31,42,4,56,30,72,32,63,48,54,48,28,38,60,56,90,42,96,44,84,24,72,48,124,57,93,72,98,54,12,72,120,80,90,60,168,62,96,32,127,84,144,68,126,96", "code": "\nfrom sympy import divisors\nprint([sum(i for i in divisors(n) if i%9) for n in range(1, 101)]) \n"}
{"sequence_id": "A116898", "text": "Numbers k such that k! is turned into a prime number by changing its trailing 0's into 1's.", "sequence": "2,10,34,499,1746", "code": "\nfrom sympy import isprime\nfrom math import factorial\ndef ok(n):\n  s, zeros = str(factorial(n)), 0\n  while s[-1] == '0': s = s[:-1]; zeros += 1\n  return isprime(int(s + '1'*zeros))\nprint([m for m in range(500) if ok(m)]) \n"}
{"sequence_id": "A116946", "text": "Closest semiprime to n-th semiprime S that is different from S (break ties by taking the smaller semiprime).", "sequence": "6,4,10,9,15,14,22,21,26,25,34,33,34,39,38,49,51,49,57,58,57,65,62,65,77,74,85,86,85,86,93,94,93,94,111,115,118,119,118,122,121,122,133,134,133,142,141,142,146,145,158,159,158,159,169,166,178,177,185", "code": "\nfrom sympy import factorint\ndef semiprime(n): return sum(e for e in factorint(n).values()) == 2\ndef nextsemiprime(n):\n  nxt = n + 1\n  while not semiprime(nxt): nxt += 1\n  return nxt\ndef aupton(terms):\n  prv, cur, nxt, alst = 0, 4, 6, []\n  while len(alst) < terms:\n    alst.append(prv if 2*cur - prv <= nxt else nxt)\n    prv, cur, nxt = cur, nxt, nextsemiprime(nxt)\n  return alst\nprint(aupton(59)) \n"}
{"sequence_id": "A116988", "text": "Sum of digits of (10^n)!.", "sequence": "1,27,648,10539,149346,1938780,23903442,284222502,3292100235,37420852599", "code": "\nfrom math import factorial\ndef A116988(n):\n    return sum(int(d) for d in str(factorial(10**n))) \n"}
{"sequence_id": "A117057", "text": "Palindromes which are divisible by the product of their digits.", "sequence": "1,2,3,4,5,6,7,8,9,11,111,212,1111,2112,4224,11111,11711,13131,21112,21312,31113,42624,111111,211112,234432,1111111,1113111,2111112,2112112,2114112,2118112,11111111,21111112,21122112,61111116,111111111", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom gmpy2 import t_mod, mpz\nA117057 = sorted([mpz(n) for n in (str(x)+str(x)[::-1] for x in range(1,10**6))\n        if not (n.count('0') or t_mod(mpz(n), reduce(mul,(mpz(d) for d in n))))]+\n        [mpz(n) for n in (str(x)+str(x)[-2::-1] for x in range(10**6))\n        if not (n.count('0') or t_mod(mpz(n), reduce(mul,(mpz(d) for d in n))))])\n\n"}
{"sequence_id": "A117128", "text": "Recam\u00e1n transform of primes (another version): a(0)=1; for n>0, a(n) = a(n-1) - prime(n) if that number is positive and not already in the sequence, otherwise a(n) = a(n-1) + prime(n).", "sequence": "1,3,6,11,4,15,2,19,38,61,32,63,26,67,24,71,18,77,16,83,12,85,164,81,170,73,174,277,384,275,162,35,166,29,168,317,468,311,148,315,142,321,140,331,138,335,136,347,124,351,122,355,116,357,106,363,100,369,98,375,94,377", "code": "\nfrom sympy import primerange, prime\ndef aupton(terms):\n  alst = [1]\n  for n, pn in enumerate(primerange(1, prime(terms)+1), start=1):\n    x = alst[-1] - pn\n    alst += [x if x > 0 and x not in alst else alst[-1] + pn]\n  return alst\nprint(aupton(61)) \n"}
{"sequence_id": "A117228", "text": "Palindromes which are divisible by the product and by the sum of their digits.", "sequence": "1,2,3,4,5,6,7,8,9,111,2112,4224,13131,21112,21312,31113,42624,211112,234432,1113111,2111112,2114112,2118112,21122112,61111116,111111111,211121112,211242112,211262112,213141312,2111111112,2112332112,2114114112,2131221312", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom gmpy2 import t_mod, mpz\nA117228 = sorted([mpz(n) for n in (str(x)+str(x)[::-1] for x in range(1,10**8))\n..........if not (n.count('0') or t_mod(mpz(n), sum((mpz(d) for d in n)))\n..........or t_mod(mpz(n), reduce(mul,(mpz(d) for d in n))))]+\n..........[mpz(n) for n in (str(x)+str(x)[-2::-1] for x in range(10**8))\n..........if not (n.count('0') or t_mod(mpz(n), sum((mpz(d) for d in n)))\n..........or t_mod(mpz(n), reduce(mul,(mpz(d) for d in n))))])\n\n"}
{"sequence_id": "A117345", "text": "Indices n such that the 3 X 3 matrix with components (row by row) prime(n+k), 0 <= k <= 8, has zero determinant.", "sequence": "330,561,1009,1123,1826,2632,3966,4056,6031,6363,6505,7112,8154,9348,9613,11199,12123,12301,12944,14980,15216,15236,16355,16358,17628,18287,18737,19378,20228,21113,25155,26733,28203,29007,31620,32181,33245", "code": "\nfrom sympy import nextprime, Matrix\nk,A117345_list, plist = 1,[], [2, 3, 5, 7, 11, 13, 17, 19, 23]\nwhile k < 10**7:\n    if Matrix(plist).reshape(3,3).det() == 0:\n        A117345_list.append(k)\n    k,plist = k+1,plist[1:]+[nextprime(plist[-1])] \n"}
{"sequence_id": "A117431", "text": "String n is at position n in decimal digits of golden ratio (phi).", "sequence": "1,20,62,9956", "code": "\nfrom sympy import S\ndef aupto(nn):\n  phistr = str(S.GoldenRatio.n(nn+len(str(nn))+1)).replace(\".\", \"\")[:-1]\n  for n in range(1, nn+1):\n    nstr = str(n)\n    if phistr[n-1:n-1+len(nstr)] == nstr: print(n, end=\", \")\naupto(10**5) \n"}
{"sequence_id": "A117432", "text": "Let n be an integer consisting of m digits. Then n is a Phithy number if the n-th m-tuple in the decimal digits of golden ratio phi is string n.", "sequence": "1,20,63,104,7499430,9228401", "code": "\nfrom sympy import S\ndef aupto(nn):\n  mm = len(str(nn))\n  phistr = str(S.GoldenRatio.n(nn*mm+1)).replace(\".\", \"\")[:-1]\n  for n in range(1, nn+1):\n    nstr = str(n)\n    m = len(nstr)\n    if phistr[(n-1)*m:n*m] == nstr: print(n, end=\", \")\naupto(10**5) \n"}
{"sequence_id": "A117501", "text": "Triangle generated from an array of generalized Fibonacci-like terms.", "sequence": "1,1,1,1,2,2,1,3,3,3,1,4,4,5,5,1,5,5,7,8,8,1,6,6,9,11,13,13,1,7,7,11,14,18,21,21,1,8,8,13,17,23,29,34,34,1,9,9,15,20,28,37,47,55,55,1,10,10,17,23,33,45,60,76,89,89,1,11,11,19,26,38,53,73,97,123,144,144", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n, k):\n    return 1 if k==1 else n if k==2 else a(n, k - 1) + a(n, k - 2)\nfor n in range(1, 21): print([a(n - k + 1, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A117619", "text": "a(n) = n^2 + 7.", "sequence": "7,8,11,16,23,32,43,56,71,88,107,128,151,176,203,232,263,296,331,368,407,448,491,536,583,632,683,736,791,848,907,968,1031,1096,1163,1232,1303,1376,1451,1528,1607,1688,1771,1856,1943,2032,2123,2216,2311,2408", "code": " def a(n): return n**2 + 7 \n"}
{"sequence_id": "A117633", "text": "Number of self-avoiding walks of n steps on a Manhattan square lattice.", "sequence": "1,2,4,8,14,26,48,88,154,278,500,900,1576,2806,4996,8894,15564,27538,48726,86212,150792,265730,468342,825462,1442866,2535802,4457332,7835308,13687192,24008300,42118956,73895808,129012260,225966856,395842772,693470658,1210093142,2117089488,3704400974", "code": "\ndef add(L, x):\n    M=[y for y in L]; M.append(x)\n    return M\nplus=lambda L, M:[x+y for x, y in zip(L, M)]\nmo=[[1, 0], [0, 1], [-1, 0], [0, -1]]\ndef a(n, P=[[0, 0]]):\n    if n==0: return 1\n    X=P[-1]; x=X[0]%2; y=X[1]%2; mo=[[(-1)**y, 0], [0, (-1)**x]]\n    mv1 = [plus(P[-1], x) for x in mo]\n    mv2=[x for x in mv1 if x not in P]\n    if n==1: return len(mv2)\n    else: return sum(a(n-1, add(P, x)) for x in mv2)\n[a(n) for n in range(21)]\n\n"}
{"sequence_id": "A117715", "text": "Triangle T(n,m) containing the value of the Fibonacci polynomial F(n,x) at x=m.", "sequence": "0,1,1,0,1,2,1,2,5,10,0,3,12,33,72,1,5,29,109,305,701,0,8,70,360,1292,3640,8658,1,13,169,1189,5473,18901,53353,129949,0,21,408,3927,23184,98145,328776,927843,2298912,1,34,985,12970,98209,509626,2026009,6624850,18674305,46866034", "code": "\nfrom sympy import fibonacci\ndef T(n, m): return 0 if n==0 else fibonacci(n, m)\nfor n in range(21): print([T(n, m) for m in range(n + 1)]) \n"}
{"sequence_id": "A117769", "text": "Lucas numbers for which the product of the digits is a Fibonacci number.", "sequence": "1,3,11,18,2207,39603,64079,103682,439204,710647,1860498,3010349,4870847,12752043,20633239,54018521,87403803,370248451,599074578,969323029,1568397607,2537720636,4106118243,10749957122,17393796001", "code": "\nfrom operator import mul\nfrom functools import reduce\nA117769_list, a, b = [], 2, 1\nfor i in range(10**3):\n    if reduce(mul,(int(d) for d in str(b))) in (0,1,2,3,5,8,21,144):\n        A117769_list.append(b)\n    a, b = b, a+b \n"}
{"sequence_id": "A117770", "text": "Fibonacci numbers for which the product of the digits is also a Fibonacci number.", "sequence": "0,1,2,3,5,8,13,21,610,10946,75025,832040,2178309,5702887,14930352,39088169,102334155,165580141,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,32951280099", "code": "\nfrom operator import mul\nfrom functools import reduce\nA117770_list, a, b = [0], 1, 1\nfor i in range(10**3):\n    if reduce(mul,(int(d) for d in str(b))) in (0,1,2,3,5,8,21,144):\n        A117770_list.append(b)\n    a, b = b, a+b \n"}
{"sequence_id": "A117790", "text": "Lucas numbers for which the sum of the digits is a prime.", "sequence": "1,3,7,11,29,47,76,199,322,2207,24476,1149851,141422324,969323029,2537720636,10749957122,73681302247,119218851371,312119004989,505019158607,2139295485799,3461452808002,5600748293801,100501350283429", "code": "\nfrom sympy import isprime\nA117790_list, a, b = [1], 1, 3\nfor _ in range(10**6):\n    if isprime(sum(int(d) for d in str(b))):\n        A117790_list.append(b)\n    a, b = b, a+b \n"}
{"sequence_id": "A117966", "text": "Balanced ternary enumeration (based on balanced ternary representation) of integers; write n in ternary and then replace 2's with (-1)'s.", "sequence": "0,1,-1,3,4,2,-3,-2,-4,9,10,8,12,13,11,6,7,5,-9,-8,-10,-6,-5,-7,-12,-11,-13,27,28,26,30,31,29,24,25,23,36,37,35,39,40,38,33,34,32,18,19,17,21,22,20,15,16,14,-27,-26,-28,-24,-23,-25,-30,-29,-31,-18,-17,-19,-15,-14,-16,-21,-20,-22,-36", "code": "\ndef a(n):\n    if n==0: return 0\n    if n%3==0: return 3*a(n//3)\n    elif n%3==1: return 3*a((n - 1)//3) + 1\n    else: return 3*a((n - 2)//3) - 1\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A117967", "text": "Positive part of inverse of A117966; write n in balanced ternary and then replace (-1)'s with 2's.", "sequence": "0,1,5,3,4,17,15,16,11,9,10,14,12,13,53,51,52,47,45,46,50,48,49,35,33,34,29,27,28,32,30,31,44,42,43,38,36,37,41,39,40,161,159,160,155,153,154,158,156,157,143,141,142,137,135,136,140,138,139,152,150,151,146", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a004488(n): return int(\"\".join([str((3 - i)%3) for i in digits(n, 3)[1:]]), 3)\ndef a117968(n):\n    if n==1: return 2\n    if n%3==0: return 3*a117968(n/3)\n    elif n%3==1: return 3*a117968((n - 1)/3) + 2\n    else: return 3*a117968((n + 1)/3) + 1\ndef a(n): return 0 if n==0 else a004488(a117968(n)) \n"}
{"sequence_id": "A117968", "text": "Negative part of inverse of A117966; write -n in balanced ternary and then replace (-1)'s with 2's.", "sequence": "2,7,6,8,22,21,23,19,18,20,25,24,26,67,66,68,64,63,65,70,69,71,58,57,59,55,54,56,61,60,62,76,75,77,73,72,74,79,78,80,202,201,203,199,198,200,205,204,206,193,192,194,190,189,191,196,195,197,211,210,212,208,207", "code": "\ndef a(n):\n    if n==1: return 2\n    if n%3==0: return 3*a(n//3)\n    elif n%3==1: return 3*a((n - 1)//3) + 2\n    else: return 3*a((n + 1)//3) + 1\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A118015", "text": "a(n) = floor(n^2/5).", "sequence": "0,0,0,1,3,5,7,9,12,16,20,24,28,33,39,45,51,57,64,72,80,88,96,105,115,125,135,145,156,168,180,192,204,217,231,245,259,273,288,304,320,336,352,369,387,405,423,441,460,480,500,520,540,561,583,605,627,649,672", "code": " [int(n**2/5) for n in range(60)] \n"}
{"sequence_id": "A118101", "text": "Decimal representation of n-th iteration of the Rule 94 elementary cellular automaton starting with a single ON cell.", "sequence": "1,7,27,119,427,1879,6827,30039,109227,480599,1747627,7689559,27962027,123032919,447392427,1968526679,7158278827,31496426839,114532461227,503942829399,1832519379627,8063085270359,29320310074027,129009364325719,469124961184427", "code": " print([(11*4**n + 10)//6 - 2*0**abs(n-1) if n%2 else (5*4**n + 1)//3 - 0**n for n in range(50)]) \n"}
{"sequence_id": "A118108", "text": "Decimal representation of n-th iteration of the Rule 54 elementary cellular automaton starting with a single black cell.", "sequence": "1,7,17,119,273,1911,4369,30583,69905,489335,1118481,7829367,17895697,125269879,286331153,2004318071,4581298449,32069089143,73300775185,513105426295,1172812402961,8209686820727,18764998447377,131354989131639,300239975158033", "code": " print([(16+12*(n%2))*4**n//15 for n in range(30)]) \n"}
{"sequence_id": "A118109", "text": "Binary representation of n-th iteration of the Rule 54 elementary cellular automaton starting with a single black cell.", "sequence": "1,111,10001,1110111,100010001,11101110111,1000100010001,111011101110111,10001000100010001,1110111011101110111,100010001000100010001,11101110111011101110111,1000100010001000100010001,111011101110111011101110111,10001000100010001000100010001,1110111011101110111011101110111", "code": " print([(10000+1100*(n%2))*100**n//9999 for n in range(30)]) \n"}
{"sequence_id": "A118171", "text": "Decimal representation of n-th iteration of the Rule 158 elementary cellular automaton starting with a single black cell.", "sequence": "1,7,29,115,477,1843,7645,29491,122333,471859,1957341,7549747,31317469,120795955,501079517,1932735283,8017272285,30923764531,128276356573,494780232499,2052421705181,7916483719987,32838747282909,126663739519795,525419956526557", "code": "\nan_158 = []\nfor n in range(0,40,2):\n    an_158.append(28*4**n//15)\n    an_158.append(27*4**(n+1)//15)\nprint(an_158) \n"}
{"sequence_id": "A118224", "text": "Smallest number having at least 2*n divisors.", "sequence": "2,6,12,24,48,60,120,120,180,240,360,360,720,720,720,840,1260,1260,1680,1680,2520,2520,2520,2520,5040,5040,5040,5040,5040,5040,7560,7560,10080,10080,10080,10080,15120,15120,15120,15120,20160,20160,25200,25200,25200", "code": "\nfrom sympy import divisors\ndef a(n):\n  m = 4*n - 2\n  while len(divisors(m)) < 2*n: m += 1\n  return m\nprint([a(n) for n in range(1, 46)]) \n"}
{"sequence_id": "A118363", "text": "Factorial base Niven (or Harshad) numbers: numbers that are divisible by the sum of their factorial base digits.", "sequence": "1,2,4,6,8,9,12,16,18,20,24,26,27,30,35,36,40,48,52,54,56,60,70,72,75,80,90,91,96,105,108,112,117,120,122,123,126,132,135,140,144,148,150,152,156,161,168,175,180,186,192,204,208,210,222,224,240,244,245,246", "code": "\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef ok(n): return n%sum(map(int, list(str(a007623(n)))))==0\nprint([n for n in range(1, 251) if ok(n)]) \n"}
{"sequence_id": "A118548", "text": "Squares which are divisible by the product of their digits.", "sequence": "1,4,9,36,144,1296,2916,11664,41616,82944,186624,1218816,2214144,11614464,21123216,21233664,22127616,27123264,49787136,122943744,146313216,171714816,222129216,429981696,812934144,1316818944", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom gmpy2 import t_mod, mpz\nA118548 = [n for n in (x**2 for x in range(1,10**6)) if not (str(n).count('0') or t_mod(n, reduce(mul,(mpz(d) for d in str(n)))))]\n\n"}
{"sequence_id": "A118575", "text": "Dividuus numbers: numbers which are divisible by (1) the sum of their digits,(2) the product of their digits,(3) the digital root and (4) the multiplicative digital root.", "sequence": "1,2,3,4,5,6,7,8,9,12,24,111,112,132,135,144,216,312,315,432,612,624,1116,1212,1344,1416,2112,2232,3168,3312,4112,4224,6624,8112,11112,11115,11133,11172,11232,11313,11331,11424,11664,12132,12216,12312,12432", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom gmpy2 import t_mod, mpz\ndef A031347(n):\n    while n > 9:\n        n = reduce(mul, (int(d) for d in str(n)))\n    return n\nA118575 = [n for n in range(1, 10**9) if A031347(n) and not\n           (str(n).count('0') or t_mod(n, (1+t_mod((n-1), 9))) or\n           t_mod(n, A031347(n)) or t_mod(n,sum((mpz(d) for d in str(n))))\n           or t_mod(n, reduce(mul,(mpz(d) for d in str(n)))))]\n\n"}
{"sequence_id": "A118600", "text": "Palindromes in base 9 (written in base 9).", "sequence": "0,1,2,3,4,5,6,7,8,11,22,33,44,55,66,77,88,101,111,121,131,141,151,161,171,181,202,212,222,232,242,252,262,272,282,303,313,323,333,343,353,363,373,383,404,414,424,434,444,454,464,474,484,505,515,525,535,545", "code": "\nfrom gmpy2 import digits\ndef palgenbase(l,b): \n....if l > 0:\n........yield 0\n........for x in range(1,l+1):\n............for y in range(b**(x-1),b**x):\n................s = digits(y,b)\n................yield int(s+s[-2::-1])\n............for y in range(b**(x-1),b**x):\n................s = digits(y,b)\n................yield int(s+s[::-1])\nA118600_list = list(palgenbase(3,9)) \n"}
{"sequence_id": "A118868", "text": "Smallest number that can be represented in n different ways in n different bases utilizing only decimal characters (0 to 9).", "sequence": "1,2,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,22,24,26,28,30,33,36,39,42,45,48,56,57,60,69,72,81,84,93,105,105,144,144,177,216,225,225,288,441,513,513,729,1224,1800,2304,2304,4761,4761,11664,11664,11664", "code": "\ndef a(n, startat=1):\n  k = startat\n  while True:\n    base, reps = 2, {(1,)} \n    while len(reps) < n:\n      digs, kb, all09 = [], k, True\n      while kb >= base:\n        kb, d = divmod(kb, base)\n        digs.append(d)\n        if d > 9: all09 = False; break \n      digs += [kb]\n      if all09 and kb <= 9: reps.add(tuple(digs))\n      if len(digs) == 1: break\n      base += 1\n    if len(reps) >= n: return k\n    k += 1\nan = 1\nfor n in range(1, 62):\n  an = a(n, startat=an)\n  print(an, end=\", \") \n"}
{"sequence_id": "A118909", "text": "a(1) = 4; a(n) is least semiprime > a(n-1)^2.", "sequence": "4,21,445,198026,39214296677,1537761063871773242347,2364709089560047865452947255794201194068433,5591849078247910476736920566826713466552016538943524658263883555662554776622687075541", "code": "\nfrom itertools import accumulate\nfrom sympy.ntheory.factor_ import primeomega\ndef nextsemiprime(n):\n  while primeomega(n + 1) != 2: n += 1\n  return n + 1\ndef f(anm1, _): return nextsemiprime(anm1**2)\nprint(list(accumulate([4]*6, f))) \n"}
{"sequence_id": "A119031", "text": "Add and Reverse: a(n) = the reversal of (a(n-1)+d), case a(1)=1 and d=4.", "sequence": "1,5,9,31,53,75,97,101,501,505,905,909,319,323,723,727,137,141,541,545,945,949,359,363,763,767,177,181,581,585,985,989,399,304,803,708,217,122,621,526,35,93,79,38,24,82,68,27,13,71,57,16,2,6,1,5,9,31,53,75,97", "code": "\na = 1\ncounter = 0\nwhile counter < 60:\n    print(a)\n    counter += 1\n    a = int(str(a + 4)[::-1])  \n"}
{"sequence_id": "A119156", "text": "Triangular numbers composed of digits {2,3,8}.", "sequence": "3,28,3828,828828,388333828828,223832333328828,332828222833288828828,28388332838238232223328828", "code": "\nklimit = 10**6\nA000217 = (k*(k+1)//2 for k in range(klimit)) \nprint([m for m in A000217 if set(str(m)) <= set(\"238\")]) \n"}
{"sequence_id": "A119289", "text": "Prime numbers p such that there is no prime between 10*p and 10*p+9 inclusive.", "sequence": "53,89,107,113,167,179,251,317,347,389,397,419,431,443,457,461,521,599,641,643,653,709,727,761,773,797,839,863,887,907,911,977,991,1087,1091,1103,1153,1187,1213,1217,1229,1231,1259,1277,1283,1301,1307,1319,1327", "code": "\nfrom sympy import isprime, primerange\ndef ok(p): s = str(p); return all(not isprime(int(s+d)) for d in \"1379\")\nprint(list(filter(ok, primerange(1, 1328)))) \n"}
{"sequence_id": "A119304", "text": "Triangle read by rows: T(n,k) = binomial(4n-k,n-k), 0 <= k <= n.", "sequence": "1,4,1,28,7,1,220,55,10,1,1820,455,91,13,1,15504,3876,816,136,16,1,134596,33649,7315,1330,190,19,1,1184040,296010,65780,12650,2024,253,22,1,10518300,2629575,593775,118755,20475,2925,325,25,1,94143280,23535820", "code": "\nfrom sympy import binomial\ni=0\nfor n in range(12):\n    for k in range(n+1):\n        print(str(i)+\" \"+str(binomial(4*n-k,n-k)))\n        i+=1 \n"}
{"sequence_id": "A119309", "text": "a(n) = binomial(2*n,n) * 6^n.", "sequence": "1,12,216,4320,90720,1959552,43110144,960740352,21616657920,489977579520,11171488813056,255928652808192,5886359014588416,135839054182809600,3143703825373593600,72933928748667371520", "code": "\nimport math\nf=math.factorial\ndef C(n,r): return f(n)//f(r)//f(n-r)\ndef A119309(n): return C(2*n,n)*(6**n) \n"}
{"sequence_id": "A119461", "text": "Zero-free numbers with digit sum equal to 7.", "sequence": "7,16,25,34,43,52,61,115,124,133,142,151,214,223,232,241,313,322,331,412,421,511,1114,1123,1132,1141,1213,1222,1231,1312,1321,1411,2113,2122,2131,2212,2221,2311,3112,3121,3211,4111,11113,11122,11131,11212,11221,11311,12112,12121,12211,13111,21112,21121,21211,22111,31111,111112,111121,111211,112111,121111,211111,1111111", "code": "\ndef ok(n): s = str(n); return '0' not in s and sum(map(int, s)) == 7\nprint(list(filter(ok, range(1111112)))) \n"}
{"sequence_id": "A119491", "text": "Sum of the first n n-digit primes.", "sequence": "2,24,311,4062,50153,600240,7000409,80000960,900000729,10000000754,110000001257,1200000001154,13000000002051,140000000003318,1500000000003685,16000000000004454,170000000000009723,1800000000000004696,19000000000000007691,200000000000000006828", "code": "\nfrom sympy import nextprime\ndef a(n):\n  s = p = nextprime(10**(n-1))\n  for n in range(n-1): p = nextprime(p); s += p\n  return s\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A119598", "text": "Numbers that are repunits in four or more bases.", "sequence": "1,31,8191", "code": "\ndef isrep(n, b):\n  while n >= b:\n    n, r = divmod(n, b)\n    if r != 1: return False\n  return n == 1\ndef agen():\n  yield 1\n  n = 2\n  while True:\n    reps = 2 \n    for b in range(2, n-1):\n      if isrep(n, b): reps += 1\n      if reps == 4: yield n; break\n    n += 1\nfor m in agen(): print(m) \n"}
{"sequence_id": "A119650", "text": "Numbers k such that (2^67 - 1) * 10^k + (2^257 - 1) is prime.", "sequence": "42,62,146,210,936,1490,7932", "code": "\nfrom sympy import isprime\ndef afind(limit, startk=0):\n    c1, c2, pow10 = 2**67-1, 2**257-1, 10**startk\n    for k in range(startk, limit+1):\n        if isprime(c1*pow10 + c2): print(k, end=\", \")\n        pow10 *= 10\nafind(1500) \n"}
{"sequence_id": "A119678", "text": "a(n) is the least k such that 4^k mod k = n.", "sequence": "3,14,137243,5,6821,10,57,124,35,18,2791496231,244,51,505,199534799,20,30271293169,49,45,236,399531841,42,533,25,39,50,352957,36,995,98,33,112,47503,55,42345881,44,2981,289,805,78,1019971289,25498,2121,212", "code": "\ndef a(n):\n  k = 1\n  while 4**k % k != n: k += 1\n  return k\nprint([a(n) for n in range(1, 11)]) \n"}
{"sequence_id": "A119719", "text": "Continued fraction expansion of the value (mod 1) where ?(x)-x attains its global maximum.", "sequence": "0,1,3,1,4", "code": " from itertools import product\ndef qx(arr): \n..qx = 0\n..for i in range(1,len(arr)): \n....qx += (-1)**(i+1) / 2**sum(arr[:i+1])\n..ratio = arr[-1]\n..for i in range(len(arr)-2,-1,-1): \n....ratio = arr[i] + 1/ratio\n..return 2*qx - ratio, ratio \narr = [0,1]\nfor k in range(1,19):\n..cap = [0,()] \n..for tag in product(range(1,21), repeat=4):\n....res = qx(arr + list(tag)) \n....if res[0] > cap[0]: cap = [res[0], tag, res[1]]\n..print(cap) \n..arr.append(cap[1][0]) \n\n"}
{"sequence_id": "A119733", "text": "Offsets of the terms of the nodes of the reverse Collatz function.", "sequence": "0,1,2,5,4,7,10,19,8,11,14,23,20,29,38,65,16,19,22,31,28,37,46,73,40,49,58,85,76,103,130,211,32,35,38,47,44,53,62,89,56,65,74,101,92,119,146,227,80,89,98,125,116,143,170,251,152,179,206,287,260,341,422,665,64,67", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n): return 0 if n==0 else 2*a((n - 1)//2) + 3**bin((n - 1)//2).count('1') if n%2 else 2*a(n//2)\nprint([a(n) for n in range(131)]) \n"}
{"sequence_id": "A119735", "text": "Numbers n such that every digit occurs at least once in n^3.", "sequence": "2326,2535,2795,3123,3506,3909,4602,4782,5027,5048,5196,5362,5394,5402,5437,6215,6221,6517,6687,6789,6802,6993,7061,7202,7219,7616,7638,8124,8244,8248,8288,8384,8402,8443,8496,8499,8817,9006,9048,9142,9374,9476", "code": "\nA119735_list, m = [], [6, -6, 1, 0]\nfor n in range(1,10**6+1):\n....for i in range(3):\n........m[i+1] += m[i]\n....if len(set(str(m[-1]))) == 10:\n........A119735_list.append(n) \n"}
{"sequence_id": "A119861", "text": "Number of distinct prime factors of the odd Catalan numbers A038003(n).", "sequence": "0,1,3,6,11,20,36,64,117,209,381,699,1291,2387,4445,8317,15645,29494,55855,106021,201778,384941,735909,1409683,2705277,5200202", "code": "\nfrom sympy import factorint\nA119861_list, c, s = [0], {}, 3\nfor n in range(2,2**19):\n....for p,e in factorint(4*n-2).items():\n........if p in c:\n............c[p] += e\n........else:\n............c[p] = e\n....for p,e in factorint(n+1).items():\n........if c[p] == e:\n............del c[p]\n........else:\n............c[p] -= e\n....if n == s:\n........A119861_list.append(len(c))\n........s = 2*s+1 \n"}
{"sequence_id": "A119908", "text": "Largest squared prime factor of the odd Catalan number (A038003(n)) or 1, if it is squarefree.", "sequence": "1,1,3,1,11,13,13,29,43,61,79,107,181,251,359,509,719,1021,1447,2039,2887,4093,5717,8179,11579", "code": "\nfrom sympy import factorint\nA119908_list, c, s = [], {}, 3\nfor n in range(2,2**16):\n....for p,e in factorint(4*n-2).items():\n........if p in c:\n............c[p] += e\n........else:\n............c[p] = e\n....for p,e in factorint(n+1).items():\n........if c[p] == e:\n............del c[p]\n........else:\n............c[p] -= e\n....if n == s:\n........c2 = [p for p,e in c.items() if e >= 2]\n........A119908_list.append(1 if c2 == [] else max(c2))\n........s = 2*s+1 \n"}
{"sequence_id": "A120004", "text": "Number of distinct numbers as substrings of n in decimal representation.", "sequence": "1,1,1,1,1,1,1,1,1,1,3,2,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,2,4,4,5,5,5,5", "code": "\ndef A120004(n):\n    s = str(n)\n    m = len(s)\n    return len(set(int(s[i:j]) for i in range(m) for j in range(i+1,m+1))) \n"}
{"sequence_id": "A120303", "text": "Largest prime factor of Catalan number A000108(n).", "sequence": "2,5,7,7,11,13,13,17,19,19,23,23,23,29,31,31,31,37,37,41,43,43,47,47,47,53,53,53,59,61,61,61,67,67,71,73,73,73,79,79,83,83,83,89,89,89,89,97,97,101,103,103,107,109,109,113,113,113,113,113,113,113,127,127,131,131", "code": "\nfrom gmpy2 import is_prime\nA120303 = [2]\nfor n in range(3, 801):\n    for k in range(2*n-1, n, -2):\n        if is_prime(k, n):\n            A120303.append(k)\n            break\nfor n in range(len(A120303)):\n    print(n+2, A120303[n])  \n"}
{"sequence_id": "A120389", "text": "a(n) is such that the a(n)-th composite number is (n-th prime)^2.", "sequence": "1,4,15,33,90,129,227,288,429,694,798,1149,1417,1565,1879,2399,2993,3201,3879,4365,4623,5429,6002,6920,8245,8948,9314,10067,10457,11245,14251,15184,16627,17130,19711,20253,21919,23653,24845,26687,28604", "code": "\nfrom sympy import prime, compositepi\nA120389_list = [compositepi(prime(i)**2) for i in range(1,101)] \n"}
{"sequence_id": "A120623", "text": "Numbers n such that the n-th Catalan number C(2n, n)/(n + 1) is divisible by n/3 but not divisible by n.", "sequence": "3,12,18,84,99,120,198,216,273,342,432,522,540,792,828,945,975,984,990,1035,1071,1323,1377,1512,1548,1575,1710,1755,1863,2052,2106,2226,2385,2442,2790,2928,3009,3015,3132,3198,3483,3672,3807,3915,3996,4212,4428", "code": "\nA120623_list, b = [], 1\nfor n in range(1, 10**5):\n    if b % n and not (3*b) % n:\n        A120623_list.append(n)\n    b = b*(4*n+2)//(n+2) \n"}
{"sequence_id": "A120624", "text": "Numbers n such that the n-th Catalan number C(2n,n)/(n+1) is divisible by 2n.", "sequence": "6,28,42,45,66,77,91,110,126,140,153,156,170,187,190,204,209,210,220,228,231,238,266,276,299,308,312,315,322,325,330,345,378,414,420,429,435,440,442,450,459,460,468,476,483,493,496,510,527,551,558,561,570", "code": "\nfrom __future__ import division\nA120624_list, b = [], 1\nfor n in range(1,10**5):\n    if not b % (2*n):\n        A120624_list.append(n)\n    b = b*(4*n+2)//(n+2) \n"}
{"sequence_id": "A120701", "text": "Number of unit circles which fit touching a circle of radius n-1, i.e., with their centers on a circle of radius n.", "sequence": "2,6,9,12,15,18,21,25,28,31,34,37,40,43,47,50,53,56,59,62,65,69,72,75,78,81,84,87,91,94,97,100,103,106,109,113,116,119,122,125,128,131,135,138,141,144,147,150,153,157,160,163,166,169,172,175,179,182,185,188", "code": "\nfrom mpmath import mp, pi, asin\nmp.dps=100\ndef a(n): return int(floor(pi/asin(1./n)))\nprint([a(n) for n in range(1, 61)]) \n"}
{"sequence_id": "A120941", "text": "a(n)=k-n where prime(k) is the smallest prime greater than prime(n)*prime(n+1).", "sequence": "3,5,9,18,30,42,60,77,113,145,179,229,262,293,353,430,487,545,622,671,737,826,916,1052,1184,1249,1310,1373,1443,1654,1894,2026,2131,2298,2481,2602,2782,2943,3107,3298,3436,3651,3866,3975,4083,4346,4808,5144", "code": "\nfrom sympy import prime, primepi\nprint([primepi(prime(n)*prime(n + 1)) - n + 1 for n in range(1, 100)]) \n"}
{"sequence_id": "A120944", "text": "Composite squarefree numbers.", "sequence": "6,10,14,15,21,22,26,30,33,34,35,38,39,42,46,51,55,57,58,62,65,66,69,70,74,77,78,82,85,86,87,91,93,94,95,102,105,106,110,111,114,115,118,119,122,123,129,130,133,134,138,141,142,143,145,146,154,155,158,159,161", "code": "\nfrom sympy import factorint\ndef ok(n): f = factorint(n); return len(f) > 1 and all(f[p] < 2 for p in f)\nprint(list(filter(ok, range(1, 162)))) \n"}
{"sequence_id": "A120981", "text": "Triangle read by rows: T(n,k) is the number of ternary trees with n edges and having k vertices of outdegree 1 (n >= 0, k >= 0).", "sequence": "1,0,3,3,0,9,1,27,0,27,18,12,162,0,81,15,270,90,810,0,243,138,270,2430,540,3645,0,729,189,2898,2835,17010,2835,15309,0,2187,1218,4536,34776,22680,102060,13608,61236,0,6561,2280,32886,61236,312984,153090,551124", "code": "\nfrom sympy import binomial\ndef T(n, k): return binomial(n + 1, k)*sum([3**(2*k - n + 3*j)*binomial(n + 1 - k, j)*binomial(j, n - k - 2*j) for j in range(n + 2 - k)])//(n + 1)\nfor n in range(21): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A120986", "text": "Triangle read by rows: T(n,k) is the number of ternary trees with n edges and having k middle edges (n >= 0, k >= 0).", "sequence": "1,2,1,5,6,1,14,28,12,1,42,120,90,20,1,132,495,550,220,30,1,429,2002,3003,1820,455,42,1,1430,8008,15288,12740,4900,840,56,1,4862,31824,74256,79968,42840,11424,1428,72,1,16796,125970,348840,465120,325584", "code": "\nfrom sympy import binomial\ndef T(n, k): return binomial(n + 1, k)*binomial(2*(n + 1), n - k)//(n + 1)\nfor n in range(21): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A121207", "text": "Triangle read by rows. The definition is by diagonals. The r-th diagonal from the right, for r >= 0, is given by b(0) = b(1) = 1; b(n+1) = Sum_{k=0..n} binomial(n+2,k+r)*a(k).", "sequence": "1,1,1,1,1,2,1,1,3,5,1,1,4,9,15,1,1,5,14,31,52,1,1,6,20,54,121,203,1,1,7,27,85,233,523,877,1,1,8,35,125,400,1101,2469,4140,1,1,9,44,175,635,2046,5625,12611,21147,1,1,10,54,236,952,3488,11226,30846,69161,115975", "code": "\n\nfrom itertools import accumulate\ndef Gould_diag(diag, size):\n    if size < 1: return []\n    if size == 1: return [1]\n    L, accu = [1,1], [1]*diag\n    for _ in range(size-2):\n        accu = list(accumulate([accu[-1]] + accu))\n        L.append(accu[-1])\n    return L \n"}
{"sequence_id": "A121263", "text": "Descending dungeons: see Comments lines for definition.", "sequence": "10,11,13,16,20,25,31,38,46,55,65,87,135,239,463,943,1967,4143,8751,18479,38959,103471,306223,942127,2932783,9153583,28562479,89028655,277145647,861652015,2675637295,10173443119,41132125231,168836688943,695134284847", "code": "\ndef a(n):\n  a_of_n = [((10 + int(i))) for i in range(n)]\n  while len(a_of_n) != 1:\n    exponent = 0\n    a_of_n [-2] = list(str(a_of_n [-2]))\n    for i in range(len(a_of_n [-2])):\n      a_of_n [-2] [-(i+1)] = int(a_of_n [-2] [-(i+1)])\n      a_of_n [-2] [-(i+1)] *= ((a_of_n [-1]) ** exponent)\n      exponent += 1\n    a_of_n [-2] = sum(a_of_n [-2])\n    a_of_n = a_of_n [:((len(a_of_n))-1)]\n  return (a_of_n [0])\n\n"}
{"sequence_id": "A121307", "text": "Products of three terms from A003627.", "sequence": "8,20,44,50,68,92,110,116,125,164,170,188,212,230,236,242,275,284,290,332,356,374,404,410,425,428,452,470,506,524,530,548,575,578,590,596,605,638,668,692,710,716,725,764,782,788,830,890,902,908,932,935,956", "code": "\nfrom sympy import primerange\nfrom itertools import combinations_with_replacement as mc\ndef aupto(limit):\n    terms = [p for p in primerange(2, limit//4+1) if p%3 == 2]\n    return sorted(set(a*b*c for a, b, c in mc(terms, 3) if a*b*c <= limit))\nprint(aupto(957)) \n"}
{"sequence_id": "A121322", "text": "Numbers m such that m^5 contains every digit at least once.", "sequence": "309,418,462,474,575,635,662,699,702,713,737,746,747,748,765,771,795,838,875,876,892,897,943,945,976,1009,1012,1018,1033,1072,1104,1107,1137,1143,1149,1167,1174,1183,1187,1195,1203,1233,1248,1249,1269,1292", "code": "\ndef ok(n): return len(set(str(n**5))) == 10\nprint([m for m in range(1293) if ok(m)]) \n"}
{"sequence_id": "A121354", "text": "a(n) = (3*n-1)*a(n-1) - a(n-2).", "sequence": "0,1,5,39,424,5897,99825,1990603,45684044,1185794541,34342357645,1097769650099,38387595395820,1457630855391061,59724477475637681,2626419378072666903,123381986291939706760,6166472895218912671097,326699681460310431861381,18289015688882165271566239", "code": "\nfrom sympy import cacheit\n@cacheit\ndef A121354(n):\n    if n <= 1:\n        return n\n    else:\n        return (3*n-1)*A121354(n-1)-A121354(n-2)\nprint([A121354(n) for n in range(20)]) \n"}
{"sequence_id": "A121539", "text": "Numbers whose binary expansion ends in an even number of 1's.", "sequence": "0,2,3,4,6,8,10,11,12,14,15,16,18,19,20,22,24,26,27,28,30,32,34,35,36,38,40,42,43,44,46,47,48,50,51,52,54,56,58,59,60,62,63,64,66,67,68,70,72,74,75,76,78,79,80,82,83,84,86,88,90,91,92,94,96,98,99,100", "code": "\ndef ok(n): b = bin(n)[2:]; return (len(b) - len(b.rstrip('1')))%2 == 0\nprint(list(filter(ok, range(101)))) \n"}
{"sequence_id": "A121608", "text": "Primes that can be written as concatenation of two composite numbers in decimal representation.", "sequence": "89,109,149,229,269,349,359,389,409,421,433,439,449,457,463,487,491,499,509,569,659,677,691,709,769,809,821,827,829,839,857,859,863,877,881,887,919,929,977,991,1009,1021,1033,1039,1049,1051,1063,1069,1087,1091", "code": "\nfrom sympy import isprime\ndef comp(s): i=int(s); return s[0]!='0' and i > 1 and not isprime(i)\ndef ok(n):\n  s = str(n)\n  for i in range(1, len(s)):\n    if comp(s[:i]) and comp(s[i:]) and isprime(int(s)): return True\nprint([m for m in range(1092) if ok(m)]) \n"}
{"sequence_id": "A121669", "text": "Numbers with sum of digits = 19, divisible by 19 and containing the string \"19\".", "sequence": "17119,19171,19342,19513,20197,21907,33193,34219,41914,51319,61921,101935,102619,112195,119035,119206,121942,125191,171019,171190,190171,190342,190513,191026,191710,192052,192223,193420,194104,195130,195301,197011,201970,204193", "code": "\ndef ok(n): s = str(n); return n%19==0 and '19' in s and sum(map(int, s))==19\nprint(list(filter(ok, range(205000)))) \n"}
{"sequence_id": "A121787", "text": "\"Crossing walks hitting the center\" on the square lattice (see Jensen web site for further information).", "sequence": "1,10,7056,462755440,2593165016903538,1243982213040307428318660,51166088445891978924432033203830714,180349587397776823066172713933745722978533730900", "code": "\n\nfrom graphillion import GraphSet\nimport graphillion.tutorial as tl\ndef A121787(n):\n    if n == 0: return 1\n    universe = tl.grid(2 * n, 2 * n)\n    GraphSet.set_universe(universe)\n    start, goal = 1, (2 * n + 1) * (2 * n + 1)\n    paths = GraphSet.paths(start, goal).including((start + goal) // 2)\n    return paths.len()\nprint([A121787(n) for n in range(7)])  \n"}
{"sequence_id": "A121879", "text": "a(n) = Fibonacci(n-1)*a(n-1) - a(n-2), with a(1)=0, a(2)=1.", "sequence": "0,1,1,1,2,9,70,901,18851,640033,35182964,3130643763,450777518908,105028031261801,39595117008180069,24152916346958580289,23838888839331110565174,38070681323495436614002589,98374616701023368879472124802,411304234356297381789636339794573", "code": "\nfrom sympy import fibonacci, cacheit\n@cacheit\ndef A121879(n):\n    if n <= 2: return n-1\n    else: return fibonacci(n-1)*A121879(n-1)-A121879(n-2)\nprint([A121879(n) for n in range(1, 25)]) \n"}
{"sequence_id": "A121943", "text": "Numbers k such that the central binomial coefficient C(2k,k) is divisible by k^2.", "sequence": "1,924,1287,2002,2145,3366,3640,3740,4199,6006,6118,6552,7480,7920,8580,8855,10465,10920,11385,11592,12285,12325,12441,12540,12597,12920,13224,13398,13566,15080,15834,18270,18354,18837,18972,19227,23562,23870,25641,25740", "code": "\nfrom __future__ import division\nA121943_list, b = [], 2\nfor n in range(1,10**5):\n    if not b % (n**2):\n        A121943_list.append(n)\n    b = b*(4*n+2)//(n+1) \n"}
{"sequence_id": "A122004", "text": "Primes p that divide A123373(p-1).", "sequence": "2,3,5,23,29", "code": "\nfrom sympy import nextprime, prime\np, A122004_list = 2, []\nwhile p < 10**6:\n    if 0 == sum(pow(prime(i),prime(j),p) for i in range(1,p) for j in range(1,p)) % p:\n        A122004_list.append(p)\n    p = nextprime(p) \n"}
{"sequence_id": "A122045", "text": "Euler (or secant) numbers E(n).", "sequence": "1,0,-1,0,5,0,-61,0,1385,0,-50521,0,2702765,0,-199360981,0,19391512145,0,-2404879675441,0,370371188237525,0,-69348874393137901,0,15514534163557086905,0,-4087072509293123892361,0,1252259641403629865468285,0,-441543893249023104553682821", "code": "\nfrom sympy import bernoulli as B\ndef a(n): return int(2**n*2**(n + 1)*(B(n + 1, 3/4) - B(n + 1, 1/4))/(n + 1))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A122111", "text": "Self-inverse permutation of the positive integers induced by partition enumeration in A112798 and partition conjugation.", "sequence": "1,2,4,3,8,6,16,5,9,12,32,10,64,24,18,7,128,15,256,20,36,48,512,14,27,96,25,40,1024,30,2048,11,72,192,54,21,4096,384,144,28,8192,60,16384,80,50,768,32768,22,81,45,288,160,65536,35,108,56,576,1536,131072,42", "code": "\nfrom sympy import factorint, prevprime, prime, primefactors\nfrom operator import mul\ndef a001222(n): return 0 if n==1 else a001222(n/primefactors(n)[0]) + 1\ndef a064989(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==2 else prevprime(i)**f[i] for i in f])\ndef a105560(n): return 1 if n==1 else prime(a001222(n))\ndef a(n): return 1 if n==1 else a105560(n)*a(a064989(n))\n[a(n) for n in range(1, 101)] \n"}
{"sequence_id": "A122612", "text": "Sums of cubes of primes.", "sequence": "8,16,24,27,32,35,40,43,48,51,54,56,59,62,64,67,70,72,75,78,80,81,83,86,88,89,91,94,96,97,99,102,104,105,107,108,110,112,113,115,116,118,120,121,123,124,125,126,128,129,131,132,133,134,135,136,137,139,140,141", "code": "\nfrom sympy import primerange, integer_nthroot as iroot\ndef ok(n):\n    cands = [p**3 for p in primerange(2, iroot(n, 3)[0]+1) if p**3 <= n]\n    return n in cands or any(ok(n-c) for c in cands)\nprint(list(filter(ok, range(142)))) \n"}
{"sequence_id": "A122729", "text": "Primes that are the sum of 5 positive cubes.", "sequence": "5,19,31,59,71,83,89,97,101,109,127,131,157,181,199,227,233,241,251,257,269,281,283,293,307,331,347,349,353,373,379,409,421,431,433,443,449,461,487,499,503,523,541,557,563,569,587,593,599,601,619,631,647,661", "code": "\nfrom sympy import isprime\nfrom collections import Counter\nfrom itertools import combinations_with_replacement as combs_w_rep\ndef aupto(lim):\n  s = filter(lambda x: x<=lim, (i**3 for i in range(1, int(lim**(1/3))+2)))\n  s2 = filter(lambda x: x<=lim, (sum(c) for c in combs_w_rep(s, 5)))\n  s2counts = Counter(s2)\n  return sorted(filter(isprime, s2counts))\nprint(aupto(661)) \n"}
{"sequence_id": "A122771", "text": "Triangle read by rows, 0 <= k <= n: T(n,k) is the coefficient of x^k in the characteristic polynomial of I + A^(-1), where A is the n-step Fibonacci companion matrix and I is the identity matrix.", "sequence": "1,2,-1,-1,-1,1,2,-2,2,-1,-1,-2,4,-3,1,2,-3,6,-7,4,-1,-1,-3,9,-13,11,-5,1,2,-4,12,-22,24,-16,6,-1,-1,-4,16,-34,46,-40,22,-7,1,2,-5,20,-50,80,-86,62,-29,8,-1,-1,-5,25,-70,130,-166,148,-91,37,-9,1,2,-6,30,-95,200,-296,314,-239,128,-46,10,-1,-1,-6,36,-125", "code": "\nfrom sympy import Matrix,eye\ndef A122771_row(n):\n  if n==0: return [1]\n  A=Matrix(n,n,lambda i,j:int(i==n-1 or i==j-1))\n  p=(eye(n)+A.inv()).charpoly()\n  return [(-1)**n*c for c in p.all_coeffs()[::-1]] \n"}
{"sequence_id": "A122840", "text": "a(n) is the number of 0's at the end of n when n is written in base 10.", "sequence": "0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0", "code": "\ndef a(n): return len(str(n)) - len(str(int(str(n)[::-1]))) \n"}
{"sequence_id": "A122953", "text": "a(n) = number of distinct positive integers represented in binary which are substrings of binary expansion of n.", "sequence": "1,2,2,3,3,4,3,4,4,4,5,6,6,6,4,5,5,5,6,6,5,7,7,8,8,8,8,9,9,8,5,6,6,6,7,6,7,8,8,8,8,6,8,10,9,10,9,10,10,10,10,11,10,10,11,12,12,12,12,12,12,10,6,7,7,7,8,7,8,9,9,8,7,9,10,10,11,11,10,10,10,10,11,9,7,11,11,13,13,12", "code": "\ndef a(n):\n  b = bin(n)[2:]\n  m = len(b)\n  return len(set(int(b[i:j]) for i in range(m) for j in range(i+1,m+1))-{0})\nprint([a(n) for n in range(1, 91)]) \n"}
{"sequence_id": "A123070", "text": "Hofstadter Flip-G-sequence.", "sequence": "0,1,1,2,3,3,4,5,5,6,6,7,8,8,9,10,10,11,11,12,13,13,14,14,15,16,16,17,18,18,19,19,20,21,21,22,23,23,24,24,25,26,26,27,27,28,29,29,30,31,31,32,32,33,34,34,35,35,36,37,37,38,39,39,40,40,41,42,42,43,44", "code": " \ndef gflip_iter():\n    yield 0\n    yield 1\n    \n    queue = [(1, 1)]\n    n = 2\n    while True:\n        parent, state = queue.pop(0)\n        yield parent\n        if state == 0:\n            \n            queue.append((n, 1))\n            queue.append((n, 0))\n        elif state == 1:\n            \n            queue.append((n, 0))\n        n += 1\ni = gflip_iter()\nfor n in range(0, 10001):\n    print(\"%d %d\" % (n, next(i)))\n\n"}
{"sequence_id": "A123094", "text": "Sum of first n 12th powers.", "sequence": "0,1,4097,535538,17312754,261453379,2438235715,16279522916,84998999652,367428536133,1367428536133,4505856912854,13421957361110,36720042483591,93413954858887,223160292749512,504635269460168,1087257506689929,2244088888116105,4457403807182266", "code": "\nA123094_list, m = [0], [479001600, -2634508800, 6187104000, -8083152000, 6411968640, -3162075840, 953029440, -165528000, 14676024, -519156, 4094, -1, 0 , 0]\nfor _ in range(10**2):\n    for i in range(13):\n        m[i+1]+= m[i]\n    A123094_list.append(m[-1]) \n"}
{"sequence_id": "A123095", "text": "Sum of first n 11th powers.", "sequence": "0,1,2049,179196,4373500,53201625,415998681,2393325424,10983260016,42364319625,142364319625,427675990236,1170684360924,2962844754961,7012409924625,15662165784000,33254351828416,67526248136049", "code": "\nA123095_list, m = [0], [39916800, -199584000, 419126400, -479001600, 322494480, -129230640, 29607600, -3498000, 171006, -2046, 1, 0 , 0]\nfor _ in range(10**2):\n....for i in range(12):\n........m[i+1]+= m[i]\n....A123095_list.append(m[-1]) \n"}
{"sequence_id": "A123098", "text": "Multiplicative encoding of triangle formed by reading Pascal's triangle mod 2 (A047999).", "sequence": "2,6,10,210,22,858,1870,9699690,46,4002,7130,160660290,20746,1008940218,2569288370,32589158477190044730,118,21594,39530,3595293030,94754,17808161514,44788794490,7074421030108255253430,263258,141108130806,281595235990,296987147493893719182390,944729501606", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import prime\ndef A123098(n):\n    return reduce(mul,(1 if ~(n-1) & k else prime(k+1) for k in range(n))) \n"}
{"sequence_id": "A123134", "text": "a(n) = prime(n)*(prime(n+1) + 1).", "sequence": "8,18,40,84,154,234,340,456,690,928,1178,1554,1804,2064,2538,3180,3658,4148,4824,5254,5840,6636,7470,8722,9894,10504,11124,11770,12426,14464,16764,18078,19180,20850,22648,23858,25748,27384,29058,31140,32578", "code": "\nfrom sympy import prime\ndef a(n): return prime(n) * (prime(n + 1) + 1) \n"}
{"sequence_id": "A123275", "text": "Square array A(n,m) = largest divisor of m which is coprime to n, read by upwards antidiagonals.", "sequence": "1,1,2,1,1,3,1,2,3,4,1,1,1,1,5,1,2,3,4,5,6,1,1,3,1,5,3,7,1,2,1,4,5,2,7,8,1,1,3,1,1,3,7,1,9,1,2,3,4,5,6,7,8,9,10,1,1,1,1,5,1,7,1,1,5,11,1,2,3,4,5,6,7,8,9,10,11,12,1,1,3,1,5,3,1,1,9,5,11,3,13,1,2,1,4,1,2,7,8,1,2", "code": "\n\nfrom sympy.ntheory import divisors\nfrom math import gcd\ndef T(n,m):\n    return [i for i in divisors(m) if gcd(i,n)==1][-1]\nfor i in range(1, 16):\n    print([T(i+1-j, j) for j in range(1, i+1)]) \n"}
{"sequence_id": "A123329", "text": "Let M be the matrix defined in A111490. Sequence gives M(2,1)-M(1,2), M(2,1)+M(3,1)+M(3,2)-M(1,2)-M(1,3)-M(2,3), etc.", "sequence": "0,1,3,8,14,26,39,59,83,115,148,197,247,307,376,460,545,651,758,887,1027,1181,1336,1527,1724,1937,2163,2417,2672,2969,3267,3596,3940,4304,4681,5113,5546,6001,6473,6995,7518,8095,8673,9291,9942,10619,11297,12051", "code": "\ndef M(n,k): return 1 + (k-1)%n\ndef a(n):\n  return sum(M(i,j)-M(j,i) for i in range(2, n+3) for j in range(1, i))\nprint([a(n) for n in range(48)]) \n"}
{"sequence_id": "A123346", "text": "Mirror image of the Bell triangle A011971, which is also called the Pierce triangle or Aitken's array.", "sequence": "1,2,1,5,3,2,15,10,7,5,52,37,27,20,15,203,151,114,87,67,52,877,674,523,409,322,255,203,4140,3263,2589,2066,1657,1335,1080,877,21147,17007,13744,11155,9089,7432,6097,5017,4140,115975,94828,77821,64077,52922,43833,36401,30304,25287,21147", "code": "\n\nfrom itertools import accumulate\nA123346_list = blist = [1]\nfor _ in range(2*10**2):\n....b = blist[-1]\n....blist = list(accumulate([b]+blist))\n....A123346_list += reversed(blist)\n\n"}
{"sequence_id": "A123753", "text": "Partial sums of A070941.", "sequence": "1,3,6,9,13,17,21,25,30,35,40,45,50,55,60,65,71,77,83,89,95,101,107,113,119,125,131,137,143,149,155,161,168,175,182,189,196,203,210,217,224,231,238,245,252,259,266,273,280,287,294,301,308,315,322,329,336,343", "code": "\ndef A123753(n):\n    s, i, z = n+1, n, 1\n    while 0 <= i: s += i; i -= z; z += z\n    return s\nprint([A123753(n) for n in range(0, 58)]) \n"}
{"sequence_id": "A123886", "text": "a(0)=1. a(n) = a(n-1) + (number of earlier terms {i.e., terms a(0) through a(n-1)} that divide n).", "sequence": "1,2,4,5,8,10,12,13,17,18,22,23,27,29,31,33,37,39,42,43,48,49,52,54,59,61,64,66,69,71,75,77,81,83,86,88,93,95,97,100,106,107,110,112,116,118,121,122,128,130,134,136,141,142,147,149,153,154,157,159,165,167,170", "code": "\na, an, la = [1], 1, 1\nprint(la-1,an)\nwhile la < 63:\n....dc, di = 0, 0\n....while di < la:\n........if la%a[di] == 0:\n............dc = dc+1\n........di = di+1\n....an = an+dc\n....la, a = la+1, a+[an]\n....print(la-1,an) \n"}
{"sequence_id": "A123911", "text": "Numbers n such that if you multiply the primes that are indexed by the digits of n and add the sum of digits of n you get n.", "sequence": "2295,29625,869227,24612989369,989252839643,475851922819895,2766613478748294,383649822198994888719136,753247689895391625667326763984815199", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom itertools import combinations_with_replacement\nA123911_list, plist = [], [0]+[prime(i) for i in range(1,10)]\nfor l in range(1,30):\n    L = 10**(l-1)\n    H = 10*L\n    for c in combinations_with_replacement(range(1,10),l):\n        n = reduce(mul,[plist[i] for i in c]) + sum(c)\n        if L <= n < H and sorted(int(d) for d in str(n)) == list(c):\n            A123911_list.append(n) \n"}
{"sequence_id": "A124010", "text": "Triangle in which first row is 0, n-th row (n>1) lists the (ordered) prime signature of n, that is, the exponents of distinct prime factors in factorization of n.", "sequence": "0,1,1,2,1,1,1,1,3,2,1,1,1,2,1,1,1,1,1,1,4,1,1,2,1,2,1,1,1,1,1,1,3,1,2,1,1,3,2,1,1,1,1,1,1,5,1,1,1,1,1,1,2,2,1,1,1,1,1,3,1,1,1,1,1,1,2,1,2,1,1,1,1,4,1,2,1,2,1,1,2,1,1,1,3,1,1,3,1,1,1,1,1,1,2,1,1,1,1,1,2,1,6,1,1,1,1,1,1,2,1,1,1,1,1,1,1,3,2,1", "code": "\nfrom sympy import factorint\ndef a(n):\n    f=factorint(n)\n    return [0] if n==1 else [f[i] for i in f]\nfor n in range(1, 21): print(a(n)) \n"}
{"sequence_id": "A124065", "text": "Numbers k such that 8*k - 1 and 8*k + 1 are twin primes.", "sequence": "9,24,30,39,54,75,129,144,165,186,201,234,261,264,324,336,339,375,390,396,420,441,459,471,516,534,600,621,654,660,690,705,735,795,819,849,870,891,936,945,1011,1029,1125,1155,1179,1215,1221,1251,1284,1395,1419", "code": "\nfrom sympy import isprime\ndef ok(n): return isprime(8*n - 1) and isprime(8*n + 1)\nprint(list(filter(ok, range(1420)))) \n"}
{"sequence_id": "A124199", "text": "Primes of the form k(k+1)/2-2 (i.e., two less than triangular numbers).", "sequence": "13,19,43,53,89,103,151,229,251,349,433,463,593,701,739,859,1033,1223,1429,1483,1709,1889,1951,2143,2699,3001,3079,3319,3739,4003,4093,4463,4751,5563,5669,6553,7019,7873,8513,9043,10009,10151,10729,11173,11779", "code": "\nimport sympy\n[n*(n+1)/2-2 for n in range(10**6) if isprime(n*(n+1)/2-2)] \n"}
{"sequence_id": "A124202", "text": "a(n) = median of the largest prime dividing a random n-digit number.", "sequence": "3,12,53,229,947,3863,15731,63823,258737", "code": "\nfrom sympy import factorint\nfrom statistics import median\ndef a(n):\n  lb, ub = max(2, 10**(n-1)), 10**n\n  return int(round(median([max(factorint(i)) for i in range(lb, ub)])))\nprint([a(n) for n in range(1, 6)]) \n"}
{"sequence_id": "A124292", "text": "Number of free generators of degree n of symmetric polynomials in 4 noncommuting variables.", "sequence": "1,1,2,6,21,78,297,1143,4419,17118,66366,257391,998406,3873015,15024609,58285737,226111986,877174110,3402893997,13201132950,51212274057,198672129783,770725711035,2989941920334,11599136512038,44997518922327,174562710686622", "code": "\ndef a(n, adict={1:1, 2:1, 3:2}):\n    if n in adict:\n        return adict[n]\n    adict[n]=6*a(n-1)-9*a(n-2)+3*a(n-3)\n    return adict[n] \n"}
{"sequence_id": "A124302", "text": "Number of set partitions with at most 3 blocks; number of Dyck paths of height at most 4; dimension of space of symmetric polynomials in 3 noncommuting variables.", "sequence": "1,1,2,5,14,41,122,365,1094,3281,9842,29525,88574,265721,797162,2391485,7174454,21523361,64570082,193710245,581130734,1743392201,5230176602,15690529805,47071589414,141214768241,423644304722,1270932914165,3812798742494,11438396227481", "code": "\ndef a(n, adict={0:1, 1:1, 2:2}):\n    if n in adict:\n        return adict[n]\n    adict[n]=4*a(n-1) - 3*a(n-2)\n    return adict[n] \n"}
{"sequence_id": "A124315", "text": "a(n) = Sum_{ d divides n } tau(gcd(d,n/d)), where tau = sigma_0 = A000005.", "sequence": "1,2,2,4,2,4,2,6,4,4,2,8,2,4,4,9,2,8,2,8,4,4,2,12,4,4,6,8,2,8,2,12,4,4,4,16,2,4,4,12,2,8,2,8,8,4,2,18,4,8,4,8,2,12,4,12,4,4,2,16,2,4,8,16,4,8,2,8,4,8,2,24,2,4,8,8,4,8,2,18,9,4,2,16,4,4,4,12,2,16,4,8,4,4,4,24,2,8", "code": "\nfrom sympy import divisors, divisor_count, gcd\ndef a(n): return sum([divisor_count(gcd(d, n/d)) for d in divisors(n)]) \n"}
{"sequence_id": "A124316", "text": "a(n) = Sum_{ d divides n } sigma(gcd(d,n/d)), where sigma is the sum of divisors function, A000203.", "sequence": "1,2,2,5,2,4,2,8,6,4,2,10,2,4,4,15,2,12,2,10,4,4,2,16,8,4,10,10,2,8,2,22,4,4,4,30,2,4,4,16,2,8,2,10,12,4,2,30,10,16,4,10,2,20,4,16,4,4,2,20,2,4,12,37,4,8,2,10,4,8,2,48,2,4,16,10,4,8,2,30,23,4,2,20,4,4,4,16,2,24", "code": "\nfrom sympy import divisors, divisor_sigma, gcd\ndef a(n): return sum([divisor_sigma(gcd(d, n/d)) for d in divisors(n)]) \n"}
{"sequence_id": "A124625", "text": "Even numbers sandwiched between 1's.", "sequence": "1,0,1,2,1,4,1,6,1,8,1,10,1,12,1,14,1,16,1,18,1,20,1,22,1,24,1,26,1,28,1,30,1,32,1,34,1,36,1,38,1,40,1,42,1,44,1,46,1,48,1,50,1,52,1,54,1,56,1,58,1,60,1,62,1,64,1,66,1,68,1,70,1,72,1,74,1,76,1,78,1,80,1,82,1,84", "code": " print([(n-1)**(n%2) for n in range(0, 86)]) \n"}
{"sequence_id": "A124651", "text": "Least n-digit number m such that m and m^10 are zeroless.", "sequence": "1,12,113,1134,11227,112154,1112236,11111566,111123685,1111133874,11111178192,111111796422,1111111392823,11111112811396,111111112641445,1111111115954155,11111111158315794,111111111132821544,1111111111273944122,11111111111777673838,111111111113343756694", "code": "\nfrom sympy import integer_nthroot\ndef a(n):\n  if n == 1: return 1\n  m, perfect = integer_nthroot(int('286797199' + '1'*(10*n-18)), 10)\n  strm = str(m)\n  \n  while strm.count('0') > 0 or str(m**10).count('0') > 0:\n    if '0' in strm:\n      ind0 = strm.find('0')\n      m = int(strm[:ind0] + '1'*(len(strm)-ind0))\n    elif strm[-1] == '9':\n      m += 2\n    else:\n      m += 1\n    strm = str(m)\n  return m\nfor n in range(1, 15):\n  print(a(n), end=\", \") \n"}
{"sequence_id": "A124661", "text": "Popular primes: primes prime(n) such that prime(n-k)+prime(n+k) >= 2*prime(n) for all k = 1,2,...n-2.", "sequence": "2,3,5,7,13,19,23,31,43,47,73,83,109,113,181,199,283,293,313,317,463,467,503,509,523,619,661,683,691,887,1063,1069,1103,1109,1123,1129,1303,1307,1321,1327,1613,1621,1627,1637,1669,1789", "code": "\ndef a124661(end):\n....a124661_list=[2, 3, 5, 7]\n....primes=[2,3]\n....add=True\n....for num in range(4, end*3):\n........prime=False\n........length=len(primes)\n........for y in range(0,length):\n............if num % primes[y]!=0:\n................prime=True\n............else:\n................prime=False\n................break\n........if (prime):\n............primes.append(num)\n....for x in range(4, int(len(primes)/2)):\n........for k in range(1, x-2):\n............if (primes[x-k]+primes[x+k]>=primes[x]*2):\n................add=True\n............else:\n................add=False\n................break\n........if (add):\n............if (primes[x]>end):\n................break\n............else:\n................a124661_list.append(primes[x])\n....return a124661_list\n\n"}
{"sequence_id": "A124661", "text": "Popular primes: primes prime(n) such that prime(n-k)+prime(n+k) >= 2*prime(n) for all k = 1,2,...n-2.", "sequence": "2,3,5,7,13,19,23,31,43,47,73,83,109,113,181,199,283,293,313,317,463,467,503,509,523,619,661,683,691,887,1063,1069,1103,1109,1123,1129,1303,1307,1321,1327,1613,1621,1627,1637,1669,1789", "code": "\nfrom sympy import prime\nA124661_list = []\nfor n in range(1,10**6):\n    p = prime(n)\n    for k in range(1,n-1):\n        if prime(n-k)+prime(n+k) < 2*p:\n            break\n    else:\n        A124661_list.append(p) \n"}
{"sequence_id": "A124830", "text": "Number of distinct prime factors of A055932(n).", "sequence": "0,1,1,2,1,2,1,2,2,3,1,2,2,2,3,1,2,3,2,2,3,1,2,3,2,3,2,4,2,3,1,3,2,3,2,3,2,4,2,3,3,2,1,3,2,3,4,2,3,3,2,3,4,2,3,3,2,1,4,3,2,3,4,2,3,3,2,4,3,2,3,4,2,3,4,3,2,1,4,3,3,2,5,3,3,4,2,3,3,2,4,3,2,4,3,4,2,3,3,4,3,2,3,1,4", "code": "\nfrom sympy import nextprime, primefactors\ndef a053669(n):\n    p = 2\n    while True:\n        if n%p!=0: return p\n        else: p=nextprime(p)\ndef ok(n): return True if n==1 else a053669(n)>max(primefactors(n))\nprint([len(primefactors(n)) for n in range(1, 10001) if ok(n)]) \n"}
{"sequence_id": "A124859", "text": "Multiplicative with p^e -> primorial(e), p prime and e > 0.", "sequence": "1,2,2,6,2,4,2,30,6,4,2,12,2,4,4,210,2,12,2,12,4,4,2,60,6,4,30,12,2,8,2,2310,4,4,4,36,2,4,4,60,2,8,2,12,12,4,2,420,6,12,4,12,2,60,4,60,4,4,2,24,2,4,12,30030,4,8,2,12,4,8,2,180,2,4,12,12,4,8,2,420,210,4,2,24,4,4", "code": "\nfrom sympy.ntheory.factor_ import core\nfrom sympy import factorint, primorial, primefactors\nfrom operator import mul\ndef omega(n): return 0 if n==1 else len(primefactors(n))\ndef a(n):\n    f=factorint(n)\n    return n if n<3 else 2**omega(n) if core(n) == n else reduce(mul, [primorial(f[i]) for i in f]) \n"}
{"sequence_id": "A124970", "text": "Smallest positive integer which can be expressed as the ordered sum of 3 squares in exactly n different ways.", "sequence": "7,1,9,41,81,146,194,306,369,425,594,689,866,1109,1161,1154,1361,1634,1781,1889,2141,2729,2609,3626,3366,3566,3449,3506,4241,4289,4826,5066,5381,7034,5561,6254,7229,7829,8186,8069,8126,8609,8921,8774,10386,11574,11129", "code": "\nfrom collections import Counter\nfrom itertools import count, combinations_with_replacement as mc\ndef aupto(lim):\n  sq = filter(lambda x: x<=lim, (i**2 for i in range(int(lim**(1/2))+2)))\n  s3 = filter(lambda x: 0<x<=lim, (sum(m) for m in mc(sq, 3)))\n  counts, alst = Counter(s3), [7]\n  for n in count(1):\n      mink = min((k for k in counts if counts[k]==n), default=False)\n      if not mink: break\n      alst.append(mink)\n  return alst\nprint(aupto(11600)) \n"}
{"sequence_id": "A125204", "text": "a(0)=0, a(1)=1; and a(n) = a(n-1) + a(a(n-1) mod n) for n>=2.", "sequence": "0,1,2,4,4,8,10,14,24,34,38,46,84,94,132,216,240,242,266,266,276,280,520,652,656,666,906,1122,1124,1644,2300,2310,2320,2358,2442,3564,3564,3648,3648,3928,3952,4192,6634,6718,9018,9284,12932,12946,15388,15390", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n): return n if n<2 else a(n - 1) + a(a(n - 1)%n)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A125289", "text": "Numbers with unique nonzero digit in decimal representation.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,20,22,30,33,40,44,50,55,60,66,70,77,80,88,90,99,100,101,110,111,200,202,220,222,300,303,330,333,400,404,440,444,500,505,550,555,600,606,660,666,700,707,770,777,800,808,880,888,900,909", "code": "\nA125289_list = [n for n in range(10**4) if len(set(str(n))-{'0'})==1]\n\n"}
{"sequence_id": "A125562", "text": "a(n) = denominator of (2n + 1)!/3^n.", "sequence": "1,1,3,3,1,3,3,3,9,3,3,9,9,1,3,3,3,9,3,3,9,9,3,9,9,9,27,3,3,9,9,3,9,9,9,27,9,9,27,27,1,3,3,3,9,3,3,9,9,3,9,9,9,27,3,3,9,9,3,9,9,9,27,9,9,27,27,3,9,9,9,27,9,9,27,27,9,27,27,27,81,3,3,9,9,3,9,9,9,27,9,9,27,27,3,9,9", "code": "\nfrom sympy import factorial, Integer\ndef a(n): return (factorial(2*n + 1) / Integer(3)**n).denominator()\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A125577", "text": "a(0) = 1; for n >= 1, a(n) = n^2 - a(n-1).", "sequence": "1,0,4,5,11,14,22,27,37,44,56,65,79,90,106,119,137,152,172,189,211,230,254,275,301,324,352,377,407,434,466,495,529,560,596,629,667,702,742,779,821,860,904,945,991,1034,1082,1127,1177,1224,1276,1325,1379,1430", "code": "\na = 1\nfor n in range(1,77):\n    print(a, end=',')\n    a = n*n - a\n"}
{"sequence_id": "A126306", "text": "a(n) = number of double-rises (UU-subsequences) in the n-th Dyck path encoded by A014486(n).", "sequence": "0,0,0,1,0,1,1,1,2,0,1,1,1,2,1,2,1,1,2,2,2,2,3,0,1,1,1,2,1,2,1,1,2,2,2,2,3,1,2,2,2,3,1,2,1,1,2,2,2,2,3,2,3,2,2,3,2,2,2,3,3,3,3,3,4,0,1,1,1,2,1,2,1,1,2,2,2,2,3,1,2,2,2,3,1,2,1,1,2,2,2,2,3,2,3,2,2,3,2,2,2,3", "code": "\ndef ok(n):\n    if n==0: return True\n    B=bin(n)[2:] if n!=0 else '0'\n    s=0\n    for b in B:\n        s+=1 if b=='1' else -1\n        if s<0: return False\n    return s==0\ndef a014081(n): return sum(((n>>i)&3==3) for i in range(len(bin(n)[2:]) - 1))\nprint([a014081(n) for n in range(4001) if ok(n)]) \n"}
{"sequence_id": "A126430", "text": "a(n)-a(n-1) is the smallest integer missing in the auxiliary set composed of the previous terms and sums and differences of previous pairs of the sequence.", "sequence": "1,3,8,14,24,36,54,73,93,119,148,179,213,254,296,339,384,431,479,531,587,645,706,769,833,899,966,1037,1114,1194,1276,1360,1449,1540,1638,1737,1839,1942,2046,2156,2269,2384,2505,2628,2756,2887,3019,3155,3292,3431", "code": "\nkeep = [1,3]\nfor aa in range(999):\n....flag = False\n....temp = set()\n....for x in keep:\n........for y in keep:\n............if x != y:\n................temp.add(x+y)\n................temp.add(abs(x-y))\n............temp.add(x)\n............temp.add(y)\n....now = sorted(list(temp))\n....for x in range(1,len(now)):\n........if now[x] - now[x-1] != 1:\n............keep.append(keep[-1]+now[x-1]+1)\n............flag = True\n............break\n....if not flag:\n........keep.append(keep[-1]+max(now)+1)\nwith open(\"A126430b.txt\",\"w\") as g:\n....for x,y in enumerate(keep):\n........g.write(str(x+1)+\" \"+str(y)+\"\\n\")\n\n"}
{"sequence_id": "A126689", "text": "Decimal expansion of negative of Granville-Soundararajan constant.", "sequence": "6,5,6,9,9,9,0,1,3,7,1,6,9,2,7,8,6,8,2,7,9,1,2,0,0,5,6,8,8,9,5,7,5,7,8,0,7,5,5,4,7,4,1,9,1,5,4,0,8,9,8,3,1,6,5,7,1,5,7,7,8,1,6,3,5,2,6,0,2,7,8,8,8,1,1,3,8,2,8,4,4,0,2,4,0,5,7,6,0,3,8,2,6,3,9,8,3,6,5,3,8,7,1,5,2", "code": "\nfrom mpmath import mp, polylog, sqrt, e, pi\nmp.dps=106\nprint([int(k) for k in list(str(4*polylog(2, -sqrt(e)) + pi**2/3 + 1)[3:-1])]) \n"}
{"sequence_id": "A126692", "text": "Prime numbers p such that 1000-p is also a prime. All terms are shown.", "sequence": "3,17,23,29,47,53,59,71,89,113,137,173,179,191,227,239,257,281,317,347,353,359,383,401,431,443,479,491,509,521,557,569,599,617,641,647,653,683,719,743,761,773,809,821,827,863,887,911,929,941,947,953,971,977,983,997", "code": "\nfrom sympy import isprime, primerange\nprint(sorted(p for p in primerange(1, 1000) if isprime(1000-p))) \n"}
{"sequence_id": "A126703", "text": "Numbers k such that last k digits of k^k form a prime number.", "sequence": "143,433,1687,3283,14949", "code": "\nfrom sympy import isprime\nA126703_list = [n for n in range(1,2000) if isprime(pow(n,n,10**n))] \n"}
{"sequence_id": "A126717", "text": "Least odd k such that k*2^n-1 is prime.", "sequence": "3,3,1,1,3,1,3,1,5,7,5,3,5,1,5,9,17,1,3,1,17,7,33,13,39,57,11,21,27,7,213,1,5,31,3,25,17,21,3,25,107,15,33,3,35,7,23,31,5,19,11,21,65,147,5,3,33,51,77,45,17,1,53,9,3,67,63,43,63,51,27,73,5,15,21,25,3,55,47,69", "code": "\nfrom sympy import isprime\ndef a(n):\n    k=1\n    while True:\n        if isprime(k*2**n - 1): return k\n        k+=2\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A126911", "text": "Numbers k such that 1 + k^2 + k^4 + k^6 + k^8 + k^10 + k^12 + k^13 is prime.", "sequence": "10,24,60,148,174,180,268,274,280,294,346,472,484,516,522,598,654,804,834,856,858,898,994,1012,1036,1054,1066,1102,1168,1272,1294,1338,1342,1368,1420,1462,1500,1536,1564,1588,1608,1624,1710,1746,1786,1792,1822,1992", "code": "\nfrom sympy import isprime\ndef ok(k): return isprime(1+sum(k**i for i in [2, 4, 6, 8, 10, 12, 13]))\nprint([k for k in range(2000) if ok(k)]) \n"}
{"sequence_id": "A127118", "text": "a(n) = n-th prime * n-th nonprime.", "sequence": "2,12,30,56,99,130,204,266,345,464,558,740,861,946,1128,1325,1534,1647,1876,2130,2336,2607,2822,3115,3492,3838,4017,4280,4578,4972,5715,6026,6576,6811,7450,7701,8164,8802,9185,9688,10203,10498,11460,11966,12411", "code": "\nfrom sympy import prime, composite\ndef A127118(n):\n    return 2 if n == 1 else prime(n)*composite(n-1) \n"}
{"sequence_id": "A127334", "text": "Numbers that are the sum of 7 consecutive primes.", "sequence": "58,75,95,119,143,169,197,223,251,281,311,341,371,401,431,463,493,523,559,593,625,659,689,719,757,791,827,863,905,947,991,1027,1063,1099,1139,1171,1211,1247,1281,1313,1351,1395,1441,1479,1519,1561,1603,1643", "code": "\nfrom sympy import prime\ndef a(x): return sum(prime(x + n) for n in range(7))\nprint([a(i) for i in range(1, 50)]) \n"}
{"sequence_id": "A127336", "text": "Numbers that are the sum of 9 consecutive primes.", "sequence": "100,127,155,187,221,253,287,323,363,401,439,479,515,553,593,635,679,721,763,803,841,881,929,977,1025,1067,1115,1163,1213,1267,1321,1367,1415,1459,1511,1555,1601,1643,1691,1747,1801,1851,1903,1951,1999,2053", "code": "\nfrom sympy import prime\ndef a(x): return sum([prime(x + n) for n in range(9)])\nprint([a(i) for i in range(1, 50)]) \n"}
{"sequence_id": "A127421", "text": "Numbers whose decimal expansion is a concatenation of 2 consecutive increasing nonnegative numbers.", "sequence": "1,12,23,34,45,56,67,78,89,910,1011,1112,1213,1314,1415,1516,1617,1718,1819,1920,2021,2122,2223,2324,2425,2526,2627,2728,2829,2930,3031,3132,3233,3334,3435,3536,3637,3738,3839,3940,4041,4142,4243,4344,4445,4546", "code": " for n in range(100): print(int(str(n)+str(n+1))) \n"}
{"sequence_id": "A127548", "text": "O.g.f.: Sum_{n>=0} n!*(x/(1+x)^2)^n.", "sequence": "1,1,0,1,4,19,112,771,6088,54213,537392,5867925,69975308,904788263,12607819040,188341689287,3002539594128,50878366664393,913161208490016,17304836525709097,345279674107957524,7235298537356113339", "code": "\nimport math\ndef binomial(n,m):\n    a=1\n    for k in range(n-m+1,n+1):\n        a *= k\n    return a//math.factorial(m)\ndef A127548(n):\n    if n == 0:\n        return 1\n    a=0\n    for s in range(1,n+1):\n        a += (-1)**(n-s)*binomial(s+n-1,2*s-1)*math.factorial(s)\n    return a\nfor n in range(30):\n    print(A127548(n))\n\n"}
{"sequence_id": "A127648", "text": "Triangle read by rows: row n consists of n zeros followed by n+1.", "sequence": "1,0,2,0,0,3,0,0,0,4,0,0,0,0,5,0,0,0,0,0,6,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15", "code": "\nfor i in range(1,15):\n    print(i, end=\", \")\n    for j in range(i):\n        print(\"0\", end=\", \") \n"}
{"sequence_id": "A127741", "text": "a(n) = (n+1) * A005493(n).", "sequence": "1,6,30,148,755,4044,22841,136056,853452,5625950,38885297,281170080,2122313505,16688829122,136457754030,1158155642512,10186602918035,92711977180164,871936904575985,8462913158427580,84668764368102012,872196382566014506,9241557859113581689", "code": "\n\nfrom itertools import accumulate\nA127741_list, blist, b = [], [1], 1\nfor n in range(1,1001):\n....blist = list(accumulate([b]+blist))\n....b = blist[-1]\n....A127741_list.append(blist[-2]*n) \n"}
{"sequence_id": "A127818", "text": "a(n) is the least k such that the remainder when 10^k is divided by k is n.", "sequence": "3,14,7,6,35,94,993,46,22963573117,11,15084115509707,22,21,86,99985,24,221819,82,327,1996,28039,26,169,38,39,74,24257,36,10191082613,65,49,34,4739,66,99965,188,171,62,3753219157,60,3961,58,87,76,28315,159,10441", "code": "\ndef a(n):\n  k = 1\n  while 10**k % k != n: k += 1\n  return k\nprint([a(n) for n in range(1, 9)]) \n"}
{"sequence_id": "A127920", "text": "1/6 of product of three numbers: n-th prime, previous and following number.", "sequence": "1,4,20,56,220,364,816,1140,2024,4060,4960,8436,11480,13244,17296,24804,34220,37820,50116,59640,64824,82160,95284,117480,152096,171700,182104,204156,215820,240464,341376,374660,428536,447580,551300,573800,644956", "code": "\nfrom sympy import prime\nprint([(prime(n) - 1)*prime(n)*(prime(n) + 1)//6 for n in range(1, 101)]) \n"}
{"sequence_id": "A127936", "text": "Numbers n such that 1 + Sum_{i=1..n} 2^(2i-1) is prime.", "sequence": "1,2,3,5,6,8,9,11,15,21,30,39,50,63,83,95,99,156,173,350,854,1308,1769,2903,5250,5345,5639,6195,7239,21368,41669,47684,58619,63515,69468,70539,133508,134993,187160,493095", "code": "\nfrom sympy import isprime\nA127936 = [i for i in range(1,10**3) if isprime(int('01'*i+'1',2))]\n\n"}
{"sequence_id": "A127962", "text": "Binary expansion of A000979(n).", "sequence": "11,1011,101011,1010101011,101010101011,1010101010101011,101010101010101011,1010101010101010101011,101010101010101010101010101011", "code": "\nfrom gmpy2 import divexact\nfrom sympy import prime, isprime\nA127962 = [int(bin(p)[2:]) for p in (divexact(2**prime(n)+1,3) for n in range(2,10**2)) if isprime(p)] \n"}
{"sequence_id": "A128024", "text": "Numbers n such that (7^n - 3^n)/4 is prime.", "sequence": "3,7,19,109,131,607,863,2917,5923,12421", "code": "\nfrom sympy import isprime\ndef aupto(lim): return [k for k in range(lim+1) if isprime((7**k-3**k)//4)]\nprint(aupto(900)) \n"}
{"sequence_id": "A128227", "text": "Right border (1,1,1,...) added to A002260.", "sequence": "1,1,1,1,2,1,1,2,3,1,1,2,3,4,1,1,2,3,4,5,1,1,2,3,4,5,6,1,1,2,3,4,5,6,7,1,1,2,3,4,5,6,7,8,1,1,2,3,4,5,6,7,8,9,1,1,2,3,4,5,6,7,8,9,10,1,1,2,3,4,5,6,7,8,9,10,11,1,1,2,3,4,5,6,7,8,9,10,11,12,1", "code": "\ndef T(n, k): return 1 if n==k else k\nfor n in range(1, 11): print([T(n, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A128229", "text": "A natural number transform, inverse of signed A094587.", "sequence": "1,1,1,0,2,1,0,0,3,1,0,0,0,4,1,0,0,0,0,5,1,0,0,0,0,0,6,1,0,0,0,0,0,0,7,1,0,0,0,0,0,0,0,8,1,0,0,0,0,0,0,0,0,9,1,0,0,0,0,0,0,0,0,0,10,1,0,0,0,0,0,0,0,0,0,0,11,1,0,0,0,0,0,0,0,0,0,0,0,12,1", "code": "\ndef T(n, k): return 1 if n==k else n - 1 if k==n - 1 else 0\nfor n in range(1, 11): print([T(n, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A128287", "text": "Nonprime numbers k such that k divides A014137(k).", "sequence": "1,8,133,49378", "code": "\nfrom __future__ import division\nfrom sympy import isprime\nA128287_list, x, s = [1], 1, 2\nfor i in range(2,10**5):\n....x = x*(4*i-2)//(i+1)\n....s += x\n....if not (isprime(i) or s % i):\n........A128287_list.append(i) \n"}
{"sequence_id": "A128437", "text": "a(n) = floor((numerator of H(n))/n), where H(n) = Sum_{k=1..n} 1/k is the n-th harmonic number.", "sequence": "1,1,3,6,27,8,51,95,792,738,7610,7168,88153,83695,79717,152284,2478954,793016,14489252,2791756,898002,867872,19318117,56159289,1362100898,1322913164,11575416740,11264449603,318174017634,310156094338", "code": "\nfrom sympy import harmonic\ndef A128437(n): return harmonic(n).p//n \n"}
{"sequence_id": "A128438", "text": "a(n) = floor((denominator of H(n))/n), where H(n) = Sum_{k=1..n} 1/k, the n-th harmonic number.", "sequence": "1,1,2,3,12,3,20,35,280,252,2520,2310,27720,25740,24024,45045,720720,226893,4084080,775975,246341,235144,5173168,14872858,356948592,343219800,2974571600,2868336900,80313433200,77636318760,2329089562800", "code": "\nfrom sympy import harmonic\ndef A128438(n): return harmonic(n).q//n \n"}
{"sequence_id": "A128783", "text": "Numbers whose square is a nontrivial concatenation of other squares.", "sequence": "7,10,12,13,19,20,21,30,35,37,38,40,41,44,50,57,60,65,70,80,90,95,97,100,102,105,107,108,110,112,119,120,121,125,129,130,138,140,150,160,170,180,190,191,200,201,204,205,209,210,212,220,223,230,240,250", "code": "\nfrom math import isqrt\ndef issquare(n): return isqrt(n)**2 == n\ndef ok(n, c):\n    if n%10 in { 2, 3, 7, 8}: return False\n    if issquare(n) and c > 1: return True\n    d = str(n)\n    for i in range(1, len(d)):\n        if issquare(int(d[:i])) and ok(int(d[i:]), c+1): return True\n    return False\nprint([r for r in range(251) if ok(r*r, 1)]) \n"}
{"sequence_id": "A129111", "text": "Sums of three consecutive heptagonal numbers.", "sequence": "8,26,59,107,170,248,341,449,572,710,863,1031,1214,1412,1625,1853,2096,2354,2627,2915,3218,3536,3869,4217,4580,4958,5351,5759,6182,6620,7073,7541,8024,8522,9035,9563,10106,10664,11237,11825,12428,13046,13679,14327", "code": "\ndef a(n): return 3*n*(5*n+7)//2 + 8\nprint([a(n) for n in range(44)]) \n"}
{"sequence_id": "A129135", "text": "Number of permutations of [n] with exactly 5 fixed points.", "sequence": "1,0,21,112,1134,11088,122430,1468368,19090071,267258992,4008887883,64142201760,1090417436108,19627513841376,372922762997772,7458455259939936,156627560458759005,3445806330092671776,79253545592131484497,1902085094211155585424", "code": "\nfrom sympy import binomial\nA129135_list, m, x = [], 1, 0\nfor n in range(5,21):\n....x, m = x*n + m*binomial(n,5), -m\n....A129135_list.append(x) \n"}
{"sequence_id": "A129226", "text": "Residues of the Lucas - Lehmer primality test for M(31) = 2147483647.", "sequence": "4,14,194,37634,1416317954,669670838,1937259419,425413602,842014276,12692426,2044502122,1119438707,1190075270,1450757861,877666528,630853853,940321271,512995887,692931217,1883625615,1992425718", "code": "\np = 31; Mp = 2**p - 1\nfrom itertools import accumulate\ndef f(anm1, _): return (anm1**2 - 2) % Mp\nprint(list(accumulate([4]*30, f))) \n"}
{"sequence_id": "A129476", "text": "a(n) is the concatenation in increasing order of all single-digit divisors of n.", "sequence": "1,12,13,124,15,1236,17,1248,139,125,1,12346,1,127,135,1248,1,12369,1,1245,137,12,1,123468,15,12,139,1247,1,12356,1,1248,13,12,157,123469,1,12,13,12458,1,12367,1,124,1359,12,1,123468,17,125", "code": "\ndef a(n): return int('1'+\"\".join(d for d in \"23456789\" if n%int(d) == 0))\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A129545", "text": "Triangular numbers T such that T+1 is a prime.", "sequence": "1,6,10,28,36,66,78,136,190,210,276,378,630,820,946,990,1128,1326,1596,1830,2016,2080,2346,2556,2850,2926,3570,3916,4560,4656,4950,5050,5778,6216,6328,8646,8778,9180,9870,11026,12720,13366,14028,14196,14878", "code": "\nfrom sympy import isprime\ndef T(n): return n*(n+1)//2\ndef ok(T): return isprime(T+1)\nprint(list(filter(ok, (T(n) for n in range(175))))) \n"}
{"sequence_id": "A129696", "text": "Antidiagonal sums of triangular array T defined in A014430: T(j,k) = binomial(j+1, k)-1 for 1 <= k <= j.", "sequence": "1,2,5,9,17,29,50,83,138,226,370,602,979,1588,2575,4171,6755,10935,17700,28645,46356,75012,121380,196404,317797,514214,832025,1346253,2178293,3524561,5702870,9227447,14930334,24157798,39088150,63245966", "code": "\nprpr = 1\nprev = 2\nfor n in range(2,100):\n    print(prpr, end=\", \")\n    curr = prpr+prev + 1 + n//2\n    prpr = prev\n    prev = curr\n\n"}
{"sequence_id": "A129774", "text": "Main diagonal of table of length of English names of numbers.", "sequence": "1,5,8,30,0,42,36,47,79,3000000,606,502,301,305,420,218,181,176,233,367,578,2101,2105,1607,1540,1616,1311,1232,1235,1298,1423,1787,3348,3793,11375,13358,13823,17577,23339,23833,37777,101398,103384,103875,111478,113394", "code": "\ndef A129774(n):\n  i, found, limit = 0, 0, 10**2\n  while found < n-2 and i < limit:\n    i += 1\n    found += 1*(A005589(i)==n)\n  return i*(i < limit)\nprint([A129774(i) for i in range(3,12)]) \n"}
{"sequence_id": "A129888", "text": "Start with 10; write down the sum of its digits; add last two terms; repeat.", "sequence": "10,1,11,2,13,4,17,8,25,7,32,5,37,10,47,11,58,13,71,8,79,16,95,14,109,10,119,11,130,4,134,8,142,7,149,14,163,10,173,11,184,13,197,17,214,7,221,5,226,10,236,11,247,13,260,8,268,16,284,14,298,19,317,11,328,13", "code": "\ndef next2(n): sd = sum(map(int, str(n))); return [sd, n+sd]\ndef aupton(terms):\n    alst = [10]\n    while len(alst) < terms: alst.extend(next2(alst[-1]))\n    return alst[:terms]\nprint(aupton(66)) \n"}
{"sequence_id": "A130206", "text": "Primes in lunar arithmetic in base 3 written in base 10.", "sequence": "5,6,7,8,11,19,20,23,29,32,34,35,38,46,47,55,56,58,59,61,62,64,65,68,71,73,74,77,83,86,88,89,95,97,98,103,104,106,107,110,119,127,128,136,137,142,143,145,146,154,155,163,164,166,167,169,170,173,175,176,178,179,184,185,187,188,190", "code": "\ndef ternary(m):\n    if m == 0: return '0'\n    s = []\n    while m:\n        m, r = divmod(m, 3)\n        s.append(str(r))\n    return ''.join(reversed(s))\ndef addn(m1, m2):\n    s1, s2 = ternary(m1), ternary(m2)\n    len_max = max(len(s1), len(s2))\n    return int(''.join(max(i, j) for i, j in zip(s1.rjust(len_max, '0'), s2.rjust(len_max, '0'))))\ndef muln(m1, m2):\n    s1, s2, prod =  ternary(m1), ternary(m2), '0'\n    for i in range(len(s2)):\n        k = s2[-i-1]\n        prod = addn(int(str(prod), 3), int(''.join(min(j, k) for j in s1), 3)*3**i)\n    return prod\nfor m in range(3,201):\n    i, ct = 1, 0\n    for i in range(1, m+1):\n        if i == 2: continue\n        j = i\n        for j in range(1, m+1):\n            if j == 2: continue\n            ij = int(str(muln(i, j)), 3)\n            if ij == m: ct += 1; break\n        if ct > 0: break\nif ct == 0: print(m) \n"}
{"sequence_id": "A130232", "text": "a(1) = 0; a(n) = a(n-1) + (number of times the digit 0 has appeared in the sequence so far).", "sequence": "0,1,2,3,4,5,6,7,8,9,10,12,14,16,18,20,23,26,29,32,35,38,41,44,47,50,54,58,62,66,70,75,80,86,92,98,104,111,118,125,132,139,146,153,160,168,176,184,192,200,210,221,232,243,254,265,276,287,298,309,321,333,345,357,369", "code": "\nA130232_list, c = [0], 1\nfor _ in range(100):\n    A130232_list.append(A130232_list[-1]+c)\n    c += str(A130232_list[-1]).count('0') \n"}
{"sequence_id": "A130334", "text": "Smallest m>n such that the m-th and n-th triangular numbers are coprime.", "sequence": "2,4,10,6,7,10,9,10,13,12,13,22,15,16,22,18,19,22,21,22,25,24,25,37,27,28,37,30,31,37,33,34,37,36,37,46,39,40,46,42,43,46,45,46,52,48,49,58,51,52,58,54,55,58,57,58,61,60,61,73,63,64,73,66,67,70,69,70,73,72,73", "code": "\nfrom math import gcd\ndef A130334(n):\n    k, Tn, Tm = n+1, n*(n+1)//2, (n+1)*(n+2)//2\n    while gcd(Tn,Tm) != 1:\n        k += 1\n        Tm += k\n    return k \n"}
{"sequence_id": "A130335", "text": "Smallest k > 0 such that gcd(n*(n+1)/2, (n+k)*(n+k+1)/2) = 1.", "sequence": "1,2,7,2,2,4,2,2,4,2,2,10,2,2,7,2,2,4,2,2,4,2,2,13,2,2,10,2,2,7,2,2,4,2,2,10,2,2,7,2,2,4,2,2,7,2,2,10,2,2,7,2,2,4,2,2,4,2,2,13,2,2,10,2,2,4,2,2,4,2,2,10,2,2,7,2,2,4,2,2,4,2,2,22,2,2,7,2,2,16,2,2,4,2,2,10,2,2,7,2", "code": "\nfrom math import gcd\ndef A130335(n):\n    k, Tn, Tm = 1, n*(n+1)//2, (n+1)*(n+2)//2\n    while gcd(Tn,Tm) != 1:\n        k += 1\n        Tm += k+n\n    return k \n"}
{"sequence_id": "A130562", "text": "Triangular table of denominators of the coefficients of Laguerre-Sonin polynomials L(1/2,n,x).", "sequence": "1,2,1,8,2,2,16,8,4,6,128,16,16,4,24,256,128,32,16,48,120,1024,256,256,32,192,240,720,2048,1024,512,256,384,64,96,5040,32768,2048,2048,512,3072,384,384,10080,40320,65536,32768,4096,2048,6144,3072,2304,40320", "code": "\nfrom sympy import binomial, factorial, Integer\ndef a(n, m): return ((-1)**m * binomial(n + 1/Integer(2), n -m) / factorial(m)).denominator()\nfor n in range(21): print([a(n, m) for m in range(n + 1)]) \n"}
{"sequence_id": "A130696", "text": "Numbers k such that 2^k does not contain all ten decimal digits.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,69,71,72,73,74,75,76,77,78,80,81,83,85,86,90,91,92,93,99,102,107,108,153,168", "code": " print([n for n in range(1000) if len(set(str(2**n))) < 10]) \n"}
{"sequence_id": "A130860", "text": "Number of decimal places of Pi given by integer approximations of the form a^(1/n).", "sequence": "0,0,2,2,4,2,3,4,5,5,6,6,6,6,9,9,9,10,10,11,11,13,12,13,13,14,14,14", "code": "\nfrom math import pi, floor, ceil\ndef round(x):\n    return math.floor(x + 0.5)\ndef decimal_places(x, y):\n    dp = -1\n    \n    while floor(x + 0.5) == floor(y + 0.5) and x and y:\n        x = (x - floor(x)) * 10\n        y = (y - floor(y)) * 10\n        dp = dp + 1\n    return dp\nfor n in range(1, 30):\n    pi_to_the_n = pow(pi, n)\n    pi_to_the_n_rnd = round(pi_to_the_n)\n    pi_approx = pow(pi_to_the_n_rnd, 1.0 / n)\n    dps = decimal_places(pi_approx, pi)\n    print(dps)\n"}
{"sequence_id": "A130870", "text": "Palindromic primes with squareful neighbors.", "sequence": "151,727,919,10601,14741,15451,15551,16361,16561,19891,30403,31013,33533,34543,35153,39293,70507,71317,72227,73637,75557,78787,79397,93139,94049,94349,94649,94849,94949,95959,97579,1022201,1055501", "code": "\nfrom sympy import isprime, factorint\ndef palgen10odd(l): \n....if l > 0:\n........yield 0\n........for x in range(1,l+1):\n............for y in range(10**(x-1),10**x):\n................s = str(y)\n................yield int(s+s[-2::-1])\nA130870_list = []\nfor i in palgen10odd(5):\n....if i > 2 and isprime(i) and max(factorint(i-1).values()) > 1 and max(factorint(i+1).values()) > 1:\n........A130870_list.append(i) \n"}
{"sequence_id": "A130901", "text": "a(n) = Sum_{k=1..9} floor(10^n / k).", "sequence": "1,26,281,2827,28288,282895,2828967,28289681,282896824,2828968252,28289682538,282896825395,2828968253967,28289682539681,282896825396824,2828968253968252,28289682539682538,282896825396825395,2828968253968253967,28289682539682539681", "code": "\ndef a(n): return sum(10**n//k for k in range(1, 10))\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A131269", "text": "a(n) = 3*a(n-1) - 2*a(n-2) - a(n-3) + a(n-4) with n>3, a(0)=1, a(1)=2, a(2)=3, a(3)=6.", "sequence": "1,2,3,6,11,20,35,60,101,168,277,454,741,1206,1959,3178,5151,8344,13511,21872,35401,57292,92713,150026,242761,392810,635595,1028430,1664051,2692508,4356587,7049124,11405741,18454896,29860669,48315598,78176301,126491934", "code": "\nprpr = 1\nprev = 2\nfor n in range(2,99):\n    current = prpr + prev + n - 2\n    print(prpr, end=',')\n    prpr = prev\n    prev = current  \n\n"}
{"sequence_id": "A131440", "text": "Triangular table of numerators of the coefficients of Laguerre-Sonin polynomials L(1/2,n,x).", "sequence": "1,3,-1,15,-5,1,35,-35,7,-1,315,-105,63,-3,1,693,-1155,231,-33,11,-1,3003,-3003,3003,-143,143,-13,1,6435,-15015,9009,-2145,715,-13,1,-1,109395,-36465,51051,-7293,12155,-221,17,-17,1,230945,-692835,138567,-46189,46189,-4199,323,-323,19,-1", "code": "\nfrom sympy import binomial, factorial, Integer\ndef a(n, m): return ((-1)**m * binomial(n + 1/Integer(2), n -m) / factorial(m)).numerator()\nfor n in range(21): print([a(n, m) for m in range(n + 1)]) \n"}
{"sequence_id": "A131535", "text": "Least power of 2 having exactly n consecutive 1's in its decimal representation.", "sequence": "1,0,40,42,313,485,1841,8923,8554,81783,165742,1371683,1727601,9386566,28190643,63416789", "code": "\ndef A131535(n):\n    s, t, m, k, u = '1'*n, '1'*(n+1), 0, 1, '1'\n    while s not in u or t in u:\n        m += 1\n        k *= 2\n        u = str(k)\n    return m \n"}
{"sequence_id": "A131536", "text": "Least power of 2 having exactly n consecutive 2's in its decimal representation.", "sequence": "0,1,51,43,692,314,2354,8555,13326,81784,279272,865356,1727608,1727602,23157022,63416790", "code": "\ndef A131536(n):\n    s, t, m, k, u = '2'*n, '2'*(n+1), 0, 1, '1'\n    while s not in u or t in u:\n        m += 1\n        k *= 2\n        u = str(k)\n    return m \n"}
{"sequence_id": "A131537", "text": "Least exponent k such that 2^k has exactly n consecutive 3's in its decimal representation.", "sequence": "5,25,83,219,221,2270,11020,18843,192915,271978,743748,1039315,13873203,14060685", "code": "\ndef a(n):\n  k, n2, np2 = 1, '3'*n, '3'*(n+1)\n  while True:\n    while not n2 in str(2**k): k += 1\n    if np2 not in str(2**k): return k\n    k += 1\nprint([a(n) for n in range(1, 9)]) \n"}
{"sequence_id": "A131544", "text": "Least power of 3 having exactly n consecutive 9's in its decimal representation.", "sequence": "2,34,35,276,1520,2342,8882,32313,164065,265693,1123487,2421341,6250773,9995032,68353789,78927182", "code": "\ndef A131544(n):\n....m, s = 1, '9'*n\n....for i in range(1,10**9):\n........m *= 3\n........if s in str(m):\n............return i\n....return \"search limit reached.\" \n"}
{"sequence_id": "A131546", "text": "Least power of 3 having exactly n consecutive 7's in its decimal representation.", "sequence": "3,11,112,184,721,3520,6643,12793,67448,208380,364578,1123485,9549790,23340555,88637856", "code": "\ndef A131546(n):\n....str7 = '7'*n\n....x,exponent = 3,1\n....while not str7 in str(x):\n........exponent += 1\n........x *= 3\n....return exponent \n"}
{"sequence_id": "A131549", "text": "Least exponent k such that 3^k has exactly n consecutive 4's in its decimal representation.", "sequence": "5,12,55,308,510,2340,7286,9670,125406,222961,847169,639226,6250771,14929721", "code": "\ndef a(n):\n  target, antitarget = '4'*n, '4'*(n+1)\n  k, pow3 = 1, 3\n  while True:\n    t = str(pow3)\n    if target in t and antitarget not in t: return k\n    k, pow3 = k+1, pow3*3\nprint([a(n) for n in range(1, 9)]) \n"}
{"sequence_id": "A131551", "text": "Least power of 3 having exactly n consecutive 2's in its decimal representation.", "sequence": "3,19,148,253,330,2380,2124,30598,22791,238582,107187,1521134,10363119,9995030,68353787", "code": "\ndef a(n):\n  k, n2, np2 = 1, '2'*n, '2'*(n+1)\n  while True:\n    while not n2 in str(3**k): k += 1\n    if np2 not in str(3**k): return k\n    k += 1\nprint([a(n) for n in range(1, 8)]) \n"}
{"sequence_id": "A131552", "text": "Least positive power of 3 having exactly n consecutive 1's in its decimal representation.", "sequence": "4,19,93,334,841,3404,7271,7720,44152,406774,993948,2421339,8786439,11387707,93548200", "code": "\ndef A131552(n):\n....m, s = 1, '1'*n\n....for i in range(1,10**9):\n........m *= 3\n........if s in str(m):\n............return i\n....return \"search limit reached.\" \n"}
{"sequence_id": "A131590", "text": "Sum of the squares of the first 2^n primes.", "sequence": "4,13,87,1027,13275,155995,1789395,19523155,204330315,2081006083,20605602003,199966727443,1908356153955,17942429101363,166591116531123,1529578004981731,13917470067182067,125565110929591171,1124685106917162579,10009134886727192611", "code": "\nfrom sympy import sieve, prime\ndef a(n): return sum(p*p for p in sieve.primerange(1, prime(2**n)+1))\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A131744", "text": "Eric Angelini's \"1995\" puzzle: the sequence is defined by the property that if one writes the English names for the entries, replaces each letter with its rank in the alphabet and calculates the absolute values of the differences, one recovers the sequence.", "sequence": "1,9,9,5,5,9,9,5,5,9,1,3,13,17,1,3,13,17,9,5,5,9,9,5,5,9,1,3,13,17,1,3,13,17,9,5,5,9,10,1,9,15,12,10,13,0,15,12,1,9,2,15,0,9,5,14,17,17,9,6,15,0,9,1,1,9,15,12,10,13,0,15,12,1,9,2,15,0,9,5,14,17,17,9", "code": "\ndef chrdist(a, b): return abs(ord(a)-ord(b))\ndef aupto(nn):\n  allnames = \"zero,one,two,three,four,five,six,seven,eight,nine,ten,eleven,twelve,thirteen,fourteen,fifteen,sixteen,seventeen,eighteen,nineteen,twenty,twentyone\"\n  names = allnames.split(\",\")\n  alst, aidx, last, nxt = [1, 9], 1, \"e\", \"one\"\n  while len(alst) < nn:\n    nxt = names[alst[aidx]]\n    alst += [chrdist(a, b) for a, b in zip(last+nxt[:-1], nxt)]\n    last, aidx = nxt[-1], aidx + 1\n  return alst[:nn]\nprint(aupto(84)) \n"}
{"sequence_id": "A132106", "text": "a(n) = 1 + floor(sqrt(n)) + Sum_{i=1..n} floor(n/i).", "sequence": "1,3,5,7,11,13,17,19,23,27,31,33,39,41,45,49,55,57,63,65,71,75,79,81,89,93,97,101,107,109,117,119,125,129,133,137,147,149,153,157,165,167,175,177,183,189,193,195,205,209,215,219,225,227,235,239,247,251,255,257,269", "code": "\nfrom math import isqrt\ndef A132106(n): return (lambda m: 2*(sum(n//k for k in range(1, m+1)))+m*(1-m)+1)(isqrt(n)) \n"}
{"sequence_id": "A132174", "text": "Index of starting position of n-th generation of terms in A063882.", "sequence": "1,5,10,21,44,92,189,385,778,1565,3141,6294,12602,25219,50454,100926,201871,403763,807548,1615119,3230263,6460552,12921132,25842293,51684616,103369264,206738561,413477157,826954350,1653908737,3307817513,6615635066,13231270174", "code": "\nfrom __future__ import division\ndef A132174(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 5\n    h, m = divmod(n - 3, 5)\n    return (382*2**(5*h + m)-10*2**m)//31- 7*h - m -(1 if m==3 else (-1 if m==4 else 2)) \n"}
{"sequence_id": "A132291", "text": "Base 10 strong Skolem-Langford numbers.", "sequence": "12132003,23121300,30023121,31213200,1214230043,1312432004,2342131400,2412134003,3004312142,3400324121,4002342131,4131243200,1213267345006475,1213275364005746,1214267540036573,1214273645300765,1214275640035763,1215247365430076", "code": "\ndef A132291gen(): \n  for numd in range(1, 11):\n    dset = (\"0123456789\")[:numd]\n    s = [0 for _ in range(2*numd)]\n    for an in sorted(SL(dset, s)):\n      yield an\nfor n, an in enumerate(A132291gen(), start=1):\n  print(n, an) \n"}
{"sequence_id": "A132365", "text": "Least number k such that the Lucas number A000032(k) contains n.", "sequence": "1,0,2,3,13,9,4,6,7,24,5,10,15,26,20,25,49,6,11,16,13,12,10,21,45,40,20,36,7,31,50,12,35,19,17,15,41,36,22,23,39,39,14,21,41,60,8,32,19,56,20,13,45,37,51,44,17,56,42,22,25,62,35,15,71,47,25,24,43,32,17,45,49,38", "code": "\ndef A132365(n):\n    a, b, m, s = 2, 1, 0, str(n)\n    while True:\n        if s in str(a):\n            return m\n        m += 1\n        a, b = b, a+b \n"}
{"sequence_id": "A132391", "text": "Numbers whose square starts with 4 identical digits.", "sequence": "2357,2582,3334,4714,5774,6667,8165,8819,9428,10541,10542,10543,10544,10545,14907,14908,14909,18257,18258,18259,21081,21082,21083,23570,23571,25819,25820,27888,27889,29813,29814,31622,33332,33333", "code": "\ndef aupto(limit):\n  alst = []\n  for m in range(34, limit+1):\n    if len(set(str(m*m)[:4])) == 1: alst.append(m)\n  return alst\nprint(aupto(33333)) \n"}
{"sequence_id": "A132861", "text": "Smallest number at distance 3n from nearest prime (variant 2).", "sequence": "2,26,53,532,211,1342,2179,15704,16033,31424,24281,31430,31433,155960,58831,360698,206699,370312,370315,492170,1357261,1357264,1357267,2010802,2010805,4652428,12485141,17051788,17051791,17051794,11117213,20831416,10938023,20831422", "code": " \nfrom sympy import prevprime, nextprime\ndef A051700(n):\n  return [2, 1, 1][n] if n < 3 else min(n-prevprime(n), nextprime(n)-n)\ndef a(n):\n  if n == 0: return 2\n  m = 0\n  while A051700(m) != 3*n: m += 1\n  return m\nprint([a(n) for n in range(13)]) \n"}
{"sequence_id": "A132971", "text": "a(2*n) = a(n), a(4*n+1) = -a(n), a(4*n+3) = 0, with a(0) = 1.", "sequence": "1,-1,-1,0,-1,1,0,0,-1,1,1,0,0,0,0,0,-1,1,1,0,1,-1,0,0,0,0,0,0,0,0,0,0,-1,1,1,0,1,-1,0,0,1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,1,1,0,1,-1,0,0,1,-1,-1,0,0,0,0,0,1,-1", "code": "\nfrom sympy import mobius, prime, log\nimport math\ndef A(n): return n - 2**int(math.floor(log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a(n): return mobius(b(n)) \n"}
{"sequence_id": "A133421", "text": "Image of n under one application of the \"7x+1\" map.", "sequence": "8,1,1,2,1,3,50,4,3,5,78,6,92,7,5,8,120,9,134,10,7,11,162,12,5,13,9,14,204,15,218,16,11,17,7,18,260,19,13,20,288,21,302,22,15,23,330,24,344,25,17,26,372,27,11,28,19,29,414,30,428,31,21,32,13,33,470,34,23,35,498", "code": "\nfrom __future__ import division\ndef A133421(n):\n    return n//2 if not n % 2 else (n//3 if not n % 3 else (n//5 if not n % 5 else 7*n+1)) \n"}
{"sequence_id": "A133500", "text": "The powertrain or power train map: Powertrain(n): if abcd... is the decimal expansion of a number n, then the powertrain of n is the number n' = a^b*c^d* ..., which ends in an exponent or a base according as the number of digits is even or odd. a(0) = 0 by convention.", "sequence": "0,1,2,3,4,5,6,7,8,9,1,1,1,1,1,1,1,1,1,1,1,2,4,8,16,32,64,128,256,512,1,3,9,27,81,243,729,2187,6561,19683,1,4,16,64,256,1024,4096,16384,65536,262144,1,5,25,125,625,3125,15625,78125,390625,1953125,1,6,36,216,1296", "code": "\ndef A133500(n):\n    s = str(n)\n    l = len(s)\n    m = int(s[-1]) if l % 2 else 1\n    for i in range(0,l-1,2):\n        m *= int(s[i])**int(s[i+1])\n    return m \n"}
{"sequence_id": "A133598", "text": "Numbers k with all digits distinct and nonzero, such that none of k's digits divide k, but all the nonzero digits not in k do divide k.", "sequence": "5936,45798,45978,47598,47958,49578,49758,54798,57894,58794,58974,59478,59836,59874,74598,74958,75498,78594,78954,79458,79854,85794,87594,87954,89574,94578,94758,95478,95874,97458,97854,98754,346598,358694", "code": "\ndef ok(n):\n    s = str(n); ss = set(s)\n    return '0' not in ss and len(s) == len(ss) and all(n%int(d) for d in ss) and all(n%int(d) == 0 for d in set(\"123456789\")-ss)\nanswer2 = list(filter(ok, range(N))) \n"}
{"sequence_id": "A133598", "text": "Numbers k with all digits distinct and nonzero, such that none of k's digits divide k, but all the nonzero digits not in k do divide k.", "sequence": "5936,45798,45978,47598,47958,49578,49758,54798,57894,58794,58974,59478,59836,59874,74598,74958,75498,78594,78954,79458,79854,85794,87594,87954,89574,94578,94758,95478,95874,97458,97854,98754,346598,358694", "code": " \nfrom sympy.utilities.iterables import multiset_permutations\ndef agen():\n  for digits in range(1, 10):\n    for mp in multiset_permutations(\"123456789\", digits):\n      n, mpc = int(\"\".join(mp)), set(\"123456789\") - set(mp)\n      if all(n%int(d) for d in mp) and all(n%int(d) == 0 for d in mpc):\n        yield n\nprint([an for an in agen()]) \n"}
{"sequence_id": "A133602", "text": "The matrix-vector product A133080 * A000108.", "sequence": "1,2,2,7,14,56,132,561,1430,6292,16796,75582,208012,950912,2674440,12369285,35357670,165002460,477638700,2244901890,6564120420,31030387440,91482563640,434542177290,1289904147324,6151850548776", "code": "\nfrom sympy import catalan\ndef a005807(n): return catalan(n) + catalan(n + 1)\ndef a048990(n): return catalan(2*n)\nl=[1, 2]\nfor n in range(2, 31): l+=[a048990(n//2) if n%2==0 else a005807(n - 1)]\nprint(l) \n"}
{"sequence_id": "A133606", "text": "Numbers n with all digits different, such that all of its digits divide n, but none of the nonzero digits not in n divide n.", "sequence": "1,124,175,412,1326,1362,1395,1935,3126,3162,3195,3915,4172,9315,14728,17248,21784,72184,123864,124368,126384,132648,132864,136824,138624,142368,148632,162384,163248,163824,164328,164832,168432,183264,186432", "code": "\ndef ok(n):\n  s = str(n); ss = set(s)\n  return '0' not in ss and len(s) == len(ss) and all(n%int(d) == 0 for d in ss) and all(n%int(d) for d in set(\"123456789\")-ss)\nprint(list(filter(ok, range(200000)))) \n"}
{"sequence_id": "A133606", "text": "Numbers n with all digits different, such that all of its digits divide n, but none of the nonzero digits not in n divide n.", "sequence": "1,124,175,412,1326,1362,1395,1935,3126,3162,3195,3915,4172,9315,14728,17248,21784,72184,123864,124368,126384,132648,132864,136824,138624,142368,148632,162384,163248,163824,164328,164832,168432,183264,186432", "code": " \nfrom sympy.utilities.iterables import multiset_permutations\ndef agen():\n  for digits in range(1, 10):\n    for mp in multiset_permutations(\"123456789\", digits):\n      n, mpc = int(\"\".join(mp)), set(\"123456789\") - set(mp)\n      if all(n%int(d) == 0 for d in mp) and all(n%int(d) for d in mpc):\n        yield n\nprint([an for an in agen()]) \n"}
{"sequence_id": "A133942", "text": "a(n) = (-1)^n * n!.", "sequence": "1,-1,2,-6,24,-120,720,-5040,40320,-362880,3628800,-39916800,479001600,-6227020800,87178291200,-1307674368000,20922789888000,-355687428096000,6402373705728000,-121645100408832000,2432902008176640000", "code": "\nimport math\nfor n in range(0, 25): print((-1)**n*math.factorial(n), end=', ') \n"}
{"sequence_id": "A134009", "text": "a(1) = 1; a(n+1) = round(sqrt(3)*a(n)).", "sequence": "1,2,3,5,9,16,28,48,83,144,249,431,747,1294,2241,3882,6724,11646,20171,34937,60513,104812,181540,314437,544621,943311,1633863,2829934,4901589,8489801,14704767,25469404,44114302,76408212,132342905,229224635,397028714", "code": "\nfrom gmpy2 import isqrt_rem\nA134009_list = [1]\nfor _ in range(1000):\n    i, j = isqrt_rem(3*A134009_list[-1]**2)\n    A134009_list.append(int(i+ int(4*(j-i) >= 1))) \n"}
{"sequence_id": "A134021", "text": "Length of n in balanced ternary representation.", "sequence": "1,1,2,2,2,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5", "code": "\ndef a(n):\n    if n==0: return 1\n    s=0\n    x=0\n    while n>0:\n        x=n%3\n        n=n//3\n        if x==2:\n            x=-1\n            n+=1\n        s+=1\n    return s\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A134022", "text": "Number of negative trits in balanced ternary representation of n.", "sequence": "0,0,1,0,0,2,1,1,1,0,0,1,0,0,3,2,2,2,1,1,2,1,1,2,1,1,1,0,0,1,0,0,2,1,1,1,0,0,1,0,0,4,3,3,3,2,2,3,2,2,3,2,2,2,1,1,2,1,1,3,2,2,2,1,1,2,1,1,3,2,2,2,1,1,2,1,1,2,1,1,1,0,0,1,0,0,2,1,1,1,0,0,1,0,0,3,2,2,2,1,1,2,1,1,2", "code": "\ndef a(n):\n    s=0\n    x=0\n    while n>0:\n        x=n%3\n        n=n//3\n        if x==2:\n            x=-1\n            n+=1\n        if x==-1: s+=1\n    return s\nprint([a(n) for n in range(151)]) \n"}
{"sequence_id": "A134023", "text": "Number of zeros in balanced ternary representation of n.", "sequence": "1,0,0,1,0,0,1,0,1,2,1,0,1,0,0,1,0,1,2,1,0,1,0,1,2,1,2,3,2,1,2,1,0,1,0,1,2,1,0,1,0,0,1,0,1,2,1,0,1,0,1,2,1,2,3,2,1,2,1,0,1,0,1,2,1,0,1,0,1,2,1,2,3,2,1,2,1,2,3,2,3,4,3,2,3,2,1,2,1,2,3,2,1,2,1,0,1,0,1,2,1,0,1,0,1", "code": "\ndef a(n):\n    if n==0: return 1\n    s=0\n    x=0\n    while n>0:\n        x=n%3\n        n=n//3\n        if x==2:\n            x=-1\n            n+=1\n        if x==0: s+=1\n    return s\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A134024", "text": "Number of positive trits in balanced ternary representation of n.", "sequence": "0,1,1,1,2,1,1,2,1,1,2,2,2,3,1,1,2,1,1,2,2,2,3,1,1,2,1,1,2,2,2,3,2,2,3,2,2,3,3,3,4,1,1,2,1,1,2,2,2,3,1,1,2,1,1,2,2,2,3,2,2,3,2,2,3,3,3,4,1,1,2,1,1,2,2,2,3,1,1,2,1,1,2,2,2,3,2,2,3,2,2,3,3,3,4,2,2,3,2,2,3,3,3,4,2", "code": "\ndef a(n):\n    s=0\n    x=0\n    while n>0:\n        x=n%3\n        n //= 3\n        if x==2:\n            x=-1\n            n+=1\n        if x==1: s+=1\n    return s\nprint([a(n) for n in range(151)]) \n"}
{"sequence_id": "A134028", "text": "Reversal of n in balanced ternary representation.", "sequence": "0,1,-2,1,4,-11,-2,7,-8,1,10,-5,4,13,-38,-11,16,-29,-2,25,-20,7,34,-35,-8,19,-26,1,28,-17,10,37,-32,-5,22,-23,4,31,-14,13,40,-119,-38,43,-92,-11,70,-65,16,97,-110,-29,52,-83,-2,79,-56,25,106,-101,-20,61,-74,7,88,-47,34,115,-116,-35,46,-89,-8,73,-62,19,100", "code": "\ndef a(n):\n    if n==0: return 0\n    s=[]\n    x=0\n    while n>0:\n        x=n%3\n        n=n//3\n        if x==2:\n            x=-1\n            n+=1\n        s.append(x)\n    l=s[::-1]\n    return sum(l[i]*3**i for i in range(len(l)))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A134057", "text": "a(n) = binomial(2^n-1,2).", "sequence": "0,0,3,21,105,465,1953,8001,32385,130305,522753,2094081,8382465,33542145,134193153,536821761,2147385345,8589737985,34359345153,137438167041,549754241025,2199020109825,8796086730753,35184359505921", "code": "\nprint([(2**n-1)*(2**(n-1)-1) for n in range(23)])\n\n"}
{"sequence_id": "A134194", "text": "a(n) = the smallest positive divisor of n that does not occur among the exponents in the prime factorization of n.", "sequence": "1,2,3,1,5,2,7,1,1,2,11,3,13,2,3,1,17,3,19,4,3,2,23,2,1,2,1,4,29,2,31,1,3,2,5,1,37,2,3,2,41,2,43,4,3,2,47,2,1,5,3,4,53,2,5,2,3,2,59,3,61,2,3,1,5,2,67,4,3,2,71,1,73,2,3,4,7,2,79,2,1,2,83,3,5,2,3,2,89,3,7,4,3,2,5,2", "code": "\nfrom sympy import divisors, factorint\ndef a(n):\n    f=factorint(n)\n    l=[f[i] for i in f]\n    return min(i for i in divisors(n) if i not in l)\nprint([a(n) for n in range(1, 97)]) \n"}
{"sequence_id": "A134406", "text": "Composite numbers of the form k^2 + 1.", "sequence": "10,26,50,65,82,122,145,170,226,290,325,362,442,485,530,626,730,785,842,901,962,1025,1090,1157,1226,1370,1445,1522,1682,1765,1850,1937,2026,2117,2210,2305,2402,2501,2602,2705,2810,3026,3250,3365,3482,3601,3722,3845", "code": "\nfrom sympy import isprime\nfrom itertools import count, takewhile\ndef aupto(limit):\n    form = takewhile(lambda x: x <= limit, (k**2+1 for k in count(1)))\n    return [number for number in form if not isprime(number)]\nprint(aupto(3845)) \n"}
{"sequence_id": "A134593", "text": "a(n) = 5*n^2 + 10*n + 1. Coefficients of the rational part of (1 + sqrt(n))^5.", "sequence": "1,16,41,76,121,176,241,316,401,496,601,716,841,976,1121,1276,1441,1616,1801,1996,2201,2416,2641,2876,3121,3376,3641,3916,4201,4496,4801,5116,5441,5776,6121,6476,6841,7216,7601,7996,8401,8816,9241,9676,10121", "code": "\nprint([5*i**2-4 for i in range(1,100)])\n\n"}
{"sequence_id": "A134596", "text": "The largest n-digit primeval number A072857.", "sequence": "2,37,137,1379,13679,123479,1234679,12345679,102345679,1123456789,10123456789", "code": " \n"}
{"sequence_id": "A134808", "text": "Cyclops numbers.", "sequence": "0,101,102,103,104,105,106,107,108,109,201,202,203,204,205,206,207,208,209,301,302,303,304,305,306,307,308,309,401,402,403,404,405,406,407,408,409,501,502,503,504,505,506,507,508,509,601,602,603,604,605,606", "code": "\nfrom itertools import product\ndef cyclops(upto=float('inf'), upton=float('inf')): \n  yield 0\n  c, n, half_digits, pow10 = 0, 1, 0, 10\n  while 100**(half_digits+1) < upto and n < upton:\n    half_digits += 1\n    pow10 *= 10\n    for left in product(\"123456789\", repeat=half_digits):\n      left_plus_eye = int(\"\".join(left))*pow10\n      for right in product(\"123456789\", repeat=half_digits):\n        c, n = left_plus_eye + int(\"\".join(right)), n+1\n        if c <= upto and n <= upton: yield c\nprint([c for c in cyclops(upto=606)])\nprint([c for c in cyclops(upton=52)]) \n"}
{"sequence_id": "A134809", "text": "Cyclops primes.", "sequence": "101,103,107,109,307,401,409,503,509,601,607,701,709,809,907,11027,11047,11057,11059,11069,11071,11083,11087,11093,12011,12037,12041,12043,12049,12071,12073,12097,13033,13037,13043,13049,13063", "code": " \nfrom sympy import isprime\nprint([c for c in cyclops(upto=13063) if isprime(c)]) \n"}
{"sequence_id": "A134859", "text": "Wythoff AAA numbers.", "sequence": "1,6,9,14,19,22,27,30,35,40,43,48,53,56,61,64,69,74,77,82,85,90,95,98,103,108,111,116,119,124,129,132,137,142,145,150,153,158,163,166,171,174,179,184,187,192,197,200,205,208,213,218,221,226,229,234,239,242", "code": "\nfrom sympy import floor\nfrom mpmath import phi\ndef A(n): return floor(n*phi)\ndef a(n): return A(A(A(n))) \n"}
{"sequence_id": "A134860", "text": "Wythoff AAB numbers; also, Fib101 numbers: those n for which the Zeckendorf expansion A014417(n) ends with 1,0,1.", "sequence": "4,12,17,25,33,38,46,51,59,67,72,80,88,93,101,106,114,122,127,135,140,148,156,161,169,177,182,190,195,203,211,216,224,232,237,245,250,258,266,271,279,284,292,300,305,313,321,326,334,339,347,355,360,368,373", "code": "\nfrom sympy import fibonacci\ndef a(n):\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return x\ndef ok(n): return str(a(n))[-3:]==\"101\"\nprint([n for n in range(4, 501) if ok(n)]) \n"}
{"sequence_id": "A134861", "text": "Wythoff BAA numbers.", "sequence": "2,10,15,23,31,36,44,49,57,65,70,78,86,91,99,104,112,120,125,133,138,146,154,159,167,175,180,188,193,201,209,214,222,230,235,243,248,256,264,269,277,282,290,298,303,311,319,324,332,337,345,353,358,366,371", "code": "\nfrom sympy import floor\nfrom mpmath import phi\ndef A(n): return floor(n*phi)\ndef B(n): return floor(n*phi**2)\ndef a(n): return B(A(A(n))) \n"}
{"sequence_id": "A134862", "text": "Wythoff ABB numbers.", "sequence": "8,21,29,42,55,63,76,84,97,110,118,131,144,152,165,173,186,199,207,220,228,241,254,262,275,288,296,309,317,330,343,351,364,377,385,398,406,419,432,440,453,461,474,487,495,508,521,529,542,550,563,576,584,597", "code": "\nfrom sympy import floor\nfrom mpmath import phi\ndef A(n): return floor(n*phi)\ndef B(n): return floor(n*phi**2)\ndef a(n): return A(B(B(n))) \n"}
{"sequence_id": "A134863", "text": "Wythoff BAB numbers.", "sequence": "7,20,28,41,54,62,75,83,96,109,117,130,143,151,164,172,185,198,206,219,227,240,253,261,274,287,295,308,316,329,342,350,363,376,384,397,405,418,431,439,452,460,473,486,494,507,520,528,541,549,562,575,583,596", "code": "\nfrom sympy import floor\nfrom mpmath import phi\ndef A(n): return floor(n*phi)\ndef B(n): return floor(n*phi**2)\ndef a(n): return B(A(B(n))) \n"}
{"sequence_id": "A134864", "text": "Wythoff BBB numbers.", "sequence": "13,34,47,68,89,102,123,136,157,178,191,212,233,246,267,280,301,322,335,356,369,390,411,424,445,466,479,500,513,534,555,568,589,610,623,644,657,678,699,712,733,746,767,788,801,822,843,856,877,890,911,932,945", "code": "\nfrom sympy import floor\nfrom mpmath import phi\ndef B(n): return floor(n*phi**2)\ndef a(n): return B(B(B(n))) \n"}
{"sequence_id": "A135027", "text": "Numbers k such that the sum of the digits of k^2 is 10. Multiples of 10 are omitted.", "sequence": "8,19,35,46,55,71,145,152,179,251,332,361,449,451,548,649,4499,20249,20251,24499,100549,114499,316261", "code": "\ndef A007953(n):\n    a=0\n    sh=n\n    while sh > 0:\n        a += sh % 10\n        sh //= 10\n    return a\ndef isA135027(n):\n    if n % 10 == 0:\n        return False\n    else:\n        return A007953(n**2) == 10\nfor n in range(70000):\n    if isA135027(n):\n        print(n)\n\n"}
{"sequence_id": "A135027", "text": "Numbers k such that the sum of the digits of k^2 is 10. Multiples of 10 are omitted.", "sequence": "8,19,35,46,55,71,145,152,179,251,332,361,449,451,548,649,4499,20249,20251,24499,100549,114499,316261", "code": " \ndef ok(n): return n%10 != 0 and sum(map(int, str(n*n))) == 10\nprint(list(filter(ok, range(316262)))) \n"}
{"sequence_id": "A135066", "text": "Primes p such that p^3 is a palindrome.", "sequence": "2,7,11,101", "code": "\nfrom sympy import nextprime\ndef ispal(n): s = str(n); return s == s[::-1]\np = 2\nwhile True:\n  if ispal(p**3): print(p)\n  p = nextprime(p) \n"}
{"sequence_id": "A135141", "text": "a(1)=1, a(p_n)=2*a(n), a(c_n)=2*a(n)+1, where p_n = n-th prime, c_n = n-th composite number.", "sequence": "1,2,4,3,8,5,6,9,7,17,16,11,10,13,19,15,12,35,18,33,23,21,14,27,39,31,25,71,34,37,32,67,47,43,29,55,22,79,63,51,20,143,26,69,75,65,38,135,95,87,59,111,30,45,159,127,103,41,24,287,70,53,139,151,131,77,36,271,191", "code": "\nfrom sympy import isprime, primepi\ndef a(n): return 1 if n==1 else 2*a(primepi(n)) if isprime(n) else 2*a(n - 1 - primepi(n)) + 1 \n"}
{"sequence_id": "A135277", "text": "a(n) = prime(2n-1) + prime(2n) + prime(2n+1).", "sequence": "10,23,41,59,83,109,131,159,187,211,235,269,301,319,349,395,425,457,487,519,551,581,607,661,689,713,749,789,817,841,883,931,961,1015,1049,1079,1119,1151,1187,1229,1271,1303,1331,1367,1391,1433,1477,1511,1553,1611", "code": "\nfrom sympy import prime\ndef a(n): return prime(2*n-1) + prime(2*n) + prime(2*n+1)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A135504", "text": "a(1)=1; for n>1, a(n) = a(n-1) + lcm(a(n-1),n).", "sequence": "1,3,6,18,108,216,1728,3456,6912,41472,497664,995328,13934592,27869184,167215104,334430208,6019743744,12039487488,240789749760,481579499520,963158999040,11557907988480,277389791723520,554779583447040", "code": "\nfrom sympy import lcm\nl=[0, 1]\nfor n in range(2, 101):\n    x=l[n - 1]\n    l.append(x + lcm(x, n))\nprint(l) \n"}
{"sequence_id": "A135518", "text": "Generalized repunits in base 15.", "sequence": "1,16,241,3616,54241,813616,12204241,183063616,2745954241,41189313616,617839704241,9267595563616,139013933454241,2085209001813616,31278135027204241,469172025408063616,7037580381120954241,105563705716814313616,1583455585752214704241", "code": "\ndef a(n): return int('1'*n, 15)\nprint([a(n) for n in range(1, 20)]) \n"}
{"sequence_id": "A135772", "text": "Numbers having equal number of divisors and binary digits.", "sequence": "1,2,3,4,8,10,14,15,16,32,44,45,50,52,63,64,128,130,135,136,138,152,154,165,170,174,182,184,186,189,190,195,222,230,231,232,238,246,248,250,255,256,441,484,512,567,592,656,688,752,848,891,944,976", "code": "\nfrom sympy import divisor_count\ndef ok(n): return divisor_count(n) == n.bit_length()\nprint(list(filter(ok, range(1, 977)))) \n"}
{"sequence_id": "A135923", "text": "(n^8 - 60*n^6 + 90*n^5 + 1160*n^4 - 3204*n^3 - 5349*n^2 + 26586*n - 23760)/24.", "sequence": "0,35,1430,13941,75205,289800,897165,2379300,5620846,12135825,24377000,46145495,83119995,143526526,238971495,385462350,604641900,925264015,1384940106,2032187465,2928812225,4152661380,5800779985,7993011336,10876079610,14628196125", "code": "\nfrom itertools import islice\ndef A135923_generator():\n....m = [1680, -840, -1380, -240, 641, 393, -209, -10, 0]\n....yield m[-1]\n....while True:\n........for i in range(8):\n............m[i+1]+= m[i]\n........yield m[-1]\nlist(islice(A135923_generator(),0,50,1)) \n"}
{"sequence_id": "A136037", "text": "Numbers with at least three adjacent equal digits in binary representation.", "sequence": "7,8,14,15,16,17,23,24,28,29,30,31,32,33,34,35,39,40,46,47,48,49,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,78,79,80,81,87,88,92,93,94,95,96,97,98,99,103,104,110,111,112,113,114,115,116,117,118,119", "code": "\ndef ok(n): b = bin(n)[2:]; return \"000\" in b or \"111\" in b\nprint(list(filter(ok, range(120)))) \n"}
{"sequence_id": "A136562", "text": "Consider the triangle A136561: the n-th diagonal (from the right) is the sequence of (signed) differences between pairs of consecutive terms in the (n-1)th diagonal. The rightmost diagonal (A136562) is defined: A136562(1)=1; A136562(n) is the smallest integer > A136562(n-1) such that any (signed) integer occurs at most once in the triangle A136561.", "sequence": "1,3,9,14,26,36,63,74,103,118,149,169,210,233,280,302,357,392,464,489,553,591,673,713,796,844,941,987,1083,1134,1238,1292,1398,1463,1596,1652,1769,1840,1980,2046,2172,2250,2416,2492,2565,2715,2836,3051,3130,3298", "code": "\na, t = [1], [1]\nfor n in range(1, 100):\n    d = a[-1]\n    while True:\n        d += 1\n        row = [d]\n        for j in range(n):\n            row.append(row[-1]-t[-j-1])\n            if row[-1] in t:\n                break\n        else:\n            a.append(d)\n            t += reversed(row)\n            break\nprint(a)\n\n\n\n"}
{"sequence_id": "A136845", "text": "Numbers k such that k and k^2 use only the digits 0, 1, 3, 5 and 8.", "sequence": "0,1,10,100,1000,10000,58151,100000,550501,581510,1000000,5505010,5815100,5818151,10000000,55050100,55055001,58151000,58181510,100000000,183031501,550501000,550550010,555005001,581510000,581815100,1000000000,1000550501,1005055001,1830315010,3180155001,3318358151,5505010000,5505500100,5505550001", "code": "\nfrom itertools import product\nA136845_list = [0,1]\nfor l in range(15):\n....for a in ('1','3','5','8'):\n........for b in product('01358',repeat=l):\n............for c in ('0','1','5'):\n................n = int(''.join([a]+list(b)+[c]))\n................if set(str(n*n)) <= {'0','1','3','5','8'}:\n....................A136845_list.append(n) \n"}
{"sequence_id": "A137019", "text": "Numbers k such that k and k^2 use only the digits 1, 2, 7 and 9.", "sequence": "1,11,27,2777", "code": "\nfrom itertools import product\nA137019_list = [n for n in (int(''.join(d)) for l in range(1,9) for d in product('1279',repeat=l)) if set(str(n**2)) <= set('1279')] \n"}
{"sequence_id": "A137066", "text": "Numbers k such that k and k^2 use only the digits 2, 3, 4 and 5.", "sequence": "2,5,235,2335,23335,233335,2333335,2354235,23333335,233333335,2333333335,2333524235,23333333335,23333524235,233333333335,2333333333335,23333333333335,233333333333335,2333333333333335,23333333333333335,233333333333333335", "code": " \nprint(auptod(16, only=\"2345\")) \n"}
{"sequence_id": "A137079", "text": "Numbers k such that k and k^2 use only the digits 2, 3, 5 and 6.", "sequence": "5,6,25,235,256,23566,2352365325,23523653335", "code": "\nfrom itertools import product\nA137079_list = [int(''.join(a)+b) for l in range(10) for a in product('2356',repeat = l) for b in ('5','6') if set(str(int(''.join(a)+b)**2)) <= {'2','3','5','6'}]\n\n"}
{"sequence_id": "A137093", "text": "Numbers k such that k and k^2 use only the digits 2, 4, 5 and 6.", "sequence": "2,5,25,65,665,6665,66665,666665,6666665,25625465,65226242,66666665,666666665,6666666665,66666666665,666666666665,6666666666665,66666666666665,666666666666665,6666666666666665,66666666666666665,666666666666666665,6666666666666666665", "code": "\nfrom itertools import product\nA137093_list = [int(''.join(a)) for l in range(1,10) for a in product('2456',repeat = l) if set(str(int(''.join(a))**2)) <= {'2','4','5','6'}] \n"}
{"sequence_id": "A137093", "text": "Numbers k such that k and k^2 use only the digits 2, 4, 5 and 6.", "sequence": "2,5,25,65,665,6665,66665,666665,6666665,25625465,65226242,66666665,666666665,6666666665,66666666665,666666666665,6666666666665,66666666666665,666666666666665,6666666666666665,66666666666666665,666666666666666665,6666666666666666665", "code": " \nprint(auptod(16, only=\"2456\")) \n"}
{"sequence_id": "A137110", "text": "Numbers k such that k and k^2 use only the digits 2, 5, 6 and 7.", "sequence": "5,25,26,75,76,275,525,526,725,7525,27525,72576,256266,276725,725725,276726675,756652275", "code": "\ndef auptod(maxdigits, only=\"2567\"):\n  aset, digset, valid = set(), set(only), set(only)\n  for e in range(1, maxdigits+1):\n    newvalid = set()\n    for tstr in valid:\n      t = int(tstr)\n      if set(str(t**2)) <= digset: aset.add(t)\n      for d in digset:\n        dtstr = d + tstr\n        dt = int(dtstr)\n        remstr = str(dt**2)[-e-1:]\n        if set(remstr) <= digset: newvalid.add(dtstr)\n    valid = newvalid\n  return sorted(aset)\nprint(auptod(16)) \n"}
{"sequence_id": "A137116", "text": "Numbers k such that k and k^2 use only the digits 2, 5, 7, 8 and 9.", "sequence": "5,27,77,85,527,727,7227,9777,28277,29585,88277,99277,278527,298827,2788527,2789227,5289227,8875727,9889277,22925527,27797977,29879585,52898827,85298827,88875527,99789227,99988777,278889277,287279585,292898827,297875527,299929585,527252527,528982977,727528527,727825527,727925527,988579585,992587527", "code": " \nprint(auptod(16, only=\"25789\")) \n"}
{"sequence_id": "A137117", "text": "Numbers k such that k and k^2 use only the digits 2, 5, 7 and 9.", "sequence": "5,27,77,527,7227,27797977", "code": " \nprint(auptod(16, only=\"2579\")) \n"}
{"sequence_id": "A137119", "text": "Numbers k such that k and k^2 use only the digits 2, 6, 7 and 9.", "sequence": "26,27,277,269777", "code": "\ndef test(n):\n    while n > 0:\n        d, n = n%10, n//10\n        if d == 0 or d == 1 or d == 3 or d == 4 or d == 5 or d == 8:\n            return 0\n    return 1\nn, a = 0, 1\nwhile n >= 0:\n    if test(a) and test(a*a):\n        n = n+1\n        print(n,a)\n    a = a+1 \n"}
{"sequence_id": "A137146", "text": "Numbers k such that k and k^2 use only the digits 5, 6, 7 and 8.", "sequence": "76,766,7666,76666,766666,7666666,76666666,766666666,7666666666,76666666666,766666666666,7666666666666,76666666666666,766666666666666", "code": "\nfrom itertools import product\nA137146_list = [n for n in (int(''.join(d)) for l in range(1,6) for d in product('5678',repeat=l)) if set(str(n**2)) <= set('5678')] \n"}
{"sequence_id": "A137214", "text": "a(n) is the number of distinct decimal digits in 2^n.", "sequence": "1,1,1,1,2,2,2,3,3,3,4,4,4,4,5,5,3,5,4,4,7,6,5,4,4,4,6,6,6,9,7,7,5,6,6,7,7,8,7,7,7,6,8,7,9,8,7,8,9,7,8,9,8,7,7,8,8,7,9,8,9,9,9,9,9,9,8,9,10,9,10,7,9,8,9,9,9,8,9,10,9,9,10,9,10,9,9,10,10,10,9,8,9,9,10,10,10,10,10", "code": "\ndef a(n): return len(set(str(2**n)))\nprint([a(n) for n in range(99)]) \n"}
{"sequence_id": "A137243", "text": "Number of coprime pairs (a,b) with -n <= a,b <= n.", "sequence": "8,16,32,48,80,96,144,176,224,256,336,368,464,512,576,640,768,816,960,1024,1120,1200,1376,1440,1600,1696,1840,1936,2160,2224,2464,2592,2752,2880,3072,3168,3456,3600,3792,3920,4240,4336,4672,4832,5024,5200,5568", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A137243(n):\n    if n == 0:\n        return 0\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(A137243(k1)//4-1)\n        j, k1 = j2, n//j2\n    return 4*(n*(n-1)-c+j) \n"}
{"sequence_id": "A137286", "text": "Triangle of coefficients of a version of the Hermite polynomials defined by P(x, n) = x*P(x, n - 1) - n*P(x, n - 2).", "sequence": "1,0,1,-2,0,1,0,-5,0,1,8,0,-9,0,1,0,33,0,-14,0,1,-48,0,87,0,-20,0,1,0,-279,0,185,0,-27,0,1,384,0,-975,0,345,0,-35,0,1,0,2895,0,-2640,0,588,0,-44,0,1,-3840,0,12645,0,-6090,0,938,0,-54,0,1", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef P(x, n): return 1 if n==0 else x if n==1 else x*P(x, n - 1) - n*P(x, n - 2)\ndef a(n): return Poly(P(x, n), x).all_coeffs()[::-1]\nfor n in range(11): print(a(n)) \n"}
{"sequence_id": "A137341", "text": "a(n) = n! * A000110(n) where A000110 is the sequence of Bell numbers.", "sequence": "1,1,4,30,360,6240,146160,4420080,166924800,7673823360,420850080000,27086342976000,2018319704755200,172142484203289600,16642276683198566400,1808459441303074560000,219273812138054209536000,29473992420094651613184000", "code": "\nfrom sympy import bell, factorial\n[factorial(n) * bell(n) for n in range(101)] \n"}
{"sequence_id": "A137385", "text": "Number of errors that occur when choosing n as modulus in French INSEE code (0<n<100).", "sequence": "8190,7600,2184,6810,7246,2024,994,5956,182,7128,336,1806,448,920,1932,5068,375,168,330,6578,196,312,274,1579,6250,414,0,821,200,1908,244,4246,84,342,878,154,112,301,140,5844,134,182,122,276,168,255,111,1347,125,6248,92,363,104,0,294,715,85,183,75,1758,92,223,0,3492,392,78,70,300,64,864,110,140,63,108,1673,262,28,130,65,5054,0,120,63,160,323,111,51,238,57,168,28,225,77,102,286,1132,74,120,0", "code": "\nfor cle in range(1,100):\n    n=0\n    for r1 in range(1,14):\n        for r2 in range(r1,14):\n            ur1=cle-(10**(13-r1))%cle\n            ur2=cle-(10**(13-r2))%cle\n            for c1 in range(10):\n                for c2 in range(10):\n                    if c1==c2:\n                        dif=1\n                    else:\n                        dif=(c1*ur1-c2*ur2)%cle\n                    if dif==0:\n                        n=n+1\n    print(cle,':',n)\n"}
{"sequence_id": "A137397", "text": "Number of distinct palindromic subwords in the binary representation of n.", "sequence": "2,2,3,3,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8", "code": "\ndef ispal(s): return s == s[::-1]\ndef a(n):\n  s = bin(n)[2:]\n  return 1 + len(set(s[i:j] for i in range(len(s))\n    for j in range(i+1, len(s)+1) if ispal(s[i:j])))\nprint([a(n) for n in range(105)]) \n"}
{"sequence_id": "A137401", "text": "a(n) is the number of ordered solutions (x,y,z) to x^3 + y^3 == z^3 mod n with 1 <= x,y,z <= n-1.", "sequence": "0,0,2,7,12,20,0,63,116,72,90,131,0,108,182,339,240,602,324,415,326,420,462,839,604,216,1808,763,756,812,810,1735,992,1056,1092,3311,648,1620,650,2511,1560,1640,1134,2227,4328,1980,2070,3683,2484,2644,2450,1519", "code": "\ndef A137401(n):\n    ndict = {}\n    for i in range(1,n):\n        m = pow(i,3,n)\n        if m in ndict:\n            ndict[m] += 1\n        else:\n            ndict[m] = 1\n    count = 0\n    for i in ndict:\n        ni = ndict[i]\n        for j in ndict:\n            k = (i+j) % n\n            if k in ndict:\n                count += ni*ndict[j]*ndict[k]\n    return count \n"}
{"sequence_id": "A137515", "text": "Maximal number of right triangles in n turns of Pythagoras's snail.", "sequence": "16,53,109,185,280,395,531,685,860,1054,1268,1502,1756,2029,2322,2635,2967,3319,3691,4083,4494,4926,5376,5847,6337,6848,7377,7927,8496,9086,9694,10323,10971,11639,12327,13035,13762,14509,15276,16062,16868,17694", "code": " from math import asin, sqrt,pi hyp=2 som=0 n=1 while n<500: if som+asin(1/sqrt(hyp))/pi*180>n*360: print hyp-2 n=n+1 som=som+asin(1/sqrt(hyp))/pi*180 hyp=hyp+1\n"}
{"sequence_id": "A137727", "text": "Final digit of prime(n)*prime(n+1).", "sequence": "6,5,5,7,3,1,3,7,7,9,7,7,3,1,1,7,9,7,7,3,7,7,7,3,7,3,1,3,7,1,7,7,3,1,9,7,1,1,1,7,9,1,3,1,3,9,3,1,3,7,7,9,1,7,1,7,9,7,7,3,9,1,7,3,1,7,7,9,3,7,7,3,1,7,7,7,3,7,9,1,9,1,3,7,7,7,3,7,3,1,3,3,7,9,7,7,9,3,3,7,9,1,7,9,7", "code": "\nfrom sympy import prime\ndef a(n): return (prime(n)*prime(n+1))%10\nprint([a(n) for n in range(1, 106)]) \n"}
{"sequence_id": "A137727", "text": "Final digit of prime(n)*prime(n+1).", "sequence": "6,5,5,7,3,1,3,7,7,9,7,7,3,1,1,7,9,7,7,3,7,7,7,3,7,3,1,3,7,1,7,7,3,1,9,7,1,1,1,7,9,1,3,1,3,9,3,1,3,7,7,9,1,7,1,7,9,7,7,3,9,1,7,3,1,7,7,9,3,7,7,3,1,7,7,7,3,7,9,1,9,1,3,7,7,7,3,7,3,1,3,3,7,9,7,7,9,3,3,7,9,1,7,9,7", "code": " \nfrom sympy import nextprime\ndef aupton(terms):\n    p1, p2, alst = 2, 3, []\n    while len(alst) < terms:\n        p1, p2, alst = p2, nextprime(p2), alst + [(p1*p2)%10]\n    return alst\nprint(aupton(105)) \n"}
{"sequence_id": "A137744", "text": "Number of different strings of length n obtained from \"abcd\" by iteratively duplicating any substring.", "sequence": "0,0,0,0,1,4,13,40,119,348,1014,2966,8726,25820,76823,229814,691186,2089850,6351448,19398726,59525641,183462778", "code": "\ndef process(s,n,catalog,cache):\n....l=len(s)\n....if l==n:\n........catalog.add(s)\n........return\n....if s in cache:\n........return\n....cache.add(s)\n....for x in range(l):\n........for y in range(x+1,min(x+n-l,l)+1):\n............process(s[:y]+s[x:],n,catalog,cache)\ndef A137744(n):\n....catalog=set()\n....cache=set()\n....process(\"abcd\",n,catalog,cache)\n....return len(catalog)\n\n"}
{"sequence_id": "A137786", "text": "a(n) = 4^n - 3^n - 2^n.", "sequence": "-1,-1,3,29,159,749,3303,14069,58719,241949,988503,4015109,16241679,65506349,263636103,1059360149,4251855039,17050597949,68331794103,273715121189,1096023794799,4387584060749,17560800790503,70274592610229,281192530396959,1125052584678749", "code": "\nprint([4**n - 3**n - 2**n for n in range(99)])\n\n"}
{"sequence_id": "A137790", "text": "a(n) = 8^n-7^n-6^n-5^n-4^n-3^n-2^n.", "sequence": "3761,77325,896849,8869821,81550961,719926125,6196609169,52439953821,438516694961,3635082523725,29935019892689,245264010263421,2001462391659761,16280541150478125,132087583623451409,1069376609438070621,8642407976463949361,69743131733050637325", "code": "\ndef a(n): return 8**n - 7**n - 6**n - 5**n - 4**n - 3**n - 2**n\nprint([a(n) for n in range(5, 23)]) \n"}
{"sequence_id": "A137894", "text": "Limiting sequence when we start with positive integers (A000027) and at step n >= 1 add to the term at position n + a(n) the value n.", "sequence": "1,3,3,4,7,9,7,12,9,10,11,17,13,21,21,16,17,27,19,38,21,33,23,24,25,39,27,28,41,30,31,48,33,51,49,51,37,57,39,40,41,63,43,44,63,69,47,72,49,75,51,52,53,81,77,84,57,78,59,90,61,93,63,64,91,99,67,68,69,99", "code": "\nTOP = 1000\na = [1]*TOP\nfor n in range(1,TOP):\n  a[n]=n\nfor n in range(1,TOP):\n  print(str(a[n]),end=',')\n  if n+a[n]<TOP: a[n+a[n]] += n\n\n"}
{"sequence_id": "A137921", "text": "Number of divisors d of n such that d+1 is not a divisor of n.", "sequence": "1,1,2,2,2,2,2,3,3,3,2,3,2,3,4,4,2,4,2,4,4,3,2,5,3,3,4,5,2,5,2,5,4,3,4,6,2,3,4,6,2,5,2,5,6,3,2,7,3,5,4,5,2,6,4,6,4,3,2,7,2,3,6,6,4,6,2,5,4,7,2,8,2,3,6,5,4,6,2,8,5,3,2,8,4,3,4,7,2,8,4,5,4,3,4,9,2,5,6,7,2,6,2,7,8", "code": "\nfrom sympy import divisors\ndef A137921(n):\n....return len([d for d in divisors(n,generator=True) if n % (d+1)])\n\n"}
{"sequence_id": "A137928", "text": "The even principal diagonal of a 2n X 2n square spiral.", "sequence": "2,4,10,16,26,36,50,64,82,100,122,144,170,196,226,256,290,324,362,400,442,484,530,576,626,676,730,784,842,900,962,1024,1090,1156,1226,1296,1370,1444,1522,1600,1682,1764,1850,1936,2026,2116,2210,2304,2402,2500,2602,2704,2810", "code": " a = lambda n: 2*n + 4*floor((n-1)**2/4)\n"}
{"sequence_id": "A137931", "text": "Sum of the principal diagonals of a 2n X 2n square spiral.", "sequence": "0,10,56,170,384,730,1240,1946,2880,4074,5560,7370,9536,12090,15064,18490,22400,26826,31800,37354,43520,50330,57816,66010,74944,84650,95160,106506,118720,131834,145880,160890,176896,193930,212024,231210,251520,272986,295640", "code": " f = lambda n: -1 + n + sum(2*k**2 - k + 1 for k in range(0,2*n+1))\n"}
{"sequence_id": "A137931", "text": "Sum of the principal diagonals of a 2n X 2n square spiral.", "sequence": "0,10,56,170,384,730,1240,1946,2880,4074,5560,7370,9536,12090,15064,18490,22400,26826,31800,37354,43520,50330,57816,66010,74944,84650,95160,106506,118720,131834,145880,160890,176896,193930,212024,231210,251520,272986,295640", "code": " a = lambda n: 2*n**2 + 2*n + (16*n**3 + 2*n)/3\n"}
{"sequence_id": "A137932", "text": "Terms in an n X n spiral that do not lie on its principal diagonals.", "sequence": "0,0,0,4,8,16,24,36,48,64,80,100,120,144,168,196,224,256,288,324,360,400,440,484,528,576,624,676,728,784,840,900,960,1024,1088,1156,1224,1296,1368,1444,1520,1600,1680,1764,1848,1936,2024,2116,2208,2304,2400,2500,2600,2704,2808", "code": " a = lambda n: n**2 - (2*n - (n%2))\n"}
{"sequence_id": "A137935", "text": "a(n) = 5n + 26*floor(n/5).", "sequence": "0,5,10,15,20,51,56,61,66,71,102,107,112,117,122,153,158,163,168,173,204,209,214,219,224,255,260,265,270,275,306,311,316,321,326,357,362,367,372,377,408,413,418,423,428,459,464,469,474,479,510,515,520,525,530,561,566", "code": " a = lambda n: 5*n + 26*floor(n/5)\n"}
{"sequence_id": "A137936", "text": "a(n) = 5*mod(n,5) + floor(n/5).", "sequence": "0,5,10,15,20,1,6,11,16,21,2,7,12,17,22,3,8,13,18,23,4,9,14,19,24,5,10,15,20,25,6,11,16,21,26,7,12,17,22,27,8,13,18,23,28,9,14,19,24,29,10,15,20,25,30,11,16,21,26,31,12,17,22,27,32,13,18,23,28,33,14,19,24,29,34", "code": " a = lambda n: 5*(n%5) + floor(n/5)\n"}
{"sequence_id": "A137985", "text": "Complementing any single bit in the binary representation of these primes produces a composite number.", "sequence": "127,173,191,223,233,239,251,257,277,337,349,373,431,443,491,509,557,653,683,701,733,761,787,853,877,1019,1193,1201,1259,1381,1451,1453,1553,1597,1709,1753,1759,1777,1973,2027,2063,2333,2371,2447,2633,2879,2917", "code": "\nfrom sympy import isprime, primerange\ndef ok(p): \n  return not any(isprime((1<<k)^p) for k in range(p.bit_length()))\ndef aupto(limit):\n  alst = []\n  for p in primerange(2, limit+1):\n    if ok(p): alst.append(p)\n  return alst\nprint(aupto(2917)) \n"}
{"sequence_id": "A138010", "text": "a(n) is the number of positive divisors of n that divide d(n), where d(n) is the number of positive divisors of n, A000005(n); a(n) also equals d(gcd(n, d(n))).", "sequence": "1,2,1,1,1,2,1,3,2,2,1,4,1,2,1,1,1,4,1,2,1,2,1,4,1,2,1,2,1,2,1,2,1,2,1,3,1,2,1,4,1,2,1,2,2,2,1,2,1,2,1,2,1,2,1,4,1,2,1,6,1,2,2,1,1,2,1,2,1,2,1,6,1,2,2,2,1,2,1,4,1,2,1,6,1,2,1,4,1,4,1,2,1,2,1,6,1,2,2,1,1,2,1,4,1,2,1,6,1,2,1,2,1,2,1,2,2,2,1,4", "code": "\nfrom sympy import divisors, divisor_count\ndef a(n): return sum([ 1*(divisor_count(n)%d==0) for d in divisors(n)]) \n"}
{"sequence_id": "A138011", "text": "a(n) = number of positive divisors, k, of n where d(k) divides d(n). (d(m) = number of positive divisors of m, A000005)", "sequence": "1,2,2,2,2,4,2,3,2,4,2,5,2,4,4,2,2,5,2,5,4,4,2,6,2,4,3,5,2,8,2,4,4,4,4,4,2,4,4,6,2,8,2,5,5,4,2,5,2,5,4,5,2,6,4,6,4,4,2,11,2,4,5,2,4,8,2,5,4,8,2,10,2,4,5,5,4,8,2,5,2,4,2,11,4,4,4,6,2,11,4,5,4,4,4,9,2,5,5,4", "code": "\nfrom sympy import divisors, divisor_count\ndef a(n): return sum([1*(divisor_count(n)%divisor_count(d)==0) for d in divisors(n)]) \n"}
{"sequence_id": "A138012", "text": "a(n) = number of positive divisors, k, of n where d(k) divides n (where d(k) = number of positive divisors of k, A000005).", "sequence": "1,2,1,2,1,3,1,3,2,3,1,6,1,3,1,3,1,5,1,4,1,3,1,8,1,3,2,4,1,4,1,3,1,3,1,9,1,3,1,6,1,4,1,4,2,3,1,8,1,3,1,4,1,5,1,6,1,3,1,11,1,3,2,3,1,4,1,4,1,4,1,12,1,3,2,4,1,4,1,8,2,3,1,11,1,3,1,6,1,7,1,4,1,3,1,10,1,3,2,4,1,4,1,6", "code": "\nfrom sympy import divisors, divisor_count\ndef a(n): return sum([1*(n%divisor_count(d)==0) for d in divisors(n)]) \n"}
{"sequence_id": "A138091", "text": "Numbers n such that n^0+(n+1)^1+(n+2)^2+(n+3)^3+(n+4)^4+(n+5)^5+(n+6)^6+(n+7)^7+(n+8)^8+(n+9)^9+(n+10)^10+(n+11)^11+(n+12)^12+(n+13)^13 is a prime.", "sequence": "25,43,55,109,131,379,389,587,617,649,683,697,719,971,1013,1279,1291,1727,1735,1823,1853,2005,2059,2087,2167,2395,2399,2561,2647,2783,2957,2983", "code": "\nfrom sympy import isprime\nA138091_list, m = [], [6227020800, 44068147200, 181142438400, 564307430400, 1475073815040, 3408641107200, 7182564530400, 14081919023520, 26048741640120, 45924510262992, 77755456075656, 127171611204708, 201851662963039, 312086923782438]\nfor n in range(1,2*10**5+1):\n....for i in range(13):\n........m[i+1]+= m[i]\n....if isprime(m[-1]):\n........A138091_list.append(n) \n"}
{"sequence_id": "A138173", "text": "a(n) is the smallest m such that m^3 begins with n^2.", "sequence": "1,16,21,55,63,154,17,4,201,10,23,113,257,27,609,295,307,148,1535,342,164,1692,809,1793,397,878,9,428,944,4482,987,1008,1029,4872,107,2349,5154,5247,2478,252,552,5609,5697,5785,2726,1284,2806,6131,2885", "code": "\nfrom gmpy2 import iroot\ndef A138173(n):\n    d, nd = 1, n**2\n    while True:\n        x = iroot(nd-1,3)[0]+1\n        if x**3 < nd+d:\n            return int(x)\n        d *= 10\n        nd *= 10 \n"}
{"sequence_id": "A138182", "text": "Smallest summand in the Zeckendorf representation of the n-th prime.", "sequence": "2,3,5,2,3,13,1,1,2,8,2,3,2,1,13,1,1,1,1,3,5,3,2,89,8,1,1,5,2,3,1,8,1,3,5,2,13,1,2,8,1,3,13,2,1,55,1,3,2,1,233,1,8,5,3,1,2,1,2,1,3,5,1,2,1,8,1,2,1,1,2,3,3,1,2,1,1,2,3,3,8,2,2,1,2,3,1,1,8,2,1,13,21,1,1,3,1,144,2,2", "code": "\nfrom sympy import prime\ndef A138182(n):\n    m, tlist = prime(n), [1,2]\n    while tlist[-1]+tlist[-2] <= m:\n        tlist.append(tlist[-1]+tlist[-2])\n    for d in tlist[::-1]:\n        if d == m:\n            return d\n        elif d < m:\n            m -= d \n"}
{"sequence_id": "A138290", "text": "Numbers m such that 2^(m+1) - 2^k - 1 is composite for all 0 <= k < m.", "sequence": "6,14,22,26,30,36,38,42,54,57,62,70,78,81,90,94,110,122,126,132,134,138,142,147,150,158,166,168,171,172,174,178,182,190,194,198,206,210,222,238,254,285,294,312,315,318,334,336,350,366,372,382,405,414,416,432", "code": "\nfrom sympy import isprime\nA138290_list = []\nfor n in range(1,10**3):\n    k2, n2 = 1, 2**(n+1)\n    for k in range(n):\n        if isprime(n2-k2-1):\n                break\n        k2 *= 2\n    else:\n        A138290_list.append(n) \n"}
{"sequence_id": "A138524", "text": "a(n) = Sum_{k=1..n} (2*k)!.", "sequence": "2,26,746,41066,3669866,482671466,87660962666,21010450850666,6423384156578666,2439325392333218666,1126440053169940898666,621574841786409380258666,403913035968392044964258666,305292257647682252546468258666", "code": "\nfrom math import factorial\ndef a(n): return sum(factorial(2*k) for k in range(1, n+1))\nprint([a(n) for n in range(1, 16)]) \n"}
{"sequence_id": "A138578", "text": "Numbers k such that 2^(2*k-7)-7 is prime.", "sequence": "23,361,995,1163,1253,1891,6413", "code": "\nfrom sympy import isprime\ndef afind(limit):\n  k = 5; pow2 = 2**(2*k-7)\n  while k < limit:\n    while not isprime(pow2 - 7) and k <= limit: k += 1; pow2 *= 4\n    if k > limit: return\n    print(k, end=\", \"); k += 1; pow2 *= 4\nafind(2000) \n"}
{"sequence_id": "A138584", "text": "Palindromic primes using only digits 3 and 5.", "sequence": "3,5,353,33533,35353,3353533,3553553,333535333,335333533,355353553,355555553,33335353333,33553335533,35533333553,35553535553,3335535355333,3335555555333,3353353533533,3353355533533,3355535355533,3533355533353,3533533353353", "code": "\nfrom itertools import product\nfrom sympy import isprime\nA138584_list = []\nfor l in range(17):\n    for d in product('35',repeat=l):\n        s = ''.join(d)\n        n = int(s+'3'+s[::-1])\n        if isprime(n):\n            A138584_list.append(n)\n        n += 2*10**l\n        if isprime(n):\n            A138584_list.append(n) \n"}
{"sequence_id": "A138666", "text": "Numbers n such that every sum of consecutive positive numbers ending in n is not prime.", "sequence": "1,8,14,18,20,25,26,28,32,33,35,38,39,44,46,48,50,56,58,60,62,63,65,68,72,74,77,78,80,81,85,86,88,92,93,94,95,98,102,104,105,108,110,111,116,118,119,122,123,124,125,128,130,133,134,138,140,143,144,145,146,148", "code": "\nfrom sympy import isprime\nfrom itertools import accumulate\ndef ok(n): return all(not isprime(s) for s in accumulate(range(n, 0, -1)))\ndef aupto(nn): return [m for m in range(1, nn+1) if ok(m)]\nprint(aupto(148)) \n"}
{"sequence_id": "A138879", "text": "Sum of all parts of the last section of the set of partitions of n.", "sequence": "1,3,5,11,15,31,39,71,94,150,196,308,389,577,750,1056,1353,1881,2380,3230,4092,5412,6821,8935,11150,14386,17934,22834,28281,35735,43982,55066,67551,83821,102365,126267,153397,188001,227645,277305,334383", "code": "\nfrom sympy.ntheory import npartitions\nprint([npartitions(n)*n - npartitions(n - 1)*(n - 1) for n in range(1, 51)]) \n"}
{"sequence_id": "A138918", "text": "Numbers n such that 18n-1 is prime.", "sequence": "1,3,4,5,6,10,11,13,14,15,20,24,25,26,28,29,31,33,36,38,39,40,43,45,46,48,49,53,54,59,61,64,66,68,70,71,76,80,83,84,88,89,90,91,95,104,105,106,110,111,115,116,119,123,126,130,131,133,134,136,144,145,148,150", "code": "\nfrom gmpy2 import divexact, t_mod\nfrom sympy import prime\nA138918 = [divexact(p+1,18) for p in (prime(n) for n in range(1,10**6)) if not t_mod(p+1,18)] \n"}
{"sequence_id": "A139053", "text": "Array read by rows: row n lists the first 3 primes with n digits.", "sequence": "2,3,5,11,13,17,101,103,107,1009,1013,1019,10007,10009,10037,100003,100019,100043,1000003,1000033,1000037,10000019,10000079,10000103,100000007,100000037,100000039,1000000007,1000000009,1000000021,10000000019,10000000033,10000000061", "code": "\nfrom sympy import nextprime\ndef auptodigs(maxdigits):\n  alst = []\n  for n in range(1, maxdigits+1):\n    p1 = nextprime(10**(n-1))\n    p2 = nextprime(p1)\n    p3 = nextprime(p2)\n    alst.extend([p1, p2, p3])\n  return alst\nprint(auptodigs(11)) \n"}
{"sequence_id": "A139250", "text": "Toothpick sequence (see Comments lines for definition).", "sequence": "0,1,3,7,11,15,23,35,43,47,55,67,79,95,123,155,171,175,183,195,207,223,251,283,303,319,347,383,423,483,571,651,683,687,695,707,719,735,763,795,815,831,859,895,935,995,1083,1163,1199,1215,1243,1279,1319,1379", "code": "\ndef msb(n):\n    t = 0\n    while n>>t > 0:\n        t += 1\n    return 2**(t - 1)\ndef a(n):\n    k = (2 * msb(n)**2 + 1) / 3\n    return 0 if n == 0 else k if n == msb(n) else k + 2*a(n - msb(n)) + a(n - msb(n) + 1) - 1\n[a(n) for n in range(101)]  \n"}
{"sequence_id": "A139285", "text": "Smallest nontrivial number m that when expressed in base n and then interpreted in base 10, is a multiple of the original number.", "sequence": "3,2,7,6,5,308,51,34217,7794416", "code": "\nm,M=2,11\nwhile M%m>0:\n    m,M=m+1,10*M+1\nprint(1,m)\nfor n in range(2,10):\n    m,M,d=n,10,10-n\n    while M%m>0:\n        m=m+1\n        u,s=m,0\n        while u%n==0:\n            u,s=u//n,10*s+d\n        M=M+1+s\n    print(n,m)\n\n"}
{"sequence_id": "A139383", "text": "Number of n-level labeled rooted trees with n leaves.", "sequence": "1,1,2,12,154,3455,120196,5995892,406005804,35839643175,3998289746065,550054365477936,91478394767427823,18091315306315315610,4196205472500769304318,1128136777063831105273242,347994813261017613045578964,122080313159891715442898099217", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef A(n, k): return 1 if n==0 or k==0 else sum(binomial(n - 1, j - 1)*A(j, k - 1)*A(n - j, k) for j in range(1, n + 1))\ndef a(n): return A(n, n - 1)\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A139401", "text": "If n is a square, a(n) is 0. Otherwise, a(n) is the smallest number k such that n is not a quadratic residue modulo k.", "sequence": "0,3,4,0,3,4,4,3,0,4,3,5,5,3,4,0,3,4,4,3,8,4,3,7,0,3,4,5,3,4,4,3,5,4,3,0,5,3,4,7,3,4,4,3,7,4,3,5,0,3,4,5,3,4,4,3,5,4,3,9,7,3,4,0,3,4,4,3,7,4,3,5,5,3,4,7,3,4,4,3,0,4,3,9,8,3,4,5,3,4,4,3,5,4,3,7,5,3,4,0,3,4,4,3,9", "code": "\ndef A139401(n):\nif int(sqrt(n)) == sqrt(n): return 0\n  for pp in range(2,n+2): \n    residues = frozenset(pow(k, 2, pp) for k in range(pp))\n    if n % pp not in residues:\n      return pp \n"}
{"sequence_id": "A139417", "text": "Sum of digits of the square of the sum of the preceding numbers.", "sequence": "1,1,4,9,9,18,18,9,18,27,27,27,18,27,27,18,27,18,27,18,9,27,27,27,27,18,27,9,27,27,27,9,27,27,36,27,27,27,18,27,27,27,27,27,36,36,9,27,27,18,36,36,27,18,27,18,27,27,27,27,36,36,27,18,36,27,36", "code": "\ndef sd(n): return sum(map(int, str(n)))\ndef aupton(terms):\n    alst, s = [1], 1\n    for n in range(2, terms+1): alst.append(sd(s**2)); s += alst[-1]\n    return alst\nprint(aupton(67)) \n"}
{"sequence_id": "A139562", "text": "Sum of primes < n^2.", "sequence": "0,0,5,17,41,100,160,328,501,791,1060,1593,2127,2914,3831,4661,6081,7982,9523,11599,13887,16840,20059,23592,26940,32353,37561,42468,48494,55837,62797,70241,80189,89672,100838,111587,124211,136114,148827", "code": "\nfrom sympy import primerange\ndef a(n): return sum(p for p in primerange(1, n*n))\nprint([a(n) for n in range(39)]) \n"}
{"sequence_id": "A139770", "text": "Smallest number having at least as many divisors as n.", "sequence": "1,2,2,4,2,6,2,6,4,6,2,12,2,6,6,12,2,12,2,12,6,6,2,24,4,6,6,12,2,24,2,12,6,6,6,36,2,6,6,24,2,24,2,12,12,6,2,48,4,12,6,12,2,24,6,24,6,6,2,60,2,6,12,24,6,24,2,12,6,24,2,60,2,6,12,12,6,24,2,48,12,6,2,60,6,6,6,24,2", "code": "\nfrom sympy import divisor_count as d\ndef a(n):\n    x=d(n)\n    m=1\n    while True:\n        if d(m)>=x: return m\n        else: m+=1 \n"}
{"sequence_id": "A140263", "text": "Permutation of nonnegative integers obtained by interleaving A117967 and A117968.", "sequence": "0,1,2,5,7,3,6,4,8,17,22,15,21,16,23,11,19,9,18,10,20,14,25,12,24,13,26,53,67,51,66,52,68,47,64,45,63,46,65,50,70,48,69,49,71,35,58,33,57,34,59,29,55,27,54,28,56,32,61,30,60,31,62,44,76,42,75,43,77,38,73,36", "code": "\nfrom sympy import ceiling\nfrom sympy.ntheory.factor_ import digits\ndef a004488(n): return int(\"\".join([str((3 - i)%3) for i in digits(n, 3)[1:]]), 3)\ndef a117968(n):\n    if n==1: return 2\n    if n%3==0: return 3*a117968(n/3)\n    elif n%3==1: return 3*a117968((n - 1)/3) + 2\n    else: return 3*a117968((n + 1)/3) + 1\ndef a117967(n): return 0 if n==0 else a117968(-n) if n<0 else a004488(a117968(n))\ndef a001057(n): return -(-1)**n*ceiling(n/2)\ndef a(n): return a117967(a001057(n)) \n"}
{"sequence_id": "A140264", "text": "Inverse permutation to A140263.", "sequence": "0,1,2,5,7,3,6,4,8,17,19,15,23,25,21,11,13,9,18,16,20,12,10,14,24,22,26,53,55,51,59,61,57,47,49,45,71,73,69,77,79,75,65,67,63,35,37,33,41,43,39,29,31,27,54,52,56,48,46,50,60,58,62,36,34,38,30,28,32,42,40,44", "code": "\ndef a117966(n):\n    if n==0: return 0\n    if n%3==0: return 3*a117966(n/3)\n    elif n%3==1: return 3*a117966((n - 1)/3) + 1\n    else: return 3*a117966((n - 2)/3) - 1\ndef Z(z): return 2*z if z>0 else 2*abs(z) + 1\ndef a140266(n): return Z(a117966(n - 1))\ndef a(n): return a140266(n + 1) - 1 \n"}
{"sequence_id": "A140265", "text": "Permutation of natural numbers: a(n) = A140263(n-1)+1.", "sequence": "1,2,3,6,8,4,7,5,9,18,23,16,22,17,24,12,20,10,19,11,21,15,26,13,25,14,27,54,68,52,67,53,69,48,65,46,64,47,66,51,71,49,70,50,72,36,59,34,58,35,60,30,56,28,55,29,57,33,62,31,61,32,63,45,77,43,76,44,78,39,74,37", "code": "\nfrom sympy import ceiling\nfrom sympy.ntheory.factor_ import digits\ndef a004488(n): return int(\"\".join([str((3 - i)%3) for i in digits(n, 3)[1:]]), 3)\ndef a117968(n):\n    if n==1: return 2\n    if n%3==0: return 3*a117968(n/3)\n    elif n%3==1: return 3*a117968((n - 1)/3) + 2\n    else: return 3*a117968((n + 1)/3) + 1\ndef a117967(n): return 0 if n==0 else a117968(-n) if n<0 else a004488(a117968(n))\ndef a001057(n): return -(-1)**n*ceiling(n/2)\ndef a(n): return a117967(a001057(n - 1)) + 1 \n"}
{"sequence_id": "A140266", "text": "Inverse permutation to A140265.", "sequence": "1,2,3,6,8,4,7,5,9,18,20,16,24,26,22,12,14,10,19,17,21,13,11,15,25,23,27,54,56,52,60,62,58,48,50,46,72,74,70,78,80,76,66,68,64,36,38,34,42,44,40,30,32,28,55,53,57,49,47,51,61,59,63,37,35,39,31,29,33,43,41,45", "code": "\ndef a117966(n):\n    if n==0: return 0\n    if n%3==0: return 3*a117966(n/3)\n    elif n%3==1: return 3*a117966((n - 1)/3) + 1\n    else: return 3*a117966((n - 2)/3) - 1\ndef Z(z): return 2*z if z>0 else 2*abs(z) + 1\ndef a(n): return Z(a117966(n - 1)) \n"}
{"sequence_id": "A140267", "text": "Nonnegative integers in balanced ternary representation (with 2 standing for -1 digit).", "sequence": "0,1,12,10,11,122,120,121,102,100,101,112,110,111,1222,1220,1221,1202,1200,1201,1212,1210,1211,1022,1020,1021,1002,1000,1001,1012,1010,1011,1122,1120,1121,1102,1100,1101,1112,1110,1111,12222,12220,12221", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a004488(n): return int(\"\".join([str((3 - i)%3) for i in digits(n, 3)[1:]]), 3)\ndef a117968(n):\n    if n==1: return 2\n    if n%3==0: return 3*a117968(n/3)\n    elif n%3==1: return 3*a117968((n - 1)/3) + 2\n    else: return 3*a117968((n + 1)/3) + 1\ndef a117967(n): return 0 if n==0 else a004488(a117968(n))\ndef a(n): return int(\"\".join(map(str, digits(a117967(n), 3)[1:]))) \n"}
{"sequence_id": "A140268", "text": "a(n) = negative integer -n presented in balanced ternary system.", "sequence": "2,21,20,22,211,210,212,201,200,202,221,220,222,2111,2110,2112,2101,2100,2102,2121,2120,2122,2011,2010,2012,2001,2000,2002,2021,2020,2022,2211,2210,2212,2201,2200,2202,2221,2220,2222,21111,21110,21112", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a117968(n):\n    if n==1: return 2\n    if n%3==0: return 3*a117968(n/3)\n    elif n%3==1: return 3*a117968((n - 1)/3) + 2\n    else: return 3*a117968((n + 1)/3) + 1\ndef a(n): return int(\"\".join(map(str, digits(a117968(n), 3)[1:]))) \n"}
{"sequence_id": "A140365", "text": "a(n) = sum of primes in {6*n-5, 6*n-1}.", "sequence": "5,18,30,42,29,31,78,90,53,59,61,138,73,162,89,0,198,210,222,0,0,258,137,139,149,151,157,330,173,179,181,191,390,199,0,211,0,450,462,239,241,251,257,263,269,271,558,283,293,0,0,618,630,0,0,331,337,347,702", "code": "\nfrom sympy import isprime\ndef a(n): return sum(k*isprime(k) for k in {6*n-5, 6*n-1})\nprint([a(n) for n in range(1, 60)]) \n"}
{"sequence_id": "A140466", "text": "a(n) = 4*A002088(n).", "sequence": "0,4,8,16,24,40,48,72,88,112,128,168,184,232,256,288,320,384,408,480,512,560,600,688,720,800,848,920,968,1080,1112,1232,1296,1376,1440,1536,1584,1728,1800,1896,1960,2120,2168,2336,2416,2512,2600,2784,2848,3016,3096", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A140466(n): \n    if n == 0:\n        return 0\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(A140466(k1)//2-1)\n        j, k1 = j2, n//j2\n    return 2*(n*(n-1)-c+j) \n"}
{"sequence_id": "A140488", "text": "Trajectory of 5 under repeated application of the map: n -> n + second-smallest number that does not divide n.", "sequence": "5,8,13,16,21,25,28,33,37,40,46,50,54,59,62,66,71,74,78,83,86,90,97,100,106,110,114,119,122,126,131,134,138,143,146,150,157,160,166,170,174,179,182,186,191,194,198,203,206,210,218,222,227,230,234,239,242,246", "code": "\ndef aupton(terms):\n    alst = [5]\n    while len(alst) < terms:\n        an, k, smallest = alst[-1], 2, False\n        while not smallest or an%k == 0:\n            if not smallest and an%k != 0: smallest = True\n            k += 1\n        alst.append(an+k)\n    return alst\nprint(aupton(58)) \n"}
{"sequence_id": "A140517", "text": "Number of cycles in an n X n grid.", "sequence": "0,1,13,213,9349,1222363,487150371,603841648931,2318527339461265,27359264067916806101,988808811046283595068099,109331355810135629946698361371,36954917962039884953387868334644457", "code": "\n\nfrom graphillion import GraphSet\nimport graphillion.tutorial as tl\ndef A140517(n):\n    if n == 0: return 0\n    universe = tl.grid(n, n)\n    GraphSet.set_universe(universe)\n    cycles = GraphSet.cycles()\n    return cycles.len()\nprint([A140517(n) for n in range(9)])  \n"}
{"sequence_id": "A140532", "text": "Number of primes with n distinct decimal digits, none of which are 0.", "sequence": "4,20,83,395,1610,5045,12850,23082,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom itertools import permutations\nfrom sympy import isprime, primerange\ndef distinct_digs(n): s = str(n); return len(s) == len(set(s))\ndef a(n):\n  if n >= 9: return 0\n  return sum(isprime(int(\"\".join(p))) for p in permutations(\"123456789\", n))\nprint([a(n) for n in range(1, 30)]) \n"}
{"sequence_id": "A140560", "text": "Primes p such that p + 30 is not a prime.", "sequence": "2,3,5,19,47,61,89,103,113,131,139,157,173,179,191,223,229,257,269,271,293,311,313,331,347,373,383,397,421,439,443,463,467,487,499,503,509,521,523,593,599,607,619,641,659,673,677,683,691,701,719,733,751,761", "code": "\nfrom sympy import isprime, primerange\nprint([p for p in primerange(1, 1001) if not isprime(p + 30)]) \n"}
{"sequence_id": "A140635", "text": "Smallest positive integer having the same number of divisors as n.", "sequence": "1,2,2,4,2,6,2,6,4,6,2,12,2,6,6,16,2,12,2,12,6,6,2,24,4,6,6,12,2,24,2,12,6,6,6,36,2,6,6,24,2,24,2,12,12,6,2,48,4,12,6,12,2,24,6,24,6,6,2,60,2,6,12,64,6,24,2,12,6,24,2,60,2,6,12,12,6,24,2,48,16,6,2,60,6,6,6,24,2", "code": "\nfrom sympy import divisor_count as d\ndef a(n):\n    x=d(n)\n    m=1\n    while True:\n        if d(m)==x: return m\n        else: m+=1 \n"}
{"sequence_id": "A140706", "text": "A054525 * A014683; a(n) = Sum_{d|n} mu(d)*A014683(n/d).", "sequence": "1,2,3,1,5,0,7,4,5,2,11,5,13,4,6,8,17,7,19,9,10,8,23,8,19,10,18,13,29,11,31,16,18,14,22,12,37,16,22,16,41,15,43,21,25,20,47,16,41,21,30,25,53,18,38,24,34,26,59,15,61,28,37,32,46,23,67,33,42,27,71,24,73,34,41", "code": "\nfrom sympy import isprime, mobius, divisors\ndef a014683(n): return n + isprime(n)\ndef a140706(n): return sum(mobius(d)*a014683(n//d) for d in divisors(n))\nprint([a140706(n) for n in range(1,51)]) \n"}
{"sequence_id": "A140758", "text": "a(n) = floor(n*Pi/2).", "sequence": "0,1,3,4,6,7,9,10,12,14,15,17,18,20,21,23,25,26,28,29,31,32,34,36,37,39,40,42,43,45,47,48,50,51,53,54,56,58,59,61,62,64,65,67,69,70,72,73,75,76,78,80,81,83,84,86,87,89,91,92,94,95,97,98,100,102,103,105", "code": "\nimport math\nx=0\nwhile x < 36001:\n    y = math.radians(x)\n    z = math.trunc(y)\n    print(z, end=\", \")\n    x += 90\n\n"}
{"sequence_id": "A140773", "text": "Consider the products of all pairs of (not necessarily distinct) positive divisors of n. a(n) is the number of these products that divide n. a(n) also is the number of the products that are divisible by n.", "sequence": "1,2,2,4,2,5,2,6,4,5,2,10,2,5,5,9,2,10,2,10,5,5,2,16,4,5,6,10,2,14,2,12,5,5,5,20,2,5,5,16,2,14,2,10,10,5,2,24,4,10,5,10,2,16,5,16,5,5,2,28,2,5,10,16,5,14,2,10,5,14,2,32,2,5,10,10,5,14,2,24,9,5,2,28,5,5,5,16,2,28,5", "code": " \n"}
{"sequence_id": "A140868", "text": "a(n) = floor(floor(n*alpha)*alpha) where alpha = 1+sqrt(2) = A014176.", "sequence": "4,9,16,21,28,33,38,45,50,57,62,67,74,79,86,91,98,103,108,115,120,127,132,137,144,149,156,161,168,173,178,185,190,197,202,207,214,219,226,231,236,243,248,255,260,267,272,277,284,289,296,301,306,313,318,325,330,337,342,347,354,359,366,371,376,383", "code": "\nfrom sympy import integer_nthroot\ndef A140868(n):\n    f = lambda n: n+integer_nthroot(2*n**2,2)[0]\n    return f(f(n)) \n"}
{"sequence_id": "A141255", "text": "Total number of line segments between points visible to each other in a square n X n lattice.", "sequence": "0,6,28,86,200,418,748,1282,2040,3106,4492,6394,8744,11822,15556,20074,25456,32086,39724,48934,59456,71554,85252,101250,119040,139350,161932,187254,215136,246690,280916,319346,361328,407302,457180,511714,570232", "code": "\nfrom sympy import totient\ndef A141255(n): return 2*(n-1)*(2*n-1) + 2*sum(totient(i)*(n-i)*(2*n-i) for i in range(2,n)) \n"}
{"sequence_id": "A141263", "text": "Lesser of a prime/emirp pair.", "sequence": "2,3,5,7,11,13,17,37,79,101,107,113,131,149,151,157,167,179,181,191,199,313,337,347,353,359,373,383,389,709,727,739,757,769,787,797,919,929,1009,1021,1031,1033,1061,1069,1091,1097,1103,1109,1151,1153,1181", "code": "\nfrom gmpy2 import next_prime, is_prime\nA141263_list, p = [], 1\nfor _ in range(1,10**4):\n....p = next_prime(p)\n....ps = int(str(p)[::-1])\n....if p <= ps and is_prime(ps):\n........A141263_list.append(int(p)) \n"}
{"sequence_id": "A141297", "text": "a(n) = number of distinct (nonempty) substrings in the binary representation of n.", "sequence": "1,3,2,5,5,5,3,7,8,7,8,8,8,7,4,9,11,11,12,11,9,11,11,11,12,11,11,11,11,9,5,11,14,15,16,14,15,16,16,15,15,11,14,16,14,15,14,14,16,16,16,16,14,14,15,15,16,15,15,14,14,11,6,13,17,19,20,19,20,21,21,19,17,19,21,20,21", "code": "\ndef a(n):\n  b = bin(n)[2:]\n  m = len(b)\n  return len(set(b[i:j] for i in range(m) for j in range(i+1, m+1)))\nprint([a(n) for n in range(1, 78)]) \n"}
{"sequence_id": "A141435", "text": "a(1) = 1, a(2) = 2; a(n) = a(n-a(1)) + a(n-a(2)) + a(n-a(3)) + a(n-a(4)) + ...", "sequence": "1,2,3,6,11,20,38,71,132,247,461,861,1609,3005,5613,10485,19584,36581,68330,127632,238404,445314,831798,1553712,2902170,5420945,10125754,18913838,35329048,65990929,123264078,230244265,430071949,803328933", "code": "\ndef A141435(terms):\n    seq = [1, 2]\n    for n in range(3, terms):\n        s = 0\n        for m in seq:\n            if (n - m) > 0:\n                s += seq[n - m - 1] \n        seq.append(s)\n    return seq\nprint(A141435(40)) \n"}
{"sequence_id": "A142954", "text": "a(n) = 2*n+3+3*(-1)^n.", "sequence": "2,10,6,14,10,18,14,22,18,26,22,30,26,34,30,38,34,42,38,46,42,50,46,54,50,58,54,62,58,66,62,70,66,74,70,78,74,82,78,86,82,90,86,94,90,98,94,102,98,106,102,110,106,114,110", "code": " for n in range(1,50): print(2*n+3+3*(-1)**n, end=', ') \n"}
{"sequence_id": "A142975", "text": "n-th term of the Fibonacci-type sequence x(1)=1, x(2)=Fibonacci(n), x(k+1)=x(k)+x(k-1) for k>1.", "sequence": "1,1,3,7,17,43,109,281,727,1891,4929,12871,33641,87985,230203,602447,1576849,4127635,10805301,28287049,74053871,193871371,507555073,1328785487,3478787857,9107556193,23843845299,62423922391,163427829137,427859414971,1120150172989", "code": "\ndef fib(arb1,arb2,nth):\n    if nth == 0:\n            return arb1\n    if nth == 1:\n            return arb2\n    x = [0]*nth\n    x[0] = arb1\n    x[1] = arb2\n    for i in range(2,nth,1):\n            x[i] = x[i-1]+x[i-2]\n    return x[-1]\ndef fib2d(n):\n    return fib(1,fib(1,1,n),n)\n[fib2d(i) for i in range(1,10)]\n\n"}
{"sequence_id": "A142994", "text": "Crystal ball sequence for the lattice C_5.", "sequence": "1,51,501,2471,8361,22363,50973,103503,192593,334723,550725,866295,1312505,1926315,2751085,3837087,5242017,7031507,9279637,12069447,15493449,19654139,24664509,30648559,37741809,46091811,55858661,67215511,80349081", "code": "\nA142994_list, m = [], [512, -768, 352, -48, 2, 1]\nfor _ in range(10**2):\n    A142994_list.append(m[-1])\n    for i in range(5):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A143010", "text": "Crystal ball sequence for the A4 x A4 lattice.", "sequence": "1,41,661,5741,33001,142001,494341,1465661,3833941,9073501,19789001,40328641,77620661,142282141,250054001,423621001,694880441,1107728161,1721435341,2614694501,3890418001,5681377241,8156775661,11529853541", "code": "\nA143010_list, m = [], [4900, -14700, 17500, -10500, 3340, -540, 40, 0, 1]\nfor _ in range(10**2):\n    A143010_list.append(m[-1])\n    for i in range(8):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A143077", "text": "a(n) is the n-th term of a pseudo-Fibonacci sequence created by applying the function fib(1,...,n) to itself n times.", "sequence": "1,1,4,31,485,27343,3595117,1359551201,1310562076858,3378072688461451,22702751567715567129,401359405793550977993221,18572242457139030215454649193,2252593125544789695036793639095505", "code": "\ndef fib(arb1, arb2, nth):\n    if nth == 0:\n        return arb1\n    if nth == 1:\n        return arb2\n    x = [0]*nth\n    x[0] = arb1\n    x[1] = arb2\n    for i in range(2, nth, 1):\n        x[i] = x[i-1]+x[i-2]\n    return x[-1]\ndef fib2d(n):\n    return fib(1, fib(1, 1, n), n)\ndef fib3d(n):\n    return fib(1, fib(1, fib(1, 1, n), n), n)\ndef slowfibnd(n): \n    begin = \"fib(1, 0+1, n)\"\n    for x in range(n-1):\n        begin = begin.replace('0+1', 'fib(1, 0+1, n)')\n    return eval(begin)\n"}
{"sequence_id": "A143089", "text": "a(n) = a(n - a(n-1)) + a(floor(2*n/3)).", "sequence": "1,1,2,3,3,5,4,6,7,6,7,9,10,10,9,11,12,14,13,14,14,15,15,18,16,18,21,17,22,20,21,21,24,21,25,25,25,26,28,30,28,27,33,29,31,30,33,30,37,34,33,38,34,39,36,39,40,42,40,44,40,43,41,48,45,43,49,44,46,51,47,46,58,48", "code": "\nfrom sympy import cacheit\n@cacheit\ndef A143089(n):\n    if n <= 1:\n        return 1\n    else:\n        return A143089(n-A143089(n-1))+A143089(2*n//3)\nprint([A143089(n) for n in range(40)]) \n"}
{"sequence_id": "A143270", "text": "a(n) = n*A002088(n).", "sequence": "1,4,12,24,50,72,126,176,252,320,462,552,754,896,1080,1280,1632,1836,2280,2560,2940,3300,3956,4320,5000,5512,6210,6776,7830,8340,9548,10368,11352,12240,13440,14256,15984,17100,18486,19600,21730,22764,25112", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A143270(n): \n    if n == 0:\n        return 0\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(2*A143270(k1)//k1-1)\n        j, k1 = j2, n//j2\n    return n*(n*(n-1)-c+j)//2 \n"}
{"sequence_id": "A143301", "text": "Decimal expansion of the Hall-Montgomery constant.", "sequence": "1,7,1,5,0,0,4,9,3,1,4,1,5,3,6,0,6,5,8,6,0,4,3,9,9,7,1,5,5,5,2,1,2,1,0,9,6,2,2,2,6,2,9,0,4,2,2,9,5,5,0,8,4,1,7,1,4,2,1,1,0,9,1,8,2,3,6,9,8,6,0,5,5,9,4,3,0,8,5,7,7,9,8,7,9,7,1,1,9,8,0,8,6,8,0,0,8,1,7,3,0,6,4,2,3", "code": "\nfrom mpmath import mp, pi, e, polylog, sqrt\nmp.dps=106\nprint([int(z) for z in list(str(1 + pi**2/6 + 2* polylog(2, - sqrt(e)))[2:-1])]) \n"}
{"sequence_id": "A143376", "text": "Triangle read by rows: T(n,k) is the number of unordered pairs of vertices at distance k in the cube Q_n of dimension n (1 <= k <= n).", "sequence": "1,4,2,12,12,4,32,48,32,8,80,160,160,80,16,192,480,640,480,192,32,448,1344,2240,2240,1344,448,64,1024,3584,7168,8960,7168,3584,1024,128,2304,9216,21504,32256,32256,21504,9216,2304,256,5120,23040,61440,107520", "code": "\nimport math\nf=math.factorial\ndef C(n,r): return f(n) / f(r) / f(n-r)\ni=1\nfor n in range(1,126):\n....for k in range(1,n+1):\n........print(str(i)+\" \"+str(2**(n-1)*C(n,k)))\n........i+=1 \n"}
{"sequence_id": "A143443", "text": "a(n) = n * A002321(n).", "sequence": "1,0,-3,-4,-10,-6,-14,-16,-18,-10,-22,-24,-39,-28,-15,-16,-34,-36,-57,-60,-42,-22,-46,-48,-50,-26,-27,-28,-58,-90,-124,-128,-99,-68,-35,-36,-74,-38,0,0,-41,-84,-129,-132", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A143443(n):\n    if n == 0:\n        return 0\n    c, j = n, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A143443(k1)//k1\n        j, k1 = j2, n//j2\n    return n*(j-c) \n"}
{"sequence_id": "A143959", "text": "Final digit of n^(n+1)-(n+1)^n for n>2", "sequence": "7,9,9,7,9,7,1,9,3,1,5,9,9,5,1,1,1,9,9,9,7,9,9,7,9,7,1,9,3,1,5,9,9,5,1,1,1,9,9,9,7,9,9,7,9,7,1,9,3,1,5,9,9,5,1,1,1,9,9,9,7,9,9,7,9,7,1,9,3,1,5,9,9,5,1,1,1,9,9,9,7,9,9,7,9,7,1,9,3,1,5,9,9,5,1,1,1,9,9,9", "code": " \n"}
{"sequence_id": "A143992", "text": "Numbers n such that the sum of the prime factors of n (counted with multiplicity) is a proper substring of n.", "sequence": "18,144,150,168,175,198,220,230,242,246,255,322,366,444,624,1166,1243,1323,1330,1331,1462,1480,1530,1992,2187,2230,2240,2406,2436,2625,2650,2673,2730,2744,2808,2925,3024,3125,3182,3264,3286,3366,3388,3420,3484", "code": "\nfrom sympy import factorint, isprime\nA143992_list = [n for n in range(2,10**6) if n != 4 and not isprime(n) and str(sum(a*b for a, b in factorint(n).items())) in str(n)] \n"}
{"sequence_id": "A144150", "text": "Square array A(n,k), n >= 0, k >= 0, read by antidiagonals, where the e.g.f. of column k is 1+g^(k+1)(x) with g = x-> exp(x)-1.", "sequence": "1,1,1,1,1,1,1,1,2,1,1,1,3,5,1,1,1,4,12,15,1,1,1,5,22,60,52,1,1,1,6,35,154,358,203,1,1,1,7,51,315,1304,2471,877,1,1,1,8,70,561,3455,12915,19302,4140,1,1,1,9,92,910,7556,44590,146115,167894,21147,1,1,1,10,117", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef A(n, k): return 1 if n==0 or k==0 else sum([binomial(n - 1, j - 1)*A(j, k - 1)*A(n - j, k) for j in range(1, n + 1)])\nfor n in range(51): print([A(k, n - k) for k in range(n + 1)]) \n"}
{"sequence_id": "A144161", "text": "Triangle read by rows: T(n,k) = number of simple graphs on n labeled nodes with k edges that are node-disjoint unions of undirected cycle subgraphs.", "sequence": "1,1,0,1,0,0,1,0,0,1,1,0,0,4,3,1,0,0,10,15,12,1,0,0,20,45,72,70,1,0,0,35,105,252,490,465,1,0,0,56,210,672,1960,3720,3507,1,0,0,84,378,1512,5880,16740,31563,30016,1,0,0,120,630,3024,14700,55800,157815,300160,286884", "code": "\nfrom sympy.core.cache import cacheit\nfrom operator import mul\nfrom functools import reduce\n@cacheit\ndef T(n, k): return 1 if k==0 else 0 if k<0 or n<k else T(n - 1, k) + sum([reduce(mul, [n - i for i in range(1, j + 1)])*T(n - 1 - j, k - j - 1) for j in range(2, k + 1)])//2\nfor n in range(21): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A144164", "text": "Number of simple graphs on n labeled nodes, where each maximally connected subgraph is either a tree or a cycle, also row sums of A144163, A215861.", "sequence": "1,1,2,8,45,338,3304,40485,602075,10576466,214622874,4941785261,127282939615,3625467047196,113140481638088,3838679644895477,140681280613912089,5538276165405744140,233086092164091031114,10443453353262112373541,496313160155209940833001", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial, prod\n@cacheit\ndef f(n, k): return 1 if k==0 else 0 if k<0 or n<=k else n**(n - 2) if k == n - 1 else sum(binomial(n - 1, j)*f(j + 1, j)*f(n - 1 - j, k - j) for j in range(k + 1))\n@cacheit\ndef c(n, k): return 1 if k==0 else 0 if k<0 or n<k else c(n - 1, k) + sum(prod(n - i for i in range(1, j + 1)) * c(n - 1 - j, k - j - 1) for j in range(2, k + 1))//2\ndef T(n, k): return f(n, k) + sum(binomial(n, j)*f(n - j, k - j)*c(j, j) for j in range(3, k + 1))\ndef a(n): return sum(T(n, k) for k in range(n + 1))\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A144255", "text": "Semiprimes of the form k^2+1.", "sequence": "10,26,65,82,122,145,226,362,485,626,785,842,901,1157,1226,1522,1765,1937,2026,2117,2305,2402,2501,2602,2705,3365,3482,3601,3722,3845,4097,4226,4762,5042,5777,6085,6242,6401,7226,7397,7745,8465,9026,9217,10001,10202", "code": "\nfrom sympy import primeomega\nfrom itertools import count, takewhile\ndef aupto(limit):\n    form = takewhile(lambda x: x <= limit, (k**2+1 for k in count(1)))\n    return [number for number in form if primeomega(number)==2]\nprint(aupto(10202)) \n"}
{"sequence_id": "A144752", "text": "Positive integers whose binary representation is a palindrome and has a prime number of 0's.", "sequence": "9,17,21,45,51,65,85,93,99,107,189,219,231,257,297,325,365,381,387,427,443,455,471,765,891,951,975,1105,1161,1241,1285,1365,1421,1501,1533,1539,1619,1675,1755,1787,1799,1879,1911,1935,1967,3069,3579,3831,3951", "code": "\nfrom sympy import isprime\ndef ok(n): b = bin(n)[2:]; return b == b[::-1] and isprime(b.count('0'))\nprint(list(filter(ok, range(4000)))) \n"}
{"sequence_id": "A144752", "text": "Positive integers whose binary representation is a palindrome and has a prime number of 0's.", "sequence": "9,17,21,45,51,65,85,93,99,107,189,219,231,257,297,325,365,381,387,427,443,455,471,765,891,951,975,1105,1161,1241,1285,1365,1421,1501,1533,1539,1619,1675,1755,1787,1799,1879,1911,1935,1967,3069,3579,3831,3951", "code": " \nfrom sympy import isprime\nfrom itertools import product\ndef ok2(bin_str): return isprime(bin_str.count(\"0\"))\ndef bin_pals(maxdigits):\n    yield from \"01\"\n    digits, midrange = 2, [[\"\"], [\"0\", \"1\"]]\n    for digits in range(2, maxdigits+1):\n        for p in product(\"01\", repeat=digits//2-1):\n            left = \"1\"+\"\".join(p)\n            for middle in midrange[digits%2]:\n                yield left + middle + left[::-1]\ndef auptopow2(e): return [int(b, 2) for b in filter(ok2, bin_pals(e))]\nprint(auptopow2(12)) \n"}
{"sequence_id": "A144753", "text": "Positive integers whose binary representation is a palindrome and has a prime number of 1's.", "sequence": "3,5,7,9,17,21,31,33,65,73,93,107,127,129,257,273,313,341,381,403,443,471,513,1025,1057,1137,1193,1273,1317,1397,1453,1571,1651,1707,1831,2047,2049,4097,4161,4321,4433,4593,4681,4841,4953,5189,5349,5461,5709", "code": "\nfrom sympy import isprime\ndef ok(n): b = bin(n)[2:]; return b == b[::-1] and isprime(b.count(\"1\"))\nprint(list(filter(ok, range(5710)))) \n"}
{"sequence_id": "A144753", "text": "Positive integers whose binary representation is a palindrome and has a prime number of 1's.", "sequence": "3,5,7,9,17,21,31,33,65,73,93,107,127,129,257,273,313,341,381,403,443,471,513,1025,1057,1137,1193,1273,1317,1397,1453,1571,1651,1707,1831,2047,2049,4097,4161,4321,4433,4593,4681,4841,4953,5189,5349,5461,5709", "code": " \nfrom sympy import isprime\nfrom itertools import product\ndef ok2(bin_str): return isprime(bin_str.count(\"1\"))\ndef bin_pals(maxdigits):\n    yield from \"01\"\n    digits, midrange = 2, [[\"\"], [\"0\", \"1\"]]\n    for digits in range(2, maxdigits+1):\n        for p in product(\"01\", repeat=digits//2-1):\n            left = \"1\"+\"\".join(p)\n            for middle in midrange[digits%2]:\n                yield left + middle + left[::-1]\ndef auptopow2(e): return [int(b, 2) for b in filter(ok2, bin_pals(e))]\nprint(auptopow2(13)) \n"}
{"sequence_id": "A144754", "text": "Integers that have a prime number of 0's in their binary expansion.", "sequence": "4,8,9,10,12,17,18,19,20,21,22,24,25,26,28,32,35,37,38,39,41,42,43,44,45,46,49,50,51,52,53,54,56,57,58,60,65,66,68,71,72,75,77,78,79,80,83,85,86,87,89,90,91,92,93,94,96,99,101,102,103,105,106,107,108,109,110", "code": "\nfrom sympy import isprime\ni=j=1\nwhile j<=250:\n    if isprime(bin(i)[2:].count(\"0\")):\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A144840", "text": "Numbers k such that the three numbers k-1, k+3 and k+5 are all prime.", "sequence": "8,14,38,68,98,104,194,224,278,308,458,614,824,854,878,1088,1298,1424,1448,1484,1664,1694,1784,1868,1874,1994,2084,2138,2378,2684,2708,2798,3164,3254,3458,3464,3848,4154,4514,4784,5228,5414,5438,5648,5654,5738", "code": "\nfrom sympy import isprime\ndef ok(n): return n > 4 and isprime(n-1) and isprime(n+3) and isprime(n+5)\nprint(list(filter(ok, range(5739)))) \n"}
{"sequence_id": "A144842", "text": "Numbers k such that the three numbers k+3, k-3 and k+5 are all prime.", "sequence": "8,14,26,56,104,134,176,194,236,266,566,596,656,824,1016,1226,1286,1484,1604,1616,1874,2084,2336,2546,2966,3254,3326,3464,3536,3764,3914,3926,4016,4214,4256,4646,4796,5006,5276,5474,5654,5846,5864,6266,6356,6566", "code": "\nfrom sympy import isprime\ndef ok(n): return n > 4 and isprime(n-3) and isprime(n+3) and isprime(n+5)\nprint(list(filter(ok, range(6567)))) \n"}
{"sequence_id": "A145203", "text": "a(n) = Primepi(A002407(n)).", "sequence": "4,8,12,18,31,58,67,78,101,115,157,260,279,297,337,361,406,449,500,578,604,688,716,808,907,937,1037,1146,1259,1407,1447,1577,1614,1926,2204,2253,2511,2613,2725,2772,2882,2992,3576,3762,4480", "code": "\nfrom sympy import isprime, primepi\nA145203_list = [primepi(3*n*(n+1)+1) for n in range(10**3) if isprime(3*n*(n+1)+1)] \n"}
{"sequence_id": "A145285", "text": "a(n) is the number of monomials in the n-th power of polynomial x^4-x^3-x^2-x-1.", "sequence": "5,8,12,16,20,25,28,32,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,101,105,109,113,117,121,125,129,133,137,141,145,149,153,157,161,165,169,173,177,181,185,189,193,197,201,205,209,213,217,221,225,229,233", "code": "\nfrom sympy import expand\nfrom sympy.abc import x\ndef A145285(n):\n    return len(expand((x**4-x**3-x**2-x-1)**n).as_terms()[0]) \n"}
{"sequence_id": "A145445", "text": "a(n) = the smallest square > n-th prime.", "sequence": "4,4,9,9,16,16,25,25,25,36,36,49,49,49,49,64,64,64,81,81,81,81,100,100,100,121,121,121,121,121,144,144,144,144,169,169,169,169,169,196,196,196,196,196,225,225,225,225,256,256,256,256,256,256,289,289,289,289", "code": "\nfrom sympy import prime, integer_nthroot\ndef a(n): return (integer_nthroot(prime(n), 2)[0]+1)**2\nprint([a(n) for n in range(1, 59)]) \n"}
{"sequence_id": "A145461", "text": "Numbers that can be written with a single digit in base 10 as well as in some base b<10.", "sequence": "0,1,2,3,4,5,6,7,8,9,777", "code": "\nfrom math import *\ni=1\nwhile i<(10**10-1)/9:\n    i=10*i+1\n    for m in range(1,10):\n        q=i*m\n        q2=q\n        for b in range(2,10):\n            restes=[]\n            q=q2\n            while q>0:\n                r=q%b\n                q=q//b\n                restes.append(r)\n            if restes==[restes[0]]*len(restes):\n                print(q2,restes,\"en base \",b)\n"}
{"sequence_id": "A145491", "text": "In these bases, there exist numbers written with only one distinct digit whose translation in binary is also written with the same lonely digit.", "sequence": "5,6,14,30,62,90,126,254,510,1022,2046,4094,8190", "code": " from math import *\n.for b1 in range(2,3):\n....for b2 in range(b1+1,10001):\n........for m in range(2,20):\n............for n in range(2,m+1):\n................if (1-b1**m)*(1-b2)==(1-b1)*(1-b2**n):\n....................print \"b1,b2=\",b1,b2,\" m,n=\",m,n\n"}
{"sequence_id": "A145551", "text": "Numbers k such that product of divisors of k / sum of divisors of k is an integer.", "sequence": "1,6,28,30,66,84,102,120,210,270,318,330,364,420,462,496,510,546,570,642,672,690,714,840,868,870,924,930,966,1080,1092,1122,1320,1410,1428,1488,1518,1590,1638,1722,1770,1782,1890,1932,2040,2130,2226,2280,2310", "code": "\nfrom sympy import divisor_sigma\nA145551_list = [n for n in range(1,10**3) if not n**divisor_sigma(n,0) % divisor_sigma(n,1)**2] \n"}
{"sequence_id": "A145642", "text": "Cubefree part of n!.", "sequence": "1,2,6,3,15,90,630,630,210,2100,23100,34650,450450,6306300,28028,7007,119119,2144142,40738698,101846745,230945,5080790,116858170,350574510,70114902,1822987452,1822987452,6380456082,185033226378,5550996791340", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import factorint\ndef A145642(n):\n....return 1 if n <=1 else reduce(mul,[p**(e % 3) for p,e in factorint(math.factorial(n)).items()])\n\n"}
{"sequence_id": "A145643", "text": "Cubefree part of n!!.", "sequence": "1,2,3,1,15,6,105,6,35,60,385,90,5005,1260,75075,315,1276275,210,24249225,525,509233725,11550,11712375675,34650,2342475135,900900,2342475135,3153150,67931778915,28028,2105885146365,14014,2573859623335", "code": "\nfrom sympy import factorint, prod\ndef A145643(n):\n    return 1 if n <= 1 else prod(p**(e % 3) for p, e in factorint(prod(range(n,0,-2))).items())\n\n"}
{"sequence_id": "A145679", "text": "Lower limit of backward value of 2^n and n!.", "sequence": "2,1,1,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0", "code": "\n\na,i=2,0; x=a\nwhile 1:\n     i+=1; print x, ',' ,\n     if a%2**(i+1) == 0: x=0\n     else: x=1; a+=10**i\n\n"}
{"sequence_id": "A145768", "text": "a(n) = the bitwise XOR of squares of first n natural numbers.", "sequence": "0,1,5,12,28,5,33,16,80,1,101,28,140,37,225,0,256,33,357,12,412,37,449,976,400,993,325,924,140,965,65,896,1920,961,1861,908,1692,965,1633,912,1488,833,1445,668,1292,741,2721,512,2816,609,2981,396,2844,485", "code": "\nfrom operator import xor\ndef A145768(n):\n....return reduce(xor, [x**2 for x in range(n+1)]) \n"}
{"sequence_id": "A145827", "text": "Numbers n such that A145768(n) is a square.", "sequence": "0,1,7,9,14,15,16,24,33,63,89,193,240,255,271,430,448,528,575,729,742,783,903,1297,1776,2409,2623,3494,4079,4159,5439,8278,13631,13737,16128,41825,53007,64344,95985,99015,100607,138238,147734,198976,256177,262079,262335,278847", "code": "\nimport math\nx = 0\nfor i in range(1<<20):\n    x ^= i*i\n    t = int(math.sqrt(x))\n    if x == t*t:\n        print(str(i), end=', ')\n\n"}
{"sequence_id": "A145828", "text": "Squares in A145768 (XOR of squares of the numbers 1...n).", "sequence": "0,1,16,1,225,0,256,400,961,256,2401,4225,50176,9216,9216,113569,20736,518400,160000,893025,390625,861184,685584,134689,861184,3568321,389376,6806881,12730624,12730624,4260096,105534529", "code": "\nfrom gmpy2 import is_square\nfilter(is_square, [reduce(lambda x,y:x^y, [x**2 for x in range(n)]) for n in range(1,10**4)]) \n"}
{"sequence_id": "A145913", "text": "a(n) = smallest integer k such that 1/log((1 + k)^(1/k)) is bigger than n.", "sequence": "1,3,6,10,14,18,22,27,32,37,42,47,52,57,63,68,74,79,85,91,97,102,108,114,120,126,133,139,145,151,157,164,170,176,183,189,196,202,209,216,222,229,235,242,249,256,262,269,276,283,290,297,304,310,317,324,331", "code": "\nimport math\ndef a(n):\n    k=1\n    while True:\n        if (1/math.log((1 + k)**(1/k))) > n: return k\n        else: k+=1\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A146971", "text": "Number of weight-n binary n X n matrices that yield the all-ones matrix after repeatedly changing a 0 having at least two 1-neighbors to a 1.", "sequence": "1,2,14,130,1615,23140,383820,7006916,140537609,3035127766", "code": " \n"}
{"sequence_id": "A147537", "text": "Numbers whose binary representation is the concatenation of 2n-1 digits 1 and n digits 0.", "sequence": "2,28,248,2032,16352,131008,1048448,8388352,67108352,536869888,4294965248,34359734272,274877898752,2199023239168,17592186011648,140737488289792,1125899906711552,9007199254478848,72057594037403648,576460752302374912,4611686018425290752", "code": "\ndef a(n): return ((1 << (2*n-1)) - 1) << n\nprint([a(n) for n in range(1, 22)]) \n"}
{"sequence_id": "A147538", "text": "Numbers whose binary representation is the concatenation of n 1's and 2n-1 digits 0.", "sequence": "2,24,224,1920,15872,129024,1040384,8355840,66977792,536346624,4292870144,34351349760,274844352512,2198889037824,17591649173504,140735340871680,1125891316908032,9007164895002624,72057456598974464,576460202547609600", "code": "\ndef a(n): return ((1 << n) - 1) << (2*n-1)\nprint([a(n) for n in range(1, 22)]) \n"}
{"sequence_id": "A147665", "text": "a(n) = a(a(n - 1)) + r(n) for n >= 3, where r(3*k) = a(a(k)), r(3*k+1) = a(a(k)) and r(3*k+2) = a(n-a(k)), with a(0) = 0 and a(1) = a(2) = 1.", "sequence": "0,1,1,2,2,3,3,3,5,4,3,6,4,3,6,5,5,9,6,5,12,6,5,15,8,8,11,8,7,11,8,7,14,9,7,14,8,7,10,5,5,13,6,6,13,6,6,9,7,6,9,8,9,17,12,7,12,7,6,15,9,8,14,9,7,18,9,7,12,9,9,16,10,8,14,11,11,15,11,12,13,8,10,14,9,7,15,11,12,15", "code": "\ndef A147665(n):\n    if n <= 2:\n        return [0, 1, 1][n]\n    elif n % 3 <= 1:\n        return A147665(A147665(n - 1)) + A147665(A147665(n // 3))\n    else:\n        return A147665(A147665(n - 1)) + A147665(n - A147665(n // 3))\nprint([A147665(n) for n in range(60)]) \n"}
{"sequence_id": "A147771", "text": "a(n) = round(n^(n/2)).", "sequence": "1,2,5,16,56,216,907,4096,19683,100000,534146,2985984,17403307,105413504,661735514,4294967296,28761784748,198359290368,1406563064942,10240000000000,76436817165460,584318301411328,4569515072723572", "code": "\nfrom gmpy2 import isqrt_rem\ndef A147771(n):\n    i, j = isqrt_rem(n**n)\n    return int(i+int(4*(j-i) >= 1)) \n"}
{"sequence_id": "A147773", "text": "a(n) = round((n^n)^(1/3)).", "sequence": "1,2,3,6,15,36,94,256,729,2154,6583,20736,67156,223150,759375,2642246,9387369,34012224,125537306,471556032,1801088541,6989288907,27536796143,110075314176,446169698824,1832746290156,7625597484987,32122422687591", "code": "\nfrom gmpy2 import iroot_rem\ndef A147773(n):\n    i, j = iroot_rem(n**n,3)\n    return int(i+int(8*j >= 6*i*(2*i+1)+1)) \n"}
{"sequence_id": "A147974", "text": "a(n) = n^3-((n-1)^3+(n-2)^3+(n-3)^3).", "sequence": "10,8,18,28,26,0,-62,-172,-342,-584,-910,-1332,-1862,-2512,-3294,-4220,-5302,-6552,-7982,-9604,-11430,-13472,-15742,-18252,-21014,-24040,-27342,-30932,-34822,-39024,-43550,-48412,-53622,-59192,-65134,-71460", "code": "\ndef a(n): return n**3-((n-1)**3+(n-2)**3+(n-3)**3)\nprint([a(n) for n in range(1, 37)]) \n"}
{"sequence_id": "A151413", "text": "Index at which n occurs in A160256, or -1 if n never occurs.", "sequence": "1,2,3,4,14,5,20,6,7,12,32,11,301,22,16,8,1065,9", "code": "\nfrom __future__ import division\nfrom fractions import gcd\ndef A151413(n):\n....if n <= 2:\n........return n\n....else:\n........l1, l2, m, b = 2, 1, 1, {1,2}\n........for j in range(3,10**9):\n............i = m\n............while True:\n................if not i in b:\n....................if i == n:\n........................return j\n....................l1, l2, m = i, l1, l1//gcd(l1,i)\n....................b.add(i)\n....................break\n................i += m\n........return \"search limit reached.\" \n"}
{"sequence_id": "A151799", "text": "Version 2 of the \"previous prime\" function: largest prime < n.", "sequence": "2,3,3,5,5,7,7,7,7,11,11,13,13,13,13,17,17,19,19,19,19,23,23,23,23,23,23,29,29,31,31,31,31,31,31,37,37,37,37,41,41,43,43,43,43,47,47,47,47,47,47,53,53,53,53,53,53,59,59,61,61,61,61,61,61,67,67,67,67,71,71,73,73,73,73", "code": "\nfrom sympy import prevprime\ndef A151799(n):\n    return prevprime(n) \n"}
{"sequence_id": "A151800", "text": "Least prime > n (version 2 of the \"next prime\" function).", "sequence": "2,2,3,5,5,7,7,11,11,11,11,13,13,17,17,17,17,19,19,23,23,23,23,29,29,29,29,29,29,31,31,37,37,37,37,37,37,41,41,41,41,43,43,47,47,47,47,53,53,53,53,53,53,59,59,59,59,59,59,61,61,67,67,67,67,67,67,71,71,71,71,73,73,79", "code": "\nfrom sympy import nextprime\ndef A151800(n):\n    return nextprime(n) \n"}
{"sequence_id": "A151842", "text": "a(3n)=n, a(3n+1)=2n+1, a(3n+2)=n+1.", "sequence": "0,1,1,1,3,2,2,5,3,3,7,4,4,9,5,5,11,6,6,13,7,7,15,8,8,17,9,9,19,10,10,21,11,11,23,12,12,25,13,13,27,14,14,29,15,15,31,16,16,33,17,17,35,18,18,37,19,19,39,20,20,41,21,21,43,22,22,45,23,23,47", "code": "\ndef pairup(x): return [x[i:i+2] for i in range(len(x)-1)]\ndef combine(vals): return sum(vals)\ndef expand(L,fn): return [(x[0],fn(x),x[1]) for x in pairup(L)]\nL = list(range(20))\nprint(expand(L,combine))\n"}
{"sequence_id": "A151949", "text": "a(n) = image of n under the Kaprekar map n -> (n with digits sorted into descending order) - (n with digits sorted into ascending order).", "sequence": "0,0,0,0,0,0,0,0,0,0,9,0,9,18,27,36,45,54,63,72,18,9,0,9,18,27,36,45,54,63,27,18,9,0,9,18,27,36,45,54,36,27,18,9,0,9,18,27,36,45,45,36,27,18,9,0,9,18,27,36,54,45,36,27,18,9,0,9,18,27,63,54,45,36,27,18,9,0,9,18,72,63,54,45,36,27,18,9,0,9,81,72,63,54,45,36,27,18,9,0,99,99,198,297,396,495,594,693,792,891,99,0,99,198,297,396,495,594,693,792", "code": "\ndef A151949(n):\n    return int(\"\".join(sorted(str(n),reverse=True)))-int(\"\".join(sorted(str(n)))) \n"}
{"sequence_id": "A151991", "text": "Numbers n with the property that (n-x)(n-y)(n-z) = xyz has no integer solutions 0 < x,y,z < n.", "sequence": "1,3,5,7,9,11,13,17,19,21,23,25,27,29,31,33,37,39,41,43,47,49,51,53,57,59,61,67,69,71,73,79,81,83,87,89,93,95,97,101,103,107,109,111,113,115,121,123,125,127,129,131,133,137,139,141,145,147,149,151,155,157,159", "code": "\ndef exis(n):\n    for x in range(1,n):\n        for y in range(x+1):\n            for z in range(y+1):\n                if x*y*z==(k-x)*(k-y)*(k-z):\n                    return True\n    return False\nfor k in range(1, 200, 2):\n    if not exis(k):\n        print(str(k), end=',')\n"}
{"sequence_id": "A152031", "text": "a(n) = n^5 + n^4 + n^3 + n^2 + n.", "sequence": "0,5,62,363,1364,3905,9330,19607,37448,66429,111110,177155,271452,402233,579194,813615,1118480,1508597,2000718,2613659,3368420,4288305,5399042,6728903,8308824,10172525,12356630,14900787,17847788,21243689,25137930,29583455", "code": " def a(n): return n**5 + n**4 + n**2 + n \n"}
{"sequence_id": "A152054", "text": "Bouncy numbers (numbers whose digits are in neither increasing nor decreasing order).", "sequence": "101,102,103,104,105,106,107,108,109,120,121,130,131,132,140,141,142,143,150,151,152,153,154,160,161,162,163,164,165,170,171,172,173,174,175,176,180,181,182,183,184,185,186,187,190,191,192,193,194,195,196", "code": "\na = 1\nb = 100\nwhile a != 51:\n    if str(b) != ''.join(sorted(str(b))) and str(b) != ''.join(sorted(str(b)))[::-1]:\n        print(b)\n        a += 1\n    b += 1\n\n"}
{"sequence_id": "A152147", "text": "Irregular triangle in which row n lists k > 0 such that the sum of digits of k^n equals k.", "sequence": "1,2,3,4,5,6,7,8,9,1,9,1,8,17,18,26,27,1,7,22,25,28,36,1,28,35,36,46,1,18,45,54,64,1,18,27,31,34,43,53,58,68,1,46,54,63,1,54,71,81,1,82,85,94,97,106,117,1,98,107,108,1,108,1,20,40,86,103,104,106,107,126,134,135", "code": "\ndef ok(k, r): return sum(map(int, str(k**r))) == k\ndef agen(rows, startrow=1, withzero=0):\n  for r in range(startrow, rows + startrow):\n    d, lim = 1, 1\n    while lim < r*9*d: d, lim = d+1, lim*10\n    yield from [k for k in range(1-withzero, lim+1) if ok(k, r)]\nprint([an for an in agen(13)]) \n"}
{"sequence_id": "A152423", "text": "A variation of the Josephus problem, removing every other person, starting with person 1; a(n) is the last person remaining.", "sequence": "1,2,2,4,2,4,6,8,2,4,6,8,10,12,14,16,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,2,4,6,8,10,12,14,16,18,20", "code": " m=len(bin(n))-3; print(n if 2**m==n else 2*(n-2**m)) \n"}
{"sequence_id": "A152925", "text": "a(n) = smallest number m such that in 1,2,..,m written in base n, no two of the n digits occurs the same number of times.", "sequence": "1,5,13,47,105,536,1341,9231,24697,212594,592269,6100559,17464969,209215572", "code": "\ndef different(d):\n    for i in range(len(d)):\n        for j in range(i):\n            if d[i] == d[j]:\n                return False\n    return True\ndef a(base):\n    d = [0] * base\n    n = 0\n    while True:\n        n += 1\n        m = n\n        while m > 0:\n            d[m % base] += 1\n            m //= base\n        if different(d):\n            break\n    return n\n"}
{"sequence_id": "A153000", "text": "Toothpick sequence in the first quadrant.", "sequence": "0,1,2,3,5,8,10,11,13,16,19,23,30,38,42,43,45,48,51,55,62,70,75,79,86,95,105,120,142,162,170,171,173,176,179,183,190,198,203,207,214,223,233,248,270,290,299,303,310,319,329,344,366,387", "code": "\ndef msb(n):\n    t=0\n    while n>>t>0: t+=1\n    return 2**(t - 1)\ndef a139250(n):\n    k=(2*msb(n)**2 + 1)//3\n    return 0 if n==0 else k if n==msb(n) else k + 2*a139250(n - msb(n)) + a139250(n - msb(n) + 1) - 1\ndef a(n): return 0 if n==0 else (a139250(n + 2) - 3)//4\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A153003", "text": "Toothpick sequence in the first three quadrants.", "sequence": "0,1,4,7,10,16,25,31,34,40,49,58,70,91,115,127,130,136,145,154,166,187,211,226,238,259,286,316,361,427,487,511,514,520,529,538,550,571,595,610,622,643,670,700,745,811,871,898,910,931", "code": "\ndef msb(n):\n    t=0\n    while n>>t>0: t+=1\n    return 2**(t - 1)\ndef a139250(n):\n    k=(2*msb(n)**2 + 1)/3\n    return 0 if n==0 else k if n==msb(n) else k + 2*a139250(n - msb(n)) + a139250(n - msb(n) + 1) - 1\ndef a(n): return 0 if n==0 else (a139250(n + 1) - 3)*3/4 + 1\n[a(n) for n in range(51)] \n"}
{"sequence_id": "A153045", "text": "Numbers k such that 2*k-11 is not a prime.", "sequence": "10,13,16,18,19,22,23,25,28,30,31,33,34,37,38,40,43,44,46,48,49,51,52,53,55,58,61,63,64,65,66,67,68,70,72,73,76,77,78,79,82,83,85,86,88,90,91,93,94,97,98,99,100,103,106,107,108,109,110,112,113,114", "code": "\nfrom sympy import isprime\ndef ok(n): return n > 6 and not isprime(2*n-11)\nprint(list(filter(ok, range(115)))) \n"}
{"sequence_id": "A153061", "text": "a(-1) = 2, a(n) = a(n-1)^2 + n.", "sequence": "4,17,291,84684,7171379860,51428689096413619605,2644910062175573125355281735337640356031,6995549236997594095768769895625713364190838574177475661857423797590740438072968", "code": "\ndef aupton(terms):\n  alst = [4]\n  for n in range(1, terms): alst.append(alst[-1]**2 + n)\n  return alst\nprint(aupton(8)) \n"}
{"sequence_id": "A153141", "text": "Permutation of nonnegative integers: A059893-conjugate of A153151.", "sequence": "0,1,3,2,7,6,4,5,15,14,12,13,8,9,10,11,31,30,28,29,24,25,26,27,16,17,18,19,20,21,22,23,63,62,60,61,56,57,58,59,48,49,50,51,52,53,54,55,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,127,126,124,125,120,121", "code": "\ndef ok(n): return n&(n - 1)==0\ndef a153151(n): return n if n<2 else 2*n - 1 if ok(n) else n - 1\ndef A(n): return (int(bin(n)[2:][::-1], 2) - 1)/2\ndef msb(n): return n if n<3 else msb(n/2)*2\ndef a059893(n): return A(n) + msb(n)\ndef a(n): return 0 if n==0 else a059893(a153151(a059893(n))) \n"}
{"sequence_id": "A153142", "text": "Permutation of nonnegative integers: A059893-conjugate of A153152.", "sequence": "0,1,3,2,6,7,5,4,12,13,14,15,10,11,9,8,24,25,26,27,28,29,30,31,20,21,22,23,18,19,17,16,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,40,41,42,43,44,45,46,47,36,37,38,39,34,35,33,32,96,97,98,99,100,101,102", "code": "\ndef ok(n): return n&(n - 1)==0\ndef a153152(n): return n if n<2 else (n + 1)/2 if ok(n + 1) else n + 1\ndef A(n): return (int(bin(n)[2:][::-1], 2) - 1)/2\ndef msb(n): return n if n<3 else msb(n/2)*2\ndef a059893(n): return A(n) + msb(n)\ndef a(n): return 0 if n==0 else  a059893(a153152(a059893(n))) \n"}
{"sequence_id": "A153151", "text": "Rotated binary decrementing: For n<2 a(n) = n, if n=2^k, a(n) = 2*n-1, otherwise a(n) = n-1.", "sequence": "0,1,3,2,7,4,5,6,15,8,9,10,11,12,13,14,31,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,63,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,127,64,65,66,67,68,69", "code": "\ndef ok(n): return n&(n - 1)==0\ndef a(n): return n if n<2 else 2*n - 1 if ok(n) else n - 1 \n"}
{"sequence_id": "A153152", "text": "Rotated binary incrementing: For n<2 a(n)=n, if n=(2^k)-1, a(n)=(n+1)/2, otherwise a(n)=n+1.", "sequence": "0,1,3,2,5,6,7,4,9,10,11,12,13,14,15,8,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,16,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,32,65,66,67,68,69,70,71,72", "code": "\ndef ok(n): return n&(n - 1)==0\ndef a(n): return n if n<2 else (n + 1)/2 if ok(n + 1) else n + 1 \n"}
{"sequence_id": "A153334", "text": "Number of zig-zag paths from top to bottom of an n X n square whose color is that of the top right corner.", "sequence": "1,1,4,8,24,52,136,296,720,1556,3624,7768,17584,37416,83024,175568,383904,807604,1746280,3657464,7839216,16357496,34812144,72407728,153204064,317777032,669108496,1384524656,2903267040,5994736336", "code": "\nimport math\ndef C(n,r):\n....f=math.factorial\n....return f(n)/f(r)/f(n-r)\ndef A153334(n):\n....if n%2==0: return str(int((n+1)*2**(n-2)-2*(n-1)*C(n-2,(n-2)/2)))\n....else: return str(int((n+1)*2**(n-2)-(n-1)*C(n-1,(n-1)/2))) \n"}
{"sequence_id": "A153335", "text": "Number of zig-zag paths from top to bottom of an n X n square whose color is not that of the top right corner.", "sequence": "0,1,2,8,18,52,116,296,650,1556,3372,7768,16660,37416,79592,175568,371034,807604,1697660,3657464,7654460,16357496,34106712,72407728,150499908,317777032,658707896,1384524656,2863150440,5994736336", "code": "\nimport math\ndef C(n, r):\n....f=math.factorial\n....return f(n)/f(r)/f(n-r)\ndef A153335(n):\n....if n%2==0: return str(int((n+1)*2**(n-2)-2*(n-1)*C(n-2, (n-2)/2)))\n....else: return str(int((n+1)*2**(n-2)-(n)*C(n-1, (n-1)/2))) \n"}
{"sequence_id": "A153336", "text": "Number of zig-zag paths from top to bottom of a 2n by 2n square whose color is that of the top right corner", "sequence": "1,8,52,296,1556,7768,37416,175568,807604,3657464,16357496,72407728,317777032,1384524656,5994736336,25816193952,110652549620,472302724408,2008499580504,8513063608304,35975584631128,151621915797840", "code": "\nimport math\ndef C(n,r):\n....f=math.factorial\n....return f(n)/f(r)/f(n-r)\ndef A153336(n):\n....return str((2*n+1)*2**(2*n-2)-2*(2*n-1)*C(2*n-2,n-1)) \n"}
{"sequence_id": "A153337", "text": "Number of zig-zag paths from top to bottom of a 2n-1 by 2n-1 square whose color is that of the top right corner", "sequence": "1,4,24,136,720,3624,17584,83024,383904,1746280,7839216,34812144,153204064,669108496,2903267040,12526343584,53779871552,229895033832,978965187184,4154438114480,17575883030496,74150192517808", "code": "\nimport math\ndef C(n,r):\n....f=math.factorial\n....return f(n)/f(r)/f(n-r)\ndef A153337(n):\n....return str(n*2**(2*n-2)-2*(n-1)*C(2*n-2,n-1)) \n"}
{"sequence_id": "A153338", "text": "Number of zig-zag paths from top to bottom of a 2n-1 by 2n-1 square whose color is not that of the top right corner.", "sequence": "0,2,18,116,650,3372,16660,79592,371034,1697660,7654460,34106712,150499908,658707896,2863150440,12371226064,53178791162,227561427612,969890051884,4119092850680,17438036501676,73611934643368,309935825654168,1301878616066736", "code": "\nimport math\ndef C(n,r):\n....f=math.factorial\n....return f(n)/f(r)/f(n-r)\ndef A153338(n):\n....return str(n*2**(2*n-2)-(2*n-1)*C(2*n-2,n-1)) \n"}
{"sequence_id": "A153429", "text": "Numbers k such that k! is equal to the sum of two consecutive primes.", "sequence": "4,5,27,77,102", "code": "\nfrom sympy import isprime, nextprime, prevprime\ndef ok(n):\n  if n <= 5: return n == 5\n  return not isprime(n//2) and n == prevprime(n//2) + nextprime(n//2)\ndef afind(limit):\n  factk = 1\n  for k in range(1, limit+1):\n    factk *= k\n    if ok(factk): print(k, end=\", \")\nafind(140) \n"}
{"sequence_id": "A153671", "text": "Minimal exponents m such that the fractional part of (101/100)^m obtains a maximum (when starting with m=1).", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,110,180,783,859,1803,7591,10763,19105,50172,355146,1101696,1452050,3047334,3933030", "code": "\nA153671_list, m, n, k, q = [], 1, 101, 100, 0\nwhile m < 10**4:\n    r = n % k\n    if r > q:\n        q = r\n        A153671_list.append(m)\n    m += 1\n    n *= 101\n    k *= 100\n    q *= 100 \n"}
{"sequence_id": "A153679", "text": "Minimal exponents m such that the fractional part of (1024/1000)^m obtains a maximum (when starting with m=1).", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,82,134,1306,2036,6393,34477,145984,2746739,2792428,8460321", "code": "\nA153679_list, m, n, k, q = [], 1, 1024, 1000, 0\nwhile m < 10**4:\n    r = n % k\n    if r > q:\n        q = r\n        A153679_list.append(m)\n    m += 1\n    n *= 1024\n    k *= 1000\n    q *= 1000 \n"}
{"sequence_id": "A153686", "text": "Numbers k such that the fractional part of (11/10)^k is less than 1/k.", "sequence": "1,2,3,17,37,48,237,420,599,615,6638,13885,13886,62963,1063942,9479731", "code": "\nA153686_list, k, k10, k11 =  [], 1, 10, 11\nwhile k < 10**6:\n    if (k11 % k10)*k < k10:\n        A153686_list.append(k)\n    k += 1\n    k10 *= 10\n    k11 *= 11 \n"}
{"sequence_id": "A153687", "text": "Minimal exponents m such that the fractional part of (11/10)^m obtains a maximum (when starting with m=1).", "sequence": "1,2,3,4,5,6,7,23,56,77,103,320,1477,1821,2992,15290,180168,410498,548816,672732,2601223", "code": "\nA153687_list, m, n, k, q = [], 1, 11, 10, 0\nwhile m < 10**4:\n    r = n % k\n    if r > q:\n        q = r\n        A153687_list.append(m)\n    m += 1\n    n *= 11\n    k *= 10\n    q *= 10 \n"}
{"sequence_id": "A153695", "text": "Minimal exponents m such that the fractional part of (10/9)^m obtains a maximum (when starting with m=1).", "sequence": "1,2,3,4,5,6,13,17,413,555,2739,3509,3869,5513,12746,31808,76191,126237,430116,477190,1319307,3596185", "code": "\nA153695_list, m, m10, m9, q = [], 1, 10, 9, 0\nwhile m < 10**4:\n    r = m10 % m9\n    if r > q:\n        q = r\n        A153695_list.append(m)\n    m += 1\n    m10 *= 10\n    m9 *= 9\n    q *= 9 \n"}
{"sequence_id": "A153745", "text": "Numbers k such that the number of digits d in k^2 is not prime and for each factor f of d the sum of the d/f digit groupings in k^2 of size f is a square.", "sequence": "1,2,3,39,60,86,90,321,347,401,3387,3414,3578,3900,4767,6000,6549,6552,6744,6780,6783,7387,7862,7889,8367,8598,8600,8773,8898,9000,9220,9884,9885,10000,10001,10002,10003,10004,10005,10010,10011,10012,10013,10020", "code": "\nfrom sympy import divisors\nfrom gmpy2 import is_prime, isqrt_rem, isqrt, is_square\nA153745_list = []\nfor l in range(1,20):\n....if not is_prime(l):\n........fs = divisors(l)\n........a, b = isqrt_rem(10**(l-1))\n........if b > 0:\n............a += 1\n........for n in range(a,isqrt(10**l-1)+1):\n............ns = str(n**2)\n............for g in fs:\n................y = 0\n................for h in range(0,l,g):\n....................y += int(ns[h:h+g])\n................if not is_square(y):\n....................break\n............else:\n................A153745_list.append(n) \n"}
{"sequence_id": "A153789", "text": "First differences of harmonic (or Ore) numbers A001599.", "sequence": "5,22,112,130,226,176,966,1332,3230,1928,62,10410,20,9226,2394,2520,23100,49804,12136,49600,6200,63910,4550,90580,27720,179040,156120,30660,27300,197496,138294,332010,118440,638820,50960,60760,166740", "code": "\nfrom numpy import diff\nfrom sympy import divisor_sigma as sigma\ndef ore(n): return (n*sigma(n, 0))%sigma(n, 1) == 0\nprint(diff(list(filter(ore, range(1, 9000))))) \n"}
{"sequence_id": "A153806", "text": "Strobogrammatic cyclops numbers.", "sequence": "0,101,609,808,906,11011,16091,18081,19061,61019,66099,68089,69069,81018,86098,88088,89068,91016,96096,98086,99066,1110111,1160911,1180811,1190611,1610191,1660991,1680891,1690691,1810181,1860981", "code": "\nimport sys\nf = open('b153806.txt', 'w')\ni = 1\nn = 0\na = [\"\"]\nr = [\"\"]  \nwhile True:\n....for x,y in zip(a,r):\n........f.write(str(i)+\" \"+x+\"0\"+y+\"\\n\")\n........i += 1\n........if i>20000:\n............f.close()\n............sys.exit()\n....a = sum([[x+\"1\",x+\"6\",x+\"8\",x+\"9\"] for x in a],[])\n....r = sum([[\"1\"+x,\"9\"+x,\"8\"+x,\"6\"+x] for x in r],[])\n\n"}
{"sequence_id": "A153816", "text": "a(n) = Sum_{i=1..(10^n-1)/9} floor(((10^n-1)/9)/i).", "sequence": "1,29,542,7967,105225,1308095,15639310,181976675,2075608136,23314508721,258729364359,2843136431305,30989792180446,335482200606705,3610664794156597,38665075822637767,412235037037411453,4378193158484415385,46340359465948601163", "code": "\ndef a(n): t = (10**n-1)//9; return sum(t//i for i in range(1, t+1))\nprint([a(n) for n in range(1, 10)]) \n"}
{"sequence_id": "A153823", "text": "Number of proper divisors of n!.", "sequence": "0,0,1,3,7,15,29,59,95,159,269,539,791,1583,2591,4031,5375,10751,14687,29375,41039,60799,95999,191999,242879,340031,532223,677375,917279,1834559,2332799,4665599,5529599,7864319,12165119,16422911", "code": "\nfrom sympy import factorial, divisor_count\ndef A153823(n):\n    return divisor_count(factorial(n))-1 \n"}
{"sequence_id": "A153880", "text": "Shift factorial base representation left by one digit.", "sequence": "0,2,6,8,12,14,24,26,30,32,36,38,48,50,54,56,60,62,72,74,78,80,84,86,120,122,126,128,132,134,144,146,150,152,156,158,168,170,174,176,180,182,192,194,198,200,204,206,240,242,246,248,252,254,264,266,270,272", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623((n//p), p+1)*10 + n%p\ndef a(n):\n    x = (str(a007623(n)) + '0')[::-1]\n    return 0 if n==0 else sum(int(x[i])*f(i + 1) for i in range(len(x)))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A153976", "text": "a(n) = n^3 + (n+2)^3.", "sequence": "8,28,72,152,280,468,728,1072,1512,2060,2728,3528,4472,5572,6840,8288,9928,11772,13832,16120,18648,21428,24472,27792,31400,35308,39528,44072,48952,54180,59768,65728,72072,78812,85960,93528,101528,109972,118872,128240", "code": "\ndef a(n): return n**3 + (n+2)**3\nprint([a(n) for n in range(40)]) \n"}
{"sequence_id": "A154435", "text": "Permutation of nonnegative integers induced by Lamplighter group generating wreath recursion, variant 3: a = s(b,a), b = (a,b), starting from the state a.", "sequence": "0,1,3,2,6,7,5,4,13,12,14,15,10,11,9,8,26,27,25,24,29,28,30,31,21,20,22,23,18,19,17,16,53,52,54,55,50,51,49,48,58,59,57,56,61,60,62,63,42,43,41,40,45,44,46,47,37,36,38,39,34,35,33,32,106,107,105,104,109,108", "code": "\nfrom sympy import floor\ndef a006068(n):\n    s=1\n    while True:\n        ns=n>>s\n        if ns==0: break\n        n=n^ns\n        s<<=1\n    return n\ndef a054429(n): return 1 if n==1 else 2*a054429(floor(n/2)) + 1 - n%2\ndef a(n): return 0 if n==0 else a054429(a006068(a054429(n))) \n"}
{"sequence_id": "A154436", "text": "Permutation of nonnegative integers induced by Lamplighter group generating wreath recursion, variant 1: a = s(a,b), b = (a,b), starting from the state a.", "sequence": "0,1,3,2,7,6,4,5,15,14,12,13,9,8,10,11,31,30,28,29,25,24,26,27,19,18,16,17,21,20,22,23,63,62,60,61,57,56,58,59,51,50,48,49,53,52,54,55,39,38,36,37,33,32,34,35,43,42,40,41,45,44,46,47,127,126,124,125,121,120", "code": "\nfrom sympy import floor\ndef a003188(n): return n^(n>>1)\ndef a054429(n): return 1 if n==1 else 2*a054429(floor(n/2)) + 1 - n%2\ndef a(n): return 0 if n==0 else a054429(a003188(a054429(n))) \n"}
{"sequence_id": "A154951", "text": "Found by taking the tree defined by the Hofstadter H-sequence (A005374), mirroring it left to right and relabeling the nodes so they increase left to right. a(n) is the parent node of node n in the tree so constructed.", "sequence": "0,1,1,2,3,4,4,5,6,6,7,8,9,9,10,10,11,12,13,13,14,15,15,16,16,17,18,19,19,20,21,22,22,23,24,24,25,25,26,27,28,28,29,29,30,31,32,32,33,34,35,35,36,37,37,38,38,39,40,41,41,42,43,43,44,44,45,46,47,47", "code": " \n\ndef hflip_iter():\n    yield 0\n    yield 1\n    \n    queue = [(1, 1)]\n    n = 2\n    while True:\n        parent, state = queue.pop(0)\n        yield parent\n        if state == 0:\n            \n            queue.append((n, 1))\n            queue.append((n, 0))\n        elif state == 1:\n            \n            queue.append((n, 2))\n        elif state == 2:\n            \n            queue.append((n, 0))\n        n += 1\ni = hflip_iter()\nfor n in range(0, 10001):\n    print(\"%d %d\" % (n, next(i)))\n"}
{"sequence_id": "A155011", "text": "Sophie Germain Fibonacci prime numbers.", "sequence": "2,3,5,89,233,10597999265301490732599643671505003412515860435409421932560009680142974347195483140293254396195769876129909", "code": "\nfrom gmpy2 import is_prime\nA155011_list = []\na, b, a2, b2 = 0, 1, 1, 3\nfor _ in range(10**6):\n    if is_prime(b) and is_prime(b2):\n        A155011_list.append(b)\n    a, b, a2, b2 = b, a+b, b2, a2+b2-1 \n"}
{"sequence_id": "A155012", "text": "Fibonacci prime numbers f, 3*f+2 are also primes.", "sequence": "3,5,13,89,233,1597,514229,99194853094755497,19134702400093278081449423917", "code": "\nfrom gmpy2 import is_prime\nA155012_list = []\na, b, a2, b2 = 0, 1, 2, 5\nfor _ in range(10**3):\n    if is_prime(b) and is_prime(b2):\n        A155012_list.append(b)\n    a, b, a2, b2 = b, a+b, b2, a2+b2-2 \n"}
{"sequence_id": "A155043", "text": "a(0)=0; for n >= 1, a(n) = 1 + a(n-d(n)), where d(n) is the number of divisors of n (A000005).", "sequence": "0,1,1,2,2,3,2,4,3,3,3,4,3,5,4,5,5,6,4,7,5,7,5,8,6,6,6,9,6,10,6,11,7,11,7,12,10,13,8,13,8,14,8,15,9,14,9,15,9,10,10,16,10,17,10,17,10,18,11,19,10,20,12,19,19,21,12,22,13,22,13,23,11,24,14,23,14,25,14,26,14,15,15", "code": "\nfrom sympy import divisor_count as d\ndef a(n): return 0 if n==0 else 1 + a(n - d(n))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A155146", "text": "Numbers n such that n^3 has exactly 3 different digits.", "sequence": "5,6,8,9,14,15,30,36,40,62,70,92,101,110,173,192,211,300,400,700,888,1001,1010,1100,1920,3000,3543,4000,7000,8880,10001,10010,10100,11000,19200,30000,35430,40000,70000,88800,100001,100010,100100,101000,110000,110011", "code": "\nA155146_list, n3, m = [], 0, 0\nfor n in range(1,10**7):\n....m += 6*(n-1)\n....n3 += m + 1\n....if len(set(str(n3))) == 3:\n........A155146_list.append(n) \n"}
{"sequence_id": "A155148", "text": "Numbers n such that n^4 has exactly 2 different decimal digits.", "sequence": "2,3,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000", "code": "\nA155148_list, m = [], [24, -36, 14, -1, 0]\nfor n in range(1,10**6+1):\n....for i in range(4):\n........m[i+1] += m[i]\n....if len(set(str(m[-1]))) == 2:\n........A155148_list.append(n) \n"}
{"sequence_id": "A155149", "text": "Numbers n such that n^4 has exactly 3 different decimal digits.", "sequence": "4,5,9,11,16,20,30,34,200,300,2000,3000,20000,30000,200000,300000,2000000,3000000,20000000,30000000,200000000,300000000", "code": "\nA155149_list = [n for n in range(1,10**6) if len(set(str(n**4))) == 3]\n\n"}
{"sequence_id": "A155150", "text": "Numbers n such that n^4 has exactly 4 distinct decimal digits.", "sequence": "6,7,8,15,19,21,24,27,28,36,39,40,42,46,50,52,57,64,67,69,70,80,85,88,90,101,110,131,150,160,183,190,202,203,340,400,433,500,570,670,700,800,843,850,900,1001,1010,1100,1171,1500,1600,1900,2673,2868,3400,4000", "code": "\nA155150_list, m = [], [24, -36, 14, -1, 0]\nfor n in range(1,10**3+1):\n....for i in range(4):\n........m[i+1] += m[i]\n....if len(set(str(m[-1]))) == 4:\n........A155150_list.append(n) \n"}
{"sequence_id": "A155578", "text": "Intersection of A000404 and A155717: N = a^2 + b^2 = c^2 + 7*d^2 for some positive integers a,b,c,d.", "sequence": "8,29,32,37,53,72,109,113,116,128,137,148,149,193,197,200,212,232,233,261,277,281,288,296,317,333,337,373,389,392,400,401,421,424,436,449,452,457,464,477,512,541,548,557,569,592,596,613,617,641,648,653,673", "code": "\nfrom math import isqrt\ndef aupto(limit):\n    cands = range(1, isqrt(limit)+1)\n    left =  set(a**2 +   b**2 for a in cands for b in cands)\n    right = set(c**2 + 7*d**2 for c in cands for d in cands)\n    return sorted(k for k in left & right if k <= limit)\nprint(aupto(673)) \n"}
{"sequence_id": "A155717", "text": "Numbers of the form N = a^2 + 7b^2 for some positive integers a,b.", "sequence": "8,11,16,23,29,32,37,43,44,53,56,64,67,71,72,77,79,88,92,99,107,109,112,113,116,121,127,128,137,144,148,149,151,161,163,172,176,179,184,191,193,197,200,203,207,211,212,224,232,233,239,253,256,259,261,263,268", "code": "\ndef aupto(limit):\n    cands = range(1, int(limit**.5)+2)\n    nums = [a**2 + 7*b**2 for a in cands for b in cands]\n    return sorted(set(k for k in nums if k <= limit))\nprint(aupto(268)) \n"}
{"sequence_id": "A155764", "text": "Records in A047160.", "sequence": "0,1,3,9,15,18,21,27,33,39,42,45,48,75,87,93,117,120,135,138,168,183,210,228,300,333,369,393,453,525,621,720,810,846,1086,1281,1305,1515,1590,1617,1722,1794,1833,1851,2010,2064,2085,2112,2217,2352,2754,2784", "code": "\nfrom sympy import isprime\na_rec = -1\nm = 2\nwhile 1:\n    a = 0\n    while a < m - 1:\n        if isprime(m-a) == 1 and isprime(m+a) == 1:\n            if a > a_rec:\n                print(a)\n                a_rec = a\n            break\n        a += 1\nm += 1 \n"}
{"sequence_id": "A155875", "text": "Smallest positive composite number such that a(n) - n is also composite.", "sequence": "4,9,6,9,8,9,10,15,12,15,14,15,16,21,18,21,20,21,22,25,24,25,26,27,28,33,30,33,32,33,34,35,36,39,38,39,40,45,42,45,44,45,46,49,48,49,50,51,52,55,54,55,56,57,58,63,60,63,62,63,64,65,66,69,68,69,70", "code": "\nfrom sympy import isprime\ndef composite(n): return n >= 4 and not isprime(n)\ndef a(n):\n  an = n + 4\n  while not (composite(an) and composite(an-n)): an += 1\n  return an\nprint([a(n) for n in range(67)]) \n"}
{"sequence_id": "A155879", "text": "a(0) = 4; for n > 0, a(n) is the smallest composite number c > a(n-1) such that c - n is also composite.", "sequence": "4,9,10,12,14,15,16,21,22,24,25,26,27,28,30,33,34,35,36,39,40,42,44,45,46,49,50,51,52,54,55,56,57,58,60,62,63,64,65,66,68,69,70,75,76,77,78,80,81,82,84,85,86,87,88,90,91,92,93,94,95,96,98,99,100,104,105,106,108", "code": "\nfrom sympy import isprime\ndef composite(n): return n >= 4 and not isprime(n)\ndef aupton(nn):\n  alst = [4]\n  for n in range(1, nn+1):\n    an = max(alst[-1] + 1, n + 4)\n    while not (composite(an) and composite(an-n)): an += 1\n    alst.append(an)\n  return alst\nprint(aupton(68)) \n"}
{"sequence_id": "A155944", "text": "Jacobsthal numbers A001045, every second term incremented by 1.", "sequence": "0,2,1,4,5,12,21,44,85,172,341,684,1365,2732,5461,10924,21845,43692,87381,174764,349525,699052,1398101,2796204,5592405,11184812,22369621,44739244,89478485,178956972,357913941,715827884,1431655765,2863311532,5726623061,11453246124,22906492245", "code": " print([(2**n + 1)//3 + n%2 for n in range(40)]) \n"}
{"sequence_id": "A156200", "text": "Primes that contain all the digits {0,6,8,9} and only these digits.", "sequence": "6089,8069,8609,60089,60689,60869,60889,60899,66089,66809,68099,68909,69809,80669,86069,88069,88609,89069,600689,600889,606899,608089,608099,608609,608669,608899,608989,608999,609809,609989,660809,660899,666089", "code": "\nfrom itertools import product\nfrom gmpy2 import is_prime\nA156200_list = [int(''.join(d)) for l in range(4,10) for d in product('0689',repeat=l) if d[0] != '0' and len(set(d)) == 4 and is_prime(int(''.join(d)))] \n"}
{"sequence_id": "A156202", "text": "a(n) = 2*a(n-1)+3 for n > 1, a(1) = 10.", "sequence": "10,23,49,101,205,413,829,1661,3325,6653,13309,26621,53245,106493,212989,425981,851965,1703933,3407869,6815741,13631485,27262973,54525949,109051901,218103805,436207613,872415229,1744830461,3489660925,6979321853,13958643709", "code": "\nfrom itertools import accumulate\ndef f(an, _): return 2*an + 3\nprint(list(accumulate([10]*31, f))) \n"}
{"sequence_id": "A156207", "text": "Sum of the products of the digits in n and their position m in n.", "sequence": "1,2,3,4,5,6,7,8,9,1,3,5,7,9,11,13,15,17,19,2,4,6,8,10,12,14,16,18,20,3,5,7,9,11,13,15,17,19,21,4,6,8,10,12,14,16,18,20,22,5,7,9,11,13,15,17,19,21,23,6,8,10,12,14,16,18,20,22,24,7,9,11,13,15,17,19,21,23,25,8,10", "code": "\ndef A156207(n):\n....s=0\n....for i in range(len(str(n))):\n........s+=(i+1)*int(x[i])\n....return s \n"}
{"sequence_id": "A156238", "text": "Smallest heptagonal number with n distinct prime factors.", "sequence": "7,18,286,3010,32890,769230,3333330,159189030,16015883940,477463360374,21643407275490,1148540321999070,18489352726664820,4561561662153109614,71000485538666794110,14440652550858108745170,927869754030522488795610", "code": "\nfrom sympy import primefactors\ndef A000566(n): return n*(5*n-3)//2\ndef a(n):\n    k = 1\n    while len(primefactors(A000566(k))) != n: k += 1\n    return A000566(k)\nprint([a(n) for n in range(1, 9)]) \n"}
{"sequence_id": "A156238", "text": "Smallest heptagonal number with n distinct prime factors.", "sequence": "7,18,286,3010,32890,769230,3333330,159189030,16015883940,477463360374,21643407275490,1148540321999070,18489352726664820,4561561662153109614,71000485538666794110,14440652550858108745170,927869754030522488795610", "code": " \nfrom sympy import primefactors\ndef A000566(n): return n*(5*n-3)//2\ndef A000566_distinct_factors(n):\n    pf1 = primefactors(n)\n    pf2 = primefactors(5*n-3)\n    combined = set(pf1) | set(pf2)\n    return len(combined) if n%4 == 0 or (5*n-3)%4 == 0 else len(combined)-1\ndef a(n):\n    k = 1\n    while A000566_distinct_factors(k) != n: k += 1\n    return A000566(k)\nprint([a(n) for n in range(1, 10)]) \n"}
{"sequence_id": "A156239", "text": "Smallest octagonal number with n distinct prime factors.", "sequence": "8,21,280,1680,38760,326040,10986360,185040240,4897368840,383246454360,13143876816840,376306806515640,27961718389364760,3250163645572822440,152582219844376633080,6202664616058189439160,1454199694916714984358120", "code": "\nfrom sympy import primefactors\ndef octagonal(n): return n*(3*n - 2)\ndef a(n):\n    k = 1\n    while len(primefactors(octagonal(k))) != n: k += 1\n    return octagonal(k)\nprint([a(n) for n in range(1, 10)]) \n"}
{"sequence_id": "A156239", "text": "Smallest octagonal number with n distinct prime factors.", "sequence": "8,21,280,1680,38760,326040,10986360,185040240,4897368840,383246454360,13143876816840,376306806515640,27961718389364760,3250163645572822440,152582219844376633080,6202664616058189439160,1454199694916714984358120", "code": " \nfrom sympy import primefactors, primorial\ndef A000567(n): return n*(3*n-2)\ndef A000567_distinct_factors(n):\n    return len(set(primefactors(n)) | set(primefactors(3*n-2)))\ndef a(n):\n    k, lb = 1, primorial(n)\n    while A000567(k) < lb: k += 1\n    while A000567_distinct_factors(k) != n: k += 1\n    return A000567(k)\nprint([a(n) for n in range(1, 10)]) \n"}
{"sequence_id": "A156320", "text": "List of prime pairs of the form (p, p+8).", "sequence": "3,11,5,13,11,19,23,31,29,37,53,61,59,67,71,79,89,97,101,109,131,139,149,157,173,181,191,199,233,241,263,271,269,277,359,367,389,397,401,409,431,439,449,457,479,487,491,499,563,571,569,577,593,601,599,607,653,661,683,691,701", "code": "\nfrom sympy import isprime, primerange\nfor pn in primerange(1,300):\n    if isprime(pn+8):\n        print(pn, pn+8)\n\n"}
{"sequence_id": "A156353", "text": "A symmetrical powers triangle sequence: t(n,m) = (m^(n - m) + (n - m)^m).", "sequence": "2,3,3,4,8,4,5,17,17,5,6,32,54,32,6,7,57,145,145,57,7,8,100,368,512,368,100,8,9,177,945,1649,1649,945,177,9,10,320,2530,5392,6250,5392,2530,320,10,11,593,7073,18785,23401,23401,18785,7073,593,11,12,1124,20412", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\nm=((t*t+3*t+4)/2-n)**(n-t*(t+1)/2)+(n-t*(t+1)/2)**((t*t+3*t+4)/2-n)\n\n"}
{"sequence_id": "A156703", "text": "String of digits encountered in decimal expansion of successive ratios k/(k+1), treating only non-repeating expansions, with decimal point and leading and trailing zeros removed.", "sequence": "5,75,8,875,9,9375,95,96,96875,975,98,984375,9875,99,992,9921875,99375,995,996,99609375,996875,9975,998,998046875,9984,9984375,99875,999,9990234375,9992,99921875,999375,9995,99951171875,9996,999609375,99968,9996875,99975", "code": "\nimport string,copy\nfrom decimal import *\ngetcontext().prec = 200\nmaxx=1000\nn=1\nmaxLen=0\nwhile n<maxx:\n    q=Decimal(n)/Decimal(n+1)\n    ratio=str(q)\n    myLen=len(ratio)\n    ratio.replace(\" \",\"\")\n    if len(ratio[2:])<15:\n        print(ratio[2:])\n    else:\n        strCopy=copy.copy(ratio[2:])\n        match=0\n        maxCnt=0\n        keyStr=' '\n        subLen=n\n        cap=len(ratio[2:])\n        for j5 in range(0,cap ):\n            for i5 in range(subLen,1,-1):\n                if i5<=j5:\n                    break\n                subStr=strCopy[j5:i5]\n                if len(subStr)<1:\n                    continue\n                match=strCopy.count(subStr)\n                z=match*len(subStr)\n                if z>maxCnt and match>1:\n                    if len(subStr)==1 and z<subLen:\n                        maxCnt=z\n                        keyStr=copy.copy(subStr)\n                    else:\n                        maxCnt=z\n                        keyStr=copy.copy(subStr)\n        if maxCnt>4:\n            pass\n        else:\n            print(ratio[2:])\n        getcontext().prec = max(2*subLen,200)\n    n+=1\n\n"}
{"sequence_id": "A156903", "text": "Abundant numbers (A005101) whose abundance is odd.", "sequence": "18,36,72,100,144,162,196,200,288,324,392,400,450,576,648,784,800,882,900,968,1152,1296,1352,1458,1568,1600,1764,1800,1936,2178,2304,2450,2500,2592,2704,2916,3042,3136,3200,3528,3600,3872,4050,4356,4608,4624", "code": "\nfrom sympy.ntheory import divisor_sigma\ndef a(n):\n    return divisor_sigma(n) - 2*n\n[n for n in range(18, 5001) if a(n) > 0 and a(n) % 2] \n"}
{"sequence_id": "A157238", "text": "0-1 sequence generated by starting with a 0, and then by using whichever of 0, 1 will result in the shortest sequence repeated at the end.", "sequence": "0,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,0,1,0,0,1,1,0,1,1,1,0,0,1,0,1,1,0,0", "code": "\nx = [0]\nwhile len(x) < 1000:\n    t = x[-1]\n    z = 1\n    while 2 * z + 1 <= len(x):\n        if x[-z:] == x[-(2 * z + 1) : -(z + 1)]:\n            t = x[-(z + 1)]\n        z += 1\n    x.append(1 - t)\nprint(x)\n"}
{"sequence_id": "A157712", "text": "Smallest prime made up of 0's and prime(n) 1's (or 0 when no such prime exists).", "sequence": "11,0,101111,11110111,101111111111,101101111111111,101111111111111111,1111111111111111111,11111111111111111111111,111110111111111111111111111111,11111101111111111111111111111111", "code": "\nfrom __future__ import division\nfrom itertools import combinations\nfrom sympy import prime, isprime\ndef A157712(n):\n    if n == 1:\n        return 11\n    if n == 2:\n        return 0\n    p = prime(n)\n    l = p\n    while True:\n        for i in combinations(range(l),l-p):\n            s = ['1']*l\n            for x in i:\n                s[x] = '0'\n            q = int(''.join(s))\n            if isprime(q):\n                return q\n        l += 1 \n"}
{"sequence_id": "A157799", "text": "Numerator of Bernoulli(n, 1/3).", "sequence": "1,-1,-1,1,13,-5,-121,49,1093,-809,-49205,20317,61203943,-722813,-5580127,34607305,25949996501,-2145998417,-2832495743227,167317266613,101471818419863,-16020403322021,-4469253897850313,1848020950359841,11126033443528968583,-252778977216700025", "code": "\nfrom sympy import bernoulli, Integer\ndef a(n): return bernoulli(n, 1/Integer(3)).numerator() \n"}
{"sequence_id": "A157800", "text": "Denominator of Bernoulli(n, 1/3).", "sequence": "1,6,18,27,810,243,10206,2187,65610,19683,1299078,177147,483611310,1594323,9565938,14348907,7317942570,129140163,103053850074,1162261467,383546284110,10460353203,1443528742014,94143178827,257010878197710", "code": "\nfrom sympy import bernoulli, Integer\ndef a(n): return bernoulli(n, 1/Integer(3)).denominator() \n"}
{"sequence_id": "A157807", "text": "Numerators of fractions arranged in Cantor's ordering (1/1, 2/1, 1/2, 1/3, 3/1, 4/1, 3/2, 2/3, 1/4, 1/5, 5/1, 6/1, 5/2, ...) with equivalent fractions removed.", "sequence": "1,2,1,1,3,4,3,2,1,1,5,6,5,4,3,2,1,1,3,5,7,8,7,5,4,2,1,1,3,7,9,10,9,8,7,6,5,4,3,2,1,1,5,7,11,12,11,10,9,8,7,6,5,4,3,2,1,1,3,5,9,11,13,14,13,11,8,7,4,2,1,1,3,5,7,9,11,13,15,16,15,14", "code": "\nfrom fractions import gcd\nfor s in range(2, 100, 2):\n..for i in range(1, s):\n....if gcd(i, s - i) != 1: continue\n....print(i)\n..for i in range(s, 0, -1):\n....if gcd(i, s + 1 - i) != 1: continue\n....print(i)\n\n"}
{"sequence_id": "A157813", "text": "Denominators of fractions arranged in Cantor's ordering (1/1, 2/1, 1/2, 1/3, 3/1, 4/1, 3/2, 2/3, 1/4, 1/5, 5/1, 6/1, 5/2, ...) with equivalent fractions removed.", "sequence": "1,1,2,3,1,1,2,3,4,5,1,1,2,3,4,5,6,7,5,3,1,1,2,4,5,7,8,9,7,3,1,1,2,3,4,5,6,7,8,9,10,11,7,5,1,1,2,3,4,5,6,7,8,9,10,11,12,13,11,9,5,3,1,1,2,4,7,8,11,13,14,15,13,11,9,7,5,3,1,1,2,3,4", "code": "\nfrom fractions import gcd\nfor s in range(2, 100, 2):\n..for i in range(1, s):\n....if gcd(i, s - i) != 1: continue\n....print(s - i)\n..for i in range(s, 0, -1):\n....if gcd(i, s + 1 - i) != 1: continue\n....print(s + 1 - i)\n\n"}
{"sequence_id": "A157883", "text": "Numerator of Bernoulli(n, 2/5).", "sequence": "1,-1,-11,3,91,-43,-12347,1183,62851,-54423,-39448591,3799763,27287144401,-375591203,-34562009741,49954996743,89299092717107,-8604866798383,-135379643536733633,1863607913992123,2694379428323830241,-495661415843787963,-1648224141847799919403", "code": "\nfrom sympy import bernoulli, Integer\ndef a(n): return bernoulli(n, Integer(2)/5).numerator()\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A158214", "text": "Smallest palindromic prime made up of 0's and k 1's, where k = A007310(n), odd numbers not divisible by 3.", "sequence": "100111001,110111011,1110111110111,10111101110111101,100111111111111111001,1111111111111111111,11111111111111111111111,10111111111101110111111111101,1111110111111111111111110111111", "code": "\nfrom __future__ import division\nfrom sympy.utilities.iterables import multiset_permutations\nfrom sympy import isprime\nA158214_list = []\nfor i in range(2,101):\n    if i % 6 == 1 or i % 6 == 5:\n        i2 = i//2\n        l = i2\n        flag = True\n        while flag:\n            dlist = '0'*(l-i2) + '1'*i2\n            for d in multiset_permutations(dlist):\n                s = ''.join(d)\n                n = int(s+'1'+s[::-1])\n                if isprime(n):\n                    A158214_list.append(n)\n                    flag = False\n                    break\n            else:\n                l += 1 \n"}
{"sequence_id": "A158215", "text": "Smallest palindromic prime made up of 0's and p(n) 1's, where p(n) is the n-th prime = A000040(n) (or 0 when no such prime exists).", "sequence": "11,0,100111001,110111011,1110111110111,10111101110111101,100111111111111111001,1111111111111111111,11111111111111111111111,1111110111111111111111110111111,11111101111111110101111111110111111", "code": "\nfrom __future__ import division\nfrom itertools import combinations\nfrom sympy import prime, isprime\ndef A158215(n):\n    if n == 1:\n        return 11\n    if n == 2:\n        return 0\n    p2 = prime(n)//2\n    l = p2\n    while True:\n        for i in combinations(range(l),l-p2):\n            s = ['1']*l\n            for x in i:\n                s[x] = '0'\n            s = ''.join(s)\n            q = int(s+'1'+s[::-1])\n            if isprime(q):\n                return q\n        l += 1 \n"}
{"sequence_id": "A158288", "text": "The number of twin prime pairs in the n-th century.", "sequence": "8,7,4,2,3,2,3,0,5,0,5,1,3,2,4,0,4,2,2,3,3,3,2,3,0,2,2,3,1,1,0,2,2,4,2,4,1,1,2,2,4,2,5,1,2,2,2,2,0,2,2,0,2,0,3,2,3,1,3,0,1,2,1,1,1,2,2,4,2,2,0,1,1,3,2,3,0,1,1,1,2,0,3,1,1,2,1,0,3,1,2,0,2,1,4,0,2,2,1,1,4,1,1,2,2", "code": "\nfrom sympy import primerange, isprime\ndef a(n):\n    s=0\n    for p in primerange(100*n - 99, 100*n - 1):\n        if isprime(p + 2):s+=1\n    return s\nprint([a(n) for n in range(1, 201)]) \n"}
{"sequence_id": "A158295", "text": "Primes p such that p^3-p-+1 are twin primes.", "sequence": "2,11,31,41,239,521,2309,4099,4409,4441,4651,5009,5039,5261,6481,6871,7129,8609,9391,10259,12841,13759,14519,14879,14939,15569,16871,18451,20369,22441,24049,25841,28151,28279,29429,30181,30631,32089,32299,36781", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**5) if isprime(p) and isprime(p**3-p-1) and isprime(p**3-p+1)} \n"}
{"sequence_id": "A158352", "text": "a(n) is the smallest number whose name in US English contains n vowels.", "sequence": "2,1,11,14,71,101,111,114,171,1071,1101,1111,1114,1171,11171,14171,71171,101171,111171,114171,171171,1071171,1101171,1111171,1114171,1171171,11171171,14171171,71171171,101171171,111171171,114171171,171171171,1071171171,1101171171", "code": "\nfrom num2words import num2words\ndef A158352(n):\n  i = 1\n  while sum(1 for c in num2words(i).replace(' and ', '') if c in \"aeiouy\")!=n:\n    i += 1\n  return i\nprint([A158352(n) for n in range(1,16)]) \n"}
{"sequence_id": "A158353", "text": "a(n) is the smallest number greater than a(n-1) whose name in US English contains n vowels.", "sequence": "2,3,11,14,71,101,111,114,171,1071,1101,1111,1114,1171,11171,14171,71171,101171,111171,114171,171171,1071171,1101171,1111171,1114171,1171171,11171171,14171171,71171171,101171171,111171171,114171171,171171171,1071171171,1101171171", "code": "\nfrom num2words import num2words\ndef A158353upto(n):\n  i, ans = 1, []\n  for k in range(1, n+1):\n    while sum(1 for c in num2words(i).replace(' and ', '') if c in \"aeiouy\") != k:\n      i += 1\n      ans.append(i)\n  return ans\nprint(A158353upto(20)) \n"}
{"sequence_id": "A158568", "text": "a(n) = Sum_{i=1..Fibonacci(n)} sigma_0(i) where sigma_0(n) is A000005(n).", "sequence": "1,1,3,5,10,20,37,70,127,231,413,746,1307,2295,4010,6957,12031,20712,35514,60718,103500,175989,298539,505399,853777,1439856,2424299,4075479,6841787,11470592,19207624,32126763,53678285", "code": "\nfrom math import isqrt\ndef A153568(n):\n    a, b, = 0, 1\n    for _ in range(n): a, b = b, a+b\n    return (lambda m: 2*sum(a//k for k in range(1, m+1))-m*m)(isqrt(a)) \n"}
{"sequence_id": "A158581", "text": "Numbers having in binary representation at least two ones and two zeros.", "sequence": "9,10,12,17,18,19,20,21,22,24,25,26,28,33,34,35,36,37,38,39,40,41,42,43,44,45,46,48,49,50,51,52,53,54,56,57,58,60,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,96,97", "code": "\ndef ok(n): b = bin(n)[2:]; return b.count('0') >= 2 and b.count('1') >= 2\nprint(list(filter(ok, range(98)))) \n"}
{"sequence_id": "A158625", "text": "Lower limit of backward value of 5^n.", "sequence": "5,2,1,3,0,2,3,3,0,4,3,1,1,3,1,1,2,4,2,1,0,3,1,3,3,0,0,0,2,3,1,4,1,0,2,1,0,3,4,3,0,2,1,2,2,1,1,4,4,3,4,0,2,0,4,0,2,2,1,1,1,1,1,0,1,0,0,1,1,3,3,2,0,1,1,4,4,2,0,1,4,2,4,1,2,0,4", "code": "\n\na,i=5,0; x=a\nwhile i < 100:\n     i+=1; print(x, end=',')\n     for j in range(5):\n         if (a+j*10**i)%(5**(i+1))==0: x=j; a+=j*10**i\n\n"}
{"sequence_id": "A158796", "text": "Index of first of three successive primes which sum to a cube.", "sequence": "85,3696,79700,263166,283353,434935,678277,950264,1043678,1266169,1321463,1436753,2629623,3568796,3604676,3676738,3713180,5096401,5558697,7162624,9303565,9504536,10988577,12778681,13108392,18730119", "code": "\nfrom __future__ import division\nfrom sympy import prevprime, nextprime, isprime, primepi\nA158796_list, i = [], 3\nwhile i < 10**6:\n    n = i**3\n    m = n//3\n    pm, nm = prevprime(m), nextprime(m)\n    k = n - pm - nm\n    if isprime(m):\n        if m == k:\n            A158796_list.append(primepi(pm))\n    else:\n        if nextprime(nm) == k:\n            A158796_list.append(primepi(pm))\n        elif prevprime(pm) == k:\n            A158796_list.append(primepi(pm)-1)\n    i += 1 \n"}
{"sequence_id": "A158826", "text": "Third iteration of x*C(x) where C(x) is the Catalan function (A000108).", "sequence": "1,3,12,54,260,1310,6824,36478,199094,1105478,6227712,35520498,204773400,1191572004,6990859416,41313818217,245735825082,1470125583756,8840948601024,53417237877396,324123222435804,1974317194619712", "code": "\nfrom sympy import binomial as C\ndef a(n):\n    return sum(C(2*k - 2, k - 1) * sum(C(-k + 2*i - 1, i - 1) * C(2*n - i - 1, n - 1) for i in range(k, n + 1)) for k in range(1, n + 1)) / n\n[a(n) for n in range(1, 51)] \n"}
{"sequence_id": "A158896", "text": "Primes whose squares are a concatenation of 2 with some prime.", "sequence": "5,17,53,151,157,163,173,463,467,491,523,541,1451,1471,1483,1489,1499,1511,1549,1553,1567,1609,1657,1721,1723,4583,4597,4621,4649,4663,4673,4703,4729,4751,4759,4787,4813,4937,4943,4973,4993,5039,5077,5227,5297", "code": "\nfrom sympy import isprime, primerange\ndef ok(p):\n  s = str(p*p); return s[0] == '2' and s[1] != '0' and isprime(int(s[1:]))\nprint(list(filter(ok, primerange(2, 5298)))) \n"}
{"sequence_id": "A158923", "text": "a(1) = 2, a(n) = a(n-1) + round(log(a(n-1))) for n >= 2.", "sequence": "2,3,4,5,7,9,11,13,16,19,22,25,28,31,34,38,42,46,50,54,58,62,66,70,74,78,82,86,90,94,99,104,109,114,119,124,129,134,139,144,149,154,159,164,169,174,179,184,189,194,199,204,209,214,219,224,229,234,239,244,249", "code": "\nfrom math import log\nprint(2)\na_last = n = 2\nwhile n >= 2:\n    a = a_last + int(log(a_last) + 0.5)\n    print(a)\n    a_last = a\n    n += 1 \n"}
{"sequence_id": "A158962", "text": "a(n) is the smallest number m such that all n numbers m-1, m.m-1, ..., m.m. .. .m-1 are prime, where dot means concatenation.", "sequence": "3,4,4,444,827868,10387692,1885781034", "code": "\nfrom sympy import isprime\ndef A158962(n):\n    m = 1\n    while True:\n        for i in range(n):\n            if not isprime(int(str(m)*(i+1))-1):\n                break\n        else:\n            return m\n        m += 1 \n"}
{"sequence_id": "A159065", "text": "Number of crossings in a regular drawing of the complete bipartite graph K(n,n).", "sequence": "0,1,7,27,65,147,261,461,737,1143,1637,2349,3217,4401,5769,7457,9433,11945,14753,18235,22173,26771,31801,37813,44449,52161,60489,69955,80289,92203,104941,119493,135261,152705,171205,191649,213473,237877", "code": "\nfrom math import gcd\ndef a159065(n):\n    c=0\n    for a in range(1, n):\n        for b in range(1, n):\n            if gcd(a, b)==1:\n                c+=(n - a)*(n - b)\n                if 2*a<n and 2*b<n:c-=(n - 2*a)*(n - 2*b)\n    return c\nprint([a159065(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A159065", "text": "Number of crossings in a regular drawing of the complete bipartite graph K(n,n).", "sequence": "0,1,7,27,65,147,261,461,737,1143,1637,2349,3217,4401,5769,7457,9433,11945,14753,18235,22173,26771,31801,37813,44449,52161,60489,69955,80289,92203,104941,119493,135261,152705,171205,191649,213473,237877", "code": "\nfrom sympy import totient\ndef A159065(n): return n-1 if n <= 2 else 2*n-3+3*sum(totient(i)*(n-i)*i for i in range(2,(n+1)//2)) + sum(totient(i)*(n-i)*(2*n-i) for i in range((n+1)//2,n)) \n"}
{"sequence_id": "A159280", "text": "Numerator of Hermite(n, 1/11).", "sequence": "1,2,-238,-1444,169900,1737592,-202103816,-2927191216,336509481872,6340061157920,-720237529201376,-16783423060569152,1883705456612924608,52506471481118666624,-5821124423542023483520,-189534174225114089489152,20751613309007317066199296", "code": "\nfrom sympy import hermite\ndef a(n): return hermite(n, 1/11)*11**n \n"}
{"sequence_id": "A159842", "text": "Number of symmetrically-distinct supercells (sublattices) of the fcc and bcc lattices (n is the \"volume factor\" of the supercell).", "sequence": "1,2,3,7,5,10,7,20,14,18,11,41,15,28,31,58,21,60,25,77,49,54,33,144,50,72,75,123,49,158,55,177,97,112,99,268,75,136,129,286,89,268,97,249,218,190,113,496,146,280,203,333,141,421,207,476,247,290,171,735", "code": "\ndef dc(f, *r): \n    if not r:\n        return f\n    return lambda n: sum(f(d)*dc(*r)(n//d) for d in range(1, n+1) if n%d == 0)\ndef fin(*a): \n    return lambda n: 0 if n > len(a) else a[n-1]\ndef per(*a): \n    return lambda n: a[n%len(a)]\nu, N, N2 = lambda n: 1, lambda n: n, lambda n: n**2\ndef a(n): \n    return (dc(u, N, N2)(n) + 9*dc(fin(1, -1, 0, 4), u, u, N)(n)\n            + 8*dc(fin(1, 0, -1, 0, 0, 0, 0, 0, 3), u, u, per(0, 1, -1))(n)\n            + 6*dc(fin(1, -1, 0, 2), u, u, per(0, 1, 0, -1))(n))//24\nprint([a(n) for n in range(1, 300)])\n\n"}
{"sequence_id": "A159907", "text": "Numbers n with half-integral abundancy index, sigma(n)/n = k+1/2 with integer k.", "sequence": "2,24,4320,4680,26208,8910720,17428320,20427264,91963648,197064960,8583644160,10200236032,21857648640,57575890944,57629644800,206166804480,17116004505600,1416963251404800,15338300494970880", "code": "\nfrom fractions import Fraction\nfrom sympy import divisor_sigma as sigma\ndef aupto(limit):\n  for k in range(1, limit):\n    if Fraction(int(sigma(k, 1)), k).denominator == 2:\n      print(k, end=\", \")\naupto(3*10**4) \n"}
{"sequence_id": "A159918", "text": "Number of ones in binary representation of n^2.", "sequence": "0,1,1,2,1,3,2,3,1,3,3,5,2,4,3,4,1,3,3,5,3,6,5,3,2,5,4,6,3,5,4,5,1,3,3,5,3,6,5,7,3,5,6,7,5,8,3,4,2,5,5,5,4,8,6,7,3,6,5,7,4,6,5,6,1,3,3,5,3,6,5,7,3,6,6,9,5,7,7,5,3,6,5,8,6,7,7,7,5,9,8,5,3,6,4,5,2,5,5,6,5,9,5,7,4", "code": "\ndef A159918(n):\n    return bin(n*n).count('1') \n"}
{"sequence_id": "A159991", "text": "Powers of 60.", "sequence": "1,60,3600,216000,12960000,777600000,46656000000,2799360000000,167961600000000,10077696000000000,604661760000000000,36279705600000000000,2176782336000000000000,130606940160000000000000", "code": " for n in range(0,20): print(60**n, end=', ') \n"}
{"sequence_id": "A160078", "text": "Positive integers which apparently never result in a palindrome under repeated applications of the function f(x) = x + (x with digits in binary expansion reversed). Binary analog of Lychrel numbers.", "sequence": "22,26,28,35,37,41,45,46,47,49,60,61,67,75,77,78,84,86,89,90,93,94,95,97,105,106,108,110,116,120,122,124,125,131,135,139,141,147,149,152", "code": "\nfrom sympy.ntheory.digits import digits\ndef make_int(l, b):\n    return int(''.join(str(d) for d in l), b)\nmaxn = 102\nit = []\nfor i in range( 1, maxn ) :\n    d = digits( i, 2 )[1:]\n    isLychrel = True\n    for j in range( 1000 ) :\n        d = digits( make_int( d, 2 ) + make_int( d[::-1], 2 ), 2 )[1:]\n        if d == d[::-1] :\n            it.append( j + 1 )\n            isLychrel = False\n            break\n    if isLychrel :\n        it.append( 0 )\nprint('Maximum iterations for non-seed numbers', max( it ))\nLychrel = []\nfor i in range( len(it) ) :\n    if it[i] == 0 :\n        Lychrel.append( i + 1 )\nprint('Count of binary Lychrel numbers', len( Lychrel ))\nprint('All binary lichler under', maxn)\nprint('Decimal form', Lychrel)\nprint('Binary form', list(map( lambda x: ''.join( map( str, toSystem( x, 2 ) ) ), Lychrel )))\n"}
{"sequence_id": "A160093", "text": "Number of digits in n, excluding any trailing zeros.", "sequence": "1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,3,3,3,3,3", "code": "\ndef A160093(n):\n     return len(str(int(str(n)[::-1]))) \n"}
{"sequence_id": "A160256", "text": "a(1)=1, a(2)=2. For n >=3, a(n) = the smallest positive integer not occurring earlier in the sequence such that a(n)*a(n-1)/a(n-2) is an integer.", "sequence": "1,2,3,4,6,8,9,16,18,24,12,10,30,5,36,15,48,20,60,7,120,14,180,21,240,28,300,35,360,42,420,11,840,22,1260,33,1680,44,2100,55,2520,66,2940,77,3360,88,3780,110,378,165,126,220,63,440,189,880,567,1760", "code": "\nfrom __future__ import division\nfrom fractions import gcd\nA160256_list, l1, l2, m, b = [1,2], 2, 1, 1, {1,2}\nfor _ in range(10**3):\n....i = m\n....while True:\n........if not i in b:\n............A160256_list.append(i)\n............l1, l2, m = i, l1, l1//gcd(l1,i)\n............b.add(i)\n............break\n........i += m \n"}
{"sequence_id": "A160337", "text": "1 plus primes using only digits {0, 1, 2, 3, 5, 7}.", "sequence": "1,2,3,5,7,11,13,17,23,31,37,53,71,73,101,103,107,113,127,131,137,151,157,173,211,223,227,233,251,257,271,277,307,311,313,317,331,337,353,373,503,521,523,557,571,577,701,727,733,751,757,773,1013,1021,1031", "code": "\nfrom sympy import isprime\ndef ok(n): return n == 1 or (set(str(n)) <= set(\"012357\") and isprime(n))\nprint([m for m in range(1032) if ok(m)]) \n"}
{"sequence_id": "A160492", "text": "a(n) = number of solutions to an equation x_1 + ... + x_j =0 with 1<=j<=n satisfying -n<=x_i<=n (1<=i<=j).", "sequence": "1,6,45,560,9795,223524,6284089,210208560,8156750283,360297117070,17853149451841,980844453593160,59179098916735213,3890176308574524934,276750779199166606705,21185250061147839785120,1736385140876356212244563,151719500906542020597450498", "code": "\nfrom sympy import binomial\ndef C(r, m, k): return sum([(-1)**i*binomial(r - 1 - i*m, k - 1)*binomial(k, i) for i in range(int((r - k)/m) + 1)])\ndef a(n): return sum([C(v*(n + 1), 2*n + 1, v) for v in range(1, n + 1)]) \n"}
{"sequence_id": "A160520", "text": "a(n) is the number of different values in period of continued fraction of square root of n-th nonsquare integer.", "sequence": "1,2,1,2,2,2,1,2,2,2,3,2,1,2,4,2,3,4,3,2,1,2,3,3,2,4,2,3,3,2,1,2,2,2,2,2,4,3,3,5,3,2,1,2,4,3,4,2,2,3,2,4,3,5,3,2,1,2,5,2,4,3,4,2,3,2,2,5,4,3,3,2,1,2,2", "code": "\nimport math\ndef findperiod( d ) :\n    if len(d) == 0 :\n        return 0\n    for p in range( 1, len(d) - 1 ) :\n        isPeriod = True\n        for i in range(0, p) :\n            for j in range(i + p, len(d), p ) :\n                if not d[i] == d[j] :\n                    isPeriod = False\n                    break\n            if not isPeriod :\n                break\n        if isPeriod :\n            return len( set( d[:p] ) )\n    return -1\ndef nextv( a, b, n, less = True ) :\n    \n    d = -1\n    while (a[1]*a[1] < n * a[0] * a[0]) == less :\n        d += 1\n        a = ( a[0] + b[0], a[1] + b[1] )\n    a = ( a[0] - b[0], a[1] - b[1] )\n    return d, a, b\ndef generated( n ) :\n    maxperiod = 100\n    s = int( math.sqrt( n ) )\n    if s * s == n :\n        return []\n    a = (1, 0)\n    b = (0, 1)\n    ds = []\n    for i in range( maxperiod ):\n        d, b, a = nextv( a, b, n )\n        ds.append( d )\n        d, b, a = nextv( a, b, n, less = False )\n        ds.append( d )\n    return ds[1:]\nmaxn = 1000\nns = [x for x in range( maxn ) if not int( math.sqrt( x ) ) ** 2 == x ]\nv = list(map( findperiod, map( generated, ns ) ))\nif v.count( -1 ) == 0 :\n    print(v)\n"}
{"sequence_id": "A160530", "text": "Positive integers that contain only odd-length runs of 0's and 1's in their binary expansion.", "sequence": "1,2,5,7,8,10,14,17,21,23,29,31,32,34,40,42,46,56,58,62,65,69,71,81,85,87,93,95,113,117,119,125,127,128,130,136,138,142,160,162,168,170,174,184,186,190,224,226,232,234,238,248,250,254,257,261,263,273,277,279", "code": "\nfrom itertools import groupby\ndef ok(n): return all(len(list(g))%2 == 1 for k, g in groupby(bin(n)[2:]))\nprint([i for i in range(1, 280) if ok(i)]) \n"}
{"sequence_id": "A160652", "text": "Express n in balanced ternary, then reverse the digits, leaving any trailing zeros alone.", "sequence": "0,1,-2,3,4,-11,-6,7,-8,9,10,-5,12,13,-38,-33,16,-29,-18,25,-20,21,34,-35,-24,19,-26,27,28,-17,30,37,-32,-15,22,-23,36,31,-14,39,40,-119,-114,43,-92,-99,70,-65,48,97,-110,-87,52,-83,-54,79,-56,75,106,-101", "code": "\ndef a(n):\n    if n==0: return 0\n    r=0\n    dr=1\n    while n%3==0:\n        dr*=3\n        n/=3\n    while n!=0:\n        q=(n + 1)/3\n        r=3*r + dr*(n - 3*q)\n        n=q\n    return r\n\n"}
{"sequence_id": "A160658", "text": "Numbers that have the letter \"n\" in the middle of their names when written in American English.", "sequence": "1,17,193,197,198,293,297,298,301,302,306,310,693,697,698,701,702,706,710,801,802,806,810,1013,1014,1018,1019,1041,1042,1046,1051,1052,1056,1061,1062,1066,1104,1105,1109,1173,1177,1178,1273,1277,1278,1673,1677,1678", "code": "\nfrom num2words import num2words\ndef middle(s): return s[len(s)//2] if len(s)%2 == 1 else None\ndef n2w(n):\n  map = {ord(c): None for c in \"-, \"}\n  return num2words(n).replace(\" and\", \"\").translate(map)\ndef aupto(nn): return [n for n in range(1, nn+1) if middle(n2w(n)) == 'n']\nprint(aupto(1678)) \n"}
{"sequence_id": "A160663", "text": "Number of distinct sums that one can obtain by adding two squares among the n first ones.", "sequence": "2,5,9,14,19,26,33,41,50,60,70,82,93,105,119,134,147,164,179,197,215,234,251,272,293,314,336,359,381,407,430,456,483,507,535,566,594,623,652,686,714,748,780,812,849,883,918,956,992,1030,1068,1107,1141,1181", "code": "\ndef a(n):\n    SUM, SQR = set(), set(x**2 for x in range(1, n + 1))\n    for i in SQR:\n        SUM.add(i)\n        for j in SQR: SUM.add(i + j)\n    return len(SUM)\n\n"}
{"sequence_id": "A160786", "text": "The number of odd partitions of consecutive odd integers.", "sequence": "1,2,4,8,16,29,52,90,151,248,400,632,985,1512,2291,3431,5084,7456,10836,15613,22316,31659,44601,62416,86809,120025,165028,225710,307161,416006,560864,752877,1006426,1340012,1777365,2348821,3093095,4059416,5310255,6924691", "code": "\n\ndef numoddpart(n, m=1):\n    \"\"\"The number of partitions of n into an odd number of parts of size at least m\"\"\"\n    if n < m:\n        return 0\n    elif n == m:\n        return 1\n    else:\n        \n        \n        return 1 + sum([numevenpart(n - k,  k) for k in range(m, n//3 + 1)])\ndef numevenpart(n, m=1):\n    \"\"\"The number of partitions of n into an even number of parts of size at least m\"\"\"\n    if n < 2*m:\n        return 0\n    elif n == 2*m:\n        return 1\n    else:\n        return sum([numoddpart(n - k,  k) for k in range(m,  n//2 + 1)])\n[numoddpart(n) for n in range(1, 70, 2)]\n"}
{"sequence_id": "A160786", "text": "The number of odd partitions of consecutive odd integers.", "sequence": "1,2,4,8,16,29,52,90,151,248,400,632,985,1512,2291,3431,5084,7456,10836,15613,22316,31659,44601,62416,86809,120025,165028,225710,307161,416006,560864,752877,1006426,1340012,1777365,2348821,3093095,4059416,5310255,6924691", "code": "\n\nps = {(0,0): 1}\ndef p(n, k):\n    \"\"\"Number of partitions of n into exactly k parts\"\"\"\n    if (n,k) in ps: return ps[(n,k)]\n    if (n<=0) or (k<=0): return 0\n    ps[(n,k)] = p(n-k,k) + p(n-1,k-1)\n    return ps[(n,k)]\ndef a(n): return sum([p(2*n+1, k) for k in range(1,2*n+3,2)])\n[a(n) for n in range(0,41)]\n\n"}
{"sequence_id": "A160827", "text": "a(n) = 3*n^4 + 12*n^3 + 30*n^2 + 36*n + 17.", "sequence": "17,98,353,962,2177,4322,7793,13058,20657,31202,45377,63938,87713,117602,154577,199682,254033,318818,395297,484802,588737,708578,845873,1002242,1179377,1379042,1603073,1853378,2131937,2440802,2782097,3158018,3570833", "code": "\nA160827_list, m = [], [72, -36, 30, 15, 17]\nfor _ in range(10**2):\n    A160827_list.append(m[-1])\n    for i in range(4):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A160828", "text": "a(n) = 4*n^4 + 24*n^3 + 84*n^2 + 144*n + 98.", "sequence": "98,354,978,2258,4578,8418,14354,23058,35298,51938,73938,102354,138338,183138,238098,304658,384354,478818,589778,719058,868578,1040354,1236498,1459218,1710818,1993698,2310354,2663378,3055458,3489378,3968018,4494354", "code": "\nA160828_list, m = [], [96, 0, 80, 80, 98]\nfor _ in range(10**2):\n    A160828_list.append(m[-1])\n    for i in range(4):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A160943", "text": "a(n) = n + digital sum(n-1) + digital sum(n+1).", "sequence": "3,6,9,12,15,18,21,24,18,21,15,18,21,24,27,30,33,36,30,33,27,30,33,36,39,42,45,48,42,45,39,42,45,48,51,54,57,60,54,57,51,54,57,60,63,66,69,72,66,69,63,66,69,72,75,78,81,84,78,81,75,78,81,84,87,90,93,96,90,93", "code": "\ndef A160943(n): return n+sum(int(d) for d in str(n-1))+sum(int(d) for d in str(n+1)) \n"}
{"sequence_id": "A161001", "text": "Those positive integers n that when read in binary contains runs of 0's and 1's being of distinct lengths, the list of lengths forming a permutation of some number of consecutive positive integers.", "sequence": "1,3,4,6,7,15,24,28,31,35,39,49,55,57,59,63,112,120,127,255,391,399,451,463,480,483,487,496,511,536,540,560,572,624,632,776,782,784,798,880,888,900,902,912,926,944,956,964,966,968,974,984,988,1023,1984,2016", "code": "\nfrom itertools import groupby\ndef ok(n):\n  runlengths = [len(list(g)) for k, g in groupby(bin(n)[2:])]\n  minrl = min(runlengths)\n  return sorted(runlengths) == list(range(minrl, minrl+len(runlengths)))\nprint([n for n in range(1, 2021) if ok(n)]) \n"}
{"sequence_id": "A161001", "text": "Those positive integers n that when read in binary contains runs of 0's and 1's being of distinct lengths, the list of lengths forming a permutation of some number of consecutive positive integers.", "sequence": "1,3,4,6,7,15,24,28,31,35,39,49,55,57,59,63,112,120,127,255,391,399,451,463,480,483,487,496,511,536,540,560,572,624,632,776,782,784,798,880,888,900,902,912,926,944,956,964,966,968,974,984,988,1023,1984,2016", "code": " \nfrom itertools import permutations\ndef runlengths(k, r): \n  c = ['1', '0']\n  return sorted([int(\"\".join([c[j%2]*p[j] for j in range(r-k+1)]), 2)\n    for p in permutations(range(k, r+1))])\ndef aupto(nn):\n  digits, k, r, out = 1, 1, 1, []\n  while len(out) < nn:\n    for r in range(1, digits + 1):\n      for k in range(1, r + 1):\n        if sum(range(k, r+1)) == digits:\n          out += runlengths(k, r)\n    digits += 1\n  return sorted(set(out))[:nn]\nprint(aupto(56)) \n"}
{"sequence_id": "A161132", "text": "Number of permutations of {1,2,...,n} that have no even fixed points.", "sequence": "1,1,1,4,14,78,426,3216,24024,229080,2170680,25022880,287250480,3884393520,52370755920,812752093440,12585067447680,220448163358080,3854801333416320,75225258805132800,1465957162768492800,31537353006189676800,677696237345719468800", "code": "\nimport math\nf=math.factorial\ndef C(n, r): return f(n)/ f(r)/ f(n - r)\ndef A161132(n):\n....s=0\n....for j in range(0, (n/2)+1):\n........s+=(-1)**j*C(n/2, j)*f(n - j)\n....return s \n"}
{"sequence_id": "A161134", "text": "Triangle read by rows: T(n,k) is the number of permutations of {1,2,...,n} having exactly k even fixed points (0 <= k <= floor(n/2)).", "sequence": "1,1,1,1,4,2,14,8,2,78,36,6,426,234,54,6,3216,1512,288,24,24024,12864,3024,384,24,229080,108960,22320,2400,120,2170680,1145400,272400,37200,3000,120,25022880,11998800,2563200,309600,21600,720,287250480", "code": "\nfrom sympy import factorial, binomial\ndef T(n,k):\n    s=0\n    for j in range(n//2 - k+1):\n        s+=(-1)**j * factorial(n-k-j) * binomial(n//2 - k, j)\n    return binomial(n//2, k)* s\ni=0\nfor n in range(26):\n    for k in range(n//2 + 1):\n        print(str(i)+\" \"+str(T(n,k)))\n        i+=1\n\n"}
{"sequence_id": "A161152", "text": "Positive integers n such that {the number of (non-leading) 0's in the binary representation of n} is coprime to n.", "sequence": "1,2,5,6,8,9,11,13,14,17,19,20,21,23,25,27,29,30,32,33,35,37,38,39,41,43,44,45,47,49,50,51,52,53,55,56,57,59,61,62,66,67,68,69,71,72,73,77,79,81,83,85,86,87,89,91,92,93,95,96,97,101,103,106,107,109,111,113,115", "code": "\nfrom fractions import gcd\ni=j=1\nwhile j<=100:\n    if gcd(bin(i)[2:].count(\"0\"),i)==1:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A161153", "text": "Positive integers that are coprime to their number of digits in binary representation.", "sequence": "1,3,4,5,7,9,11,13,15,16,17,18,19,21,22,23,24,26,27,28,29,31,35,37,41,43,47,49,53,55,59,61,64,65,66,67,68,69,71,72,73,74,75,76,78,79,80,81,82,83,85,86,87,88,89,90,92,93,94,95,96,97,99,100,101,102,103,104,106", "code": "\nfrom fractions import gcd\ni=1\nj=1\nwhile j<=100:\n    if gcd(len(bin(i)[2:]),i)==1:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A161154", "text": "Positive integers n such that both {the number of (non-leading) 0's in the binary representation of n} is coprime to n and {the number of 1's in the binary representation of n} is coprime to n.", "sequence": "1,2,5,8,9,11,13,14,17,19,23,25,27,29,32,33,35,37,38,39,41,43,44,45,47,49,50,51,52,53,56,57,59,61,62,67,71,73,77,79,83,85,87,89,91,93,95,97,101,103,107,109,113,117,119,121,125,128,131,133,134,135,137,139,141", "code": "\nfrom fractions import gcd\ni=j=1\nwhile j<=100:\n    if gcd(bin(i)[2:].count(\"0\"),i)==1==gcd(bin(i)[2:].count(\"1\"),i):\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A161155", "text": "Positive integers n such that {the number of (non-leading) 0's in the binary representation of n} is coprime to n, {the number of 1's in the binary representation of n} is coprime to n and {the number of digits in the binary representation of n} is coprime to n.", "sequence": "1,5,9,11,13,17,19,23,27,29,35,37,41,43,47,49,53,59,61,67,71,73,79,83,85,87,89,93,95,97,101,103,107,109,113,117,121,125,131,133,135,137,139,141,143,147,149,151,153,157,161,163,165,167,169,173,175,177,179,181", "code": "\nfrom fractions import gcd\ni=j=1\nwhile j<=100:\n    if gcd(bin(i)[2:].count(\"0\"),i)==1 and gcd(bin(i)[2:].count(\"1\"),i)==1 and gcd(len(bin(i)[2:]),i)==1:\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A161156", "text": "Positive integers n such that {the number of (non-leading) 0's in the binary representation of n} is coprime to n, and {the number of 1's in the binary representation of n} is coprime to n, but {the number of digits in the binary representation of n} is not coprime to n.", "sequence": "2,8,14,25,32,33,38,39,44,45,50,51,52,56,57,62,77,91,119,128,134,146,148,152,158,164,176,182,188,194,196,206,208,214,218,224,236,242,244,248,254,267,279,291,297,309,327,333,339,351,357,369,375,381,387,393", "code": "\nfrom fractions import gcd\ni=j=1\nwhile j<=1000:\n    if gcd(bin(i)[2:].count(\"0\"),i)==1 and gcd(bin(i)[2:].count(\"1\"),i)==1 and gcd(len(bin(i)[2:]),i)!=1:\n        print(str(i), end=\",\")\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A161164", "text": "Absolute value of (the n-th twin prime minus the n-th non-twin prime).", "sequence": "1,18,30,36,40,50,60,54,58,56,70,68,70,86,90,66,70,104,114,96,112,108,112,98,112,116,124,134,138,126,130,128,132,110,112,108,114,90,96,92,94,30,36,36,46,26,28,22,20,60,30,52,44,54,42,54,50,52,48,178,164,168,150", "code": "\nfrom sympy import nextprime\ndef aupton(terms):\n  n, p, q = 1, 2, 3\n  alst, non_twins, twins = [], [2], [3]\n  while True:\n    p, q = q, nextprime(q)\n    if q - p == 2:\n      if p != twins[-1]: twins.append(p)\n      twins.append(q)\n    else:\n      if p != twins[-1]: non_twins.append(p)\n    if len(twins) >= n and len(non_twins) >= n:\n      alst.append(abs(twins[n-1] - non_twins[n-1]))\n      if n == terms: break\n      n += 1\n  return alst\nprint(aupton(63)) \n"}
{"sequence_id": "A161169", "text": "Triangle read by rows: T(n,k) = number of permutations of {1..n} with at most k inversions.", "sequence": "1,1,1,2,1,3,5,6,1,4,9,15,20,23,24,1,5,14,29,49,71,91,106,115,119,120,1,6,20,49,98,169,259,360,461,551,622,671,700,714,719,720,1,7,27,76,174,343,602,961,1416,1947,2520,3093,3624,4079,4438,4697,4866,4964,5013", "code": " ct = {(0,0): 1}\ndef c(n,k):\n....if k<0: return 0\n....k = min(k, n*(n-1)/2)\n....if (n,k) in ct: return ct[(n,k)]\n....ct[(n,k)] = c(n,k-1) + c(n-1,k) - c(n-1,k-n)\n....return ct[(n,k)]\n"}
{"sequence_id": "A161354", "text": "Cubes whose reversal is a prime number.", "sequence": "125,125000,140608,704969,1643032,1815848,3511808,3723875,3869893,7301384,9393931,10360232,11543176,14526784,15069223,15252992,15813251,16777216,19902511,34328125,34645976,35287552,70444997,92345408", "code": "\nfrom sympy import isprime\nA161354_list, i, j = [], 0, 0\nwhile j < 10**15:\n    p = int(str(j)[::-1])\n    if isprime(p):\n        A161354_list.append(j)\n    j += 3*i*(i+1)+1\n    i += 1\nA161354_list = sorted(A161354_list) \n"}
{"sequence_id": "A161400", "text": "Positive integers that are palindromes (of even length) in binary, each made by concatenating two identical binary palindromes.", "sequence": "3,15,45,63,153,255,561,693,891,1023,2145,2925,3315,4095,8385,9417,10965,11997,12771,13803,15351,16383,33153,39321,42405,48573,50115,56283,59367,65535,131841,140049,152361,160569,166725,174933,187245", "code": "\nfrom itertools import product\ndef bin_pals():\n  yield \"1\"\n  digits, midrange = 2, [[\"\"], [\"0\", \"1\"]]\n  while True:\n    for p in product(\"01\", repeat=digits//2-1):\n      left = \"1\"+\"\".join(p)\n      for middle in midrange[digits%2]:\n        yield left+middle+left[::-1]\n    digits += 1\ndef aupton(terms):\n  alst, bgen = [], bin_pals()\n  while len(alst) < terms: b = next(bgen); alst.append(int(b+b, 2))\n  return alst\nprint(aupton(37)) \n"}
{"sequence_id": "A161493", "text": "Positive integers, k, for which k mod d(k) and k have opposite (odd/even) parity, where d(k) is the number of divisors of k.", "sequence": "1,4,9,16,64,100,144,196,225,324,441,484,576,625,676,900,1024,1089,1296,1521,1764,1936,2025,2116,2304,2601,3136,3249,3364,3844,4096,4225,4356,4761,4900,5625,5776,6084,6400,6561,6724,7396,7569,8649,8836,9216,9801", "code": "\nfrom sympy import divisor_count\nprint([n**2 for n in range(1, 1001) if int(math.floor(n**2/divisor_count(n**2)))%2]) \n"}
{"sequence_id": "A161501", "text": "a(n) is the smallest positive integer that is a palindrome when represented in binary, and is made by appending some number (zero or more) of binary digits on the right of n's binary representation.", "sequence": "1,5,3,9,5,27,7,17,9,21,45,51,27,119,15,33,17,73,153,165,21,45,93,99,51,107,27,231,119,495,31,65,33,273,561,73,297,153,313,325,165,85,693,717,45,93,189,195,99,403,51,843,107,219,443,455,231,471,119,975,495,2015", "code": "\ndef A161501(n):\n    s = bin(n)[2:]\n    if s == s[::-1]:\n        return n\n    for i in range(1,len(s)):\n        if s[i:] == s[-1:i-1:-1]:\n            return int(s+s[i-1::-1],2) \n"}
{"sequence_id": "A161502", "text": "a(n) is the smallest number of binary digits that when appended to the right side of the binary representation of n, forms a binary palindrome.", "sequence": "0,1,0,1,0,2,0,1,0,1,2,2,1,3,0,1,0,2,3,3,0,1,2,2,1,2,0,3,2,4,0,1,0,3,4,1,3,2,3,3,2,1,4,4,0,1,2,2,1,3,0,4,1,2,3,3,2,3,1,4,3,5,0,1,0,4,5,2,4,3,4,4,0,2,5,1,4,2,3,3,2,1,5,5,0,3,4,4,3,4,2,5,0,1,2,2,1,4,0,2,4,3,4,4,3", "code": "\ndef A161502(n):\n    s = bin(n)[2:]\n    if s == s[::-1]:\n        return 0\n    for i in range(1,len(s)):\n        if s[i:] == s[-1:i-1:-1]:\n            return i \n"}
{"sequence_id": "A161606", "text": "a(n) = gcd(A008472(n), A001222(n)).", "sequence": "0,1,1,2,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,2,1,1,1,1,1,3,3,1,1,1,1,2,1,2,1,1,1,2,1,1,3,1,1,1,1,1,5,1,1,2,3,1,1,2,1,2,1,1,2,1,1,1,2,2,1,1,1,2,1,1,5,1,1,1,3,2,3,1,1,1,1,1,4,2,1,2,1,1,2,2,1,2,1,2,1,1,3,1,1,1,1,1,1,3", "code": "\nfrom sympy import primefactors, gcd\ndef a001222(n): return 0 if n==1 else a001222(n//primefactors(n)[-1]) + 1\ndef a(n): return gcd(sum(primefactors(n)), a001222(n))\nprint([a(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A161638", "text": "The largest number of steps in Euclid's algorithm applied to A157807(n) and A157813(n).", "sequence": "1,1,2,2,1,1,2,3,2,2,1,1,2,2,3,3,2,2,4,3,1,1,2,2,3,3,2,2,3,2,1,1,2,3,3,2,3,4,4,3,2,2,4,3,1,1,2,2,2,4,2,3,5,3,3,3,2,2,4,4,3,3,1,1,2,3,2,3,4,3,2,2,3,3,4,3,2,2,1,1,2,3,2,3,3,3,2", "code": "\nfrom fractions import gcd\ndef euclid_steps(a, b):\n..if b == 0:\n....return 0\n..else:\n....return 1 + euclid_steps(b, a % b)\nfor s in range(2, 100, 2):\n..for i in range(1, s):\n....if gcd(i, s - i) != 1: continue\n....print(euclid_steps(i, s - i))\n..for i in range(s, 0, -1):\n....if gcd(i, s + 1 - i) != 1: continue\n....print(euclid_steps(i, s + 1 - i))\n\n"}
{"sequence_id": "A161664", "text": "Sum_{i=1..n} i-d(i), where d(n) is the number of divisors of n (A000005).", "sequence": "0,0,1,2,5,7,12,16,22,28,37,43,54,64,75,86,101,113,130,144,161,179,200,216,238,260,283,305,332,354,383,409,438,468,499,526,561,595,630,662,701,735,776,814,853,895,940,978,1024,1068,1115,1161,1212,1258,1309", "code": "\nfrom math import isqrt\ndef A161664(n): return (lambda m: n*(n+1)//2+m*m-2*sum(n//k for k in range(1, m+1)))(isqrt(n)) \n"}
{"sequence_id": "A161710", "text": "a(n) = (-6*n^7 + 154*n^6 - 1533*n^5 + 7525*n^4 - 18879*n^3 + 22561*n^2 - 7302*n + 2520)/2520.", "sequence": "1,2,3,4,6,8,12,24,39,-2,-295,-1308,-3980,-9996,-22150,-44808,-84483,-150534,-256001,-418588,-661806,-1016288,-1521288,-2226376,-3193341,-4498314,-6234123,-8512892,-11468896,-15261684,-20079482,-26142888", "code": "\nA161710_list, m = [1], [-12, 80, -223, 333, -281, 127, -23, 1]\nfor _ in range(1,10**2):\n    for i in range(7):\n        m[i+1]+= m[i]\n    A161710_list.append(m[-1]) \n"}
{"sequence_id": "A161715", "text": "a(n) = (50*n^7 - 1197*n^6 + 11333*n^5 - 53655*n^4 + 132125*n^3 - 156828*n^2 + 73212*n + 5040)/5040.", "sequence": "1,2,3,5,6,10,15,30,171,886,3359,10143,26072,59502,123931,240048,438261,761754,1270123,2043641,3188202,4840994,7176951,10416034,14831391,20758446,28604967,38862163,52116860,69064806,90525155,117456180", "code": "\nA161710_list, m = [1], [50, -321, 864, -1249, 1024, -452, 85, 1]\nfor _ in range(1,10**2):\n    for i in range(7):\n        m[i+1]+= m[i]\n    A161710_list.append(m[-1]) \n"}
{"sequence_id": "A161721", "text": "Primes p such that the reversal of p is prime and the product of p with its reversal is a palindrome.", "sequence": "2,3,11,101,1021,1201,111211,112111,1000211,1010201,1020101,1101211,1102111,1111021,1112011,1120001,1121011,1201111,10011101,10012001,10021001,10100201,10111001,10200101,11012011,11021011,11100121,12100111", "code": "\nfrom sympy import isprime\nA161721_list = [2]\nfor i in range(3,10**6,2):\n....j = int(str(i)[::-1])\n....if j == i:\n........s = str(i**2)\n........if s == s[::-1] and isprime(i):\n............A161721_list.append(i)\n....elif j > i:\n........s = str(i*j)\n........if s == s[::-1] and isprime(i) and isprime(j):\n............A161721_list.extend([i,j])\nA161721_list = sorted(A161721_list) \n"}
{"sequence_id": "A161886", "text": "Number of nonzero elements in the n X n Redheffer matrix.", "sequence": "1,4,7,11,14,19,22,27,31,36,39,46,49,54,59,65,68,75,78,85,90,95,98,107,111,116,121,128,131,140,143,150,155,160,165,175,178,183,188,197,200,209,212,219,226,231,234,245,249,256,261,268,271,280,285,294,299,304", "code": "\nfrom math import isqrt\ndef A161886(n): return (lambda m: 2*sum(n//k for k in range(1, m+1))+n-1-m*m)(isqrt(n)) \n"}
{"sequence_id": "A162318", "text": "A positive integer n is included if |d(n+1)-d(n)| = 2, where d(n) is the number of divisors of n.", "sequence": "5,6,7,10,13,20,22,27,32,37,45,46,50,51,58,61,62,68,73,74,76,82,91,92,106,115,117,123,124,146,152,153,157,164,166,170,174,178,187,188,193,206,212,226,235,236,245,261,262,267,272,274,277,278,284,291,313,325", "code": "\nfrom sympy import divisor_count\nprint([n for n in range(500) if abs(divisor_count(n + 1) - divisor_count(n)) == 2]) \n"}
{"sequence_id": "A162326", "text": "Let a(0) = a(1) = 1, and n*a(n) = 2*(-7+5*n)*a(n-1) + 9*(2-n)*a(n-2) for n >= 2.", "sequence": "1,1,3,13,71,441,2955,20805,151695,1135345,8671763,67320573,529626839,4213228969,33833367963,273892683573,2232832964895,18314495896545,151037687326755,1251606057754605,10416531069771111,87029307323766681", "code": "\nL = [1, 1]\nfor n in range(2,22):\n    L.append( ((-14 + 10*n)*L[-1] + (18-9*n)*L[-2])//n )\nprint(L)\n\n"}
{"sequence_id": "A162459", "text": "A002321*A000079.", "sequence": "1,0,-4,-8,-32,-32,-128,-256,-512,-512,-2048,-4096,-12288,-16384,-16384,-32768,-131072,-262144,-786432,-1572864,-2097152,-2097152,-8388608,-16777216,-33554432,-33554432,-67108864,-134217728,-536870912,-1610612736,-4294967296", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A162459(n):\n    if n == 0:\n        return 0\n    c, j = n, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A162459(k1)//2**(k1-1)\n        j, k1 = j2, n//j2\n    return 2**(n-1)*(j-c) \n"}
{"sequence_id": "A162510", "text": "Dirichlet inverse of A076479.", "sequence": "1,1,1,2,1,1,1,4,2,1,1,2,1,1,1,8,1,2,1,2,1,1,1,4,2,1,4,2,1,1,1,16,1,1,1,4,1,1,1,4,1,1,1,2,2,1,1,8,2,2,1,2,1,4,1,4,1,1,1,2,1,1,2,32,1,1,1,2,1,1,1,8,1,1,2,2,1,1,1,8,8,1,1,2,1,1,1,4,1,2,1,2,1,1,1,16,1,2,2,4,1,1,1,4,1", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef a(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [2**(f[i] - 1) for i in f]) \n"}
{"sequence_id": "A162511", "text": "Multiplicative function with a(p^e)=(-1)^(e-1)", "sequence": "1,1,1,-1,1,1,1,1,-1,1,1,-1,1,1,1,-1,1,-1,1,-1,1,1,1,1,-1,1,1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,-1,1,1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,1,-1", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef a(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [(-1)**(f[i] - 1) for i in f]) \n"}
{"sequence_id": "A162512", "text": "Dirichlet inverse of A162511.", "sequence": "1,-1,-1,2,-1,1,-1,-4,2,1,-1,-2,-1,1,1,8,-1,-2,-1,-2,1,1,-1,4,2,1,-4,-2,-1,-1,-1,-16,1,1,1,4,-1,1,1,4,-1,-1,-1,-2,-2,1,-1,-8,2,-2,1,-2,-1,4,1,4,1,1,-1,2,-1,1,-2,32,1,-1,-1,-2,1,-1,-1,-8,-1,1,-2,-2,1,-1,-1,-8,8,1", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef a(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [-(-2)**(f[i] - 1) for i in f]) \n"}
{"sequence_id": "A162555", "text": "a(n) = the smallest positive integer not occurring earlier in the sequence such that Sum_{k=1..n} a(k) written in decimal contains decimal n as a substring.", "sequence": "1,11,18,4,16,6,14,8,12,10,13,7,15,5,17,3,19,2,9,30,101,201,301,401,26,76,501,453,49,601,170,32,168,34,20,82,264,38,162,40,160,42,158,44,106,96,154,48,152,50,150,52,148,54,146,56,21,81,242,60,140,62,138,64,136", "code": "\nA162555_list, A162555_set, s = [], set(), 0\nfor i in range(1,10001):\n    j, si = 1, str(i)\n    while si not in str(s+j) or j in A162555_set:\n        j += 1\n    A162555_list.append(j)\n    A162555_set.add(j)\n    s += j \n"}
{"sequence_id": "A162610", "text": "Triangle read by rows in which row n lists n terms, starting with 2n-1, with gaps = n-1 between successive terms.", "sequence": "1,3,4,5,7,9,7,10,13,16,9,13,17,21,25,11,16,21,26,31,36,13,19,25,31,37,43,49,15,22,29,36,43,50,57,64,17,25,33,41,49,57,65,73,81,19,28,37,46,55,64,73,82,91,100,21,31,41,51,61,71,81,91,101,111,121", "code": " \ndef A162610(n, k):\n    return 2*n-1+(k-1)*(n-1)\nprint([A162610(n,k) for n in range(1,20) for k in range(1,n+1)])\n"}
{"sequence_id": "A162614", "text": "Triangle read by rows in which row n lists n+1 terms, starting with n, such that the difference between successive terms is equal to n^3 - 1.", "sequence": "0,1,1,2,9,16,3,29,55,81,4,67,130,193,256,5,129,253,377,501,625,6,221,436,651,866,1081,1296,7,349,691,1033,1375,1717,2059,2401,8,519,1030,1541,2052,2563,3074,3585,4096,9,737,1465,2193,2921,3649,4377,5105,5833", "code": "\ndef A162614(n,k):\n    return n+k*(n**3-1)\nprint([A162614(n,k) for n in range(20) for k in range(n+1)])\n"}
{"sequence_id": "A162874", "text": "Twin primes p and r (p < r) such that p-1, p+1 and r+1 are not cubefree.", "sequence": "69497,69499,416501,416503,474497,474499,632501,632503,960497,960499,1068497,1068499,1226501,1226503,1402871,1402873,1464101,1464103,1635497,1635499,1716497,1716499,1919429,1919431,1986497,1986499", "code": "\nfrom sympy import nextprime, factorint\ndef cubefree(n): return max(e for e in factorint(n).values()) <= 2\ndef auptop(limit):\n    alst, p, r = [], 3, 5\n    while p < limit:\n        if r - p == 2 and not any(cubefree(i) for i in [p-1, p+1, r+1]):\n            alst.extend([p, r])\n        p, r = r, nextprime(p)\n    return alst\nprint(auptop(2*10**6)) \n"}
{"sequence_id": "A162943", "text": "a(n) = 2^(1-A002321(n)).", "sequence": "1,2,4,4,8,4,8,8,8,4,8,8,16,8,4,4,8,8,16,16,8,4,8,8,8,4,4,4,8,16,32,32,16,8,4,4,8,4,2,2,4,8,16,16,16,8,16,16,16,16,8,8,16,16,8,8,4,2,4,4,8,4,4,4,2,4,8,8,4,8,16,16,32,16,16,16,8", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A162943(n):\n    if n == 0:\n        return 2\n    c, j = n, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(4-len(bin(A162943(k1))))\n        j, k1 = j2, n//j2\n    return 2**(1+c-j) \n"}
{"sequence_id": "A163167", "text": "a(n) = sum_{d | phi(n)} mu( phi(d) ) * phi(n)/d, where phi = A000010.", "sequence": "1,1,3,3,5,3,6,5,6,5,15,5,9,6,10,10,20,6,21,10,9,15,36,10,25,9,21,9,41,10,30,20,25,20,18,9,33,21,18,20,50,9,51,25,18,36,72,20,51,25,40,18,65,21,50,18,33,41,87,20,45,30,33,40,36,25,75,40,61,18,120,18,66,33,50,33", "code": "\nfrom sympy import mobius, totient, divisors\ndef a(n):\n    tn = totient(n)\n    return sum(mobius(totient(d))*tn//d for d in divisors(tn))\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A163233", "text": "Two-dimensional Binary Reflected Gray Code: a(i,j) = bits of binary expansion of A003188(i) interleaved with that of A003188(j).", "sequence": "0,1,2,5,3,10,4,7,11,8,20,6,15,9,40,21,22,14,13,41,42,17,23,30,12,45,43,34,16,19,31,28,44,47,35,32,80,18,27,29,60,46,39,33,160,81,82,26,25,61,62,38,37,161,162,85,83,90,24,57,63,54,36,165,163,170,84,87,91", "code": "\ndef a000695(n):\n    n=bin(n)[2:]\n    x=len(n)\n    return sum([int(n[i])*4**(x - 1 - i) for i in range(x)])\ndef a003188(n): return n^(n>>1)\ndef a(n, k): return a000695(a003188(n)) + 2*a000695(a003188(k))\nfor n in range(21): print([a(n - k, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A163234", "text": "Inverse permutation of A163233.", "sequence": "0,1,2,4,6,3,11,7,9,13,5,8,24,18,17,12,28,21,37,29,10,15,16,22,58,48,47,38,31,39,23,30,35,43,27,34,62,52,51,42,14,19,20,26,32,25,41,33,112,98,97,84,73,85,61,72,70,59,83,71,40,49,50,60,120,105,137,121,78", "code": "\ndef A(x, y): return (((x + y)**2) + x + 3*y)//2\ndef a006068(n):\n    s=1\n    while True:\n        ns=n>>s\n        if ns==0: break\n        n=n^ns\n        s<<=1\n    return n\ndef a059905(n): return sum([(n>>2*i&1)<<i for i in range(int(len(bin(n)[2:])//2) + 1)])\ndef a059906(n):\n    x=[int(k) for k in list(bin(n)[2:])][::-1]\n    return sum([x[2*i + 1]*2**i for i in range(len(x)//2)])\ndef a(n): return A(a006068(a059905(n)), a006068(a059906(n)))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A163235", "text": "Two-dimensional Binary Reflected Gray Code, transposed version: a(i,j) = bits of binary expansion of A003188(j) interleaved with that of A003188(i).", "sequence": "0,2,1,10,3,5,8,11,7,4,40,9,15,6,20,42,41,13,14,22,21,34,43,45,12,30,23,17,32,35,47,44,28,31,19,16,160,33,39,46,60,29,27,18,80,162,161,37,38,62,61,25,26,82,81,170,163,165,36,54,63,57,24,90,83,85,168,171,167", "code": "\ndef a000695(n):\n    n=bin(n)[2:]\n    x=len(n)\n    return sum(int(n[i])*4**(x - 1 - i) for i in range(x))\ndef a003188(n): return n^(n>>1)\ndef a(n, k): return a000695(a003188(n)) + 2*a000695(a003188(k))\nfor n in range(21): print([a(k, n - k) for k in range(n + 1)]) \n"}
{"sequence_id": "A163236", "text": "Inverse permutation of A163235.", "sequence": "0,2,1,4,9,5,13,8,6,11,3,7,24,17,18,12,35,27,43,34,14,20,19,26,62,51,52,42,32,41,25,33,28,37,21,29,58,47,48,38,10,16,15,22,31,23,39,30,112,97,98,84,70,83,59,71,73,61,85,72,40,50,49,60,135,119,151,134,90", "code": "\ndef A(x, y): return (((x + y)**2) + x + 3*y)//2\ndef a006068(n):\n    s=1\n    while True:\n        ns=n>>s\n        if ns==0: break\n        n=n^ns\n        s<<=1\n    return n\ndef a059905(n): return sum([(n>>2*i&1)<<i for i in range(int(len(bin(n)[2:])//2) + 1)])\ndef a059906(n):\n    x=[int(k) for k in list(bin(n)[2:])][::-1]\n    return sum([x[2*i + 1]*2**i for i in range(len(x)//2)])\ndef a(n): return A(a006068(a059906(n)), a006068(a059905(n)))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A163241", "text": "Simple self-inverse permutation: Write n in base 4, then replace each digit '2' with '3' and vice versa, then convert back to decimal.", "sequence": "0,1,3,2,4,5,7,6,12,13,15,14,8,9,11,10,16,17,19,18,20,21,23,22,28,29,31,30,24,25,27,26,48,49,51,50,52,53,55,54,60,61,63,62,56,57,59,58,32,33,35,34,36,37,39,38,44,45,47,46,40,41,43,42,64,65,67,66,68,69,71,70", "code": "\ndef a000695(n):\n    n=bin(n)[2:]\n    x=len(n)\n    return sum([int(n[i])*4**(x - 1 - i) for i in range(x)])\ndef a059905(n): return sum([(n>>2*i&1)<<i for i in range(len(bin(n)[2:])//2 + 1)])\ndef a059906(n):\n    x=[int(k) for k in list(bin(n)[2:])][::-1]\n    return sum([x[2*i + 1]*2**i for i in range(len(x)//2)])\ndef a(n): return a000695(a059905(n)^a059906(n)) + 2*a000695(a059906(n))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A163263", "text": "Numbers having multiple representations as the product of non-overlapping ranges of consecutive numbers.", "sequence": "210,720,175560,17297280", "code": "\nimport heapq\ndef aupton(terms, verbose=False):\n    p = 2*3; h = [(p, 2, 3)]; nextcount = 4; alst = []; oldv = None\n    while len(alst) < terms:\n        (v, s, l) = heapq.heappop(h)\n        if v == oldv and ((s > oldl) or (olds > l)) and v not in alst:\n            alst.append(v)\n            if verbose: print(f\"{v}, [= Prod_{{i = {s}..{l}}} i = Prod_{{i = {olds}..{oldl}}} i]\")\n        if v >= p:\n            p *= nextcount\n            heapq.heappush(h, (p, 2, nextcount))\n            nextcount += 1\n        oldv, olds, oldl = v, s, l\n        v //= s; s += 1; l += 1; v *= l\n        heapq.heappush(h, (v, s, l))\n    return alst\nprint(aupton(4, verbose=True)) \n"}
{"sequence_id": "A163491", "text": "A fractal sequence (if we delete the first occurrence of n we get the sequence itself).", "sequence": "1,1,1,2,1,2,3,1,2,4,3,1,5,2,4,6,3,1,7,5,2,8,4,6,9,3,1,10,7,5,11,2,8,12,4,6,13,9,3,14,1,10,15,7,5,16,11,2,17,8,12,18,4,6,19,13,9,20,3,14,21,1,10,22,15,7,23,5,16,24,11,2,25,17,8,26,12", "code": "\ndef a(n): return (n+2)//3 if n%3==1 else a(n*2//3)\nprint([a(n) for n in range(1, 78)]) \n"}
{"sequence_id": "A163498", "text": "Those primes p that after each is written in binary, and a 0 is inserted before every 1, then the value of this new number is also prime.", "sequence": "2,3,11,13,23,37,43,59,79,89,103,109,113,139,149,181,193,197,227,239,263,269,281,283,307,401,433,443,449,457,463,503,523,547,587,617,653,673,691,811,821,823,829,839,877,887,911,937,967,1021,1049,1061,1063", "code": " from sympy import prime, isprime\n[prime(n) for n in range(1,1000) if isprime(int(bin(prime(n)).replace('1','01'),2))] \n"}
{"sequence_id": "A163499", "text": "Take A163498(n) written in binary, insert a 0 before every 1. a(n) is the decimal equivalent of the result.", "sequence": "2,5,37,41,149,137,293,677,1109,593,1301,1321,673,1061,1097,2377,641,1289,2693,10837,2069,2089,2129,4261,4421,2593,5281,21157,2689,5393,21589,43669,4133,4229,8741,8849,9257,4673,18757,20773,20809,41621,41641,21013", "code": " from sympy import prime, isprime\n[int(bin(prime(n)).replace('1','01'),2) for n in range(1,1000) if isprime(int(bin(prime(n)).replace('1','01'),2))] \n"}
{"sequence_id": "A163573", "text": "Primes p such that (p+1)/2, (p+2)/3 and (p+3)/4 are also primes.", "sequence": "12721,16921,19441,24481,49681,61561,104161,229321,255361,259681,266401,291721,298201,311041,331921,419401,423481,436801,446881,471241,525241,532801,539401,581521,600601,663601,704161,709921,783721,867001,904801", "code": "\nfrom sympy import prime, isprime\nA163573_list = [4*q-3 for q in (prime(i) for i in range(1,10000)) if isprime(4*q-3) and isprime(2*q-1) and (not (4*q-1) % 3) and isprime((4*q-1)//3)] \n"}
{"sequence_id": "A163574", "text": "Decimal expansion of smallest zeroless pandigital number in base n such that each k-digit substring (1 <= k <= n-1 = number of base-n digits) starting from the left, is divisible by k (or 0 if none exists).", "sequence": "1,0,27,0,2285,0,874615,0,381654729,0,0,0,559922224824157,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\ndef vgen(n,b):\n....if n == 1:\n........t = list(range(1,b))\n........for i in range(1,b):\n............u = list(t)\n............u.remove(i)\n............yield i, u\n....else:\n........for d, v in vgen(n-1,b):\n............for g in v:\n................k = d*b+g\n................if not k % n:\n....................u = list(v)\n....................u.remove(g)\n....................yield k, u\ndef A163574(n):\n....for a, b in vgen(n-1,n):\n........return a\n....return 0 \n"}
{"sequence_id": "A163585", "text": "a(n) = floor((4*Pi)^n * n!).", "sequence": "1,12,315,11906,598481,37603698,2835252098,249401800589,25072603664742,2835644669262813,356337618445884526,49256576349520039506,7427716723230571769719,1213412735113655221460574,213474717926699991459606943,40239036333940441855233097277", "code": "\nfrom mpmath import mp, pi, fac\nmp.dps = 120\ndef a(n): return int(floor((4*pi)**n*fac(n)))\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A163626", "text": "Triangle read by rows: The n-th derivative of the logistic function written in terms of y, where y = 1/(1 + exp(-x)).", "sequence": "1,1,-1,1,-3,2,1,-7,12,-6,1,-15,50,-60,24,1,-31,180,-390,360,-120,1,-63,602,-2100,3360,-2520,720,1,-127,1932,-10206,25200,-31920,20160,-5040,1,-255,6050,-46620,166824,-317520,332640,-181440,40320,1,-511,18660", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef T(n, k):return 1 if n==0 and k==0 else 0 if k>n or k<0 else (k + 1)*T(n - 1, k) - k*T(n - 1, k - 1)\nfor n in range(51): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A163836", "text": "Composites whose largest prime factor is equal to the sum of all the other prime factors (with repetition).", "sequence": "4,9,25,30,49,70,84,121,169,286,289,308,361,440,495,528,529,594,646,728,819,841,884,961,975,1040,1170,1248,1369,1404,1496,1681,1683,1748,1798,1849,1976,2209,2223,2499,2809,2975,3128,3135,3344,3481,3519,3526,3570", "code": "\nfrom sympy import factorint\ndef ok(n):\n  f = factorint(n)\n  return sum(f[p] for p in f) > 1 and 2*max(f) == sum(p*f[p] for p in f)\nprint(list(filter(ok, range(3571)))) \n"}
{"sequence_id": "A163889", "text": "Number of unlock patterns of length n for the Android operating system.", "sequence": "1,9,56,320,1624,7152,26016,72912,140704,140704", "code": "\ndef f(p, s, x={1:{3:2,7:4,9:5},2:{8:5},3:{1:2,7:5,9:6},4:{6:5},5:{},6:{4:5},7:{1:4,3:5,9:8},8:{2:5},9:{1:5,3:6,7:8}}):\n    return int(s==0) or sum(f(p+[n], s-1) for n in (n for n in range(1,10) if (not p or n not in p and (n not in x[p[-1]] or x[p[-1]][n] in p))))\nprint([f([], s) for s in range(10)]) \n"}
{"sequence_id": "A163981", "text": "a(n) is the smallest prime of the form prime(n+1)*k - prime(n), k >= 1, where prime(n) is the n-th prime.", "sequence": "7,2,2,37,2,89,2,73,151,2,43,127,2,239,59,419,2,73,359,2,401,419,1163,881,307,2,967,2,569,3697,397,691,2,457,2,163,821,839,179,1259,2,2111,2,1777,2,223,3803,3863,2,3499,1201,2,2269,263,269,1889,2,283,1409,2,2647", "code": "\nfrom sympy import isprime, nextprime, prime\ndef a(n):\n    pn = prime(n); pn1 = nextprime(pn); k = 1\n    while not isprime(pn1*k - pn): k += 1\n    return pn1*k - pn\nprint([a(n) for n in range(1, 62)]) \n"}
{"sequence_id": "A164284", "text": "a(n) = 15*n-7.", "sequence": "8,23,38,53,68,83,98,113,128,143,158,173,188,203,218,233,248,263,278,293,308,323,338,353,368,383,398,413,428,443,458,473,488,503,518,533,548,563,578,593,608,623,638,653,668,683,698,713,728,743,758,773,788", "code": "\ndef a(n): return 15*n - 7\nprint([a(n) for n in range(1, 54)]) \n"}
{"sequence_id": "A164387", "text": "Number of binary strings of length n with no substrings equal to 0000 or 0010.", "sequence": "1,2,4,8,14,25,45,82,149,270,489,886,1606,2911,5276,9562,17330,31409,56926,103173,186991,338903,614229,1113231,2017624,3656749,6627505,12011714,21770074,39456161,71510489,129605869,234898146,425730250,771595046,1398441654", "code": "\ndef a(n, adict={0:1, 1:2, 2:4, 3:8, 4:14}):\n    if n in adict:\n        return adict[n]\n    adict[n]=a(n-1)+a(n-2)+a(n-4)+a(n-5)\n    return adict[n] \n"}
{"sequence_id": "A164485", "text": "Number of binary strings of length n with no substrings equal to 0001, 1000 or 1001.", "sequence": "13,21,33,53,85,137,221,357,577,933,1509,2441,3949,6389,10337,16725,27061,43785,70845,114629,185473,300101,485573,785673,1271245,2056917,3328161,5385077,8713237,14098313,22811549,36909861,59721409,96631269", "code": "\nfrom sympy import fibonacci\ndef a(n): return 4*fibonacci(n) + 1\nprint([a(n) for n in range(4, 101)]) \n"}
{"sequence_id": "A164834", "text": "Numbers such that the two adjacent integers are a perfect cube and a prime.", "sequence": "2,28,126,728,3374,6858,19682,24390,29790,50652,91126,250048,274626,300762,328510,357912,571788,753570,970298,1157626,1295028,1442898,1771560,1860868,2146688,2146690,2460374,2924208,3048624,3442950,3581578,4492124,5000212", "code": "\nfrom sympy import isprime\ndef aupto(limit):\n  i, c, alst = 1, 1, []\n  while c <= limit + 1:\n    if isprime(c-2) and c-1 <= limit: alst.append(c-1)\n    if isprime(c+2) and c+1 <= limit: alst.append(c+1)\n    i += 1\n    c = i**3\n  return alst\nprint(aupto(5000212)) \n"}
{"sequence_id": "A164884", "text": "a(n) = image of n under the base-2 Kaprekar map n -> (n with digits sorted into descending order) - (n with digits sorted into ascending order).", "sequence": "0,0,1,0,3,3,3,0,7,9,9,7,9,7,7,0,15,21,21,21,21,21,21,15,21,21,21,15,21,15,15,0,31,45,45,49,45,49,49,45,45,49,49,45,49,45,45,31,45,49,49,45,49,45,45,31,49,45,45,31,45,31,31,0,63,93,93,105,93,105,105,105,93,105,105", "code": "\ndef A164884(n):\n    return int(\"\".join(sorted(bin(n)[2:],reverse=True)),2)-int(\"\".join(sorted(bin(n)[2:])),2) \n"}
{"sequence_id": "A164894", "text": "Base-10 representation of the binary string formed by appending 10, 100, 1000, 10000, ..., etc., to 1.", "sequence": "1,6,52,840,26896,1721376,220336192,56406065280,28879905423616,29573023153783296,60565551418948191232,248076498612011791288320,2032242676629600594233921536,33296264013899376135928570454016,1091051979207454757222107396637212672", "code": "\ndef a(n): return int(\"\".join(\"1\"+\"0\"*i for i in range(n)), 2)\nprint([a(n) for n in range(1, 16)]) \n"}
{"sequence_id": "A164908", "text": "a(n) = (3*4^n - 0^n)/2.", "sequence": "1,6,24,96,384,1536,6144,24576,98304,393216,1572864,6291456,25165824,100663296,402653184,1610612736,6442450944,25769803776,103079215104,412316860416,1649267441664,6597069766656,26388279066624,105553116266496,422212465065984", "code": " print([int(6*4**(n-1)) for n in range(50)]) \n"}
{"sequence_id": "A164944", "text": "Decimal value of the concatenation of first n even numbers in binary.", "sequence": "2,20,166,2664,42634,682156,10914510,349264336,11176458770,357646680660,11444693781142,366230200996568,11719366431890202,375019725820486492,12000631226255567774,768040398480356337568,49154585502742805604386", "code": "\ndef a(n):return int(\"\".join(bin(2*(i+1))[2:] for i in range(n)), 2)\nprint([a(n) for n in range(1, 19)]) \n"}
{"sequence_id": "A165090", "text": "a(n) is the image of n under the base-8 Kaprekar map n -> (n with digits sorted into descending order) - (n with digits sorted into ascending order)", "sequence": "0,0,0,0,0,0,0,0,7,0,7,14,21,28,35,42,14,7,0,7,14,21,28,35,21,14,7,0,7,14,21,28,28,21,14,7,0,7,14,21,35,28,21,14,7,0,7,14,42,35,28,21,14,7,0,7,49,42,35,28,21,14,7,0,63,63,126,189,252,315,378,441,63,0,63,126,189", "code": "\ndef A165090(n):\n    if n==0:return 0\n    return int(\"\".join(sorted(oct(n)[2:],reverse=True)),8)-int(\"\".join(sorted(oct(n)[2:])),8) \n"}
{"sequence_id": "A165192", "text": "a(0) = 1, a(1) = 2, a(3) = 3, a(n) = a(n-1) - a(n-3).", "sequence": "1,2,3,2,0,-3,-5,-5,-2,3,8,10,7,-1,-11,-18,-17,-6,12,29,35,23,-6,-41,-64,-58,-17,47,105,122,75,-30,-152,-227,-197,-45,182,379,424,242,-137,-561,-803,-666,-105,698,1364,1469,771,-593,-2062,-2833,-2240,-178", "code": "\nseries = [1, 2, 3]\nfor i in range(2, 30):\n    series.append(series[i] - series[i - 2])\nprint(series)\n"}
{"sequence_id": "A165361", "text": "Decimal expansion of log 2 times the negative of Granville-Soundararajan constant.", "sequence": "4,5,5,3,9,7,0,1,3,9,8,8,5,5,3,3,8,6,1,8,3,6,2,5,0,2,6,3,3,7,7,5,5,6,6,3,7,5,0,0,0,2,6,2,4,2,1,4,9,3,8,6,7,0,7,0,9,7,3,3,8,8,5,2,6,1,7,8,1,9,8,0,1,2,7,1,4,9,9,7,4,9,3,4,3,1,5,7,1,0,3,7,7,9,8,1,5,9,5,2,9,7,2,7,7", "code": "\nfrom mpmath import mp, pi, sqrt, polylog, log\nmp.dps=106\nC = -log(2)*(4*polylog(2, -sqrt(e)) + pi**2/3 + 1)\nprint([int(n) for n in list(str(C)[2:-1])]) \n"}
{"sequence_id": "A165413", "text": "a(n) is the number of distinct lengths of runs in the binary representation of n.", "sequence": "1,1,1,2,1,2,1,2,2,1,2,1,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,3,2,2,2,3,2,2,1,2,2,2,2,2,2,3,2,1,2,2,2,3,1,3,2,3,2,2,2,1,2,2,2,3,3,2,3,2,3,2,2,2,2,2,3,3,2,2,2,2,2,1,2,2,3,2,2,2,3,2,2,2,2,3,3,2,2,2,2,2,3,2", "code": "\nfrom itertools import groupby\ndef a(n): return len(set([len(list(g)) for k, g in groupby(bin(n)[2:])]))\nprint([a(n) for n in range(1, 106)]) \n"}
{"sequence_id": "A165415", "text": "a(n) = the smallest positive integer that contains more digits written in binary than n has written in binary, and which does not contain binary n as a substring in its binary representation.", "sequence": "7,4,10,8,8,8,18,16,16,16,16,16,16,16,34,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,66,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,130,128,128,128,128,128,128", "code": "\ndef a(n):\n    if n == 2: return 7\n    digs = n.bit_length()\n    return int(2**digs) if n != 2**(digs - 1) else int(2**digs + 2)\nprint([a(n) for n in range(2, 71)]) \n"}
{"sequence_id": "A165443", "text": "a(n) = ( 16^(2*n+1) + 81^(2*n+1) )/97.", "sequence": "1,5521,35957041,235845988561,1547368082644081,10152277523461827601,66609091687940958003121,437022250271846649679394641,2867302983958645970747063186161,18812374877733491600234823630721681", "code": " for n in range(0, 10): print(int((16**(2*n+1)+81**(2*n+1))/97), end=', ') \n"}
{"sequence_id": "A165449", "text": "Write the prime numbers in a string: 2357111317192329... (cf. A033308). The sequence gives the first position in the string for natural numbers.", "sequence": "5,1,2,21,3,31,4,41,12,47,5,62,7,22,77,32,9,95,11,589,110,113,1,128,131,137,63,149,15,158,8,14,123,24,2,188,19,42,72,206,21,215,23,227,233,236,25,248,75,257,78,263,27,269,275,278,3,290,29,299,31,829", "code": "\nfrom sympy import primerange\nfrom itertools import count, takewhile\ndef afind(plimit):\n  s = \"\".join(str(p) for p in primerange(1, plimit+1))\n  return [1+s.find(str(n)) for n in takewhile(lambda i: str(i) in s, count(1))]\nprint(afind(10**4)) \n"}
{"sequence_id": "A165457", "text": "a(n) = (2*n+1)!*(2*n+3)/3.", "sequence": "1,10,280,15120,1330560,172972800,31135104000,7410154752000,2252687044608000,851515702861824000,391697223316439040000,215433472824041472000000,139600890389978873856000000", "code": "\nimport math\nfor n in range(0, 12): print(int(math.factorial(2*n+1)*(2*n+3)/3), end=', ') \n"}
{"sequence_id": "A165458", "text": "a(0)=1, a(1)=4, a(n) = 12*a(n-2) - a(n-1).", "sequence": "1,4,8,40,56,424,248,4840,-1864,59944,-82312,801640,-1789384,11409064,-32881672,169790440,-564370504,2601855784,-9374301832,40596571240,-153088193224,640247048104,-2477305366792,10160269944040,-39887934345544,161811173674024", "code": " for n in range(0, 30): print(int((8*3**n-(-4)**n)/7), end=', ') \n"}
{"sequence_id": "A165460", "text": "The height at the 1/3 point of Jacobi-bridge, computed for 12n+7. a(n) = Sum_{i=0..(4n+2)} J(i,12n+7), where J(i,m) is the Jacobi symbol.", "sequence": "2,2,6,2,8,2,10,4,10,4,10,6,14,2,4,4,18,6,14,4,12,8,22,6,16,6,20,6,2,8,18,6,28,4,20,4,30,12,14,0,14,6,28,10,28,6,32,10,16,8,26,10,26,6,24,8,36,10,28,8,26,10,30,8,0,10,32,14,18,12,0,14,44,6,32,6,38,0,32,8,22", "code": "\nfrom sympy import jacobi_symbol as J\ndef a(n): return sum([J(i, 12*n + 7) for i in range(4*n + 3)]) \n"}
{"sequence_id": "A165470", "text": "a(0)=1, a(1)=5, a(n) = 20*a(n-2) - a(n-1).", "sequence": "1,5,15,85,215,1485,2815,26885,29415,508285,80015,10085685,-8485385,210199085,-379906785,4583888485,-12182024185,103859793885,-347500277585,2424696155285,-9374701706985,57868624812685,-245362658952385,1402735155206085,-6309988334253785", "code": " for n in range(0, 30): print(int((10*4**n-(-5)**n)/9), end=', ') \n"}
{"sequence_id": "A165552", "text": "a(1) = 1, and then a(n) is sum of k*a(k) where k<n and k divides n.", "sequence": "1,1,1,3,1,6,1,15,4,8,1,54,1,10,9,135,1,78,1,100,11,14,1,822,6,16,40,162,1,262,1,2295,15,20,13,2142,1,22,17,2220,1,420,1,334,180,26,1,22710,8,238,21,444,1,2562,17,4818,23,32,1,10782,1,34,278,75735,19,856,1,712", "code": "\nfrom sympy import divisors\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n): return 1 if n==1 else sum(d*a(d) for d in divisors(n)[:-1])\nprint([a(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A165562", "text": "Numbers n for which n+n' is prime, n' being the arithmetic derivative of n.", "sequence": "2,6,10,14,15,21,26,30,33,34,35,38,42,46,51,55,57,58,65,66,74,78,85,86,93,102,110,111,118,123,141,143,145,155,158,161,166,177,178,182,185,186,194,201,203,205,206,209,210,215,221,230,246,254,258,267,278,282,290", "code": "\nfrom sympy import isprime, factorint\nA165562 = [n for n in range(1,10**5) if isprime(n+sum([int(n*e/p) for p,e in factorint(n).items()]))] \n"}
{"sequence_id": "A165601", "text": "Midpoint height of Jacobi-bridge, computed for 4n+3. a(n) = Sum_{i=0..(2n+1)} J(i,4n+3), where J(i,m) is the Jacobi symbol.", "sequence": "1,1,3,2,3,3,1,3,6,4,3,5,6,4,9,2,3,7,2,5,9,6,6,8,0,5,9,8,6,10,6,5,15,2,9,10,0,7,12,10,3,11,6,2,15,8,6,13,12,9,12,0,9,14,12,7,15,12,6,15,1,6,21,12,12,13,6,11,0,6,9,14,12,8,24,10,9,19,0,10,12,12,9,18,18,1,15", "code": "\nfrom sympy import jacobi_symbol as J\ndef a(n): return sum([J(i, 4*n + 3) for i in range(2*n + 2)]) \n"}
{"sequence_id": "A165754", "text": "a(n) = nimsum(n+(n+1)+(n+2)).", "sequence": "3,0,5,2,7,4,9,6,11,8,13,10,15,12,17,14,19,16,21,18,23,20,25,22,27,24,29,26,31,28,33,30,35,32,37,34,39,36,41,38,43,40,45,42,47,44,49,46,51,48,53,50,55,52,57,54,59,56,61,58,63,60,65,62,67,64,69,66,71,68,73,70", "code": "\nn = 0\nwhile n < 100:\n    print(n^(n+1)^(n+2), end=',')\n    n += 1\n"}
{"sequence_id": "A165794", "text": "Nimsum of pairs of consecutive Lucas numbers.", "sequence": "3,2,7,3,12,25,15,50,99,55,188,389,843,322,1567,3531,1388,7009,12823,8082,25739,50479,24828,94029,203347,436994,169975,812115,1793132,911369,3247295,6798738,3281747,12244295,33047100,13090261,46475931", "code": "\na = 2\nb = 1\nwhile b < 2000:\n    c = a^b\n    print(c)\n    a, b = b, a+b\n"}
{"sequence_id": "A165911", "text": "a(n) = squarefree kernel (or radical) of a(n-1) + a(n-2), with a(0)=0 and a(1)=1.", "sequence": "0,1,1,2,3,5,2,7,3,10,13,23,6,29,35,2,37,39,38,77,115,6,11,17,14,31,15,46,61,107,42,149,191,170,19,21,10,31,41,6,47,53,10,21,31,26,57,83,70,51,11,62,73,15,22,37,59,6,65,71,34,105,139,122,87,209,74,283,357,10", "code": "\nfrom operator import mul\nfrom sympy import primefactors\nfrom functools import reduce\ndef rad(n): return 1 if n<2 else reduce(mul, primefactors(n))\nl=[0, 1]\nfor n in range(2, 101):\n    l.append(rad(l[n - 1] + l[n - 2]))\nprint(l) \n"}
{"sequence_id": "A166100", "text": "Sum of those positive i <= 2n+1, for which J(i,2n+1)=+1. Here J(i,k) is the Jacobi symbol.", "sequence": "1,1,5,7,27,22,39,15,68,76,63,92,250,117,203,186,165,175,333,156,410,430,270,423,1029,357,689,440,513,767,915,504,780,1072,759,994,1314,725,1155,1343,2187,1577,1360,957,1958,1547,1395,1330,2328,1485,2525", "code": "\nfrom sympy import jacobi_symbol as J\ndef a(n): return sum([i for i in range(1, 2*n + 2) if J(i, 2*n + 1)==1]) \n"}
{"sequence_id": "A166267", "text": "Number of 1's in the binary representation of A000129(n).", "sequence": "0,1,1,2,2,4,3,4,4,7,5,8,6,7,10,11,10,8,13,12,12,14,16,17,11,14,17,20,16,17,19,21,23,17,17,19,24,24,25,18,29,26,29,26,26,29,35,29,26,40,29,33,33,38,36,34,28,38,42,40,37,34,40,27,45,35,37,41,40,44,48,45,41,45", "code": "\ndef A000129(n):\n    if n <=1:\n        return n\n    else:\n        return 2*A000129(n-1)+A000129(n-2)\ndef A000120(n):\n    a=0\n    sh=n\n    while sh > 0:\n        a += sh & 1\n        sh >>= 1\n    return a\ndef A166267(n):\n    return A000120(A000129(n))\nprint([A166267(n) for n in range(30)])\n\n"}
{"sequence_id": "A166374", "text": "Numbers whose arithmetic derivative is equal to Euler totient function: n' = phi(n).", "sequence": "2,9,15,625,1225,3993,117649,218491,857375,3788435,4259571,69302975,136410197,200533921,313742585,603439225,1516358753,2563893625,3326174929,5655792025,10214476341,25937424601,29677977573,59797108943,283867750439,715167055525", "code": "\nfrom sympy import factorint, totient\nA166374 = [n for n in range(1,10**6) if sum([int(n*e/p) for p,e in factorint(n).items()]) == totient(n)] \n"}
{"sequence_id": "A166404", "text": "Self-inverse permutation of natural numbers obtained by exchanging the run lengths of adjacent runs of ones and zeros in the binary expansion of n, starting from the most significant run of 1's. (See the example lines).", "sequence": "0,1,2,3,6,5,4,7,14,13,10,11,12,9,8,15,30,29,26,27,22,21,20,23,28,25,18,19,24,17,16,31,62,61,58,59,54,53,52,55,46,45,42,43,44,41,40,47,60,57,50,51,38,37,36,39,56,49,34,35,48,33,32,63,126,125,122,123,118,117", "code": "\ndef a(n):\n    if n==0: return 0\n    x=bin(n)[2:]\n    r=[]\n    s=1\n    p=\"\"\n    for i in range(1, len(x)):\n        if x[i - 1]==x[i]: s+=1\n        else:\n            r+=[s, ]\n            s=1\n    l=r+[s]\n    L=[]\n    if len(l)%2==0:\n        for i in range(0, len(l), 2): L+=[l[i + 1], l[i]]\n    else:\n        b=l[-1]\n        for i in range(0, len(l) - 1, 2): L+=[l[i + 1], l[i]]\n        L+=[b, ]\n    for i in range(len(L)):\n        if i%2==0: p+='1'*L[i]\n        else: p+='0'*L[i]\n    return int(p, 2)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A166405", "text": "Sum of those positive i <= 2n+1, for which J(i,2n+1)=-1. Here J(i,k) is the Jacobi symbol.", "sequence": "0,2,5,14,0,33,39,45,68,95,63,161,0,126,203,279,165,245,333,312,410,473,270,658,0,459,689,660,513,944,915,630,780,1139,759,1491,1314,775,1155,1738,0,1826,1360,1479,1958,1729,1395,2090,2328,1485,2525,2884", "code": "\nfrom sympy import jacobi_symbol as J\ndef a(n): return sum(i for i in range(1, 2*n + 2) if J(i, 2*n + 1)==-1)\n\n"}
{"sequence_id": "A166406", "text": "a(n) = A166405(n)-A166100(n).", "sequence": "-1,1,0,7,-27,11,0,30,0,19,0,69,-250,9,0,93,0,70,0,156,0,43,0,235,-1029,102,0,220,0,177,0,126,0,67,0,497,0,50,0,395,-2187,249,0,522,0,182,0,760,0,0,0,515,0,321,0,888,0,230,0,1190,-6655,246,0,635,0,655,0", "code": "\nfrom sympy import jacobi_symbol as J\ndef a(n):\n    l=0\n    m=0\n    for i in range(1, 2*n + 2):\n        if J(i, 2*n + 1)==-1: l+=i\n        elif J(i, 2*n + 1)==1: m+=i\n    return l - m\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A166407", "text": "a(n) = floor(3*(A166406(n)/A005408(n))).", "sequence": "-3,1,0,3,-9,3,0,6,0,3,0,9,-30,1,0,9,0,6,0,12,0,3,0,15,-63,6,0,12,0,9,0,6,0,3,0,21,0,2,0,15,-81,9,0,18,0,6,0,24,0,0,0,15,0,9,0,24,0,6,0,30,-165,6,0,15,0,15,0,6,0,9,0,30,0,0,0,21,0,12,0,30,0,3,0,33,-234,6,0,6", "code": "\nfrom sympy import floor, jacobi_symbol as J\ndef a(n):\n    l=0\n    m=0\n    for i in range(1, 2*n + 2):\n        if J(i, 2*n + 1)==-1: l+=i\n        elif J(i, 2*n + 1)==1: m+=i\n    return floor(3*((l - m)/(2*n + 1)))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A166408", "text": "a(n) = floor(A166407(n)/3).", "sequence": "-1,0,0,1,-3,1,0,2,0,1,0,3,-10,0,0,3,0,2,0,4,0,1,0,5,-21,2,0,4,0,3,0,2,0,1,0,7,0,0,0,5,-27,3,0,6,0,2,0,8,0,0,0,5,0,3,0,8,0,2,0,10,-55,2,0,5,0,5,0,2,0,3,0,10,0,0,0,7,0,4,0,10,0,1,0,11,-78,2,0,2,0,5,0,8,0,2,0", "code": "\nfrom sympy import floor, jacobi_symbol as J\ndef a(n):\n    l=0\n    m=0\n    for i in range(1, 2*n + 2):\n        if J(i, 2*n + 1)==-1: l+=i\n        elif J(i, 2*n + 1)==1: m+=i\n    return floor(3*((l - m)/(2*n + 1)))//3\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A166409", "text": "Odd numbers corresponding to the positions of zeros in A166406.", "sequence": "5,13,17,21,29,33,37,41,45,53,57,61,65,69,73,77,85,89,93,97,99,101,105,109,113,117,125,129,133,137,141,145,147,149,153,157,161,165,173,177,181,185,189,193,197,201,205,207,209,213,217,221,229,233,237,241", "code": "\nfrom sympy import jacobi_symbol as J\ndef a(n):\n    l=0\n    m=0\n    for i in range(1, 2*n + 2):\n        if J(i, 2*n + 1)==-1: l+=i\n        elif J(i, 2*n + 1)==1: m+=i\n    return l - m\nprint([2*n + 1 for n in range(201) if a(n)==0]) \n"}
{"sequence_id": "A166456", "text": "Row sums of triangle A166455.", "sequence": "1,2,6,12,30,60,124,248,510,1020,2044,4088,8188,16376,32760,65520,131070,262140,524284,1048568,2097148,4194296,8388600,16777200,33554428,67108856,134217720,268435440,536870904,1073741808,2147483632", "code": "\ndef A000120(n):\n    a = 0\n    while n > 0:\n        a += n % 2\n        n //= 2\n    return a\ndef A001316(n):\n    return 2**A000120(n)\ndef A166456(n):\n    return 2**(n+1) - A001316(n)\nprint([A166456(n) for n in range(80)])\n\n"}
{"sequence_id": "A166540", "text": "Number of ways to place 2 nonattacking kings on an n X n X n raumschach board.", "sequence": "0,0,0,193,1548,6714,21280,55395,125748,257908,489024,870885,1473340,2388078,3732768,5655559,8339940,12009960,16935808,23439753,31902444,42769570,56558880,73867563,95379988,121875804,154238400,193463725,240669468,297104598,364159264", "code": " \nm=int(input('What\\'s the biggest board to investigate? '))\nfor n in range (0, m+1):\n    sum=0\n    for x1 in range (1, n+1):\n      for y1 in range (1, n+1):\n        for z1 in range (1, n+1):\n          for x2 in range (1, n+1):\n            for y2 in range (1, n+1):\n              for z2 in range (1, n+1):\n                if abs(x1-x2)>1 or abs(y1-y2)>1 or abs(z1-z2)>1:\n                  sum=sum+1\n    sum=sum//2\n    print(n, sum)\n"}
{"sequence_id": "A166623", "text": "Irregular triangle read by rows, in which row n lists the M\u00fcnchhausen numbers in base n, for 2 <= n.", "sequence": "1,2,1,5,8,1,29,55,1,1,3164,3416,1,3665,1,1,28,96446,923362,1,3435,1,34381388,34381640,1,20017650854,1,93367,30033648031,8936504649405,8936504649431,1,31,93344,17852200903304,606046687989917", "code": "\nfrom itertools import combinations_with_replacement\nfrom sympy.ntheory.factor_ import digits\nA166623_list = []\nfor b in range(2,20):\n    sublist = []\n    for l in range(1,b+2):\n        for n in combinations_with_replacement(range(b),l):\n            x = sum(d**d for d in n)\n            if tuple(sorted(digits(x,b)[1:])) == n:\n                sublist.append(x)\n    A166623_list.extend(sorted(sublist)) \n"}
{"sequence_id": "A166727", "text": "Positive integers with English names ending in \"r\".", "sequence": "4,24,34,44,54,64,74,84,94,104,124,134,144,154,164,174,184,194,204,224,234,244,254,264,274,284,294,304,324,334,344,354,364,374,384,394,404,424,434,444,454,464,474,484,494,504,524,534,544,554,564,574,584,594", "code": "\ndef a(n): return (n-1)//9*100 + ((n-1)%9 + 1)*((n-1)%9 > 0)*10 + 4\nprint([a(n) for n in range(1, 55)]) \n"}
{"sequence_id": "A166728", "text": "Positive integers with English names ending in \"x\".", "sequence": "6,26,36,46,56,66,76,86,96,106,126,136,146,156,166,176,186,196,206,226,236,246,256,266,276,286,296,306,326,336,346,356,366,376,386,396,406,426,436,446,456,466,476,486,496,506,526,536,546,556,566,576,586,596", "code": "\ndef agen(lim): yield from (k for k in range(6, lim+1, 10) if k%100 != 16)\nprint([an for an in agen(600)]) \n"}
{"sequence_id": "A166921", "text": "Least prime with exactly n prime anagrams not equal to itself.", "sequence": "2,13,113,149,1013,1039,1427,1123,1439,1579,1237,10271,10453,10139,10253,10243,10457,11579,10789,10273,11239,12457,10729,13249,12347,13687,12539,14759,13799,10739,12637,12893,23957,13597,100493,12379,14593,101383,13789", "code": " \nfrom sympy import isprime\nfrom itertools import permutations\ndef anagrams(n):\n  s = str(n)\n  return set(int(\"\".join(p)) for p in permutations(s) if p[0] != '0')\ndef num_prime_anagrams(n): return sum(isprime(i) for i in anagrams(n))\ndef a(n):\n  if n == 0: return 2\n  k = 3\n  while not isprime(k) or num_prime_anagrams(k) != n+1: k += 2\n  return k\nprint([a(n) for n in range(39)]) \n"}
{"sequence_id": "A166923", "text": "Digital root of prime(n)^2.", "sequence": "4,9,7,4,4,7,1,1,7,4,7,1,7,4,4,1,7,4,7,1,1,4,4,1,4,4,7,1,1,7,1,7,4,7,7,4,7,1,7,4,1,1,4,7,1,1,7,4,4,7,1,7,4,1,7,4,1,1,4,4,7,7,1,7,4,4,4,7,7,4,4,1,4,7,1,7,4,1,7,7,7,4,1,1,4,4,1,4,4,7,1,4,1,7,7,1,7,1,1,1,4,1,7,4,7", "code": "\nfrom sympy import prime\ndef A166923(n):\n....return 1 + (prime(n)**2-1) % 9 \n"}
{"sequence_id": "A167197", "text": "a(6) = 7, for n >= 7, a(n) = a(n - 1) + gcd(n, a(n - 1))", "sequence": "7,14,16,17,18,19,20,21,28,29,30,31,32,33,34,35,36,37,38,39,52,53,54,55,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,116,117,120,121,122,123,124,125,126,127,128", "code": "\nfrom math import gcd\ndef aupton(nn):\n    alst = [7]\n    for n in range(7, nn+1): alst.append(alst[-1] + gcd(n, alst[-1]))\n    return alst\nprint(aupton(68)) \n"}
{"sequence_id": "A167216", "text": "Primes whose reversal - 1 is also prime.", "sequence": "3,23,41,47,83,89,233,251,257,281,401,461,491,809,821,827,839,857,863,887,2003,2069,2081,2099,2153,2213,2237,2267,2333,2351,2381,2393,2399,2477,2591,2633,2657,2711,2741,2753,2789,2819,2879,2909,2939,2957,2963", "code": "\nfrom sympy import isprime, primerange\ndef ok(p): return isprime(int(str(p)[::-1]) - 1)\nprint([p for p in primerange(1, 3000) if ok(p)]) \n"}
{"sequence_id": "A167218", "text": "Primes whose reversal - 1 is a square.", "sequence": "2,5,71,73,101,109,263,269,523,541,587,1061,1063,2089,2251,2273,2297,2843,2861,5441,5477,5483,6203,6221,7129,7507,7937,10009,10163,10169,10487,10691,20201,20693,22391,22769,24023,24877,26141,26171,26723", "code": "\nfrom sympy import isprime\nA167218_list, i, j = [], 0, 1\nwhile j < 10**10:\n    p = int(str(j)[::-1])\n    if j % 10 and isprime(p):\n        A167218_list.append(p)\n    j += 2*i+1\n    i += 1\nA167218_list = sorted(A167218_list) \n"}
{"sequence_id": "A167267", "text": "Interspersion of the signature sequence of (1+sqrt(5))/2.", "sequence": "1,3,2,7,5,4,12,10,8,6,19,16,14,11,9,28,24,21,18,15,13,38,34,30,26,23,20,17,50,45,41,36,32,29,25,22,63,58,53,48,43,39,35,31,27,78,72,67,61,56,51,46,42,37,33", "code": "\n\nimport math\nfrom sympy import sqrt\nr=(1 + sqrt(5))/2\ndef s(n): return 1 if n<1 else s(n - 1) + 1 + int(math.floor(n*r))\ndef p(n): return n + 1 + sum(int(math.floor((n - k)/r)) for k in range(n+1))\nv=[s(n) for n in range(101)]\nu=[p(n) for n in range(101)]\ndef w(i, j): return u[i - 1] + v[j - 1] + (i - 1) * (j - 1) - 1\nfor n in range(1, 11):\n    print([w(k, n - k + 1) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A167489", "text": "Product of run lengths in binary representation of n.", "sequence": "1,1,1,2,2,1,2,3,3,2,1,2,4,2,3,4,4,3,2,4,2,1,2,3,6,4,2,4,6,3,4,5,5,4,3,6,4,2,4,6,3,2,1,2,4,2,3,4,8,6,4,8,4,2,4,6,9,6,3,6,8,4,5,6,6,5,4,8,6,3,6,9,6,4,2,4,8,4,6,8,4,3,2,4,2,1,2,3,6,4,2,4,6,3,4,5,10,8,6,12,8,4,8", "code": "\ndef A167489(n):\n  '''Product of run lengths in binary representation of n.'''\n  p = 1\n  b = n%2\n  i = 0\n  while (n != 0):\n    n >>= 1\n    i += 1\n    if ((n%2) != b):\n      p *= i\n      i = 0\n      b = n%2\n  return(p)\n\n"}
{"sequence_id": "A167508", "text": "Number of different letters in the French spelling of the number n.", "sequence": "4,2,4,5,6,4,3,4,4,4,3,4,5,5,8,6,4,7,6,7,5,7,9,8,10,7,7,8,7,8,4,5,7,7,7,7,7,6,7,6,7,7,9,10,7,9,10,9,9,8,8,8,10,11,9,8,10,10,9,9,8,9,10,9,11,10,8,9,10,10,9,9,11,10,12,11,9,10,11,11,10,10,12,12,10,11,12,12,11,11,12", "code": "\nimport re\nfrom num2words import num2words\nfrom unidecode import unidecode\ndef A167508(n): return len(set(re.sub(\"[^a-z]\", \"\", unidecode(num2words(n, lang='fr'))))) \n"}
{"sequence_id": "A167535", "text": "Primes which are the concatenation of two squares (in decimal notation).", "sequence": "11,19,41,149,181,251,449,491,499,641,811,1009,1289,1361,1699,2251,2549,4001,4289,4441,4729,6449,6481,6761,7841,8419,9001,9619,10891,11369,11681,12149,12251,12401,12601,12809,13249,13691,13721,14449,14489", "code": "\nfrom sympy import isprime\ndef aupto(lim):\n    s = list(i**2 for i in range(1, int(lim**(1/2))+2))\n    t = set(int(str(a)+str(b)) for a in s for b in s)\n    return sorted(filter(isprime, filter(lambda x: x<=lim, t)))\nprint(aupto(15000)) \n"}
{"sequence_id": "A167764", "text": "a(n) is the index k of k-th prime prime(k) in the smallest concatenation \"2 3 ... prime(k)\" where prime(n+1) is a factor.", "sequence": "10,3,5,7,18,11,58,2,6,28,177,85,47,3,191,35,9,12,40,108,40,60,69,43,84,314,29,77,231,59,76,49,86,289,5,51,71,43,269,101,53,78,42,46,958,22,5,101,151,65,198,80,22,428,363,172,686,494,399,11,96,425,277,525", "code": "\nfrom sympy import nextprime, prime\ndef a(n):\n    pn1 = prime(n+1)\n    k, pk, s = 1, 2, \"2\"\n    while int(s)%pn1:\n        k += 1; pk = nextprime(pk); s += str(pk)\n    return k\nprint([a(n) for n in range(1, 65)]) \n"}
{"sequence_id": "A167807", "text": "Square pyramidal numbers which are sums of three consecutive primes.", "sequence": "1015,25585,1623245,2127685,7838831,8865649,19849115,52051769,73998155,88409285,91753025,161553785,216862421,289872105,347016319,382029011,466430159,835713879,1077314939,1223359835,1509659555,1584781241", "code": "\nfrom __future__ import division\nfrom sympy import nextprime, prevprime\nA167807_list = []\nfor i in range(3,10**6):\n    n = i*(i+1)*(2*i+1)//6\n    p2 = prevprime(n//3)\n    p1, p3 = prevprime(p2), nextprime(p2)\n    q = p1+p2+p3\n    while q <= n:\n        if q == n:\n            A167807_list.append(n)\n        p1, p2, p3 = p2, p3, nextprime(p3)\n        q = p1+p2+p3 \n"}
{"sequence_id": "A168183", "text": "Numbers that are not multiples of 9.", "sequence": "1,2,3,4,5,6,7,8,10,11,12,13,14,15,16,17,19,20,21,22,23,24,25,26,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44,46,47,48,49,50,51,52,53,55,56,57,58,59,60,61,62,64,65,66,67,68,69,70,71,73,74,75,76,77,78,79,80", "code": " from gmpy2 import f_mod\n[n for n in range(100) if f_mod(n,9)] \n"}
{"sequence_id": "A168221", "text": "a(n) = A006368(A006368(n)).", "sequence": "0,1,2,3,9,6,7,4,18,5,11,12,27,15,16,8,36,10,20,21,45,24,25,13,54,14,29,30,63,33,34,17,72,19,38,39,81,42,43,22,90,23,47,48,99,51,52,26,108,28,56,57,117,60,61,31,126,32,65,66,135,69,70,35,144,37,74,75,153,78,79,40", "code": "\ndef A006368(n):\n    if n%2 == 0:\n        return 3*(n//2)\n    elif n%4 == 1:\n        return 3*(n//4)+1\n    else:\n        return 3*(n+1)//4-1\nn = 0\nwhile n < 30:\n    print(n,A006368(A006368(n)))\n    n = n+1 \n"}
{"sequence_id": "A168294", "text": "Carryless product n times n+1.", "sequence": "0,2,6,2,0,0,2,6,2,90,110,132,156,172,190,110,132,156,172,280,420,462,406,442,480,420,462,406,442,670,930,992,956,912,970,930,992,956,912,260,640,622,606,682,660,640,622,606,682,50,550,552,556,552,550,550,552,556,552", "code": "\ndef A168294(n):\n    s, t = [int(d) for d in str(n)], [int(d) for d in str(n+1)]\n    l, m = len(s), len(t)\n    u = [0]*(l+m-1)\n    for i in range(l):\n        for j in range(m):\n            u[i+j] = (u[i+j] + s[i]*t[j]) % 10\n    return int(\"\".join(str(d) for d in u)) \n"}
{"sequence_id": "A169594", "text": "Number of divisors of n, counting divisor multiplicity in n.", "sequence": "1,2,2,4,2,4,2,6,4,4,2,7,2,4,4,9,2,7,2,7,4,4,2,10,4,4,6,7,2,8,2,11,4,4,4,12,2,4,4,10,2,8,2,7,7,4,2,14,4,7,4,7,2,10,4,10,4,4,2,13,2,4,7,15,4,8,2,7,4,8,2,16,2,4,7,7,4,8,2,14,9,4,2,13,4,4,4,10,2,13,4,7,4,4,4,17,2,7", "code": "\ndef a286561(n, k):\n    i=1\n    if k==1: return 1\n    while n%(k**i)==0:\n        i+=1\n    return i-1\ndef a(n): return sum([a286561(n, d) for d in divisors(n)]) \n"}
{"sequence_id": "A169613", "text": "Triangular array: T(n,k)=floor(F(n)/F(n-k)), k=1,2,...,n-2; n>=3, where F=A000045 (Fibonacci numbers).", "sequence": "2,1,3,1,2,5,1,2,4,8,1,2,4,6,13,1,2,4,7,10,21,1,2,4,6,11,17,34,1,2,4,6,11,18,27,55,1,2,4,6,11,17,29,44,89,1,2,4,6,11,18,28,48,72,144,1,2,4,6,11,17,29,46,77,116,233,1,2,4,6,11,17,29,47,75,125,188,377,1,2,4,6,11", "code": "\nfrom sympy import fibonacci as F, floor\ndef T(n, k): return floor(F(n)/F(n - k))\nfor n in range(3, 16): print([T(n, k) for k in range(1, n - 1)]) \n"}
{"sequence_id": "A169639", "text": "Write n in French (cf. A167507) and sum the letters using a=1, ..., z=26.", "sequence": "64,35,54,81,82,43,52,60,58,46,37,60,71,83,123,92,64,97,95,83,72,132,126,153,154,115,124,132,130,118,82,142,136,163,164,125,134,142,140,128,97,157,151,178,179,140,149,157,155,143,104,164,158,185,186,147,156,164", "code": "\nfrom num2words import num2words\nfrom unidecode import unidecode\ndef A169639(n): return sum(ord(s)-96 for s in unidecode(num2words(n,lang='fr')) if s.isalpha()) \n"}
{"sequence_id": "A169652", "text": "a(1) = 5, a(n) = square of sum of previous terms.", "sequence": "5,25,900,864900,749661588900,561993796031809299372900,315837026779085485103717848762253067469831416900,99753027484652761836825641888570160231510113731744254964202314837133807826801896930564374920900", "code": "\n\nlst=[5]\nprint(\"1 5\")\ni=2\na=sum(lst)**2\nwhile i<=11:\n    print(str(i)+\" \"+str(a))\n    lst.append(a)\n    i+=1\n    a=sum(lst)**2 \n"}
{"sequence_id": "A169824", "text": "Numbers n such that n is divisible by n-with-its-digits-reversed.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,20,22,30,33,40,44,50,55,60,66,70,77,80,88,90,99,100,101,110,111,121,131,141,151,161,171,181,191,200,202,212,220,222,232,242,252,262,272,282,292,300,303,313,323,330,333,343,353,363,373,383,393", "code": "\nA169824_list = [n for n in range(1,1000) if not n % int(str(n)[::-1])] \n"}
{"sequence_id": "A169834", "text": "Numbers k such that d(k-1) = d(k) = d(k+1).", "sequence": "34,86,94,142,202,214,218,231,243,244,302,375,394,446,604,634,664,698,903,922,1042,1106,1138,1262,1275,1310,1335,1346,1402,1642,1762,1833,1838,1886,1894,1925,1942,1982,2014,2055,2102,2134,2182,2218,2265,2306,2344,2362", "code": "\nfrom sympy import divisor_count as d\ndef ok(n): return d(n-1) == d(n) == d(n+1)\nprint(list(filter(ok, range(1, 2400)))) \n"}
{"sequence_id": "A169843", "text": "EKG sequence started at 6 instead of 2.", "sequence": "6,2,4,8,10,5,15,3,9,12,14,7,21,18,16,20,22,11,33,24,26,13,39,27,30,25,35,28,32,34,17,51,36,38,19,57,42,40,44,46,23,69,45,48,50,52,54,56,49,63,60,55,65,70,58,29,87,66,62,31,93,72,64,68,74,37,111,75,78,76,80,82,41", "code": "\nfrom math import gcd\ndef aupton(terms):\n  alst, aset = [1, 6], {1, 6}\n  for n in range(2, terms+1):\n    k = 2\n    while True:\n      while k in aset: k += 1\n      if gcd(alst[-1], k) != 1: alst.append(k); aset.add(k); break\n      k += 1\n  return alst[1:]\nprint(aupton(73)) \n"}
{"sequence_id": "A169851", "text": "EKG sequence started at 10 instead of 2.", "sequence": "10,2,4,6,3,9,12,8,14,7,21,15,5,20,16,18,22,11,33,24,26,13,39,27,30,25,35,28,32,34,17,51,36,38,19,57,42,40,44,46,23,69,45,48,50,52,54,56,49,63,60,55,65,70,58,29,87,66,62,31,93,72,64,68,74,37,111,75,78,76,80,82,41", "code": "\nfrom math import gcd\ndef aupton(terms):\n    alst, aset = [1, 10], {1, 10}\n    for n in range(2, terms+1):\n        k = 2\n        while True:\n            while k in aset: k += 1\n            if gcd(alst[-1], k) != 1: alst.append(k); aset.add(k); break\n            k += 1\n    return alst[1:]\nprint(aupton(73)) \n"}
{"sequence_id": "A169902", "text": "Earliest sequence such that xy | a(x+y) and (x+y) | a(xy) for all x >= 1, y >= 1.", "sequence": "2,3,4,60,12,2520,120,5040,2520,277200,2520,4324320,27720,5045040,10810800,49008960,720720,4190266080,12252240,4655851200,4888643760,117793035360,232792560,642507465600,26771144400,2088149263200", "code": "\nfrom math import gcd\nfor n in range(1,1001):\n..a_n = 1\n..res = []\n..for addend in range(1,n//2+1): res.append(addend*(n - addend))\n..for dividend in range(1,n+1):\n....if not n%dividend: res.append(dividend + n//dividend)\n....if dividend*dividend >= n: break\n..for i in res: a_n *= i // gcd(a_n,i)\n..print(n,a_n)\n\n"}
{"sequence_id": "A169936", "text": "Numbers whose name in English is an anagram of the name of another number.", "sequence": "67,69,76,79,96,97,102,103,104,105,106,107,108,109,112,122,123,124,125,126,127,128,129,132,133,134,135,136,137,138,139,142,143,144,145,146,147,148,149,152,153,154,155,156,157,158,159,162,163,164", "code": "\nfrom num2words import num2words\ndef alst(ALLBELOW=1000):\n  out, ana = set(), dict()\n  for i in range(ALLBELOW):\n    key = \"\".join(sorted(num2words(i)))\n    if key in ana: out.update([ana[key], i])\n    else: ana[key] = i\n  return sorted(out)\nprint(alst()) \n"}
{"sequence_id": "A169966", "text": "Numbers whose decimal expansion contains only 0's and 3's.", "sequence": "0,3,30,33,300,303,330,333,3000,3003,3030,3033,3300,3303,3330,3333,30000,30003,30030,30033,30300,30303,30330,30333,33000,33003,33030,33033,33300,33303,33330,33333,300000,300003,300030,300033,300300,300303,300330,300333", "code": "\ndef a(n): return 3*int(bin(n)[2:])\nprint([a(n) for n in range(40)]) \n"}
{"sequence_id": "A170732", "text": "Expansion of g.f.: (1+x)/(1 - 12*x).", "sequence": "1,13,156,1872,22464,269568,3234816,38817792,465813504,5589762048,67077144576,804925734912,9659108818944,115909305827328,1390911669927936,16690940039135232,200291280469622784,2403495365635473408,28841944387625680896,346103332651508170752", "code": " for i in range(1001):print(i,13*12**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170737", "text": "Expansion of g.f.: (1+x)/(1-17*x).", "sequence": "1,18,306,5202,88434,1503378,25557426,434476242,7386096114,125563633938,2134581776946,36287890208082,616894133537394,10487200270135698,178282404592306866,3030800878069216722,51523614927176684274,875901453762003632658,14890324713954061755186", "code": " for i in range(31):print(i,18*17**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170738", "text": "Expansion of g.f.: (1+x)/(1-18*x).", "sequence": "1,19,342,6156,110808,1994544,35901792,646232256,11632180608,209379250944,3768826516992,67838877305856,1221099791505408,21979796247097344,395636332447752192,7121453984059539456,128186171713071710208,2307351090835290783744,41532319635035234107392", "code": " for i in range(31):print(i,19*18**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170740", "text": "Expansion of g.f.: (1+x)/(1-20*x).", "sequence": "1,21,420,8400,168000,3360000,67200000,1344000000,26880000000,537600000000,10752000000000,215040000000000,4300800000000000,86016000000000000,1720320000000000000,34406400000000000000,688128000000000000000,13762560000000000000000,275251200000000000000000", "code": " for i in range(31):print(i,21*20**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170741", "text": "Expansion of g.f.: (1+x)/(1-21*x).", "sequence": "1,22,462,9702,203742,4278582,89850222,1886854662,39623947902,832102905942,17474161024782,366957381520422,7706105011928862,161828205250506102,3398392310260628142,71366238515473190982,1498691008824937010622,31472511185323677223062,660922734891797221684302", "code": " for i in range(31):print(i,22*21**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170742", "text": "Expansion of g.f.: (1+x)/(1-22*x).", "sequence": "1,23,506,11132,244904,5387888,118533536,2607737792,57370231424,1262145091328,27767192009216,610878224202752,13439320932460544,295665060514131968,6504631331310903296,143101889288839872512,3148241564354477195264,69261314415798498295808,1523748917147566962507776", "code": " for i in range(31):print(i,23*22**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170743", "text": "Expansion of g.f.: (1+x)/(1-23*x).", "sequence": "1,24,552,12696,292008,6716184,154472232,3552861336,81715810728,1879463646744,43227663875112,994236269127576,22867434189934248,525950986368487704,12096872686475217192,278228071788929995416,6399245651145389894568,147182649976343967575064", "code": " for i in range(1001):print(i,24*23**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170744", "text": "Expansion of g.f.: (1+x)/(1-24*x).", "sequence": "1,25,600,14400,345600,8294400,199065600,4777574400,114661785600,2751882854400,66045188505600,1585084524134400,38042028579225600,913008685901414400,21912208461633945600,525893003079214694400,12621432073901152665600,302914369773627663974400", "code": " for i in range(31):print(i,25*24**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170745", "text": "Expansion of g.f.: (1+x)/(1-25*x).", "sequence": "1,26,650,16250,406250,10156250,253906250,6347656250,158691406250,3967285156250,99182128906250,2479553222656250,61988830566406250,1549720764160156250,38743019104003906250,968575477600097656250,24214386940002441406250,605359673500061035156250", "code": " for i in range(31):print(i,26*25**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170746", "text": "Expansion of g.f.: (1+x)/(1-26*x).", "sequence": "1,27,702,18252,474552,12338352,320797152,8340725952,216858874752,5638330743552,146596599332352,3811511582641152,99099301148669952,2576581829865418752,66991127576500887552,1741769316989023076352,45286002241714599985152,1177436058284579599613952", "code": " for i in range(31):print(i,27*26**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170747", "text": "Expansion of g.f.: (1+x)/(1-27*x).", "sequence": "1,28,756,20412,551124,14880348,401769396,10847773692,292889889684,7908027021468,213516729579636,5764951698650172,155653695863554644,4202649788315975388,113471544284531335476,3063731695682346057852,82720755783423343562004,2233460406152430276174108", "code": " for i in range(31):print(i,28*27**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170748", "text": "Expansion of g.f.: (1+x)/(1-28*x).", "sequence": "1,29,812,22736,636608,17825024,499100672,13974818816,391294926848,10956257951744,306775222648832,8589706234167296,240511774556684288,6734329687587160064,188561231252440481792,5279714475068333490176,147832005301913337724928", "code": " for i in range(31):print(i,29*28**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170749", "text": "Expansion of g.f.: (1+x)/(1-29*x).", "sequence": "1,30,870,25230,731670,21218430,615334470,17844699630,517496289270,15007392388830,435214379276070,12621216999006030,366015292971174870,10614443496164071230,307818861388758065670,8926746980273983904430,258875662427945533228470", "code": " for i in range(31):print(i,30*29**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170750", "text": "Expansion of g.f.: (1+x)/(1-30*x).", "sequence": "1,31,930,27900,837000,25110000,753300000,22599000000,677970000000,20339100000000,610173000000000,18305190000000000,549155700000000000,16474671000000000000,494240130000000000000,14827203900000000000000,444816117000000000000000", "code": " for i in range(31):print(i,31*30**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170751", "text": "Expansion of g.f.: (1+x)/(1-31*x).", "sequence": "1,32,992,30752,953312,29552672,916132832,28400117792,880403651552,27292513198112,846067909141472,26228105183385632,813071260684954592,25205209081233592352,781361481518241362912,24222205927065482250272,750888383739029949758432", "code": " for i in range(1001):print(i,32*31**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170752", "text": "Expansion of g.f.: (1+x)/(1-32*x).", "sequence": "1,33,1056,33792,1081344,34603008,1107296256,35433480192,1133871366144,36283883716608,1161084278931456,37154696925806592,1188950301625810944,38046409652025950208,1217485108864830406656,38959523483674573012992,1246704751477586336415744", "code": " for i in range(1001):print(i,33*32**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170753", "text": "Expansion of g.f.: (1+x)/(1-33*x).", "sequence": "1,34,1122,37026,1221858,40321314,1330603362,43909910946,1449027061218,47817893020194,1577990469666402,52073685498991266,1718431621466711778,56708243508401488674,1871372035777249126242,61755277180649221165986,2037924146961424298477538", "code": " for i in range(1001):print(i,34*33**(i-1) if i>0 else 1) \n"}
{"sequence_id": "A170780", "text": "a(n) = n^8*(n^8 + 1)/2.", "sequence": "0,1,32896,21526641,2147516416,76294140625,1410555793536,16616468167201,140737496743936,926510115949281,5000000050000000,22974865038965521,92442129662509056,332708304999455281,1088976669642580096", "code": " for n in range(0,20): print(int(n**8*(n**8 + 1)/2), end=', ') \n"}
{"sequence_id": "A170790", "text": "a(n) = n^9*(n^8 + 1)/2.", "sequence": "0,1,65792,64579923,8590065664,381470703125,8463334761216,116315277170407,1125899973951488,8338591043543529,50000000500000000,252723515428620731,1109305555950108672,4325207964992918653", "code": " for n in range(0,20): print(int(n**9*(n**8 + 1)/2), end=', ') \n"}
{"sequence_id": "A170791", "text": "a(n) = n^9*(n^9 + 1)/2.", "sequence": "0,1,131328,193720086,34359869440,1907349609375,50779983373056,814206819132028,9007199321849856,75047317842209805,500000000500000000,2779958657925089586,13311666643022512128,56227703481280946251", "code": " for n in range(0,20): print(int(n**9*(n**9 + 1)/2), end=', ') \n"}
{"sequence_id": "A170802", "text": "a(n) = n^10*(n^10 + 1)/2.", "sequence": "0,1,524800,1743421725,549756338176,47683720703125,1828079250264576,39896133290043625,576460752840294400,6078832731271856601,50000000005000000000,336374997479248716901,1916879996254696243200", "code": " for n in range(0,20): print(int(n**10*(n**10 + 1)/2), end=', ') \n"}
{"sequence_id": "A170818", "text": "a(n) is the product of primes (with multiplicity) of form 4*k+1 that divide n.", "sequence": "1,1,1,1,5,1,1,1,1,5,1,1,13,1,5,1,17,1,1,5,1,1,1,1,25,13,1,1,29,5,1,1,1,17,5,1,37,1,13,5,41,1,1,1,5,1,1,1,1,25,17,13,53,1,5,1,1,29,1,5,61,1,1,1,65,1,1,17,1,5,1,1,73,37,25,1,1,13,1,5,1,41,1,1,85,1,29,1", "code": "\nfrom sympy import factorint, prod\ndef a072438(n):\n    f = factorint(n)\n    return 1 if n == 1 else prod(i**f[i] for i in f if i % 4 != 1)\ndef a(n): return n//a072438(n) \n"}
{"sequence_id": "A171000", "text": "Irreducible Boolean polynomials written as binary vectors.", "sequence": "1,10,11,101,1001,1011,1101,10001,10011,10111,11001,11101,100001,100011,100101,100111,101001,101011,110001,110101,111001,1000001,1000011,1000101,1000111,1001011,1001101,1001111,1010001,1010011,1010111,1011001,1011101,1100001", "code": "\ndef addn(m1, m2):\n    s1, s2 = \"{0:b}\".format(m1), \"{0:b}\".format(m2)\n    len_max = max(len(s1), len(s2))\n    return int(''.join(max(i, j) for i, j in zip(s1.rjust(len_max, '0'), s2.rjust(len_max, '0'))))\ndef muln(m1, m2):\n    s1, s2, prod =  \"{0:b}\".format(m1), \"{0:b}\".format(m2), '0'\n    for i in range(len(s2)):\n        k = s2[-i-1]\n        prod = addn(int(str(prod), 2), int(''.join(min(j, k) for j in s1), 2)*2**i)\n    return prod\nL_p10, m = [1], 2\nwhile m < 100:\n    ct = 0\n    for i in range(1, len(L_p10)):\n        p = L_p10[i]\n        for j in range(2, m):\n            jp = int(str(muln(j, p)), 2)\n            if jp > m: break\n            if jp == m: ct += 1; break\n        if ct > 0: break\n    if ct == 0: L_p10.append(m)\n    m += 1\nL_p2 = []\nfor d in L_p10: L_p2.append(\"{0:b}\".format(d))\nprint(*L_p2, sep =', ') \n"}
{"sequence_id": "A171113", "text": "a(n) is the Severi degree for curves of degree n and cogenus 3.", "sequence": "0,0,15,675,7915,41310,145383,404185,959115,2029980,3939295,7139823,12245355,20064730,31639095,48282405,71625163,103661400,146798895,203912635,278401515,374248278,496082695,649247985,839870475,1074932500,1362348543,1711044615", "code": "\n[0, 0] + [(9*d**6 + 9*d**4 + 423*d**3 - 829*d)//2 - 27*d**5 - 229*d**2 + 525 for d in range(3, 30)] \n"}
{"sequence_id": "A171163", "text": "Number of children at height n in a doubly logarithmic tree. Leaves are at height 0.", "sequence": "0,2,2,4,16,256,65536,4294967296,18446744073709551616,340282366920938463463374607431768211456,115792089237316195423570985008687907853269984665640564039457584007913129639936", "code": "\ndef doubly_log_tree_children(n):\n    if n==0:\n        return 0\n    if n==1:\n        return 2\n    return 2**(2**(n-2))\n"}
{"sequence_id": "A171462", "text": "Number of hands a bartender needs to have in order to win at the blind bartender's problem with n glasses in a cycle.", "sequence": "0,1,2,2,4,4,6,4,6,8,10,8,12,12,12,8,16,12,18,16,18,20,22,16,20,24,18,24,28,24,30,16,30,32,30,24,36,36,36,32,40,36,42,40,36,44,46,32,42,40,48,48,52,36,50,48,54,56,58,48,60,60,54,32,60,60,66,64,66,60,70,48,72", "code": "\nfrom sympy import primefactors\ndef a(n): return 0 if n == 1 else n - n//(primefactors(n)[-1])\nprint([a(n) for n in range(1, 74)]) \n"}
{"sequence_id": "A171503", "text": "Number of 2 X 2 integer matrices with entries from {0,1,...,n} having determinant 1.", "sequence": "0,3,7,15,23,39,47,71,87,111,127,167,183,231,255,287,319,383,407,479,511,559,599,687,719,799,847,919,967,1079,1111,1231,1295,1375,1439,1535,1583,1727,1799,1895,1959,2119,2167,2335,2415,2511,2599", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A171503(n): \n    if n == 0:\n        return 0\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(A171503(k1)-1)//2\n        j, k1 = j2, n//j2\n    return 2*(n*(n-1)-c+j) - 1 \n"}
{"sequence_id": "A171641", "text": "Non-deficient numbers with even sigma which are not Zumkeller.", "sequence": "738,748,774,846,954,1062,1098,1206,1278,1314,1422,1494,1602,1746,1818,1854,1926,1962,2034,2286,2358,2466,2502,2682,2718,2826,2934,3006,3114,3222,3258,3438,3474,3492,3546,3582,3636,3708,3798,3852,3924", "code": "\nfrom sympy import divisors\nimport numpy as np\nA171641 = []\nfor n in range(2,10**6):\n....d = divisors(n)\n....s = sum(d)\n....if not s % 2 and 2*n <= s:\n........d.remove(n)\n........s2, ld = int(s/2-n), len(d)\n........z = np.zeros((ld+1,s2+1),dtype=int)\n........for i in range(1,ld+1):\n............y = min(d[i-1],s2+1)\n............z[i,range(y)] = z[i-1,range(y)]\n............z[i,range(y,s2+1)] = np.maximum(z[i-1,range(y,s2+1)],z[i-1,range(0,s2+1-y)]+y)\n........if z[ld,s2] != s2:\n............A171641.append(n)\n\n"}
{"sequence_id": "A171642", "text": "Non-deficient numbers with odd sigma such that the sum of the even divisors is twice the sum of the odd divisors.", "sequence": "18,162,450,882,1458,2178,2450,3042,4050,5202,6050,6498,7938,8450,9522,11250,13122,15138,17298,19602,22050,24642,27378,30258,33282,36450,39762,43218,46818,50562,54450,58482,61250,62658,66978,71442,76050,80802,85698", "code": "\nfrom sympy import divisors\nA171642 = []\nfor n in range(1,10**5):\n....d = divisors(n)\n....s = sum(d)\n....if s % 2 and 2*n <= s and s == 3*sum([x for x in d if x % 2]):\n........A171642.append(n)\n\n"}
{"sequence_id": "A171757", "text": "Even numbers whose binary expansion begins 10.", "sequence": "2,4,8,10,16,18,20,22,32,34,36,38,40,42,44,46,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178", "code": "\nfrom itertools import count, product, takewhile\ndef agen(): \n    yield 2\n    for digits in count(0):\n        for mid in product(\"01\", repeat=digits):\n            yield int(\"10\" + \"\".join(mid) + \"0\", 2)\ndef aupto(lim): return list(takewhile(lambda x: x <= lim, agen()))\nprint(aupto(180)) \n"}
{"sequence_id": "A171797", "text": "A modified Sisyphus function: a(n) = concatenation of (number of digits in n) (number of even digits) (number of odd digits).", "sequence": "110,101,110,101,110,101,110,101,110,101,211,202,211,202,211,202,211,202,211,202,220,211,220,211,220,211,220,211,220,211,211,202,211,202,211,202,211,202,211,202,220,211,220,211,220,211,220,211,220,211,211,202", "code": "\ndef a(n):\n    s = str(n); e = sum(d in \"02468\" for d in s)\n    return int(\"\".join(map(str, (len(s), e, len(s)-e))))\nprint([a(n) for n in range(52)]) \n"}
{"sequence_id": "A171865", "text": "Positions of 0's in A181391.", "sequence": "1,2,4,6,11,13,18,21,25,31,36,42,45,48,53,57,60,64,67,73,82,85,90,93,99,102,106,111,117,122,126,130,135,139,143,149,153,157,163,169,174,180,184,188,197,200,203,209,213,216,226,229,233,237,243,247,252,255,258,264,270", "code": "\nA181391_list, A171865_list = [0, 0], [1,2]\nfor n in range(1, 10**4):\n....for m in range(n-1, -1, -1):\n........if A181391_list[m] == A181391_list[n]:\n............A181391_list.append(n-m)\n............break\n....else:\n........A181391_list.append(0)\n........A171865_list.append(n+2) \n"}
{"sequence_id": "A171868", "text": "First differences of A171865.", "sequence": "1,2,2,5,2,5,3,4,6,5,6,3,3,5,4,3,4,3,6,9,3,5,3,6,3,4,5,6,5,4,4,5,4,4,6,4,4,6,6,5,6,4,4,9,3,3,6,4,3,10,3,4,4,6,4,5,3,3,6,6,7,3,5,4,5,4,6,6,6,5,4,6,4,4,6,4,5,4,7,3,4,5,4,8,10,3,5,5,6,3,8,4,4,6,7,6,6,10,4,4,8,3,4,4", "code": "\nA181391_list, A171868_list, l = [0, 0], [1], 0\nfor n in range(1, 10**4):\n....for m in range(n-1, -1, -1):\n........if A181391_list[m] == A181391_list[n]:\n............A181391_list.append(n-m)\n............break\n....else:\n........A181391_list.append(0)\n........A171868_list.append(n-l)\n........l = n \n"}
{"sequence_id": "A171887", "text": "Records in A171868 (positions).", "sequence": "1,2,4,9,20,50,147,269,992,1000,4297,76468,97314,445519,1315337,2594742,3888902,91859035,92411466,1180624310,4501485474,11288114818,23434425843", "code": "\nA181391_list, A171887_list, l, r, k = [0, 0], [1], 0, 1, 1\nfor n in range(1, 10**6):\n....for m in range(n-1, -1, -1):\n........if A181391_list[m] == A181391_list[n]:\n............A181391_list.append(n-m)\n............break\n....else:\n........A181391_list.append(0)\n........k += 1\n........if n-l > r:\n............r = n-l\n............A171887_list.append(k)\n........l = n \n"}
{"sequence_id": "A171888", "text": "Records in A171868 (values).", "sequence": "1,2,5,6,9,10,11,13,15,16,18,19,21,22,23,24,27,28,29,30,31,33,34", "code": "\nA181391_list, A171888_list, l, r = [0, 0], [1], 0, 1\nfor n in range(1, 10**6):\n....for m in range(n-1, -1, -1):\n........if A181391_list[m] == A181391_list[n]:\n............A181391_list.append(n-m)\n............break\n....else:\n........A181391_list.append(0)\n........if n-l > r:\n............r = n-l\n............A171888_list.append(r)\n........l = n \n"}
{"sequence_id": "A171901", "text": "Numbers with at least two identical neighboring digits in their decimal representation.", "sequence": "11,22,33,44,55,66,77,88,99,100,110,111,112,113,114,115,116,117,118,119,122,133,144,155,166,177,188,199,200,211,220,221,222,223,224,225,226,227,228,229,233,244,255,266,277,288,299,300,311,322,330,331,332,333", "code": "\ndef is_ok(n):\n    s = str(n)\n    return any(s[i] == s[i - 1] for i in range(1, len(s)))\nA171901_list = [n for n in range(400) if is_ok(n)] \n"}
{"sequence_id": "A171911", "text": "Van Eck's sequence (cf. A181391), but starting with a(1) = 1.", "sequence": "1,0,0,1,3,0,3,2,0,3,3,1,8,0,5,0,2,9,0,3,9,3,2,6,0,6,2,4,0,4,2,4,2,2,1,23,0,8,25,0,3,19,0,3,3,1,11,0,5,34,0,3,7,0,3,3,1,11,11,1,3,5,13,0,10,0,2,33,0,3,9,50,0,4,42,0,3,7,25,40,0,5,20,0,3,8,48,0,4,15", "code": "\nA171911_list, l = [1, 0], 0\nfor n in range(1, 10**4):\n    for m in range(n-1, -1, -1):\n        if A171911_list[m] == l:\n            l = n-m\n            break\n    else:   \n        l = 0\n    A171911_list.append(l) \n"}
{"sequence_id": "A171915", "text": "Van Eck sequence (cf. A181391) starting with a(1) = 5.", "sequence": "5,0,0,1,0,2,0,2,2,1,6,0,5,12,0,3,0,2,9,0,3,5,9,4,0,5,4,3,7,0,5,5,1,23,0,5,4,10,0,4,3,13,0,4,4,1,13,5,12,35,0,8,0,2,36,0,3,16,0,3,3,1,16,5,16,2,12,18,0,10,32,0,3,12,7,46,0,5,14,0,3,8,30,0,4,40,0,3,7", "code": "\nA171915_list, l = [5, 0], 0\nfor n in range(1, 10**4):\n    for m in range(n-1, -1, -1):\n        if A171915_list[m] == l:\n            l = n-m\n            break\n    else:\n        l = 0\n    A171915_list.append(l) \n"}
{"sequence_id": "A172164", "text": "Differences between numbers of triangles entirely contained in two consecutive turns of Pythagoras's snail (Theodorus spiral).", "sequence": "20,19,20,19,20,21,18,21,19,20,20,20,19,20,20,19,20,20,20,19,21,18,21,19,21,18,21,19,21,18,21,19,20,20,20,19,20,20,19,20,20,20,19,20,20,20,19,21,18,21,19,20,20,20,19,20,20,20,19,20,20,19,20,20,20,19,21,18,21", "code": " \n"}
{"sequence_id": "A172404", "text": "Numbers k such that 3 is the first digit of 2^k.", "sequence": "5,15,25,35,45,55,65,75,78,85,88,95,98,108,118,128,138,148,158,168,178,181,188,191,201,211,221,231,241,251,261,271,274,281,284,291,294,304,314,324,334,344,354,364,367,374,377,384,387,397,407,417,427,437,447,457,467,470,477,480,487,490,500", "code": "\nans, x = [], 1.\nfor n in range(501):\n    if 3 < x < 4: ans.append(n)\n    x = x*2\n    if x > 10: x = x / 10\nprint(ans)\n"}
{"sequence_id": "A172443", "text": "Numbers with exactly 64 divisors.", "sequence": "7560,9240,10920,11880,13440,14040,14280,15960,16632,17160,17280,18360,19320,19656,20520,20790,21000,21120,22440,24024,24192,24360,24570,24840,24960,25080,25704,26040,26520,27000,28728,29568,29640,30030,30360,30888,31080", "code": "\nfrom sympy import divisor_count\ndef ok(n): return divisor_count(n) == 64\nprint(list(filter(ok, range(31100)))) \n"}
{"sequence_id": "A173071", "text": "Palindromic mountain primes.", "sequence": "131,151,181,191,12421,12721,12821,13831,13931,14741,17971,1235321,1245421,1257521,1268621,1278721,1456541,1469641,1489841,1579751,1589851,123484321,123494321,123575321,136797631,167898761,12345854321", "code": "\nfrom itertools import combinations\nfrom gmpy2 import is_prime\nA173071_list = []\nfor l in range(1,10):\n    for i in combinations('23456789',l):\n        s = '1'+''.join(i)\n        p = int(s+s[l-1::-1])\n        if is_prime(p):\n            A173071_list.append(p) \n"}
{"sequence_id": "A173102", "text": "Number of partitions x + y = z with {x,y,z} in {1,2,3,..,3n} and z > y >= x.", "sequence": "2,9,20,36,56,81,110,144,182,225,272,324,380,441,506,576,650,729,812,900,992,1089,1190,1296,1406,1521,1640,1764,1892,2025,2162,2304,2450,2601,2756,2916,3080,3249,3422,3600,3782,3969,4160,4356,4556,4761,4970", "code": "\ndef A173102(n):\n    return (9*n**2 - (n % 2))//4 \n"}
{"sequence_id": "A173200", "text": "Solutions y of the Mordell equation y^2 = x^3 - 3a^2 - 1 for a = 0,1,2, ... (solutions x are given by A053755).", "sequence": "0,11,70,225,524,1015,1746,2765,4120,5859,8030,10681,13860,17615,21994,27045,32816,39355,46710,54929,64060,74151,85250,97405,110664,125075,140686,157545,175700,195199,216090,238421,262240,287595,314534,343105", "code": " for n in range(1,20): print(8*n**3 - 24*n**2 + 27*n - 11, end=', ') \n"}
{"sequence_id": "A173207", "text": "Cubefree Fibonacci numbers which are not squarefree.", "sequence": "75025,12586269025,225851433717,2111485077978050,4660046610375530309,354224848179261915075,43566776258854844738105,114059301025943970552219,42230279526998466217810220532898,1672445759041379840132227567949787325", "code": "\nfrom sympy import factorint\nA173207_list = []\na, b = 1, 2\nfor _ in range(10**2):\n....if max(factorint(b).values()) == 2:\n........A173207_list.append(b)\n....a, b = b, a + b \n"}
{"sequence_id": "A173208", "text": "Squarefree Fibonacci numbers F such that F+1 and F-1 are also squarefree.", "sequence": "2,34,610,10946,196418,3524578,63245986,1134903170,6557470319842,117669030460994,37889062373143906,679891637638612258,12200160415121876738,3928413764606871165730,1264937032042997393488322", "code": "\nfrom sympy import factorint\nA173208_list = [2]\na, b = 2, 3\nfor _ in range(10**2):\n....if max(factorint(b).values()) <= 1 and max(factorint(b-1).values()) <= 1 and max(factorint(b+1).values()) <= 1:\n........A173208_list.append(b)\n....a, b = b, a + b \n"}
{"sequence_id": "A173228", "text": "The number of trailing zeros in (10^n)!", "sequence": "2,24,249,2499,24999,249998,2499999,24999999,249999998,2499999997,24999999997,249999999997,2499999999997,24999999999998,249999999999997,2499999999999996,24999999999999995,249999999999999995,2499999999999999995,24999999999999999996", "code": "\nfrom math import log, ceil\ndef a(n):\n  return sum(10**n // 5**k for k in range(1, ceil(log(10, 5) * n)))\n\n"}
{"sequence_id": "A173499", "text": "Number of sequences of length n with terms from {0,1,...,n-1} such that the sum of terms is 0 modulo n and the i-th term is not i.", "sequence": "0,0,2,20,204,2604,39990,720600,14913080,348678440,9090909090,261535698060,8230246567620,281241170407092,10371206370520814,410525522232055664,17361641481138401520,781282469559318055056", "code": "\nfor n in range(1, 33):\n    print((n-1)**n // n, end=',')\n\n"}
{"sequence_id": "A173639", "text": "Numbers n such that the sum of the digits of 11*n is odd.", "sequence": "19,28,29,37,38,39,46,47,48,49,55,56,57,58,59,64,65,66,67,68,69,73,74,75,76,77,78,79,82,83,84,85,86,87,88,89,119,128,129,137,138,139,146,147,148,149", "code": "\nans = []\nfor n in range(1,151):\n    N,s = 11*n,0\n    while N:\n        s += N % 10\n        N //= 10\n    if s % 2:\n        ans.append(n)\nprint(ans)\n"}
{"sequence_id": "A174322", "text": "a(n) is the smallest n-digit number with exactly 4 divisors.", "sequence": "6,10,106,1003,10001,100001,1000001,10000001,100000001,1000000006,10000000003,100000000007,1000000000007,10000000000015,100000000000013,1000000000000003,10000000000000003,100000000000000015,1000000000000000007,10000000000000000001", "code": "\nfrom sympy import divisors\ndef a(n):\n    k = 10**(n-1)\n    while len(divisors(k)) != 4: k += 1\n    return k\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A174322", "text": "a(n) is the smallest n-digit number with exactly 4 divisors.", "sequence": "6,10,106,1003,10001,100001,1000001,10000001,100000001,1000000006,10000000003,100000000007,1000000000007,10000000000015,100000000000013,1000000000000003,10000000000000003,100000000000000015,1000000000000000007,10000000000000000001", "code": " \nfrom sympy import divisors\ndef a(n):\n    k = 10**(n-1) - 1\n    divs = -1\n    while divs != 4:\n      k += 1\n      divs = 0\n      for d in divisors(k, generator=True):\n        divs += 1\n        if divs > 4: break\n    return k\nprint([a(n) for n in range(1, 22)]) \n"}
{"sequence_id": "A174341", "text": "a(n) = numerator(Bernoulli(n, 1) + 1/(n+1)).", "sequence": "2,1,1,1,1,1,1,1,7,1,1,1,-37,1,37,1,-211,1,2311,1,-407389,1,37153,1,-1181819909,1,76977929,1,-818946931,1,277930363757,1,-84802531453217,1,90219075042851,1,-711223555487930419,1,12696640293313423,1,-6367871182840222481,1,35351107998094669831,1,-83499808737903072705023,1,12690449182849194963361,1", "code": "\nfrom sympy import bernoulli, Integer\ndef B(n): return bernoulli(n) if n != 1 else -bernoulli(n)\ndef a(n): return (B(n) + 1/Integer(n + 1)).numerator() \n"}
{"sequence_id": "A174342", "text": "Denominator of ( A164555(n)/A027642(n) +  1/(n+1) ).", "sequence": "1,1,2,4,6,6,6,8,90,10,6,12,210,14,30,16,30,18,42,20,770,22,6,24,13650,26,54,28,30,30,462,32,5610,34,210,36,51870,38,26,40,330,42,42,44,2070,46,6,48,324870,50,1122,52,30,54,43890,56,5510,58,6,60,930930", "code": "\nfrom sympy import bernoulli, Rational\ndef B(n):\n    return bernoulli(n) if n != 1 else -bernoulli(n)\ndef a(n):\n    return (B(n) + Rational(1, n + 1)).as_numer_denom()[1]\n[a(n) for n in range(61)] \n"}
{"sequence_id": "A174574", "text": "Partial sums of A065363.", "sequence": "0,1,1,2,4,3,3,4,4,5,7,8,10,13,11,10,10,9,9,10,10,11,13,12,12,13,13,14,16,17,19,22,22,23,25,26,28,31,33,36,40,37,35,34,32,31,31,30,30,31,29,28,28,27,27,28,28,29,31,30,30,31,31,32,34,35,37,40,38,37,37,36,36,37", "code": "\ndef a065363(n):\n    s=0\n    x=0\n    while n>0:\n        x=n%3\n        n//=3\n        if x==2:\n            x=-1\n            n+=1\n        s+=x\n    return s\nl=[0]\nfor n in range(1, 101): l.append(l[n - 1] + a065363(n))\nprint(l) \n"}
{"sequence_id": "A174579", "text": "Number of spanning trees in the n-triangular grid graph.", "sequence": "1,3,54,5292,2723220,7242690816,98719805835000,6861326937782575104,2423821818614367091537296,4342290918217084382837760000000,39389085041906366256386454778172877408,1807026244113880332171608161401397806958116864", "code": "\n\nfrom graphillion import GraphSet\ndef make_n_triangular_grid_graph(n):\n    s = 1\n    grids = []\n    for i in range(n + 1, 1, -1):\n        for j in range(i - 1):\n            a, b, c = s + j, s + j + 1, s + i + j\n            grids.extend([(a, b), (a, c), (b, c)])\n        s += i\n    return grids\ndef A174579(n):\n    if n == 0: return 1\n    universe = make_n_triangular_grid_graph(n)\n    GraphSet.set_universe(universe)\n    spanning_trees = GraphSet.trees(is_spanning=True)\n    return spanning_trees.len()\nprint([A174579(n) for n in range(8)])  \n"}
{"sequence_id": "A174657", "text": "Balanced ternary numbers with more negative trits than positive trits.", "sequence": "5,14,15,17,23,41,42,43,44,45,47,50,51,53,59,68,69,71,77,95,122,123,124,125,126,127,128,129,131,132,133,134,135,137,140,141,143,149,150,151,152,153,155,158,159,161,167,176,177,179,185,203,204,205,206,207,209", "code": "\ndef a(n):\n    s=0\n    x=0\n    while n>0:\n        x=n%3\n        n//=3\n        if x==2:\n            x=-1\n            n+=1\n        s+=x\n    return s\nprint([n for n in range(301) if a(n)<0]) \n"}
{"sequence_id": "A174658", "text": "Balanced ternary numbers with equal count of negative trits and positive trits.", "sequence": "0,2,6,8,16,18,20,24,26,32,46,48,52,54,56,60,62,70,72,74,78,80,86,96,98,104,130,136,138,142,144,146,154,156,160,162,164,168,170,178,180,182,186,188,194,208,210,214,216,218,222,224,232,234,236,240,242,248,258", "code": "\ndef a(n):\n    s=0\n    x=0\n    while n>0:\n        x=n%3\n        n //= 3\n        if x==2:\n            x=-1\n            n+=1\n        s+=x\n    return s\nprint([n for n in range(301) if a(n)==0]) \n"}
{"sequence_id": "A174659", "text": "Balanced ternary numbers with more positive trits than negative trits.", "sequence": "1,3,4,7,9,10,11,12,13,19,21,22,25,27,28,29,30,31,33,34,35,36,37,38,39,40,49,55,57,58,61,63,64,65,66,67,73,75,76,79,81,82,83,84,85,87,88,89,90,91,92,93,94,97,99,100,101,102,103,105,106,107,108,109,110,111,112", "code": "\ndef a(n):\n    s=0\n    x=0\n    while n>0:\n        x=n%3\n        n//=3\n        if x==2:\n            x=-1\n            n+=1\n        s+=x\n    return s\nprint([n for n in range(301) if a(n)>0]) \n"}
{"sequence_id": "A174863", "text": "Little omega analog to Liouville's function L(n).", "sequence": "1,0,-1,-2,-3,-2,-3,-4,-5,-4,-5,-4,-5,-4,-3,-4,-5,-4,-5,-4,-3,-2,-3,-2,-3,-2,-3,-2,-3,-4,-5,-6,-5,-4,-3,-2,-3,-2,-1,0,-1,-2,-3,-2,-1,0,-1,0,-1,0,1,2,1,2,3,4,5,6,5,4,3,4,5,4,5,4,3,4,5,4,3,4,3,4,5,6,7", "code": "\nfrom sympy import primefactors\ndef omega(n): return 0 if n==1 else len(primefactors(n))\ndef a(n): return sum([(-1)**omega(i) for i in range(1, n + 1)]) \n"}
{"sequence_id": "A174967", "text": "Smallest number of the form k^2 + k + 1 with n distinct prime divisors.", "sequence": "1,3,21,273,10101,316407,6914271,2424626841,346084535811,6177672967557,1741866776384007,92264158181274807,103008522046409631057,22810816825458528984663,2220066397007943013450011,545889722100356705628041121,73293936170018923619553695493", "code": "\nfrom sympy import primefactors\ndef a(n):\n  k = 1\n  while len(primefactors(k**2 + k + 1)) != n: k += 1\n  return k**2 + k + 1\nprint([a(n) for n in range(1, 8)]) \n"}
{"sequence_id": "A174973", "text": "Numbers whose divisors increase by a factor of 2 or less.", "sequence": "1,2,4,6,8,12,16,18,20,24,28,30,32,36,40,42,48,54,56,60,64,66,72,80,84,88,90,96,100,104,108,112,120,126,128,132,140,144,150,156,160,162,168,176,180,192,196,198,200,204,208,210,216,220,224,228,234,240,252,256", "code": "\nfrom sympy import divisors\ndef ok(n):\n    d = divisors(n)\n    return all(d[i]/d[i-1] <= 2 for i in range(1, len(d)))\nprint(list(filter(ok, range(1, 257)))) \n"}
{"sequence_id": "A175017", "text": "Primes p containing the string \"13\" and sum of digits sod(p) = 13.", "sequence": "139,1327,1381,2137,2713,3613,4513,5413,6133,7213,9013,11317,11353,12613,13009,13063,13171,13441,13513,13711,15313,18013,21613,24133,26113,31333,31513,32413,34213,36013,41341,41413,44131,45013,51133,53113,54013", "code": "\nfrom sympy import nextprime\nA175017_list, p = [],2\nwhile len(A175017_list) <= 100:\n    s = str(p)\n    if '13' in s and sum(int(d) for d in s) == 13:\n        A175017_list.append(p)\n    p = nextprime(p) \n"}
{"sequence_id": "A175046", "text": "Write n in binary, then increase each run of 0's by one 0, and increase each run of 1's by one 1. a(n) is the decimal equivalent of the result.", "sequence": "3,12,7,24,51,28,15,48,99,204,103,56,115,60,31,96,195,396,199,408,819,412,207,112,227,460,231,120,243,124,63,192,387,780,391,792,1587,796,399,816,1635,3276,1639,824,1651,828,415,224,451,908,455,920,1843,924", "code": "\nfrom re import split\ndef A175046(n):\n    return int(''.join(d+'1' if '1' in d else d+'0' for d in split('(0+)|(1+)',bin(n)[2:]) if d != '' and d != None),2) \n"}
{"sequence_id": "A175047", "text": "Write n in binary, then increase each run of 0's by one 0. a(n) is the decimal equivalent of the result.", "sequence": "1,4,3,8,9,12,7,16,17,36,19,24,25,28,15,32,33,68,35,72,73,76,39,48,49,100,51,56,57,60,31,64,65,132,67,136,137,140,71,144,145,292,147,152,153,156,79,96,97,196,99,200,201,204,103,112,113,228,115,120,121,124,63,128", "code": "\nfrom re import split\ndef A175047(n):\n  return int(''.join(d+'0' if '0' in d else d for d in split('(0+)|(1+)',bin(n)[2:]) if d != '' and d != None),2) \n"}
{"sequence_id": "A175061", "text": "A positive integer n is included if n, when written in binary, is made of run-lengths (lengths of runs of 0's as well as of runs of 1's) that form a permutation of some number of consecutive positive integers starting with 1.", "sequence": "1,4,6,35,39,49,55,57,59,536,540,560,572,624,632,776,782,784,798,880,888,900,902,912,926,944,956,964,966,968,974,984,988,16775,16783,16835,16847,16867,16871,17159,17183,17283,17311,17379,17383,17935,17951", "code": "\nfrom itertools import groupby\ndef ok(n):\n  runlengths = [len(list(g)) for k, g in groupby(bin(n)[2:])]\n  return sorted(runlengths) == list(range(1, len(runlengths)+1))\nprint([n for n in range(1, 17952) if ok(n)]) \n"}
{"sequence_id": "A175061", "text": "A positive integer n is included if n, when written in binary, is made of run-lengths (lengths of runs of 0's as well as of runs of 1's) that form a permutation of some number of consecutive positive integers starting with 1.", "sequence": "1,4,6,35,39,49,55,57,59,536,540,560,572,624,632,776,782,784,798,880,888,900,902,912,926,944,956,964,966,968,974,984,988,16775,16783,16835,16847,16867,16871,17159,17183,17283,17311,17379,17383,17935,17951", "code": " \nfrom itertools import permutations\ndef runlength(r): \n  c = ['1', '0']\n  return sorted([int(\"\".join([c[j%2]*p[j] for j in range(r)]), 2)\n    for p in permutations(range(1, r+1))])\ndef aupto(nn):\n  r, out = 1, []\n  while len(out) < nn:\n    out += runlength(r)\n    r += 1\n  return out[:nn]\nprint(aupto(47)) \n"}
{"sequence_id": "A175345", "text": "Numbers m such that A006218(m) is a perfect square.", "sequence": "1,7,101,312,351,448,479,726,781,897,1040,1580,1605,2159,2339,2783,3298,3739,4485,4608,4650,4735,4776,4902,5473,6746,6894,6994,8353,8961,10117,10658,11714,12226,13758,14309,14729,15512,18446,18682", "code": "\nfrom sympy import integer_nthroot, divisor_count\nA175345_list, k, c, = [], 1, 1\nwhile k < 10**4:\n    if integer_nthroot(c,2)[1]: A175345_list.append(k)\n    k += 1\n    c += divisor_count(k) \n"}
{"sequence_id": "A175356", "text": "Those positive integers n where, when written in binary, there are exactly k number of runs (of either 0's or 1's) each of exactly k length, for all k where 1<=k<=m, for some positive integer m.", "sequence": "1,19,25,27,8984,8988,9016,9100,9112,9116,9784,10008,10012,10040,12568,12572,12600,12680,12686,12728,12740,12742,12744,12750,12760,12764,12856,13192,13198,13240,13880,14104,14108,14136,14476,14488,14492,14532,14534,14536", "code": "\nfrom itertools import groupby\ndef ok(n):\n  runlens = [len(list(g)) for k, g in groupby(bin(n)[2:])]\n  return all(runlens.count(k) == k for k in range(1, max(runlens)+1))\ndef aupto(limit): return [m for m in range(1, limit+1) if ok(m)]\nprint(aupto(14536)) \n"}
{"sequence_id": "A175452", "text": "a(n) = smallest prime such that a(n)+2 is multiple of 2n+1.", "sequence": "7,3,5,7,31,11,13,83,17,19,67,23,79,317,29,31,103,109,37,367,41,43,139,47,151,157,53,283,293,59,61,193,199,67,211,71,73,229,709,79,911,83,433,443,89,277,283,677,97,503,101,103,2459,107,109,337,113,349,593,1087", "code": "\nfrom sympy import nextprime\ndef a(n):\n    p, m = 2, 2*n+1\n    while (p+2)%m: p = nextprime(p)\n    return p\nprint([a(n) for n in range(1, 61)]) \n"}
{"sequence_id": "A175495", "text": "Positive integers k such that k < 2^d(k), where d(k) is the number of divisors of k.", "sequence": "1,2,3,4,6,8,10,12,14,15,16,18,20,24,28,30,32,36,40,42,44,45,48,50,52,54,56,60,63,64,66,70,72,78,80,84,88,90,96,100,102,104,105,108,110,112,114,120,126,128,130,132,135,136,138,140,144,150,152,154,156", "code": "\nfrom sympy import divisor_count\ndef ok(n): return n < 2**divisor_count(n)\nprint(list(filter(ok, range(1, 157)))) \n"}
{"sequence_id": "A175498", "text": "a(1)=1. a(n) = the smallest positive integer not occurring earlier such that a(n)-a(n-1) doesn't equal a(k)-a(k-1) for any k with 2 <= k <= n-1.", "sequence": "1,2,4,3,6,10,5,11,7,12,9,16,8,17,15,23,13,24,18,28,14,26,19,32,20,34,21,36,25,41,22,39,30,48,27,46,29,49,31,52,37,59,33,56,40,64,35,60,38,65,42,68,43,71,44,73,45,75,51,82,47,79,112,50,84,53,88,54,90,57,94,55,93,61,100,58,98,62,103,63,105,67", "code": "\nA175498_list, l, s, b1, b2 = [1,2], 2, 3, set(), set([1])\nfor n in range(3, 10**5):\n....i = s\n....while True:\n........if not (i in b1 or i-l in b2):\n............A175498_list.append(i)\n............b1.add(i)\n............b2.add(i-l)\n............l = i\n............while s in b1:\n................b1.remove(s)\n................s += 1\n............break\n........i += 1 \n"}
{"sequence_id": "A175499", "text": "a(n) = A175498(n+1)-A175498(n).", "sequence": "1,2,-1,3,4,-5,6,-4,5,-3,7,-8,9,-2,8,-10,11,-6,10,-14,12,-7,13,-12,14,-13,15,-11,16,-19,17,-9,18,-21,19,-17,20,-18,21,-15,22,-26,23,-16,24,-29,25,-22,27,-23,26,-25,28,-27,29,-28,30,-24,31,-35,32,33,-62,34,-31,35,-34,36,-33,37,-39,38,-32,39,-42,40,-36", "code": "\nA175499_list, l, s, b = [1], 2, 3, set()\nfor n in range(2, 10**2):\n....i, j = s, s-l\n....while True:\n........if not (i in b or j in A175499_list):\n............A175499_list.append(j)\n............b.add(i)\n............l = i\n............while s in b:\n................b.remove(s)\n................s += 1\n............break\n........i += 1\n........j += 1 \n"}
{"sequence_id": "A175522", "text": "A000120-perfect numbers.", "sequence": "2,25,95,111,119,123,125,169,187,219,221,247,289,335,365,411,415,445,485,493,505,629,655,685,695,697,731,767,815,841,871,943,949,965,985,1003,1139,1207,1241,1261,1263,1273,1343,1387,1465,1469,1507,1513,1529,1563", "code": "\nfrom sympy import divisors\ndef A000120(n): return bin(n).count('1')\ndef aupto(limit):\n  alst = []\n  for m in range(1, limit+1):\n    if A000120(m) == sum(A000120(d) for d in divisors(m)[:-1]): alst += [m]\n  return alst\nprint(aupto(1563)) \n"}
{"sequence_id": "A175549", "text": "Number of triples (a, b, c) with gcd(a, b, c) = 1 and -n <= a,b,c <= n.", "sequence": "0,26,98,290,578,1154,1730,2882,4034,5762,7490,10370,12674,16706,20162,24770,29378,36290,41474,50114,57026,66242,74882,87554,96770,111170,123266,138818,152642,172802,186626,209666,228098,251138,271874,299522", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A175549(n):\n    if n == 0:\n        return 0\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A175549(k1)\n        j, k1 = j2, n//j2\n    return 4*n*(n - 1)*(2*n + 5)-c+26*(j-1)\n"}
{"sequence_id": "A175582", "text": "a(n) = sigma(n-th Zumkeller number)/2.", "sequence": "6,14,21,30,28,36,45,48,62,60,60,84,72,72,84,93,112,90,117,126,108,105,140,124,120,180,156,168,144,168,186,196,189,240,180,186,273,192,254,234,252,217,288,300,252,228,252,280,273,372,252,364,264,294,360,360,279", "code": "\nfrom sympy import divisors\nimport numpy as np\nA175582 = []\nfor n in range(1,10**5):\n....d = divisors(n)\n....s = sum(d)\n....if not s % 2 and 2*n <= s:\n........d.remove(n)\n........s2, ld = int(s/2-n), len(d)\n........z = np.zeros((ld+1,s2+1),dtype=int)\n........for i in range(1,ld+1):\n............y = min(d[i-1],s2+1)\n............z[i,range(y)] = z[i-1,range(y)]\n............z[i,range(y,s2+1)] = np.maximum(z[i-1,range(y,s2+1)],z[i-1,range(0,s2+1-y)]+y)\n............if z[i,s2] == s2:\n................A175582.append(int(s/2))\n................break\n\n"}
{"sequence_id": "A175583", "text": "Zumkeller numbers n such that sigma(n)/2 - n is prime.", "sequence": "12,40,70,80,88,160,272,320,490,544,928,1184,1312,1332,1575,1696,1888,2420,2560,2624,2628,3380,3392,3712,3920,4030,4100,4736,5120,5248,5696,5830,6464,6664,6784,7232,7424,7808,8228,8704,8784,8925,9680,10100", "code": "\nfrom sympy import isprime, divisors\nfrom sympy.combinatorics.subsets import Subset\nfor n in range(1,10**5):\n    d = divisors(n)\n    s = sum(d)\n    if not s % 2 and max(d)<= s//2 and isprime(s//2-n):\n        for x in range(1,2**len(d)):\n            if sum(Subset.unrank_binary(x,d).subset) == s//2:\n                print(n,end=', ')\n                break\n\n"}
{"sequence_id": "A175583", "text": "Zumkeller numbers n such that sigma(n)/2 - n is prime.", "sequence": "12,40,70,80,88,160,272,320,490,544,928,1184,1312,1332,1575,1696,1888,2420,2560,2624,2628,3380,3392,3712,3920,4030,4100,4736,5120,5248,5696,5830,6464,6664,6784,7232,7424,7808,8228,8704,8784,8925,9680,10100", "code": "\nfrom sympy import isprime, divisors\nimport numpy as np\nA175583 = []\nfor n in range(1,10**5):\n    d = divisors(n)\n    s = sum(d)\n    if not s % 2 and 2*n <= s and isprime(s//2-n):\n        d.remove(n)\n        s2, ld = int(s//2-n), len(d)\n        z = np.zeros((ld+1,s2+1),dtype=int)\n        for i in range(1,ld+1):\n            y = min(d[i-1],s2+1)\n            z[i,range(y)] = z[i-1,range(y)]\n            z[i,range(y,s2+1)] = np.maximum(z[i-1,range(y,s2+1)],z[i-1,range(0,s2+1-y)]+y)\n            if z[i,s2] == s2:\n                A175583.append(n)\n                break\n\n"}
{"sequence_id": "A175591", "text": "a(n) = (sigma(n-th Zumkeller number)/2) - (n-th Zumkeller number).", "sequence": "0,2,1,6,0,6,5,6,14,6,4,24,6,2,6,13,28,2,27,30,6,1,32,12,6,60,30,36,6,28,36,40,29,72,6,10,93,6,62,36,48,9,78,84,32,6,28,52,39,132,6,112,6,34,96,90,7,60,80,6,48,134,6,45,28,108,6,61,102,160,38,48,72,22,26,6,225,28,6", "code": "\nfrom sympy import divisors\nimport numpy as np\nA175591 = []\nfor n in range(1,10**6):\n....d = divisors(n)\n....s = sum(d)\n....if not s % 2 and 2*n <= s:\n........d.remove(n)\n........s2, ld = int(s/2-n), len(d)\n........z = np.zeros((ld+1,s2+1),dtype=int)\n........for i in range(1,ld+1):\n............y = min(d[i-1],s2+1)\n............z[i,range(y)] = z[i-1,range(y)]\n............z[i,range(y,s2+1)] = np.maximum(z[i-1,range(y,s2+1)],z[i-1,range(0,s2+1-y)]+y)\n............if z[i,s2] == s2:\n................A175591.append(s2)\n................break\n\n"}
{"sequence_id": "A175634", "text": "Chen semiprimes: semiprimes m such that m+4 is either a prime or a semiprime.", "sequence": "6,9,10,15,21,22,25,33,34,35,39,49,51,55,57,58,65,69,82,85,87,91,93,111,115,118,119,123,129,133,141,142,145,155,159,169,177,183,187,201,202,205,209,213,214,215,217,219,235,237,247,249,253,259,265,267,274,287", "code": "\nfrom sympy.ntheory.factor_ import primeomega, isprime\ndef issemiprime(n): return primeomega(n) == 2\ndef ok(n): return issemiprime(n) and (issemiprime(n+4) or isprime(n+4))\nprint(list(filter(ok, range(1, 288)))) \n"}
{"sequence_id": "A175680", "text": "Semiprimes that are not Chen semiprimes A175634.", "sequence": "4,14,26,38,46,62,74,77,86,94,95,106,121,122,134,143,146,158,161,166,178,185,194,203,206,218,221,226,254,262,278,302,314,321,326,329,334,339,341,346,362,365,371,381,386,395,398,422,437,446,451,458,466,471", "code": "\nfrom sympy.ntheory.factor_ import primeomega, isprime\ndef issemiprime(n): return primeomega(n) == 2\ndef ok(n): return issemiprime(n) and not (issemiprime(n+4) or isprime(n+4))\nprint(list(filter(ok, range(1, 472)))) \n"}
{"sequence_id": "A175733", "text": "a(n) is the smallest n-digit number with 3 divisors.", "sequence": "4,25,121,1369,10201,100489,1018081,10004569,100140049,1000267129,10000600009,100008370081,1000006000009,10000033772089,100000380000361,1000000025191729,10000001400000049,100000000621806289,1000000014000000049,10000000055856073561", "code": "\nfrom math import sqrt\nfrom sympy import nextprime\ndef a(n): return nextprime(int(sqrt(10**n+1)))**2\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A175770", "text": "In the sequence of prime numbers, replace all the '3' digits with '1' and vice versa.", "sequence": "2,1,5,7,33,31,37,39,21,29,13,17,43,41,47,51,59,63,67,73,71,79,81,89,97,303,301,307,309,331,327,313,317,319,349,353,357,361,367,371,379,383,393,391,397,399,233,221,227,229,211,219,243,253,257,261,269,273,277", "code": "\nfrom sympy import prime\ndef a(n):\n  return int(str(prime(n)).translate({ord('1'):ord('3'), ord('3'):ord('1')}))\nprint([a(n) for n in range(1, 60)]) \n"}
{"sequence_id": "A175795", "text": "Numbers n such that the digits of sigma(n) are exactly the same (albeit in different order) as the digits of phi(n), in base 10.", "sequence": "1,65,207,1769,2066,2771,3197,4330,4587,4769,4946,5067,6443,6623,6989,7133,8201,9263,11951,12331,13243,16403,17429,17441,21416,22083,23161,24746,27058,27945,28049,28185,28451,29111,30551,31439,32554,32566,32849,33715", "code": "\nfrom sympy import totient, divisor_sigma\nA175795_list = [n for n in range(1,10**4) if sorted(str(divisor_sigma(n))) == sorted(str(totient(n)))] \n"}
{"sequence_id": "A175796", "text": "H_n(n, 2) where H_c(a, b) is the hyperoperation function with operator c.", "sequence": "3,3,4,9,256", "code": "\ndef H(a, b, c):\n    if c == 0: return b + 1\n    if c == 1 and b == 0: return a\n    if c == 2 and b == 0: return 0\n    if c >= 3 and b == 0: return 1\n    return H(a, H(a, b - 1, c), c - 1)\nfor n in range(5): print(H(n, 2, n))\n"}
{"sequence_id": "A175824", "text": "Maximum unsigned integer that can be stored in n bytes.", "sequence": "0,255,65535,16777215,4294967295,1099511627775,281474976710655,72057594037927935,18446744073709551615,4722366482869645213695,1208925819614629174706175,309485009821345068724781055", "code": "\nprint([2**(8 * i) - 1 for i in range(12)])\n"}
{"sequence_id": "A175825", "text": "Maximum signed integer that can be stored in n bytes.", "sequence": "127,32767,8388607,2147483647,549755813887,140737488355327,36028797018963967,9223372036854775807,2361183241434822606847,604462909807314587353087,154742504910672534362390527,39614081257132168796771975167,10141204801825835211973625643007", "code": "\nprint([2**(8 * i - 1) - 1 for i in range(1, 12)])\n"}
{"sequence_id": "A175833", "text": "Periodic sequence: repeat 4,7,11.", "sequence": "4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11,4,7,11", "code": " [4,7,11]*30 \n"}
{"sequence_id": "A175839", "text": "Smallest runs of n*2-1 consecutive composites.", "sequence": "4,8,9,10,24,25,26,27,28,90,91,92,93,94,95,96,114,115,116,117,118,119,120,121,122,114,115,116,117,118,119,120,121,122,123,124,114,115,116,117,118,119,120,121,122,123,124,125,126", "code": "\nfrom sympy import isprime\nout = []\nrun = 1\nfor n in range(4, 10000):\n    isrun = True\n    for o in range(run): isrun *= not isprime(n + o - run)\n    if isrun:\n        for o in range(run): out.append(n + o - run)\n        run += 2\nprint(out)\n"}
{"sequence_id": "A175867", "text": "a(0) = 2; a(n) = a(n - 1) * 2 + 1 if a(n - 1) is prime, or a(n - 1) / (smallest prime factor) if it is composite.", "sequence": "2,5,11,23,47,95,19,39,13,27,9,3,7,15,5,11,23,47,95,19,39,13,27,9,3,7,15,5,11,23,47,95,19,39,13,27,9,3,7,15,5,11,23,47,95,19,39,13,27,9,3,7,15,5,11,23,47,95,19,39,13,27,9,3,7,15,5,11,23,47,95,19,39,13,27,9,3,7", "code": "\nimport math\nfrom sympy import isprime\na = [2]\nwhile not a[ -1] in a[:-1]:\n    if isprime(a[ -1]):\n        a.append(a[ -1] * 2 + 1)\n    else:\n        for div in range(2, int(math.sqrt(a[ -1])) + 1):\n            if not a[ -1] % div:\n                a.append(a[ -1] // div)\n                break\nprint(a)\n"}
{"sequence_id": "A175871", "text": "a(0) = 2; a(n) = a(n - 1) * 3 + 1 if a(n - 1) is prime, or a(n - 1) / (smallest prime factor) if it is composite.", "sequence": "2,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,7,22,11,34,17,52,26,13,40,20,10,5,16,8", "code": "\nimport math\nfrom sympy import isprime\na = [2]\nwhile not a[ -1] in a[:-1]:\n    if isprime(a[ -1]):\n        a.append(a[ -1] * 3 + 1)\n    else:\n        for div in range(2, int(math.sqrt(a[ -1])) + 1):\n            if not a[ -1] % div:\n                a.append(a[ -1] // div)\n                break\nprint(a)\n"}
{"sequence_id": "A175892", "text": "Row a(0) = A000027; row a(n) for n > 0 is the sequence of natural numbers up to each k in row a(n-1).", "sequence": "1,1,2,1,1,3,1,1,2,4,1,1,1,1,5,1,1,1,2,2,6,1,1,1,1,1,3,7,1,1,1,1,2,1,1,8,1,1,1,1,1,1,2,2,9,1,1,1,1,1,2,1,1,3,10,1,1,1,1,1,1,1,1,2,4,11,1,1,1,1,1,1,2,1,2,3,1,12,1,1,1,1,1,1,1,1,1,1,1,2,13,1,1,1,1,1,1,1,2,1,1,1,1", "code": "\nout = [list(range(1, 143))]\nfor row in range(1, 142):\n    out.append([])\n    for column in range(142):\n        out[row].extend(range(1, out[row - 1][column] + 1))\n        if len(out[row]) > 143: break\nn = 0\nfor diagonal in range(142):\n    x = diagonal\n    while x >= 0:\n        print(n, out[x][diagonal - x])\n        n += 1\n        x -= 1\n"}
{"sequence_id": "A175924", "text": "Smallest power of 2 with n repeated digits.", "sequence": "1,65536,16777216,2199023255552,1684996666696914987166688442938726917102321526408785780068975640576", "code": "\nimport math\nfor N in range(1, 10):\n    repdigits = 1\n    n = 0\n    while repdigits < N:\n        n += 1\n        s = str(2 ** n)\n        prev = \"\"\n        repdigits = maxrepdigits = 1\n        for d in s:\n            if d == prev: repdigits += 1\n            else:\n                maxrepdigits = max(maxrepdigits, repdigits)\n                repdigits = 1\n            prev = d\n        repdigits = max(maxrepdigits, repdigits)\n    print(N, 2 ** n)\n"}
{"sequence_id": "A175930", "text": "Concatenation of run lengths in binary expansion of n, written in base 2, then converted to base 10.", "sequence": "1,3,2,6,7,5,3,7,13,15,14,10,11,7,4,12,15,27,26,30,31,29,15,11,21,23,22,14,15,9,5,13,25,31,30,54,55,53,27,31,61,63,62,58,59,31,28,20,23,43,42,46,47,45,23,15,29,31,30,18,19,11,6,14,27,51,50,62,63,61,31,55,109,111", "code": "\nfrom itertools import groupby\ndef a(n):\n    c = \"\".join(bin(len(list(g)))[2:] for k, g in groupby(bin(n)[2:]))\n    return int(c, 2)\nprint([a(n) for n in range(1, 75)]) \n"}
{"sequence_id": "A175941", "text": "Number of n-step self-avoiding walks on a line, where step X skips X - 1 spaces.", "sequence": "1,2,4,6,10,18,30,50,78,130,210,350,586,954,1606,2588,4234,6944,11342,18948,31450,52206,85662,141680,233040,385428,644910,1072074,1783342,2953094,4897922,8157096,13571014,22552212,37486916,62325564,103508754,172765524,287428656,479052200,798944976", "code": "\nx = 1\nn = 0\nruns = [[n]]\nwhile x < 30:\n    print(x - 1, n)\n    runs2 = []\n    n = 0\n    while runs:\n        for pmx in (x, -x):\n            if runs[0][ -1] + pmx not in runs[0]:\n                runs2.append(runs[0] + [runs[0][ -1] + pmx])\n                n += 1\n        del runs[0]\n    runs = runs2\n    x += 1\n"}
{"sequence_id": "A175975", "text": "Numbers n with property that n^n has exactly two 1's.", "sequence": "8,12,17,22,23,27,30", "code": "\nA175975_list = [n for n in range(1000) if str(n**n).count('1') == 2] \n"}
{"sequence_id": "A176112", "text": "This sequence contains primes that, under the Collatz function, take a prime number of steps to reach one.", "sequence": "3,5,41,43,53,61,109,139,149,163,167,173,179,227,233,269,307,317,373,401,439,443,479,541,557,563,607,617,619,661,751,787,827,863,911,937,1069,1087,1093,1097,1193,1259,1297,1303,1321,1373,1381,1409,1439", "code": "\n\n\n\n\n\n\ndef Collatz(number):\n....X = number\n....Steps = 0\n....while X != 1:\n........Steps += 1\n........if X%2==0:\n............X //= 2\n........else:\n............X = 3*X + 1\n.....return Steps\n\n\n\n\n\n\ndef primer(n):\n....if n==1:\n........return [2]\n....elif n==2:\n........return [2,3]\n....elif n<2:\n........return []\n....p = [2,3]\n....x = 0\n....i = 3\n....while len(p) < n+1:\n........if x < len(p):\n............if i%p[x] != 0:\n................x += 1\n............if p[x]> i**0.5:\n................p.append(i)\n................x = 0\n................i += 2\n............if i%p[x] == 0:\n................i += 2\n................x = 0\n....return [2]+p[2:]\n\n\n\n\n\n\n\n\n\nColDict = {}\nColPrime = {}\nColPriList = []\nColLineList = []\nPrimeList = primer(n)\nfor number in PrimeList:\n....Var = Collatz(number)\n....if Var not in ColDict:\n........ColDict[Var] = [number]\n....elif Var in ColDict:\n........ColDict[Var].append(number)\nfor key in ColDict:\n....if key in PrimeList:\n........ColPriList = ColPriList + ColDict[key] . ColPriList.sort()\n"}
{"sequence_id": "A176297", "text": "Numbers with at least one 3 in their prime signature.", "sequence": "8,24,27,40,54,56,72,88,104,108,120,125,135,136,152,168,184,189,200,216,232,248,250,264,270,280,296,297,312,328,343,344,351,360,375,376,378,392,408,424,432,440,456,459,472,488,500,504,513,520,536,540,552,568,584,594,600,616,621,632,648,664,675,680,686,696,702,712", "code": "\nfrom sympy import factorint\ndef ok(n): return 3 in [e for e in factorint(n).values()]\nprint(list(filter(ok, range(713)))) \n"}
{"sequence_id": "A176298", "text": "Triangle T(n,k) = 1 + n - floor(n/(k+1)) - floor(n/(n-k+1)) read by rows.", "sequence": "1,1,1,1,1,1,1,2,2,1,1,2,3,2,1,1,3,4,4,3,1,1,3,4,5,4,3,1,1,4,5,6,6,5,4,1,1,4,6,6,7,6,6,4,1,1,5,6,7,8,8,7,6,5,1,1,5,7,8,8,9,8,8,7,5,1,1,6,8,9,9,10,10,9,9,8,6,1,1,6,8,9,10,10,11,10,10,9,8,6,1", "code": "\n\ni=0\nfor n in range(126):\n    for m in range(n+1):\n        print(str(i)+\" \"+str(1+n-(n/(m+1))-(n/(n-m+1))))\n        i+=1 \n"}
{"sequence_id": "A176299", "text": "Variant sequence A169652, with a(1)=1 and a(2)=3.", "sequence": "1,3,16,400,176400,31265312400,977530816165936208400,955566496615167328821016225384209913664400,913107329453384594090655605142589591944555936335177523176387250981965992675658480400", "code": "\n\nlst=[1,3]\nprint(\"1 1\")\nprint(\"2 3\")\ni=3\na=sum(lst)**2\nwhile i<=12:\n    print(str(i)+\" \"+str(a))\n    lst.append(a)\n    i+=1\n    a=sum(lst)**2 \n"}
{"sequence_id": "A176303", "text": "a(n) = abs(2^n-127).", "sequence": "126,125,123,119,111,95,63,1,129,385,897,1921,3969,8065,16257,32641,65409,130945,262017,524161,1048449,2097025,4194177,8388481,16777089,33554305,67108737,134217601,268435329,536870785,1073741697,2147483521,4294967169", "code": " def A176303(n): return abs(2**n-127) \n"}
{"sequence_id": "A176341", "text": "a(n) = the location of the first appearance of the decimal expansion of n in the decimal expansion of Pi.", "sequence": "32,1,6,0,2,4,7,13,11,5,49,94,148,110,1,3,40,95,424,37,53,93,135,16,292,89,6,28,33,186,64,0,15,24,86,9,285,46,17,43,70,2,92,23,59,60,19,119,87,57,31,48,172,8,191,130,210,404,10,4,127,219,20,312,22,7,117,98,605,41", "code": "\npi = \"314159265358979323846264338327950288419716939937510582097494459230...\"\n[ pi.find(str(i)) for i in range(10000) ]\n"}
{"sequence_id": "A176371", "text": "Primes p such that reversal(p) - 13 is a square.", "sequence": "31,41,71,83,281,311,431,479,733,751,797,2011,2857,3163,4373,4397,4943,7541,7577,7583,9413,9491,20533,20731,20771,24151,24547,24767,26249,28979,31121,41201,41609,43321,43391,43753,45641,49459,49463,49811,49891", "code": "\nfrom sympy import isprime\nA176371_list, i, j = [], 0, 13\nwhile j < 10**10:\n    p = int(str(j)[::-1])\n    if j % 10 and isprime(p):\n        A176371_list.append(p)\n    j += 2*i+1\n    i += 1\nA176371_list = sorted(A176371_list) \n"}
{"sequence_id": "A176482", "text": "Triangle, read by rows, defined by T(n, k) = b(n) - b(k) - b(n-k) + 1 (see formula section for recurrence for b(n)).", "sequence": "1,1,1,1,3,1,1,9,9,1,1,29,35,29,1,1,94,120,120,94,1,1,304,395,415,395,304,1,1,983,1284,1369,1369,1284,983,1,1,3179,4159,4454,4519,4454,4159,3179,1,1,10281,13457,14431,14706,14706,14431,13457,10281,1", "code": " \n"}
{"sequence_id": "A176508", "text": "Triangle, read by rows, defined by T(n, k) = b(n) - b(k) - b(n-k) + 1, b(n) = A003269(n).", "sequence": "1,1,1,1,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,1,1,1,1,2,3,3,2,1,1,1,1,2,3,4,3,2,1,1,1,2,3,4,5,5,4,3,2,1,1,3,5,6,7,7,7,6,5,3,1", "code": " \n"}
{"sequence_id": "A176558", "text": "a(n) is the reverse concatenation of divisors of n.", "sequence": "1,21,31,421,51,6321,71,8421,931,10521,111,1264321,131,14721,15531,168421,171,1896321,191,20105421,21731,221121,231,2412864321,2551,261321,27931,28147421,291,30151065321,311,32168421,331131,341721,35751,361812964321,371", "code": "\nfrom sympy import divisors\ndef a(n): return int(\"\".join(str(d) for d in divisors(n)[::-1]))\nprint([a(n) for n in range(1, 35)]) \n"}
{"sequence_id": "A176630", "text": "Nonpalindromic numbers whose binary representation when reversed is the same as binary representation of the number reversed in decimal.", "sequence": "92,732,759,957,5485,5845,71869,77360,96817,319773,377913,13162800,39781062,79497594,94729789,98792749,144579540,1231493321,1233941321,7075293947,7493925707,32817543720,71461803829,92830816417", "code": "\ndef agen():\n  k = 0\n  while True:\n    strk = str(k)\n    revstrk = strk[::-1]\n    if revstrk != strk:\n      if int(revstrk) == int((bin(k)[2:])[::-1], 2):\n        yield k\n    k += 1\ng = agen()\nprint([next(g) for i in range(11)]) \n"}
{"sequence_id": "A176670", "text": "Composite numbers having the same digits as their prime factors (with multiplicity), excluding zero digits.", "sequence": "1111,1255,12955,17482,25105,28174,51295,81229,91365,100255,101299,105295,107329,110191,110317,117067,124483,127417,129595,132565,137281,145273,146137,149782,163797,171735,174082,174298,174793,174982,193117,208174,210181,217894", "code": "\nfrom sympy import factorint, flatten\ndef sd(n): return sorted(str(n).replace('0', ''))\ndef ok(n):\n  f = factorint(n)\n  return sum(f[p] for p in f) > 1 and sd(n) == sorted(flatten(sd(p)*f[p] for p in f))\nprint(list(filter(ok, range(220000)))) \n"}
{"sequence_id": "A176707", "text": "Sum of digits of all distinct prime factors of n-th semiprime.", "sequence": "2,5,3,7,9,8,10,4,5,6,5,10,12,12,7,7,7,11,7,13,13,6,9,8,12,9,7,13,9,14,11,7,13,15,10,13,10,16,15,2,9,8,10,17,15,14,10,6,16,12,9,18,11,12,13,4,17,19,10,15,10,18,16,4,18,10,6,12,11,10,12,11,12,13,12,7,16,19,14,14,7", "code": "\nfrom sympy import factorint\ndef aupton(terms):\n  alst, m = [], 4\n  while len(alst) < terms:\n    f = factorint(m)\n    if sum(f.values()) == 2: \n      alst.append(sum(sum(map(int, str(p))) for p in f.keys()))\n    m += 1\n  return alst\nprint(aupton(81)) \n"}
{"sequence_id": "A176774", "text": "Smallest polygonality of n = smallest integer m>=3 such that n is m-gonal number.", "sequence": "3,4,5,3,7,8,4,3,11,5,13,14,3,4,17,7,19,20,3,5,23,9,4,26,10,3,29,11,31,32,12,7,5,3,37,38,14,8,41,15,43,44,3,9,47,17,4,50,5,10,53,19,3,56,20,11,59,21,61,62,22,4,8,3,67,68,24,5,71,25,73,74,9,14,77,3,79,80,4,15,83", "code": "\nfrom __future__ import division\nfrom gmpy2 import isqrt\ndef A176774(n):\n    k = (isqrt(8*n+1)-1)//2\n    while k >= 2:\n        a, b = divmod(2*(k*(k-2)+n),k*(k-1))\n        if not b:\n            return a\n        k -= 1 \n"}
{"sequence_id": "A176838", "text": "Primes p such that p^3 = q//3 for a prime q, where \"//\" denotes concatenation.", "sequence": "17,157,257,277,397,677,877,997,1217,1697,1997,2417,2777,3257,3517,3697,4157,4177,5077,5197,5897,6277,7417,7517,8377,9397,9497,9677,9857,11197,11597,12157,12457,12697,13397,13477,13877,14057,14197,15017,16477,17597,18097", "code": "\nfrom sympy import isprime, primerange\ndef ok(p): q, r = divmod(p**3, 10); return r == 3 and isprime(q)\nprint(list(filter(ok, primerange(2, 18200)))) \n"}
{"sequence_id": "A176898", "text": "a(n) = binomial(6*n, 3*n)*binomial(3*n, n)/(2*(2*n+1)*binomial(2*n, n)).", "sequence": "5,231,14586,1062347,84021990,7012604550,607892634420,54200780036595,4938927219474990,457909109348466930,43057935618181929900,4096531994713828810686,393617202432246696493436,38142088615983865845923052,3723160004902167033863327592", "code": "\nimport math\nf=math.factorial\ndef C(n,r): return f(n)/f(r)/f(n-r)\ndef A176898(n): return C(6*n, 3*n) * C(3*n, n) / (2*(2*n+1) * C(2*n, n)) \n"}
{"sequence_id": "A176975", "text": "Dimension arising in an indefinite quaternion algebra over Q.", "sequence": "0,-1,0,-1,1,2,2,2,3,4,6,6,8,8,11,13,15,17,19,22,27,29,33,36,42,47,52,57,63,70,78,84,93,100,110,120,130,140,151,163,177,189,203,216,233,249,265,282,300,319,340,359,381,402,426,450,475,500,526,554,584", "code": "\n[(4*k**3-18*k**2+696*k-1737+(-1)**k*225 + [0,-1,1][k%3]*160 + [1,0,0,-1][k%4]*360 + [1,0,0,-1,0][k%5]*1152) // 1440 for k in range(100)] \n"}
{"sequence_id": "A177025", "text": "Number of ways to represent n as a polygonal number.", "sequence": "1,1,1,2,1,1,2,2,1,2,1,1,3,2,1,2,1,1,3,2,1,2,2,1,2,3,1,2,1,1,2,2,2,4,1,1,2,2,1,2,1,1,4,2,1,2,2,1,3,2,1,2,3,1,2,2,1,2,1,1,2,3,2,4,1,1,2,3,1,2,1,1,3,2,1,3,1,1,4,2,1,2,2,1,2,2,1,2,3,2,2,2,2,3,1,1,2,3", "code": "\nfrom sympy import divisors\ndef a(n):\n    i=2*n\n    x=0\n    for d in divisors(i):\n        if d>2:\n            s=i/d\n            if (s - 2)%(d - 1)==0: x+=1\n    return x \n"}
{"sequence_id": "A177029", "text": "Numbers that have exactly two different representations as polygonal numbers.", "sequence": "6,9,10,12,16,18,22,24,25,27,30,33,34,35,39,40,42,46,48,49,52,54,57,58,60,63,65,69,72,76,82,84,85,87,88,90,92,93,94,95,99,102,106,108,114,115,118,121,123,124,125,129,130,132,133,138,142,147,150,155,159,160,162,166,168", "code": "\nA177029_list = []\nfor m in range(1,10**4):\n    n, c = 3, 0\n    while n*(n+1) <= 2*m:\n        if not 2*(n*(n-2) + m) % (n*(n - 1)):\n            c += 1\n            if c > 1:\n                break\n        n += 1\n    if c == 1:\n        A177029_list.append(m) \n"}
{"sequence_id": "A177360", "text": "a(n) contains the nonzero frequencies f(d) of digits d=0 .. 9 in all terms up to a(n-1) in concatenated form sorted with respect to d: f(0)//0//f(1)//1//...//f(9)//9. Initial term a(1)=1.", "sequence": "1,11,31,4113,612314,8112332416,1113253342618,151528344153628,1817210364454648,102118211310455661768,3028110212311475962788,50331142143124851064711819,704111621731641051165713829,905011821931841251468714839,1105712022132141451569718869", "code": "\ndef aupton(nn):\n  alst, last_str = [1], \"1\"\n  dig_counts = [0 for i in range(10)]\n  for n in range(2, nn+1):\n    nxt = []\n    for d in \"0123456789\":\n      if d in last_str: dig_counts[int(d)] += last_str.count(d)\n      if dig_counts[int(d)] > 0: nxt += [dig_counts[int(d)], int(d)]\n    nxt_str = \"\".join(map(str, nxt))\n    alst.append(int(nxt_str)); last_str = nxt_str\n  return alst\nprint(aupton(15)) \n"}
{"sequence_id": "A177719", "text": "Number of line segments connecting exactly 3 points in an n X n grid of points", "sequence": "0,0,8,24,60,112,212,344,548,800,1196,1672,2284,2992,3988,5128,6556,8160,10180,12424,15068,17968,21604,25576,30092,34976,40900,47288,54500,62224,70972,80296,90740,101824,114700,128344,143212,158896,176836", "code": "\nfrom sympy import totient\ndef A177719(n): return 4*((n-1)*(n-2) + sum(totient(i)*(n-2*i)*(n-i) for i in range(2,n//2+1))) \n"}
{"sequence_id": "A177869", "text": "Integers divisible by their number of digits in binary.", "sequence": "1,2,6,8,12,20,25,30,36,42,48,54,60,70,77,84,91,98,105,112,119,126,128,136,144,152,160,168,176,184,192,200,208,216,224,232,240,248,261,270,279,288,297,306,315,324,333,342,351,360,369,378,387,396,405", "code": "\nimport math\nfor n in range(1, 1000):\n    if not n % int(math.log(n, 2) + 1): print(n) \n"}
{"sequence_id": "A177958", "text": "a(n) = n for n <= 6; for n > 6, a(n) is the smallest number not already used such that gcd(a(n), a(n-1)) >= 6.", "sequence": "1,2,3,4,5,6,12,18,9,27,36,24,8,16,32,40,10,20,30,15,45,54,42,7,14,21,28,35,49,56,48,60,50,25,75,90,63,70,77,11,22,33,44,55,66,72,64,80,88,96,78,13,26,39,52,65,91,84,98,105", "code": "\nfrom sympy import gcd\nl=list(range(1, 7))\nfor n in range(6, 101):\n    k=7\n    while k in l or gcd(l[n - 1], k)<6: k+=1\n    l.append(k)\nprint(l) \n"}
{"sequence_id": "A177970", "text": "Array T(n,m) = A177944(2*n,2*m) read by antidiagonals.", "sequence": "1,1,1,1,26,1,1,99,99,1,1,244,622,244,1,1,485,2300,2300,485,1,1,846,6423,12000,6423,846,1,1,1351,15001,45031,45031,15001,1351,1,1,2024,30924,136120,218774,136120,30924,2024,1,1,2889,58122,352698,831384", "code": "\nfrom sympy import binomial\ndef T(m, n): return (2*n + 1)*binomial(2*m + 1 + 2*n, 2*m) - 2*n - 2*m\nfor n in range(11): print([T(m, n - m) for m in range(n + 1)]) \n"}
{"sequence_id": "A178029", "text": "Numbers whose sum of divisors equals the sum of their anti-divisors.", "sequence": "11,22,33,65,82,117,218,483,508,537,6430,21541,117818,3589646,7231219,8515767,13050345,47245905,50414595,104335023,217728002,1217532421,1573368218,1875543429,2269058065,11902221245,12196454655,12658724029", "code": "\nfrom sympy import divisors\n[n for n in range(1,10**5) if sum([d for d in range(2,n) if (n % d) and (2*n) % d in [d-1,0,1]]) == sum(divisors(n))] \n"}
{"sequence_id": "A178061", "text": "Number of distinct cycles without repeated edges on the multigraph consisting of two vertices joined by n edges.", "sequence": "0,0,1,3,9,25,120,546,4438,28134,308115,2440405,33237831,314699463,5119097074,56345113020,1065268609980,13359512435356,287786703606453,4049825314169079,97903924694681365,1527478596708475845,40946200336523631996,701409698806896677158", "code": "\ndef trfact_(n, k):\n    return reduce(lambda x, y: x*y, range(k+1, n+1), 1)\ndef choose_(n,k):\n    if k > n/2:\n        return trfact_(n,k)/trfact_(n-k,1)\n    else:\n        return trfact_(n,n-k)/trfact_(k,1)\ndef a_(n):\n    return choose_(n,2) + sum(trfact_(n, n-k)/(2*k) for k in range(4, n+1, 2))\n"}
{"sequence_id": "A178165", "text": "Number of unordered collections of distinct nonempty subsets of an n-element set where each element appears in at most 2 subsets.", "sequence": "1,2,8,59,652,9736,186478,4421018,126317785,4260664251,166884941780,7489637988545,380861594219460,21739310882945458,1381634777325000263,97089956842985393297,7497783115765911443879,632884743974716421132084", "code": "\ndef powerSet(k): return [toBinary(n,k) for n in range(1,2**k)]\ndef courcelle(maxUses, remainingSets, exact=False):\n    if exact and not all(maxUses<=sum(remainingSets)): ans=0\n    elif len(remainingSets)==0: ans=1\n    else:\n        set0=remainingSets[0]\n        if all(set0<=maxUses): ans=courcelle(maxUses-set0,remainingSets[1:],exact=exact)\n        else: ans=0\n        ans+=courcelle(maxUses,remainingSets[1:],exact=exact)\n    return ans\nfor i in range(10):\n    print(i, courcelle(array([2]*i),powerSet(i),exact=False))\n"}
{"sequence_id": "A178173", "text": "Number of collections of nonempty subsets of an n-element set where each element appears in at most 4 subsets.", "sequence": "1,2,8,128,11087,2232875,775098224,428188962261,355916994389700,425272149099677521,703909738878615927739,1565842283246869237505246,4565002967677134523844716754,17076464900445281560851997140670,80494979734877344662882495100752511", "code": "\nfrom sets import Set\nfrom numpy import array\ndef toBinary(n,k):\n    ans=[]\n    for i in range(k):\n        ans.insert(0,n%2)\n        n=n>>1\n    return array(ans)\ndef powerSet(k): return [toBinary(n,k) for n in range(1,2**k)]\ndef courcelle(maxUses,remainingSets,exact=False):\n    if exact and not all(maxUses<=sum(remainingSets)): ans=0\n    elif len(remainingSets)==0: ans=1\n    else:\n        set0=remainingSets[0]\n        if all(set0<=maxUses): ans=courcelle(maxUses-set0,remainingSets[1:],exact=exact)\n        else: ans=0\n        ans+=courcelle(maxUses,remainingSets[1:],exact=exact)\n    return ans\nfor i in range(10):\n    print(i, courcelle(array([4]*i),powerSet(i),exact=False))\n"}
{"sequence_id": "A178218", "text": "Numbers of the form 2k^2-2k+1 or 2k^2-1.", "sequence": "1,5,7,13,17,25,31,41,49,61,71,85,97,113,127,145,161,181,199,221,241,265,287,313,337,365,391,421,449,481,511,545,577,613,647,685,721,761,799,841,881,925,967,1013,1057,1105,1151,1201,1249", "code": "\na = 1\nfor n in range(2,77):\n    print(a, end=\",\")\n    a = n*(n+1) - a\n\n"}
{"sequence_id": "A178354", "text": "Numbers m such that d(1)^1 + d(2)^2 + ... + d(p)^p = d(1)^p + d(2)^(p-1) +... + d(p)^1, where d(i), i=1..p, are the digits of m.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,22,33,44,55,66,77,88,99,100,101,110,111,120,121,130,131,140,141,150,151,160,161,170,171,180,181,190,191,202,212,222,232,242,252,262,272,282,292,303,313,323,333,343,353,363,373,383,393,404,414,424,434,444,454", "code": "\ndef digpow(s): return sum(int(d)**i for i, d in enumerate(s, start=1))\ndef aupto(limit):\n  alst = []\n  for k in range(1, limit+1):\n    s = str(k)\n    if digpow(s) == digpow(s[::-1]): alst.append(k)\n  return alst\nprint(aupto(454)) \n"}
{"sequence_id": "A178366", "text": "Numbers with rounded up arithmetic mean of digits = 6.", "sequence": "6,29,38,39,47,48,56,57,65,66,74,75,83,84,92,93,169,178,179,187,188,189,196,197,198,259,268,269,277,278,279,286,287,288,295,296,297,349,358,359,367,368,369,376,377,378,385,386,387,394,395,396,439,448,449,457", "code": "\ndef ok(n): s = str(n); return 5*len(s) < sum(map(int, s)) <= 6*len(s)\nprint(list(filter(ok, range(458)))) \n"}
{"sequence_id": "A178534", "text": "Triangle T(n,k) read by rows. T(n,1) = A000045(n+1), k > 1: T(n,k) = (Sum_{i=1..k-1} T(n-i,k-1)) - (Sum_{i=1..k-1} T(n-i,k)).", "sequence": "1,2,1,3,1,1,5,2,1,1,8,3,1,1,1,13,5,3,1,1,1,21,8,4,2,1,1,1,34,13,6,4,2,1,1,1,55,21,11,6,3,2,1,1,1,89,34,17,9,6,3,2,1,1,1,144,55,27,15,9,5,3,2,1,1,1,233,89,45,25,14,9,5,3,2,1,1,1,377,144,72,40,23,14,8,5,3,2,1,1,1", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import fibonacci\n@cacheit\ndef A(n, k): return fibonacci(n + 1) if k==1 else 0 if k>n else sum([A(n - i, k - 1) for i in range(1, k)]) - sum([A(n - i, k) for i in range(1, k)])\nfor n in range(1, 13): print([A(n, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A178550", "text": "Primes with exactly one digit 1.", "sequence": "13,17,19,31,41,61,71,103,107,109,127,137,139,149,157,163,167,173,179,193,197,199,241,251,271,281,313,317,331,401,419,421,431,461,491,521,541,571,601,613,617,619,631,641,661,691,701,719,751,761,821,881,919", "code": "\nfrom sympy import isprime\nprint([i for i in range(1000) if str(i).count('1') == 1 and isprime(i)]) \n"}
{"sequence_id": "A178551", "text": "Primes with exactly two 2's.", "sequence": "223,227,229,1223,1229,2027,2029,2129,2203,2207,2213,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2423,2521,2621,2729,2927,3221,3229,4229,5227,6221,6229,7229,8221,9221,9227,10223,12203,12211,12239", "code": "\nfrom sympy import isprime\nprint([i for i in range(10000) if str(i).count('2') == 2 and isprime(i)]) \n"}
{"sequence_id": "A178715", "text": "a(n) = solution to the \"Select All, Copy, Paste\" problem: Given the ability to type a single letter, or to type individual \"Select All\", \"Copy\" or \"Paste\" command keystrokes, what is the maximal number of letters of text that can be obtained with n keystrokes?", "sequence": "1,2,3,4,5,6,9,12,16,20,27,36,48,64,81,108,144,192,256,324,432,576,768,1024,1296,1728,2304,3072,4096,5184,6912,9216,12288,16384,20736,27648,36864,49152,65536,82944,110592,147456,196608,262144,331776,442368,589824,786432,1048576,1327104,1769472,2359296,3145728,4194304", "code": "\ndef a(n):\n    c=(n//5) + 1\n    if n<15:\n        if n==5: return 5\n        if n==10: return 20\n        r=(n + 1)%c\n        q=((n + 1)//c) - 1\n        return q**(c - r)*(q + 1)**r\n    else:\n        r=n%5\n        return 3**(4 - r)*4**(c - 4 + r)\nprint([a(n) for n in range(1, 102)]) \n"}
{"sequence_id": "A178921", "text": "Product of distances between successive distinct prime divisors of n; zero if n has only 1 distinct prime factor.", "sequence": "0,0,0,0,0,1,0,0,0,3,0,1,0,5,2,0,0,1,0,3,4,9,0,1,0,11,0,5,0,2,0,0,8,15,2,1,0,17,10,3,0,4,0,9,2,21,0,1,0,3,14,11,0,1,6,5,16,27,0,2,0,29,4,0,8,8,0,15,20,6,0,1,0,35,2,17,4,10,0,3,0,39,0,4,12,41,26,9,0,2,6,21,28,45,14,1,0,5,8,3,0,14,0,11", "code": "\nfrom sympy import primerange\nprimes = list(primerange(2,500))\nfor n in range(1,100):\n    d = n\n    prev = 0\n    product = 1\n    for p in primes:\n        if d%p==0:\n            if prev:\n                product *= p-prev\n            while d%p==0:\n                d//=p\n            if d==1:\n                break\n            prev = p\n    if prev==0:\n        product = 0\n    print(product, end=',')\n"}
{"sequence_id": "A179027", "text": "Primes with a 3 as the only prime digit.", "sequence": "3,13,31,43,83,103,113,131,139,163,193,311,349,389,431,439,443,463,613,631,643,683,839,863,883,983,1013,1031,1039,1063,1093,1103,1163,1193,1301,1319,1361,1381,1399,1439,1483,1493,1613,1663,1693,1831,1913,1931", "code": "\nfrom sympy import sieve\ndef ok(p): s=str(p); return set(s)&set(\"2357\")=={'3'} and s.count('3')==1\ndef aupto(limit): return [p for p in sieve.primerange(1, limit+1) if ok(p)]\nprint(aupto(1931)) \n"}
{"sequence_id": "A179118", "text": "Number of Collatz steps to reach 1 starting with 2^n + 1.", "sequence": "1,7,5,19,12,26,27,121,122,35,36,156,113,52,53,98,99,100,101,102,72,166,167,168,169,170,171,247,173,187,188,251,252,178,179,317,243,195,196,153,154,155,156,400,326,495,496,161,162,331,332,408,471,410,411,337,338,339,340,553", "code": "\ndef steps(a):\n  if a==1:     return 0\n  elif a%2==0: return 1+steps(a//2)\n  else:        return 1+steps(a*3+1)\nfor n in range(60):\n  print(n, steps((1<<n)+1))\n"}
{"sequence_id": "A179290", "text": "Decimal expansion of length of edge of a regular icosahedron with radius of circumscribed sphere = 1.", "sequence": "1,0,5,1,4,6,2,2,2,4,2,3,8,2,6,7,2,1,2,0,5,1,3,3,8,1,6,9,6,9,5,7,5,3,2,1,4,5,7,0,9,9,5,8,6,4,4,8,6,6,8,3,5,6,3,0,5,7,8,7,1,0,4,6,4,8,2,4,2,2,2,9,2,8,0,6,4,2,8,0,3,6,7,4,3,2,6,5,2,5,7,6,6,3,1,0,5,1,4,1,9,1,3,3,9", "code": "\nfrom decimal import *\ngetcontext().prec = 110\nc = Decimal.sqrt(2 - 2 / Decimal.sqrt(Decimal(5)))\nprint([int(i) for i in str(c) if i != '.'])\n\n"}
{"sequence_id": "A179295", "text": "a(n) is the least prime number such that prime(n)+a(n)+1 is a prime or -1 if no such prime number exists.", "sequence": "2,3,5,3,5,3,5,3,5,7,5,3,5,3,5,5,7,5,3,7,5,3,5,7,3,5,3,5,3,13,3,5,11,11,7,5,5,3,5,5,11,11,5,3,13,11,11,3,5,3,5,11,29,5,5,5,7,5,3,11,23,13,3,5,3,13,5,11,5,3,5,7,5,5,3,5,7,3,7,11,11", "code": "\nfrom sympy import prime, isprime, nextprime\ndef a(n):\n    p=2\n    while not isprime(prime(n) + p + 1): p=nextprime(p)\n    return p\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A179550", "text": "Primes p such that p plus or minus the sum of its digits squared yields a prime in both cases.", "sequence": "13,127,457,1429,1553,1621,2273,2341,2837,4129,4231,4561,4813,5119,5519,5531,6121,6451,6547,8161,8167,8219,8237,8783,8819,8831,8941,9511,10267,10559,11299,11383,12809,13183,15091,15569,16573,17569,17659,18133", "code": "\nfrom sympy import isprime, primerange\ndef sumdd(n): return sum(int(d)**2 for d in str(n))\ndef list(nn):\n  for p in primerange(2, nn+1):\n    s = sumdd(p)\n    if isprime(p-s) and isprime(p+s): print(p, end=\", \")\nlist(18133) \n"}
{"sequence_id": "A179551", "text": "Primes p such that p plus the sum of cubes of its digits yields a prime.", "sequence": "11,13,31,73,79,101,103,109,127,167,257,277,307,367,389,419,431,439,523,587,613,653,673,677,691,761,907,947,983,1021,1061,1063,1151,1153,1193,1283,1289,1409,1423,1483,1553,1559,1579,1621,1733,1759,1823,1847,1861", "code": "\nfrom sympy import isprime, primerange\ndef sumddd(n): return sum(int(d)**3 for d in str(n))\ndef list(nn):\n  for p in primerange(2, nn+1):\n    if isprime(p+sumddd(p)): print(p, end=\", \")\nlist(1861) \n"}
{"sequence_id": "A179767", "text": "a(n) is the smallest prime of the form 4k + 3 such that the first n iterations of the map p -> 4p + 3 are prime with the next iteration being composite.", "sequence": "3,19,7,179,1447,32059,55171,17231,32611,644823367,8870650619,10808693851,26813406071", "code": "\nfrom sympy import isprime\ndef iters(p):\n  c = 0\n  while isprime(4*p + 3): p, c = 4*p + 3, c + 1\n  return c\ndef a(n):\n  k = 0\n  while True:\n    p, k = 4*k + 3, k + 1\n    if isprime(p) and iters(p) == n: return p\nprint([a(n) for n in range(9)]) \n"}
{"sequence_id": "A179865", "text": "Number of n-bit binary numbers containing one run of 0's.", "sequence": "1,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276,300,325,351,378,406,435,465,496,528,561,595,630,666,703,741,780,820,861,903,946,990,1035,1081,1128,1176,1225,1275,1326,1378,1431", "code": "\ndef A179865(n):\n    if n==1: return 1\n    return n*(n-1)//2  \n"}
{"sequence_id": "A179897", "text": "Numbers a_n with property that a(n) is arithmetic mean of sequence \"n-times n^-1, once n^(2*n+1)\" that has integer valued both arithmetic and geometric means even though some of the sequence members are (for n>1) non-integer.", "sequence": "1,11,547,52429,8138021,1865813431,593445188743,250199979298361,135085171767299209,90909090909090909091", "code": " [(n**(2*n+1)+1)//(n+1) for n in range(1,11)]\n"}
{"sequence_id": "A179937", "text": "a(n) is the product of the non-palindromic divisors of n.", "sequence": "1,1,1,1,1,1,1,1,1,10,1,12,13,14,15,16,17,18,19,200,21,1,23,288,25,338,27,392,29,4500,31,512,1,578,35,7776,37,722,507,8000,41,12348,43,1,675,1058,47,221184,49,12500,867,17576,53,26244,1,21952,1083,1682,59", "code": "\ndef ispal(n):\n    return n==int(str(n)[::-1])\ndef A179937(n):\n    s=1\n    for i in range(1, n+1):\n        if n%i==0 and not ispal(i):\n            s*=i\n    return s \n"}
{"sequence_id": "A180130", "text": "Smallest k such that k*2^n is a sum of two successive primes.", "sequence": "5,4,2,1,7,4,2,1,9,15,8,4,2,1,25,19,11,12,6,3,10,5,35,33,52,26,13,28,14,7,15,38,19,45,47,26,13,43,84,42,21,39,35,18,9,46,23,43,49,104,52,26,13,48,24,12,6,3,21,36,18,9,15,15,9,42,21,23,67,62,31,64,32,16,8,4,2,1,45", "code": "\nfrom sympy import isprime, nextprime, prevprime\ndef ok(n):\n  if n <= 5: return n == 5\n  return not isprime(n//2) and n == prevprime(n//2) + nextprime(n//2)\ndef a(n):\n  k, pow2 = 1, 2**n\n  while not ok(k*pow2): k += 1\n  return k\nprint([a(n) for n in range(79)]) \n"}
{"sequence_id": "A180131", "text": "Smallest k such that k*3^n is a sum of two successive primes.", "sequence": "5,4,2,6,2,10,20,26,22,10,16,8,8,72,24,8,18,6,2,6,2,10,20,20,22,20,52,50,104,118,84,28,38,306,102,34,100,50,30,10,192,64,46,66,22,220,84,28,176,88,30,10,8,152,292,98,82,124,160,206,106,106,160,128,78,26,110,80", "code": "\nfrom sympy import isprime, nextprime, prevprime\ndef ok(n):\n  if n <= 5: return n == 5\n  return not isprime(n//2) and n == prevprime(n//2) + nextprime(n//2)\ndef a(n):\n  k, pow3 = 1, 3**n\n  while not ok(k*pow3): k += 1\n  return k\nprint([a(n) for n in range(68)]) \n"}
{"sequence_id": "A180132", "text": "Smallest k such that k*5^n is a sum of two successive primes.", "sequence": "5,1,4,10,2,8,12,12,36,12,28,66,30,6,18,132,36,108,34,14,48,60,12,22,150,30,6,74,54,16,8,66,150,30,6,14,374,110,22,82,62,66,108,348,114,428,190,38,570,114,102,24,82,86,178,420,84,108,328,186,126,192,76,82,24", "code": "\nfrom sympy import nextprime, prevprime\ndef sum2succ(n): return n == prevprime(n//2) + nextprime(n//2)\ndef a(n):\n  if n < 2: return [5, 1][n]\n  k, pow5 = 1, 5**n\n  while not sum2succ(k*pow5): k += 1\n  return k\nprint([a(n) for n in range(65)]) \n"}
{"sequence_id": "A180133", "text": "Smallest k such that k*6^n is a sum of two successive primes.", "sequence": "5,2,1,1,4,12,2,1,4,3,5,8,7,34,8,11,33,26,13,9,13,90,15,40,30,5,43,9,69,38,27,79,47,9,36,6,1,92,44,51,50,16,81,21,9,50,84,14,45,59,124,215,36,6,1,20,31,35,33,46,18,3,23,114,19,41,84,14,8,35,114,19,73,14,39,68,42", "code": "\nfrom sympy import nextprime, prevprime\ndef sum2succ(n): return n == prevprime(n//2) + nextprime(n//2)\ndef a(n):\n  if n == 0: return 5\n  k, pow6 = 1, 6**n\n  while not sum2succ(k*pow6): k += 1\n  return k\nprint([a(n) for n in range(77)]) \n"}
{"sequence_id": "A180134", "text": "Smallest k such that k*7^n is a sum of two successive primes.", "sequence": "5,6,18,10,30,18,4,28,4,30,30,60,120,38,12,6,52,120,70,10,102,60,70,10,186,174,42,6,90,146,154,22,18,140,20,168,24,240,60,80,26,286,154,22,12,196,28,4,2,128,116,156,422,130,204,84,12,118,88,240,536,564,798,114", "code": "\nfrom sympy import isprime, nextprime, prevprime\ndef ok(n):\n  if n <= 5: return n == 5\n  return not isprime(n//2) and n == prevprime(n//2) + nextprime(n//2)\ndef a(n):\n  k, pow7 = 1, 7**n\n  while not ok(k*pow7): k += 1\n  return k\nprint([a(n) for n in range(64)]) \n"}
{"sequence_id": "A180135", "text": "Smallest k such that k*11^n is a sum of two successive primes.", "sequence": "5,18,6,24,6,32,40,26,20,94,50,26,10,168,30,18,196,126,70,166,30,54,130,26,50,10,40,28,20,120,84,26,228,336,92,174,24,308,28,102,216,232,68,112,192,252,512,302,110,10,330,30,138,150,168,770,70,264,24,72,180,198", "code": "\nfrom sympy import isprime, nextprime, prevprime\ndef ok(n):\n  if n <= 5: return n == 5\n  return not isprime(n//2) and n == prevprime(n//2) + nextprime(n//2)\ndef a(n):\n  k, pow11 = 1, 11**n\n  while not ok(k*pow11): k += 1\n  return k\nprint([a(n) for n in range(62)]) \n"}
{"sequence_id": "A180136", "text": "Smallest k such that k*12^n is a sum of two successive primes.", "sequence": "5,1,1,2,18,8,13,6,2,11,11,39,20,12,1,8,9,31,182,24,2,126,128,66,9,86,146,43,170,49,155,119,115,21,77,18,60,5,119,81,27,45,81,23,28,134,14,262,131,86,55,7,549,81,199,107,100,184,85,80,32,43,118,299,43,224,187", "code": "\nfrom sympy import nextprime, prevprime\ndef sum2succ(n): return n == prevprime(n//2) + nextprime(n//2)\ndef a(n):\n  if n == 0: return 5\n  k, pow12 = 1, 12**n\n  while not sum2succ(k*pow12): k += 1\n  return k\nprint([a(n) for n in range(67)]) \n"}
{"sequence_id": "A180137", "text": "Smallest k such that k*13^n is a sum of two successive primes.", "sequence": "5,4,24,4,8,22,40,4,14,16,28,10,266,40,20,46,112,156,12,20,228,26,2,220,60,140,92,42,316,132,84,70,68,50,280,164,112,146,148,30,36,126,390,30,30,38,462,114,14,86,56,168,1600,224,104,8,72,434,142,60,750,202,318", "code": "\nfrom sympy import isprime, nextprime, prevprime\ndef ok(n):\n  if n <= 5: return n == 5\n  return not isprime(n//2) and n == prevprime(n//2) + nextprime(n//2)\ndef a(n):\n  k, pow13 = 1, 13**n\n  while not ok(k*pow13): k += 1\n  return k\nprint([a(n) for n in range(63)]) \n"}
{"sequence_id": "A180138", "text": "Table, t, read by antidiagonals: t(b,e) is the smallest k such that k*b^e is a sum of two successive primes.", "sequence": "5,5,4,5,4,2,5,2,2,1,5,1,7,6,7,5,2,4,2,2,4,5,6,1,10,9,10,2,5,1,18,1,2,8,20,1,5,2,2,10,4,8,2,26,9,5,3,2,15,30,12,12,25,22,15,5,18,1,20,2,18,2,12,11,10,8,5,1,6,6,22,19,4,1,36,6,16,4,5,4,1,24,6,16,6,28,4,12,10,8,2", "code": "\nfrom sympy import isprime, nextprime, prevprime\ndef sum2succ(n):\n  if n <= 5: return n == 5\n  return not isprime(n//2) and n == prevprime(n//2) + nextprime(n//2)\ndef T(b, e):\n  k, powb = 1, b**e\n  while not sum2succ(k*powb): k += 1\n  return k\ndef atodiag(maxd): \n  return [T(b-e, e) for b in range(2, maxd+2) for e in range(b-1)]\nprint(atodiag(13)) \n"}
{"sequence_id": "A180200", "text": "a(0)=0, a(1)=1; for n > 1, a(n) = 2*m + 1 - (n mod 2 + m mod 2) mod 2, where m = a(floor(n/2)).", "sequence": "0,1,2,3,5,4,6,7,10,11,9,8,13,12,14,15,21,20,22,23,18,19,17,16,26,27,25,24,29,28,30,31,42,43,41,40,45,44,46,47,37,36,38,39,34,35,33,32,53,52,54,55,50,51,49,48,58,59,57,56,61,60,62,63,85,84,86,87,82,83,81,80,90", "code": "\ndef a(n):\n....if n<2:return n\n....else:\n........m=a(n/2)\n........return 2*m + 1 - (n%2 + m%2)%2 \n"}
{"sequence_id": "A180301", "text": "Starting with 1, the next entry is the next higher integer whose spelling in US English comes lexicographically later.", "sequence": "1,2,200,201,202,2000,2001,2002,2200,2201,2202,2000000000000,2000000000001,2000000000002,2000000000200,2000000000201,2000000000202,2000000002000,2000000002001,2000000002002,2000000002200,2000000002201,2000000002202", "code": "\nfrom num2words import num2words\ndef n2w(n):\n    return num2words(n).replace(\" and\", \"\").replace(\",\", \"\")\ndef afind(limit, start=1):\n    last, t = start, start+1\n    print(start, end=\", \")\n    while t <= limit:\n        target = n2w(last)\n        while n2w(t) <= target:\n            t += 1\n            if t > limit: return\n        last = t\n        print(t, end=\", \")\nafind(3000) \n"}
{"sequence_id": "A180332", "text": "Primitive Zumkeller numbers.", "sequence": "6,20,28,70,88,104,272,304,368,464,496,550,572,650,836,945,1184,1312,1376,1430,1504,1575,1696,1870,1888,1952,2002,2090,2205,2210,2470,2530,2584,2990,3128,3190,3230,3410,3465,3496,3770,3944,4030,4070,4095,4216", "code": "\nfrom sympy import divisors\nfrom sympy.utilities.iterables import subsets\ndef isz(n): \n    divs = divisors(n)\n    s = sum(divs)\n    if not (s%2 == 0 and 2*n <= s): return False\n    S = s//2 - n\n    R = [m for m in divs if m <= S]\n    return any(sum(c) == S for c in subsets(R))\ndef ok(n): return isz(n) and not any(isz(d) for d in divisors(n)[:-1])\nprint(list(filter(ok, range(1, 5000)))) \n"}
{"sequence_id": "A180446", "text": "Number of non-pentagonal numbers <= n.", "sequence": "0,0,1,2,3,3,4,5,6,7,8,9,9,10,11,12,13,14,15,16,17,18,18,19,20,21,22,23,24,25,26,27,28,29,30,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,63,64,65,66", "code": " l = [n-floor((sqrt(24*n+1)+1)/6) for n in range(0,101)]\n"}
{"sequence_id": "A180447", "text": "n appears 3n+1 times.", "sequence": "0,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8", "code": " l = [floor((sqrt(24*n+1)+1)/6) for n in range(0,101)]\n"}
{"sequence_id": "A180481", "text": "The smallest prime q > p = prime(n) such that p*(q-p)+q, p*(q-p)-q, q*(q-p)+p and q*(q-p)-p are simultaneously prime, or 0 if no such q exists.", "sequence": "11,23,11,67,3119,19,941,739,29,41,79,127,5507,1399,191,56873,1193,16657,49411,30059,10453,373,719,18773,12277,1031,1489,131,823,1283,14251,317,10631,313,191,16987,70381,229,8447,3539,1019,3499,2777,301579,587,241,6229,229,11657,571,2969,701,1627,20327,467,2069,863", "code": "\nfrom sympy import prime, isprime\ndef A180481(n):\n....p = prime(n)\n....n += 1\n....q = prime(n)\n....while q < 10**14: \n........if isprime(p*(q-p)+q) and isprime(p*(q-p)-q) and isprime(q*(q-p)+p) and isprime(q*(q-p)-p):\n............return(q)\n........n += 1\n........q = prime(n)\n....return(0) \n\n"}
{"sequence_id": "A180484", "text": "Numbers n such that r*(n/k)^2 is an integer, where n=(x_1 x_2 ... x_r) with x_i the decimal digits of n and k = x_1 * x_2 * ... * x_r.", "sequence": "1,2,3,4,5,6,7,8,9,11,12,15,24,36,111,112,115,128,132,135,144,175,212,216,224,312,315,384,432,612,624,672,735,816,1111,1112,1113,1114,1115,1116,1121,1122,1124,1125,1127,1128,1131,1134,1144,1161,1164,1176,1184", "code": "\nfrom gmpy2 import t_mod, mpz\nfrom operator import mul\nfrom functools import reduce\nA180484 = [mpz(n) for n in (str(x) for x in range(1,10**9)) if not\n..........(n.count('0') or t_mod(mpz(n)**2*len(n),\n..........reduce(mul, (mpz(d) for d in n))**2))]\n\n"}
{"sequence_id": "A180582", "text": "Number of Hamiltonian cycles in C_6 X P_n.", "sequence": "1,8,86,776,7010,63674,578090,5247824,47640092,432480632,3926091512,35641352528,323554871864,2937255393440,26664624744320,242063463190976,2197470272854016,19948799940346880,181096701955896896,1644009442040416928,14924441010395894048,135485194778650515104", "code": "\n\nfrom graphillion import GraphSet\ndef make_CnXPk(n, k):\n    grids = []\n    for i in range(1, k + 1):\n        for j in range(1, n):\n            grids.append((i + (j - 1) * k, i + j * k))\n        grids.append((i + (n - 1) * k, i))\n    for i in range(1, k * n, k):\n        for j in range(1, k):\n            grids.append((i + j - 1, i + j))\n    return grids\ndef A180582(n):\n    universe = make_CnXPk(6, n)\n    GraphSet.set_universe(universe)\n    cycles = GraphSet.cycles(is_hamilton=True)\n    return cycles.len()\nprint([A180582(n) for n in range(1, 30)])  \n"}
{"sequence_id": "A180636", "text": "Positive integers that are divisible by neither 8k-1 nor 8k+1, for all k > 0.", "sequence": "1,2,3,4,5,6,8,10,11,12,13,16,19,20,22,24,26,29,32,37,38,40,43,44,48,52,53,58,59,61,64,67,74,76,80,83,86,88,96,101,104,106,107,109,116,118,122,128,131,134,139,148,149,152,157,160,163,166,172,173,176,179,181,192", "code": " \nimport itertools\nfor n in itertools.count(1):\n....for k in range(1,2+n//8):\n........if n%(8*k-1)==0 or n%(8*k+1)==0:\n............break\n....else:\n........print(n)\n"}
{"sequence_id": "A180646", "text": "Numbers k such that 3 + phi(k)^3 is prime, where phi is Euler's totient function.", "sequence": "3,4,5,6,8,10,12,17,23,32,34,40,46,48,51,53,60,64,68,80,85,96,101,102,106,107,120,125,128,136,159,160,167,170,191,192,202,204,212,213,214,235,240,249,250,267,281,284,318,319,321,332,334,339,345,355,356,368", "code": "\nfrom sympy import isprime, totient\nprint([n for n in range(1001) if isprime(3 + totient(n)**3)]) \n"}
{"sequence_id": "A180741", "text": "Numbers k such that 5^k + 3^k - 1 is prime.", "sequence": "1,3,9,39,165,11289", "code": "\nfrom sympy import isprime\ndef afind(limit, startk=1):\n    pow5, pow3 = 5**startk, 3**startk\n    for k in range(startk, limit+1):\n        if isprime(pow5 + pow3 - 1): print(k, end=\", \")\n        pow5 *= 5; pow3 *= 3\nafind(1000) \n"}
{"sequence_id": "A180857", "text": "Wiener index of the Moebius ladder M(n).", "sequence": "1,6,21,44,85,138,217,312,441,590,781,996,1261,1554,1905,2288,2737,3222,3781,4380,5061,5786,6601,7464,8425,9438,10557,11732,13021,14370,15841,17376,19041,20774,22645,24588,26677,28842,31161,33560,36121,38766", "code": "\ndef A180857(n):\n    return n*(-3-(-1)**n+4*n+2*n**2)//4 \n"}
{"sequence_id": "A180922", "text": "Smallest n-digit number that is divisible by exactly 3 primes (counted with multiplicity).", "sequence": "8,12,102,1001,10002,100006,1000002,10000005,100000006,1000000003,10000000001,100000000006,1000000000001,10000000000001,100000000000018,1000000000000002,10000000000000006,100000000000000007,1000000000000000001,10000000000000000007", "code": "\nfrom sympy import factorint\ndef triprimes(n): f = factorint(n); return sum(f[p] for p in f) == 3\ndef a(n):\n  an = max(1, 10**(n-1))\n  while not triprimes(an): an += 1\n  return an\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A180938", "text": "Smallest k such that k*n has an even number of 1's in its base-2 expansion.", "sequence": "3,3,1,3,1,1,9,3,1,1,3,1,3,9,1,3,1,1,3,1,3,3,1,1,3,3,1,9,1,1,33,3,1,1,3,1,3,3,1,1,3,3,1,3,1,1,3,1,3,3,1,3,1,1,3,9,1,1,3,1,3,33,1,3,1,1,3,1,3,3,1,1,3,3,1,3,1,1,3,1,3,3,1,3,1,1,5,3,1,1,5,1,11,3,1,1,3,3,1,3,1,1,9,3,1", "code": "\ndef a(n):\n    k=1\n    while True:\n        if not bin(k*n)[2:].count('1')%2: return k\n        k+=1\nprint([a(n) for n in range(1, 61)]) \n"}
{"sequence_id": "A180965", "text": "Number of tatami tilings of a 2 X n grid (with monomers allowed).", "sequence": "1,2,6,13,29,68,156,357,821,1886,4330,9945,22841,52456,120472,276681,635433,1459354,3351598,7697381,17678037,40599916,93242996,214144685,491811165,1129508406,2594063186,5957604017,13682413681,31423445328,72168035504,165743294353", "code": "\nfrom math import log\nprint(0,1)\nprint(1,2)\nprint(2,6)\nprint(3,13)\nn,a0,a1,a2,a3 = 3,13,6,2,1\nwhile log(a0)/log(10) < 1000:\n....n,a0,a1,a2,a3 = n+1,2*(a0+a2)-a3,a0,a1,a2\n....print(n,a0) \n"}
{"sequence_id": "A180975", "text": "Array of the \"egg-drop\" numbers, read by downwards antidiagonals.", "sequence": "1,1,2,1,3,3,1,3,6,4,1,3,7,10,5,1,3,7,14,15,6,1,3,7,15,25,21,7,1,3,7,15,30,41,28,8,1,3,7,15,31,56,63,36,9,1,3,7,15,31,62,98,92,45,10", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef T(n, k): return 0 if n*k == 0 else T(n-1, k-1) + 1 + T(n-1, k)\nprint([T(k, n-k) for n in range(1, 12) for k in range(1, n)]) \n"}
{"sequence_id": "A181134", "text": "Sum of 13th powers: a(n) = Sum_{j=0..n} j^13.", "sequence": "0,1,8193,1602516,68711380,1289414505,14350108521,111239118928,660994932816,3202860761145,13202860761145,47725572905076,154718778284148,457593884876401,1251308658130545,3197503726489920", "code": "\nA181134_list, m = [0], [6227020800, -37362124800, 97037740800, -142702560000, 130456085760, -76592355840, 28805736960, -6711344640, 901020120, -60780720, 1569750, -8190, 1, 0 , 0]\nfor _ in range(10**2):\n....for i in range(14):\n........m[i+1]+= m[i]\n....A181134_list.append(m[-1]) \n"}
{"sequence_id": "A181282", "text": "a(n) is the number of associate Rota-Baxter words in one idempotent generator x and one idempotent operator P of degree n. Such words are Rota-Baxter words that begin and/or ends with x, and P is applied n times in the word.", "sequence": "1,3,12,60,336,2016,12672,82368,549120,3734016,25798656,180590592,1278025728,9128755200,65727037440,476521021440,3475800391680,25489202872320,187815179059200,1389832325038080,10324468700282880", "code": "\nimport math\nf = math.factorial\ndef C(n,r): return f(n)/f(r)/f(n-r)\ndef A181282(n): return 1 if n==0 else 3*2**(n-1)*(C(2*n,n)/(n+1)) \n"}
{"sequence_id": "A181362", "text": "a(n) is the starting position of the n-th occurrence of n in the string 123456789101112131415161718192021... .", "sequence": "1,15,37,59,81,103,125,147,169,214,235,271,307,533,836,1139,1442,1745,2048,2651,541,708,978,1308,1608,1908,2208,2508,2808,4115,2684,3020,3424,3428,4232,4331,4375,4419,4463,6652,3229,4595,4639,4679,4719,4767", "code": "\ndef a(n):\n    \n    \n    full='~'+''.join(map(str,range(1,10000)))\n    def place(n,str_n,offset):\n        p=full[offset:].find(str_n)+offset\n        return p if n==1 else place(n-1,str_n,p+1)\n    return place(n,str(n),0)\n\nprint(', '.join(str(a(i)) for i in range(1,51)))\n"}
{"sequence_id": "A181373", "text": "Least m>0 such that prime(n) divides S(m)=A007908(m)=123...m and all numbers obtained by cyclic permutations of its digits; 0 if no such m exists.", "sequence": "0,2,0,100,106,120,196,102,542,400,181,21,216,372,10446,127,10086,616,399,1703,196,2009,118,12350,516,416,13244,884,15462,15146,106", "code": "\nfrom sympy import prime\ndef A181373(n):\n    s, p, l = '', prime(n), 0\n    for m in range(1,10**6):\n        u = str(m)\n        s += u\n        l += len(u)\n        t = s\n        if not int(t) % p:\n            for i in range(l-1):\n                t = t[1:]+t[0]\n                if int(t) % p:\n                    break\n            else:\n                return m\n    else:\n        return 'search limit reached.' \n"}
{"sequence_id": "A181391", "text": "Van Eck's sequence: For n >= 1, if there exists an m < n such that a(m) = a(n), take the largest such m and set a(n+1) = n-m; otherwise a(n+1) = 0. Start with a(1)=0.", "sequence": "0,0,1,0,2,0,2,2,1,6,0,5,0,2,6,5,4,0,5,3,0,3,2,9,0,4,9,3,6,14,0,6,3,5,15,0,5,3,5,2,17,0,6,11,0,3,8,0,3,3,1,42,0,5,15,20,0,4,32,0,3,11,18,0,4,7,0,3,7,3,2,31,0,6,31,3,6,3,2,8,33,0,9,56,0,3,8,7,19,0,5,37,0,3,8,8,1", "code": "\nA181391 = [0,0]\nfor n in range(1,10**4):\n    for m in range(n-1,-1,-1):\n        if A181391[m] == A181391[n]:\n            A181391.append(n-m)\n            break\n    else:\n        A181391.append(0) \n"}
{"sequence_id": "A181391", "text": "Van Eck's sequence: For n >= 1, if there exists an m < n such that a(m) = a(n), take the largest such m and set a(n+1) = n-m; otherwise a(n+1) = 0. Start with a(1)=0.", "sequence": "0,0,1,0,2,0,2,2,1,6,0,5,0,2,6,5,4,0,5,3,0,3,2,9,0,4,9,3,6,14,0,6,3,5,15,0,5,3,5,2,17,0,6,11,0,3,8,0,3,3,1,42,0,5,15,20,0,4,32,0,3,11,18,0,4,7,0,3,7,3,2,31,0,6,31,3,6,3,2,8,33,0,9,56,0,3,8,7,19,0,5,37,0,3,8,8,1", "code": "\nA181391 = [0]\nlast_pos = {}\nfor i in range(10**4):\n    new_value = i - last_pos.get(A181391[i], i)\n    A181391.append(new_value)\n    last_pos[A181391[i]] = i\n\n"}
{"sequence_id": "A181585", "text": "\"Early bird\" squares: write the square numbers in a string 149162536496481100... . Sequence gives numbers k such that k^2 occurs in the string ahead of its natural place.", "sequence": "7,8,21,25,46,97,129,161,196,221,245,258,277,296,350,436,460,592,661,694,789,804,875,877,1250,2025,2221,3500,3959,4020,5461,5920,7925,9607,12500,14772,19821,20010,21825,22011,22221,24012,25225,25375,25388,26013,28014", "code": "\ndef aupto(limit):\n    s, alst = \"\", []\n    for k in range(1, limit+1):\n        ss = str(k*k)\n        if ss in s: alst.append(k)\n        s += ss\n    return alst\nprint(aupto(28028)) \n"}
{"sequence_id": "A181666", "text": "Odd part of a(n) is of form (4^k-1)/3.", "sequence": "1,2,4,5,8,10,16,20,21,32,40,42,64,80,84,85,128,160,168,170,256,320,336,340,341,512,640,672,680,682,1024,1280,1344,1360,1364,1365,2048,2560,2688,2720,2728,2730,4096,5120,5376,5440,5456,5460,5461,8192,10240", "code": "\nfor a in range (2,17):\n  print()\n  for b in range(a-2,-1,-2):\n    print(((1<<a)-(1<<b))//3,end =\", \")\n\n"}
{"sequence_id": "A181709", "text": "Indices of primes in A007310.", "sequence": "2,3,4,5,6,7,8,10,11,13,14,15,16,18,20,21,23,24,25,27,28,30,33,34,35,36,37,38,43,44,46,47,50,51,53,55,56,58,60,61,64,65,66,67,71,75,76,77,78,80,81,84,86,88,90,91,93,94,95,98,103,104,105,106,111,113,116,117,118", "code": "\nfrom sympy import isprime\nout = \"\"\nfor n,p in enumerate(isprime((6*n+(-1)**n-3)//2) for n in range(1,1000)):\n    out+=[\"\",\"%s \"%str(n+1)][p]\nfor n,p in enumerate(out.rstrip(\" \").split(\" \")): print(n+1,p)\n"}
{"sequence_id": "A181718", "text": "a(n) = (1/9)*(10^(2*n) + 10^n - 2).", "sequence": "0,12,1122,111222,11112222,1111122222,111111222222,11111112222222,1111111122222222,111111111222222222,11111111112222222222,1111111111122222222222,111111111111222222222222,11111111111112222222222222,1111111111111122222222222222", "code": "\nfor n in range(30):\n    print((10**(2*n)+10**n-2)//9, end=', ')\n\n"}
{"sequence_id": "A181796", "text": "a(n) = number of divisors of n whose canonical prime factorizations contain no repeated positive exponents (cf. A130091).", "sequence": "1,2,2,3,2,3,2,4,3,3,2,5,2,3,3,5,2,5,2,5,3,3,2,7,3,3,4,5,2,4,2,6,3,3,3,7,2,3,3,7,2,4,2,5,5,3,2,9,3,5,3,5,2,7,3,7,3,3,2,7,2,3,5,7,3,4,2,5,3,4,2,10,2,3,5,5,3,4,2,9,5,3,2,7,3,3,3,7,2,7,3,5,3,3,3,11,2,5,5,7,2,4,2,7,4", "code": "\nfrom sympy import factorint, divisors\ndef ok(n):\n    f=factorint(n)\n    ex=[f[i] for i in f]\n    for i in ex:\n        if ex.count(i)>1: return 0\n    return 1\ndef a(n): return sum([1 for i in divisors(n) if ok(i)]) \n"}
{"sequence_id": "A181811", "text": "a(n) = smallest integer that, upon multiplying any divisor of n, produces a member of A025487.", "sequence": "1,1,2,1,6,2,30,1,4,6,210,2,2310,30,12,1,30030,4,510510,6,60,210,9699690,2,36,2310,8,30,223092870,12,6469693230,1,420,30030,180,4,200560490130,510510,4620,6,7420738134810,60,304250263527210,210,24,9699690", "code": "\nfrom sympy import primerange, factorint\nfrom operator import mul\nfrom functools import reduce\ndef P(n): return reduce(mul, [i for i in primerange(2, n + 1)])\ndef a(n):\n    f = factorint(n)\n    return 1 if n==1 else (reduce(mul, [P(i)**f[i] for i in f]))//n\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A181812", "text": "Range of values of A181811, in order of first appearance: a(n) = A181811(2n-1).", "sequence": "1,2,6,30,4,210,2310,12,30030,510510,60,9699690,36,8,223092870,6469693230,420,180,200560490130,4620,7420738134810,304250263527210,24,13082761331670030,900,60060,614889782588491410,1260,1021020,32589158477190044730", "code": "\nfrom sympy import primerange, factorint\nfrom operator import mul\ndef P(n): return reduce(mul, [i for i in primerange(2, n + 1)])\ndef a181811(n):\n    f = factorint(n)\n    return 1 if n==1 else (reduce(mul, [P(i)**f[i] for i in f]))/n\ndef a(n): return a181811(2*n - 1) \n"}
{"sequence_id": "A181940", "text": "a(0)=0, and there are a(n) terms between a(n) and the nearest a(n)+1.", "sequence": "0,1,0,2,0,1,3,1,0,2,4,2,0,1,3,5,3,1,0,2,4,6,4,2,0,1,3,5,7,5,3,1,0,2,4,6,8,6,4,2,0,1,3,5,7,9,7,5,3,1,0,2,4,6,8,10,8,6,4,2,0,1,3,5,7,9,11,9,7,5,3,1,0,2,4,6,8,10,12,10,8,6,4,2,0,1,3,5,7,9,11,13,11,9,7,5,3,1,0,2,4,6,8,10,12", "code": "\ndef T(num_rows):\n    L, R = [0], [0]\n    for n in range(1, num_rows):\n        R.reverse()\n        R.insert(0, n)\n        L.extend(R)\n    return L\nprint(T(14)) \n"}
{"sequence_id": "A181957", "text": "Smallest positive integer which cannot be calculated by an expression containing n binary operators (either add or multiply) whose operands are integers between 1 and 9; parenthesis allowed.", "sequence": "10,19,92,239,829,2831,10061,38231,189311,621791,2853533,11423579", "code": "\ndef aupton(nn):\n    alst = [10]\n    R = {0: set(range(1, 10))}   \n    for n in range(1, nn):\n        R[n] = set()\n        for i in range((n+1)//2):\n            for a in R[i]:\n                for b in R[n-1-i]:\n                    R[n].update([a+b, a*b])\n        k = 10\n        while k in R[n]: k += 1  \n        alst.append(k)\n    return alst\nprint(aupton(9)) \n"}
{"sequence_id": "A181965", "text": "a(n) = 10^(2n+1) - 10^n - 1.", "sequence": "8,989,99899,9998999,999989999,99999899999,9999998999999,999999989999999,99999999899999999,9999999998999999999,999999999989999999999,99999999999899999999999,9999999999998999999999999,999999999999989999999999999,99999999999999899999999999999,9999999999999998999999999999999", "code": " def A181965(n): return 10**(n*2+1)-1-10^n \n"}
{"sequence_id": "A181988", "text": "If n is odd, a(n) = (n+1)/2; if n is even, a(n) = a(n/2) + A003602(n).", "sequence": "1,2,2,3,3,4,4,4,5,6,6,6,7,8,8,5,9,10,10,9,11,12,12,8,13,14,14,12,15,16,16,6,17,18,18,15,19,20,20,12,21,22,22,18,23,24,24,10,25,26,26,21,27,28,28,16,29,30,30,24,31,32,32,7,33,34,34,27,35,36", "code": "\nfrom itertools import count\ndef interleave(A):\n    A1=next(A)\n    A2=interleave(A)\n    while True:\n        yield next(A1)\n        yield next(A2)\ndef multiples(k):\n    return (k*i for i in count(1))\ninterleave(multiples(k) for k in count(1))\n(Scheme, with memoization-macro definec)\n(definec (A181988 n) (if (even? n) (+ (A003602 n) (A181988 (/ n 2))) (A003602 n)))\n;; _Antti Karttunen_, Jan 19 2016\n"}
{"sequence_id": "A182134", "text": "Number of primes p such that prime(n) < p < prime(n)^(1 + 1/n).", "sequence": "1,1,1,1,2,2,2,1,2,2,2,3,3,2,2,3,4,3,4,3,3,2,2,4,5,4,3,2,2,2,3,4,4,3,4,4,4,4,3,4,5,4,4,3,2,2,4,5,5,4,4,4,3,5,6,5,5,4,3,3,2,4,4,4,3,2,5,5,5,5,5,5,5,5,5,4,4,4,4,5,6,5,7,6,6,5,5,5,5,4,4,5,4,5,4,3,3,3,3,5,5,5,5,6,5", "code": "\nfrom sympy import primepi, prime\ndef a(n): return primepi(prime(n)**(1 + 1/n)) - n \n"}
{"sequence_id": "A182182", "text": "a(0) = 0, a(1) = 1; for n > 1, a(n) = a(n-1) XOR a(n-2) XOR n.", "sequence": "0,1,3,1,6,2,2,7,13,3,4,12,4,5,15,5,26,14,6,27,9,7,24,8,8,25,11,9,30,10,10,31,53,11,28,52,12,29,55,13,18,54,14,19,49,15,16,48,16,17,51,17,22,50,18,23,61,19,20,60,20,21,63,21,106,62,22,107,57", "code": "\nprpr = 0\nprev = 1\nprint('0,1', end=',')\nfor i in range(2,101):\n    current = prev ^ prpr ^ i\n    print(current, end=\",\")\n    prpr = prev\n    prev = current\n"}
{"sequence_id": "A182187", "text": "a(n) is the least m >= n such that the Hamming distance D(n,m) = 2.", "sequence": "3,2,4,5,7,6,10,11,11,10,12,13,15,14,22,23,19,18,20,21,23,22,26,27,27,26,28,29,31,30,46,47,35,34,36,37,39,38,42,43,43,42,44,45,47,46,54,55,51,50,52,53,55,54,58,59,59,58,60,61,63,62,94,95,67,66,68", "code": "\ndef a(n):\n  m = n + 1\n  while bin(n^m).count('1') != 2: m += 1\n  return m\nprint([a(n) for n in range(67)]) \n"}
{"sequence_id": "A182209", "text": "a(n) is the least m >= n, such that the Hamming distance D(n,m) = 3.", "sequence": "7,6,5,4,9,8,8,9,15,14,13,12,16,17,18,19,23,22,21,20,25,24,24,25,31,30,29,28,36,37,38,39,39,38,37,36,41,40,40,41,47,46,45,44,48,49,50,51,55,54,53,52,57,56,56,57,63,62,61,60,76,77,78,79,71,70,69", "code": "\ndef d(n, m): return bin(n^m).count('1')\ndef a(n):\n    m = n+1\n    while d(n, m) != 3: m += 1\n    return m\nprint([a(n) for n in range(67)]) \n"}
{"sequence_id": "A182212", "text": "Floor(n! / Fibonacci(n)).", "sequence": "1,2,3,8,24,90,387,1920,10672,65978,448503,3326400,26725411,231242151,2143728472,21198368680,222722246772,2477698802526,29094738198716,359630747697951,4667544506825273,63463425429259086,902118740233973431,13380961044971520000", "code": "\nprpr = 0\nprev = 1\nfa = 1\nfor i in range(2,26):\n    print(fa//prev, end=',')\n    fa *= i\n    current = prev + prpr\n    prpr = prev\n    prev = current\n"}
{"sequence_id": "A182213", "text": "a(n) = n! mod Fibonacci(n).", "sequence": "0,0,0,0,0,0,9,0,32,10,33,0,37,273,80,840,1116,816,404,1485,1742,7854,27833,0,49100,37681,66606,85839,222482,656920,1335931,417165,362268,3309347,1266460,976752,20352231,19601527,4303068,8848455,136897669,254107048", "code": "\nprpr = 0\nprev = 1\nfa = 1\nfor i in range(2,50):\n    print(fa % prev, end=',')\n    fa *= i\n    current = prev + prpr\n    prpr = prev\n    prev = current\n"}
{"sequence_id": "A182228", "text": "a(n) = 3*a(n-2) - a(n-1) for n > 1, a(0) = 0, a(1) = 1.", "sequence": "0,1,-1,4,-7,19,-40,97,-217,508,-1159,2683,-6160,14209,-32689,75316,-173383,399331,-919480,2117473,-4875913,11228332,-25856071,59541067,-137109280,315732481,-727060321,1674257764,-3855438727,8878212019,-20444528200,47079164257,-108412748857", "code": "\nprpr = 0\nprev = 1\nfor i in range(2,55):\n    current = prpr*3-prev\n    print (current, end=',')\n    prpr = prev\n    prev = current\n"}
{"sequence_id": "A182229", "text": "a(n) = a(n-1) + floor(a(n-2)/3) with a(0)=2, a(1)=3.", "sequence": "2,3,3,4,5,6,7,9,11,14,17,21,26,33,41,52,65,82,103,130,164,207,261,330,417,527,666,841,1063,1343,1697,2144,2709,3423,4326,5467,6909,8731,11034,13944,17622,22270,28144,35567,44948,56803,71785,90719,114647,144886,183101", "code": "\nprpr = 2\nprev = 3\nfor i in range(2,51):\n    current = prev + prpr//3\n    print(current, end=',')\n    prpr = prev\n    prev = current\n"}
{"sequence_id": "A182230", "text": "a(n) = a(n-1)+floor(a(n-2)/4) with a(0)=3, a(1)=4.", "sequence": "3,4,4,5,6,7,8,9,11,13,15,18,21,25,30,36,43,52,62,75,90,108,130,157,189,228,275,332,400,483,583,703,848,1023,1235,1490,1798,2170,2619,3161,3815,4605,5558,6709,8098,9775,11799,14242,17191,20751,25048,30235", "code": "\nprpr = 3\nprev = 4\nfor i in range(2,55):\n    current = prev + prpr//4\n    print(current, end=',')\n    prpr = prev\n    prev = current\n"}
{"sequence_id": "A182242", "text": "a(0)=0, a(n) = (a(n-1) + n) AND n.", "sequence": "0,1,2,1,4,1,6,5,8,1,10,1,12,9,6,5,16,1,18,1,20,1,22,5,24,17,10,1,28,25,22,21,32,1,34,1,36,1,38,5,40,1,42,1,44,9,38,5,48,33,18,1,52,33,22,5,56,49,42,33,28,25,22,21,64,1,66,1,68,1,70,5,72,1", "code": "\na=0\nfor i in range(1,511):\n    print(a, end=',')\n    a += i\n    a &= i\n"}
{"sequence_id": "A182243", "text": "a(0)=0, a(n) = (a(n-1) AND n) + n.", "sequence": "0,1,2,5,8,5,10,9,16,9,18,13,24,21,18,17,32,17,34,21,40,21,42,25,48,41,34,29,56,53,50,49,64,33,66,37,72,37,74,41,80,41,82,45,88,53,82,49,96,81,66,53,104,85,74,57,112,105,98,93,88,85,82,81,128,65", "code": "\na=0\nfor i in range(1,511):\n    print(a, end=',')\n    a &= i\n    a += i\n"}
{"sequence_id": "A182247", "text": "a(0)=0, a(n) = (a(n-1) + n) OR n.", "sequence": "0,1,3,7,15,21,31,39,47,57,75,95,111,125,143,159,191,209,243,279,319,341,383,407,447,473,507,543,575,605,639,671,703,737,803,871,943,1013,1087,1127,1199,1273,1323,1407,1455,1533", "code": "\na=0\nfor i in range(1,51):\n    print(a, end=',')\n    a += i\n    a |= i\n"}
{"sequence_id": "A182248", "text": "a(0)=0, a(n) = (a(n-1) OR n) + n.", "sequence": "0,2,4,10,18,28,36,46,54,72,84,106,122,140,156,174,206,240,260,298,338,364,404,430,470,504,532,570,602,636,668,702,734,800,836,906,978,1052,1124,1166,1238,1320,1364,1450,1498,1580", "code": "\na=0\nfor i in range(1,51):\n    print(a, end=',')\n    a |= i\n    a += i\n"}
{"sequence_id": "A182249", "text": "a(0)=0, a(n) = (a(n-1) * n) OR n.", "sequence": "0,1,2,7,28,141,846,5927,47416,426745,4267450,46941951,563303420,7322944461,102521222462,1537818336943,24605093391088,418286587648497,7529158577672946,143054012975785975,2861080259515719516", "code": "\na=0\nfor i in range(1,51):\n    print(a, end=',')\n    a *= i\n    a |= i\n"}
{"sequence_id": "A182250", "text": "a(0)=2, a(n) = (a(n-1) * n) OR n.", "sequence": "2,3,6,19,76,381,2286,16007,128056,1152505,11525050,126775551,1521306620,19776986061,276877804862,4153167072943,66450673167088,1129661443840497,20333905989128946,386344213793449975,7726884275868999516", "code": "\na=2\nfor i in range(1,51):\n    print(a, end=',')\n    a *= i\n    a |= i\n"}
{"sequence_id": "A182251", "text": "a(0)=0, a(n) = (a(n-1) OR n) * n.", "sequence": "0,1,6,21,84,425,2586,18137,145096,1305873,13058830,143647141,1723765788,22408955257,313725373682,4705880605425,75294089686800,1279999524675617,23039991444161430,437759837439067189,8755196748781343780", "code": "\na=0\nfor i in range(1,51):\n. print a,\n. a |= i\n. a *= i\n"}
{"sequence_id": "A182252", "text": "a(0)=4, a(n) = (a(n-1) OR n) * n.", "sequence": "4,5,14,45,180,905,5466,38297,306376,2757393,27574030,303314341,3639772188,47317038457,662438538482,9936578077425,158985249238800,2702749237059617,48649486267073430,924340239074395189,18486804781487903780", "code": "\na=4\nfor i in range(1,51):\n. print a,\n. a |= i\n. a *= i\n"}
{"sequence_id": "A182305", "text": "a(n+1) = a(n) + floor(a(n)/4) with a(0)=4.", "sequence": "4,5,6,7,8,10,12,15,18,22,27,33,41,51,63,78,97,121,151,188,235,293,366,457,571,713,891,1113,1391,1738,2172,2715,3393,4241,5301,6626,8282,10352,12940,16175,20218,25272,31590,39487", "code": "\na=4\nfor i in range(55):\n   print(a, end=',')\n   a += a//4\n"}
{"sequence_id": "A182306", "text": "a(n+1) = a(n) + floor(a(n)/5) with a(0)=5.", "sequence": "5,6,7,8,9,10,12,14,16,19,22,26,31,37,44,52,62,74,88,105,126,151,181,217,260,312,374,448,537,644,772,926,1111,1333,1599,1918,2301,2761,3313,3975,4770,5724,6868,8241,9889,11866,14239,17086,20503,24603,29523,35427,42512", "code": "\na=5\nfor i in range(55):\n. print a,\n. a += a/5\n"}
{"sequence_id": "A182307", "text": "a(n+1) = a(n) + floor(a(n)/6) with a(0)=6.", "sequence": "6,7,8,9,10,11,12,14,16,18,21,24,28,32,37,43,50,58,67,78,91,106,123,143,166,193,225,262,305,355,414,483,563,656,765,892,1040,1213,1415,1650,1925,2245,2619,3055,3564,4158,4851,5659,6602,7702,8985,10482,12229,14267,16644", "code": "\na=6\nfor i in range(55):\n. print a,\n. a += a/6\n"}
{"sequence_id": "A182308", "text": "a(n+1) = a(n) + floor(a(n)/7) with a(0)=7", "sequence": "7,8,9,10,11,12,13,14,16,18,20,22,25,28,32,36,41,46,52,59,67,76,86,98,112,128,146,166,189,216,246,281,321,366,418,477,545,622,710,811,926,1058,1209,1381,1578,1803,2060,2354,2690,3074,3513,4014,4587,5242,5990", "code": "\na=7\nfor i in range(55):\n    print(a, end=',')\n    a += a//7\n"}
{"sequence_id": "A182361", "text": "a(n+1) = a(n) + floor(a(n)/8) with a(0)=8.", "sequence": "8,9,10,11,12,13,14,15,16,18,20,22,24,27,30,33,37,41,46,51,57,64,72,81,91,102,114,128,144,162,182,204,229,257,289,325,365,410,461,518,582,654,735,826,929,1045,1175,1321,1486,1671,1879,2113,2377,2674,3008", "code": "\na=8\nfor i in range(55):\n. print a,\n. a += a/8\n"}
{"sequence_id": "A182362", "text": "a(n+1) = a(n) + floor(a(n)/9) with a(0)=9.", "sequence": "9,10,11,12,13,14,15,16,17,18,20,22,24,26,28,31,34,37,41,45,50,55,61,67,74,82,91,101,112,124,137,152,168,186,206,228,253,281,312,346,384,426,473,525,583,647,718,797,885,983,1092,1213,1347,1496,1662,1846", "code": "\na=9\nfor i in range(55):\n. print a,\n. a += a/9\n"}
{"sequence_id": "A182363", "text": "a(n+1) = a(n) + floor(a(n)/10) with a(0)=10.", "sequence": "10,11,12,13,14,15,16,17,18,19,20,22,24,26,28,30,33,36,39,42,46,50,55,60,66,72,79,86,94,103,113,124,136,149,163,179,196,215,236,259,284,312,343,377,414,455,500,550,605,665,731,804,884,972,1069,1175,1292", "code": "\na=10\nfor i in range(55):\n. print a,\n. a += a/10\n"}
{"sequence_id": "A182388", "text": "a(0)=1, a(n) = (a(n-1) XOR n) + n.", "sequence": "1,1,5,9,17,25,37,41,41,41,45,49,73,81,109,113,113,113,117,121,129,169,213,217,217,217,221,225,281,289,349,353,353,353,357,361,369,377,389,457,521,585,653,721,809,817,845,913,977,1041,1109,1177,1249", "code": "\na=1\nfor i in range(1,55):\n. print a,\n. a ^= i\n. a += i\n"}
{"sequence_id": "A182389", "text": "a(0)=1, a(n) = (a(n-1) + n) XOR n.", "sequence": "1,3,7,9,9,11,23,25,41,59,79,81,81,83,111,113,145,179,215,249,281,315,327,329,377,395,447,449,449,451,511,513,513,515,519,521,521,523,535,537,617,699,719,721,721,723,815,881,913,1011,1047,1145", "code": "\na=1\nfor i in range(1,55):\n    print(a, end=',')\n    a += i\n    a ^= i\n"}
{"sequence_id": "A182390", "text": "a(0)=0, a(n) = (a(n-1) * n) XOR n.", "sequence": "0,1,0,3,8,45,264,1855,14832,133497,1334960,14684571,176214856,2290793125,32071103752,481066556279,7697064900448,130850103307633,2355301859537376,44750735331210163,895014706624203240,18795308839108268061,413496794460381897320", "code": "\na=0\nfor i in range(1,55):\n. print a,\n. a *= i\n. a ^= i\n"}
{"sequence_id": "A182420", "text": "a(0)=0, a(n) = (a(n-1) XOR n) * n.", "sequence": "0,1,6,15,44,205,1218,8547,68440,615897,6158910,67747911,812974980,10568674805,147961447354,2219421710235,35510747363504,603682705179313,10866288693227382,206459485171319935,4129189703426398300,86712983771954363901", "code": "\na=0\nfor i in range(1,55):\n. print a,\n. a ^= i\n. a *= i\n"}
{"sequence_id": "A182437", "text": "a(0)=0, a(n) = (a(n-1) XOR n) * (n+1).", "sequence": "0,2,0,12,40,270,1848,14840,133488,1334970,14684560,176214852,2290793128,32071103750,481066556280,7697064900464,130850103307616,2355301859537394,44750735331210144,895014706624203260,18795308839108268040,413496794460381897342", "code": "\na=0\nfor i in range(1,55):\n  print a,\n  a ^= i\n  a *= i+1\n"}
{"sequence_id": "A182442", "text": "a(0)=0, a(1)=1, for n>1, a(n) = a(n-1)*2 + floor(a(n-2)/n).", "sequence": "0,1,2,4,8,16,33,68,140,287,588,1202,2453,4998,10171,20675,41985,85186,172704,349891,708417,1433495,2899190,5860705,11842209,23918846,48293161,97472205,196669165,396699440,799954518,1612705792,3250410162", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,99):\n.  current = prev*2 + prpr//n\n.  print prpr,\n.  prpr = prev\n.  prev = current\n"}
{"sequence_id": "A182443", "text": "a(0)=0, a(1)=1, for n>1, a(n) = floor(a(n-1)/n) + a(n-2)*2.", "sequence": "0,1,0,2,0,4,0,8,1,16,3,32,8,64,20,129,48,260,110,525,246,1061,540,2145,1169,4336,2504,8764,5321,17711,11232,35784,23582,72282,49289,145972,102632,294717,213019,594896,440910,1200545,910404,2422262,1875859", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,99):\n.  current = prev//n + prpr*2\n.  print prpr,\n.  prpr = prev\n.  prev = current\n"}
{"sequence_id": "A182444", "text": "a(0)=0, a(1)=1, for n>1, a(n) = a(n-1) + (a(n-2) mod n).", "sequence": "0,1,1,2,3,5,8,13,13,17,20,26,34,34,40,44,52,62,78,83,101,121,134,140,154,169,193,200,225,251,266,269,279,284,291,295,298,334,366,388,394,413,429,455,488,493,521,544,585,590,625,654,655,673,680,693", "code": "\nprpr = 0\nprev = 1\nfor i in range(2,99):\n.  current = prev + (prpr % i)\n.  print prpr,\n.  prpr = prev\n.  prev = current\n"}
{"sequence_id": "A182445", "text": "a(0)=0, a(1)=1, for n>1, a(n) = a(n-2) + (a(n-1) mod n).", "sequence": "0,1,1,2,3,5,8,6,14,11,15,15,18,20,24,29,37,32,51,45,56,59,71,61,84,70,102,91,109,113,132,121,157,146,167,173,196,184,228,217,245,257,250,292,278,300,302,320,334,360,344,398,378,405,405,425,438,464,438", "code": "\nprpr = 0\nprev = 1\nfor i in range(2,99):\n.  current = prpr + (prev % i)\n.  print prpr,\n.  prpr = prev\n.  prev = current\n"}
{"sequence_id": "A182455", "text": "a(0)=1, a(n) = (a(n-1) mod (n+2))*(n+2).", "sequence": "1,3,12,10,24,21,40,36,60,55,84,78,112,105,144,136,180,171,220,210,264,253,312,300,364,351,420,406,480,465,544,528,612,595,684,666,760,741,840,820,924,903,1012,990,1104,1081,1200,1176,1300,1275,1404", "code": "\na=1\nfor n in range(1,55):\n. print a,\n. a = (a%(n+2)) * (n+2)\n"}
{"sequence_id": "A182456", "text": "a(0)=1; for n>0, a(n) = ( a(n-1) mod (n+3) )*(n+3).", "sequence": "1,4,20,12,35,24,54,40,77,60,104,84,135,112,170,144,209,180,252,220,299,264,350,312,405,364,464,420,527,480,594,544,665,612,740,684,819,760,902,840,989,924,1080,1012,1175,1104,1274,1200,1377,1300,1484", "code": "\na=1\nfor n in range(1, 55):\n    print(a, end=\",\")\n    a = (a%(n+3)) * (n+3)\n"}
{"sequence_id": "A182457", "text": "a(0)=0, a(1)=1, a(n) = (a(n-2)*a(n-1)+1) mod n.", "sequence": "0,1,1,2,3,2,1,3,4,4,7,7,2,2,5,11,8,4,15,4,1,5,6,8,1,9,10,10,17,26,23,10,7,5,2,11,23,32,15,13,36,18,19,42,7,25,38,11,35,43,6,4,25,48,13,20,37,0,1,1,2,3,7,22,27,10,7,4,29,48,63,43,46,8", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,77):\n.  current = ( prev*prpr + 1 ) % n\n.  print prpr,\n.  prpr = prev\n.  prev = current\n"}
{"sequence_id": "A182458", "text": "a(0)=1, a(1)=2, a(n) = (a(n-2)*a(n-1)+1) mod n.", "sequence": "1,2,1,0,1,1,2,3,7,4,9,4,1,5,6,1,7,8,3,6,19,10,15,13,4,3,13,13,2,27,25,25,18,22,23,17,32,27,29,4,37,26,39,26,3,34,11,46,27,18,37,4,45,22,19,34,31,29,30,45,31,54,1,55,56,26,5,64,49,32,29,6", "code": "\nprpr = 1\nprev = 2\nfor n in range(2,77):\n    current = ( prev*prpr + 1 ) % n\n    print(prpr, end=',')\n    prpr = prev\n    prev = current\n"}
{"sequence_id": "A182469", "text": "Triangle read by rows in which row n lists the odd divisors of n.", "sequence": "1,1,1,3,1,1,5,1,3,1,7,1,1,3,9,1,5,1,11,1,3,1,13,1,7,1,3,5,15,1,1,17,1,3,9,1,19,1,5,1,3,7,21,1,11,1,23,1,3,1,5,25,1,13,1,3,9,27,1,7,1,29,1,3,5,15,1,31,1,1,3,11,33,1,17,1,5,7,35,1", "code": "\nfrom sympy import divisors\ndef row(n):\n    return [d for d in divisors(n) if d % 2]\nfor n in range(1, 21): print(row(n)) \n"}
{"sequence_id": "A182491", "text": "T(n,k), a triangular array read by rows, is the Wiener index for the complete bipartite graph K(n,k).", "sequence": "1,4,8,9,14,21,16,22,30,40,25,32,41,52,65,36,44,54,66,80,96,49,58,69,82,97,114,133,64,74,86,100,116,134,154,176,81,92,105,120,137,156,177,200,225,100,112,126,142,160,180,202,226,252,280,121,134,149,166,185,206,229,254,281,310,341", "code": "\ni=1\nfor n in range(1,101):\n....for k in range(1,n+1):\n........print str(i)+\" \"+str(n*k + n*(n-1) + k*(k-1))\n........i+=1 \n"}
{"sequence_id": "A182505", "text": "a(0)=0, a(1)=1, a(n) = ( (a(n-1)+a(n-2)) AND n) + n.", "sequence": "0,1,2,6,4,5,6,10,8,9,10,14,20,13,14,26,16,17,18,22,20,21,22,26,40,25,26,46,36,45,46,58,64,65,34,70,68,37,70,74,40,73,74,46,84,45,46,58,80,49,50,86,52,53,86,58,72,57,58,110,100,77,110,122,128,129", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,99):\n  current = n + ((prpr + prev) & n)\n  print prpr,\n  prpr = prev\n  prev = current\n"}
{"sequence_id": "A182506", "text": "a(0)=0, a(1)=1, a(n) = ( (a(n-1)+a(n-2)) XOR n) + n.", "sequence": "0,1,5,8,13,21,42,63,105,170,291,465,772,1253,2037,3300,5337,8637,13974,22611,36625,59270,95895,155169,251064,406233,657317,1063552,1720917,2784485,4505410,7289943,11795417,19085362,30880843,49966209,80847116,130813389,211660581", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,99):\n  current = n + ((prpr + prev) ^ n)\n  print prpr,\n  prpr = prev\n  prev = current\n"}
{"sequence_id": "A182508", "text": "a(0)=0, a(1)=1, a(n) = (a(n-2)+a(n-1)+n) AND n.", "sequence": "0,1,2,2,0,5,2,6,0,9,2,2,0,13,10,6,0,17,2,2,16,5,2,22,16,25,2,18,16,29,10,6,32,1,2,34,0,5,34,6,0,41,2,2,32,13,10,6,0,49,34,2,16,5,2,54,48,25,2,18,16,29,42,6,64,1,2,66,0,5,66,6", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,99):\n  current = (prpr + prev + n) & n\n  print prpr,\n  prpr = prev\n  prev = current\n"}
{"sequence_id": "A182509", "text": "a(0)=0, a(1)=1, a(n)=(a(n-1) XOR n) + a(n-2).", "sequence": "0,1,3,1,8,14,16,37,61,89,144,244,392,633,1023,1641,2680,4306,6968,11261,18209,29489,47688,77200,124880,202073,326931,528993,855952,1384942,2240896,3625869,5866797,9492633,15359464,24852068,40211496,65063537,105275007", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,99):\n  current = (prev ^ n) + prpr\n  print prpr,\n  prpr = prev\n  prev = current\n"}
{"sequence_id": "A182510", "text": "a(0)=0, a(1)=1, a(n)=(a(n-1) XOR n) - a(n-2).", "sequence": "0,1,3,-1,-8,-2,0,9,1,-1,-12,0,24,21,3,-9,-28,-2,8,29,1,-9,-32,0,56,33,3,-9,-24,-2,-8,-23,-47,7,84,112,0,-75,-109,-1,68,110,0,-67,-111,-1,64,112,0,-63,-13,-1,-40,-18,0,73,113,-1,-172,-144,-8,85,115", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,99):\n  current = (prev ^ n) - prpr\n  print prpr,\n  prpr = prev\n  prev = current\n"}
{"sequence_id": "A182511", "text": "a(0)=1, a(1)=2, a(n) = (a(n-2)*a(n-1) mod n) + 1.", "sequence": "1,2,1,3,4,3,1,4,5,3,6,8,1,9,10,1,11,12,7,9,4,16,21,15,4,11,19,21,8,24,13,3,8,25,31,6,7,6,5,31,36,10,25,36,21,37,42,4,25,3,26,28,1,29,30,46,37,50,53,55,36,29,53,26,35,1,36,37,41,69,30,12,1", "code": "\nprpr = 1\nprev = 2\nfor n in range(2,99):\n  current = (prpr * prev) % n + 1\n  print prpr,\n  prpr = prev\n  prev = current\n"}
{"sequence_id": "A182536", "text": "a(0)=0, a(1)=1, a(n)=(a(n-1) XOR a(n-2)) + n.", "sequence": "0,1,3,5,10,20,36,55,27,53,56,24,44,65,123,73,66,28,112,127,35,113,104,48,112,89,67,53,146,196,116,207,219,53,272,328,124,345,331,57,410,460,128,375,547,897,464,640,896,305,739,1029,1818,852,1156,2055,3259,1269,2184,3256,1132,2321,3515,1257,2450,3516,1136,2575", "code": "\nprpr, prev = 0,1\nfor n in range(2,99):\n.  current = (prpr ^ prev) + n\n.  print prpr,\n.  prpr, prev = prev, current\n"}
{"sequence_id": "A182537", "text": "a(0)=0, a(1)=1, a(n) = a(n-1) + (a(n-2) XOR n).", "sequence": "0,1,3,5,12,12,22,33,63,103,156,264,408,669,1075,1733,2792,4540,7350,11877,19207,31095,50312,81384,131704,213097,344779,557885,902676,1460532,2363198,3823721,6186887,10010575,16197492,26208096,42405552,68613621,111019147,179632733", "code": "\nprpr, prev = 0, 1\nfor n in range(2, 99):\n.  current = prev + (prpr ^ n)\n.  print prpr,\n.  prpr, prev = prev, current\n"}
{"sequence_id": "A182538", "text": "a(n) = (a(n-1) AND a(n-2)) + n.", "sequence": "0,1,2,3,6,7,12,11,16,9,10,19,14,15,28,27,40,25,26,43,30,31,52,43,56,65,26,27,54,47,68,35,32,65,34,35,70,39,44,75,48,41,74,51,46,79,60,59,104,89,122,139,62,63,116,107,152,65,58,59,118,111,164,99,96,161,98,99,166,103", "code": "\nprpr, prev = 0,1\nfor n in range(2,99):\n.  current = (prpr & prev) + n\n.  print prpr,\n.  prpr, prev = prev, current\n"}
{"sequence_id": "A182539", "text": "a(n) = a(n-1) + (a(n-2) AND n).", "sequence": "0,1,1,2,2,2,4,6,6,6,8,10,18,26,28,38,54,54,72,90,90,106,124,126,150,174,192,202,202,210,220,238,238,270,304,306,338,370,372,406,438,438,472,506,514,554,556,598,630,646,696,698,746,794,828,846,902,910,912,922,938,962,1004,1006,1070", "code": "\nprpr, prev = 0,1\nfor n in range(2,99):\n.  current = prev + (prpr & n)\n.  print prpr,\n.  prpr, prev = prev, current\n"}
{"sequence_id": "A182556", "text": "a(0)=1, a(n+1) = (a(n)*6) XOR a(n).", "sequence": "1,7,45,291,2033,10327,55901,377971,2580161,13329991,68092909,475337827,3047910961,21335374615,108342024605,611555770419,4227169747201,22855656310535,114836769975597,592467546841635,4147130288467697,24449879086004055,171122765320764253", "code": "\na=1\nfor n in range(55):\n. print a,\n. a ^= a*6\n"}
{"sequence_id": "A182557", "text": "a(n) = a(n-1)*2 + floor(sqrt(a(n-2))).", "sequence": "0,1,2,5,11,24,51,106,219,448,910,1841,3712,7466,14992,30070,60262,120697,241639,483625,967741,1936177,3873337,7748065,15498098,30998979,62001894,124009355,248026584,496064303,992144354,1984310980,3968653458,7937351461,15874765919", "code": "\nimport math\nprpr = 0\nprev = 1\nfor n in range(55):\n.  current = prev*2 + int(math.sqrt(prpr))\n.  print prpr,\n.  prpr = prev\n.  prev = current\n"}
{"sequence_id": "A182558", "text": "a(n) = a(n-1)*2 - floor(sqrt(a(n-2))).", "sequence": "0,1,2,3,5,9,16,29,54,103,199,388,762,1505,2983,5928,11802,23528,46948,93743,187270,374234,748036,1495461,2990058,5978894,11956059,23909673,47815889,95626889,191246864,382483950,764954071,1529888585,3059749513", "code": "\nimport math\nprpr = 0\nprev = 1\nfor n in range(55):\n.  current = prev*2 - int(math.sqrt(prpr))\n.  print prpr,\n.  prpr = prev\n.  prev = current\n"}
{"sequence_id": "A182559", "text": "a(n) = a(n-2)*2 + floor(sqrt(a(n-1))).", "sequence": "0,1,1,3,3,7,8,16,20,36,46,78,100,166,212,346,442,713,910,1456,1858,2955,3770,5971,7617,12029,15343,24181,30841,48537,61902,97322,124115,194996,248671,390490,497966,781685,996816,1564368,1994882,3130148,3991533,6262293", "code": "\nimport math\nprpr = 0\nprev = 1\nfor n in range(55):\n.  current = prpr*2 + int(math.sqrt(prev))\n.  print prpr,\n.  prpr = prev\n.  prev = current\n"}
{"sequence_id": "A182560", "text": "a(n) = (a(n-1) AND a(n-2)) XOR n.", "sequence": "0,1,2,3,6,7,0,7,8,9,2,11,14,7,8,15,24,25,10,27,30,15,24,31,0,25,26,3,30,31,0,31,32,33,2,35,38,7,32,39,8,41,34,11,46,39,8,47,56,25,42,59,30,47,56,31,32,57,26,35,62,31,32,63,96,97,34,99,102,39,96,103", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,55):\n.  current = (prev & prpr) ^ n\n.  print prpr,\n.  prpr = prev\n.  prev = current\n"}
{"sequence_id": "A182577", "text": "Number of ones in Zeckendorf representation of n!", "sequence": "1,1,1,2,2,4,3,5,6,9,8,11,11,11,16,17,17,18,23,23,28,31,33,27,33,29,40,37,42,42,41,44,47,44,53,56,57,50,64,55,59,68,63,72,70,61,69,85,80,83,87,97,98,101,87,91,100,102,114,108,116,109,117,117,113,124", "code": "\nfrom math import factorial\ndef A182577(n):\n    m, tlist, s = factorial(n), [1,2], 0\n    while tlist[-1]+tlist[-2] <= m:\n        tlist.append(tlist[-1]+tlist[-2])\n    for d in tlist[::-1]:\n        if d <= m:\n            s += 1\n            m -= d\n    return s \n"}
{"sequence_id": "A182578", "text": "Number of ones in Zeckendorf representation of n^n.", "sequence": "1,1,2,3,3,6,3,10,13,12,16,15,20,24,20,30,25,31,26,33,33,31,34,42,49,49,53,55,56,55,58,64,64,67,73,78,70,76,77,75,89,83,92,90,106,99,100,99,107,116,107,115,125,125,122,119,127,137,127,138,155,156,153,160", "code": "\ndef A182578(n):\n    m, tlist, s = n**n, [1,2], 0\n    while tlist[-1]+tlist[-2] <= m:\n        tlist.append(tlist[-1]+tlist[-2])\n    for d in tlist[::-1]:\n        if d <= m:\n            s += 1\n            m -= d\n    return s \n"}
{"sequence_id": "A182622", "text": "a(n) is the number whose binary representation is the concatenation of the divisors of n written in base 2.", "sequence": "1,6,7,52,13,222,15,840,121,858,27,28268,29,894,991,26896,49,113970,51,215892,2037,3446,55,14471576,441,3514,3899,217052,61,14538238,63,1721376,7905,13410,7139,926213284,101,13542,8039,221009192", "code": "\ndef A182622(n):\n....s=\"\"\n....for i in range(1,n+1):\n........if n%i==0:\n............s+=bin(i)[2:]\n....return int(s,2) \n"}
{"sequence_id": "A182648", "text": "a(n) is the largest n-digit number with exactly 4 divisors.", "sequence": "8,95,998,9998,99998,999997,9999998,99999997,999999991,9999999997,99999999997,999999999997,9999999999989,99999999999997,999999999999998,9999999999999994,99999999999999989,999999999999999993,9999999999999999991,99999999999999999983", "code": "\nfrom sympy import divisors\ndef a(n):\n    k = 10**n - 1\n    divs = -1\n    while divs != 4:\n      k -= 1\n      divs = 0\n      for d in divisors(k, generator=True):\n        divs += 1\n        if divs > 4: break\n    return k\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A182705", "text": "Row sums of triangle A182701.", "sequence": "1,4,12,28,60,114,210,360,603,970,1529,2340,3536,5222,7620,10944,15555,21816,30343,41740,56994,77132,103684,138312,183450,241696,316764,412776,535340,690750,887499,1135072,1446060,1834742,2319555,2921616,3667921,4589260", "code": "\nfrom sympy import npartitions as p\ndef a000070(n): return sum([p(k) for k in range(n + 1)])\ndef a(n): return n*a000070(n - 1) \n"}
{"sequence_id": "A182754", "text": "a(1) = 1, a(2) = 21, a(n) = 77*a(n-2) for n>=3.", "sequence": "1,21,77,1617,5929,124509,456533,9587193,35153041,738213861,2706784157,56842467297,208422380089,4376869981869,16048523266853,337018988603913,1235736291547681,25950462122501301,95151694449171437,1998185583432600177,7326680472586200649", "code": "\ndef aupton(nn):\n  dmo = [1, 21, 77]\n  for n in range(3, nn+1): dmo.append(77*dmo[-2])\n  return dmo[:nn]\nprint(aupton(21)) \n"}
{"sequence_id": "A182910", "text": "Number of unitary prime divisors of the swinging factorial (A056040) n$ = n! / floor(n/2)!^2.", "sequence": "0,0,1,2,2,3,1,2,3,3,1,2,3,4,3,3,4,5,4,5,4,6,5,6,5,5,4,4,3,4,5,6,7,8,6,6,7,8,7,7,8,9,9,10,9,7,6,7,7,7,7,8,7,8,8,10,11,13,12,13,11,12,11,10,11,13,12,13", "code": "\nfrom sympy import factorint, factorial\ndef a056169(n): return 0 if n==1 else sum(1 for i in factorint(n).values() if i==1)\ndef a056040(n): return factorial(n)//factorial(n//2)**2\ndef a(n): return a056169(a056040(n))\nprint([a(n) for n in range(68)]) \n"}
{"sequence_id": "A183041", "text": "Least number of knight's moves from (0,0) to (n,1) on infinite chessboard.", "sequence": "3,2,1,2,3,4,3,4,5,6,5,6,7,8,7,8,9,10,9,10,11,12,11,12,13,14,13,14,15,16,15,16,17,18,17,18,19,20,19,20,21,22,21,22,23,24,23,24,25,26,25,26,27,28,27,28,29,30,29,30,31,32,31,32,33,34,33,34,35,36", "code": "\ndef a(n):\n  if n < 2: return [3, 2][n]\n  m, r = divmod(n, 4)\n  return [2*m+1, 2*m+2][r%2]\nprint([a(n) for n in range(70)]) \n"}
{"sequence_id": "A183109", "text": "Triangle read by rows: T(n,m) = number of n X m binary matrices with no zero rows or columns (n >= 1, 1 <= m <= n).", "sequence": "1,1,7,1,25,265,1,79,2161,41503,1,241,16081,693601,24997921,1,727,115465,10924399,831719761,57366997447,1,2185,816985,167578321,26666530801,3776451407065,505874809287625", "code": "\nimport math\nf = math.factorial\ndef C(n,r): return f(n)//f(r)//f(n - r)\ndef T(n,m):\n    return sum((-1)**j*C(m,j)*(2**(m - j) - 1)**n for j in range (m+1))\ni=1\nfor n in range(1,21):\n    for m in range(1, n+1):\n        print(str(i)+\" \"+str(T(n, m)))\n        i+=1 \n"}
{"sequence_id": "A183132", "text": "Successive integers produced by Conway's PRIMEGAME using Kilminster's Fractran program with only nine fractions.", "sequence": "10,5,36,858,234,5577,1521,3549,8281,910,100,50,25,180,3388,924,252,6006,1638,39039,10647,24843,57967,6370,700,300,7150,1950,46475,12675,29575,3250,360,6776,1848,504,12012,3276,78078,21294,507507,138411,322959,753571", "code": "\nfrom fractions import Fraction\nnums = [ 3, 847, 143, 7, 10, 3,  36, 1, 36]\ndens = [11,  45,   6, 3, 91, 7, 325, 2,  5]\nPRIMEGAME = [Fraction(num, den) for num, den in zip(nums, dens)]\ndef succ(n, program):\n    for i in range(len(program)):\n      if (n*program[i]).denominator == 1: return (n*program[i]).numerator\ndef orbit(start, program, steps):\n    orb = [start]\n    for s in range(1, steps): orb.append(succ(orb[-1], program))\n    return orb\nprint(orbit(10, PRIMEGAME, steps=44)) \n"}
{"sequence_id": "A183209", "text": "Tree generated by floor(3n/2): a(1) = 1, a(2n) = (3*a(n))-1, a(2n+1) = floor((3*a(n+1))/2).", "sequence": "1,2,3,5,4,8,7,14,6,11,12,23,10,20,21,41,9,17,16,32,18,35,34,68,15,29,30,59,31,62,61,122,13,26,25,50,24,47,48,95,27,53,52,104,51,101,102,203,22,44,43,86,45,89,88,176,46,92,93,185,91,182,183,365,19,38,39,77,37", "code": "\ndef a(n):\n    if n==1: return 1\n    if n%2==0: return 3*a(n//2) - 1\n    else: return (3*a((n - 1)//2 + 1))//2\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A184337", "text": "a(n) is the integer whose decimal representation consists of n 8's followed by n 1's.", "sequence": "0,81,8811,888111,88881111,8888811111,888888111111,88888881111111,8888888811111111,888888888111111111,88888888881111111111,8888888888811111111111,888888888888111111111111,88888888888881111111111111", "code": "\nfor n in range(30):\n    print((8*100**n-7*10**n-1)//9, end=', ')\n\n"}
{"sequence_id": "A184392", "text": "a(n) is the product of palindromic divisors of n.", "sequence": "1,2,3,8,5,36,7,64,27,10,11,144,1,14,15,64,1,324,1,40,21,484,1,1152,5,2,27,56,1,180,1,64,1089,2,35,1296,1,2,3,320,1,252,1,85184,135,2,1,1152,7,10,3,8,1,324,3025,448,3,2,1,720,1,2,189,64,5,18974736,1,8,3,70,1,10368,1,2,15,8,5929,36,1,320,27,2,1,1008,5,2,3,59969536,1,1620,7,8,3,2,5,1152,1,14,970299,40", "code": "\ndef ispal(n):\n    return n==int(str(n)[::-1])\ndef A184392(n):\n    s=1\n    for i in range(1, n+1):\n        if n%i==0 and ispal(i):\n             s*=i\n    return s \n"}
{"sequence_id": "A184617", "text": "With nonadjacent forms: A184615(n) + A184616(n).", "sequence": "0,1,2,5,4,5,10,9,8,9,10,21,20,21,18,17,16,17,18,21,20,21,42,41,40,41,42,37,36,37,34,33,32,33,34,37,36,37,42,41,40,41,42,85,84,85,82,81,80,81,82,85,84,85,74,73,72,73,74,69,68,69,66,65,64,65,66,69,68,69,74,73,72,73,74,85,84,85,82,81,80,81,82", "code": "\nfor n in range(77):\n  print((n^(n*3))/2, end=',')\n\n"}
{"sequence_id": "A185008", "text": "Next semiprime after 10*n.", "sequence": "4,14,21,33,46,51,62,74,82,91,106,111,121,133,141,155,161,177,183,194,201,213,221,235,247,253,262,274,287,291,301,314,321,334,341,355,361,371,381,391,403,411,422,437,445,451,466,471,481,493,501,511,526,533", "code": "\nfrom sympy.ntheory.factor_ import primeomega\ndef nextsemiprime(n):\n  while primeomega(n + 1) != 2: n += 1\n  return n + 1\ndef a(n): return nextsemiprime(10*n)\nprint([a(n) for n in range(54)]) \n"}
{"sequence_id": "A185173", "text": "Minimum number of distinct sums from consecutive terms in a circular permutation.", "sequence": "1,3,6,9,13,17,22,28,35,41,49,57,65,73,82,93", "code": "\nfrom itertools import permutations\ndef A185173(n):\n    c = n*(n+1)//2\n    for i in range(2,n+1):\n        for j in range(i+1,n+1):\n            pset = set(range(2,n+1)) - {i,j}\n            for p in permutations(pset):\n                q, rset, rl = [j,1,i]+list(p), set(), 0\n                for k in range(n):\n                    r = 0\n                    for l in range(n):\n                        r += q[(k+l) % n]\n                        if r not in rset:\n                            rset.add(r)\n                            rl += 1\n                        if rl >= c:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    c = rl\n    return c \n"}
{"sequence_id": "A185180", "text": "Enumeration table T(n,k) by antidiagonals. The order of the list is symmetrical movement from center to edges diagonal.", "sequence": "1,2,3,5,4,6,9,7,8,10,14,12,11,13,15,20,18,16,17,19,21,27,25,23,22,24,26,28,35,33,31,29,30,32,34,36,44,42,40,38,37,39,41,43,45,54,52,50,48,46,47,49,51,53,55,65,63,61,59,57,56,58,60,62,64,66,77,75", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nif j<=i:\n   m=(i*(i+1) + (j-1)*(j+2*i-4))/2\nelse:\n   m=(i*(i+1) + (j-1)*(j+2*i-4))/2 +2*(j-i)-1\n"}
{"sequence_id": "A185267", "text": "Smallest palindrome beginning with n-th prime.", "sequence": "2,3,5,7,11,131,171,191,232,292,313,373,414,434,474,535,595,616,676,717,737,797,838,898,979,101,10301,10701,10901,11311,12721,131,13731,13931,14941,151,15751,16361,16761,17371,17971,181,191,19391,19791,1991,2112,22322", "code": "\nfrom sympy import prime\ndef A185267(n):\n    p = prime(n)\n    s = str(p)\n    if s == s[::-1]:\n        return p\n    for i in range(1,len(s)):\n        if s[i:] == s[-1:i-1:-1]:\n            return int(s+s[i-1::-1]) \n"}
{"sequence_id": "A185333", "text": "Number of binary necklaces of n beads for which a cut exists producing a palindrome.", "sequence": "2,2,4,3,8,6,16,9,32,20,64,34,128,72,256,129,512,272,1024,516,2048,1056,4096,2050,8192,4160,16384,8200,32768,16512,65536,32769,131072,65792,262144,131088,524288,262656,1048576,524292,2097152", "code": "\ndef a(n):\n    if n%2: return 2**((n + 1)//2)\n    k=bin(n - 1)[2:].count('1') - bin(n)[2:].count('1')\n    return 2**(n//2 - 1) + 2**((n//2 - 2**k)//(2**(k + 1)))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A185358", "text": "The period of the sequence i^i (mod n) starts from i=a(n).", "sequence": "1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,5,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,5,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,3,4,1,1,1", "code": "\nfrom sympy import factorint, floor\ndef a(n):\n    f=factorint(n)\n    return 1 if n==1 else max(1 - i*(1 + (-f[i])//i) for i in f)\nprint([a(n) for n in range(1, 201)]) \n"}
{"sequence_id": "A185376", "text": "Number of binary necklaces of 2n beads for which a cut exists producing a palindrome.", "sequence": "2,3,6,9,20,34,72,129,272,516,1056,2050,4160,8200,16512,32769,65792,131088,262656,524292,1049600,2097184,4196352,8388610,16781312,33554496,67117056,134217736,268451840,536871040,1073774592,2147483649", "code": "\ndef a185333(n):\n    if n%2: return 2**((n + 1)//2)\n    k=bin(n - 1)[2:].count('1') - bin(n)[2:].count('1')\n    return 2**(n//2 - 1) + 2**((n//2 - 2**k)//(2**(k + 1)))\ndef a(n): return a185333(2*n)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A185457", "text": "a(n) = abs( Im((2+i)^(2^n)) ).", "sequence": "1,4,24,336,354144,116749235904,22940770664883067253376,182503181432559739767250904458105698387204864", "code": "\nfrom sympy import im, I\ndef a(n): return abs(im((2 + I)**(2**n)))\nprint([a(n) for n in range(11)]) \n"}
{"sequence_id": "A185635", "text": "Fixed points of A075075.", "sequence": "1,2,8,36,39,49,370,626,632,1030,13155,32317,61358,86704,2535431,13360009", "code": "\nfrom __future__ import division\nfrom fractions import gcd\nA185635_list, l1, l2, m, b = [1,2], 2, 1, 2, {1,2}\nfor n in range(3,10**4):\n....i = m\n....while True:\n........if not i in b:\n............if n == i:\n................A185635_list.append(i)\n............l1, l2, m = i, l1, i//gcd(l1,i)\n............b.add(i)\n............break\n........i += m \n"}
{"sequence_id": "A185670", "text": "Number of pairs (x,y) with 1 <= x < y <= n with at least one common factor.", "sequence": "0,0,0,1,1,4,4,7,9,14,14,21,21,28,34,41,41,52,52,63,71,82,82,97,101,114,122,137,137,158,158,173,185,202,212,235,235,254,268,291,291,320,320,343,363,386,386,417,423,452,470,497,497,532,546,577,597,626,626,669,669,700,726,757,773,818,818,853,877,922,922,969,969,1006,1040", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A185670(n): \n    if n == 0:\n        return 0\n    c, j = 2, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(k1*(k1-1)+1-2*A185670(k1))\n        j, k1 = j2, n//j2\n    return (c-j)//2 \n"}
{"sequence_id": "A185690", "text": "Exponential Riordan array (1,sin(x)).", "sequence": "1,0,1,-1,0,1,0,-4,0,1,1,0,-10,0,1,0,16,0,-20,0,1,-1,0,91,0,-35,0,1,0,-64,0,336,0,-56,0,1,1,0,-820,0,966,0,-84,0,1,0,256,0,-5440,0,2352,0,-120,0,1,-1,0,7381,0,-24970,0,5082,0,-165,0,1,0,-1024,0,87296,0,-90112,0,10032,0,-220,0,1", "code": "\nfrom sympy import binomial, factorial as f, floor\ndef T(n, k):\n    return 0 if (n - k)%2 else 2**(1 - k)*sum([(-1)**((n + k)//2 - i)*binomial(k, i)*(2*i - k)**n for i in range(k//2 + 1)])//f(k)\nfor n in range(1, 11): print([T(n, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A185695", "text": "Final prime adjoined in the smallest term of A019518 divisible by 61^n.", "sequence": "23,41719,308537,270907253,28643801327", "code": "\nfrom sympy import nextprime\ndef A185695(n):\n    p, k, m = 2, 61**n, 10\n    q, m2 = p % k, m % k\n    while True:\n        p = nextprime(p)\n        while p >= m:\n            m *= 10\n            m2 = m % k\n        q = (q*m2 + p) % k\n        if q == 0:\n            return p \n"}
{"sequence_id": "A185698", "text": "Final prime adjoined in the smallest term of A019518 divisible by 67^n.", "sequence": "37,37,14123267,47321411,5664619381", "code": "\nfrom sympy import nextprime\ndef A185698(n):\n    p, k, m = 2, 67**n, 10\n    q, m2 = p % k, m % k\n    while True:\n        p = nextprime(p)\n        while p >= m:\n            m *= 10\n            m2 = m % k\n        q = (q*m2 + p) % k\n        if q == 0:\n            return p \n"}
{"sequence_id": "A185704", "text": "Final prime adjoined in the smallest term of A019518 divisible by 73^n.", "sequence": "593,23909,4851169,84821071,13231167673", "code": "\nfrom sympy import nextprime\ndef A185704(n):\n    p, k, m = 2, 73**n, 10\n    q, m2 = p % k, m % k\n    while True:\n        p = nextprime(p)\n        while p >= m:\n            m *= 10\n            m2 = m % k\n        q = (q*m2 + p) % k\n        if q == 0:\n            return p \n"}
{"sequence_id": "A185826", "text": "Sum of the next n natural numbers raised to the n-th power.", "sequence": "1,25,3375,1336336,1160290625,1870414552161,5026507568359375,20882706457600000000,126834469112674289266929,1078732544346879404306640625,12415028528548173886807771291871,188031682201497672618081000000000000", "code": "\nnum = 100\nn = 0\na = range(num+1)\nfor i in range(1, num):\n....sum = 0\n....for j in range(1, i+1):\n........sum = sum + (n+j)\n....n = n + i\n....a[i] = sum**i\n"}
{"sequence_id": "A185949", "text": "Smallest prime ending in 10^n+1 in its base-10 representation.", "sequence": "11,101,21001,1810001,2100001,61000001,2010000001,11100000001,61000000001,1810000000001,14100000000001,151000000000001,5010000000000001,9100000000000001,271000000000000001,1110000000000000001,24100000000000000001,261000000000000000001,3910000000000000000001,11100000000000000000001", "code": "\nfrom sympy import isprime as is_prime\n\n\nfor n in range (1, 100):\n    pattern = 10**n + 1\n    for j in range (0, 10000000):\n        if (j == 0):\n            num = \"%d\" % (pattern)\n        else:\n            num = \"%d%d\" % (j, pattern)\n        if (is_prime(num)):\n            print(num)\n            break\n"}
{"sequence_id": "A186021", "text": "a(n) = Bell(n)*(2 - 0^n).", "sequence": "1,2,4,10,30,104,406,1754,8280,42294,231950,1357140,8427194,55288874,381798644,2765917090,20960284294,165729739608,1364153612318,11665484410114,103448316470744,949739632313502,9013431476894646,88304011710168692,891917738589610578,9277180664459998706", "code": "\nfrom itertools import accumulate\ndef A186021_list(size):\n    if size < 1: return []\n    L, accu = [1], [2]\n    for _ in range(size-1):\n        accu = list(accumulate([accu[-1]] + accu))\n        L.append(accu[0])\n    return L\nprint(A186021_list(26)) \n"}
{"sequence_id": "A186142", "text": "a(n) is the smallest suffix such that the numbers with k digits \"9\" prepended are primes for k = 1, 2, ..., n.", "sequence": "7,7,29,907,32207,573217,3136717,4128253,2181953771,2181953771,2181953771", "code": "\nfrom sympy import isprime\ndef a(n, startfrom=1):\n  an = startfrom + (1 - startfrom%2)\n  while not all(isprime(int(\"9\"*k+str(an))) for k in range(1, n+1)): an+=2\n  return an\ndef afind(nn):\n  an = 1\n  for n in range(1, nn+1): an = a(n, startfrom=an); print(an, end=\", \")\nafind(8) \n"}
{"sequence_id": "A186245", "text": "a(n) = binomial(n^2, 2*n).", "sequence": "1,84,12870,3268760,1251677700,675248872536,488526937079580,456703981505085600,535983370403809682970,771629762387959506903300,1337261858854117218288723600,2746379593275133584459064976784,6596095888094645606758451183394760", "code": "\nimport math\nfor n in range(2,22):\n    x = n*n\n    y = n+n\n    print(math.factorial(x) / (math.factorial(x-y) * math.factorial(y)), end=',')\n"}
{"sequence_id": "A186266", "text": "Expansion of 2F1( 1/2, 3/2; 4; 16*x ).", "sequence": "1,3,18,140,1260,12474,132132,1472328,17065620,204155380,2506399896,31443925968,401783498480,5215458874500,68633685693000,914099013896400,12304253831789700,167193096184907100,2291164651422801000,31637804708163654000,439903041116118980400", "code": "\nimport math\nf=math.factorial\ndef C(n,r): return f(n) / f(r) / f(n-r)\ndef Catalan(n): return C(2*n, n) / (n+1)\ndef A186266(n): return 3 * Catalan(n) * Catalan(n+1) * (n+1) / (n+3) \n"}
{"sequence_id": "A186439", "text": "Numbers whose squares end in three identical digits.", "sequence": "38,100,200,300,400,462,500,538,600,700,800,900,962,1000,1038,1100,1200,1300,1400,1462,1500,1538,1600,1700,1800,1900,1962,2000,2038,2100,2200,2300,2400,2462,2500,2538,2600,2700,2800,2900,2962,3000,3038,3100,3200,3300,3400,3462", "code": "\ndef ok(n): s = str(n*n); return len(s) > 2 and s[-1] == s[-2] == s[-3]\nprint(list(filter(ok, range(3463)))) \n"}
{"sequence_id": "A186774", "text": "Smallest power of n whose decimal expansion contains n+1, or 0 if no such number.", "sequence": "32,243,256,625,7776,16807,4096,31381059609,0,121,79496847203390844133441536,51185893014090757,155568095557812224,22168378200531005859375,17592186044416,118587876497,11019960576,42052983462257059", "code": "\ndef A186774(n):\n    if sum(int(d) for d in str(n)) == 1:\n        return 0\n    sn, k = str(n+1), 1\n    while sn not in str(k):\n        k *= n\n    return k \n"}
{"sequence_id": "A187093", "text": "a(0)=0, a(1)=a(2)=1; thereafter, a(n+1) = n^2 - a(n-1).", "sequence": "0,1,1,3,8,13,17,23,32,41,49,59,72,85,97,111,128,145,161,179,200,221,241,263,288,313,337,363,392,421,449,479,512,545,577,611,648,685,721,759,800,841,881,923,968,1013,1057,1103,1152,1201,1249,1299,1352,1405,1457", "code": "\nprint(0, end=',')       \nprpr = prev = 1         \nfor n in range(2, 77):\n    print(prpr, end=',')\n    curr = n*n - prpr   \n    prpr = prev\n    prev = curr\n\n"}
{"sequence_id": "A187220", "text": "Gullwing sequence (see Comments lines for precise definition).", "sequence": "0,1,3,7,15,23,31,47,71,87,95,111,135,159,191,247,311,343,351,367,391,415,447,503,567,607,639,695,767,847,967,1143,1303,1367,1375,1391,1415,1439,1471,1527,1591,1631,1663,1719,1791,1871,1991,2167,2327,2399,2431", "code": "\ndef msb(n):\n    t=0\n    while n>>t>0: t+=1\n    return 2**(t - 1)\ndef a139250(n):\n    k=(2*msb(n)**2 + 1)//3\n    return 0 if n==0 else k if n==msb(n) else k + 2*a139250(n - msb(n)) + a139250(n - msb(n) + 1) - 1\ndef a(n): return 0 if n==0 else 1 + 2*a139250(n - 1)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A187338", "text": "a(n) = 3*n + floor(sqrt(2)*n), complement of A187328.", "sequence": "4,8,13,17,22,26,30,35,39,44,48,52,57,61,66,70,75,79,83,88,92,97,101,105,110,114,119,123,128,132,136,141,145,150,154,158,163,167,172,176,180,185,189,194,198,203,207,211,216,220,225,229,233,238,242,247,251,256,260,264,269,273,278,282,286,291,295,300", "code": "\nfrom sympy import integer_nthroot\ndef A187338(n): return 3*n+integer_nthroot(2*n**2,2)[0] \n"}
{"sequence_id": "A187393", "text": "a(n) = floor(r*n), where r = 4 + sqrt(8); complement of A187394.", "sequence": "6,13,20,27,34,40,47,54,61,68,75,81,88,95,102,109,116,122,129,136,143,150,157,163,170,177,184,191,198,204,211,218,225,232,238,245,252,259,266,273,279,286,293,300,307,314,320,327,334,341,348,355,361,368,375,382,389,396,402,409,416,423,430,437,443,450,457,464,471,477", "code": "\nfrom sympy import integer_nthroot\ndef A187393(n): return 4*n+integer_nthroot(8*n**2,2)[0] \n"}
{"sequence_id": "A187394", "text": "a(n) = floor(s*n), where s = 4 - sqrt(8); complement of A187393.", "sequence": "1,2,3,4,5,7,8,9,10,11,12,14,15,16,17,18,19,21,22,23,24,25,26,28,29,30,31,32,33,35,36,37,38,39,41,42,43,44,45,46,48,49,50,51,52,53,55,56,57,58,59,60,62,63,64,65,66,67,69,70,71,72,73,74,76,77,78,79,80,82,83,84,85,86,87,89,90,91,92,93,94,96,97,98,99,100,101,103,104,105,106,107,108,110,111,112,113,114,115,117", "code": "\nfrom sympy import integer_nthroot\ndef A187394(n): return 4*n-1-integer_nthroot(8*n**2,2)[0] \n"}
{"sequence_id": "A187395", "text": "a(n) = floor(r*n), where r = 4 + sqrt(10); complement of A187396.", "sequence": "7,14,21,28,35,42,50,57,64,71,78,85,93,100,107,114,121,128,136,143,150,157,164,171,179,186,193,200,207,214,222,229,236,243,250,257,265,272,279,286,293,300,307,315,322,329,336,343,350,358,365,372,379,386,393,401,408,415,422,429,436,444,451,458,465,472,479,487,494,501", "code": "\nfrom sympy import integer_nthroot\ndef A187395(n): return 4*n+integer_nthroot(10*n**2,2)[0] \n"}
{"sequence_id": "A187396", "text": "a(n) = floor(s*n), where s =-2 + sqrt(10); complement of A187395.", "sequence": "1,2,3,4,5,6,8,9,10,11,12,13,15,16,17,18,19,20,22,23,24,25,26,27,29,30,31,32,33,34,36,37,38,39,40,41,43,44,45,46,47,48,49,51,52,53,54,55,56,58,59,60,61,62,63,65,66,67,68,69,70,72,73,74,75,76,77,79,80,81,82,83,84,86,87,88,89,90,91,92,94,95,96,97,98,99,101,102,103,104,105,106,108,109,110,111,112,113,115,116", "code": "\nfrom sympy import integer_nthroot\ndef A187396(n): return integer_nthroot(10*n**2,2)[0]-2*n \n"}
{"sequence_id": "A187584", "text": "Least number divisible by at least n of its digits, different and > 1.", "sequence": "2,24,248,2364,27384,243768,23469768,1234759680", "code": "\ndef c(n): return len(set(d for d in str(n) if d>'1' and n%int(d)==0))\ndef a(n):\n  m = 2*10**(n-1)\n  while c(m) < n: m += 1\n  return m\nprint([a(n) for n in range(1, 7)]) \n"}
{"sequence_id": "A187715", "text": "a(n) = 5*n - (9 + (-1)^n)/2.", "sequence": "1,5,11,15,21,25,31,35,41,45,51,55,61,65,71,75,81,85,91,95,101,105,111,115,121,125,131,135,141,145,151,155,161,165,171,175,181,185,191,195,201,205,211,215,221,225", "code": " for n in range(1,60): print(int(5*n - (9 + (-1)**n)/2), end=', ') \n"}
{"sequence_id": "A187751", "text": "n^(n!) mod (n!)^n.", "sequence": "0,0,0,81,225280,7991790625,1078848154238976,65180706714634067542224001,1650157594512930366268925848349310976,66807065275536807794426016376688705273224158387201", "code": "\nimport math\nfor n in range(12):\n  f = math.factorial(n)\n  print (n**f) % (f**n),\n"}
{"sequence_id": "A187760", "text": "Table T(n,k) read by antidiagonals. T(n,k)=n-k+1, if n>=k, T(n,k)=k-n+2, if n < k.", "sequence": "1,3,2,4,1,3,5,3,2,4,6,4,1,3,5,7,5,3,2,4,6,8,6,4,1,3,5,7,9,7,5,3,2,4,6,8,10,8,6,4,1,3,5,7,9,11,9,7,5,3,2,4,6,8,10,12,10,8,6,4,1,3,5,7,9,11", "code": "\nt=int((math.sqrt(8*n-7)-1)/2)\nresult=abs((t+1)**2 - 2*n) + 3*int((t**2+3*t+2-2*n)/(t+1))\n"}
{"sequence_id": "A187761", "text": "Number of maps f: [n] -> [n] with f(x)<=x and f(f(x)) = f(f(f(x))).", "sequence": "1,1,2,6,23,106,568,3459,23544,176850,1451253,12904312,123489888,1264591561,13790277294,159466823794,1948259002647,25066729706582,338670605492700,4792623436607059,70873649458154500,1092969062435462254,17543703470388927229,292600906102204630092", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, h): return 1 if min(n, h)==0 else sum([binomial(n - 1, j - 1)*b(j - 1, h - 1)*b(n - j, h) for j in range(1, n + 1)])\ndef a(n): return b(n, 2)\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A187765", "text": "The (n-1)th decimal place of the fractional part of the square root of n.", "sequence": "0,4,3,0,0,8,1,1,0,0,3,3,3,9,1,0,5,4,2,8,8,5,4,6,0,1,2,7,5,0,8,7,2,3,0,0,2,2,7,9,4,0,6,0,7,3,0,4,0,7,3,2,4,8,8,6,9,0,7,4,3,5,7,0,2,3,3,9,8,7,5,7,9,6,4,6,3,4,9,5,0,3,5,0,7,0,2", "code": "\nfor n in range(1,16):\n    x=str(n**0.5)\n    for i in range(n):\n        x=x+\"0\"\n    if n==1:\n        r=str(x[-1])\n    else:\n        r=r+\",\"+str(x[n])\n    if n==15:\n        print(r)\n"}
{"sequence_id": "A187795", "text": "Sum of the abundant divisors of n.", "sequence": "0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,18,0,20,0,0,0,36,0,0,0,0,0,30,0,0,0,0,0,66,0,0,0,60,0,42,0,0,0,0,0,84,0,0,0,0,0,72,0,56,0,0,0,122,0,0,0,0,0,66,0,0,0,70,0,162,0,0,0,0,0,78,0,140,0,0,0,138,0,0,0,88,0,138,0,0,0,0,0,180", "code": "\nfrom sympy import divisors, divisor_sigma\ndef A187795(n): return sum(d for d in divisors(n,generator=True) if divisor_sigma(d) > 2*d) \n"}
{"sequence_id": "A187824", "text": "a(n) is the largest m such that n is congruent to -1, 0 or 1 mod k for all k from 1 to m.", "sequence": "3,4,5,6,3,4,4,5,3,6,4,4,3,5,5,4,3,6,5,5,3,4,6,6,3,4,4,7,3,6,4,4,3,7,7,4,3,5,5,8,3,4,5,5,3,4,4,8,3,5,4,4,3,9,5,4,3,6,6,6,3,4,5,6,3,4,4,5,3,10,4,4,3,5,5,4,3,6,5,5,3,4,7,7,3,4,4,6,3,7,4,4,3,6,6,4,3,5,5,6,3", "code": "\nfrom gmpy2 import t_mod\ndef A187824(n):\n    k = 1\n    while t_mod(n+1,k) < 3:\n        k += 1\n    return k-1 \n"}
{"sequence_id": "A187824", "text": "a(n) is the largest m such that n is congruent to -1, 0 or 1 mod k for all k from 1 to m.", "sequence": "3,4,5,6,3,4,4,5,3,6,4,4,3,5,5,4,3,6,5,5,3,4,6,6,3,4,4,7,3,6,4,4,3,7,7,4,3,5,5,8,3,4,5,5,3,4,4,8,3,5,4,4,3,9,5,4,3,6,6,6,3,4,5,6,3,4,4,5,3,10,4,4,3,5,5,4,3,6,5,5,3,4,7,7,3,4,4,6,3,7,4,4,3,6,6,4,3,5,5,6,3", "code": "\ndef a(n):\n   m=1\n   while abs(n%m) < 2:\n      m += 1\n   return m\n[a(n) for n in range(1,100)]\n\n"}
{"sequence_id": "A187946", "text": "[nr+kr]-[nr]-[kr], where r=(1+sqrt(5))/2, k=5, [ ]=floor.", "sequence": "0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0", "code": "\nfrom __future__ import division\nfrom gmpy2 import isqrt\ndef A187946(n):\n    return int((isqrt(5*(n+5)**2)+n+1)//2 -(isqrt(5*n**2)+n)//2 - 6) \n"}
{"sequence_id": "A187950", "text": "[nr+kr] - [nr] - [kr], where r = (1+sqrt(5))/2, k = 4, [.]=floor.", "sequence": "1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1", "code": "\nfrom __future__ import division\nfrom gmpy2 import isqrt\ndef A187950(n):\n    return int((isqrt(5*(n+4)**2)+n)//2 -(isqrt(5*n**2)+n)//2 - 4) \n"}
{"sequence_id": "A187975", "text": "Positions of 1 in the zero-one sequence given by s(n)=[nr+5r]-[nr]-[5r], where r=sqrt(2), n>=1, [ ]=floor.", "sequence": "12,24,41,53,70,82,94,111,123,140,152,164,181,193,210,222,239,251,263,280,292,309,321,333,350,362,379,391,408,420,432,449,461,478,490,502,519,531,548,560,572,589,601,618,630,647,659,671,688,700,717,729,741,758,770,787,799,816,828,840,857,869,886,898,910,927,939,956", "code": "\nfrom gmpy2 import isqrt\nA187975_list = [n for n in range(1,10**6) if isqrt(2*(n+5)**2) - isqrt(2*n**2) == 8] \n"}
{"sequence_id": "A188014", "text": "a(n) = [nr]-[nr-kr]-[kr], where r=(1+sqrt(5))/2, k=4, [ ]=floor.", "sequence": "0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0", "code": "\nfrom __future__ import division\nfrom gmpy2 import isqrt\ndef A188014(n):\n    return int((isqrt(5*n**2)+n)//2 -(isqrt(5*(n-4)**2)+n)//2 - 4) if n > 3 else 1-(n % 2) \n"}
{"sequence_id": "A188061", "text": "Numbers n such that (product of divisors of n) == 1 (mod sum of divisors of n).", "sequence": "4,9,16,25,49,55,64,81,121,161,169,209,256,289,351,361,529,551,625,649,729,841,961,1024,1079,1189,1369,1407,1443,1681,1849,2015,2209,2289,2401,2809,2849,2915,2975,3401,3481,3721,3857,4096,4489,4599,4887,5041,5329,6049,6241,6319,6561,6889,6993,7921,8569,9409,9701", "code": "\nfrom gmpy2 import powmod, is_square, isqrt\nfrom sympy import divisor_sigma\nA188061_list = [n for n in range(1,10**4) if powmod(isqrt(n) if is_square(n) else n, int(divisor_sigma(n,0))//(1 if is_square(n) else 2), int(divisor_sigma(n,1))) == 1] \n"}
{"sequence_id": "A188068", "text": "[nr]-[kr]-[nr-kr], where r=sqrt(3), k=1, [ ]=floor.", "sequence": "0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1", "code": "\nfrom gmpy2 import isqrt\ndef A188068(n):\n    return int(isqrt(3*n**2) - isqrt(3*(n-1)**2)) - 1 \n"}
{"sequence_id": "A188082", "text": "[nr+kr]-[nr]-[kr], where r=sqrt(3), k=1, [ ]=floor.", "sequence": "1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0", "code": "\nfrom gmpy2 import isqrt\ndef A188082(n):\n    return int(isqrt(3*(n+1)**2) - isqrt(3*n**2)) - 1 \n"}
{"sequence_id": "A188089", "text": "Positions of 0 in the zero-one sequence [nr+4r]-[nr]-[4r], where r=sqrt(3), n>=1.", "sequence": "11,26,41,52,67,82,97,108,123,138,153,164,179,194,205,220,235,250,261,276,291,306,317,332,347,362,373,388,403,414,429,444,459,470,485,500,515,526,541,556,571,582,597,612,623,638,653,668,679,694,709,724,735,750,765,776,791,806,821,832,847,862,877,888,903,918,933,944,959,974,985,1000", "code": "\nfrom gmpy2 import isqrt\nA188089_list = [n for n in range(1,10**6) if isqrt(3*(n+4)**2) - isqrt(3*n**2) == 6] \n"}
{"sequence_id": "A188090", "text": "[nr+kr]-[nr]-[kr], where r=sqrt(3), k=5, [ ]=floor.", "sequence": "1,1,0,1,1,1,0,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1", "code": "\nfrom gmpy2 import isqrt\ndef A188090(n):\n    return int(isqrt(3*(n+5)**2)-isqrt(3*n**2)) - 8 \n"}
{"sequence_id": "A188187", "text": "a(n) = [nr]-[kr]-[nr-kr], where r=sqrt(5), k=1, [ ]=floor.", "sequence": "0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1", "code": "\nfrom sympy import integer_nthroot\ndef A188187(n): return integer_nthroot(5*n**2,2)[0]-integer_nthroot(5*(n-1)**2,2)[0]-2 \n"}
{"sequence_id": "A188215", "text": "Starting with an empty list, n is inserted after the a(n)th element such that the binary representations of the list's elements are always sorted lexicographically.", "sequence": "0,1,2,3,3,4,6,7,4,5,7,8,11,12,14,15,5,6,8,9,12,13,15,16,20,21,23,24,27,28,30,31,6,7,9,10,13,14,16,17,21,22,24,25,28,29,31,32,37,38,40,41,44,45,47,48,52,53,55", "code": "\nl = []\nfor i in range(17):\n    b = bin(i)[2:]\n    l.append(b)\n    l.sort()\n    print(l.index(b))\n"}
{"sequence_id": "A188221", "text": "[nr+kr]-[nr]-[kr], where r=sqrt(5), k=1, [ ]=floor.", "sequence": "0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1", "code": "\nfrom sympy import integer_nthroot\ndef A188221(n): return integer_nthroot(5*(n+1)**2,2)[0]-integer_nthroot(5*n**2,2)[0]-2 \n"}
{"sequence_id": "A188290", "text": "Positions of 0 in the zero-one sequence [nr+4r]-[nr]-[4r], where r=sqrt(5) and []=floor.", "sequence": "17,34,51,68,89,106,123,140,161,178,195,212,233,250,267,284,305,322,339,356,373,394,411,428,445,466,483,500,517,538,555,572,589,610,627,644,661,678,699,716,733,750,771,788,805,822,843,860,877,894,915,932,949,966,983,1004,1021,1038,1055", "code": "\nfrom gmpy2 import isqrt\nA188290_list = [n for n in range(1,10**6) if isqrt(5*(n+4)**2) - isqrt(5*n**2) == 8] \n"}
{"sequence_id": "A188374", "text": "[nr+kr]-[nr]-[kr], where r=1/sqrt(2), k=2, [ ]=floor.", "sequence": "1,0,0,1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,0,1,1", "code": "\nfrom __future__ import division\nfrom gmpy2 import isqrt\ndef A188374(n):\n    return int(isqrt((n+2)**2//2)-isqrt(n**2//2)) - 1 \n"}
{"sequence_id": "A188383", "text": "Positions of 1 in the zero-one sequence [nr+3r]-[nr]-[3r], where r=1/sqrt(2).", "sequence": "7,14,24,31,41,48,55,65,72,82,89,96,106,113,123,130,140,147,154,164,171,181,188,195,205,212,222,229,239,246,253,263,270,280,287,294,304,311,321,328,335,345,352,362,369,379,386,393,403,410,420,427,434,444,451,461,468,478,485,492,502,509,519,526,533,543,550", "code": "\nfrom __future__ import division\nfrom gmpy2 import isqrt\nA188383_list = [n for n in range(1,10**6) if isqrt((n+3)**2//2) - isqrt(n**2//2) == 3] \n"}
{"sequence_id": "A188528", "text": "First month in year n with a \"Friday the 13th\", starting from 1901.", "sequence": "9,6,2,5,1,4,9,3,8,5,1,9,6,2,8,10,4,9,6,2,5,1,4,6,2,8,5,1,9,6,2,5,1,4,9,3,8,5,1,9,6,2,8,10,4,9,6,2,5,1,4,6,2,8,5,1,9,6,2,5,1,4,9,3,8,5,1,9,6,2,8,10,4,9,6,2,5,1,4,6,2,8,5,1,9", "code": "\nfrom datetime import date\ndef a(n):\n    for month in range(1, 13):\n        if date.isoweekday(date(n, month, 13)) == 5: return month\nprint([a(n) for n in range(1901, 1986)]) \n"}
{"sequence_id": "A188568", "text": "Enumeration table T(n,k) by descending antidiagonals. The order of the list - if n is odd:  T(n,1), T(2,n-1), T(n-2,3), ..., T(n-1,2), T(1,n); if n is even: T(1,n), T(n-1,2), T(3,n-2), ..., T(2,n-1), T(n,1).", "sequence": "1,2,3,6,5,4,7,9,8,10,15,12,13,14,11,16,20,18,19,17,21,28,23,26,25,24,27,22,29,35,31,33,32,34,30,36,45,38,43,40,41,42,39,44,37,46,54,48,52,50,51,49,53,47,55", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nm=((i+j-1)*(i+j-2)+((-1)**max(i,j)+1)*i-((-1)**max(i,j)-1)*j)/2\n"}
{"sequence_id": "A188775", "text": "Numbers k such that Sum_{j=1..k} j^j == -1 (mod k).", "sequence": "1,2,3,6,14,42,46,1806,2185,4758,5266,10895,24342,26495,44063,52793,381826,543026,547311,805002", "code": "\nsum = 0\nfor n in range(10000):\n    sum += n**n\n    if sum % (n+1) == 0:\n        print(n+1, end=',')\n\n"}
{"sequence_id": "A188902", "text": "Numerator of the base n logarithm of the product of the divisors of n.", "sequence": "1,1,3,1,2,1,2,3,2,1,3,1,2,2,5,1,3,1,3,2,2,1,4,3,2,2,3,1,4,1,3,2,2,2,9,1,2,2,4,1,4,1,3,3,2,1,5,3,3,2,3,1,4,2,4,2,2,1,6,1,2,3,7,2,4,1,3,2,4,1,6,1,2,3,3,2", "code": "\nfrom sympy import divisor_count, Integer\ndef a(n): return (divisor_count(n) / 2).numerator()\nprint([a(n) for n in range(2, 51)])  \n"}
{"sequence_id": "A189021", "text": "Apostol's second order M\u00f6bius (or Moebius) function mu_2(n).", "sequence": "1,1,1,-1,1,1,1,0,-1,1,1,-1,1,1,1,0,1,-1,1,-1,1,1,1,0,-1,1,0,-1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,-1,-1,1,1,0,-1,-1,1,-1,1,0,1,0,1,1,1,-1,1,1,-1,0,1,1,1,-1,1,1,1,0,1,1,-1,-1,1,1,1,0,0,1,1,-1,1,1,1,0,1,-1,1,-1,1,1,1,0,1,-1,-1,1", "code": "\nfrom sympy import factorint, prod\ndef a(n): return 1 if n==1 else prod(1 if e==1 else -1 if e==2 else 0 for p, e in factorint(n).items())\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A189398", "text": "a(n) = 2^d(1) * 3^d(2) * ... * prime(k)^d(k), where d(1)d(2)...d(k) is the decimal representation of n.", "sequence": "2,4,8,16,32,64,128,256,512,2,6,18,54,162,486,1458,4374,13122,39366,4,12,36,108,324,972,2916,8748,26244,78732,8,24,72,216,648,1944,5832,17496,52488,157464,16,48,144,432,1296,3888,11664,34992,104976,314928,32", "code": "\nfrom sympy import prime\nfrom operator import mul\nfrom functools import reduce\ndef A189398(n):\n....return reduce(mul, (prime(i)**int(d) for i,d in enumerate(str(n),start=1)))\n\ndef _A189398(n):\n....nlen = len(n)\n....return _A189398(n[:-1])*prime(nlen)**int(n[-1]) if nlen > 1 else 2**int(n)\ndef A189398(n):\n....return _A189398(str(n))\n\n"}
{"sequence_id": "A189409", "text": "a(n) = prime(n)#^2 + 1, where prime(n)# is the n-th primorial (A002110).", "sequence": "2,5,37,901,44101,5336101,901800901,260620460101,94083986096101,49770428644836901,41856930490307832901,40224510201185827416901,55067354465423397733736101,92568222856376731590410384101", "code": "\nfrom functools import reduce\nimport numpy as np\ndef factors(n):\n    return reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))\nmul = 1\nfor i in range(1, 20):\n    if len(factors(i))<3:\n        mul *= i*i\n        print(mul+1, factors(mul+1))\n\n"}
{"sequence_id": "A189571", "text": "Smallest of nine consecutive primes whose sum is a prime.", "sequence": "3,29,31,37,47,79,83,89,107,109,127,131,139,149,157,173,179,193,197,199,211,241,277,347,359,367,373,389,397,433,449,487,491,521,577,593,619,643,659,677,743,761,829,853,953,977,1049,1063,1087,1129,1151,1193", "code": "\nfrom sympy import isprime, nextprime\ndef aupto(limit):\n  plst, alst = [3, 5, 7, 11, 13, 17, 19, 23, 29], []\n  while plst[0] <= limit:\n    if isprime(sum(plst)): alst.append(plst[0])\n    plst = plst[1:] + [nextprime(plst[-1])]\n  return alst\nprint(aupto(1200)) \n"}
{"sequence_id": "A189663", "text": "Partial sums of A189661.", "sequence": "0,1,1,2,2,2,3,3,4,4,4,5,5,5,6,6,7,7,7,8,8,9,9,9,10,10,10,11,11,12,12,12,13,13,13,14,14,15,15,15,16,16,17,17,17,18,18,18,19,19,20,20,20,21,21,22,22,22,23,23,23,24,24,25,25,25,26,26,26,27,27,28,28,28,29,29,30,30,30,31", "code": "\nl=[0, 0, 1]\nfor n in range(3, 101):\n    l.append(n - l[n - 1] - l[n - l[n - 1]])\nprint(l[1:]) \n"}
{"sequence_id": "A189718", "text": "Fixed point of the morphism 0->011, 1->100.", "sequence": "0,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,0,0,1,0,0,1,0,0,0,1", "code": "\nA189718_list = [0]\nfor _ in range(9):\n    A189718_list += [1-d for d in A189718_list]*2 \n"}
{"sequence_id": "A189788", "text": "Base-10 lunar factorials: a(n) = (lunar) Product_{i=1..n} i.", "sequence": "9,1,1,1,1,1,1,1,1,1,10,110,1110,11110,111110,1111110,11111110,111111110,1111111110,11111111110,111111111100,1111111111100,11111111111100,111111111111100,1111111111111100,11111111111111100,111111111111111100,1111111111111111100,11111111111111111100,111111111111111111100,1111111111111111111000", "code": " \nfrom functools import reduce\ndef a(n): return reduce(lunar_mul, [9]+list(range(1, n+1)))\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A189788", "text": "Base-10 lunar factorials: a(n) = (lunar) Product_{i=1..n} i.", "sequence": "9,1,1,1,1,1,1,1,1,1,10,110,1110,11110,111110,1111110,11111110,111111110,1111111110,11111111110,111111111100,1111111111100,11111111111100,111111111111100,1111111111111100,11111111111111100,111111111111111100,1111111111111111100,11111111111111111100,111111111111111111100,1111111111111111111000", "code": " \nfrom itertools import accumulate\ndef aupton(nn): return list(accumulate([9]+list(range(1, nn+1)), lunar_mul))\nprint(aupton(30)) \n"}
{"sequence_id": "A189823", "text": "Decimal expansion of the reduced Champernowne constant.", "sequence": "1,2,3,4,5,6,7,8,9,1,0,1,1,1,3,1,4,1,5,1,6,1,7,1,8,1,9,2,0,2,1,2,2,2,4,2,5,2,6,2,7,2,8,2,9,3,0,3,2,3,3,3,5,3,6,3,7,3,8,3,9,4,0,4,3,4,4,4,6,4,7,4,8,4,9,5,0,5,4,5,5,5,7,5,8,5,9,6,0,6,5,6,6,6,8,6,9,7,0,7,6,7,7,7,9,8,0,8,7,8,8,9,0,9,9,1,0,0,1,0,2,1,0,3,1,0,4,1,0,5,1,0,6,1,0,7,1,0,8,1,0,9,1,1,0,1,1,2,1,1,4,1,1,5,1,1,6,1,1,7,1,1,8,1,1,9,1,2,0,1,2,4,1,2,5,1,2,6,1,2,7,1,2,8,1", "code": "\ndef rchampernowne(n):\n....stri=''\n....for i in range(1,n+1) :\n........if stri.count(str(i))==0 : stri=stri+str(i)\n....return '0.'+stri+'...'\nrchampernowne(100) \n"}
{"sequence_id": "A189889", "text": "Maximum number of nonattacking kings on an n X n toroidal board.", "sequence": "1,1,1,4,5,9,10,16,18,25,27,36,39,49,52,64,68,81,85,100,105,121,126,144,150,169,175,196,203,225,232,256,264,289,297,324,333,361,370,400,410,441,451,484,495,529,540,576,588,625", "code": " def A189889(n): return 1 if n==1 else (n*(n/2))/2 \n"}
{"sequence_id": "A190403", "text": "Number n for which sigma(n)=sigma(n'), where sigma is the sum of divisors and n' the arithmetic derivative of n.", "sequence": "4,27,60,84,132,140,204,220,228,260,270,340,372,378,444,492,564,572,580,620,644,702,708,740,804,812,820,836,860,884,918,945,1026,1068,1180,1242,1276,1284,1292,1308,1316,1364,1420,1460,1484,1485,1508,1564,1566", "code": "\nfrom sympy import factorint, totient\nA190402 = [n for n in range(2,10**3) if totient(int(sum([n*e/p for p,e in factorint(n).items()]))) == totient(n)] \n"}
{"sequence_id": "A190427", "text": "a(n) = [(b*n+c)*r] - b*[n*r] - [c*r], where (r,b,c)=(golden ratio,2,1) and []=floor.", "sequence": "1,1,2,1,0,2,1,2,1,0,2,1,0,1,1,2,1,0,2,1,2,1,1,2,1,0,1,1,2,1,0,2,1,0,1,1,2,1,0,2,1,2,1,1,2,1,0,1,1,2,1,0,2,1,2,1,1,2,1,0,2,1,2,1,0,2,1,0,1,1,2,1,0,2,1,2,1,1,2,1,0,1,1,2,1,0,2,1,0,1,1,2,1,0,2,1,2,1,0,2,1,0,1,1,2,1,0,2,1,2,1,1,2,1,0,2,1,2,1,0,2,1,0,1,1,2,1,0,2,1,2", "code": "\nfrom mpmath import mp, phi\nfrom sympy import floor\nmp.dps=100\ndef a(n): return floor((2*n + 1)*phi) - 2*floor(n*phi) - 1\nprint([a(n) for n in range(1, 132)]) \n"}
{"sequence_id": "A190483", "text": "a(n) = [(bn+c)r]-b[nr]-[cr], where (r,b,c)=(sqrt(2),2,1) and []=floor.", "sequence": "1,2,0,1,0,1,2,1,1,0,1,2,1,2,0,1,0,1,2,0,1,0,1,2,1,1,0,1,0,1,2,0,1,0,1,2,1,1,0,1,2,1,2,0,1,0,1,2,1,1,0,1,2,1,1,0,1,0,1,2,0,1,0,1,2,1,1,0,1,2,1,2,0,1,0,1,2,1,1,0,1,2,1,2,0,1,0,1,2,0,1,0,1,2,1,1,0,1,0,1,2,0,1,0,1,2,1,1,0,1,2,1,2,0", "code": "\nfrom sympy import sqrt, floor\nr=sqrt(2)\ndef a(n): return floor((2*n + 1)*r) - 2*floor(n*r) - floor(r)\nprint([a(n) for n in range(1, 501)]) \n"}
{"sequence_id": "A190484", "text": "Positions of 0 in A190483.", "sequence": "3,5,10,15,17,20,22,27,29,32,34,39,44,46,51,56,58,61,63,68,73,75,80,85,87,90,92,97,99,102,104,109,114,116,119,121,126,128,131,133,138,143,145,150,155,157,160,162,167,169,172,174,179,184,186,189,191,196,198,201,203,208,213,215", "code": "\nfrom sympy import sqrt, floor\nr=sqrt(2)\ndef a190483(n): return floor((2*n + 1)*r) - 2*floor(n*r) - floor(r)\nprint([n for n in range(1, 501) if a190483(n)==0]) \n"}
{"sequence_id": "A190485", "text": "Positions of 1 in A190483.", "sequence": "1,4,6,8,9,11,13,16,18,21,23,25,26,28,30,33,35,37,38,40,42,45,47,49,50,52,54,55,57,59,62,64,66,67,69,71,74,76,78,79,81,83,86,88,91,93,95,96,98,100,103,105,107,108,110,112,115,117,120,122,124,125,127,129,132,134,136,137,139,141,144,146,148,149,151,153,154,156,158", "code": "\nfrom sympy import sqrt, floor\nr=sqrt(2)\ndef a190483(n): return floor((2*n + 1)*r) - 2*floor(n*r) - floor(r)\nprint([n for n in range(1, 501) if a190483(n)==1]) \n"}
{"sequence_id": "A190486", "text": "Positions of 2 in A190483.", "sequence": "2,7,12,14,19,24,31,36,41,43,48,53,60,65,70,72,77,82,84,89,94,101,106,111,113,118,123,130,135,140,142,147,152,159,164,171,176,181,183,188,193,200,205,210,212,217,222,229,234,239,241,246,251,253,258,263,270,275,280,282,287,292,299,304,309,311,316", "code": "\nfrom sympy import sqrt, floor\nr=sqrt(2)\ndef a190483(n): return floor((2*n + 1)*r) - 2*floor(n*r) - floor(r)\nprint([n for n in range(1, 501) if a190483(n)==2]) \n"}
{"sequence_id": "A190598", "text": "Maximal digit in base-9 expansion of n.", "sequence": "0,1,2,3,4,5,6,7,8,1,1,2,3,4,5,6,7,8,2,2,2,3,4,5,6,7,8,3,3,3,3,4,5,6,7,8,4,4,4,4,4,5,6,7,8,5,5,5,5,5,5,6,7,8,6,6,6,6,6,6,6,7,8,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,1,1,2,3,4,5,6,7,8,1,1,2,3,4,5,6,7,8,2,2,2,3,4,5", "code": "\nfrom sympy.ntheory.digits import digits\ndef a(n): return max(digits(n, 9)[1:])\nprint([a(n) for n in range(105)]) \n"}
{"sequence_id": "A190651", "text": "Years with exactly one \"Friday the 13th\", starting from 1901.", "sequence": "1902,1904,1909,1910,1913,1915,1916,1919,1921,1924,1926,1927,1930,1932,1937,1938,1941,1943,1944,1947,1949,1952,1954,1955,1958,1960,1965,1966,1969,1971,1972,1975,1977,1980,1982,1983,1986,1988,1993,1994,1997,1999,2000", "code": "\nfrom datetime import date\ndef ok(n): return sum(date.isoweekday(date(n, m, 13)) == 5 for m in range(1, 13)) == 1\nprint(list(filter(ok, range(1901, 2001)))) \n"}
{"sequence_id": "A190652", "text": "Years with exactly two \"Friday the 13ths\", starting from 1901.", "sequence": "1901,1905,1906,1907,1908,1911,1912,1917,1918,1920,1922,1923,1929,1933,1934,1935,1936,1939,1940,1945,1946,1948,1950,1951,1957,1961,1962,1963,1964,1967,1968,1973,1974,1976,1978,1979,1985,1989,1990,1991,1992,1995,1996", "code": "\nfrom datetime import date\ndef ok(n): return sum(date.isoweekday(date(n, m, 13)) == 5 for m in range(1, 13)) == 2\nprint(list(filter(ok, range(1901, 2000)))) \n"}
{"sequence_id": "A190653", "text": "Years with exactly three \"Friday the 13ths\", starting from 1901.", "sequence": "1903,1914,1925,1928,1931,1942,1953,1956,1959,1970,1981,1984,1987,1998,2009,2012,2015,2026,2037,2040,2043,2054,2065,2068,2071,2082,2093,2096,2099,2105,2108,2111,2122,2133,2136,2139,2150,2161,2164,2167,2178,2189,2192", "code": "\nfrom datetime import date\ndef ok(n): return sum(date.isoweekday(date(n, m, 13)) == 5 for m in range(1, 13)) == 3\nprint(list(filter(ok, range(1901, 2193)))) \n"}
{"sequence_id": "A190846", "text": "(Squarefree part of (ABC))/C for A=1, C=A+B, as a function of B, rounded to the nearest integer.", "sequence": "1,2,2,2,5,6,2,1,3,10,6,6,13,14,2,2,6,6,10,10,21,22,6,1,5,3,2,14,29,30,2,2,33,34,6,6,37,38,10,10,41,42,22,7,15,46,6,1,1,10,26,26,6,6,14,14,57,58,30,30,61,21,1,2,65,66,34,34,69,70,6,6,73,15,8,38,77,78,10,0,3,82,42", "code": "\nfrom operator import mul\nfrom sympy import primefactors\ndef rad(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a(n): return int(round(rad(n**2 + n)/(n + 1))) \n"}
{"sequence_id": "A190867", "text": "Count of the 3-full divisors of n.", "sequence": "1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,4,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,3,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,5,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,2,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,2,1,1,1,2,1,1", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef a(n): return 1 if n==1 else reduce(mul, [max(1, e - 1) for e in factorint(n).values()])\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A191093", "text": "[Squarefree part of (ABC)]/C for A=2, C=A+B, as a function of B, rounded to nearest integer.", "sequence": "2,1,6,1,10,1,5,1,6,3,22,3,26,1,30,0,34,2,38,5,42,3,9,3,1,7,6,7,58,1,62,1,66,3,70,3,74,5,78,5,82,11,29,11,30,3,13,1,14,3,102,1,106,1,110,7,114,15,118,15,41,1,42,1,130,17,134,17,138,3,142,3,29,19,30,19,154", "code": "\nfrom operator import mul\nfrom sympy import primefactors\ndef rad(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a(n): return int(round(rad(2*n**2 + 4*n)/(n + 2))) \n"}
{"sequence_id": "A191100", "text": "[Squarefree part of (ABC)]/C for A=3, C=A+B, as a function of B, rounded to nearest integer.", "sequence": "2,6,1,6,4,1,21,6,1,30,33,2,5,42,2,6,26,2,57,30,2,13,69,0,8,78,1,42,5,10,93,6,2,102,105,2,28,114,13,30,62,5,129,66,1,20,28,2,11,30,2,78,40,2,165,42,10,174,177,3,6,186,7,6,98,22,201,102,2,210,213,0,110,222,5,114", "code": "\nfrom operator import mul\nfrom sympy import primefactors\ndef rad(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a(n): return int(round(rad(3*n**2 + 9*n)/(n + 3))) \n"}
{"sequence_id": "A191311", "text": "Numbers n such that exactly half of the a such that 0<a<n and (a,n)=1 satisfy a^(n-1) = 1 (mod n).", "sequence": "4,6,15,91,703,1891,2701,11305,12403,13981,18721,23001,30889,38503,39865,49141,68101,79003,88561,88831,91001,93961,104653,107185,137149,146611,152551,157641,176149,188191,204001,218791,226801,228241", "code": "\nimport math\nfor x in range(2, 1000):\n  false_witnesses = 0\n  relatively_prime_values = 0\n  for y in range(x):\n    if math.gcd(y, x) == 1:\n      relatively_prime_values += 1\n    if (pow(y, x-1, x) == 1):\n      false_witnesses += 1\n  if false_witnesses * 2 == relatively_prime_values:\n    print(x, \"is a Fermat Half-Prime\")\n"}
{"sequence_id": "A191371", "text": "Number of simple labeled graphs with (at most) 3-colored nodes such that no edge connects two nodes of the same color.", "sequence": "1,3,15,123,1635,35043,1206915,66622083,5884188675,830476531203,187106645932035,67241729173555203,38521811621470420995,35161184767296890265603,51112793797110111859802115,118291368253025368001553530883,435713124846749574718274002747395,2553666761436949125065383836043837443", "code": "\nfrom sympy import binomial\ndef a047863(n): return sum([binomial(n, k)*2**(k*(n - k)) for k in range(n + 1)])\ndef a(n): return sum([binomial(n, k)*2**(k*(n - k))*a047863(k) for k in range(n + 1)]) \n"}
{"sequence_id": "A191486", "text": "Squares using only the prime digits (2,3,5,7).", "sequence": "25,225,7225,27225,55225,235225,2772225,3553225,23377225,33235225,57532225,227557225,252333225,277722225,337273225,357777225,523723225,735223225,777573225,2523555225,3325252225,3377353225,5232352225,7333353225", "code": "\nfrom math import isqrt\ndef aupto(limit):\n  alst, rootlimit = [], isqrt(limit)\n  for k in range(1, rootlimit+1):\n    if set(str(k*k)) <= set(\"2357\"): alst.append(k*k)\n  return alst\nprint(aupto(7333353225)) \n"}
{"sequence_id": "A191610", "text": "Possible number of trailing zeros in n!.", "sequence": "0,1,2,3,4,6,7,8,9,10,12,13,14,15,16,18,19,20,21,22,24,25,26,27,28,31,32,33,34,35,37,38,39,40,41,43,44,45,46,47,49,50,51,52,53,55,56,57,58,59,62,63,64,65,66,68,69,70,71,72,74,75,76,77,78,80,81,82,83,84,86,87,88,89,90,93,94,95,96,97,99,100,101,102,103,105,106,107,108,109,111,112,113,114,115,117,118,119,120,121,124,125,126,127,128,130,131,132,133,134,136", "code": "\n\nfrom itertools import accumulate\nfrom sympy import multiplicity\nA191610 = [0]+list(accumulate(multiplicity(5,n) for n in range(5,10**3,5)))\n\n"}
{"sequence_id": "A191647", "text": "Numbers n with property that the concatenation of their anti-divisors is a prime.", "sequence": "3,4,5,10,14,16,40,46,100,145,149,251,340,373,406,424,439,466,539,556,571,575,617,619,628,629,655,676,689,724,760,779,794,899,901,941,970,989,1019,1055,1070,1076,1183,1213,1226,1231,1258,1270,1285,1331,1340", "code": "\nfrom sympy import isprime\n[n for n in range(3,10**4) if isprime(int(''.join([str(d) for d in range(2,n) if n%d and 2*n%d in [d-1,0,1]])))] \n"}
{"sequence_id": "A191755", "text": "Number of square binary words: binary words of length 2n obtained by self-shuffling.", "sequence": "1,2,6,22,82,320,1268,5102,20632,83972,342468,1399296,5720966,23396618,95654386,390868900,1596000418,6511211718,26538617050,108060466284", "code": "\nfrom itertools import product, combinations\ndef a(n): \n    if n<=1: return 2**n, 1, '0'*n\n    range2n, set2n = list(range(2*n)), set(range(2*n))\n    allset, mx, argmx, ssw = set(), -1, None, [0 for i in range(2*n)]\n    for w in product(\"01\", repeat=n-1):\n        w, sswset = \"0\" + \"\".join(w), set()\n        for s in combinations(range2n, n):\n            nots = sorted(set2n-set(s))\n            for i, c in enumerate(w): ssw[s[i]] = ssw[nots[i]] = c\n            sswset.add(\"\".join(ssw))\n        allset |= sswset\n        if len(sswset) > mx: mx, argmx = len(sswset), w\n    return 2*len(allset), mx, argmx\nprint([a(n)[0] for n in range(9)]) \n"}
{"sequence_id": "A191797", "text": "a(n) = binomial(F(n), 2) where F(n) = A000045(n).", "sequence": "0,0,0,1,3,10,28,78,210,561,1485,3916,10296,27028,70876,185745,486591,1274406,3337236,8738290,22879230,59901985,156830905,410597496,1074972528,2814337800,7368069528,19289917153,50501756955,132215475106,346144864780,906219437046", "code": "\nfrom sympy import binomial, fibonacci\ndef a(n): return binomial(fibonacci(n), 2) \n"}
{"sequence_id": "A191871", "text": "a(n) = numerator(n^2 / 2^n).", "sequence": "0,1,1,9,1,25,9,49,1,81,25,121,9,169,49,225,1,289,81,361,25,441,121,529,9,625,169,729,49,841,225,961,1,1089,289,1225,81,1369,361,1521,25,1681,441,1849,121,2025,529,2209,9,2401,625,2601,169,2809,729,3025", "code": "\nfrom __future__ import division\ndef A191871(n):\n    while not n % 2:\n        n //= 2\n    return n**2 \n"}
{"sequence_id": "A191898", "text": "Symmetric square array read by antidiagonals: T(n,1)=1, T(1,k)=1, T(n,k) = -Sum_{i=1..k-1} T(n-i,k) for n >= k, -Sum_{i=1..n-1} T(k-i,n) for n < k.", "sequence": "1,1,1,1,-1,1,1,1,1,1,1,-1,-2,-1,1,1,1,1,1,1,1,1,-1,1,-1,1,-1,1,1,1,-2,1,1,-2,1,1,1,-1,1,-1,-4,-1,1,-1,1,1,1,1,1,1,1,1,1,1,1,1,-1,-2,-1,1,2,1,-1,-2,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,1,-1,1,-1,-6,-1,1,-1,1,-1,1", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef T(n, k): return 0 if n<1 or k<1 else 1 if n==1 or k==1 else T(k, n) if k>n else T(k, (n - 1)%k + 1) if n>k else -sum([T(n, i) for i in range(1, n)])\nfor n in range(1, 21): print([T(k, n - k + 1) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A192085", "text": "Number of ones in the binary expansion of n^3.", "sequence": "0,1,1,4,1,6,4,6,1,6,6,6,4,5,6,8,1,6,6,8,6,6,6,9,4,7,5,8,6,9,8,10,1,6,6,11,6,10,8,12,6,8,6,9,6,11,9,10,4,9,7,7,5,8,8,10,6,10,9,7,8,11,10,12,1,6,6,11,6,9,11,11,6,13,10,14,8,13,12,13", "code": "\ndef A192085(n):\n....return bin(n**3).count('1') \n"}
{"sequence_id": "A192272", "text": "Harmonic anti-divisor numbers.", "sequence": "5,8,41,56,588,946,972,1568,2692,5186,6874,8104,17386,27024,63584,84026,96896,167786,197416,2667584,4921776,5315554,27914146,30937248,124370356,505235234,3238952914,5079644880,6698880678,19672801456", "code": "\nfrom sympy.ntheory.factor_ import antidivisor_count, antidivisors\nA192272_list = []\nfor n in range(3,10**10):\n    if (n*antidivisor_count(n)) % sum(antidivisors(n,generator=True)) == 0:\n        A192272_list.append(n) \n"}
{"sequence_id": "A192273", "text": "Zumkeller numbers using anti-divisors (or anti-Zumkeller numbers)", "sequence": "7,10,17,22,23,31,32,33,35,37,38,39,42,45,49,50,52,53,55,58,63,67,68,70,72,73,77,78,82,83,87,88,93,94,95,98,103,105,115,116,117,123,126,127,128,130,137,142,143,148,149,157,158,160,162,163,165,171,175", "code": "\nfrom sympy import divisors\nfrom sympy.combinatorics.subsets import Subset\ndef antidivisors(n):\n    return [2*d for d in divisors(n) if n > 2*d and n % (2*d)] + \\\n           [d for d in divisors(2*n-1) if n > d >=2 and n % d] + \\\n           [d for d in divisors(2*n+1) if n > d >=2 and n % d]\nfor n in range(3,10**3):\n    d = antidivisors(n)\n    s = sum(d)\n    if not s % 2 and max(d) <= s//2:\n        for x in range(1,2**len(d)):\n            if sum(Subset.unrank_binary(x,d).subset) == s//2:\n                print(n,end=', ')\n                break\n\n"}
{"sequence_id": "A192273", "text": "Zumkeller numbers using anti-divisors (or anti-Zumkeller numbers)", "sequence": "7,10,17,22,23,31,32,33,35,37,38,39,42,45,49,50,52,53,55,58,63,67,68,70,72,73,77,78,82,83,87,88,93,94,95,98,103,105,115,116,117,123,126,127,128,130,137,142,143,148,149,157,158,160,162,163,165,171,175", "code": "\nfrom sympy import divisors\nimport numpy as np\nA192273 = []\nfor n in range(3,10**3):\n    d = [2*x for x in divisors(n) if n > 2*x and n % (2*x)] + \\\n        [x for x in divisors(2*n-1) if n > x >=2 and n % x] + \\\n        [x for x in divisors(2*n+1) if n > x >=2 and n % x]\n    s, dmax = sum(d), max(d)\n    if not s % 2 and 2*dmax <= s:\n        d.remove(dmax)\n        s2, ld = int(s/2-dmax), len(d)\n        z = np.zeros((ld+1,s2+1),dtype=int)\n        for i in range(1,ld+1):\n            y = min(d[i-1],s2+1)\n            z[i,range(y)] = z[i-1,range(y)]\n            z[i,range(y,s2+1)] = np.maximum(z[i-1,range(y,s2+1)],z[i-1,range(0,s2+1-y)]+y)\n            if z[i,s2] == s2:\n                A192273.append(n)\n                break\n\n"}
{"sequence_id": "A192274", "text": "Numbers which are both Zumkeller numbers and anti-Zumkeller numbers.", "sequence": "42,70,78,88,126,160,176,228,234,258,270,280,308,342,350,368,378,380,390,396,402,438,448,462,468,490,500,522,532,540,552,558,560,572,580,588,608,618,620,630,644,650,690,702,732,756,770,780,798,812,822,852,858", "code": "\nfrom sympy import divisors\nimport numpy as np\nA192274 = []\nfor n in range(3,10**3):\n....d = divisors(n)\n....s = sum(d)\n....if not s % 2 and 2*n <= s:\n........d.remove(n)\n........s2, ld = int(s/2-n), len(d)\n........z = np.zeros((ld+1,s2+1),dtype=int)\n........for i in range(1,ld+1):\n............y = min(d[i-1],s2+1)\n............z[i,range(y)] = z[i-1,range(y)]\n............z[i,range(y,s2+1)] = np.maximum(z[i-1,range(y,s2+1)],z[i-1,range(0,s2+1-y)]+y)\n............if z[i,s2] == s2:\n................d2 = [2*x for x in d if n > 2*x and n % (2*x)] + \\\n................[x for x in divisors(2*n-1) if n > x >=2 and n % x] + \\\n................[x for x in divisors(2*n+1) if n > x >=2 and n % x]\n................s, dmax = sum(d2), max(d2)\n................if not s % 2 and 2*dmax <= s:\n....................d2.remove(dmax)\n....................s2, ld = int(s/2-dmax), len(d2)\n....................z = np.zeros((ld+1,s2+1),dtype=int)\n....................for i in range(1,ld+1):\n........................y = min(d2[i-1],s2+1)\n........................z[i,range(y)] = z[i-1,range(y)]\n........................z[i,range(y,s2+1)] = np.maximum(z[i-1,range(y,s2+1)],z[i-1,range(0,s2+1-y)]+y)\n........................if z[i,s2] == s2:\n............................A192274.append(n)\n........................break\n................break\n\n"}
{"sequence_id": "A192276", "text": "Numbers n such that the number of anti-divisors of n divides n.", "sequence": "3,4,6,8,12,15,16,21,24,25,30,35,36,40,48,51,54,55,60,63,64,65,69,70,72,75,80,84,90,96,100,112,114,120,125,126,133,140,141,143,147,155,156,160,161,171,174,180,189,190,200,205,207,210,216,220,231,240", "code": "\n[n for n in range(3,10**5) if not n % len([d for d in range(2,n) if n%d and 2*n%d in [d-1,0,1]])] \n"}
{"sequence_id": "A192290", "text": "Anti-amicable numbers.", "sequence": "14,16,92,114,5566,6596,1077378,1529394,3098834,3978336,70774930,92974314", "code": "\nfrom sympy import divisors\ndef sigma_s(n):\n    return sum([2*d for d in divisors(n) if n > 2*d and n % (2*d)] +\n        [d for d in divisors(2*n-1) if n > d >=2 and n % d] +\n        [d for d in divisors(2*n+1) if n > d >=2 and n % d])\nA192290 = [n for n in range(1,10**4) if sigma_s(n) != n and sigma_s(sigma_s(n)) == n] \n"}
{"sequence_id": "A192293", "text": "Let sigma*_m (n) be the result of applying the sum of anti-divisors m times to n; call n (m,k)-anti-perfect if sigma*_m (n) = k*n; this sequence gives the (2,3)-anti-perfect numbers.", "sequence": "32,98,2524,199282,1336968", "code": "\nfrom sympy import divisors\ndef antidivisors(n):\n    return [2*d for d in divisors(n) if n > 2*d and n % (2*d)] + \\\n        [d for d in divisors(2*n-1) if n > d >=2 and n % d] + \\\n        [d for d in divisors(2*n+1) if n > d >=2 and n % d]\nA192293_list = []\nfor n in range(1,10**4):\n    if 3*n == sum(antidivisors(sum(antidivisors(n)))):\n         A192293_list.append(n) \n"}
{"sequence_id": "A192296", "text": "Number of ternary words of length 2n obtained by self-shuffling.", "sequence": "1,3,15,93,621,4425,32703,248901,1934007,15285771,122437215,991731999,8107830597", "code": "\nfrom itertools import product, combinations\ndef a(n):\n  if n<=1: return 3**n\n  range2n, set2n = list(range(2*n)), set(range(2*n))\n  allset, ssw = set(), [0 for i in range(2*n)]\n  for w in product(\"012\", repeat=n-1):\n    w = \"0\" + \"\".join(w)\n    if w.count(\"1\") > w.count(\"2\"): continue\n    for s in combinations(range2n, n):\n      nots = sorted(set2n-set(s))\n      for i, c in enumerate(w): ssw[s[i]] = ssw[nots[i]] = c\n      allset.add(\"\".join(ssw))\n  num2g1 = sum(w.count(\"1\") < w.count(\"2\") for w in allset)\n  return 3*(len(allset) + num2g1)\nprint([a(n) for n in range(8)]) \n"}
{"sequence_id": "A192336", "text": "Sums of two or more distinct squares.", "sequence": "5,10,13,14,17,20,21,25,26,29,30,34,35,37,38,39,40,41,42,45,46,49,50,51,52,53,54,55,56,57,58,59,61,62,63,65,66,68,69,70,71,73,74,75,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,93,94,95,97,98,99,100,101,102,103,104", "code": "\nfrom itertools import combinations\ndef aupto(lim):\n  s = [i*i for i in range(1, int(lim**.5)+2) if i*i <= lim]\n  ss = set(sum(c) for i in range(2, len(s)+1) for c in combinations(s, i))\n  return sorted(filter(lambda x: x <= lim, ss))\nprint(aupto(104)) \n"}
{"sequence_id": "A192367", "text": "Numbers k such that k! + 2*k + 1 is prime.", "sequence": "0,2,3,5,6,18,44,113,2615,16914", "code": "\nfactor=1;\nfor i in range(2,10000):\n    factor=factor*i\n    if is_probable_prime(factor+2*i+1): \n        print i\n"}
{"sequence_id": "A192434", "text": "Smallest prime p such that there is a gap of exactly n! between p and the next prime.", "sequence": "2,2,3,23,1669,1895359,111113196467011", "code": "\nimport sympy\nn=0\nwhile n>=0:\n....p=2\n....while  sympy.nextprime(p)-p!=(sympy.factorial(n)):\n........p=sympy.nextprime(p)\n....print(p)\n....n=n+1\n....p=sympy.nextprime(p)\n\n"}
{"sequence_id": "A192892", "text": "Number of n X n binary matrices whose determinants equal their permanents.", "sequence": "1,2,12,343,34997,12515441,15749457081,72424550598849,1282759836215548737", "code": "\nfrom itertools import product\nfrom sympy import Matrix\ndef A192892(n): return 1 if n == 0 else sum(1 for m in product([0,1],repeat=n**2) if (lambda x:x.det()==x.per())(Matrix(n,n,m))) \n"}
{"sequence_id": "A193231", "text": "Blue code of n: in binary coding of a polynomial over GF(2), substitute x+1 for x.", "sequence": "0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8,17,16,18,19,20,21,23,22,30,31,29,28,27,26,24,25,51,50,48,49,54,55,53,52,60,61,63,62,57,56,58,59,34,35,33,32,39,38,36,37,45,44,46,47,40,41,43,42,85,84,86", "code": "\ndef a065621(n): return n^(2*(n - (n&-n)))\ndef a048724(n): return n^(2*n)\nl=[0, 1]\nfor n in range(2, 101):\n    if n%2==0: l.append(a048724(l[n//2]))\n    else: l.append(a065621(1 + l[(n - 1)//2]))\nprint(l) \n"}
{"sequence_id": "A193286", "text": "a(n) is the maximal number of a's that can be produced in a blank document with n \"keystrokes\".", "sequence": "1,2,3,4,5,6,7,9,12,16,20,25,30,36,48,64,80,100,125,150,192,256,320,400,500,625,768,1024,1280,1600,2000,2500,3125,4096,5120,6400,8000,10000,12500,16384,20480,25600,32000,40000,50000,65536,81920,102400,128000,160000,200000,262144,327680", "code": "\ndef a(n):\n    if n<8: return n\n    elif n==8: return 9\n    elif n>8 and n<=27:\n        c=max(1, ((n + 3)//6))\n        r=(n + 2)%c\n        q=((n + 2)//c) - 2\n        return q**(c - r)*(q + 1)**r\n    else:\n        q=((n + 2)//6)\n        r=(n + 2)%6\n        return 4**(q - r)*5**r\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A193455", "text": "Paradigm shift sequence with procedure length p=3.", "sequence": "1,2,3,4,5,6,7,8,9,12,16,20,25,30,36,42,49,64,80,100,125,150,180,216,256,320,400,500,625,750,900,1080,1296,1600,2000,2500,3125,3750,4500,5400,6480,8000,10000,12500,15625,18750,22500,27000,32400,40000,50000", "code": "\ndef a(n):\n    c=(n + 6)//8\n    if n<25:\n        if n<10: return n\n        r=(n + 3)%c\n        m=(n + 3 - 3*c)//c\n        return m**(c - r)*(m + 1)**r\n    elif n==25: return 256\n    else:\n        r=(n + 6)%8\n        b=max(0, 3 - r)\n        d=max(0, r - 3)\n        return 4**b*5**(c - (b + d))*6**d\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A193638", "text": "Number of permutations of the multiset {1,1,1,2,2,2,3,3,3,...,n,n,n} with no two consecutive terms equal.", "sequence": "1,0,2,174,41304,19606320,16438575600,22278418248240,45718006789687680,135143407245840698880,553269523327347306412800,3039044104423605600086688000,21819823367694505460651694873600,200345011881335747639978525387827200", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n): return (n - 1)*(3*n - 2)//2 if n<3 else n*((3*n - 1)*(3*n**2 - 5*n + 4)*a(n - 1) + 2*(n - 1)*(6*n**2 - 9*n - 1)*a(n - 2) - 4*n*(n - 1)*(n - 2)*a(n - 3))//(2*n - 2)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A193688", "text": "Number of steps to reach 1 in Collatz (3x+1) problem starting with 2^n - 1.", "sequence": "0,7,16,17,106,107,46,47,61,62,156,157,158,159,129,130,224,225,177,178,303,304,473,474,444,445,384,385,448,449,450,451,527,528,529,530,531,532,533,534,535,536,586,587,588,589,590,591,592,593,594,595,852", "code": "\nfor i in range(1, 100):\n    n = 2**i - 1\n    x = n\n    c = 0\n    while x != 1:\n        c = c + 1\n        if (x & 1) == 0:\n            x = x//2\n        else:\n            x = 3*x + 1\n    print(c)\n\n"}
{"sequence_id": "A193758", "text": "Denominator of H(n)/H(n-1), where H(n) is the n-th harmonic number = Sum_{k=1..n} 1/k.", "sequence": "2,9,22,125,137,343,726,6849,7129,81191,83711,1118273,1145993,1171733,2391514,41421503,42142223,271211719,275295799,55835135,18858053,439143531,1332950097,33695573875,34052522467,309561680403,312536252003,9146733078187,9227046511387", "code": "\nfrom fractions import Fraction\ndef aupton(nn):\n  Hnm1, alst = Fraction(1, 1), []\n  for n in range(2, nn+1):\n    Hn = Hnm1 + Fraction(1, n)\n    alst.append((Hn/Hnm1).denominator)\n    Hnm1 = Hn\n  return alst\nprint(aupton(30)) \n"}
{"sequence_id": "A193890", "text": "Primes p such that replacing any single decimal digit d with 3*d produces another prime (obviously p can contain only digits 0, 1, 2 or 3).", "sequence": "11,311,1301,10133,1030031", "code": "\nfrom sympy import isprime\nfrom itertools import product\nA193890_list = []\nfor l in range(1,10):\n    for d in product('0123',repeat=l):\n        p = int(''.join(d))\n        if d[0] != '0' and d[-1] in ('1','3') and isprime(p):\n            for i in range(len(d)):\n                d2 = list(d)\n                d2[i] = str(3*int(d[i]))\n                if not is_prime(int(''.join(d2))):\n                    break\n            else:\n                 A193890_list.append(p) \n"}
{"sequence_id": "A194112", "text": "a(n) = Sum_{j=1..n} floor(j*sqrt(8)); n-th partial sum of Beatty sequence for sqrt(8).", "sequence": "2,7,15,26,40,56,75,97,122,150,181,214,250,289,331,376,424,474,527,583,642,704,769,836,906,979,1055,1134,1216,1300,1387,1477,1570,1666,1764,1865,1969,2076,2186,2299,2414,2532,2653,2777,2904,3034,3166", "code": "\nfrom sympy import integer_nthroot\ndef A194112(n): return sum(integer_nthroot(8*j**2,2)[0] for j in range(1,n+1)) \n"}
{"sequence_id": "A194116", "text": "a(n) = Sum_{j=1..n} floor(j*sqrt(13)); n-th partial sum of Beatty sequence for sqrt(13).", "sequence": "3,10,20,34,52,73,98,126,158,194,233,276,322,372,426,483,544,608,676,748,823,902,984,1070,1160,1253,1350,1450,1554,1662,1773,1888,2006,2128,2254,2383,2516,2653,2793,2937,3084,3235,3390,3548,3710,3875", "code": "\nfrom sympy import integer_nthroot\ndef A194116(n): return sum(integer_nthroot(13*j**2,2)[0] for j in range(1,n+1)) \n"}
{"sequence_id": "A194137", "text": "a(n) = Sum_{j=1..n} floor(j*sqrt(6)); n-th partial sum of Beatty sequence for sqrt(6).", "sequence": "2,6,13,22,34,48,65,84,106,130,156,185,216,250,286,325,366,410,456,504,555,608,664,722,783,846,912,980,1051,1124,1199,1277,1357,1440,1525,1613,1703,1796,1891,1988,2088,2190,2295,2402,2512,2624,2739,2856", "code": "\nfrom sympy import integer_nthroot\ndef A194137(n): return sum(integer_nthroot(6*j**2,2)[0] for j in range(1,n+1)) \n"}
{"sequence_id": "A194140", "text": "a(n) = Sum_{j=1..n} floor(j*(1+sqrt(3))); n-th partial sum of Beatty sequence for 1+sqrt(3).", "sequence": "2,7,15,25,38,54,73,94,118,145,175,207,242,280,320,363,409,458,509,563,620,680,742,807,875,946,1019,1095,1174,1255,1339,1426,1516,1608,1703,1801,1902,2005,2111,2220,2332,2446,2563,2683,2805,2930,3058", "code": "\nfrom sympy import integer_nthroot\ndef A194140(n): return n*(n+1)//2+sum(integer_nthroot(3*j**2,2)[0] for j in range(1,n+1)) \n"}
{"sequence_id": "A194145", "text": "Beatty sequence for -1+sqrt(6), a(n)=floor(n*(-1+sqrt(6))); complement of A194146.", "sequence": "1,2,4,5,7,8,10,11,13,14,15,17,18,20,21,23,24,26,27,28,30,31,33,34,36,37,39,40,42,43,44,46,47,49,50,52,53,55,56,57,59,60,62,63,65,66,68,69,71,72,73,75,76,78,79,81,82,84,85,86,88,89,91,92,94,95,97,98", "code": "\nfrom sympy import integer_nthroot\ndef A194145(n): return integer_nthroot(6*n**2,2)[0]-n \n"}
{"sequence_id": "A194152", "text": "Beatty sequence for 5+2*sqrt(5); complement of A194151.", "sequence": "9,18,28,37,47,56,66,75,85,94,104,113,123,132,142,151,161,170,179,189,198,208,217,227,236,246,255,265,274,284,293,303,312,322,331,340,350,359,369,378,388,397,407,416,426,435,445,454,464,473,483,492,502", "code": "\nfrom sympy import integer_nthroot\ndef A194152(n): return 5*n+integer_nthroot(20*n**2,2)[0] \n"}
{"sequence_id": "A194195", "text": "First inverse function (numbers of rows) for pairing function A060734", "sequence": "1,2,2,1,3,3,3,2,1,4,4,4,4,3,2,1,5,5,5,5,5,4,3,2,1,6,6,6,6,6,6,5,4,3,2,1,7,7,7,7,7,7,7,6,5,4,3,2,1,8,8,8,8,8,8,8,8,7,6,5,4,3,2,1,9,9,9,9,9,9,9,9,9", "code": "\nt=int(math.sqrt(n-1)) +1\ni=min(t,t**2-n+1)\n"}
{"sequence_id": "A194258", "text": "Second inverse function (numbers of columns) for pairing function A060734.", "sequence": "1,1,2,2,1,2,3,3,3,1,2,3,4,4,4,4,1,2,3,4,5,5,5,5,5,1,2,3,4,5,6,6,6,6,6,6,1,2,3,4,5,6,7,7,7,7,7,7,7,1,2,3,4,5,6,7,8,8,8,8,8,8,8,8,1,2,3,4,5,6,7,8,9,9,9,9,9,9,9,9,9,1,2,3,4,5,6", "code": "\nt=int(math.sqrt(n-1)) +1\nj=min(t,n-(t-1)**2)\n"}
{"sequence_id": "A194274", "text": "Concentric square numbers (see Comments lines for definition).", "sequence": "0,1,4,8,12,17,24,32,40,49,60,72,84,97,112,128,144,161,180,200,220,241,264,288,312,337,364,392,420,449,480,512,544,577,612,648,684,721,760,800,840,881,924,968,1012,1057,1104,1152,1200,1249,1300,1352,1404", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,777):\n    print(str(prpr), end=\", \")\n    curr = n*n - prpr\n    prpr = prev\n    prev = curr\n\n"}
{"sequence_id": "A194280", "text": "Inverse permutation to A081344.", "sequence": "1,2,5,3,6,9,13,8,4,7,12,18,25,19,14,10,15,20,26,33,41,32,24,17,11,16,23,31,40,50,61,51,42,34,27,21,28,35,43,52,62,73,85,72,60,49,39,30,22,29,38,48,59,71,84,98,113", "code": "\nt=int(math.sqrt(n-1))+1\ni=(t % 2)*min(t,n-(t-1)**2) + ((t+1) % 2)*min(t,t**2-n+1)\nj=(t % 2)*min(t,t**2-n+1) + ((t+1) % 2)*min(t,n-(t-1)**2)\nm=(i+j-1)*(i+j-2)/2+j\n"}
{"sequence_id": "A194827", "text": "2-adic valuation of the number of n X n Alternating Sign Matrices (A005130(n)).", "sequence": "0,1,0,1,0,2,2,3,2,2,0,2,2,4,4,5,4,4,2,2,0,3,4,6,6,7,6,8,8,10,10,11,10,10,8,8,6,7,6,6,4,3,0,3,4,7,8,10,10,11,10,11,10,13,14,16,16,17,16,18,18,20,20,21,20,20,18,18,16,17,16,16,14,13,10,11,10,11,10,10", "code": "\n\n\n\n\nn=10000; N=3*n+1; val=[0]*(N+1); exp=2\nwhile exp <= N:\n....for j in range(exp,N+1,exp): val[j] += 1\n....exp *= 2\nfac_val=[0]*(N+1)\nfor i in range(N): fac_val[i+1] = fac_val[i] + val[i+1]\nres=0\nfor i in range(1,n): print(i,res); res += fac_val[3*i+1] + fac_val[i] - fac_val[2*i] - fac_val[2*i+1]\n\n"}
{"sequence_id": "A194850", "text": "Number of prefix normal words of length n.", "sequence": "2,3,5,8,14,23,41,70,125,218,395,697,1273,2279,4185,7568,13997,25500,47414,87024,162456,299947,562345,1043212,1962589,3657530,6900717,12910042,24427486,45850670,86970163,163756708,311283363,587739559,1119581278,2119042830", "code": "\nfrom itertools import product\ndef is_prefix_normal(w):\n  for k in range(1, len(w)+1):\n    weight0 = w[:k].count(\"1\")\n    for j in range(1, len(w)-k+1):\n      weightj = w[j:j+k].count(\"1\")\n      if weightj > weight0: return False\n  return True\ndef a(n):\n  return sum(is_prefix_normal(w) for w in product(\"01\", repeat=n))\nprint([a(n) for n in range(1, 20)]) \n"}
{"sequence_id": "A194952", "text": "Number of Hamiltonian cycles in C_3 X C_n.", "sequence": "48,126,390,1014,2982,8094,23646,66726,196086,568302,1682382,4954998,14750310,43833150,130942398,390959430,1170256854,3502513038,10495480494,31450265622,94296270918,282731526366", "code": "\n\nfrom graphillion import GraphSet\ndef make_CnXCk(n, k):\n    grids = []\n    for i in range(1, k + 1):\n        for j in range(1, n):\n            grids.append((i + (j - 1) * k, i + j * k))\n        grids.append((i + (n - 1) * k, i))\n    for i in range(1, k * n, k):\n        for j in range(1, k):\n            grids.append((i + j - 1, i + j))\n        grids.append((i + k - 1, i))\n    return grids\ndef A194952(n):\n    universe = make_CnXCk(n, 3)\n    GraphSet.set_universe(universe)\n    cycles = GraphSet.cycles(is_hamilton=True)\n    return cycles.len()\nprint([A194952(n) for n in range(3, 30)])  \n"}
{"sequence_id": "A194982", "text": "Inverse permutation to A194981; every positive integer occurs exactly once.", "sequence": "1,2,3,4,6,5,7,9,10,8,11,13,15,14,12,16,18,20,21,19,17,22,24,26,27,28,25,23,29,31,33,34,36,35,32,30,37,39,41,42,44,45,43,40,38,46,48,50,51,53,55,54,52,49,47,56,58,60,61,63,65,66,64,62,59,57,67,69,71", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nif j>=i:\n      result=i*(2*i-1) + (j-i)*(3*i+j-3)/2\nelse:\n      result=j*(2*j-1) + (i-j)*(3*j+i-3)/2+1\n"}
{"sequence_id": "A195065", "text": "Numbers n such that BCR(n) is greater than n, where BCR = binary-complement-and-reverse = A036044.", "sequence": "0,4,8,16,18,20,24,32,34,36,40,44,48,64,66,68,70,72,74,76,80,82,84,88,92,96,100,104,112,128,130,132,134,136,138,140,144,146,148,152,154,156,160,162,164,168,172,176,180,184,188,192,196,200,208,216,224", "code": "\ndef comp(s): z, o = ord('0'), ord('1'); return s.translate({z:o, o:z})\ndef BCR(n): return int(comp(bin(n)[2:])[::-1], 2)\ndef aupto(limit): return [m for m in range(limit+1) if BCR(m) > m]\nprint(aupto(224)) \n"}
{"sequence_id": "A195269", "text": "Smallest n such that 3^n contains n consecutive 0's in its decimal representation.", "sequence": "10,35,148,332,540,540,7722,22793,107189,107189,513335,1847534,5756981,32023025,82011444", "code": "\ndef A195269(n):\n....m, s = 1, '0'*n\n....for i in range(1,10**9):\n........m *= 3\n........if s in str(m):\n............return i\n....return \"search limit reached.\" \n"}
{"sequence_id": "A195302", "text": "Xmas tree primes.", "sequence": "2,3,5,7,211,223,229,241,271,283,311,313,317,331,337,347,353,359,367,373,379,383,389,397,523,541,547,571,719,743,761,773,797,211151,211193,211199,211229,211241,211271,211283,211313,211349,211373,211433,211457,211499,211571,211619,211643,211661,211691,211727,211811,211859,211877,211997,213131", "code": "\nfrom sympy import isprime, sieve\nfrom itertools import product\ndef alst(n):\n  alst, plen = [], 1\n  while True:\n    sieve.extend(10**plen-1)\n    primes = list(str(p) for p in sieve._list)\n    primesbylen = [[p for p in primes if len(p)==i+1] for i in range(plen)]\n    for t in product(*primesbylen):\n      intt = int(\"\".join(t))\n      if isprime(intt): alst.append(intt)\n      if len(alst) == n: return alst\n    plen += 1\nprint(alst(57)) \n"}
{"sequence_id": "A195335", "text": "a(n) is the smallest Xmas tree prime with a(n-1) as a prefix (starting with 2).", "sequence": "2,211,211151,2111511013,211151101310867,211151101310867100673,2111511013108671006731000357,211151101310867100673100035710000931,211151101310867100673100035710000931100000213,2111511013108671006731000357100009311000002131000000901,211151101310867100673100035710000931100000213100000090110000001797", "code": "\nfrom sympy import isprime, nextprime\ndef alst(nn):\n  alst, astr = [2], \"2\"\n  for n in range(2, nn+1):\n    p = nextprime(10**(n-1))\n    while not isprime(int(astr + str(p))): p = nextprime(p)\n    alst.append(int(astr + str(p))); astr += str(p)\n  return alst\nprint(alst(11)) \n"}
{"sequence_id": "A195336", "text": "Smallest number k such that k^n is the sum of numbers in a twin prime pair.", "sequence": "8,6,2,150,96,324,6,1518,174,168,21384,18,20754,2988,2424,8196,3786,14952,34056,48,1620,8256,31344,1176,123360,147456,28650,132,90,12834,81126,11790,2340,9702,11496,33000,10716,66954,6816,234,109956,3012,6744,117654,19950,26550,8226,40584,23640,30660", "code": "\nfrom sympy import isprime\ndef cond(k, n): m = (k**n)//2; return isprime(m-1) and isprime(m+1)\ndef a(n):\n    k = 2\n    while not cond(k, n): k += 2\n    return k\nprint([a(n) for n in range(1, 25)]) \n"}
{"sequence_id": "A195349", "text": "Numbers n such that Sum_{k=1..n} d(k) divides Product_{k=1..n} d(k), where d(k) is the number of divisors of k.", "sequence": "1,7,19,41,57,64,68,133,145,149,164,235,267,291,317,336,358,419,433,503,528,566,599,612,659,726,801,927,1017,1035,1077,1118,1190,1206,1213,1281,1297,1309,1320,1323,1367,1446,1473,1485,1516,1595,1611,1634,1941", "code": "\nfrom sympy import divisor_count\nA195349_list, s, p = [], 0, 1\nfor k in range(1,10**4):\n    d = divisor_count(k)\n    s += d\n    p *= d\n    if p % s == 0:\n        A195349_list.append(k) \n"}
{"sequence_id": "A195527", "text": "Integers n that are k-gonal for precisely 3 distinct values of k, where k >= 3.", "sequence": "15,21,28,51,55,64,70,75,78,91,96,100,111,112,117,126,135,136,141,144,145,148,154,156,165,175,176,186,189,195,201,204,216,232,235,238,246,255,256,285,286,288,291,297,300,306,315,316,321,322,324,330,333,336", "code": "\nA195527_list = []\nfor m in range(1,10**4):\n    n, c = 3, 0\n    while n*(n+1) <= 2*m:\n        if not 2*(n*(n-2) + m) % (n*(n - 1)):\n            c += 1\n            if c > 2:\n                break\n        n += 1\n    if c == 2:\n        A195527_list.append(m) \n"}
{"sequence_id": "A195528", "text": "Integers n that are k-gonal for precisely 4 distinct values of k, where k >= 3.", "sequence": "36,45,66,81,105,120,153,171,190,196,210,261,280,351,378,396,400,405,406,456,465,477,484,496,532,576,585,606,621,630,645,666,715,726,729,736,741,742,765,780,784,801,855,876,891,910,945,960,981,1015,1045,1056", "code": "\nA195528_list = []\nfor m in range(1,10**4):\n    n, c = 3, 0\n    while n*(n+1) <= 2*m:\n        if not 2*(n*(n-2) + m) % (n*(n - 1)):\n            c += 1\n            if c > 3:\n                break\n        n += 1\n    if c == 3:\n        A195528_list.append(m) \n"}
{"sequence_id": "A196149", "text": "Numbers whose divisors increase by a factor of 3 or less.", "sequence": "1,2,3,4,6,8,9,10,12,15,16,18,20,21,24,27,28,30,32,36,40,42,44,45,48,50,54,56,60,63,64,66,70,72,75,78,80,81,84,88,90,96,99,100,102,104,105,108,110,112,117,120,126,128,130,132,135,136,140,144,147,150", "code": "\nfrom sympy import divisors\ndef ok(n):\n    d = divisors(n)\n    return all(d[i]/d[i-1] <= 3 for i in range(1, len(d)))\nprint(list(filter(ok, range(1, 151)))) \n"}
{"sequence_id": "A196168", "text": "In binary representation of n: replace each 0 with 1, and each 1 with 10.", "sequence": "1,2,5,10,11,22,21,42,23,46,45,90,43,86,85,170,47,94,93,186,91,182,181,362,87,174,173,346,171,342,341,682,95,190,189,378,187,374,373,746,183,366,365,730,363,726,725,1450,175,350,349,698,347,694,693,1386", "code": "\ndef a(n):\n    b = bin(n)[2:]\n    return int(b.replace('1', 't').replace('0', '1').replace('t', '10'), 2)\nprint([a(n) for n in range(56)]) \n"}
{"sequence_id": "A196368", "text": "Characteristic function of numbers having in decimal representation only distinct adjacent digits.", "sequence": "1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1", "code": "\nA196368_list = [int(all(str(n)[i] != str(n)[i-1] for i in range(1,len(str(n))))) for n in range(10000)] \n"}
{"sequence_id": "A197123", "text": "a(n) is the first n-digit substring to repeat in the decimal expansion of Pi.", "sequence": "1,26,592,582,60943,949129,8530614,52637962,201890888,4392366484,89879780761,756130190263,3186120489507,18220874234996,276854551127715,8230687217052243,93415455347042966,13724950651727463", "code": "\n\n\nfrom sympy import S; digits_of_pi = str(S.Pi.n(3*10**5)) \ndef a(n):\n  global digits_of_pi\n  seen = set()\n  for i in range(2, len(digits_of_pi)-n):\n    ss = digits_of_pi[i:i+n]\n    if ss in seen: return int(ss)\n    seen.add(ss)\nfor n in range(1, 11):\n  print(a(n), end=\", \") \n"}
{"sequence_id": "A197194", "text": "Binomial(n+9, 9)*9^n", "sequence": "1,90,4455,160380,4691115,118216098,2659862205,54717165360,1046465787510,18836384175180,322102169395578,5270762771927640,83014513657860330,1264374900327411180,18694686026269579590,269203478778281946096,3785673920319589866975,52108688079693178168950,703467289075857905280825", "code": "\nA197194_list, m, k = [], [1]*10, 1\nfor _ in range(10**2):\n    A197194_list.append(k*m[-1])\n    k *= 9\n    for i in range(9):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A198193", "text": "Replace 2^k in the binary representation of n with n+(k-L) where L = floor(log(n)/log(2)).", "sequence": "0,1,2,5,4,8,11,18,8,15,18,28,23,35,39,54,16,30,33,50,38,57,61,83,47,70,74,100,81,109,114,145,32,61,64,96,69,103,107,144,78,116,120,161,127,170,175,221,95,141,145,194,152,203,208,262,165,220,225,283", "code": "\ndef A198193(n): return sum((n-i)*int(j) for i,j in enumerate(bin(n)[2:])) \n"}
{"sequence_id": "A198244", "text": "Primes of the form k^10 + k^9 + k^8 + k^7 + k^6 + k^5 + k^4 + k^3 + k^2 + k + 1 where k is nonprime.", "sequence": "11,10778947368421,17513875027111,610851724137931,614910264406779661,22390512687494871811,22793803793211153712637,79905927161140977116221,184251916941751188170917,319465039747605973452001,1311848376806967295019263,1918542715220370688851293", "code": "\nfrom sympy import isprime\nA198244_list, m = [], [3628800, -15966720, 28828800, -27442800, 14707440, -4379760, 665808, -42240, 682, 0, 1]\nfor n in range(1,10**4):\n....for i in range(10):\n........m[i+1]+= m[i]\n....if not isprime(n) and isprime(m[-1]):\n........A198244_list.append(m[-1]) \n"}
{"sequence_id": "A198375", "text": "Smallest n-digit number whose product of digits is n or 0 if no number exists.", "sequence": "1,12,113,1114,11115,111116,1111117,11111118,111111119,1111111125,0,111111111126,0,11111111111127,111111111111135,1111111111111128,0,111111111111111129,0,11111111111111111145,111111111111111111137,0,0,111111111111111111111138", "code": "\ndef A198375(n): return int(str(A198376(n))[::-1])\nprint([A198375(n) for n in range(1, 25)]) \n"}
{"sequence_id": "A198376", "text": "Largest n-digit number whose product of digits is n or 0 if no such number exists.", "sequence": "1,21,311,4111,51111,611111,7111111,81111111,911111111,5211111111,0,621111111111,0,72111111111111,531111111111111,8211111111111111,0,921111111111111111,0,54111111111111111111,731111111111111111111,0,0,831111111111111111111111", "code": "\ndef A198376(n):\n  ncopy, p, an = n, 1, \"\"\n  for d in range(9, 1, -1):\n    while ncopy%d == 0: ncopy//=d; p *= d; an += str(d)\n  if p == n and len(an) <= n: return int(an+'1'*(n-len(an)))\n  return 0\nprint([A198376(n) for n in range(1, 25)]) \n"}
{"sequence_id": "A198486", "text": "Numbers with the property that all pairs of consecutive digits differ by 9.", "sequence": "1,2,3,4,5,6,7,8,9,90,909,9090,90909,909090,9090909,90909090,909090909,9090909090,90909090909,909090909090,9090909090909,90909090909090,909090909090909,9090909090909090,90909090909090909,909090909090909090,9090909090909090909", "code": "\ndef A198486():\n    print('Numbers whose consecutive digits differ by 9')\n    for i in range(1, 100001):\n        b, n = True, i\n        if n > 9:\n            while n > 9:\n                a = abs((n // 10) % 10 - n % 10)\n                if a != 9: b = False\n                n = n // 10\n        if b: print(i, end=', ')\n    return\n"}
{"sequence_id": "A198584", "text": "Odd numbers producing 3 odd numbers in the Collatz (3x+1) iteration.", "sequence": "3,13,53,113,213,227,453,853,909,1813,3413,3637,7253,7281,13653,14549,14563,29013,29125,54613,58197,58253,116053,116501,218453,232789,233013,464213,466005,466033,873813,931157,932053,932067,1856853,1864021,1864133", "code": "\n\ndef isqrt(n):\n  i=0\n  while(i*i<=n):\n    i+=1\n  return i-1\nfor n in range (200):\n  s = isqrt(3*n)//3\n  a = s*3\n  b = (a*a)//3\n  c = n-b\n  d = 4*(n*3+a+(c<s)+(c>4*s+1)+(c>5*s+1))+5\n  e = isqrt(d)\n  f = e-1-( (d-e*e) >> 1 )\n  r = ((((8<<e)-(1<<f))//3)-1)//3\n  print(r,end =\", \") \n"}
{"sequence_id": "A198584", "text": "Odd numbers producing 3 odd numbers in the Collatz (3x+1) iteration.", "sequence": "3,13,53,113,213,227,453,853,909,1813,3413,3637,7253,7281,13653,14549,14563,29013,29125,54613,58197,58253,116053,116501,218453,232789,233013,464213,466005,466033,873813,931157,932053,932067,1856853,1864021,1864133", "code": "\n\nfor a in range (5,100,1):\n  for b in range(a-8+4*(a&1),0,-6):\n    print(( ((1<<a)-(1<<b))//3-1)//3 ,end=\",\") \n"}
{"sequence_id": "A198794", "text": "a(n) = 5*6^n - 1.", "sequence": "4,29,179,1079,6479,38879,233279,1399679,8398079,50388479,302330879,1813985279,10883911679,65303470079,391820820479,2350924922879,14105549537279,84633297223679,507799783342079,3046798700052479,18280792200314879,109684753201889279", "code": "\ndef a(n):  return 5 * 6**n - 1\nprint([a(n) for n in range(22)]) \n"}
{"sequence_id": "A199110", "text": "a(n) = 7*3^n+1.", "sequence": "8,22,64,190,568,1702,5104,15310,45928,137782,413344,1240030,3720088,11160262,33480784,100442350,301327048,903981142,2711943424,8135830270,24407490808,73222472422,219667417264,659002251790,1977006755368,5931020266102", "code": "\ndef a(n): return 7*3**n + 1\nprint([a(n) for n in range(26)]) \n"}
{"sequence_id": "A199303", "text": "Palindromic primes in the sense of A007500 with digits '0', '1' and '3' only.", "sequence": "3,11,13,31,101,113,131,311,313,1031,1033,1103,1301,3011,3301,10301,10333,11003,11311,13331,30011,30103,31013,31033,33013,33301,101333,110311,113011,113131,131311,133033,133103,301331,301333,330331,333101,333103,1000033,1001003,1001303,1003001", "code": "\nfrom itertools import product\nfrom sympy import isprime\nA199303_list = [n for n in (int(''.join(s)) for s in product('013',repeat=12)) if isprime(n) and isprime(int(str(n)[::-1]))] \n"}
{"sequence_id": "A199328", "text": "Palindromic primes in the sense of A007500 with digits '0', '1' and '8' only.", "sequence": "11,101,181,1181,1811,18181,108881,110881,118081,180181,180811,181081,188011,188801,1008001,1088081,1110881,1180811,1181881,1808801,1880111,1880881,1881811,1881881,10001081,10001801,10011101,10080011,10101181,10111001,10111081,10180801,10188811,10808101,10810001", "code": "\nfrom itertools import product\nfrom sympy import isprime\nA199328_list = [n for n in (int(''.join(s)) for s in product('018',repeat=10)) if isprime(n) and isprime(int(str(n)[::-1]))] \n"}
{"sequence_id": "A199855", "text": "Inverse permutation of A210521.", "sequence": "1,4,2,5,3,6,11,7,12,8,13,9,14,10,15,22,16,23,17,24,18,25,19,26,20,27,21,28,37,29,38,30,39,31,40,32,41,33,42,34,43,35,44,36,45,56,46,57,47,58,48,59,49,60,50,61,51,62,52,63,53,64,54,65,55,66,79", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=(2*j**2+(4*i-5)*j+2*i**2-3*i+2+(2+(-1)**j)*((1-(t+1)*(-1)**i)))/4\n"}
{"sequence_id": "A199986", "text": "Numbers with digital product = 2.", "sequence": "2,12,21,112,121,211,1112,1121,1211,2111,11112,11121,11211,12111,21111,111112,111121,111211,112111,121111,211111,1111112,1111121,1111211,1112111,1121111,1211111,2111111,11111112,11111121,11111211,11112111,11121111,11211111", "code": "\ndef athrough(k1s):\n  return [int(\"1\"*(i-j)+\"2\"+\"1\"*j) for i in range(k1s+1) for j in range(i+1)]\nprint(athrough(8)) \n"}
{"sequence_id": "A199988", "text": "Numbers whose product of digits is 6.", "sequence": "6,16,23,32,61,116,123,132,161,213,231,312,321,611,1116,1123,1132,1161,1213,1231,1312,1321,1611,2113,2131,2311,3112,3121,3211,6111,11116,11123,11132,11161,11213,11231,11312,11321,11611,12113,12131,12311,13112,13121", "code": "\nfrom sympy import prod\nfrom sympy.utilities.iterables import multiset_permutations\ndef agen(maxdigits):\n    for digs in range(1, maxdigits+1):\n        for mp in multiset_permutations(\"1\"*(digs-1) + \"236\", digs):\n            if prod(map(int, mp)) == 6: yield int(\"\".join(mp))\nprint(list(agen(5))) \n"}
{"sequence_id": "A200743", "text": "Divide integers 1..n into two sets, minimizing the difference of their products. This sequence is the smaller product.", "sequence": "1,1,2,4,10,24,70,192,576,1890,6300,21600,78624,294840,1140480,4561920,18849600,79968000,348566400,1559376000,7147140000,33522128640,160745472000,787652812800,3938264064000,20080974513600,104348244639744,552160113120000,2973491173785600,16286186592000000,90678987245246400", "code": "\nfrom itertools import combinations\ndef prod(l):\n    t=1\n    for x in l:\n        t *= x\n    return t\ndef a200743(n):\n    nums = list(range(1,n+1))\n    widths = combinations(nums,n//2)\n    dimensions = [(prod(width),prod(x for x in nums if x not in width)) for width in widths]\n    best = min(dimensions,key=lambda x:max(*x)-min(*x))\n    return min(best)\n\n"}
{"sequence_id": "A200975", "text": "Numbers on the diagonals in Ulam's spiral.", "sequence": "1,3,5,7,9,13,17,21,25,31,37,43,49,57,65,73,81,91,101,111,121,133,145,157,169,183,197,211,225,241,257,273,289,307,325,343,361,381,401,421,441,463,485,507,529,553,577,601,625,651,677,703,729,757,785,813,841,871,901", "code": "\n\nsq = 5\nd = 1\nwhile 2*d - 1 < sq:\n    print(4*d*d - 4*d +1)\n    print(4*d*d - 4*d +1 + 1* 2* d)\n    print(4*d*d - 4*d +1 + 2* 2* d)\n    print(4*d*d - 4*d +1 + 3* 2* d)\n    d += 1\nprint(sq*sq)\n"}
{"sequence_id": "A201009", "text": "Numbers m such that the set of distinct prime divisors of m is equal to the set of distinct prime divisors of the arithmetic derivative m'.", "sequence": "1,4,16,27,108,144,256,432,500,784,972,1323,1728,2700,2916,3125,3456,5292,8788,11664,12500,13068,15376,16875,19683,20736,23328,25000,27648,28125,31212,34300,47916,54000,57132,65536,72000,78732,97556,102400,103788,104544", "code": "\nfrom sympy import primefactors, factorint\nA201009 = [n for n in range(1,10**5) if primefactors(n) == primefactors(sum([int(n*e/p) for p,e in factorint(n).items()]) if n > 1 else 0)] \n"}
{"sequence_id": "A201053", "text": "Nearest cube.", "sequence": "0,1,1,1,1,8,8,8,8,8,8,8,8,8,8,8,8,8,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64", "code": "\nfrom sympy import integer_nthroot\ndef A201053(n):\n    a = integer_nthroot(n,3)[0]\n    return a**3 if 2*n < a**3+(a+1)**3 else (a+1)**3 \n"}
{"sequence_id": "A201055", "text": "Composite numbers whose product of digits is 6.", "sequence": "6,16,32,116,123,132,161,213,231,312,321,611,1116,1132,1161,1312,1611,3112,3211,6111,11116,11123,11132,11231,11312,11611,12131,12311,13112,13211,21113,21131,21311,23111,31112,31211,32111,61111,111116,111123,111132,111161", "code": "\nfrom sympy import prod, isprime\nfrom sympy.utilities.iterables import multiset_permutations\ndef agen(maxdigits):\n    for digs in range(1, maxdigits+1):\n        for mp in multiset_permutations(\"1\"*(digs-1) + \"236\", digs):\n            if prod(map(int, mp)) == 6:\n                t = int(\"\".join(mp))\n                if not isprime(t): yield t\nprint(list(agen(6))) \n"}
{"sequence_id": "A201107", "text": "Primes of the form 2k^3+1.", "sequence": "3,17,251,433,1459,2663,3457,16001,18523,35153,39367,48779,54001,65537,85751,170369,370387,410759,432001,715823,746497,913067,1272113,1557377,1714751,1769473,1940599,2450087,2735263,3456001,4812209,5488001,6615899,6750001", "code": "\nfrom sympy import isprime\nprint(list(filter(isprime, (2*k**3+1 for k in range(152))))) \n"}
{"sequence_id": "A202089", "text": "Numbers n such that n^2 and (n+1)^2 have same digit sum.", "sequence": "4,13,22,49,58,76,103,130,139,157,193,202,229,247,256,274,283,301,391,418,427,454,463,472,481,508,526,553,598,607,616,643,661,679,688,724,733,742,760,769,778,796,850,868,877,886,904,913,931,949,958,976,1003", "code": "\ndef ok(n): return sum(map(int, str(n*n))) == sum(map(int, str((n+1)**2)))\nprint(list(filter(ok, range(1004)))) \n"}
{"sequence_id": "A202358", "text": "Sum of digits of n^(n!).", "sequence": "0,1,4,18,73,334,2592,18919,164476,1558521,1,187044031,2326111614,31214008090", "code": "\nfrom math import factorial\ndef a(n): return sum(map(int, str(n**(factorial(n)))))\nprint([a(n) for n in range(10)]) \n"}
{"sequence_id": "A203306", "text": "Vandermonde determinant of (1!, 2!, 3!, ..., n!).", "sequence": "1,1,1,20,182160,27993556039680,4308936629569882673577984000,58707314863972899718827044647532534690532556800000,8707001005945253804913483804375384209011420702238388319242163029949808640000000000", "code": "\nfrom sympy import factorial, prod\nf = factorial\ndef v(n): return 1 if n<2 else prod(f(k) - f(j) for k in range(2, n + 1) for j in range(1, k))\nprint([v(n) for n in range(11)]) \n"}
{"sequence_id": "A203308", "text": "a(n) = A203306(n+1)/A203306(n).", "sequence": "1,20,9108,153675648,153926018668800,13624548214772203315200,148312029363286484759480524800000,262925014428462931164318003384701335633920000,96950311125839455466119755365478799838570665250861875200000", "code": "\nfrom sympy import factorial as f\nfrom operator import mul\nfrom functools import reduce\ndef v(n):\n    return 1 if n==1 else reduce(mul, (f(k) - f(j) for k in range(2, n + 1) for j in range(1, k)))\nprint([v(n + 1)//v(n) for n in range(1, 15)]) \n"}
{"sequence_id": "A203309", "text": "Vandermonde determinant of the first n triangular numbers.", "sequence": "1,2,30,7560,57153600,20369543040000,495474875767872000000,1124860755259775229696000000000,312577210159744965479388971827200000000000,13502658421660070413446616883411391637094400000000000000", "code": "\nfrom operator import mul\nfrom functools import reduce\ndef f(n): return n*(n + 1)//2\ndef v(n): return 1 if n==1 else reduce(mul, [f(k) - f(j) for k in range(2, n + 1) for j in range(1, k)])\nprint([v(n) for n in range(1, 11)]) \n"}
{"sequence_id": "A203310", "text": "a(n) = A203309(n+1)/A203309(n).", "sequence": "2,15,252,7560,356400,24324300,2270268000,277880803200,43197833952000,8315583035760000,1942008468966720000,540988073497872000000,177227692877902867200000,67457290601651778828000000", "code": "\nfrom operator import mul\nfrom functools import reduce\ndef f(n): return n*(n + 1)//2\ndef v(n): return 1 if n==1 else reduce(mul, (f(k) - f(j) for k in range(2, n + 1) for j in range(1, k)))\nprint([v(n + 1)//v(n) for n in range(1, 15)]) \n"}
{"sequence_id": "A203311", "text": "Vandermonde determinant of (1,2,3,...,F(n+1)), where F=A000045 (Fibonacci numbers).", "sequence": "1,1,2,48,30240,1596672000,18172937502720000,122457316443772566896640000,1284319496829094129116119090331648000000,55603466527142141932748234118927499493985767915520000000", "code": "\nfrom sympy import fibonacci, factorial\nfrom operator import mul\nfrom functools import reduce\ndef f(j): return fibonacci(j + 1)\ndef v(n): return 1 if n==1 else reduce(mul, [reduce(mul, [f(k) - f(j) for j in range(1, k)]) for k in range(2, n + 1)])\nprint([v(n) for n in range(1, 16)]) \n"}
{"sequence_id": "A203312", "text": "Vandermonde sequence using x^2 - xy + y^2 applied to (1,2,...,n).", "sequence": "1,3,147,298116,47460365316,965460013501733568,3717096745012192786213464768,3763515081241454304168766426610670649344,1329626784930718063722475681347135527472012731205697536", "code": "\nfrom operator import mul\nfrom functools import reduce\ndef v(n): return 1 if n==1 else reduce(mul, [j**2 - j*k + k**2 for k in range(2, n + 1) for j in range(1, k)])\nprint([v(n) for n in range(1, 11)]) \n"}
{"sequence_id": "A203313", "text": "a(n) = v(n)/A000178(n) where v=A203311 and A000178=(superfactorials).", "sequence": "1,1,1,4,105,46200,730329600,976445416826880,253989513002664748108800,30302715258078626805231995747942400,3921367125196579314580337108803595790318851635200,1315258359298445647817718300301463137710018409451973278413455360000", "code": "\nfrom sympy import fibonacci, factorial\nfrom operator import mul\nfrom functools import reduce\ndef f(j): return fibonacci(j + 1)\ndef v(n): return 1 if n==1 else reduce(mul, [reduce(mul, [f(k) - f(j) for j in range(1, k)]) for k in range(2, n + 1)])\ndef d(n): return reduce(mul, [factorial(i - 1) for i in range(1, n + 1)])\nprint([v(n)//d(n) for n in range(1, 14)]) \n"}
{"sequence_id": "A203513", "text": "a(n) = A203312(n+1)/A203312(n).", "sequence": "3,49,2028,159201,20342448,3850078401,1012487793408,353293863908769,157973407966483200,88087149666575064369,59928191584204259377152,48860028872008706126041281", "code": "\nfrom operator import mul\nfrom functools import reduce\ndef v(n): return 1 if n==1 else reduce(mul, [reduce(mul, [j**2 - j*k + k**2 for j in range(1, k)]) for k in range(2, n + 1)])\nprint([v(n + 1)//v(n) for n in range(1, 13)]) \n"}
{"sequence_id": "A203601", "text": "a(0)=1, a(n+1) = (a(n)*7) XOR a(n).", "sequence": "1,6,44,280,1712,10336,78528,610688,4745984,28476928,173222912,1108678656,6652604416,48774012928,292681859072,1757200613376,11780162781184,70685271916544,424730711293952,3116299774853120,19823698692276224,120070359807426560,720738827865423872", "code": "\na=1\nfor n in range(55):\n    print(a, end=',')\n    a ^= a*7\n"}
{"sequence_id": "A203622", "text": "a(n) = (a(n-1) OR a(n-2)) XOR n.", "sequence": "0,1,3,0,7,2,1,4,13,4,7,12,3,2,13,0,29,12,15,28,11,10,29,8,5,20,15,4,19,10,5,16,53,20,23,52,19,18,53,16,29,52,23,28,51,18,29,48,13,12,63,12,11,58,13,8,53,4,15,52,3,10,53,0,117,52,55,116,51,50,117", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,77):\n    current = (prev | prpr) ^ n\n    print(prpr, end=',')\n    prpr = prev\n    prev = current\n"}
{"sequence_id": "A203717", "text": "A Catalan triangle by rows.", "sequence": "1,1,1,1,3,1,1,8,4,1,1,20,15,5,1,1,50,53,21,6,1,1,126,182,84,28,7,1,1,322,616,326,120,36,8,1,1,834,2070,1242,495,165,45,9,1,1,2187,6930,4680,1997,715,220,55,10,1,1,5797,23166,17512,7942,3003,1001,286,66,11,1", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(u, o, k): return 1 if u + o==0 else sum([b(u - j, o + j - 1, k) for j in range(1, min(1, u) + 1)]) + sum([b(u + j - 1, o - j, k) for j in range(1, min(k, o) + 1)])\ndef T(n, k): return b(0, n, k) - (0 if k==0 else b(0, n, k - 1))\nfor n in range(1, 16): print([T(n, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A203718", "text": "Binary sequence where each successive term is made by appending to the previous term the next smallest positive binary integer that is not already contained within it.", "sequence": "1,110,110100,110100111,1101001111000,11010011110001011,1101001111000101110000,110100111100010111000010010,11010011110001011100001001010101,1101001111000101110000100101010110110,110100111100010111000010010101011011011001", "code": "\ndef A203718(n, seed = '1'):\n    \"\"\"\n    Returns the n-th term of the sequence.\n    Optionally specified seed.\n    \"\"\"\n    i = 0\n    term = seed\n    next_int = 1\n    while i < n:\n        b = bin(next_int)[2:]\n        if b not in term:\n            term += b\n            i += 1\n        next_int += 1\n    return term\ndef A203718_list(stop, start = 0, seed = '1'):\n    \"\"\"\n    Returns a slice of the sequence up to the specified index.\n    Seed and starting index optional\n    \"\"\"\n    terms = [seed]\n    term = seed\n    i = 0\n    next_int = 1\n    while i < stop:\n        b = bin(next_int)[2:]\n        if b not in term:\n            term += b\n            if start <= i:\n                terms.append(term)\n            i += 1\n        next_int += 1\n    return terms\n"}
{"sequence_id": "A204089", "text": "The number of 1 by n Haunted Mirror Maze puzzles with a unique solution ending with a mirror, where mirror orientation is fixed.", "sequence": "1,1,4,14,48,164,560,1912,6528,22288,76096,259808,887040,3028544,10340096,35303296,120532992,411525376,1405035520,4797091328,16378294272,55918994432,190919389184,651839567872,2225519493120,7598398836736,25942556360704,88573427769344", "code": "\ndef a(n, d={0:1,1:4}):\n.if n in d:\n..return d[n]\n.d[n]=4*a(n-1) - 2*a(n-2)\n.return d[n]\n"}
{"sequence_id": "A204089", "text": "The number of 1 by n Haunted Mirror Maze puzzles with a unique solution ending with a mirror, where mirror orientation is fixed.", "sequence": "1,1,4,14,48,164,560,1912,6528,22288,76096,259808,887040,3028544,10340096,35303296,120532992,411525376,1405035520,4797091328,16378294272,55918994432,190919389184,651839567872,2225519493120,7598398836736,25942556360704,88573427769344", "code": "\n\ndef Mprint(n):\n.print('The following generate boards with a unique solution')\n.s=0\n.for x in product(['Z', 'V', 'G', '/'], repeat=n):\n..if x[-1]=='/':\n...\n...y=list(x)\n...z=list()\n...while y:\n....\n....if '/' in y:\n.....if y[0] != '/': \n......z.append(y[:y.index('/')])\n.....y=y[y.index('/')+1:]\n....else:\n.....z.append(y)\n.....y=[]\n...\n...goodword=True\n...for w in z:\n....if 'Z' in w and 'V' in w:\n.....goodword=False\n...if goodword:\n....s+=1\n....print(x)\n.return s\n"}
{"sequence_id": "A204090", "text": "The number of 1 X n Haunted Mirror Maze puzzles with a unique solution where mirror orientation is fixed.", "sequence": "1,2,8,34,134,498,1786,6274,21778,75074,257762,882946,3020354,10323714,35270530,120467458,411394306,1404773378,4796567042,16377245698,55916897282,190915194882,651831179266,2225502715906,7598365282306,25942489251842,88573293551618", "code": "\ndef a(n, d={0:1,1:2,2:8,3:34}):\n.if n in d:\n..return d[n]\n.d[n]=7*a(n-1) - 16*a(n-2) + 14*a(n-3) - 4*a(n-4)\n.return d[n]\n"}
{"sequence_id": "A204090", "text": "The number of 1 X n Haunted Mirror Maze puzzles with a unique solution where mirror orientation is fixed.", "sequence": "1,2,8,34,134,498,1786,6274,21778,75074,257762,882946,3020354,10323714,35270530,120467458,411394306,1404773378,4796567042,16377245698,55916897282,190915194882,651831179266,2225502715906,7598365282306,25942489251842,88573293551618", "code": "\n\ndef Hprint(n):\n.print('The following generate boards with a unique solution')\n.s=0\n.for x in product(['Z','V','G','/'],repeat=n):\n..\n..if '/' not in x:\n...if 'Z' not in x and 'V' not in x:\n....s+=1\n....print(x)\n..else:\n...\n...y=list(x)\n...z=list()\n...while y:\n....if '/' in y:\n.....if y[0] != '/': \n......z.append(y[:y.index('/')])\n.....y=y[y.index('/')+1:]\n....else:\n.....z.append(y)\n.....y=[]\n...\n...goodword=True\n...for w in z:\n....if 'Z' in w and 'V' in w:\n.....goodword=False\n...if goodword:\n....s+=1\n....print(x)\n.return s\n"}
{"sequence_id": "A204091", "text": "The number of 1 X n Haunted Mirror Maze puzzles with a unique solution ending with a mirror.", "sequence": "1,2,10,46,210,958,4370,19934,90930,414782,1892050,8630686,39369330,179585278,819187730,3736768094,17045465010,77753788862,354678014290,1617882493726,7380056440050,33664517212798,153562473183890,700483331493854,3195291711101490", "code": "\ndef a(n, d={0:1,1:2,2:10}):\nif n in d:\nreturn d[n]\nd[n]=5*a(n-1) - 2*a(n-2)\nreturn d[n]\n"}
{"sequence_id": "A204091", "text": "The number of 1 X n Haunted Mirror Maze puzzles with a unique solution ending with a mirror.", "sequence": "1,2,10,46,210,958,4370,19934,90930,414782,1892050,8630686,39369330,179585278,819187730,3736768094,17045465010,77753788862,354678014290,1617882493726,7380056440050,33664517212798,153562473183890,700483331493854,3195291711101490", "code": "\n\ndef Lprint(n):\n.print('The following generate boards with a unique solution')\n.s=0\n.for x in product(['Z','V','G','/','|'],repeat=n):\n..if x[-1]=='/' or x[-1]=='|':\n...\n...y=list(x)\n...z=list()\n...while y:\n....if '/' in y or '|' in y:\n.....if '/' in y and '|' in y:\n......m = min(y.index('/'), y.index('|'))\n.....else:\n......if '/' in y:\n.......m=y.index('/')\n......else:\n.......m=y.index('|')\n.....if y[0] not in ['/','|']: \n......z.append(y[:m])\n.....y=y[m+1:]\n....else:\n.....z.append(y)\n.....y=[]\n...\n...goodword=True\n...for w in z:\n....if 'Z' in w and 'V' in w:\n.....goodword=False\n...if goodword:\n....s+=1\n....print(x)\n.return s\n"}
{"sequence_id": "A204092", "text": "The number of 1 by n Haunted Mirror Maze puzzles with a unique solution.", "sequence": "1,3,17,91,449,2123,9841,45211,206881,945003,4313297,19680571,89784449,409577483,1868351281,8522666971,38876763361,177338745003,808940722577,3690027171451,16832256509249,76781232397643,350241657358321,1597645838773531,7287745912705441", "code": "\ndef a(n, d={0:1,1:3,2:17,3:91}):\n.if n in d:\n..return d[n]\n.d[n]=8*a(n-1) - 19*a(n-2) + 16*a(n-3) - 4*a(n-4)\n.return d[n]\n"}
{"sequence_id": "A204092", "text": "The number of 1 by n Haunted Mirror Maze puzzles with a unique solution.", "sequence": "1,3,17,91,449,2123,9841,45211,206881,945003,4313297,19680571,89784449,409577483,1868351281,8522666971,38876763361,177338745003,808940722577,3690027171451,16832256509249,76781232397643,350241657358321,1597645838773531,7287745912705441", "code": "\n\ndef Kprint(n):\n.print('The following generate boards with a unique solution')\n.s=0\n.for x in product(['Z','V','G','/','|'],repeat=n):\n..\n..if '/' not in x and '|' not in x:\n...if 'Z' not in x and 'V' not in x:\n....s+=1\n....print(x)\n..else:\n...\n...y=list(x)\n...z=list()\n...while y:\n....if '/' in y or '|' in y:\n.....if '/' in y and '|' in y:\n......m = min(y.index('/'), y.index('|'))\n.....else:\n......if '/' in y:\n.......m=y.index('/')\n......else:\n.......m=y.index('|')\n.....if y[0] not in ['/','|']: \n......z.append(y[:m])\n.....y=y[m+1:]\n....else:\n.....z.append(y)\n.....y=[]\n...\n...goodword=True\n...for w in z:\n....if 'Z' in w and 'V' in w:\n.....goodword=False\n...if goodword:\n....s+=1\n....print(x)\n.return s\n"}
{"sequence_id": "A204093", "text": "Numbers whose set of base-10 digits is {0,6}.", "sequence": "0,6,60,66,600,606,660,666,6000,6006,6060,6066,6600,6606,6660,6666,60000,60006,60060,60066,60600,60606,60660,60666,66000,66006,66060,66066,66600,66606,66660,66666,600000,600006,600060,600066,600600,600606,600660,600666", "code": "\ndef a(n): return int(bin(n)[2:].replace('1', '6'))\nprint([a(n) for n in range(40)]) \n"}
{"sequence_id": "A204219", "text": "Primes whose binary reversal is not prime.", "sequence": "2,19,59,79,89,103,109,137,139,149,157,179,191,211,239,241,271,281,293,311,317,347,367,379,389,397,401,419,439,457,467,499,523,541,547,557,563,569,587,593,607,613,641,647,659,673,719,733,743,751,761,769,787,809,811,829,859,863,877,887,919,929,971,977,983,991,997", "code": "\nfrom sympy import isprime, primerange\ndef ok(p): return not isprime(int(bin(p)[:1:-1], 2))\ndef aupto(lim): return [p for p in primerange(2, lim+1) if ok(p)]\nprint(aupto(1000)) \n"}
{"sequence_id": "A204232", "text": "Numbers whose binary reversal is prime.", "sequence": "3,5,6,7,10,11,12,13,14,17,20,22,23,24,25,26,28,29,31,34,37,40,41,43,44,46,47,48,50,52,53,55,56,58,61,62,67,68,71,73,74,77,80,82,83,86,88,91,92,94,96,97,100,101,104,106,107,110,112,113,115,116,121", "code": "\nfrom sympy import isprime\ndef ok(n): return isprime(int(bin(n)[2:][::-1], 2))\nprint(list(filter(ok, range(1, 122)))) \n"}
{"sequence_id": "A204771", "text": "a(n) = a(n-1) XOR (a(n-2)*3).", "sequence": "0,1,1,2,1,7,4,17,29,46,121,243,408,833,1929,3658,6353,12815,30844,61009,100133,216534,514233,930107,1686288,3352737,8264081,15163506,27077825,53153175,133991380,243114769,428343405,854649182,2120804377,3870970883,6937439304", "code": "\nprpr = 0\nprev = 1\nfor i in range(99):\n    current = (prev)^(prpr*3)\n    print(prpr, end=',')\n    prpr = prev\n    prev = current\n"}
{"sequence_id": "A204914", "text": "Ordered differences of squared primes.", "sequence": "5,21,16,45,40,24,117,112,96,72,165,160,144,120,48,285,280,264,240,168,120,357,352,336,312,240,192,72,525,520,504,480,408,360,240,168,837,832,816,792,720,672,552,480,312,957,952,936,912,840,792,672", "code": "\nfrom math import sqrt\nfrom sympy import prime, primerange\ndef aupton(terms):\n  sqps = [p*p for p in primerange(1, prime(isqrt(2*terms)+1)+1)]\n  return [b-a for i, b in enumerate(sqps) for a in sqps[:i]][:terms]\nprint(aupton(52)) \n"}
{"sequence_id": "A205493", "text": "Third row or column of table A205497.", "sequence": "1,14,109,623,2951,12331,47191,169416,579889,1914226,6144668,19298724,59579803,181448918,546629054,1632497850,4841448042,14277423006,41912838982,122587133760,357476552161,1039922075888,3019280091491,8752184436454,25337900299765", "code": " \n"}
{"sequence_id": "A205497", "text": "Rectangular array M read by antidiagonals in which entry M_{n-k,k} in row n-k and column k, 0 <= k <= n, gives the coefficient of x^k in the numerator of the conjectured generating function for row n+3 of the tabular form of A050446.", "sequence": "1,1,1,1,3,1,1,7,7,1,1,14,31,14,1,1,26,109,109,26,1,1,46,334,623,334,46,1,1,79,937,2951,2951,937,79,1,1,133,2475,12331,20641,12331,2475,133,1,1,221,6267,47191,123216,123216,47191,6267,221,1", "code": " Replace prepended dots with spaces.\nprint(\"\\n\")\nt_rows = 100\nt_cols = 101\nc_rows = 102\nc_cols = 102\nr_rows = 101\nr_cols = 101\n\n\n.t = [] for a in range(0,t_rows*t_cols):\n..t.append(0)\nfor n in range(0,t_rows):\n..t[n*t_cols]=1\nfor m in range(0,t_cols):\n..t[m]=1\nfor n in range(1,t_rows):\n..for m in range(1,t_cols):\n....s=0\n....for k in range(0,int((n-1)/2)+1):\n......s=s+t[2*k*t_cols+m-1]*t[(n-1-2*k)*t_cols+m]\n....t[n*t_cols+m]=t[n*t_cols+m-1]+s\n\nc = [] for a in range(0,c_rows*c_cols):\n..c.append(0) c[0] = 1\nfor n in range(1,c_rows):\n..for k in range(1, n + 1):\n....c[n*c_cols+k]=c[(n-1)*c_cols+k]+c[(n-1)*c_cols+k-1]\n\nfor n in range(1,c_rows):\n..for k in range(1, n + 1):\n....if k%2 == 0:\n......c[n*c_cols+k]=-c[n*c_cols+k]\n\nr = [] for a in range(0,r_rows*r_cols):\n..r.append(0)\nfor n in range(1,r_rows):\n..for k in range(0,n+1):\n....for j in range(0,k+1):\n......r[n * r_cols + k] = r[n * r_cols + k] + c[(n + 1) * c_cols + j + 1] * t[(n - 1) * t_cols + k - j]\nfor n in range(1, _rows):\n..a = \"\"\n..for k in range(0,n-2):\n....a=a+str(r[n*r_cols+k])+\" \"\n..print(a)\n\n"}
{"sequence_id": "A205770", "text": "Powers of fifth root of 100, rounded to the nearest integer.", "sequence": "1,3,6,16,40,100,251,631,1585,3981,10000,25119,63096,158489,398107,1000000,2511886,6309573,15848932,39810717,100000000,251188643,630957344,1584893192,3981071706,10000000000,25118864315,63095734448,158489319246,398107170553,1000000000000", "code": "\nfrom gmpy2 import iroot\ndef A205770(n):\n    m = 100**n\n    i = iroot(m,5)[0]\n    return int(i) + int(32*m >= (1+2*i)**5) \n"}
{"sequence_id": "A206296", "text": "Prime factorization representation of Fibonacci polynomials: a(0) = 1, a(1) = 2, and for n > 1, a(n) = A003961(a(n-1)) * a(n-2).", "sequence": "1,2,3,10,63,2750,842751,85558343750,2098355820117528699,769999781728184386440152910156250,2359414683424785920146467280333749864720543920418139851", "code": "\nfrom sympy import factorint, prime, primepi\nfrom operator import mul\ndef a003961(n):\n    F=factorint(n)\n    return 1 if n==1 else reduce(mul, [prime(primepi(i) + 1)**F[i] for i in F])\nl=[1, 2]\nfor n in range(2, 11):\n    l.append(a003961(l[n - 1])*l[n - 2])\nprint(l) \n"}
{"sequence_id": "A206481", "text": "a(n) + a(n+2) = n^3.", "sequence": "0,1,1,7,26,57,99,159,244,353,485,647,846,1081,1351,1663,2024,2433,2889,3399,3970,4601,5291,6047,6876,7777,8749,9799,10934,12153,13455,14847,16336,17921,19601,21383,23274,25273,27379,29599,31940,34401,36981,39687", "code": "\nprpr = 0\nprev = 1\nfor n in range(1,77):\n    print(prpr, end=',')\n    curr = n*n*n - prpr    \n    prpr = prev\n    prev = curr\n"}
{"sequence_id": "A206492", "text": "Sums of rows of the sequence of triangles with nonnegative integers and row widths defined by A004738.", "sequence": "0,3,3,9,21,19,11,25,45,74,66,49,26,55,90,134,190,170,138,97,50,103,162,230,310,405,365,310,243,167,85,173,267,370,485,615,763,693,605,502,387,263,133,269,411,562,725,903,1099,1316,1204,1071,920,754,576,389", "code": "\ncurSign=-1\ncurLength=sum=0\nrowLength=topLength=1\nfor n in range(1232):\n    sum += n\n    curLength += 1\n    if curLength==rowLength:\n        print(sum, end=',')\n        curLength = sum = 0\n        if rowLength==1 or rowLength==topLength:\n            curSign = -curSign\n        topLength += (rowLength==1)\n        rowLength += curSign\n"}
{"sequence_id": "A206578", "text": "The least number with exactly n ones in the continued fraction of its square root.", "sequence": "2,3,14,7,13,91,43,115,94,819,133,1075,211,1219,309,871,421,1147,244,3427,478,2575,991,8791,604,3799,886,5539,1381,8851,1279,7303,1561,19519,1759,10339,1831,12871,2038,13771,1999,8611,1516,15871,2731,20875,1726", "code": "\nfrom sympy import continued_fraction_periodic\ndef A206578(n):\n    m = 1\n    while True:\n        s = continued_fraction_periodic(0,1,m)[-1]\n        if isinstance(s,list) and s.count(1) == n:\n            return m\n        m += 1 \n"}
{"sequence_id": "A206585", "text": "The least number s > 1 having exactly n fives in the periodic part of the continued fraction of sqrt(s).", "sequence": "2,27,67,664,331,6487,1237,6019,1999,6331,3964,23983,4204,22075,9739,64639,10684,26419,17971,80719,22969,140971,28414,310759,34189,290779,39181,228691,46099,261691,56884,416707,61429,136579,76651,535375,75916,296839,87151", "code": "\nfrom sympy import continued_fraction_periodic\ndef A206585(n):\n    i = 2\n    while True:\n        s = continued_fraction_periodic(0,1,i)[-1]\n        if isinstance(s, list) and s.count(5) == n:\n            return i\n        i += 1 \n"}
{"sequence_id": "A206709", "text": "Number of primes of the form b^2 + 1 for b <= 10^n.", "sequence": "5,19,112,841,6656,54110,456362,3954181,34900213,312357934,2826683630,25814570672,237542444180,2199894223892", "code": "\nfrom sympy import isprime\ndef A206709(n):\n    c, b, b2, n10 = 0, 1, 2, 10**n\n    while b <= n10:\n        if isprime(b2):\n            c += 1\n        b += 1\n        b2 += 2*b - 1\n    return c \n"}
{"sequence_id": "A206743", "text": "G.f.: 1/(1 - x/(1 - x^2/(1 - x^5/(1 - x^12/(1 - x^29/(1 - x^70/(1 -...- x^Pell(n)/(1 -...)))))))), a continued fraction.", "sequence": "1,1,1,2,3,5,8,13,22,36,60,99,164,272,450,746,1235,2046,3389,5613,9299,15402,25514,42262,70005,115962,192084,318182,527053,873043,1446161,2395504,3968060,6572925,10887788,18035177,29874537,49485965,81971484,135782448", "code": "\nN = 1000\npell = [0,1]\nc = 2\nwhile c < N:\n....pell.append(c)\n....c = pell[-1]*2 + pell[-2]\npell.reverse()\ngf = [0]*(N+1)\nfor p in pell:\n....gf = [-x for x in gf]\n....gf[0] += 1\n....quotient = [0]*(N+1)\n....remainder = [0]*(N+1)\n....remainder[p] = 1\n....for n in range(N+1):\n........q = remainder[n]//gf[0]\n........for i in range(n,N+1):\n............remainder[i] -= q*gf[i-n]\n........quotient[n] = q\n....gf = quotient\nfor i in range(N+1):\n....print(i,gf[i])\n\n"}
{"sequence_id": "A206772", "text": "Table T(n,k)=max{4*n+k-4,n+4*k-4} n, k > 0, read by antidiagonals.", "sequence": "1,5,5,9,6,9,13,10,10,13,17,14,11,14,17,21,18,15,15,18,21,25,22,19,16,19,22,25,29,26,23,20,20,23,26,29,33,30,27,24,21,24,27,30,33,37,34,31,28,25,25,28,31,34,37,41,38,35,32,29,26,29,32,35,38,41,45", "code": "\nt=int((math.sqrt(8*n-7)-1)/2)\nresult=4*(t+1)+3*max(t*(t+1)/2-n,n-(t*t+3*t+4)/2)\n"}
{"sequence_id": "A206901", "text": "Number of nonisomorphic graded posets with 0 of rank n with no 3-element antichain.", "sequence": "1,2,8,39,199,1027,5316,27539,142694,739416,3831589,19855045,102887673,533158028,2762794601,14316644946,74188042696,384438233215,1992137140383,10323141778619,53493935746148,277202543857995,1436447874880342,7443591492820888", "code": "\ndef a(n,adict={0:1,1:2,2:8}):\n    if n in adict:\n        return adict[n]\n    adict[n]=7*a(n-1)-10*a(n-2)+3*a(n-3)\n    return adict[n]\n"}
{"sequence_id": "A206902", "text": "Number of nonisomorphic graded posets with 0 and uniform Hasse diagram of rank n with no 3-element antichain.", "sequence": "1,2,8,36,166,768,3554,16446,76102,352152,1629536,7540458,34892452,161460114,747134894,3457265922,15998031616,74028732924,342557973998,1585140808368,7335025230994,33941839649382,157061283704438,726779900373936,3363075935260696", "code": "\ndef a(n, adict={1:2,2:8,3:36}):\n    if n in adict:\n        return adict[n]\n    adict[n]=6*a(n-1)-7*a(n-2)+3*a(n-3)\n    return adict[n]\n"}
{"sequence_id": "A206947", "text": "Number of nonisomorphic graded posets with 0 and non-uniform Hasse graph of rank n, with exactly 2 elements of each rank above 0.", "sequence": "0,0,0,2,14,70,306,1248,4888,18666,70110,260414,959882,3519232,12854064,46824210,170243566,618125238,2242100898,8126927456,29442587720,106626616954,386046638142,1397431266222,5057790129274,18304064121600,66237312391776", "code": "\ndef a(n,adict={0:0,1:0,2:0,3:2,4:14}):\n    if n in adict:\n        return adict[n]\n    adict[n]=8*a(n-1)-21*a(n-2)+20*a(n-3)-5*a(n-4)\n    return adict[n]\n"}
{"sequence_id": "A206948", "text": "Number of nonisomorphic graded posets with 0 and non-uniform Hasse graph of rank n, with exactly 2 elements of each rank level above 0.", "sequence": "0,0,0,2,19,131,791,4446,23913,124892,638878,3218559,16027375,79093773,387540260,1887974063,9154751912,44221373872,212931964415,1022594028515,4900116587043,23437066655010,111923110602497", "code": "\ndef a(n, adict={0:0, 1:0, 2:0, 3:2, 4:19, 5:131}):\n  if n in adict:\n    return adict[n]\n  adict[n]=11*a(n-1)-40*a(n-2)+55*a(n-3)-30*a(n-4)+6*a(n-5)\n  return adict[n]\nfor n in range(0,40):\n  print(a(n))\n"}
{"sequence_id": "A206949", "text": "Number of nonisomorphic graded posets with 0 and non-uniform Hasse graph of rank n, with no 3-element antichain.", "sequence": "0,0,0,3,24,135,657,2961,12744,53244,218025,880308,3518721,13961727,55097091,216546048,848476296,3316800555,12942852624,50437433079,196347606849,763752142233,2969021213928,11536374392820,44809232564673,173997851613660,675501426136017", "code": "\ndef a(n,adict={0:0,1:0,2:0,3:3,4:24}):\n    if n in adict:\n        return adict[n]\n    adict[n]=9*a(n-1)-27*a(n-2)+30*a(n-3)-9*a(n-4)\n    return adict[n]\n"}
{"sequence_id": "A206950", "text": "Number of nonisomorphic graded posets with 0 and non-uniform Hasse graph of rank n, with no 3-element antichain.", "sequence": "0,0,0,3,33,259,1762,11093,66592,387264,2202053,12314587,67995221,371697914,2015659707,10859379024,58190011080,310409500291,1649579166385,8738000970251,46158910515154,243260704208613,1279386591175904,6716811592446952,35209193397256085", "code": "\ndef a(n,adict={0:0,1:0,2:0,3:3,4:33,5:259,6:1762}):\n    if n in adict:\n        return adict[n]\n    adict[n]=13*a(n-1)-59*a(n-2)+115*a(n-3)-109*a(n-4)+51*a(n-5)-9*a(n-6)\n    return adict[n]\n"}
{"sequence_id": "A207063", "text": "a(n) is the smallest number larger than a(n-1) with mutual Hamming distance 2 and a(1)=0.", "sequence": "0,3,5,6,10,12,15,23,27,29,30,46,54,58,60,63,95,111,119,123,125,126,190,222,238,246,250,252,255,383,447,479,495,503,507,509,510,766,894,958,990,1006,1014,1018,1020,1023,1535,1791,1919,1983,2015,2031,2039,2043", "code": "\ndef aupton(terms):\n    alst = [0]\n    for n in range(2, terms+1):\n        an = alst[-1] + 1\n        while bin(an^alst[-1]).count('1') != 2:  an += 1\n        alst.append(an)\n    return alst\nprint(aupton(54)) \n"}
{"sequence_id": "A207605", "text": "Triangle of coefficients of polynomials u(n,x) jointly generated with A106195; see the Formula section.", "sequence": "1,2,4,1,8,4,1,16,12,5,1,32,32,18,6,1,64,80,56,25,7,1,128,192,160,88,33,8,1,256,448,432,280,129,42,9,1,512,1024,1120,832,450,180,52,10,1,1024,2304,2816,2352,1452,681,242,63,11,1,2048,5120,6912,6400,4424,2364,985,316,75,12,1", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef u(n, x): return 1 if n==1 else u(n - 1, x) + v(n - 1, x)\ndef v(n, x): return 1 if n==1 else u(n - 1, x) + (x + 1)*v(n - 1, x)\ndef a(n): return Poly(u(n, x), x).all_coeffs()[::-1]\nfor n in range(1, 13): print(a(n)) \n"}
{"sequence_id": "A207606", "text": "Triangle of coefficients of polynomials u(n,x) jointly generated with A207607; see the Formula section.", "sequence": "1,2,3,2,4,7,2,5,16,11,2,6,30,36,15,2,7,50,91,64,19,2,8,77,196,204,100,23,2,9,112,378,540,385,144,27,2,10,156,672,1254,1210,650,196,31,2,11,210,1122,2640,3289,2366,1015,256,35,2,12,275,1782,5148,8008", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef u(n, x): return 1 if n==1 else u(n - 1, x) + v(n - 1, x)\ndef v(n, x): return 1 if n==1 else x*u(n - 1, x) + (x + 1)*v(n - 1, x)\ndef a(n): return Poly(u(n, x), x).all_coeffs()[::-1]\nfor n in range(1, 13): print(a(n)) \n"}
{"sequence_id": "A207607", "text": "Triangle of coefficients of polynomials v(n,x) jointly generated with A207606; see Formula section.", "sequence": "1,1,2,1,5,2,1,9,9,2,1,14,25,13,2,1,20,55,49,17,2,1,27,105,140,81,21,2,1,35,182,336,285,121,25,2,1,44,294,714,825,506,169,29,2,1,54,450,1386,2079,1716,819,225,33,2,1,65,660,2508,4719,5005,3185,1240,289,37,2", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef u(n, x): return 1 if n==1 else u(n - 1, x) + v(n - 1, x)\ndef v(n, x): return 1 if n==1 else x*u(n - 1, x) + (x + 1)*v(n - 1, x)\ndef a(n): return Poly(v(n, x), x).all_coeffs()[::-1]\nfor n in range(1, 13): print(a(n)) \n"}
{"sequence_id": "A207608", "text": "Triangle of coefficients of polynomials u(n,x) jointly generated with A207609; see the Formula section.", "sequence": "1,2,3,3,4,11,3,5,26,20,3,6,50,74,29,3,7,85,204,149,38,3,8,133,469,547,251,47,3,9,196,952,1618,1160,380,56,3,10,276,1764,4110,4234,2124,536,65,3,11,375,3048,9318,13036,9262,3520,719,74,3,12,495,4983", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef u(n, x): return 1 if n==1 else u(n - 1, x) + v(n - 1, x)\ndef v(n, x): return 1 if n==1 else 2*x*u(n - 1, x) + (x + 1)*v(n - 1, x)\ndef a(n): return Poly(u(n, x), x).all_coeffs()[::-1]\nfor n in range(1, 13): print(a(n)) \n"}
{"sequence_id": "A207609", "text": "Triangle of coefficients of polynomials v(n,x) jointly generated with A207608; see Formula section.", "sequence": "1,1,3,1,8,3,1,15,17,3,1,24,54,26,3,1,35,130,120,35,3,1,48,265,398,213,44,3,1,63,483,1071,909,333,53,3,1,80,812,2492,3074,1744,480,62,3,1,99,1284,5208,8802,7138,2984,654,71,3,1,120,1935,10020,22230,24408,14370,4710,855,80,3", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef u(n, x): return 1 if n==1 else u(n - 1, x) + v(n - 1, x)\ndef v(n, x): return 1 if n==1 else 2*x*u(n - 1, x) + (x + 1)*v(n - 1, x)\ndef a(n): return Poly(v(n, x), x).all_coeffs()[::-1]\nfor n in range(1, 13): print(a(n)) \n"}
{"sequence_id": "A207610", "text": "Triangle of coefficients of polynomials u(n,x) jointly generated with A207611; see the Formula section.", "sequence": "1,2,4,1,7,3,1,12,7,3,1,20,15,8,3,1,33,30,19,9,3,1,54,58,42,23,10,3,1,88,109,89,55,27,11,3,1,143,201,182,125,69,31,12,3,1,232,365,363,273,166,84,35,13,3,1,376,655,709,579,383,212,100,39,14,3,1,609", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef u(n, x): return 1 if n==1 else u(n - 1, x) + v(n - 1, x)\ndef v(n, x): return 1 if n==1 else u(n - 1, x) + x*v(n - 1, x) + 1\ndef a(n): return Poly(u(n, x), x).all_coeffs()[::-1]\nfor n in range(1, 13): print(a(n)) \n"}
{"sequence_id": "A207611", "text": "Triangle of coefficients of polynomials v(n,x) jointly generated with A207610; see Formula section.", "sequence": "1,2,1,3,2,1,5,4,2,1,8,8,5,2,1,13,15,11,6,2,1,21,28,23,14,7,2,1,34,51,47,32,17,8,2,1,55,92,93,70,42,20,9,2,1,89,164,181,148,97,53,23,10,2,1,144,290,346,306,217,128,65,26,11,2,1,233,509,653,619,472", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef u(n, x): return 1 if n==1 else u(n - 1, x) + v(n - 1, x)\ndef v(n, x): return 1 if n==1 else u(n - 1, x) + x*v(n - 1, x) + 1\ndef a(n): return Poly(v(n, x), x).all_coeffs()[::-1]\nfor n in range(1, 13): print(a(n)) \n"}
{"sequence_id": "A207612", "text": "Triangle of coefficients of polynomials u(n,x) jointly generated with A207613; see the Formula section.", "sequence": "1,2,4,2,7,6,4,12,14,12,8,20,30,32,24,16,33,60,76,72,48,32,54,116,168,184,160,96,64,88,218,356,440,432,352,192,128,143,402,728,1000,1104,992,768,384,256,232,730,1452,2184,2656,2688,2240,1664,768,512", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef u(n, x): return 1 if n==1 else u(n - 1, x) + v(n - 1, x)\ndef v(n, x): return 1 if n==1 else u(n - 1, x) + 2*x*v(n - 1, x) + 1\ndef a(n): return Poly(u(n, x), x).all_coeffs()[::-1]\nfor n in range(1, 13): print(a(n)) \n"}
{"sequence_id": "A208130", "text": "Numbers that when expressed in decimal are equal to the sum of the digits sorted into nondecreasing order and raised to the powers 1, 2, 3, ...", "sequence": "1,2,3,4,5,6,7,8,9,89,135,2537,60409,4901732,17735872,45279768,393470463,3623008669,3893095238,229386834955666,1892713761283624,1501212693940707502,1517944702855898904,12303679765763687463,122947811178635339597,1095354314191826124704,1106509957063490820877", "code": "\nfrom itertools import combinations_with_replacement\nA208130_list = []\nfor l in range(1,23):\n    for n in combinations_with_replacement(range(10),l):\n        x = sum(b**(a+1) for a,b in enumerate(n))\n        if x > 0 and tuple(sorted(int(d) for d in str(x))) == n:\n            A208130_list.append(x)\nA208130_list = sorted(A208130_list)  \n"}
{"sequence_id": "A208233", "text": "First inverse function (numbers of rows) for pairing function A188568.", "sequence": "1,1,2,3,2,1,1,3,2,4,5,2,3,4,1,1,5,3,4,2,6,7,2,5,4,3,6,1,1,7,3,5,4,6,2,8,9,2,7,4,5,6,3,8,1,1,9,3,7,5,6,4,8,2,10,11,2,9,4,7,6,5,8,3,10,1", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nif i>=j:\n   result= max(i,j)*((-1)**i+1)/2-min(i,j)*((-1)**i-1)/2\nelse:\n   result=-max(i,j)*((-1)**j-1)/2+min(i,j)*((-1)**j+1)/2\n"}
{"sequence_id": "A208234", "text": "Second inverse function (numbers of columns) for pairing function A188568.", "sequence": "1,2,1,1,2,3,4,2,3,1,1,4,3,2,5,6,2,4,3,5,1,1,6,3,4,5,2,7,8,2,6,4,5,3,7,1,1,8,3,6,5,4,7,2,9,10,2,8,4,6,5,7,3,9,1,1,10,3,8,5,6,7,4,9,2,11", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)//2\nj=(t*t+3*t+4)//2-n\nif i>=j:\n    result=-max(i,j)*((-1)**i-1)/2+min(i,j)*((-1)**i+1)/2\nelse:\n    result= max(i,j)*((-1)**j+1)/2-min(i,j)*((-1)**j-1)/2\n"}
{"sequence_id": "A208510", "text": "Triangle of coefficients of polynomials u(n,x) jointly generated with A029653; see the Formula section.", "sequence": "1,1,1,1,3,1,1,5,4,1,1,7,9,5,1,1,9,16,14,6,1,1,11,25,30,20,7,1,1,13,36,55,50,27,8,1,1,15,49,91,105,77,35,9,1,1,17,64,140,196,182,112,44,10,1,1,19,81,204,336,378,294,156,54,11,1,1,21,100,285,540,714,672,450,210,65,12,1", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef u(n, x): return 1 if n==1 else u(n - 1, x) + x*v(n - 1, x)\ndef v(n, x): return 1 if n==1 else u(n - 1, x) + x*v(n - 1, x) + 1\ndef a(n): return Poly(u(n, x), x).all_coeffs()[::-1]\nfor n in range(1, 13): print(a(n)) \n"}
{"sequence_id": "A208528", "text": "Number of permutations of n>1 having exactly 3 points P on the boundary of their bounding square.", "sequence": "0,4,16,72,384,2400,17280,141120,1290240,13063680,145152000,1756339200,22992076800,323805081600,4881984307200,78460462080000,1339058552832000,24186745110528000,460970906812416000,9245027631071232000,194632160654131200000", "code": "\nimport math\ndef a(n):\n    return (4*n-8)*math.factorial(n-2)\n"}
{"sequence_id": "A208529", "text": "Number of permutations of n > 1 having exactly 2 points on the boundary of their bounding square.", "sequence": "2,2,4,12,48,240,1440,10080,80640,725760,7257600,79833600,958003200,12454041600,174356582400,2615348736000,41845579776000,711374856192000,12804747411456000,243290200817664000,4865804016353280000,102181884343418880000", "code": "\nimport math\ndef a(n):\n    return 2*math.factorial(n-2)\n"}
{"sequence_id": "A208575", "text": "Product of digits of n in factorial base.", "sequence": "0,1,0,1,0,2,0,0,0,1,0,2,0,0,0,2,0,4,0,0,0,3,0,6,0,0,0,0,0,0,0,0,0,1,0,2,0,0,0,2,0,4,0,0,0,3,0,6,0,0,0,0,0,0,0,0,0,2,0,4,0,0,0,4,0,8,0,0,0,6,0,12,0,0,0,0,0,0,0,0,0,3,0,6,0,0,0,6,0,12,0,0,0,9,0,18", "code": "\nfrom operator import mul\ndef A(n, p=2):\n    return n if n<p else A(n//p, p+1)*10 + n%p\ndef a(n):\n    x=str(A(n - 1))\n    return 0 if \"0\" in x else reduce(mul, [int(i) for i in x])\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A208597", "text": "T(n,k) = number of n-bead necklaces labeled with numbers -k..k not allowing reversal, with sum zero.", "sequence": "1,1,2,1,3,3,1,4,7,6,1,5,13,23,11,1,6,21,60,77,26,1,7,31,125,291,297,57,1,8,43,226,791,1564,1163,142,1,9,57,371,1761,5457,8671,4783,351,1,10,73,568,3431,14838,39019,49852,20041,902,1,11,91,825,6077,34153,129823", "code": "\nfrom sympy import binomial, divisors, totient, floor\ndef comps(r, m, k): return sum([(-1)**i*binomial(r - 1 - i*m, k - 1)*binomial(k, i) for i in range(floor((r - k)/m) + 1)])\ndef a(n, k): return sum([totient(n//d)*comps(d*(k + 1), 2*k + 1, d) for d in divisors(n)])//n\nfor n in range(1, 12): print([a(k, n - k + 1) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A208736", "text": "Number of nonisomorphic graded posets with 0 and 1 and non-uniform Hasse graph of rank n, with exactly 2 elements of each rank level between 0 and 1.", "sequence": "0,0,0,1,5,22,91,361,1392,5265,19653,72694,267179,977593,3565600,12975457,47142021,171075606,620303547,2247803785,8141857808,29481675889,106728951109,386314552438,1398132674955,5059626441177,18308871648576,66249898660801", "code": "\ndef a(n, d={0:0,1:0,2:0,3:1,4:5,5:22}):\n    if n in d:\n        return d[n]\n    d[n]=8*a(n-1) - 21*a(n-2) + 20*a(n-3) - 5*a(n-4)\n    return d[n]\n"}
{"sequence_id": "A208737", "text": "Number of nonisomorphic graded posets with 0 and 1 and non-uniform Hasse graph of rank n, with no 3-element antichain.", "sequence": "0,0,0,1,7,37,175,778,3325,13837,56524,227866,909832,3607294,14227447,55894252,218937532,855650749,3338323915,13007422705,50631143323,196928737582,765495534433,2974251390529,11552064922624,44856304154086", "code": "\ndef a(n, d={0:0,1:0,2:0,3:1,4:7,5:37}):\n    if n in d:\n        return d[n]\n    d[n]=10*a(n-1) - 36*a(n-2) + 57*a(n-3) - 39*a(n-4) + 9*a(n-5)\n    return d[n]\n"}
{"sequence_id": "A208738", "text": "Number of multisets occurring as the peak heights multiset of a Dyck n-path.", "sequence": "1,2,4,9,20,45,98,211,445,927,1909,3901,7920,16011,32260,64852,130157,260932,522691,1046489,2094438,4190798,8384100,16771453,33547094,67099568,134205996,268420714,536852452,1073718799,2147455019,4294931825,8589890772", "code": "\n\ndef peakheightsmultisets(n):\n.\n.allpaths=list()\n.combinst=itertools.combinations(range(2*n),n)\n.for tup in combinst:\n..a=[]\n..for i in range(2*n):\n...if i in tup:\n....a.append(1)\n...else:\n....a.append(-1)\n..allpaths.append(tuple(a))\n.\n.output=set()\n.for x in allpaths:\n..include=True\n..peaklist=[]\n..total=0\n..for unit in x:\n...if unit==-1 and lastunit==1:\n....peaklist.append(total)\n...total+=unit\n...if total < 0:\n....include=False\n....break\n...lastunit=unit\n..if include:\n...output.add(tuple(sorted(peaklist)))\n.return output\n"}
{"sequence_id": "A208738", "text": "Number of multisets occurring as the peak heights multiset of a Dyck n-path.", "sequence": "1,2,4,9,20,45,98,211,445,927,1909,3901,7920,16011,32260,64852,130157,260932,522691,1046489,2094438,4190798,8384100,16771453,33547094,67099568,134205996,268420714,536852452,1073718799,2147455019,4294931825,8589890772", "code": "\n\ndef a(n):\n.return len(peakheightsmultisets(n))\n"}
{"sequence_id": "A209242", "text": "The largest fixed value (neither happy nor sad) in base n.", "sequence": "8,1,18,1,45,52,50,1,72,125,160,1,128,1,261,260,200,1,425,405,490,1,338,1,657,628,450,848,936,845,1000,832,648,1,1233,1377,800,1,1450,1445,1813,1341,1058,1856,2125,1844,1250,1525,1352,2205,2560,1,2873,1,3200", "code": "\nfrom sympy.ntheory.digits import digits\ndef ssd(n, b): return sum(d**2 for d in digits(n, b)[1:])\ndef a(n):\n    m = n**2 - 1\n    while m != ssd(m, n): m -= 1\n    return m\nprint([a(n) for n in range(3, 58)]) \n"}
{"sequence_id": "A209252", "text": "Number of primes (excluding n) that may be generated by replacing any decimal digit of n with a digit from 0 to 9.", "sequence": "4,4,3,3,4,3,4,3,4,4,4,7,5,9,4,5,4,8,4,7,2,7,3,7,2,3,2,8,2,5,2,5,3,9,2,3,2,6,2,7,3,6,4,8,3,4,3,7,3,8,2,7,3,7,2,3,2,8,2,5,2,5,3,9,2,3,2,6,2,7,3,6,4,8,3,4,3,9,3,6,2,7,3,7,2,3,2,8,2,5,1,6,2,8,1,2,1,5,1,6,4,10,5,9,4", "code": "\nfrom sympy import isprime\ndef A209252(n):\n    return len([1 for i in range(len(str(n))) for d in '0123456789' if d != str(n)[i] and isprime(int(str(n)[:i]+d+str(n)[i+1:]))]) \n"}
{"sequence_id": "A209268", "text": "Inverse permutation  A054582.", "sequence": "1,2,3,4,6,5,10,7,15,9,21,8,28,14,36,11,45,20,55,13,66,27,78,12,91,35,105,19,120,44,136,16,153,54,171,26,190,65,210,18,231,77,253,34,276,90,300,17,325,104,351,43,378,119,406,25,435,135,465,53,496,152", "code": "\nf = open(\"result.csv\", \"w\")\ndef A007814(n):\n\n\n        a = 0\n        nshft = n\n        while (nshft %2 == 0):\n                a += 1\n                nshft >>= 1\n        return a\n\nfor  n in range(1,10001):\n     x = A007814(n)\n     y = (n+2**x)/2**(x+1)\n     m = ((x+y)**2-x+y)/2\n     f.write('%d;%d;%d;%d;\\n' % (n, x, y, m))\nf.close()\n"}
{"sequence_id": "A209274", "text": "Table T(n,k) = n*(n+2^k-1)/2, n, k > 0  read by antidiagonals.", "sequence": "1,2,3,4,5,6,8,9,9,10,16,17,15,14,15,32,33,27,22,20,21,64,65,51,38,30,27,28,128,129,99,70,50,39,35,36,256,257,195,134,90,63,49,44,45,512,513,387,262,170,111,77,60,54,55,1024,1025,771,518,330,207,133,92,72,65,66", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult = i*(i+2**j-1)/2\n"}
{"sequence_id": "A209278", "text": "Second inverse function (numbers of rows) for pairing function A185180.", "sequence": "1,2,1,2,3,1,3,2,4,1,3,4,2,5,1,4,3,5,2,6,1,4,5,3,6,2,7,1,5,4,6,3,7,2,8,1,5,6,4,7,3,8,2,9,1,6,5,7,4,8,3,9,2,10,1,6,7,5,8,4,9,3,10,2,11,1", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nresult=int((t+3)/2)+int(i/2)*(-1)**(i+t)\n"}
{"sequence_id": "A209279", "text": "First inverse function (numbers of rows) for pairing function A185180.", "sequence": "1,1,2,2,1,3,2,3,1,4,3,2,4,1,5,3,4,2,5,1,6,4,3,5,2,6,1,7,4,5,3,6,2,7,1,8,5,4,6,3,7,2,8,1,9,5,6,4,7,3,8,2,9,1,10,6,5,7,4,8,3,9,2,10,1,11,6,7,5,8,4,9,3,10,2,11,1,12,7,6,8,5,9,4,10,3,11,2,12,1,13", "code": " \ndef a(n):\n   t = int((math.sqrt(8*n-7) - 1)/2);\n   i = n-t*(t+1)/2;\n   return int(t/2)+1+int(i/2)*(-1)**(i+t+1)\n"}
{"sequence_id": "A209293", "text": "Inverse permutation of A185180.", "sequence": "1,2,3,5,4,6,8,9,7,10,13,12,14,11,15,18,19,17,20,16,21,25,24,26,23,27,22,28,32,33,31,34,30,35,29,36,41,40,42,39,43,38,44,37,45,50,51,49,52,48,53,47,54,46,55,61,60,62,59,63,58,64,57,65,56,66,72,73,71,74,70,75,69,76,68,77,67", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nm1=int((i+j)/2)+int(i/2)*(-1)**(i+t+1)\nm2=int((i+j+1)/2)+int(i/2)*(-1)**(i+t)\nm=(m1+m2-1)*(m1+m2-2)/2+m1\n"}
{"sequence_id": "A209301", "text": "Table T(n,k) n, k > 0, T(n,k)=n-k+1, if n>=k, T(n,k)=k-n+2, if n < k.  Table read by sides of squares from T(1,n) to T(n,n), then from T(n,n) to T(n,1).", "sequence": "1,3,1,2,4,3,1,2,3,5,4,3,1,2,3,4,6,5,4,3,1,2,3,4,5,7,6,5,4,3,1,2,3,4,5,6,8,7,6,5,4,3,1,2,3,4,5,6,7,9,8,7,6,5,4,3,1,2,3,4,5,6,7,8,10,9,8,7,6,5,4,3,1,2,3,4,5,6,7,8,9,11,10,9,8,7", "code": "\nt=int((math.sqrt(n))-0.5)+1\nv=int((n-1)/t)-t+1\nresult=k*v+(2*v-1)*(t**2-n)+t\n"}
{"sequence_id": "A209302", "text": "Table T(n,k) = max{n+k-1, n+k-1} n, k > 0, read by sides of squares from T(1,n) to T(n,n), then from T(n,n) to T(n,1).", "sequence": "1,2,3,2,3,4,5,4,3,4,5,6,7,6,5,4,5,6,7,8,9,8,7,6,5,6,7,8,9,10,11,10,9,8,7,6,7,8,9,10,11,12,13,12,11,10,9,8,7,8,9,10,11,12,13,14,15,14,13,12,11,10,9,8,9,10,11,12,13,14,15,16,17,16,15,14", "code": "\nresult = 2*int(math.sqrt(n-1)) - abs(n-int(math.sqrt(n-1))**2 - int(math.sqrt(n-1)) -1) +1\n"}
{"sequence_id": "A209304", "text": "Table T(n,k)=n+4*k-4 n, k > 0, read by antidiagonals.", "sequence": "1,5,2,9,6,3,13,10,7,4,17,14,11,8,5,21,18,15,12,9,6,25,22,19,16,13,10,7,29,26,23,20,17,14,11,8,33,30,27,24,21,18,15,12,9,37,34,31,28,25,22,19,16,13,10,41,38,35,32,29,26,23,20,17,14,11,45,42,39,36,33,30,27", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\nresult = +4*(t+1) + 3*(t*(t+1)/2-n)\n"}
{"sequence_id": "A209398", "text": "Number of subsets of {1,...,n} containing two elements whose difference is 2.", "sequence": "0,0,0,2,7,17,39,88,192,408,855,1775,3655,7478,15228,30898,62511,126177,254223,511472,1027840,2063600,4140015,8300767,16635087,33324462,66736764,133615658,267461287,535294673,1071191415,2143357000,4288290240,8579130888", "code": "\n\ndef a(n, adict={0:0, 1:0, 2:0, 3:2, 4:7}):\n.if n in adict:\n..return adict[n]\n.adict[n]=3*a(n-1)-2*a(n-2)+a(n-3)-a(n-4)-2*a(n-5)\n.return adict[n]\n"}
{"sequence_id": "A209398", "text": "Number of subsets of {1,...,n} containing two elements whose difference is 2.", "sequence": "0,0,0,2,7,17,39,88,192,408,855,1775,3655,7478,15228,30898,62511,126177,254223,511472,1027840,2063600,4140015,8300767,16635087,33324462,66736764,133615658,267461287,535294673,1071191415,2143357000,4288290240,8579130888", "code": "\n\ndef contains101(n):\n.patterns=list()\n.for start in range (1,n-1):\n..s=set()\n..for i in range(3):\n...if (1,0,1)[i]:\n....s.add(start+i)\n..patterns.append(s)\n.s=list()\n.for i in range(2,n+1):\n..for temptuple in comb(range(1,n+1),i):\n...tempset=set(temptuple)\n...for sub in patterns:\n....if sub <= tempset:\n.....s.append(tempset)\n.....break\n.return s\n\ndef countcontains101(n):\n.return len(contains101(n))\n"}
{"sequence_id": "A209399", "text": "Number of subsets of {1,...,n} containing two elements whose difference is 3.", "sequence": "0,0,0,0,4,14,37,83,181,387,824,1728,3584,7360,15032,30571,61987,125339,252883,509294,1024300,2057848,4130724,8285758,16610841,33285207,66673209,133512759,267294832,535025408,1070755840,2142652160,4287149680,8577285255", "code": "\n\ndef a(n, adict={0:0, 1:0, 2:0, 3:0, 4:4, 5:14, 6:37, 7:83, 8:181}):\n.if n in adict:\n..return adict[n]\n.adict[n]=3*a(n-1)-a(n-2)-3*a(n-3)+3*a(n-4)-a(n-5)-a(n-6)-3*a(n-7)+a(n-8)+2*a(n-9)\n.return adict[n]\n"}
{"sequence_id": "A209399", "text": "Number of subsets of {1,...,n} containing two elements whose difference is 3.", "sequence": "0,0,0,0,4,14,37,83,181,387,824,1728,3584,7360,15032,30571,61987,125339,252883,509294,1024300,2057848,4130724,8285758,16610841,33285207,66673209,133512759,267294832,535025408,1070755840,2142652160,4287149680,8577285255", "code": "\n\ndef contains1001(n):\n.patterns=list()\n.for start in range (1,n-2):\n..s=set()\n..for i in range(4):\n...if (1,0,0,1)[i]:\n....s.add(start+i)\n..patterns.append(s)\n.s=list()\n.for i in range(2,n+1):\n..for temptuple in comb(range(1,n+1),i):\n...tempset=set(temptuple)\n...for sub in patterns:\n....if sub <= tempset:\n.....s.append(tempset)\n.....break\n.return s\n\ndef countcontains1001(n):\n.return len(contains1001(n))\n"}
{"sequence_id": "A209400", "text": "Number of subsets of {1,...,n} containing a subset of the form {k,k+1,k+3} for some k.", "sequence": "0,0,0,0,2,7,19,46,107,242,535,1162,2490,5281,11108,23206,48206,99663,205218,421115,861585,1758249,3580075,7275377,14759592,29897683,60481359,122206014,246665382,497414751,1002231335,2017877779,4060069150,8164204342", "code": "\n\ndef a(n, adict={0:0, 1:0, 2:0, 3:0, 4:2, 5:7}):\n.if n in adict:\n..return adict[n]\n.adict[n]=3*a(n-1)-a(n-2)-2*a(n-3)+a(n-4)-a(n-5)-2*a(n-6)\n.return adict[n]\n"}
{"sequence_id": "A209400", "text": "Number of subsets of {1,...,n} containing a subset of the form {k,k+1,k+3} for some k.", "sequence": "0,0,0,0,2,7,19,46,107,242,535,1162,2490,5281,11108,23206,48206,99663,205218,421115,861585,1758249,3580075,7275377,14759592,29897683,60481359,122206014,246665382,497414751,1002231335,2017877779,4060069150,8164204342", "code": "\n\ndef contains1101(n):\n.patterns=list()\n.for start in range (1,n-2):\n..s=set()\n..for i in range(4):\n...if (1,1,0,1)[i]:\n....s.add(start+i)\n..patterns.append(s)\n.s=list()\n.for i in range(2,n+1):\n..for temptuple in comb(range(1,n+1),i):\n...tempset=set(temptuple)\n...for sub in patterns:\n....if sub <= tempset:\n.....s.append(tempset)\n.....break\n.return s\n\ndef countcontains1101(n):\n.return len(contains1101(n))\n"}
{"sequence_id": "A209403", "text": "Convolution of primes with odd primes.", "sequence": "6,19,44,89,162,271,424,633,910,1275,1732,2309,3018,3859,4872,6057,7446,9051,10888,12997,15358,18011,20972,24277,27950,31991,36464,41325,46602,52367,58612,65385,72722,80651,89160,98317,108070,118535,129756,141713,154442", "code": "\nfrom numpy import convolve\nfrom sympy import prime, primerange\ndef aupton(nn):\n    primes = list(primerange(2, prime(nn+1)+1))\n    return list(convolve(primes[:-1], primes[1:]))[:nn]\nprint(aupton(41)) \n"}
{"sequence_id": "A209408", "text": "Number of subsets of {1,...,n} containing {a,a+4} for some a.", "sequence": "0,0,0,0,0,8,28,74,175,377,799,1673,3471,7192,14784,30208,61440,124416,251328,506712,1020015,2051015,4119775,8268215,16582735,33239558,66599068,133392344,267099120,534709192,1070244924,2141826898,4285816671,8575127217", "code": "\n\ndef contains10001(n):\n.patterns=list()\n.for start in range (1,n-3):\n..s=set()\n..for i in range(5):\n...if (1,0,0,0,1)[i]:\n....s.add(start+i)\n..patterns.append(s)\n.s=list()\n.for i in range(2,n+1):\n..for temptuple in comb(range(1,n+1),i):\n...tempset=set(temptuple)\n...for sub in patterns:\n....if sub <= tempset:\n.....s.append(tempset)\n.....break\n.return s\n\ndef countcontains10001(n):\n.return len(contains10001(n))\n\ndef a(n, adict={0:0, 1:0, 2:0, 3:0, 4:0, 5:8, 6:28, 7:74, 8:175, 9:377, 10:799, 11:1673, 12:3471, 13:7192, 14:14784}):\n.if n in adict:\n..return adict[n]\n.adict[n]=3*a(n-1)-a(n-2)-2*a(n-3)-2*a(n-4)+6*a(n-5)-2*a(n-6)-4*a(n-7)+2*a(n-8)-6*a(n-9)+2*a(n-10)+4*a(n-11)+a(n-12)-3*a(n-13)+a(n-14)+2*a(n-15)\n.return adict[n]\n"}
{"sequence_id": "A209409", "text": "Number of subsets of {1,...,n} containing {a,a+2,a+4} for some a.", "sequence": "0,0,0,0,0,4,15,37,87,200,448,992,2160,4628,9823,20699,43335,90246,187068,386192,794560,1629944,3334975,6808073,13870191,28207552,57274368,116129280,235165632,475678200,961190943,1940470231,3914210127,7889613022,15891777084", "code": "\n\ndef containscode(n,bitstring=(1,0,1,0,1)):\n.patterns=list()\n.for start in range (1,n-len(bitstring)+2):\n..s=set()\n..for i in range(len(bitstring)):\n...if bitstring[i]:\n....s.add(start+i)\n..patterns.append(s)\n.s=list()\n.for i in range(sum(bitstring),n+1):\n..for temptuple in comb(range(1,n+1),i):\n...tempset=set(temptuple)\n...for sub in patterns:\n....if sub <= tempset:\n.....s.append(tempset)\n.....break\n.return s\n\ndef countcontainscode(n,bitstring=(1,0,1,0,1)):\n.return len(containscode(n))\n"}
{"sequence_id": "A209409", "text": "Number of subsets of {1,...,n} containing {a,a+2,a+4} for some a.", "sequence": "0,0,0,0,0,4,15,37,87,200,448,992,2160,4628,9823,20699,43335,90246,187068,386192,794560,1629944,3334975,6808073,13870191,28207552,57274368,116129280,235165632,475678200,961190943,1940470231,3914210127,7889613022,15891777084", "code": "\n\ndef a(n, adict={0:0, 1:0, 2:0, 3:0, 4:0, 5:4, 6:15, 7:37, 8:87, 9:200}):\n.if n in adict:\n..return adict[n]\n.adict[n]=3*a(n-1) - 2*a(n-2) + 2*a(n-3) - 4*a(n-4) + 2*a(n-5) - 2*a(n-6) - 4*a(n-7) - a(n-8) + a(n-9) + 2*a(n-10)\n.return adict[n]\n"}
{"sequence_id": "A209410", "text": "Number of subsets of {1,...,n} not containing {a,a+2,a+4} for any a.", "sequence": "1,2,4,8,16,28,49,91,169,312,576,1056,1936,3564,6561,12069,22201,40826,75076,138096,254016,467208,859329,1580535,2907025,5346880,9834496,18088448,33269824,61192712,112550881,207013417,380757169,700321570,1288092100", "code": "\n\ndef avoidscode(n,bitstring=(1,0,1,0,1)):\n.patterns=list()\n.for start in range (1,n-len(bitstring)+2):\n..s=set()\n..for i in range(len(bitstring)):\n...if bitstring[i]:\n....s.add(start+i)\n..patterns.append(s)\n.s=list()\n.for i in range(sum(bitstring)):\n..for smallset in comb(range(1,n+1),i):\n...s.append(smallset)\n.for i in range(sum(bitstring),n+1):\n..for temptuple in comb(range(1,n+1),i):\n...tempset=set(temptuple)\n...for sub in patterns:\n....if sub <= tempset:\n.....status=False\n.....break\n...if status:\n....s.append(tempset)\n.return s\n\ndef countavoidscode(n,bitstring=(1,0,1,0,1)):\n.return len(avoidscode(n))\n\ndef a(n, adict={0:1, 1:2, 2:4, 3:8, 4:16, 5:28, 6:49, 7:91, 8:169}):\n.if n in adict:\n..return adict[n]\n.adict[n]=a(n-1) + 2*a(n-3) + 2*a(n-5) + 2*a(n-6) - a(n-8) - a(n-9)\n.return adict[n]\n"}
{"sequence_id": "A209636", "text": "Matula-numbers computed for rooted trees encoded by A071162/A071163.", "sequence": "1,2,4,3,8,6,7,5,16,12,14,10,19,13,17,11,32,24,28,20,38,26,34,22,53,37,43,29,67,41,59,31,64,48,56,40,76,52,68,44,106,74,86,58,134,82,118,62,131,89,107,71,163,101,139,79,241,157,191,109,331,179,277", "code": "\nfrom sympy import prime\ndef a(n):\n    n = 2*n\n    m = 1\n    if n<2: return 1\n    while n>1:\n        if n%2==0:\n            n//=2\n            m*=2\n        else:\n            n=(n - 1)//2\n            m=prime(m)\n    return m\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A209637", "text": "Matula-numbers computed for rooted trees encoded by A071162 when interpreted in once-halved bit-tuple format.", "sequence": "1,2,3,4,5,7,6,8,11,17,13,19,10,14,12,16,31,59,41,67,29,43,37,53,22,34,26,38,20,28,24,32,127,277,179,331,109,191,157,241,79,139,101,163,71,107,89,131,62,118,82,134,58,86,74,106,44,68,52,76,40,56,48", "code": "\nfrom sympy import prime\nfrom mpmath import log\ndef a054429(n): return 3*(2**int(log(n, 2))) - (n + 1)\ndef a209636(n):\n    n = 2*n\n    m = 1\n    if n<2: return 1\n    while n>1:\n        if n%2==0:\n            n/=2\n            m*=2\n        else:\n            n=(n - 1)/2\n            m=prime(m)\n    return m\ndef a(n): return 1 if n==0 else a209636(a054429(n)) \n"}
{"sequence_id": "A209638", "text": "Sequence A209636 (or A209637) sorted into ascending order.", "sequence": "1,2,3,4,5,6,7,8,10,11,12,13,14,16,17,19,20,22,24,26,28,29,31,32,34,37,38,40,41,43,44,48,52,53,56,58,59,62,64,67,68,71,74,76,79,80,82,86,88,89,96,101,104,106,107,109,112,116,118,124,127,128,131,134", "code": "\nfrom sympy import prime\ndef a(n):\n    n = 2*n\n    m = 1\n    if n<2: return 1\n    while n>1:\n        if n%2==0:\n            n//=2\n            m*=2\n        else:\n            n=(n - 1)//2\n            m=prime(m)\n    return m\nprint(sorted([a(n) for n in range(101)])) \n"}
{"sequence_id": "A209642", "text": "A014486-codes for rooted plane trees where non-leaf branching can occur only at the leftmost branch of any level, but nowhere else. Reflected from the corresponding rightward branching codes in A071162, thus not in ascending order.", "sequence": "0,2,10,12,42,50,52,56,170,202,210,226,212,228,232,240,682,810,842,906,850,914,930,962,852,916,932,964,936,968,976,992,2730,3242,3370,3626,3402,3658,3722,3850,3410,3666,3730,3858,3746,3874,3906,3970,3412,3668,3732,3860,3748,3876,3908,3972,3752,3880,3912,3976,3920,3984,4000,4032", "code": "\ndef a(n):\n    s=0\n    i=1\n    while n!=0:\n        if n%2==0:\n            n//=2\n            s=4*s + 1\n        else:\n            n=(n - 1)//2\n            s=(s + i)*2\n        i*=4\n    return s\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A209669", "text": "T(n,k) = count of degree k monomials in the elementary symmetric polynomials e(mu,k) summed over all partitions mu of n.", "sequence": "1,1,5,1,10,37,1,21,120,405,1,42,363,1644,5251,1,85,1117,6814,27405,84893,1,170,3360,27404,138085,514248,1556535,1,341,10164,111045,701960,3145848,11133493,33175957,1,682,30520,445132,3521405,18956548,78337448", "code": " \n"}
{"sequence_id": "A209685", "text": "Sum of last two digits of n.", "sequence": "0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7,8,9,10,11,12,13,14,6,7,8,9,10,11,12,13,14,15,7,8,9,10,11,12,13,14,15,16,8,9,10,11,12,13,14,15,16,17,9,10,11,12,13,14,15,16,17,18,0,1,2,3,4,5,6,7,8,9,1", "code": "\ndef A209685(n):\n....if n<=9:return n\n....return int(str(n)[-1])+int(str(n)[-2]) \n"}
{"sequence_id": "A209928", "text": "Largest digit of all divisors of n.", "sequence": "1,2,3,4,5,6,7,8,9,5,1,6,3,7,5,8,7,9,9,5,7,2,3,8,5,6,9,8,9,6,3,8,3,7,7,9,7,9,9,8,4,7,4,4,9,6,7,8,9,5,7,6,5,9,5,8,9,9,9,6,6,6,9,8,6,6,7,8,9,7,7,9,7,7,7,9,7,9,9,8,9,8,8,8,8,8,9", "code": "\nfrom sympy import divisors\ndef a(n): return int(max(\"\".join(map(str, divisors(n)))))\nprint([a(n) for n in range(1, 88)]) \n"}
{"sequence_id": "A210109", "text": "Number of 3-divided binary sequences (or words) of length n.", "sequence": "0,0,0,2,7,23,54,132,290,634,1342,2834,5868,12140,24899,50929,103735,210901,427623,865910,1750505,3535098,7131321,14374647,28952661,58280123,117248217,235770302,473897980,952183214,1912535827,3840345963,7709282937,15472242645,31045402788,62280978042", "code": " \nfrom itertools import product\ndef is3div(b):\n    for i in range(1, len(b)-1):\n        for j in range(i+1, len(b)):\n            X, Y, Z = b[:i], b[i:j], b[j:]\n            if all(b < bp for bp in [Z+Y+X, Z+X+Y, Y+Z+X, Y+X+Z, X+Z+Y]):\n                return True\n    return False\ndef a(n): return sum(is3div(\"\".join(b)) for b in product(\"01\", repeat=n))\nprint([a(n) for n in range(1, 16)]) \n"}
{"sequence_id": "A210205", "text": "The sum of three consecutive prime numbers, beginning with a(n), is a cube.", "sequence": "439,34603,1016201,3696493,4002991,6344687,10221397,14662309,16209029,19925483,20856907,22805969,43441271,60120691,60761413,62056457,62710787,87791567,96268243,125977651,166225747,170027449", "code": "\nfrom __future__ import division\nfrom sympy import nextprime, prevprime\nA210205_list = []\nfor i in range(3,10**6):\n    n = i**3\n    p2 = prevprime(n//3)\n    p1, p3 = prevprime(p2), nextprime(p2)\n    q = p1+p2+p3\n    while q <= n:\n        if q == n:\n            A210205_list.append(p1)\n        p1, p2, p3 = p2, p3, nextprime(p3)\n        q = p1+p2+p3 \n"}
{"sequence_id": "A210221", "text": "Triangle of coefficients of polynomials u(n,x) jointly generated with A210596; see the Formula section.", "sequence": "1,2,3,2,5,4,4,8,10,8,8,13,20,24,16,16,21,40,52,56,32,32,34,76,116,128,128,64,64,55,142,240,312,304,288,128,128,89,260,488,688,800,704,640,256,256,144,470,964,1496,1856,1984,1600,1408,512,512,233,840", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef u(n, x): return 1 if n==1 else u(n - 1, x) + v(n - 1, x)\ndef v(n, x): return 1 if n==1 else u(n - 1, x) + 2*x*v(n - 1, x)\ndef a(n): return Poly(u(n, x), x).all_coeffs()[::-1]\nfor n in range(1, 13): print(a(n)) \n"}
{"sequence_id": "A210321", "text": "Number of 4-divided binary words of length n.", "sequence": "0,0,0,0,0,1,11,37,109,287,698,1617,3642,7985,17208,36620,77093,161027,334205,690080,1418917,2907655,5941148,12110674", "code": "\nfrom itertools import product, combinations, permutations\ndef is4div(b):\n    for i, j, k in combinations(range(1, len(b)), 3):\n        divisions = [b[:i], b[i:j], b[j:k], b[k:]]\n        all_greater = True\n        for p, bp in enumerate(permutations(divisions)):\n            if p == 0: continue\n            if b >= \"\".join(bp): all_greater = False; break\n        if all_greater: return True\n    return False\ndef a(n): return sum(is4div(\"\".join(b)) for b in product(\"01\", repeat=n))\nprint([a(n) for n in range(1, 14)]) \n"}
{"sequence_id": "A210322", "text": "Number of 5-divided binary words of length n.", "sequence": "0,0,0,0,0,0,0,0,6,36,150,464,1304,3349,8213,19230,43867,97644,213776,461240,984603,2082436", "code": "\nfrom itertools import product, combinations, permutations\ndef is5div(b):\n    for i, j, k, l in combinations(range(1, len(b)), 4):\n        divisions = [b[:i], b[i:j], b[j:k], b[k:l], b[l:]]\n        all_greater = True\n        for p, bp in enumerate(permutations(divisions)):\n            if p == 0: continue\n            if b >= \"\".join(bp): all_greater = False; break\n        if all_greater: return True\n    return False\ndef a(n): return sum(is5div(\"\".join(b)) for b in product(\"01\", repeat=n))\nprint([a(n) for n in range(1, 13)]) \n"}
{"sequence_id": "A210324", "text": "Number of 3-divided words of length n over a 3-letter alphabet.", "sequence": "0,0,1,16,78,324,1141,3885,12630,40315,126604,393986,1216525,3737912,11438230,34898189,106217986,322683051", "code": "\nfrom itertools import product\ndef is3div(b):\n    for i in range(1, len(b)-1):\n        for j in range(i+1, len(b)):\n            X, Y, Z = b[:i], b[i:j], b[j:]\n            if all(b < bp for bp in [X+Z+Y, Z+Y+X, Y+X+Z, Y+Z+X, Z+X+Y]):\n                return True\n    return False\ndef a(n): return sum(is3div(\"\".join(b)) for b in product(\"012\", repeat=n))\nprint([a(n) for n in range(1, 11)]) \n"}
{"sequence_id": "A210325", "text": "Number of 4-divided words of length n over a 3-letter alphabet.", "sequence": "0,0,0,0,6,56,343,1534,6067,22162,76899,257792,843616,2712241,8606426,27040628,84311895", "code": "\nfrom itertools import product, combinations, permutations\ndef is4div(b):\n    for i, j, k in combinations(range(1, len(b)), 3):\n        divisions = [b[:i], b[i:j], b[j:k], b[k:]]\n        all_greater = True\n        for p, bp in enumerate(permutations(divisions)):\n            if p == 0: continue\n            if b >= \"\".join(bp): all_greater = False; break\n        if all_greater: return True\n    return False\ndef a(n): return sum(is4div(\"\".join(b)) for b in product(\"012\", repeat=n))\nprint([a(n) for n in range(1, 10)]) \n"}
{"sequence_id": "A210326", "text": "Number of 5-divided words of length n over a 3-letter alphabet.", "sequence": "0,0,0,0,0,0,15,166,1135,5865,26170,105224,396082,1419981,4916112", "code": "\nfrom itertools import product, combinations, permutations\ndef is5div(b):\n    for i, j, k, l in combinations(range(1, len(b)), 4):\n        divisions = [b[:i], b[i:j], b[j:k], b[k:l], b[l:]]\n        all_greater = True\n        for p, bp in enumerate(permutations(divisions)):\n            if p == 0: continue\n            if b >= \"\".join(bp): all_greater = False; break\n        if all_greater: return True\n    return False\ndef a(n): return sum(is5div(\"\".join(b)) for b in product(\"012\", repeat=n))\nprint([a(n) for n in range(1, 10)]) \n"}
{"sequence_id": "A210425", "text": "Number of 3-divided words of length n over a 4-letter alphabet.", "sequence": "0,0,4,60,374,1960,9103,40497,174127,735268,3064477,12664101,52005445,212595280,866047122", "code": "\nfrom itertools import product\ndef is3div(b):\n    for i in range(1, len(b)-1):\n        for j in range(i+1, len(b)):\n            X, Y, Z = b[:i], b[i:j], b[j:]\n            if all(b < bp for bp in [X+Z+Y, Z+Y+X, Y+X+Z, Y+Z+X, Z+X+Y]):\n                return True\n    return False\ndef a(n): return sum(is3div(\"\".join(b)) for b in product(\"0123\", repeat=n))\nprint([a(n) for n in range(1, 9)]) \n"}
{"sequence_id": "A210426", "text": "Number of 4-divided words of length n over a 4-letter alphabet.", "sequence": "0,0,0,1,44,450,3175,17977,91326,433434,1968268,8674028,37428470,159059732", "code": "\nfrom itertools import product, combinations, permutations\ndef is4div(b):\n    for i, j, k in combinations(range(1, len(b)), 3):\n        divisions = [b[:i], b[i:j], b[j:k], b[k:]]\n        all_greater = True\n        for p, bp in enumerate(permutations(divisions)):\n            if p == 0: continue\n            if b >= \"\".join(bp): all_greater = False; break\n        if all_greater: return True\n    return False\ndef a(n): return sum(is4div(\"\".join(b)) for b in product(\"0123\", repeat=n))\nprint([a(n) for n in range(1, 9)]) \n"}
{"sequence_id": "A210482", "text": "Prime numbers of the form (p#)^2+1, where p# is a primorial.", "sequence": "2,5,37,44101,5336101,94083986096101,1062053250251407755176413469419400772901", "code": "\nfrom functools import reduce\nimport numpy as np\ndef factors(n):\n    return reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))\nmul=1\nfor i in range(1,20):\n    if len(factors(i))<3:\n        mul*= i*i\n        if len(factors(mul+1))< 3:\n            print(mul+1)\n"}
{"sequence_id": "A210503", "text": "Numbers k that form a primitive Pythagorean triple with k' and sqrt(k^2 + k'^2), where k' is the arithmetic derivative of k.", "sequence": "15,35,143,323,899,1763,3599,4641,5183,10403,11663,13585,19043,22499,32399,35581,36863,39203,51983,57599,72899,79523,97343,121103,176399,186623,213443,272483,324899,359999,381923,412163,435599,446641,622081,656099,675683", "code": "\nfrom sympy import factorint\nfrom gmpy2 import mpz, is_square, gcd\nA210503 = []\nfor n in range(2,10**5):\n....nd = sum([mpz(n*e/p) for p,e in factorint(n).items()])\n....if is_square(nd**2+n**2) and gcd(gcd(n,nd),mpz(sqrt(nd**2+n**2))) == 1:\n........A210503.append(n) \n"}
{"sequence_id": "A210511", "text": "Primes formed by concatenating k, k, and 1 for k >= 1.", "sequence": "331,661,881,991,18181,20201,21211,26261,27271,32321,33331,41411,48481,51511,54541,57571,60601,65651,69691,71711,78781,86861,89891,90901,92921,98981,99991,1041041,1051051,1131131,1191191,1201201,1221221,1231231,1261261,1281281", "code": "\nimport numpy as np\ndef factors(n):\n    return reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))\nfor i in range(1,2000):\n    p1=int(str(i)+str(i)+\"1\")\n    if len(factors(p1))<3:\n        print(p1)\n"}
{"sequence_id": "A210512", "text": "Primes formed by concatenating n, n and 3 for n >= 1.", "sequence": "113,223,443,773,883,10103,11113,14143,25253,26263,28283,32323,35353,41413,50503,61613,68683,71713,77773,80803,83833,85853,88883,97973,1001003,1011013,1101103,1131133,1161163,1181183,1221223,1241243,1281283,1331333,1361363,1391393", "code": "\nimport numpy as np\nfrom functools import reduce\ndef factors(n):\n    return reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) +1) if n % i == 0))\nfor i in range(1, 1000):\n    p1=int(str(i)+str(i)+\"3\")\n    if len(factors(p1))<3:\n        print(p1, end=',')\n"}
{"sequence_id": "A210512", "text": "Primes formed by concatenating n, n and 3 for n >= 1.", "sequence": "113,223,443,773,883,10103,11113,14143,25253,26263,28283,32323,35353,41413,50503,61613,68683,71713,77773,80803,83833,85853,88883,97973,1001003,1011013,1101103,1131133,1161163,1181183,1221223,1241243,1281283,1331333,1361363,1391393", "code": "\nfrom sympy import isprime\ndef xf(n): return int(str(n)*2+'3')\ndef ok(n): return isprime(xf(n))\nprint(list(map(xf, filter(ok, range(1, 140))))) \n"}
{"sequence_id": "A210513", "text": "Primes formed by concatenating N, N, and 7.", "sequence": "227,337,557,887,997,11117,24247,26267,27277,29297,30307,32327,39397,48487,51517,54547,60607,62627,65657,68687,69697,72727,74747,78787,81817,87877,89897,90907,92927,93937,95957,101710177,101910197", "code": "\nimport numpy as np\nfrom functools import reduce\ndef factors(n):\n    return reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))\nfor i in range(1, 2000):\n    p1=int(str(i)+str(i)+\"7\")\n    if len(factors(p1))<3:\n        print(p1, end=',')\n"}
{"sequence_id": "A210514", "text": "Prime numbers generated by concatenating N, N, and 9.", "sequence": "229,449,11119,14149,22229,28289,31319,37379,44449,49499,52529,56569,67679,70709,71719,80809,86869,89899,94949,95959,1061069,1101109,1131139,1151159,1161169,1191199", "code": "\nimport numpy as np\nfrom functools import reduce\ndef factors(n):\n    return reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))\nfor i in range(1, 2000):\n    p1=int(str(i)+str(i)+\"1\")\n    if len(factors(p1))<3:\n        print(p1, end=',')\n"}
{"sequence_id": "A210515", "text": "Numbers N such that concatenation of N, N, and x generates a prime for x=1 and x=3 and x=7 and x=9.", "sequence": "1235,4061,8255,22775,24665,36500,44501,52343,54434,57644,58109,59567,59588,65018,69407,71789,78689,94280,98594,106748,114272,122504,134369,137129,138905,144302,162236,196439,235808,238235,269912,277919,278633,282461,290534", "code": "\nimport numpy as np\nfrom functools import reduce\ndef factors(n):\n    return reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))\nfor i in range(1,50000):\n    p1=int(str(i)+str(i)+\"1\")\n    p3=int(str(i)+str(i)+\"3\")\n    p7=int(str(i)+str(i)+\"7\")\n    p9=int(str(i)+str(i)+\"9\")\n    if len(factors(p1))<3 and len(factors(p3))<3 and len(factors(p7))<3 and len(factors(p9))<3:\n        print(i, end=',')\n"}
{"sequence_id": "A210521", "text": "Array read by downward antidiagonals: T(n,k) = (n+k-1)*(n+k-2) + n + floor((n+k)/2)*(1-2*floor((n+k)/2)), for n, k > 0", "sequence": "1,3,5,2,4,6,8,10,12,14,7,9,11,13,15,17,19,21,23,25,27,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,46,48,50,52,54,56,58,60,62,64,66,68", "code": "\nt=int((math.sqrt(8*n-7)-1)/2)\nv=int((t+2)/2)\nresult=2*n+v*(1-2*v)\n"}
{"sequence_id": "A210530", "text": "T(n,k) = (k + 3*n - 2 - (k+n-2)*(-1)^(k+n))/2 n, k > 0, read by antidiagonals.", "sequence": "1,2,3,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,9,10,11,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22", "code": "\nt=int((math.sqrt(8*n-7)-1)/2)\nv=int((t+2)/2)\nresult=n-v*(2*v-3)-1\n"}
{"sequence_id": "A210535", "text": "Second inverse function (numbers of columns) for pairing function A209293.", "sequence": "1,2,1,2,3,1,2,4,3,1,2,4,5,3,1,2,4,6,5,3,1,2,4,6,7,5,3,1,2,4,6,8,7,5,3,1,2,4,6,8,9,7,5,3,1,2,4,6,8,10,9,7,5,3,1,2,4,6,8,10,11,9,7,5,3,1,2,4,6,8,10,12,11,9,7,5,3,1,2,4,6,8,10,12", "code": "\nt=int((math.sqrt(8*n-7)-1)/2)\ni=n-t*(t+1)/2\nv=int((2*n+1-t*(t+1))/(t+3))\nresult=2*i-v*(4*i-2*t-3)\n"}
{"sequence_id": "A210536", "text": "T(n,k) = 3*n + (k-1) mod 3 - 2; n , k > 0, read by antidiagonals.", "sequence": "1,2,4,3,5,7,1,6,8,10,2,4,9,11,13,3,5,7,12,14,16,1,6,8,10,15,17,19,2,4,9,11,13,18,20,22,3,5,7,12,14,16,21,23,25,1,6,8,10,15,17,19,24,26,28,2,4,9,11,13,18,20,22,27,29,2,9,31,3,5,7,12,14,16", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=3*i + (j-1) % 3 - 2\n"}
{"sequence_id": "A210546", "text": "Emirps whose products of digits are prime.", "sequence": "13,17,31,71,113,311,1151,1511,111211,112111,1111711,1171111,11111117,11113111,11131111,71111111,111111131,131111111,1111115111,1115111111,11111111113,31111111111,111111111111111131,131111111111111111,1111111111111111111111111511", "code": "\nfrom __future__ import division\nfrom sympy import isprime\nA210546_list = []\nfor l in range(1,20):\n    q = (10**l-1)//9\n    for i in range(l):\n        for p in [2,3,5,7]:\n            r = q+(p-1)*10**i\n            s, t = str(r), str(r)[::-1]\n            if s != t and isprime(r) and isprime(int(t)):\n                A210546_list.append(r) \n"}
{"sequence_id": "A210589", "text": "Numbers which, when divided by their first digit, have their last digit as remainder.", "sequence": "10,20,21,30,31,32,40,41,42,43,50,51,52,53,54,60,61,62,63,64,65,70,71,72,73,74,75,76,80,81,82,83,84,85,86,87,90,91,92,93,94,95,96,97,98,100,110,120,130,140,150,160,170,180,190,200,201,210,211,220,221,230,231,240,241", "code": "\ndef ok(n): s = str(n); return n > 0 and n%int(s[0]) == int(s[-1])\nprint([k for k in range(242) if ok(k)]) \n"}
{"sequence_id": "A210596", "text": "Triangle read by rows of coefficients of polynomials v(n,x) jointly generated with A210221; see the Formula section.", "sequence": "1,1,2,2,2,4,3,6,4,8,5,10,16,8,16,8,20,28,40,16,32,13,36,64,72,96,32,64,21,66,124,184,176,224,64,128,34,118,248,376,496,416,512,128,256,55,210,476,808,1056,1280,960,1152,256,512,89,370,908,1640,2416", "code": "\nfrom sympy import Poly\nfrom sympy.abc import x\ndef u(n, x): return 1 if n==1 else u(n - 1, x) + v(n - 1, x)\ndef v(n, x): return 1 if n==1 else u(n - 1, x) + 2*x*v(n - 1, x)\ndef a(n): return Poly(v(n, x), x).all_coeffs()[::-1]\nfor n in range(1, 13): print (a(n)) \n"}
{"sequence_id": "A210698", "text": "Number of 2 X 2 matrices having all terms in {1,...,n} and determinant = 0 (mod 3).", "sequence": "1,8,33,90,209,528,889,1432,2673,3802,5297,8448,11025,14216,20625,25546,31393,42768,51145,60824,79233,92394,107297,135168,154657,176392,216513,244090,274481,330000,367641,408728,483153,533050,587089", "code": "\nfrom __future__ import division\ndef A210698(n):\n    if n % 3 == 0:\n        return 11*n**4//27\n    elif n % 3 == 1:\n        return (11*n**4 - 8*n**3 + 6*n**2 + 4*n + 14)//27\n    else:\n        return (11*n**4 - 16*n**3 + 24*n**2 + 32*n + 8)//27 \n"}
{"sequence_id": "A210725", "text": "Triangle read by rows: T(n,k) = number of forests of labeled rooted trees with n nodes and height at most k (n>=1, 0<=k<=n-1).", "sequence": "1,1,3,1,10,16,1,41,101,125,1,196,756,1176,1296,1,1057,6607,12847,16087,16807,1,6322,65794,160504,229384,257104,262144,1,41393,733833,2261289,3687609,4480569,4742649,4782969,1,293608,9046648,35464816,66025360,87238720,96915520,99637120,100000000", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef T(n, h): return 1 if min(n, h)==0 else sum([binomial(n - 1, j - 1)*j*T(j - 1, h - 1)*T(n - j, h) for j in range(1, n + 1)])\nfor n in range(1, 11): print([T(n, k) for k in range(n)]) \n"}
{"sequence_id": "A210729", "text": "a(n) = a(n-1) + a(n-2) + n + 3 with n>1, a(0)=1, a(1)=2.", "sequence": "1,2,8,16,31,55,95,160,266,438,717,1169,1901,3086,5004,8108,13131,21259,34411,55692,90126,145842,235993,381861,617881,999770,1617680,2617480,4235191,6852703,11087927,17940664,29028626,46969326,75997989,122967353", "code": "\nprpr, prev = 1,2\nfor n in range(2, 99):\n    current = prev+prpr+n+3\n    print(prpr, end=',')\n    prpr = prev\n    prev = current\n"}
{"sequence_id": "A210770", "text": "a(1) = 1, a(2) = 2; for n > 1, a(2*n+2) = smallest number not yet seen, a(2*n+1) = a(2*n) + a(2*n+2).", "sequence": "1,2,5,3,7,4,10,6,14,8,17,9,20,11,23,12,25,13,28,15,31,16,34,18,37,19,40,21,43,22,46,24,50,26,53,27,56,29,59,30,62,32,65,33,68,35,71,36,74,38,77,39,80,41,83,42,86,44,89,45,92,47,95,48,97,49,100", "code": "\ndef aupton(terms):\n    alst, seen = [1, 2], {1, 2}\n    for n in range(2, terms, 2):\n        anp1 = alst[-1] + 1\n        while anp1 in seen: anp1 += 1\n        an = alst[n-1] + anp1\n        alst, seen = alst + [an, anp1], seen | {an, anp1}\n    return alst[:terms]\nprint(aupton(67)) \n"}
{"sequence_id": "A211033", "text": "Number of 2 X 2 matrices having all elements in {0,1,...,n} and determinant = 0 (mod 3).", "sequence": "1,10,33,152,297,528,1217,1834,2673,4744,6385,8448,13073,16506,20625,29336,35545,42768,57457,67642,79233,102152,117729,135168,168929,191530,216513,264088,295561,330000,394721,437130,483153,568712,624337,684288,794737,866074", "code": "\nfrom __future__ import division\ndef A211033(n):\n    x,y,z = n//3 + 1, (n-1)//3 + 1, (n-2)//3 + 1\n    return x**4 + 4*x**3*y + 4*x**3*z + 4*x**2*y**2 + 8*x**2*y*z + 4*x**2*z**2 + y**4 + 6*y**2*z**2 + z**4 \n"}
{"sequence_id": "A211034", "text": "Number of 2 X 2 matrices having all elements in {0,1,...,n} and determinant = 1 (mod 3).", "sequence": "0,3,24,52,164,384,592,1131,1944,2628,4128,6144,7744,10955,15000,18100,23988,31104,36432,46179,57624,66052,81056,98304,110848,132723,157464,175284,205860,240000,264400,305723,351384,383812,438144,497664,539712,609531", "code": "\nfrom __future__ import division\ndef A211034(n):\n    x,y,z = n//3 + 1, (n-1)//3 + 1, (n-2)//3 + 1\n    return x**2*y**2 + 2*x**2*y*z + x**2*z**2 + 2*x*y**3 + 6*x*y**2*z + 6*x*y*z**2 + 2*x*z**3 + 2*y**3*z + 2*y*z**3 \n"}
{"sequence_id": "A211071", "text": "Number of 2 X 2 matrices having all terms in {1,...,n} and determinant = 1 (mod 3).", "sequence": "0,4,24,83,208,384,756,1332,1944,3099,4672,6144,8768,12100,15000,19995,26064,31104,39588,49588,57624,70931,86272,98304,117984,140292,157464,185283,216400,240000,277940,319924,351384,401643,456768", "code": "\nfrom __future__ import division\ndef A211071(n):\n    if n % 3 == 0:\n        return 8*n**4//27\n    elif n % 3 == 1:\n        return (8*n**4 + 4*n**3 - 3*n**2 - 2*n - 7)//27\n    else:\n        return (8*n**4 + 8*n**3 - 12*n**2 - 16*n - 4)//27 \n"}
{"sequence_id": "A211158", "text": "Number of 2 X 2 matrices having all terms in {-n,...,0,..,n} and positive odd determinant.", "sequence": "20,84,528,1040,3060,4788,10304,14400,26100,34100,55440,69264,104468,126420,180480,213248,291924,338580,448400,512400,660660,745844,940608,1051200,1301300,1441908,1756944,1932560,2322900,2538900,3015680,3277824,3852948,4167380", "code": "\ndef A211158(n):\n    return n*(n+1)*(3*n+1+3*n**2-(-1)**n*(2*n+1)) \n"}
{"sequence_id": "A211161", "text": "Table T(n,k) = n, if k is odd, k/2 if k is even; n, k > 0, read by antidiagonals.", "sequence": "1,1,2,1,1,3,2,2,1,4,1,2,3,1,5,3,2,2,4,1,6,1,3,3,2,5,1,7,4,2,3,4,2,6,1,8,1,4,3,3,5,2,7,1,9,5,2,4,4,3,6,2,8,1,10,1,5,3,4,5,3,7,2,9,1,11,6,2,5,4,4,6,3,8,2,10,1,12,1,6,3,5,5,4,7,3", "code": "\ndef a(n):\n    t=int((math.sqrt(8*n-7) - 1)/ 2)\n    i=n-t*(t+1)//2\n    j=(t*t+3*t+4)//2-n\n    return (1+(-1)**j)*j//4 - (-1+(-1)**j)*i//2\n"}
{"sequence_id": "A211191", "text": "List of odd values of k for which k^2+4 has a factor that is a square number larger than 1.", "sequence": "11,29,39,61,89,111,139,161,189,199,211,213,239,261,289,309,311,339,361,365,367,389,393,411,439,461,489,511,521,539,561,589,611,639,647,661,689,705,711,739,759,761,789,791,811,839,861,889,911,923,925,939,943,961,985,989", "code": "\nb=1\nx=1\nfor i in range(1, 100000, 2):\n....for j in range(2, i):\n.......if ((i**2)+4)%(j**2)==0:\n..........a=i\n..........if a!=b:\n.............b=a\n.............print(x,i)\n.............x=x+1\n"}
{"sequence_id": "A211197", "text": "Table T(n,k) = 2*n + ((-1)^n)*(1/2 - (k-1) mod 2) - 1/2; n, k > 0, read by antidiagonals.", "sequence": "1,2,4,1,3,5,2,4,6,8,1,3,5,7,9,2,4,6,8,10,12,1,3,5,7,9,11,13,2,4,6,8,10,12,14,16,1,3,5,7,9,11,13,15,17,2,4,6,8,10,12,14,16,18,20,1,3,5,7,9,11,13,15,17,19,21,2,4,6,8,10,12,14,16,18,20,22", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult =2*i+((-1)**i)*(0.5 - (j-1) % 2) - 0.5\n"}
{"sequence_id": "A211203", "text": "Prime numbers p such that p-1 divides (2^(p-1)+1)*(2^p-2).", "sequence": "2,3,7,11,19,31,43,79,127,151,163,211,251,271,311,331,379,487,547,631,751,811,883,991,1051,1171,1231,1459,1471,1831,1951,1999,2251,2311,2531,2647,2731,2791,2971,3079,3331,3511,3631,3691,3823,3943,4051,4447,4651", "code": "\nfrom sympy import primerange\nA211203_list = [p for p in primerange(1,10**6) if p == 2 or p == 3 or pow(2,2*p-1,p-1) == 2] \n"}
{"sequence_id": "A211264", "text": "Number of integer pairs (x,y) such that 0 < x < y <= n and x*y <= n.", "sequence": "0,1,2,3,4,6,7,9,10,12,13,16,17,19,21,23,24,27,28,31,33,35,36,40,41,43,45,48,49,53,54,57,59,61,63,67,68,70,72,76,77,81,82,85,88,90,91,96,97,100,102,105,106,110,112,116,118,120,121,127,128,130,133,136", "code": "\nfrom math import isqrt\ndef A211264(n): return (lambda m: sum(n//k for k in range(1, m+1))-m*(m+1)//2)(isqrt(n)) \n"}
{"sequence_id": "A211343", "text": "Triangle read by rows: T(n,k), n >= 1, k >= 1, in which column k lists the positive integers interleaved with k-1 zeros, and the first element of column k is in row k(k+1)/2.", "sequence": "1,2,3,1,4,0,5,2,6,0,1,7,3,0,8,0,0,9,4,2,10,0,0,1,11,5,0,0,12,0,3,0,13,6,0,0,14,0,0,2,15,7,4,0,1,16,0,0,0,0,17,8,0,0,0,18,0,5,3,0,19,9,0,0,0,20,0,0,0,2,21,10,6,0,0,1,22,0,0,4,0,0,23,11,0,0,0,0,24,0,7,0,0,0", "code": "\nfrom sympy import sqrt\nimport math\ndef a196020(n, k):return 2*n/k - k if (n - k*(k + 1)/2)%k == 0 else 0\ndef T(n, k): return int((1 + a196020(n, k))/2)\nfor n in range(1, 29): print([T(n, k) for k in range(1, int((sqrt(8*n + 1) - 1)/2) + 1)]) \n"}
{"sequence_id": "A211349", "text": "Primes p such that p-1 divides 2^p + 2.", "sequence": "2,3,11,251,5051,16811,2025251,8751251,16607051,28257611,69005051,78906251,176775251,210381251,372175451,550427051,707025251,854704451,1866788051,2441406251,2605806251,4249701251,5469531251,9304386251,10315761251,10915095251", "code": "\nfrom sympy import primerange\nA211349_list = [p for p in primerange(1,10**6) if p == 2 or pow(2,p,p-1) == p-3] \n"}
{"sequence_id": "A211377", "text": "T(n,k) = ((k + n)^2 - 4*k + 3 + (-1)^k - (k + n - 2)*(-1)^(k + n))/2; n, k > 0, read by antidiagonals.", "sequence": "1,3,4,2,5,6,8,9,12,13,7,10,11,14,15,17,18,21,22,25,26,16,19,20,23,24,27,28,30,31,34,35,38,39,42,43,29,32,33,36,37,40,41,44,45,47,48,51,52,55,56,59,60,63,64,46,49,50,53,54,57,58,61,62,65,66,68", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=((t+2)**2-4*j+3+(-1)**j-t*(-1)**(t+2))/2\n"}
{"sequence_id": "A211394", "text": "T(n,k) = (k+n)*(k+n-1)/2-(k+n-1)*(-1)^(k+n)-k+2; n , k > 0, read by antidiagonals.", "sequence": "1,5,6,2,3,4,12,13,14,15,7,8,9,10,11,23,24,25,26,27,28,16,17,18,19,20,21,22,38,39,40,41,42,43,44,45,29,30,31,32,33,34,35,36,37,57,58,59,60,61,62,63,64,65,66,46,47,48,49,50,51,52,53,54,55,56,80", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\nj=(t*t+3*t+4)/2-n\nresult=(t+2)*(t+1)/2-(t+1)*(-1)**t-j+2\n"}
{"sequence_id": "A211510", "text": "Number of ordered triples (w,x,y) with all terms in {1,...,n} and w^2 = x*y - 2n.", "sequence": "0,0,0,0,3,0,1,6,5,4,13,0,16,12,7,8,22,10,27,20,20,8,41,14,27,32,21,36,66,0,28,38,40,36,71,12,53,60,57,16,83,14,80,60,32,64,75,50,98,62,47,16,144,36,100,88,53,52,153,36,94,76,91,98,129,20,92,124,102", "code": "\nimport sympy\ndef A211510(n): return sum(x<=n and x*n>=w**2+2*n for w in range(1,n+1) for x in sympy.divisors(w**2+2*n)) \n"}
{"sequence_id": "A211889", "text": "Smallest positive d such that prime(n)+k*d is prime for 0 <= k <= n.", "sequence": "1,2,6,30,60,244230,6930,546840,3120613860,7399357350,10719893274090,173761834256010,14772517344885300", "code": "\nfrom sympy import isprime, prime, primorial, primepi\ndef A211889(n):\n    if n == 1:\n        return 1\n    delta = primorial(primepi(n))\n    p, d = prime(n), delta\n    while True:\n        q = p\n        for _ in range(n):\n            q += d\n            if not isprime(q):\n                break\n        else:\n            return d\n        d += delta \n"}
{"sequence_id": "A212173", "text": "First integer with same second signature as n (cf. A212172).", "sequence": "1,1,1,4,1,1,1,8,4,1,1,4,1,1,1,16,1,4,1,4,1,1,1,8,4,1,8,4,1,1,1,32,1,1,1,36,1,1,1,8,1,1,1,4,4,1,1,16,4,4,1,4,1,8,1,8,1,1,1,4,1,1,4,64,1,1,1,4,1,1,1,72,1,1,4,4,1,1,1,16,16,1,1,4", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef P(n): return sorted(factorint(n).values())\ndef a046523(n):\n    x=1\n    while True:\n        if P(n)==P(x): return x\n        else: x+=1\ndef a057521(n): return 1 if n==1 else reduce(mul, [1 if e==1 else p**e for p, e in factorint(n).items()])\ndef a(n): return a046523(a057521(n))\nprint([a(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A212180", "text": "Number of distinct second signatures (cf. A212172) represented among divisors of n.", "sequence": "1,1,1,2,1,1,1,3,2,1,1,2,1,1,1,4,1,2,1,2,1,1,1,3,2,1,3,2,1,1,1,5,1,1,1,3,1,1,1,3,1,1,1,2,2,1,1,4,2,2,1,2,1,3,1,3,1,1,1,2,1,1,2,6,1,1,1,2,1,1,1,5,1,1,2,2,1,1,1,4,4,1,1,2,1,1,1,3", "code": "\nfrom sympy import factorint, divisors, prod\ndef P(n): return sorted(factorint(n).values())\ndef a046523(n):\n    x=1\n    while True:\n        if P(n)==P(x): return x\n        else: x+=1\ndef a057521(n): return 1 if n==1 else prod(p**e for p, e in factorint(n).items() if e != 1)\ndef a212173(n): return a046523(a057521(n))\ndef a(n):\n    l=[]\n    for d in divisors(n):\n        x=a212173(d)\n        if not x in l:l+=[x, ]\n    return len(l)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A212181", "text": "Largest odd divisor of tau(n): a(n) = A000265(A000005(n)).", "sequence": "1,1,1,3,1,1,1,1,3,1,1,3,1,1,1,5,1,3,1,3,1,1,1,1,3,1,1,3,1,1,1,3,1,1,1,9,1,1,1,1,1,1,1,3,3,1,1,5,3,3,1,3,1,1,1,1,1,1,1,3,1,1,3,7,1,1,1,3,1,1,1,3,1,1,3,3,1,1,1,5,5,1,1,3,1,1,1,1", "code": "\nfrom sympy import divisor_count, divisors\ndef a(n): return [i for i in divisors(divisor_count(n)) if i%2][-1]\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A212309", "text": "a(n) = n! mod 3^n.", "sequence": "0,1,2,6,24,120,720,666,954,8586,26811,58725,173259,1189485,3898206,1077462,17239392,34789338,238787595,275338926,2019994119,578463687,2265847911,52114501953,121029900948,201452158890,1848601693368,4158660811014,2058540433587,36820880119062", "code": "\nimport math\nprint([math.factorial(n)%(3**n) for n in range(99)])\n"}
{"sequence_id": "A212310", "text": "a(n) = n! mod 4^n.", "sequence": "0,1,2,6,24,120,720,5040,40320,100736,483072,2168064,9239552,53005312,205203456,930568192,2004189184,12596379648,54936141824,81714020352,534768779264,1334539714560,2971594653696,68346677035008,232945365286912,1038559528091648,2232749779845120", "code": "\nimport math\nprint([math.factorial(n)%(4**n) for n in range(99)])\n"}
{"sequence_id": "A212314", "text": "Numbers m such that B(m^3) = B(m)*3, where B(m) is the binary weight of m (A000120).", "sequence": "0,5,9,10,17,18,20,33,34,36,39,40,49,65,66,68,69,72,78,80,98,105,129,130,132,135,136,138,144,156,160,169,196,199,209,210,229,257,258,260,263,264,270,272,276,277,288,291,297,312,313,320,338,359,365,392,395,398,418", "code": "\nimport math\nfor n in range(10000):\n    c1 = c2 = 0\n    t = n\n    while t:\n        c1+=t&1\n        t>>=1\n    t = n*n*n\n    while t:\n        c2+=t&1\n        t>>=1\n    if c1*3==c2: print(str(n), end=',')\n"}
{"sequence_id": "A212492", "text": "Prime p such that p, p+10, p+12 are all primes.", "sequence": "7,19,31,61,97,127,139,181,229,271,337,409,421,607,631,811,1009,1021,1039,1051,1279,1291,1471,1597,1609,1657,1777,1861,1867,1987,2017,2131,2371,2539,2647,2677,2719,2791,3109,3319,3361,3457,3517,3529,3547,3571,3907", "code": "\nfrom sympy import isprime, primerange\ndef ok(p): return isprime(p+10) and isprime(p+12)\nprint(list(filter(ok, primerange(1, 3910)))) \n"}
{"sequence_id": "A212526", "text": "Negative integers in base -4.", "sequence": "13,12,11,10,23,22,21,20,33,32,31,30,1303,1302,1301,1300,1313,1312,1311,1310,1323,1322,1321,1320,1333,1332,1331,1330,1203,1202,1201,1200,1213,1212,1211,1210,1223,1222,1221,1220", "code": "\ndef A212526(n):\n    s, q = '', -n\n    while q >= 4 or q < 0:\n        q, r = divmod(q, -4)\n        if r < 0:\n            q += 1\n            r += 4\n        s += str(r)\n    return int(str(q)+s[::-1]) \n"}
{"sequence_id": "A212529", "text": "Negative numbers in base -2.", "sequence": "11,10,1101,1100,1111,1110,1001,1000,1011,1010,110101,110100,110111,110110,110001,110000,110011,110010,111101,111100,111111,111110,111001,111000,111011,111010,100101,100100,100111,100110,100001,100000,100011,100010,101101,101100,101111,101110,101001,101000,101011,101010,11010101", "code": "\ndef A212529(n):\n    s, q = '', -n\n    while q >= 2 or q < 0:\n        q, r = divmod(q, -2)\n        if r < 0:\n            q += 1\n            r += 2\n        s += str(r)\n    return int(str(q)+s[::-1]) \n"}
{"sequence_id": "A212798", "text": "Row 3 of array in A212796.", "sequence": "3,294,11664,367500,10609215,292626432,7839321861,205683135000,5312031978672,135495143785470,3421536337406913,85686871818240000,2130987634616000199,52682956706683197258,1295799745309605101520,31730077997731715070000", "code": "\n\nfrom graphillion import GraphSet\ndef make_CnXCk(n, k):\n    grids = []\n    for i in range(1, k + 1):\n        for j in range(1, n):\n            grids.append((i + (j - 1) * k, i + j * k))\n        grids.append((i + (n - 1) * k, i))\n    for i in range(1, k * n, k):\n        for j in range(1, k):\n            grids.append((i + j - 1, i + j))\n        grids.append((i + k - 1, i))\n    return grids\ndef A212798(n):\n    if n == 1: return 3\n    if n == 2: return 294\n    universe = make_CnXCk(n, 3)\n    GraphSet.set_universe(universe)\n    spanning_trees = GraphSet.trees(is_spanning=True)\n    return spanning_trees.len()\nprint([A212798(n) for n in range(1, 30)])  \n"}
{"sequence_id": "A212799", "text": "Row 4 of array in A212796.", "sequence": "4,2304,367500,42467328,4381392020,428652000000,40643137651228,3771854305099776,344499209234302500,31074298464967845120,2774871814779003772844,245741556726521856000000,21611621448116558812137652,1889376666754339457990201088,164334311374716912516773437500", "code": "\n\nfrom graphillion import GraphSet\ndef make_CnXCk(n, k):\n    grids = []\n    for i in range(1, k + 1):\n        for j in range(1, n):\n            grids.append((i + (j - 1) * k, i + j * k))\n        grids.append((i + (n - 1) * k, i))\n    for i in range(1, k * n, k):\n        for j in range(1, k):\n            grids.append((i + j - 1, i + j))\n        grids.append((i + k - 1, i))\n    return grids\ndef A212799(n):\n    if n == 1: return 4\n    if n == 2: return 2304\n    universe = make_CnXCk(4, n)\n    GraphSet.set_universe(universe)\n    spanning_trees = GraphSet.trees(is_spanning=True)\n    return spanning_trees.len()\nprint([A212799(n) for n in range(1, 8)])  \n"}
{"sequence_id": "A212844", "text": "a(n) = 2^(n+2) mod n.", "sequence": "0,0,2,0,3,4,1,0,5,6,8,4,8,2,2,0,8,4,8,4,11,16,8,16,3,16,23,8,8,16,8,0,32,16,2,4,8,16,32,24,8,4,8,20,23,16,8,16,22,46,32,12,8,4,7,16,32,16,8,4,8,16,32,0,63,58,8,64,32,36,8,40,8,16,47", "code": "\nfor n in range(1,99):\n    print(2**(n+2) % n, end=',')\n"}
{"sequence_id": "A212875", "text": "Primonacci numbers: composite numbers that appear in the Fibonacci-like sequence generated by their own prime factors.", "sequence": "4,9,12,25,27,169,1102,7921,22287,54289,103823,777627,876897,2550409,20854593,34652571,144237401,144342653,167901581,267911895,792504416,821223649,1103528482,2040412557,2852002829,3493254541,6033671841,15658859018,116085000401", "code": "\nfrom sympy import isprime, factorint\nfrom itertools import chain\nA212875_list = []\nfor n in range(2,10**6):\n....if not isprime(n):\n........x = sorted(chain.from_iterable([p]*e for p,e in factorint(n).items()))\n........y = sum(x)\n........while y < n:\n............x, y = x[1:]+[y], 2*y-x[0]\n........if y == n:\n............A212875_list.append(n) \n"}
{"sequence_id": "A213005", "text": "a(0)=1, a(n) = least k > a(n-1) such that k*a(n-1) is a triangular number.", "sequence": "1,3,5,9,17,33,45,72,143,152,303,420,451,603,952,1398,1572,2408,3762,4233,5880,6325,8469,13384,20079,34189,62769,82665,87448,161037,287283,371337,515745,533505,573815,734484,737035,737149,767505,825495,887865,1136468,2272935", "code": "\na = 1\nfor n in range(55):\n    print(a, end=',')\n    b = k = 0\n    while k<=a:\n        tn = b*(b+1)//2\n        k = 0\n        if tn%a==0:\n            k = tn // a\n        b += 1\n    a = k\n"}
{"sequence_id": "A213059", "text": "Subsets of positive integers arranged in canonical order.", "sequence": "1,12,2,123,13,23,3,1234,124,134,234,14,24,34,4,12345,1235,1245,1345,2345,125,135,145,235,245,345,15,25,35,45,5,123456,12346,12356,12456,13456,23456,1236,1246,1256,1346,1356,1456,2346,2356,2456,3456,126,136,146,156,236,246,256,346,356,456,16,26,36,46,56,6", "code": "\nfrom itertools import chain, combinations as C\ndef powerset(s): \n  return chain.from_iterable(C(s, r) for r in range(len(s), -1, -1))\ndef agen():\n  m = 1 \n  while True:\n    for p in powerset(range(1, m)): yield int(\"\".join(map(str, p+(m,))))\n    m += 1\ndef aupton(terms):\n  alst, g = [], agen()\n  while len(alst) < terms: alst += [next(g)]\n  return alst\nprint(aupton(63)) \n"}
{"sequence_id": "A213077", "text": "a(n) = round(n^2 - sqrt(n)).", "sequence": "0,0,3,7,14,23,34,46,61,78,97,118,141,165,192,221,252,285,320,357,396,436,479,524,571,620,671,724,779,836,895,955,1018,1083,1150,1219,1290,1363,1438,1515,1594,1675,1758,1842,1929,2018,2109,2202,2297,2394", "code": "\ncount = 0\nwhile count < 50:\n    ns = count * count\n    ns = ns - math.sqrt(count)\n    ns = round(ns)\n    print(ns, end=',')\n    count += 1\n"}
{"sequence_id": "A213081", "text": "Exclusive-or based Pascal triangle, read by rows: T(n,1)=T(n,n)=n and T(n,k) = T(n-1,k-1) XOR T(n-1,k), where XOR is the bitwise exclusive-or operator.", "sequence": "1,2,2,3,0,3,4,3,3,4,5,7,0,7,5,6,2,7,7,2,6,7,4,5,0,5,4,7,8,3,1,5,5,1,3,8,9,11,2,4,0,4,2,11,9,10,2,9,6,4,4,6,9,2,10,11,8,11,15,2,0,2,15,11,8,11,12,3,3,4,13,2,2,13,4,3,3,12,13,15", "code": "\nsrc = [0]*1024\ndst = [0]*1024\nfor i in range(1,39):\n    dst[0] = dst[i-1] = i\n    for j in range(1,i-1):\n        dst[j] = src[j-1]^src[j]\n    for j in range(i):\n        src[j] = dst[j]\n        print(dst[j], end=',')\n"}
{"sequence_id": "A213084", "text": "Numbers consisting of ones and eights.", "sequence": "1,8,11,18,81,88,111,118,181,188,811,818,881,888,1111,1118,1181,1188,1811,1818,1881,1888,8111,8118,8181,8188,8811,8818,8881,8888,11111,11118,11181,11188,11811,11818,11881,11888,18111,18118,18181,18188,18811,18818", "code": "\nres = []\ni = 0\nwhile len (res) < 260:\n    for c in str(i):\n        if c in '18':\n            continue\n        else:\n            break\n    else:\n        res.append(i)\n    i = i + 1\nprint(res)\n"}
{"sequence_id": "A213088", "text": "The Manhattan distance to the origin while traversing the first quadrant in a taxicab geometry.", "sequence": "0,1,2,1,2,3,4,3,2,3,4,5,6,5,4,3,4,5,6,7,8,7,6,5,4,5,6,7,8,9,10,9,8,7,6,5,6,7,8,9,10,11,12,11,10,9,8,7,6,7,8,9,10,11,12,13,14,13,12,11,10,9,8,7,8,9,10,11,12,13,14,15,16,15,14,13,12,11", "code": "\ndef f(x, y):\n    if not x and y % 2:\n        y = y + 1\n    elif not y and not x % 2:\n        x = x + 1\n    elif x == y:\n        if x % 2:\n            x = x - 1\n        else:\n            y = y - 1\n    elif y < x:\n        if x % 2:\n            y = y + 1\n        else:\n            y = y - 1\n    else:\n        if y % 2:\n            x = x - 1\n        else:\n            x = x + 1\n    return x, y\nres = []\nx = y = 0\nfor i in range(100):\n    res.append(x + y)\n    x, y = f(x, y)\nprint(res)\n"}
{"sequence_id": "A213126", "text": "Rows of triangle formed using Pascal's rule, except sums in the n-th row are modulo n: T(n,0) = T(n,n) = 1 and T(n,k) = (T(n-1,k-1) + T(n-1,k)) mod n.", "sequence": "1,1,1,1,0,1,1,1,1,1,1,2,2,2,1,1,3,4,4,3,1,1,4,1,2,1,4,1,1,5,5,3,3,5,5,1,1,6,2,0,6,0,2,6,1,1,7,8,2,6,6,2,8,7,1,1,8,5,0,8,2,8,0,5,8,1,1,9,2,5,8,10,10,8,5,2,9,1,1,10,11,7,1,6,8,6", "code": "\nsrc = [0]*1024\ndst = [0]*1024\nfor n in range(19):\n    dst[0] = dst[n] = 1\n    for k in range(1, n):\n        dst[k] = (src[k-1]+src[k]) % n\n    for k in range(n+1):\n        src[k] = dst[k]\n        print(dst[k], end=',')\n"}
{"sequence_id": "A213171", "text": "T(n,k) = ((k+n)^2 - 4*k + 3 - (-1)^n - (k+n)*(-1)^(k+n))/2; n, k > 0, read by antidiagonals.", "sequence": "1,4,5,2,3,6,9,10,13,14,7,8,11,12,15,18,19,22,23,26,27,16,17,20,21,24,25,28,31,32,35,36,39,40,43,44,29,30,33,34,37,38,41,42,45,48,49,52,53,56,57,60,61,64,65,46,47,50,51,54,55,58,59,62,63,66,69", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=((t+2)**2-4*j+3-(-1)**i-(t+2)*(-1)**t)/2\n"}
{"sequence_id": "A213183", "text": "Initialize a(1)=R=1. Repeat: copy the last R preceding terms to current position; increment R; do twice: append the least integer that has not appeared in the sequence yet.", "sequence": "1,1,2,3,2,3,4,5,3,4,5,6,7,4,5,6,7,8,9,5,6,7,8,9,10,11,6,7,8,9,10,11,12,13,7,8,9,10,11,12,13,14,15,8,9,10,11,12,13,14,15,16,17,9,10,11,12,13,14,15,16,17,18,19,10,11,12,13,14,15,16,17,18,19,20,21,11,12", "code": "\na = [1]*992\nR = 1\ni = 2\nwhile i<900:\n        for t in range(R):\n                a[i] = a[i-R]\n                i += 1\n        R += 1\n        a[i] = a[i-1] + 1\n        i += 1\n        a[i] = a[i-1] + 1\n        i += 1\nfor i in range(1,99):\n        print(a[i], end=',')\n"}
{"sequence_id": "A213194", "text": "First inverse function (numbers of rows) for pairing function A211377.", "sequence": "1,1,1,2,2,3,1,1,2,2,3,3,4,4,5,1,1,2,2,3,3,4,4,5,5,6,6,7,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=(3*i+j-1-(-1)**i+(i+j-2)*(-1)**(i+j))/4\n"}
{"sequence_id": "A213195", "text": "Second inverse function (of columns) for pairing function A211377.", "sequence": "1,3,2,1,2,1,5,4,3,4,3,2,1,2,1,7,6,5,6,5,4,3,4,3,2,1,2,1,9,8,7,8,7,6,5,6,5,4,3,4,3,2,1,2,1,11,10,9,10,9,8,7,8,7,6,5,6,5,4,3,4,3,2,1,2,1,13,12,11,12,11,10,9,10,9,8,7,8,7,6,5,6,5,4", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=((1+(-1)**i)*((1+(-1)**j)*2*int((j+2)/4)-(-1+(-1)**j)*(2*int((i+4)/4)+2*int(j/2)))-(-1+(-1)**i)*((1+(-1)**j)*(1+2*int(i/4)+2*int(j/2))-(-1+(-1)**j)*(1+2*int(j/4))))/4\n"}
{"sequence_id": "A213196", "text": "Inverse permutation of A211377.", "sequence": "1,4,2,3,5,6,11,7,8,12,13,9,10,14,15,22,16,17,23,24,18,19,25,26,20,21,27,28,37,29,30,38,39,31,32,40,41,33,34,42,43,35,36,44,45,56,46,47,57,58,48,49,59,60,50,51,61,62,52,53,63,64,54,55,65,66,79", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nm1=(3*i+j-1-(-1)**i+(i+j-2)*(-1)**(i+j))/4\nm2=((1+(-1)**i)*((1+(-1)**j)*2*int((j+2)/4)-(-1+(-1)**j)*(2*int((i+4)/4)+2*int(j/2)))-(-1+(-1)**i)*((1+(-1)**j)*(1+2*int(i/4)+2*int(j/2))-(-1+(-1)**j)*(1+2*int(j/4))))/4\nresult=(m1+m2-1)*(m1+m2-2)/2+m1\n"}
{"sequence_id": "A213197", "text": "T(n,k) = (2*(n+k)^2 - 2*(n+k) - 4*k + 6 + (2*k-2)*(-1)^n + (2*k-1)*(-1)^k + (-2*n+1)*(-1)^(n+k))/4; n, k > 0, read by antidiagonals.", "sequence": "1,3,4,2,6,5,8,9,11,12,7,15,10,14,13,17,18,20,21,23,24,16,28,19,27,22,26,25,30,31,33,34,36,37,39,40,29,45,32,44,35,43,38,42,41,47,48,50,51,53,54,56,57,59,60,46,66,49,65,52,64,55,63,58,62,61,68", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=(2*(t+2)**2-2*(t+2)-4*j+6 +(2*j-2)*(-1)**i+(2*j-1)*(-1)**j+(-2*i+1)*(-1)**t)/4\n"}
{"sequence_id": "A213205", "text": "T(n,k) = ((k+n)^2-4*k+3+(-1)^k-2*(-1)^n-(k+n)*(-1)^(k+n))/2; n , k > 0, read by antidiagonals.", "sequence": "1,5,4,2,3,6,10,9,14,13,7,8,11,12,15,19,18,23,22,27,26,16,17,20,21,24,25,28,32,31,36,35,40,39,44,43,29,30,33,34,37,38,41,42,45,49,48,53,52,57,56,61,60,65,64,46,47,50,51,54,55,58,59,62,63,66,70", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=((t+2)**2-4*j+3+(-1)**j-2*(-1)**i-(t+2)*(-1)**t)/2\n"}
{"sequence_id": "A213239", "text": "Numbers n such that sum of digits of n = sum of digits of anti-divisors of n.", "sequence": "5,8,64,691,1779,2851,6361,9066,9606,9771,10789,10996,18996,21481,22569,27529,27691,31516,36709,36776,42649,48651,53296,56586,58749,60369,64794,72889,76754,78766,79374,79896,80989,86596,90606,90879,92766,96171,98979,108529", "code": "\n[n for n in range(1,10**5) if sum([sum([int(x) for x in str(d)]) for d in range(2,n) if n % d and 2*n % d in [d-1,0,1]]) == sum([int(x) for x in str(n)])] \n"}
{"sequence_id": "A213260", "text": "p(5n+4) where p(k) = number of partitions of k = A000041(k).", "sequence": "5,30,135,490,1575,4565,12310,31185,75175,173525,386155,831820,1741630,3554345,7089500,13848650,26543660,49995925,92669720,169229875,304801365,541946240,952050665,1653668665,2841940500,4835271870,8149040695,13610949895,22540654445,37027355200,60356673280,97662728555,156919475295", "code": "\nfrom sympy.ntheory import npartitions\ndef a(n): return npartitions(5*n+4)\nprint([a(n) for n in range(33)]) \n"}
{"sequence_id": "A213370", "text": "a(n) = n AND 2*n, where AND is the bitwise AND operator.", "sequence": "0,0,0,2,0,0,4,6,0,0,0,2,8,8,12,14,0,0,0,2,0,0,4,6,16,16,16,18,24,24,28,30,0,0,0,2,0,0,4,6,0,0,0,2,8,8,12,14,32,32,32,34,32,32,36,38,48,48,48,50,56,56,60,62,0,0,0,2,0,0,4,6,0,0,0,2,8,8", "code": "\nfor n in range(99):\n    print(2*n & n, end=\", \")\n"}
{"sequence_id": "A213381", "text": "a(n) = n^n mod (n+2).", "sequence": "1,1,0,2,4,3,0,7,6,5,4,6,8,13,0,8,16,9,4,19,12,11,16,17,14,7,4,14,16,15,0,31,18,13,16,18,20,37,24,20,16,21,4,7,24,23,16,17,6,49,4,26,34,3,8,55,30,29,4,30,32,61,0,57,16,33,4,67,46,35,16,36,38", "code": "\nprint([n**n % (n+2) for n in range(99)])\n"}
{"sequence_id": "A213382", "text": "Numbers n such that n^n mod (n + 2) = n.", "sequence": "1,4,7,13,16,19,31,37,49,55,61,67,85,91,109,121,127,139,157,175,181,193,196,199,211,217,235,247,265,289,301,307,313,319,325,337,379,391,397,409,415,445,451,469,487,499,517,535,541,571,577,589,595,631,667,679", "code": "\nfor n in range(999):\n    x = n**n % (n+2)\n    if x==n:\n        print(n, end=\", \")\n"}
{"sequence_id": "A213500", "text": "Rectangular array T(n,k):  (row n) = b**c, where b(h) = h, c(h) = h + n - 1, n >= 1, h >= 1, and ** = convolution.", "sequence": "1,4,2,10,7,3,20,16,10,4,35,30,22,13,5,56,50,40,28,16,6,84,77,65,50,34,19,7,120,112,98,80,60,40,22,8,165,156,140,119,95,70,46,25,9,220,210,192,168,140,110,80,52,28,10,286,275,255,228,196,161,125,90", "code": "\ndef t(n, k): return sum((k - i) * (n + i) for i in range(k))\nfor n in range(1, 13):\n    print([t(k, n - k + 1) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A213526", "text": "a(n) = 3*n AND n, where AND is the bitwise AND operator.", "sequence": "0,1,2,1,4,5,2,5,8,9,10,1,4,5,10,13,16,17,18,17,20,21,2,5,8,9,10,17,20,21,26,29,32,33,34,33,36,37,34,37,40,41,42,1,4,5,10,13,16,17,18,17,20,21,34,37,40,41,42,49,52,53,58,61,64,65,66,65,68", "code": "\nfor n in range(99):\n    print(3*n & n, end=',')\n"}
{"sequence_id": "A213540", "text": "Numbers k such that k AND k*2 = 2, where AND is the bitwise AND operator.", "sequence": "3,11,19,35,43,67,75,83,131,139,147,163,171,259,267,275,291,299,323,331,339,515,523,531,547,555,579,587,595,643,651,659,675,683,1027,1035,1043,1059,1067,1091,1099,1107,1155,1163,1171,1187,1195,1283,1291,1299,1315", "code": "\nfor n in range(1777):\n    a = 2*n & n\n    if a==2:\n        print(n, end=',')\n"}
{"sequence_id": "A213541", "text": "a(n) = n AND n^2, where AND is the bitwise AND operator.", "sequence": "0,1,0,1,0,1,4,1,0,1,0,9,0,9,4,1,0,1,0,1,16,17,4,17,0,17,0,25,16,9,4,1,0,1,0,1,0,1,36,33,0,1,32,41,0,41,4,33,0,33,0,33,16,49,36,17,0,49,32,25,16,9,4,1,0,1,0,1,0,1,4,1,64,65,64,73,0,9,68", "code": "\nprint([n*n & n for n in range(99)])\n"}
{"sequence_id": "A213542", "text": "a(n) = k AND k^k, where k=2*n+1, AND is the bitwise AND operator.", "sequence": "1,3,5,7,9,3,13,15,17,3,5,7,25,3,13,31,33,35,5,7,41,35,13,15,49,35,37,7,57,35,45,63,65,67,69,7,9,3,13,15,81,67,5,7,25,3,77,31,97,35,5,7,41,99,77,15,113,35,37,7,57,99,109,127,129,131,133,7,137,131", "code": "\nprint([k**k & k for k in range(1,222,2)])\n"}
{"sequence_id": "A213543", "text": "a(n) = n AND 3^n, where AND is the bitwise AND operator.", "sequence": "0,1,0,3,0,1,0,3,0,1,8,11,0,1,8,11,0,1,0,19,16,17,16,3,0,1,8,27,16,17,24,11,0,1,0,3,0,33,0,3,32,33,40,43,32,1,40,43,0,1,0,19,16,49,16,3,32,33,40,59,48,17,56,43,0,1,0,3,64,65,64,3,0,65,8,75", "code": "\nprint([3**n & n for n in range(99)])\n"}
{"sequence_id": "A213636", "text": "Remainder when n is divided by its least nondivisor.", "sequence": "1,2,1,1,1,2,1,2,1,1,1,2,1,2,1,1,1,2,1,2,1,1,1,4,1,2,1,1,1,2,1,2,1,1,1,1,1,2,1,1,1,2,1,2,1,1,1,3,1,2,1,1,1,2,1,2,1,1,1,4,1,2,1,1,1,2,1,2,1,1,1,2,1,2,1,1,1,2,1,2,1,1,1,4,1,2,1,1,1,2,1,2,1,1,1,1,1,2,1", "code": "\ndef a(n):\n    k=2\n    while n%k==0: k+=1\n    return n%k\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A213705", "text": "a(n)=n if n <= 3, otherwise a(n) = A007477(n-1)+A007477(n).", "sequence": "1,2,3,5,9,17,33,66,134,277,579,1224,2610,5609,12135,26408,57770,126962,280192,620674,1379586,3075943,6877611,15417934,34646156,78027146,176087292,398143230,901827322,2046112299,4649558191,10581041518,24112473412,55019560650,125696393844,287494670302", "code": "\nfrom sympy import binomial\ndef b(n): return sum([binomial(2*k + 2, n - k - 2)*binomial(n - k - 2, k)//(k + 1) for k in range(n - 1)])\ndef a(n): return n if n<3 else b(n - 1) + b(n)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A213714", "text": "Inverse function for injection A005187.", "sequence": "0,1,0,2,3,0,0,4,5,0,6,7,0,0,0,8,9,0,10,11,0,0,12,13,0,14,15,0,0,0,0,16,17,0,18,19,0,0,20,21,0,22,23,0,0,0,24,25,0,26,27,0,0,28,29,0,30,31,0,0,0,0,0,32,33,0,34,35,0,0,36,37,0,38,39,0,0,0,40,41,0,42,43,0,0,44,45,0,46,47,0", "code": "\nfrom sympy import factorial\ndef a046699(n):\n    if n<3: return 1\n    s=1\n    while factorial(2*s)%(2**(n - 1))>0: s+=1\n    return s\ndef a053644(n): return 0 if n==0 else 2**(len(bin(n)[2:]) - 1)\ndef a043545(n):\n    x=bin(n)[2:]\n    return int(max(x)) - int(min(x))\ndef a079559(n): return 1 if n==0 else a043545(n + 1)*a079559(n + 1 - a053644(n + 1))\ndef a(n): return 0 if n==0 else a079559(n)*(a046699(n + 2) - 1) \n"}
{"sequence_id": "A213859", "text": "a(n) = 2^n mod (n+2).", "sequence": "1,2,0,3,4,4,0,2,6,6,4,7,8,2,0,9,16,10,4,2,12,12,16,8,14,20,4,15,16,16,0,2,18,22,16,19,20,2,24,21,16,22,4,38,24,24,16,32,6,2,4,27,34,52,8,2,30,30,4,31,32,2,0,8,16,34,4,2,46,36,16,37,38,17", "code": "\nprint([2**n % (n+2) for n in range(222)])\n"}
{"sequence_id": "A213902", "text": "Number of integers of the form 6*k+1 and 6*k-1 between prime(n) and prime(n+1).", "sequence": "0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,0,1,0,1,2,0,0,0,0,0,4,0,1,0,2,0,1,1,0,1,1,0,2,0,0,0,3,3,0,0,0,1,0,2,1,1,1,0,1,0,0,2,4,0,0,0,4,1,2,0,0,1,2,1,1,0,1,2,0,2,2,0,2,0,1,0,1,2", "code": "\n\nfor i in range(777):\n    prime = primes[i]\n    nextp = primes[i+1]\n    k = nextp//6 - prime//6\n    if k:\n        k = (k-1)*2 + (prime%6==1) + (nextp%6==5)\n    print(str(k), end=',')\n"}
{"sequence_id": "A213921", "text": "Natural numbers placed in table T(n,k) layer by layer. The order of placement: at the beginning filled odd places of layer clockwise, next - even places clockwise. Table T(n,k) read by antidiagonals.", "sequence": "1,2,3,5,4,7,10,8,9,13,17,14,6,16,21,26,22,11,12,25,31,37,32,18,15,20,36,43,50,44,27,23,24,30,49,57,65,58,38,33,19,35,42,64,73,82,74,51,45,28,29,48,56,81,91,101,92,66,59,39,34,41,63,72,100,111", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nif i > j:\n   result=i*i-(j%2)*i+2-int((j+2)/2)\nelse:\n   result=j*j-((i%2)+1)*j + int((i+3)/2)\n"}
{"sequence_id": "A213922", "text": "Natural numbers placed in table T(n,k) layer by layer. The order of placement: T(n,n), T(n-1,n), T(n,n-1), ... T(1,n), T(n,1). Table T(n,k) read by antidiagonals.", "sequence": "1,3,4,8,2,9,15,6,7,16,24,13,5,14,25,35,22,11,12,23,36,48,33,20,10,21,34,49,63,46,31,18,19,32,47,64,80,61,44,29,17,30,45,62,81,99,78,59,42,27,28,43,60,79,100,120,97,76,57,40,26,41,58,77,98,121", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nif i >= j:\n   result=i*i-2*j+2\nelse:\n   result=j*j-2*i+1\n"}
{"sequence_id": "A213927", "text": "T(n,k) = (z*(z-1)-(-1+(-1)^(z^2 mod 3))*n+(1+(-1)^(z^2 mod 3))*k)/2, where z=n+k-1; n, k > 0, read by antidiagonals.", "sequence": "1,2,3,6,5,4,7,8,9,10,11,12,13,14,15,21,20,19,18,17,16,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,45,44,43,42,41,40,39,38,37,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,78", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nz=i+j-1\nresult=(z*(z-1)-(-1+(-1)**(z**2%3))*i+(1+(-1)**(z**2%3))*j)/2\n"}
{"sequence_id": "A213928", "text": "Natural numbers placed in table T(n,k) layer by layer. The order of placement - at the beginning 2 layers counterclockwise, next 1 layer clockwise and so on. T(n,k) read by antidiagonals.", "sequence": "1,4,2,5,3,9,16,6,8,10,25,15,7,11,17,26,24,14,12,18,36,49,27,23,13,19,35,37,64,48,28,22,20,34,38,50,65,63,47,29,21,33,39,51,81,100,66,62,46,30,32,40,52,80,82,121,99,67,61,45,31,41,53,79,83,101", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nif j>=i:\n   result=((1+(-1)**(j**2%3-1))*(j**2-i+1)-(-1+(-1)**(j**2%3-1))*((j-1)**2 +i))/2\nelse:\n   result=((1+(-1)**(i**2%3))*(i**2-j+1)-(-1+(-1)**(i**2%3))*((i-1)**2 +j))/2\n"}
{"sequence_id": "A214039", "text": "a(n) = a(n-1) - floor((a(n-2) + a(n-3))/2), with a(n)=n for n < 3.", "sequence": "0,1,2,2,1,-1,-2,-2,0,2,3,2,0,-2,-3,-2,1,4,5,3,-1,-5,-6,-3,3,8,8,3,-5,-10,-9,-1,9,14,10,-1,-13,-17,-10,5,19,22,10,-10,-26,-26,-8,18,35,30,4,-28,-45,-33,4,43,58,35,-15,-61,-71,-33,33,85,85", "code": "\nppp =0\nprpr=1\nprev=2\nfor n in range(65):\n    cur = prev-(prpr+ppp)//2\n    print(str(ppp), end=',')\n    ppp = prpr\n    prpr= prev\n    prev= cur\n"}
{"sequence_id": "A214041", "text": "a(n) = a(n-1) + floor((a(n-2) + a(n-3))/2), with a(n)=1 for n < 3.", "sequence": "1,1,1,2,3,4,6,9,14,21,32,49,75,115,177,272,418,642,987,1517,2331,3583,5507,8464,13009,19994,30730,47231,72593,111573,171485,263568,405097,622623,956955,1470815,2260604,3474489,5340198,8207744,12615087,19389058", "code": "\nppp=prpr=prev=1\nfor n in range(65):\n    cur=prev+(prpr+ppp)//2\n    print(str(ppp), end=',')\n    ppp,prpr,prev = prpr,prev,cur\n"}
{"sequence_id": "A214126", "text": "a(2n)=a(n-1)+a(n) and a(2n+1)=a(n+1) for n>=1, with a(0)=a(1)=1.", "sequence": "1,1,2,2,3,2,4,3,5,2,5,4,6,3,7,5,8,2,7,5,7,4,9,6,10,3,9,7,10,5,12,8,13,2,10,7,9,5,12,7,12,4,11,9,13,6,15,10,16,3,13,9,12,7,16,10,17,5,15,12,17,8,20,13,21,2,15,10,12,7,17,9,16,5,14,12", "code": "\na = [1]*(77*2)\nfor n in range(1,77):\n    a[2*n  ]=a[n-1]+a[n]\n    a[2*n+1]=a[n+1]\n    print(str(a[n-1]),end=',')\n"}
{"sequence_id": "A214127", "text": "a(2n) = a(n-1) + a(n) and a(2n+1) = a(n+1) for n>=1, with a(0)=1, a(1)=2.", "sequence": "1,2,3,3,5,3,6,5,8,3,8,6,9,5,11,8,13,3,11,8,11,6,14,9,15,5,14,11,16,8,19,13,21,3,16,11,14,8,19,11,19,6,17,14,20,9,23,15,24,5,20,14,19,11,25,16,27,8,24,19,27,13,32,21,34,3,24,16,19,11,27,14,25", "code": "\na = [1]*(77*2)\na[1]=2\nfor n in range(1,77):\n    a[2*n  ]=a[n-1]+a[n]\n    a[2*n+1]=a[n+1]\n    print(str(a[n-1]),end=',')\n"}
{"sequence_id": "A214176", "text": "Sum of the 8 nearest neighbors of n in a spiral with positive integers.", "sequence": "44,58,72,62,96,82,120,94,104,152,120,130,184,146,144,164,224,180,176,198,264,214,208,216,240,312,256,248,256,282,360,298,288,296,304,332,416,348,336,344,352,382,472,398,384,392,400,408,440,536,456,440", "code": "\nSIZE=11  \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\nsaveX = [0]* (SIZE*SIZE+1)\nsaveY = [0]* (SIZE*SIZE+1)\nsaveX[1]=posX\nsaveY[1]=posY\ndef walk(stepX,stepY,chkX,chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    saveX[n]=posX\n    saveY[n]=posY\n    n+=1\n    if posX+posY==0 or grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk(0,-1, 1, 0)    \n    if posX+posY==0:\n        break\n    walk(1, 0, 0, 1)    \n    walk(0, 1,-1, 0)    \n    walk(-1,0, 0,-1)    \nfor n in range(1,(SIZE-2)*(SIZE-2)+1):\n    posX = saveX[n]\n    posY = saveY[n]\n    k = grid[(posY-1)*SIZE+posX] + grid[(posY+1)*SIZE+posX]\n    k+= grid[(posY-1)*SIZE+posX-1] + grid[(posY-1)*SIZE+posX+1]\n    k+= grid[(posY+1)*SIZE+posX-1] + grid[(posY+1)*SIZE+posX+1]\n    print k+grid[posY*SIZE+posX-1] + grid[posY*SIZE+posX+1],\n"}
{"sequence_id": "A214226", "text": "Sum of the eight nearest neighbors of n in a triangular horizontal-last spiral with positive integers.", "sequence": "72,80,60,76,132,100,164,112,136,200,144,128,128,136,156,196,284,220,204,208,324,224,232,248,288,384,296,264,256,264,272,280,288,296,324,380,500,404,372,368,376,384,548,400,408,416,424,448,504,632,512,464,448", "code": "\nSIZE=27 \ngrid = [0] * (SIZE*SIZE)\nsaveX = [0]* (SIZE*SIZE)\nsaveY = [0]* (SIZE*SIZE)\nsaveX[1] = saveY[1] = posX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX,stepY,chkX,chkY,chkX2,chkY2):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    saveX[n]=posX\n    saveY[n]=posY\n    n+=1\n    if posX==0 or grid[(posY+chkY)*SIZE+posX+chkX]+grid[(posY+chkY2)*SIZE+posX+chkX2]==0:\n        return\nwhile 1:\n    walk( 1, 1, -1,  0, -1, 0)    \n    walk(-1, 0,  1, -1, 0, -1)    \n    if posX==0:\n        break\n    walk( 1,-1,  1, 1, 1, 1)    \nfor n in range(1,101):\n    posX = saveX[n]\n    posY = saveY[n]\n    k = grid[(posY-1)*SIZE+posX] + grid[(posY+1)*SIZE+posX]\n    k+= grid[(posY-1)*SIZE+posX-1] + grid[(posY-1)*SIZE+posX+1]\n    k+= grid[(posY+1)*SIZE+posX-1] + grid[(posY+1)*SIZE+posX+1]\n    k+= grid[posY*SIZE+posX-1] + grid[posY*SIZE+posX+1]\n    print k,\n"}
{"sequence_id": "A214230", "text": "Sum of the eight nearest neighbors of n in a right triangular type-1 spiral with positive integers.", "sequence": "53,88,78,125,85,84,125,97,108,143,223,168,158,169,201,284,208,183,179,187,210,281,226,219,227,235,261,314,430,339,311,310,318,326,346,396,515,403,360,347,355,363,371,379,411,509,427,411,419,427,435,443,451,486,557", "code": "\nSIZE=29  \ngrid = [0] * (SIZE*SIZE)\nsaveX = [0]* (SIZE*SIZE)\nsaveY = [0]* (SIZE*SIZE)\nsaveX[1] = saveY[1] = posX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX,stepY,chkX,chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    saveX[n]=posX\n    saveY[n]=posY\n    n+=1\n    if posY==0 or grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk(0, -1,  1,  1)    \n    if posY==0:\n        break\n    walk( 1, 1, -1,  0)    \n    walk(-1, 0,  0, -1)    \nfor n in range(1,92):\n    posX = saveX[n]\n    posY = saveY[n]\n    k = grid[(posY-1)*SIZE+posX] + grid[(posY+1)*SIZE+posX]\n    k+= grid[(posY-1)*SIZE+posX-1] + grid[(posY-1)*SIZE+posX+1]\n    k+= grid[(posY+1)*SIZE+posX-1] + grid[(posY+1)*SIZE+posX+1]\n    k+= grid[posY*SIZE+posX-1] + grid[posY*SIZE+posX+1]\n    print k,\n"}
{"sequence_id": "A214250", "text": "Sum of the eight nearest neighbors of n in a triangular \"horizontal-first\" spiral with positive integers.", "sequence": "56,80,108,84,132,92,84,96,128,200,152,144,236,160,172,204,284,212,188,184,192,200,208,232,280,384,304,280,280,288,428,304,312,320,340,388,500,396,356,344,352,360,368,376,384,392,400,432,496,632,520,480,472,480", "code": "\nSIZE=29  \ngrid = [0] * (SIZE*SIZE)\nsaveX = [0]* (SIZE*SIZE)\nsaveY = [0]* (SIZE*SIZE)\nsaveX[1] = saveY[1] = posX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX,stepY,chkX,chkY,chkX2,chkY2):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    saveX[n]=posX\n    saveY[n]=posY\n    n+=1\n    if posX==0 or grid[(posY+chkY)*SIZE+posX+chkX]+grid[(posY+chkY2)*SIZE+posX+chkX2]==0:\n        return\nwhile 1:\n    walk(-1, 0,  1, -1, 0, -1)   \n    if posX==0:\n        break\n    walk( 1,-1,  1, 1,  1, 1)    \n    walk( 1, 1, -1,  0, -1, 0)   \nfor n in range(1,122):\n    posX = saveX[n]\n    posY = saveY[n]\n    k = grid[(posY-1)*SIZE+posX] + grid[(posY+1)*SIZE+posX]\n    k+= grid[(posY-1)*SIZE+posX-1] + grid[(posY-1)*SIZE+posX+1]\n    k+= grid[(posY+1)*SIZE+posX-1] + grid[(posY+1)*SIZE+posX+1]\n    k+= grid[posY*SIZE+posX-1] + grid[posY*SIZE+posX+1]\n    print k,\n"}
{"sequence_id": "A214251", "text": "Sum of the eight nearest neighbors of n in a right triangular type-2 spiral with positive integers.", "sequence": "62,64,69,125,94,111,170,118,105,116,169,132,131,151,192,284,217,201,206,220,258,353,265,234,227,235,243,269,349,285,275,283,291,299,328,387,515,412,378,374,382,390,398,421,477,608,484,435,419,427,435", "code": "\nSIZE=29  \ngrid = [0] * (SIZE*SIZE)\nsaveX = [0]* (SIZE*SIZE)\nsaveY = [0]* (SIZE*SIZE)\nsaveX[1] = saveY[1] = posX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    saveX[n]=posX\n    saveY[n]=posY\n    n+=1\n    if posY==0 or grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk(-1, 0,  0, -1)    \n    walk(0, -1,  1,  1)    \n    if posY==0:\n        break\n    walk( 1, 1, -1,  0)    \nfor n in range(1, 92):\n    posX = saveX[n]\n    posY = saveY[n]\n    k = grid[(posY-1)*SIZE+posX] + grid[(posY+1)*SIZE+posX]\n    k+= grid[(posY-1)*SIZE+posX-1] + grid[(posY-1)*SIZE+posX+1]\n    k+= grid[(posY+1)*SIZE+posX-1] + grid[(posY+1)*SIZE+posX+1]\n    k+= grid[posY*SIZE+posX-1] + grid[posY*SIZE+posX+1]\n    print k,\n"}
{"sequence_id": "A214252", "text": "Sum of the eight nearest neighbors of n in a right triangular type-3 spiral with positive integers.", "sequence": "62,88,63,89,76,102,170,127,126,152,223,159,140,139,159,221,175,171,179,202,249,353,274,252,254,262,279,323,430,330,293,283,291,299,307,336,425,352,339,347,355,363,371,403,468,608,493,453,446,454,462,470,478,504", "code": "\nSIZE=28  \ngrid = [0] * (SIZE*SIZE)\nsaveX = [0]* (SIZE*SIZE)\nsaveY = [0]* (SIZE*SIZE)\nsaveX[1] = saveY[1] = posX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    saveX[n]=posX\n    saveY[n]=posY\n    n+=1\n    if posY==0 or grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posY!=0:\n    walk( 1, 1, -1,  0)    \n    walk(-1, 0,  0, -1)    \n    walk(0, -1,  1,  1)    \nfor n in range(1, 92):\n    posX = saveX[n]\n    posY = saveY[n]\n    k = grid[(posY-1)*SIZE+posX] + grid[(posY+1)*SIZE+posX]\n    k+= grid[(posY-1)*SIZE+posX-1] + grid[(posY-1)*SIZE+posX+1]\n    k+= grid[(posY+1)*SIZE+posX-1] + grid[(posY+1)*SIZE+posX+1]\n    k+= grid[posY*SIZE+posX-1] + grid[posY*SIZE+posX+1]\n    print k,\n"}
{"sequence_id": "A214332", "text": "Trajectory of 0 under the morphism 0 -> 01, 1 -> 202, 2 -> empty string.", "sequence": "0,1,2,0,2,0,1,0,1,2,0,2,0,1,2,0,2,0,1,0,1,2,0,2,0,1,0,1,2,0,2,0,1,2,0,2,0,1,0,1,2,0,2,0,1,2,0,2,0,1,0,1,2,0,2,0,1,0,1,2,0,2,0,1,2,0,2,0,1,0,1,2,0,2,0,1,0,1,2,0,2,0,1,2,0,2,0", "code": "\nfrom itertools import chain\nA214332 = [0]\nfor _ in range(10):\n....A214332 = list(chain.from_iterable(([0,1] if d == 0 else [2,0,2] if d == 1 else [] for d in A214332)))\n\n"}
{"sequence_id": "A214365", "text": "Digit-wise Fibonacci: Start with 0,1; then the next term is always the sum of the earliest two consecutive digits not yet summed so far.", "sequence": "0,1,1,2,3,5,8,13,9,4,12,13,5,3,3,4,8,8,6,7,12,16,14,13,8,3,3,7,7,5,5,4,11,11,6,10,14,12,10,9,5,2,2,2,7,7,1,1,5,5,3,3,1,9,14,7,4,4,9,14,8,2,6,10,8,6,4,10,10,5,11,11,8,13,10,5,12,10,8,7,1,8,14,10,5", "code": "\ndef aupto(n):\n  alst, remaining = [0, 1], [0, 1]\n  for i in range(2, n+1):\n    an = remaining.pop(0) + remaining[0]\n    alst.append(an)\n    remaining.extend(list(map(int, str(an))))\n  return alst    \nprint(aupto(89)) \n"}
{"sequence_id": "A214370", "text": "If a(n) has not yet been defined then set a(n) = least positive integer that has not yet occurred; also if a(n+1+a(n)) has not yet been defined then set a(n+1+a(n)) = a(n).", "sequence": "1,2,1,3,2,4,5,3,6,7,4,3,5,8,9,6,10,7,5,11,12,13,8,14,9,7,15,10,16,17,18,11,19,12,9,13,20,21,14,22,23,24,15,11,9,16,12,17,25,18,26,27,19,14,9,11,28,20,15,21,29,30,22,31,23,17,24,11,18,32,33", "code": "\nSIZE = 300\na = [-8]*SIZE\ntop=0\nfor n in range(SIZE):\n    if a[n]==-8:       \n        top+=1\n        a[n]=top\n    if n+1+a[n]<SIZE and a[n+1+a[n]]==-8:   \n        a[n+1+a[n]]=a[n]\n    print(a[n], end=',')\n"}
{"sequence_id": "A214371", "text": "If a(n) has not yet been defined then set a(n) = least positive integer that has not yet occurred; also if n>1 and a(n+a(n)) has not yet been defined then set a(n+a(n)) = a(n).", "sequence": "1,2,3,2,4,3,5,6,4,7,8,5,4,6,9,10,7,11,8,6,12,13,14,9,15,10,8,16,11,17,18,19,12,20,13,10,14,21,22,15,23,24,25,16,12,10,17,13,18,26,19,27,28,20,15,10,12,29,21,16,22,30,31,23,32,24,18,25,12,19,33", "code": "\nSIZE = 300\na = [-8]*SIZE\ntop=0\nfor n in range(SIZE):\n    if a[n]==-8:       \n        top+=1\n        a[n]=top\n    if 1<n+a[n]<SIZE and a[n+a[n]]==-8:   \n        a[n+a[n]]=a[n]\n    print(a[n], end=',')\n"}
{"sequence_id": "A214410", "text": "Numbers that can't be expressed as the sum of a square and a Fibonacci number.", "sequence": "15,20,23,31,32,40,42,45,47,48,53,58,60,61,63,68,73,74,75,76,78,79,87,88,92,95,96,97,99,106,107,109,110,111,112,116,117,118,120,127,128,130,131,132,133,135,137,139,140,141,143,150,151,154,156,158,159,161", "code": "\nprpr = 0\nprev = 1\nfib = [0]*100\nfor n in range(100):\n    fib[n] = prpr\n    curr = prpr+prev\n    prpr = prev\n    prev = curr\nfor n in range(1234):\n    i = yes = 0\n    while i*i<=n:\n        r = n - i*i\n        if r in fib:\n            yes = 1\n            break\n        i += 1\n    if yes==0:\n        print(n, end=',')\n"}
{"sequence_id": "A214410", "text": "Numbers that can't be expressed as the sum of a square and a Fibonacci number.", "sequence": "15,20,23,31,32,40,42,45,47,48,53,58,60,61,63,68,73,74,75,76,78,79,87,88,92,95,96,97,99,106,107,109,110,111,112,116,117,118,120,127,128,130,131,132,133,135,137,139,140,141,143,150,151,154,156,158,159,161", "code": "\nfrom sympy import fibonacci\nfrom itertools import count, takewhile\ndef aupto(lim):\n  fbs = list(takewhile(lambda x: x<=lim, (fibonacci(i) for i in count(0))))\n  sqs = list(takewhile(lambda x: x<=lim, (i*i for i in count(0))))\n  return sorted(set(range(1, lim+1)) - set(f+s for f in fbs for s in sqs))\nprint(aupto(161)) \n"}
{"sequence_id": "A214412", "text": "Numbers that can't be expressed as the sum of a Fibonacci number and a square of a positive integer.", "sequence": "0,8,13,15,20,23,31,32,34,40,42,45,47,48,53,55,58,60,61,63,68,73,74,75,76,78,79,87,88,92,95,96,97,99,106,107,109,110,111,112,116,117,118,120,127,128,130,131,132,133,135,137,139,140,141,143,150,151,154,156", "code": "\nprpr = 0\nprev = 1\nfib = [0]*100\nfor n in range(100):\n    fib[n] = prpr\n    curr = prpr+prev\n    prpr = prev\n    prev = curr\n\nfor n in range(777):\n    i = 1\n    yes = 0\n    while i*i<=n:\n        r = n - i*i\n        if r in fib:\n            yes = 1\n            break\n        i += 1\n    if yes==0:\n        print n,\n"}
{"sequence_id": "A214492", "text": "Arithmetic mean of next a(n) successive squares of positive integers is a square.", "sequence": "337,649,961,1273,1585,1897,1919,1151,1223,1295,1367,1439,1511,1583,1655,1727,1799,1871,1943,2015,2087,2159,2231,2303,2375,2447,2519,1487,1511,1535,1559,1583,1607,1631,1655,1679,1703,1727,1751,1775,1799,1823,1847,1871,1895,1919", "code": "\nimport math\nsum = k = 0\nfor n in range(1, 220000):\n    sum += n*n\n    k += 1\n    sqr = int(math.sqrt(sum*1.0/k))\n    while sqr*sqr*k<sum:\n        sqr+=1\n    while sqr*sqr*k>sum:\n        sqr-=1\n    if sqr*sqr*k==sum and k>1:\n        print(k, end=',')\n        sum = k = 0\n"}
{"sequence_id": "A214527", "text": "Numbers k such that the alternating sum of decimal digits of k is zero.", "sequence": "101,112,123,134,145,156,167,178,189,202,213,224,235,246,257,268,279,303,314,325,336,347,358,369,404,415,426,437,448,459,505,516,527,538,549,606,617,628,639,707,718,729,808,819,909,1010,1021,1032,1043,1054,1065,1076", "code": "\na = []\nfor n in range(1, 2000):\n    t = str(n)\n    s = int(t[0])\n    s += sum((-1)**i * int(d) for i, d in enumerate(t[1:]))\n    if s == 0:\n         a.append(n)\nprint(a)\n"}
{"sequence_id": "A214528", "text": "a(n) = least k>0 such that n! divides Fibonacci(k).", "sequence": "1,1,3,12,12,60,60,120,480,4320,43200,43200,518400,3628800,7257600,108864000,1741824000,1741824000,31352832000,31352832000,627056640000,13168189440000,289700167680000,289700167680000,6952804024320000,173820100608000000,4519322615808000000,122021710626816000000", "code": "\nn = f = c = d = 1  \nfc1 = fd1 = 0      \nfc  = fd  = 1      \nwhile 1:\n    if fc % f:\n        if c==d:\n            fd, fd1 = fc, fc1\n            t = fc*fc\n            fc, fc1 = (2*fc*fc1+t), (fc1*fc1+t)\n        else:\n            fc, fc1 = (fc*(fd1+fd) + fc1*fd), (fc*fd + fc1*fd1)\n        c += d\n        \n    else:\n        print c,\n        d = c\n        f *= n\n        n += 1\n"}
{"sequence_id": "A214560", "text": "Number of 0's in binary expansion of n^2.", "sequence": "1,0,2,2,4,2,4,3,6,4,4,2,6,4,5,4,8,6,6,4,6,3,4,7,8,5,6,4,7,5,6,5,10,8,8,6,8,5,6,4,8,6,5,4,6,3,9,8,10,7,7,7,8,4,6,5,9,6,7,5,8,6,7,6,12,10,10,8,10,7,8,6,10,7,7,4,8,6,6,8,10,7,8,5,7", "code": "\nfor n in range(300):\n    b = n*n\n    c = 0\n    while b>0:\n        c += 1-(b&1)\n        b/=2\n    print c+(n==0),\n"}
{"sequence_id": "A214560", "text": "Number of 0's in binary expansion of n^2.", "sequence": "1,0,2,2,4,2,4,3,6,4,4,2,6,4,5,4,8,6,6,4,6,3,4,7,8,5,6,4,7,5,6,5,10,8,8,6,8,5,6,4,8,6,5,4,6,3,9,8,10,7,7,7,8,4,6,5,9,6,7,5,8,6,7,6,12,10,10,8,10,7,8,6,10,7,7,4,8,6,6,8,10,7,8,5,7", "code": "\ndef A214560(n):\n....return bin(n*n)[2:].count('0') \n"}
{"sequence_id": "A214561", "text": "Number of 1's in binary expansion of n^n.", "sequence": "1,1,1,4,1,6,6,11,1,14,11,20,10,28,23,33,1,31,27,41,26,49,36,59,16,58,41,68,37,62,51,83,1,79,61,88,58,97,85,98,53,115,96,116,63,123,96,128,41,138,105,144,90,163,128,164,81,172,148,181,124,167,134,201,1", "code": "\nfor n in range(300):\n    c = 0\n    b = n**n\n    while b>0:\n        c += b&1\n        b//=2\n    print(c, end=',')\n"}
{"sequence_id": "A214561", "text": "Number of 1's in binary expansion of n^n.", "sequence": "1,1,1,4,1,6,6,11,1,14,11,20,10,28,23,33,1,31,27,41,26,49,36,59,16,58,41,68,37,62,51,83,1,79,61,88,58,97,85,98,53,115,96,116,63,123,96,128,41,138,105,144,90,163,128,164,81,172,148,181,124,167,134,201,1", "code": "\ndef a(n): return bin(n**n)[2:].count('1')\nprint([a(n) for n in range(65)]) \n"}
{"sequence_id": "A214562", "text": "Number of 0's in binary expansion of n^n.", "sequence": "0,0,2,1,8,6,10,9,24,15,23,19,34,21,31,26,64,39,49,40,61,44,63,46,95,59,82,61,98,79,97,71,160,88,112,92,129,96,115,109,160,105,131,118,178,125,159,134,228,138,178,146,207,141,183,154,245,161,192,167,231,195", "code": "\nfor n in range(300):\n    c = 0\n    b = n**n\n    while b>0:\n        c += 1-(b&1)\n        b/=2\n    print c,\n"}
{"sequence_id": "A214588", "text": "Primes p such that p mod 16 < 8.", "sequence": "2,3,5,7,17,19,23,37,53,67,71,83,97,101,103,113,131,149,151,163,167,179,181,193,197,199,211,227,229,241,257,263,277,293,307,311,337,353,359,373,389,401,419,421,433,439,449,467,487,499,503,547,563,577,593,599", "code": "\nfrom sympy import isprime\ni=1\nj=1\nwhile j<=10000:\n....if  isprime(i)==True and (i%16)<8:\n........print str(j)+\" \"+str(i)\n........j+=1\n....i+=1 \n"}
{"sequence_id": "A214619", "text": "Numbers n such that at least one other integer m exists with the same smallest prime factor, same largest prime factor, and same set of decimal digits as n.", "sequence": "148,162,180,216,264,270,296,324,432,450,462,486,540,648,720,810,814,864,962,1035,1056,1072,1080,1089,1107,1125,1215,1224,1248,1250,1260,1269,1296,1320,1326,1359,1386,1395,1426,1443,1450,1458,1480,1482,1485,1488,1515", "code": "\n\nTOP = 10000\nsmallest = [0]*TOP\nlargest  = [0]*TOP\ndigitset = [0]*TOP\nflags = [0]*TOP\nfor n in range(1,TOP):\n    curSm = curLa = curDi = 0\n    t = x = n\n    while x:\n        curDi += 10**( x%10 )\n        x /= 10\n    for p in primes:\n        if t%p==0:\n            if curSm==0:\n                curSm = p\n            curLa = p\n            t/=p\n            while t%p==0:\n                t/=p\n            if t==1:\n                break\n    digitset[n] = curDi\n    smallest[n] = curSm\n    largest[n]  = curLa\n    for k in range(1,n):\n        if smallest[k]==curSm and largest[k]==curLa and digitset[k]==curDi:\n            flags[k]+=1\n            flags[n]+=1\nfor n in range(1,TOP):\n    if flags[n]>0:\n        print n,\n"}
{"sequence_id": "A214621", "text": "Numbers n such that at least one other integer m exists with the same smallest and same largest prime factors, and same multisets of decimal and binary digits as n.", "sequence": "1080,1260,1800,2016,2673,3024,3267,3402,4032,4500,4653,4950,5346,5400,5670,5757,5940,6048,6345,6534,6804,7056,7560,7575,8064,11084,11542,12654,12915,13026,13068,13260,13860,14018,14490,14652,14904,15124,15129,16032,16320", "code": "\n\n\nTOP = 100000\nsmallest = [0]*TOP\nlargest  = [0]*TOP\ndecimal = [0]*TOP\nbinary  = [0]*TOP\nflags = [0]*TOP\nfor n in range(1,TOP):\n    curSm = curLa = curDec = curBin = 0\n    t = b = d = n\n    while b:\n        curBin += 1000**( b&1 )\n        b /= 2\n    while d:\n        curDec += 10**( d%10 )\n        d /= 10\n    for p in primes:\n        if t%p==0:\n            if curSm==0:\n                curSm = p\n            curLa = p\n            t/=p\n            while t%p==0:\n                t/=p\n            if t==1:\n                break\n    binary[n] = curBin\n    decimal[n] = curDec\n    smallest[n] = curSm\n    largest[n]  = curLa\n    for k in range(1,n):\n        if smallest[k]==curSm and largest[k]==curLa:\n            if decimal[k]==curDec and binary[k]==curBin:\n                flags[k]+=1\n                flags[n]+=1\nfor n in range(1,TOP):\n    if flags[n]>0:\n        print n,\n"}
{"sequence_id": "A214647", "text": "(n^n + n^2)/2.", "sequence": "1,4,18,136,1575,23346,411796,8388640,193710285,5000000050,142655835366,4458050224200,151437553296211,5556003412779106,218946945190429800,9223372036854775936,413620130943168382233,19673204037648268787874,989209827830156794562170", "code": "\nfor n in range(1,22):\n    print (n*n + n**n)/2,\n"}
{"sequence_id": "A214648", "text": "Sum of next a(n) > 1 triangular numbers is a triangular number.", "sequence": "2,5,125,51875,8114028125", "code": "\nfrom __future__ import division\nfrom gmpy2 import is_prime\nA214648_list, s, c, d = [], 0, 0, -1\nfor _ in range(10):\n    k = 2\n    q = 4*(k*(k*(k+c)+d))//3 + 1\n    while not is_square(q):\n        k += 1\n        q = 4*(k*(k*(k+c)+d))//3 + 1\n    A214648_list.append(k)\n    s += k\n    c, d = 3*s, 3*s**2-1 \n"}
{"sequence_id": "A214649", "text": "a(-1) = 1 and g.f. A(x) satisfies A(x) - 1/A(x) = 1/x - 1.", "sequence": "1,-1,1,1,0,-2,-3,1,11,15,-13,-77,-86,144,595,495,-1520,-4810,-2485,15675,39560,6290,-159105,-324805,87075,1592843,2616757,-2136539,-15726114,-20247800,32296693,152909577,145139491,-417959049,-1460704685,-885536173", "code": "\nA214649 = [1, -1, 1]\nfor n in range(2, 802):\n    A214649.append( ((2*n-1)*A214649[-1]\n      - 5*(n-2)*A214649[-2])//(n+1) )\nfor n in range(802):\n    print(n-1, A214649[n]) \n"}
{"sequence_id": "A214697", "text": "Least k > 1 such that tri(n)+ ... + tri(n+k-1) is a triangular number.", "sequence": "2,3,5,17,7,2,89,125,3,215,269,13,10,8,11,27,719,815,21,57,316,11,26,1517,17,1799,30,26,7,5,2609,11,2975,10,2,76,3779,1251,208,4445,115,4919,1045,5417,11,17,1205,6485,38,2860,7349,18,25,8267,8585,8909", "code": "\nfor n in range(77):\n    i = ti = n\n    sum = 0\n    tn_gte_sum = 0  \n    while i-n<=1 or tn_gte_sum!=sum:\n        sum += i*(i+1)\n        i+=1\n        while tn_gte_sum<sum:\n            tn_gte_sum = ti*(ti+1)\n            ti+=1\n    print i-n,\n"}
{"sequence_id": "A214697", "text": "Least k > 1 such that tri(n)+ ... + tri(n+k-1) is a triangular number.", "sequence": "2,3,5,17,7,2,89,125,3,215,269,13,10,8,11,27,719,815,21,57,316,11,26,1517,17,1799,30,26,7,5,2609,11,2975,10,2,76,3779,1251,208,4445,115,4919,1045,5417,11,17,1205,6485,38,2860,7349,18,25,8267,8585,8909", "code": "\nfrom math import sqrt\ndef A214697(n):\n    k, a1, a2, m = 2, 36*n, 36*n**2 - 12, n*(72*n + 144) + 81\n    while int(round(sqrt(m)))**2 != m:\n        k += 1\n        m = k*(k*(12*k + a1) + a2) + 9\n    return k \n"}
{"sequence_id": "A214698", "text": "(n^n - n^2)/2.", "sequence": "0,0,9,120,1550,23310,411747,8388576,193710204,4999999950,142655835245,4458050224056,151437553296042,5556003412778910,218946945190429575,9223372036854775680,413620130943168381944,19673204037648268787550,989209827830156794561809,52428799999999999999999800", "code": "\nfor n in range(1, 22):\n    print (n**n - n*n)/2,\n"}
{"sequence_id": "A214705", "text": "Primes that contain only the digits (2, 5, 7).", "sequence": "2,5,7,227,257,277,557,577,727,757,2557,2777,5227,5527,5557,7577,7727,7757,22277,22727,22777,25577,27277,27527,52727,52757,57527,57557,57727,72227,72277,72577,72727,75227,75277,75527,75557,75577,77527,77557,222527,222557", "code": "\nfrom sympy import primerange\ndef ok(p): return set(str(p)) <= set(\"257\")\ndef aupto(limit): return [p for p in primerange(2, limit+1) if ok(p)]\nprint(aupto(222557)) \n"}
{"sequence_id": "A214754", "text": "Primes that can be written in binary representation as a concatenation of odd primes.", "sequence": "23,29,31,47,59,61,71,79,109,113,127,151,157,167,179,191,223,229,233,239,241,251,271,283,317,349,359,367,373,379,383,431,433,439,457,463,467,479,487,491,499,503,509,541,563,599,607,631,701,719,727,733,743,751,757", "code": "\n\ndef tryPartioning(binString):  \n    if binString=='10':\n        return 0\n    l = len(binString)\n    for t in range(2, l-1):\n        substr1 = binString[:t]\n        if (int('0b'+substr1,2) in oddPrimes) or (t>=4 and tryPartioning(substr1)):\n            substr2 = binString[t:]\n            if substr2[0]!='0':\n                if (int('0b'+substr2,2) in oddPrimes) or (l-t>=4 and tryPartioning(substr2)):\n                    return 1\n    return 0\nfor p in oddPrimes:\n    if tryPartioning(bin(p)[2:]):\n        print p,\n"}
{"sequence_id": "A214755", "text": "Primes formed by concatenating odd primes.", "sequence": "37,53,73,113,137,173,193,197,233,293,311,313,317,331,337,347,353,359,367,373,379,383,389,397,433,523,541,547,557,571,577,593,613,617,673,677,719,733,743,757,761,773,797,977,1013,1033,1093,1097,1117,1123,1129,1153", "code": "\n\ndef tryPartioning(binString):  \n    l = len(binString)\n    for t in range(1, l):\n        substr1 = binString[:t]\n        if (int(substr1) in oddPrimes) or (t>=2 and tryPartioning(substr1)):\n            substr2 = binString[t:]\n            if substr2[0]!='0':\n                if (int(substr2) in oddPrimes) or (l-t>=2 and tryPartioning(substr2)):\n                    return 1\n    return 0\nfor p in oddPrimes:\n    if tryPartioning(str(p)):\n        print p,\n"}
{"sequence_id": "A214838", "text": "Triangular numbers of the form k^2 + 2.", "sequence": "3,6,66,171,2211,5778,75078,196251,2550411,6666726,86638866,226472403,2943171003,7693394946,99981175206,261348955731,3396416785971,8878171099878,115378189547778,301596468440091,3919462027838451,10245401755863186,133146330756959526,348042063230908203", "code": "\nimport math\nfor i in range(2, 1L<<32):\n      t = i*(i+1)/2 - 2\n      sr = int(math.sqrt(t))\n      if sr*sr == t:\n          print '%10d' % sr, '%10d' % i, t+2\n"}
{"sequence_id": "A214842", "text": "Anti-multiply-perfect numbers. Numbers n for which sigma*(n)/n is an integer, where sigma*(n) is the sum of the anti-divisors of n.", "sequence": "1,2,5,8,41,56,77,946,1568,2768,5186,6874,8104,17386,27024,84026,167786,2667584,4775040,4921776,27914146,505235234,3238952914,73600829714,455879783074,528080296234,673223621664,4054397778846,4437083907194,4869434608274,6904301600914,7738291969456", "code": "\nA214842 = [n for n in range(1,10**4) if not (sum([d for d in range(2,n,2) if n%d and not 2*n%d])+sum([d for d in range(3,n,2) if n%d and 2*n%d in [d-1,1]])) % n]\n\n"}
{"sequence_id": "A214852", "text": "Indices of Fibonacci numbers with the same number of 1's and 0's in their binary representation.", "sequence": "3,36,42,59,116,156,168,211,237,246,280,335,355,399,404,416,433,442,569,580,652,698,761,770,865,897,940,989,1041,1049,1101,1144,1214,1286,1335,1352,1369,1395,1698,1726,1810,1928,1940,1951,2055,2159,2326,2332", "code": "\ndef count10(x):\n    c0, c1, m = 0, 0, 1\n    while m<=x:\n      if x&m:\n        c1+=1\n      else:\n        c0+=1\n      m+=m\n    return c0-c1\nprpr, prev = 0,1\nTOP = 1<<16\nfor i in range(1,TOP):\n    if count10(prev)==0:\n        print i,\n    prpr, prev = prev, prpr+prev\n"}
{"sequence_id": "A214853", "text": "Fibonacci numbers with only one 0 in the binary representation.", "sequence": "0,2,5,13,55", "code": "\ndef count0(x):\n    c = 0\n    while x:\n        c+= 1 - (x&1)\n        if c>1:\n            return 2\n        x>>=1\n    return c\nprpr, prev = 0,1\nTOP = 1<<12\nprint(0, end=',')\nfor i in range(1,TOP):\n    if count0(prpr)==1:\n        print(prpr, end=',')\n    if (i&4095)==0:\n        print('.', end=',')\n    prpr, prev = prev, prpr+prev\n"}
{"sequence_id": "A214870", "text": "Natural numbers placed in table T(n,k) layer by layer. The order of placement: at the beginning filled odd places of layer clockwise, next - even places counterclockwise. T(n,k) read by antidiagonals.", "sequence": "1,2,3,5,4,7,10,9,8,13,17,16,6,14,21,26,25,11,12,22,31,37,36,18,15,20,32,43,50,49,27,24,23,30,44,57,65,64,38,35,19,33,42,58,73,82,81,51,48,28,29,45,56,74,91,101,100,66,63,39,34,41,59,72,92,111", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nif i > j:\n   result=i*i-i+(j%2)*(2-(j+1)/2)+((j+1)%2)*(j/2+1)\nelse:\n   result=j*j-2*(i%2)*j + (i%2)*((i+1)/2+1) + ((i+1)%2)*(-i/2+1)\n"}
{"sequence_id": "A214871", "text": "Natural numbers placed in table T(n,k) layer by layer. The order of placement - T(n,n), T(1,n), T(n,1), T(2,n), T(n,2),...T(n-1,n), T(n,n-1). Table T(n,k) read by antidiagonals.", "sequence": "1,3,4,6,2,7,11,8,9,12,18,13,5,14,19,27,20,15,16,21,28,38,29,22,10,23,30,39,51,40,31,24,25,32,41,52,66,53,42,33,17,34,43,54,67,83,68,55,44,35,36,45,56,69,84,102,85,70,57,46,26,47,58,71,86,103,123", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nif i == j:\n   result=(i-1)**2+1\nif i > j:\n   result=(i-1)**2+2*j+1\nif i < j:\n   result=(j-1)**2+2*i\n"}
{"sequence_id": "A214877", "text": "n ^ (last digit of n).", "sequence": "1,1,4,27,256,3125,46656,823543,16777216,387420489,1,11,144,2197,38416,759375,16777216,410338673,11019960576,322687697779,1,21,484,12167,331776,9765625,308915776,10460353203,377801998336,14507145975869,1,31,1024,35937,1336336", "code": "\nfor n in range(44):\n    print n ** (n%10),\n"}
{"sequence_id": "A214879", "text": "Numbers that cannot be written as sum of the squares of two primes.", "sequence": "0,1,2,3,4,5,6,7,9,10,11,12,14,15,16,17,19,20,21,22,23,24,25,26,27,28,30,31,32,33,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,51,52,54,55,56,57,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,75,76", "code": "\nfrom sympy import primerange\ndef aupto(limit):\n    primes = list(primerange(2, int((limit-4)**.5)+2))\n    nums = [p*p + q*q for i, p in enumerate(primes) for q in primes[i:]]\n    return sorted(set(range(limit+1)) - set(k for k in nums if k <= limit))\nprint(aupto(76)) \n"}
{"sequence_id": "A214913", "text": "a(n+1) = a(n) + max(1, count0s), where count0s is number of 0's in binary representation of a(n).", "sequence": "0,1,2,3,4,6,7,8,11,12,14,15,16,20,23,24,27,28,30,31,32,37,40,44,47,48,52,55,56,59,60,62,63,64,70,74,78,81,85,88,92,95,96,101,104,108,111,112,116,119,120,123,124,126,127,128,135,139,143,146,151,154,158", "code": "\na = 0\nfor n in range(100):\n    print a,\n    ta = a\n    c0 = (a==0)\n    while ta>0:\n        c0 += 1-(ta&1)\n        ta >>= 1\n    a += max(c0,1)\n"}
{"sequence_id": "A214916", "text": "a(0) = a(1) = 1, a(n) = n! / a(n-2).", "sequence": "1,1,2,6,12,20,60,252,672,1440,5400,27720,88704,224640,982800,5821200,21288960,61102080,300736800,1990850400,8089804800,25662873600,138940401600,1007370302400,4465572249600,15397724160000,90311261040000,707173952284800,3375972620697600", "code": "\nimport math\nprpr = prev = 1\nfor n in range(2, 33):\n    print prpr,\n    cur = math.factorial(n) / prpr\n    prpr = prev\n    prev = cur\n"}
{"sequence_id": "A214928", "text": "A209293 as table read layer by layer clockwise.", "sequence": "1,2,4,3,5,9,14,7,6,8,12,17,23,20,11,10,13,19,26,34,43,30,27,16,15,18,24,31,39,48,58,53,38,35,22,21,25,33,42,52,63,75,88,69,64,47,44,29,28,32,40,49,59,70,82,95,109,102,81,76,57,54,37,36,41,51,62", "code": "\nt=int((math.sqrt(n-1)))+1\ni=min(t,n-(t-1)**2)\nj=min(t,t**2-n+1)\nm1=int((i+j)/2)+int(i/2)*(-1)**(2*i+j-1)\nm2=int((i+j+1)/2)+int(i/2)*(-1)**(2*i+j-2)\nresult=(m1+m2-1)*(m1+m2-2)/2+m1\n"}
{"sequence_id": "A214929", "text": "A209293 as table read layer by layer - layer clockwise, layer counterclockwise and so on.", "sequence": "1,3,4,2,5,9,14,7,6,10,11,20,23,17,12,8,13,19,26,34,43,30,27,16,15,21,22,35,38,53,58,48,39,31,24,18,25,33,42,52,63,75,88,69,64,47,44,29,28,36,37,54,57,76,81,102,109,95,82,70,59,49,40,32,41,51,62", "code": "\nt=int((math.sqrt(n-1)))+1\ni=(t % 2)*min(t,n-(t-1)**2) + ((t+1) % 2)*min(t,t**2-n+1)\nj=(t % 2)*min(t,t**2-n+1) + ((t+1) % 2)*min(t,n-(t-1)**2)\nm1=int((i+j)/2)+int(i/2)*(-1)**(2*i+j-1)\nm2=int((i+j+1)/2)+int(i/2)*(-1)**(2*i+j-2)\nresult=(m1+m2-1)*(m1+m2-2)/2+m1\n"}
{"sequence_id": "A214936", "text": "a(0) = 1, a(n) = a(n - 1) * (length of binary representation of n).", "sequence": "1,1,2,4,12,36,108,324,1296,5184,20736,82944,331776,1327104,5308416,21233664,106168320,530841600,2654208000,13271040000,66355200000,331776000000,1658880000000,8294400000000,41472000000000,207360000000000,1036800000000000,5184000000000000", "code": "\nt = 1\nfor n in range(1,33):\n    print t,\n    t *= len(bin(n))-2\n"}
{"sequence_id": "A214939", "text": "Number of squarefree words of length n in a 5-ary alphabet.", "sequence": "5,20,80,300,1140,4260,15960,59580,222600,830880,3102120,11578800,43220940,161324400,602159940,2247585300,8389237320,31313155560,116877700500,436250537520", "code": "\nfrom itertools import product\ndef a(n):\n  if n == 1: return 5\n  squares = [\"\".join(u) + \"\".join(u)\n    for r in range(1, n//2 + 1) for u in product(\"01234\", repeat = r)]\n  words = (\"0\"+\"\".join(w) for w in product(\"01234\", repeat=n-1))\n  return 5*sum(all(s not in w for s in squares) for w in words)\nprint([a(n) for n in range(1, 10)]) \n"}
{"sequence_id": "A214940", "text": "Number of squarefree words of length n in a 6-ary alphabet", "sequence": "6,30,150,720,3480,16680,80040,383520,1838160,8807400,42202560,202209720,968880960,4642304520,22243228680,106576361760,510651000360", "code": "\nfrom itertools import product\ndef a(n):\n    if n == 1: return 6\n    squares = [\"\".join(u) + \"\".join(u)\n        for r in range(1, n//2 + 1) for u in product(\"012345\", repeat=r)]\n    words = (\"0\"+\"\".join(w) for w in product(\"012345\", repeat=n-1))\n    return 6*sum(all(s not in w for s in squares) for w in words)\nprint([a(n) for n in range(1, 9)]) \n"}
{"sequence_id": "A214943", "text": "T(n,k) = Number of squarefree words of length n in a (k+1)-ary alphabet.", "sequence": "2,3,2,4,6,2,5,12,12,0,6,20,36,18,0,7,30,80,96,30,0,8,42,150,300,264,42,0,9,56,252,720,1140,696,60,0,10,72,392,1470,3480,4260,1848,78,0,11,90,576,2688,8610,16680,15960,4848,108,0,12,110,810,4536,18480,50190,80040", "code": "\nfrom itertools import product\ndef T(n, k):\n  if n == 1: return k+1\n  symbols = \"\".join(chr(48+i) for i in range(k+1))\n  squares = [\"\".join(u)*2 for r in range(1, n//2 + 1)\n    for u in product(symbols, repeat = r)]\n  words = (\"0\" + \"\".join(w) for w in product(symbols, repeat=n-1))\n  return (k+1)*sum(all(s not in w for s in squares) for w in words)\ndef atodiag(maxd): \n  return [T(n, d+1-n) for d in range(1, maxd+1) for n in range(1, d+1)]\nprint(atodiag(11)) \n"}
{"sequence_id": "A214961", "text": "a(0)=a(1)=1, a(n) = least k > a(n-1) such that k*a(n-2) is a triangular number.", "sequence": "1,1,3,6,7,11,13,21,25,30,49,59,97,117,193,233,385,465,492,596,983,1191,1965,2381,2516,4761,5031,5761,6290,8466,9795,15470,15867,17403,20559,24170,26945,27192,27755,30130,35235,43537,45100,56805,58717,58739,91000,117477", "code": "\nprpr = prev = 1\nfor n in range(1, 55):\n    print prpr,\n    b = k = 0\n    while k<=prev:\n        d = b*(b+1)/2\n        k = 0\n        if d%prpr==0:\n            k = d / prpr\n        b += 1\n    prpr = prev\n    prev = k\n"}
{"sequence_id": "A215004", "text": "a(0) = a(1) = 1; for n>1, a(n) = a(n-1) + a(n-2) + floor(n/2).", "sequence": "1,1,3,5,10,17,30,50,84,138,227,370,603,979,1589,2575,4172,6755,10936,17700,28646,46356,75013,121380,196405,317797,514215,832025,1346254,2178293,3524562,5702870,9227448,14930334,24157799,39088150,63245967,102334135,165580121", "code": "\nprpr = prev = 1\nfor n in range(2,100):\n    print prpr,\n    curr = prpr+prev + n//2\n    prpr = prev\n    prev = curr\n"}
{"sequence_id": "A215005", "text": "a(n) = a(n-2) + a(n-1) + floor(n/2) + 1 for n > 1 and a(0)=0, a(1)=1.", "sequence": "0,1,3,6,12,21,37,62,104,171,281,458,746,1211,1965,3184,5158,8351,13519,21880,35410,57301,92723,150036,242772,392821,635607,1028442,1664064,2692521,4356601,7049138,11405756,18454911,29860685,48315614,78176318,126491951,204668289", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,100):\n    print prpr,\n    curr = prpr+prev + 1 + n//2\n    prpr = prev\n    prev = curr\n"}
{"sequence_id": "A215006", "text": "a(0)=0, a(n+1) is the least k>a(n) such that k+a(n)+n+1 is a Fibonacci number.", "sequence": "0,1,2,3,6,10,18,30,51,84,139,227,371,603,980,1589,2576,4172,6756,10936,17701,28646,46357,75013,121381,196405,317798,514215,832026,1346254,2178294,3524562,5702871,9227448,14930335,24157799,39088151,63245967,102334136,165580121", "code": "\nprpr = 0\nprev = 1\nfib = [0]*100\nfor n in range(100):\n    fib[n] = prpr\n    curr = prpr+prev\n    prpr = prev\n    prev = curr\na = 0\nfor n in range(1,55):\n    print(a, end=',')\n    b = c = 0\n    while c <= a:\n        c = fib[b] - a - n\n        b += 1\n    a=c\n"}
{"sequence_id": "A215006", "text": "a(0)=0, a(n+1) is the least k>a(n) such that k+a(n)+n+1 is a Fibonacci number.", "sequence": "0,1,2,3,6,10,18,30,51,84,139,227,371,603,980,1589,2576,4172,6756,10936,17701,28646,46357,75013,121381,196405,317798,514215,832026,1346254,2178294,3524562,5702871,9227448,14930335,24157799,39088151,63245967,102334136,165580121", "code": "\nprint(0, end=',')\nprpr = 1\nprev = 2\nfor n in range(3,56):\n    print(prpr, end=',')\n    curr = prpr+prev + n//2 - 1\n    prpr = prev\n    prev = curr\n"}
{"sequence_id": "A215011", "text": "a(n) = least k>0 such that triangular(n) divides Fibonacci(k).", "sequence": "1,4,12,15,20,8,24,12,60,10,60,84,56,40,60,18,36,36,90,120,40,120,24,300,175,252,72,168,140,60,60,60,180,360,120,228,342,252,420,60,40,88,660,60,120,48,48,168,1400,900,252,189,108,180,120,72,252,406,1740", "code": "\nTOP = 333\nprpr = y = 0\nprev = k = 1\nres = [-1]*TOP\nwhile y<TOP-1:\n    for i in range(1,TOP):\n      if res[i]<0 and prev % (i*(i+1)/2) == 0:\n        res[i] = k\n        y += 1\n    curr = prpr+prev\n    prpr = prev\n    prev = curr\n    k += 1\nfor i in range(1,TOP):\n    print res[i],\n"}
{"sequence_id": "A215014", "text": "Numbers where any two consecutive decimal digits differ by 1 after arranging the digits in decreasing order.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98,102,120,123,132,201,210,213,231,234,243,312,321,324,342,345,354,423,432,435,453,456,465,534,543,546,564,567,576,645,654,657,675,678,687,756,765,768,786,789,798,867", "code": "\n\ndef consecutive(li):\n  for i in range(len(li)-1):\n    if(li[i+1]!=1+li[i]): return False\n  return True\ndef sorted_digits(n):\n  lst=[]\n  while(n>0):\n    lst+=[n%10] ; n//=10\n  lst.sort() ; return lst\nj=0\nfor i in range(1,10001):\n  while(not consecutive(sorted_digits(j))): j+=1\n  print(str(i)+\" \"+str(j)) ; j+=1\n"}
{"sequence_id": "A215095", "text": "a(0)=0, a(1)=1, a(n) = least k>a(n-1) such that k+a(n-2) is a Jacobsthal number.", "sequence": "0,1,3,4,8,17,35,68,136,273,547,1092,2184,4369,8739,17476,34952,69905,139811,279620,559240,1118481,2236963,4473924,8947848,17895697,35791395,71582788,143165576,286331153,572662307,1145324612,2290649224,4581298449,9162596899", "code": "\nprpr = 0\nprev = 1\njac = [0]*10000\nfor n in range(10000):\n    jac[n] = prpr\n    curr = prpr*2 + prev\n    prpr = prev\n    prev = curr\nprpr, prev = 0, 1\nfor n in range(1, 44):\n    print prpr,\n    b = c = 0\n    while c<=prev:\n        c = jac[b] - prpr\n        b+=1\n    prpr = prev\n    prev = c\n"}
{"sequence_id": "A215096", "text": "a(0)=0, a(1)=1, a(n) = n! - a(n-2).", "sequence": "0,1,2,5,22,115,698,4925,39622,357955,3589178,39558845,475412422,6187461955,86702878778,1301486906045,20836087009222,354385941189955,6381537618718778,121290714467642045,2426520470557921222,50969651457241797955,1121574207307049758778", "code": "\nprpr = 0\nprev = f = 1\nfor n in range(2, 33):\n    print prpr,\n    f *= n\n    curr = f - prpr\n    prpr = prev\n    prev = curr\n"}
{"sequence_id": "A215097", "text": "a(n) = n^3 - a(n-2) for n >= 2 and a(0)=0, a(1)=1.", "sequence": "0,1,8,26,56,99,160,244,352,485,648,846,1080,1351,1664,2024,2432,2889,3400,3970,4600,5291,6048,6876,7776,8749,9800,10934,12152,13455,14848,16336,17920,19601,21384,23274,25272,27379,29600,31940,34400,36981,39688,42526", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,77):\n    print(prpr, end=',')\n    curr = n*n*n - prpr\n    prpr = prev\n    prev = curr\n"}
{"sequence_id": "A215098", "text": "a(0)=0, a(1)=1, a(n) = n*(n-1) - a(n-2).", "sequence": "0,1,2,5,10,15,20,27,36,45,54,65,78,91,104,119,136,153,170,189,210,231,252,275,300,325,350,377,406,435,464,495,528,561,594,629,666,703,740,779,820,861,902,945,990,1035,1080,1127,1176,1225,1274,1325,1378,1431", "code": "\nprpr = 0\nprev = 1\nfor n in range(2,77):\n    print prpr,\n    curr = n*(n-1) - prpr\n    prpr = prev\n    prev = curr\n"}
{"sequence_id": "A215099", "text": "a(0)=0, a(1)=1, a(n) = least k>a(n-1) such that k+a(n-2) is prime.", "sequence": "0,1,2,4,5,7,8,10,11,13,18,24,25,29,34,38,39,41,44,48,53,55,56,58,71,73,78,84,85,89,94,102,103,109,120,124,131,133,138,144,145,149,162,164,169,173,178,180,181,187,192,196,197,201", "code": "\n\nprpr = 0\nprev = 1\nfor n in range(77):\n    print prpr,\n    b = c = 0\n    while c<=prev:\n        c = primes[b] - prpr\n        b+=1\n    prpr = prev\n    prev = c\n"}
{"sequence_id": "A215159", "text": "a(n) = floor(n^n / (n+1)).", "sequence": "1,0,1,6,51,520,6665,102942,1864135,38742048,909090909,23775972550,685853880635,21633936185160,740800455037201,27368368148803710,1085102592571150095,45957792327018709120,2070863582910344082917,98920982783015679456198", "code": "\nfor n in range(55):\n    print(n**n // (n+1), end=\",\")\n"}
{"sequence_id": "A215172", "text": "a(0)=1, a(n) = a(n-1)*4^n + 2^n - 1. That is, add n 0's and n 1's to the binary representation of previous term.", "sequence": "1,5,83,5319,1361679,1394359327,5711295803455,93573870443806847,6132457173405325525247,1607586853265165654490350079,1685676992249374341322873324438527,7070241751299519797307892876185811552255", "code": "\na = 1\nfor n in range(1,13):\n    \n    print a,\n    a = a*(4**n) + 2**n - 1\n"}
{"sequence_id": "A215199", "text": "Smallest number k such that k and k+1 are both of the form p*q^n where p and q are distinct primes.", "sequence": "14,44,135,2511,8991,29888,916352,12393728,155161088,2200933376,6856828928,689278976,481758175232,3684603215871,35419114668032,2035980763136,174123685117952,9399153082499072,19047348965998592,203368956137832447,24217192574746623,2503092614937444351", "code": "\nfrom sympy import isprime, nextprime\nfrom sympy.ntheory.modular import crt\ndef A215199(n):\n    l = len(str(3**n))-1\n    l10, result = 10**l, 2*10**l\n    while result >= 2*l10:\n        l += 1\n        l102, result = l10, 20*l10\n        l10 *= 10\n        q, qn = 2, 2**n\n        while qn <= l10:\n            s, sn = 2, 2**n\n            while sn <= l10:\n                if s != q:\n                    a, b = crt([qn,sn],[0,1])\n                    if a <= l102:\n                        a = b*(l102//b) + a\n                    while a < l10:\n                        p, t = a//qn, (a-1)//sn\n                        if p != q and t != s and isprime(p) and isprime(t):\n                            result = min(result,a-1)\n                        a += b\n                s = nextprime(s)\n                sn = s**n\n            q = nextprime(q)\n            qn = q**n\n    return result \n"}
{"sequence_id": "A215203", "text": "a(0) = 0, a(n) = a(n - 1)*2^(n + 1) + 2^n - 1. That is, add one 0 and n 1's to the binary representation of previous term.", "sequence": "0,1,11,183,5871,375775,48099263,12313411455,6304466665215,6455773865180671,13221424875890015231,54154956291645502388223,443637401941159955564326911,7268555193403964711965932118015,238176016577461115681699663643131903", "code": "\na = 0\nfor n in range(1,10):\n    \n    print a,\n    a = a*(2**(n+1)) + 2**n - 1\n"}
{"sequence_id": "A215265", "text": "(n-1)^(n+1) - n^n.", "sequence": "-2,-1,-3,-11,-13,971,31469,856073,23576391,686321335,21381059609,714688329389,25606611695675,981043357956611,40073886188532741,1740059447428511761,80079381261983807759,3895126220983308449519,199726027609854787271729", "code": "\nfor n in range(33):\n    print (n-1)**(n+1) - n**n,\n"}
{"sequence_id": "A215422", "text": "Length of binary representation of Fibonacci(2^n).", "sequence": "1,1,2,5,10,22,44,88,177,355,710,1421,2843,5687,11374,22748,45497,90995,181991,363982,727965,1455930,2911861,5823723,11647446,23294892,46589786,93179572,186359144,372718289", "code": "\nTOP = 33\nfib2m1 = [0]*TOP  \nfib2   = [1]*TOP  \nprint(1, end=',')\nfor n in range(1,TOP):\n    fib2[n]   = (2*fib2m1[n-1] + fib2[n-1])*fib2[n-1]\n    fib2m1[n] = fib2m1[n-1]*fib2m1[n-1] + fib2[n-1]*fib2[n-1]\n    print(len(bin(fib2[n]))-2, end=',')\n"}
{"sequence_id": "A215448", "text": "a(0)=1, a(1)=0, a(n) = a(n-1) + a(n-2) + Sum_{i=0...n-1} a(i).", "sequence": "1,0,2,5,15,43,124,357,1028,2960,8523,24541,70663,203466,585857,1686908,4857258,13985917,40270843,115955271,333879896,961368845,2768151264,7970573896,22950352843,66082907265,190278147899,547884090854,1577569365297,4542429947992", "code": "\na = [1]*33\na[1]=0\nsum = a[0]+a[1]\nfor n in range(2,33):\n    print a[n-2],\n    a[n] = a[n-1] + a[n-2] + sum\n    sum += a[n]\n"}
{"sequence_id": "A215450", "text": "a(0)=0, a(1)=1, a(n) = a(n-1) + (Sum_{i=0...n-1)a(i)) mod n.", "sequence": "0,1,2,2,3,6,8,9,16,18,23,23,26,33,35,45,55,71,87,94,111,128,132,140,152,172,186,198,210,224,244,249,264,294,325,341,344,360,393,425,434,454,491,525,530,538,541,573,604,649,687,687,733,749,785,804,805,826,870,904", "code": "\na = [0]*77\na[1]=1\nsum = a[0]+a[1]\nfor n in range(2,77):\n    print a[n-2],\n    a[n] = a[n-1] + sum % n\n    sum += a[n]\n"}
{"sequence_id": "A215451", "text": "a(0)=1, a(n) = (sum of previous terms) mod (a(n-1)+n).", "sequence": "1,1,2,4,0,3,2,4,5,8,12,19,30,5,1,1,13,21,15,11,3,17,22,20,0,20,10,28,54,0,2,4,14,23,33,0,12,28,52,45,35,48,88,61,42,36,35,70,16,1,8,41,3,21,0,5,18,23,43,17,1,41,65,111,149,25,1,53,29,63,98,102,154,5", "code": "\nsum = a = 1\nfor n in range(1,333):\n    print a,\n    a = sum % (a+n)\n    sum += a\n"}
{"sequence_id": "A215452", "text": "a(1)=1, a(n) = (sum of previous terms) mod (a(n-1)+n).", "sequence": "1,1,2,4,8,2,0,2,9,10,18,27,4,16,11,7,2,4,13,9,0,18,4,4,2,10,3,5,26,54,21,32,4,29,42,14,10,44,57,44,63,6,5,10,52,23,32,44,64,74,71,33,18,60,93,29,46,48,60,84,38,26,39,46,83,81,25,59,93,22,47,24,34,53", "code": "\nsum = a = 1\nfor n in range(2,333):\n    print a,\n    a = sum % (a+n)\n    sum += a\n"}
{"sequence_id": "A215453", "text": "a(n) = least k>0 such that n^n divides Fibonacci(k).", "sequence": "1,6,36,192,3125,3888,941192,12582912,516560652,7500000000,259374246010,743008370688,163086595857367,1190572159881216,583858520507812500,13835058055282163712,437950726881001816329,3278867339608044797952,1874292305362402347591138,78643200000000000000000000,2225747435575612389097571208", "code": "\nTOP = 9\nprpr = 0\nprev = k = y = 1\nres = [-1]*TOP\nii = [0]*TOP\nfor i in range(1, TOP):\n    ii[i] = i**i\nwhile y<TOP:\n    for i in range(y, TOP):\n      if res[i]<0 and prev % ii[i] == 0:\n        res[i] = k\n        y += 1\n        for i in range(1, TOP):\n          print res[i],\n        print\n    curr = prpr+prev\n    prpr = prev\n    prev = curr\n    k += 1\n"}
{"sequence_id": "A215454", "text": "a(n) = least positive k such that n^2 divides k!", "sequence": "1,4,6,6,10,6,14,8,9,10,22,6,26,14,10,10,34,9,38,10,14,22,46,8,20,26,15,14,58,10,62,12,22,34,14,9,74,38,26,10,82,14,86,22,10,46,94,10,28,20,34,26,106,15,22,14,38,58,118,10,122,62,14,16,26,22,134,34", "code": "\nTOP = 77\nii = [0]*TOP\nfor i in range(1, TOP):\n    ii[i] = i*i\nf = k = y = 1\nres = [-1]*TOP\nwhile y<TOP:\n    for i in range(1, TOP):\n      if res[i]<0 and f % ii[i] == 0:\n        res[i] = k\n        y += 1\n    k += 1\n    f *= k\nfor i in range(1, TOP):\n    print res[i],\n"}
{"sequence_id": "A215460", "text": "Floor(n!^2 / n^n).", "sequence": "1,1,1,2,4,11,30,96,339,1316,5584,25733,128025,683949,3905083,23731187,152934464,1041782238,7479469995,56448098958,446768591341,3700276748921,32007269639380,288630046441757,2708888570942365,26419890078249485,267389254029561667", "code": "\nf = 1\nfor n in range(1,33):\n    print f*f // n**n,\n    f *= n+1\n"}
{"sequence_id": "A215468", "text": "Sum of the 8 nearest neighbors of n in a rotated-square spiral with positive integers.", "sequence": "50,62,72,86,76,84,122,88,144,104,166,120,152,160,144,218,160,168,248,184,192,278,208,216,260,268,240,248,346,264,272,280,384,296,304,312,422,328,336,344,400,408,368,376,384,506,400,408,416,424,552,440,448,456,464,598", "code": "\nSIZE=17  \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\nsaveX = [0]* (SIZE*SIZE+1)\nsaveY = [0]* (SIZE*SIZE+1)\ngrid[posY*SIZE+posX]=1\nsaveX[1]=posX\nsaveY[1]=posY\nposX += 1\ngrid[posY*SIZE+posX]=2\nsaveX[2]=posX\nsaveY[2]=posY\nn = 3\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    saveX[n]=posX\n    saveY[n]=posY\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posX!=SIZE-1:\n    walk(-1,  1, -1, -1)    \n    walk(-1, -1,  1, -1)    \n    walk( 1, -1,  1,  0)    \n    walk( 1,  0,  1,  1)    \n    walk( 1,  1, -1,  1)    \nfor s in range(1, n):\n    posX = saveX[s]\n    posY = saveY[s]\n    i,j = grid[(posY-1)*SIZE+posX-1], grid[(posY-1)*SIZE+posX+1]\n    u,v = grid[(posY+1)*SIZE+posX-1], grid[(posY+1)*SIZE+posX+1]\n    if i==0 or j==0 or u==0 or v==0:\n        break\n    k = grid[(posY-1)*SIZE+posX  ] + grid[(posY+1)*SIZE+posX  ]\n    k+= grid[ posY   *SIZE+posX-1] + grid[ posY   *SIZE+posX+1]\n    print i+j+u+v+k,\nprint\nfor y in range(SIZE):\n    for x in range(SIZE):\n        print '%3d' % grid[y*SIZE+x],\n    print\n"}
{"sequence_id": "A215470", "text": "Prime intersections in a square spiral with positive integers: primes p such that there are four primes among eight nearest neighbors of p.", "sequence": "71,353,701,1151,1451,3347,4691,13463,21017,27947,34337,42017,52253,57191,79907,80831,81611,121469,144497,159737,161141,256301,265547,284231,285707,312161,334511,346559,348617,382601,392069,422867,440303,502013,541061,545873,593207", "code": "\nSIZE = 3335  \nTOP = SIZE*SIZE\nprime = [1]*TOP\nprime[1]=0\nfor i in range(4,TOP,2):\n    prime[i]=0\nfor i in range(3,TOP,2):\n    if prime[i]==1:\n        for j in range(i*3,TOP,i*2):\n            prime[j]=0\ngrid = [0] * TOP\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX] = 1\nn = 2\nsaveX = [0]* (TOP+1)\nsaveY = [0]* (TOP+1)\nsaveX[1]=posX\nsaveY[1]=posY\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    saveX[n]=posX\n    saveY[n]=posY\n    n+=1\n    if posX*posY==0 or grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk(0, -1, 1, 0)   \n    if posX*posY==0:\n        break\n    walk(1, 0, 0, 1)    \n    walk(0, 1, -1, 0)   \n    walk(-1, 0, 0, -1)  \nfor s in range(1, n):\n  if prime[s]:\n    posX = saveX[s]\n    posY = saveY[s]\n    a,b=(grid[(posY-1)*SIZE+posX-1]) , (grid[(posY-1)*SIZE+posX+1])\n    c,d=(grid[(posY+1)*SIZE+posX-1]) , (grid[(posY+1)*SIZE+posX+1])\n    if a*b==0 or c*d==0:\n        break\n    if prime[a]+prime[b]+prime[c]+prime[d]==4:\n        print s,\n"}
{"sequence_id": "A215471", "text": "Numbers n such that in a rotated-square spiral with positive integers (A215468) among n's eight nearest neighbors five or more are primes.", "sequence": "8,30,138,658,2620,3010,3168,3372,3462,8628,11940,17682,24918,27918,32560,39228,39790,40128,43608,48532,53268,55372,56040,56712,73362,85200,85888,90646,96052,101748,102652,104382,112068,113932,115330,119298,128518,129288,131500", "code": "\nSIZE = 3335  \nTOP = SIZE*SIZE\nt = TOP//2\nprime = [1]*t\nprime[1]=0\nfor i in range(4,t,2):\n    prime[i]=0\nfor i in range(3,t,2):\n    if prime[i]==1:\n        for j in range(i*3,t,i*2):\n            prime[j]=0\ngrid = [0] * TOP\nposX = posY = SIZE//2\nsaveX = [0]* (t+1)\nsaveY = [0]* (t+1)\ngrid[posY*SIZE+posX] = 1\nsaveX[1]=posX\nsaveY[1]=posY\nposX += 1\ngrid[posY*SIZE+posX] = 2\nsaveX[2]=posX\nsaveY[2]=posY\nn = 3\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    saveX[n]=posX\n    saveY[n]=posY\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posX!=SIZE-1:\n    walk(-1,  1, -1, -1)    \n    walk(-1, -1,  1, -1)    \n    walk( 1, -1,  1,  0)    \n    walk( 1,  0,  1,  1)    \n    walk( 1,  1, -1,  1)    \nfor s in range(1, n):\n    posX = saveX[s]\n    posY = saveY[s]\n    a,b=(grid[(posY-1)*SIZE+posX-1]) , (grid[(posY-1)*SIZE+posX+1])\n    c,d=(grid[(posY+1)*SIZE+posX-1]) , (grid[(posY+1)*SIZE+posX+1])\n    e,f=(grid[(posY-1)*SIZE+posX  ]) , (grid[(posY+1)*SIZE+posX  ])\n    g,h=(grid[ posY   *SIZE+posX-1]) , (grid[ posY   *SIZE+posX+1])\n    if a*b==0 or c*d==0 or e*f==0 or g*h==0:\n        break\n    z = prime[a]+prime[b]+prime[c]+prime[d]\n    if z+prime[e]+prime[f]+prime[g]+prime[h] >= 5:\n        print s,\n"}
{"sequence_id": "A215488", "text": "a(0)=1, a(n) = a(n-1) + a(2*n AND n), where AND is the bitwise AND operator.", "sequence": "1,2,3,6,7,8,15,30,31,32,33,36,67,98,165,330,331,332,333,336,337,338,345,360,691,1022,1353,1686,2377,3068,5445,10890,10891,10892,10893,10896,10897,10898,10905,10920,10921,10922,10923,10926,10957,10988,11055,11220,22111,33002", "code": "\na = [1]*1000\nfor n in range(1,777):\n    print a[n-1],\n    a[n]= a[n-1] + a[2*n & n]\n"}
{"sequence_id": "A215525", "text": "a(0)=a(1)=1, a(n) = a(n-1) + a(a(n-2) mod n).", "sequence": "1,1,2,3,5,8,16,17,18,36,54,57,73,81,84,100,105,205,305,405,413,429,634,734,788,824,842,926,928,1854,2782,3606,6388,6424,9206,9611,10453,11381,11384,17772,18560,18965,30349,30351,36775,37204,37633,38559,38560,75764", "code": "\na = [1]*1000\nfor n in range(2,77):\n..print(a[n-2],end=', ')\n..a[n] = a[n-1] + a[a[n-2] % n]\n\n"}
{"sequence_id": "A215526", "text": "a(0)=a(1)=1, a(n) = a(n-2) + a(a(n-1) mod n).", "sequence": "1,1,2,3,5,4,10,7,17,24,22,25,23,47,27,70,37,73,38,74,65,76,87,114,125,115,150,185,223,250,245,473,360,718,365,788,725,875,726,1000,727,1245,912,1269,1787,1629,1861,1852,2084,2002,2086,3863,2156,4588,4312", "code": "\na = [1]*1000\nfor n in range(2, 77):\n    print a[n-2],\n    a[n] = a[n-2] + a[a[n-1] % n]\n"}
{"sequence_id": "A215530", "text": "The limit of the string \"0, 1\" under the operation 'repeat string twice and append 0'.", "sequence": "0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0", "code": "\nTOP = 10000\na = [0]*TOP\nb = [0]*TOP\na[1] = b[1] = 1\nn = 2\nwhile n*2+1<TOP:\n  a[n:] = a[:n]\n  a.append(0)\n  b[n:] = b[:n]\n  b.append(1)\n  n += n+1\nfor i in range(n-1):\n  print a[i],\n  if b[i]!= 1 - a[i+1]:\n    print 'error!'\n    break\n"}
{"sequence_id": "A215531", "text": "The limit of the string \"0, 1\" under the operation 'append first k terms, k=k+2' with k=1 initially.", "sequence": "0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,1,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0", "code": "\nTOP = 1000\na = [0]*TOP\na[1] = 1\nn = 2\nk = 1\nwhile n+k < TOP:\n  a[n:] = a[:k]\n  n += k\n  k += 2\nfor k in range(n):\n  print a[k],\n"}
{"sequence_id": "A215532", "text": "The limit of the string \"0, 1\" under the operation 'append first k terms, increment k' with k=2 initially.", "sequence": "0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0", "code": "\nTOP = 1000\na = [0]*TOP\na[1] = 1\nn = k = 2\nwhile n+k < TOP:\n  a[n:] = a[:k]\n  n += k\n  k += 1\nfor k in range(n):\n  print a[k],\n"}
{"sequence_id": "A215581", "text": "The limit of the string \"0, 1\" under the operation 'append last k terms, append first k terms, increment k' with k=1 initially.", "sequence": "0,1,1,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,0,0,1,0,0,1,1,0,1,0,0,1,0,1,1", "code": "\nTOP = 1000\na = [0]*TOP\na[1] = 1\nn = 2\nk = 1\nwhile n+k*2 < TOP:\n  a[n:] = a[n-k:n]\n  n += k\n  a[n:] = a[:k]\n  n += k\n  k += 1\nfor k in range(n):\n  print a[k],\n"}
{"sequence_id": "A215604", "text": "a(0)=0, a(n) = (n + a(floor(n/2))) mod 3.", "sequence": "0,1,0,1,1,2,1,2,0,1,0,1,1,2,1,2,1,2,1,2,2,0,2,0,1,2,1,2,2,0,2,0,0,1,0,1,1,2,1,2,0,1,0,1,1,2,1,2,1,2,1,2,2,0,2,0,1,2,1,2,2,0,2,0,1,2,1,2,2,0,2,0,1,2,1,2,2,0,2,0,2,0,2,0,0,1,0,1,2", "code": "\nTOP = 1000\na = [0]*TOP\nfor n in range(1, TOP):\n    print a[n-1],\n    a[n] = (n + a[n//2]) % 3\n"}
{"sequence_id": "A215659", "text": "Values of k such that k*(k - 1) is a primorial number.", "sequence": "2,3,6,15,715", "code": "\nfrom sympy import primorial, integer_nthroot\nA215659_list = []\nfor i in range(1,10**2):\n    a, b = integer_nthroot(4*primorial(i)+1,2)\n    if b:\n        A215659_list.append((a+1)//2) \n"}
{"sequence_id": "A215721", "text": "The values of N for which the 1 X N domino-covering game is a second player win.", "sequence": "0,1,5,9,15,21,25,29,35,39,43,55,59,63,73,77,89,93,97,107,111,123,127,131,141,145,157,161,165,175,179,191,195,199,209,213,225,229,233", "code": "\nimport numpy as np\nN = np.array([0,0])\nU = np.arange(1000)\nfor i in U:\n    N = np.append(N, np.setdiff1d(U,np.bitwise_xor(N[:-1],N[-2::-1])).min())\nprint(list(*np.where(N==0)))\n"}
{"sequence_id": "A215727", "text": "a(n) is the smallest m for which 3^m contains n consecutive identical digits.", "sequence": "0,11,32,33,274,538,2124,7720,22791,107187,107187,639226,5756979,8885853,68353787,78927180,78927180", "code": "\ndef A215727(n):\n    l, x = [str(d)*n for d in range(10)], 1\n    for m in range(10**9):\n        s = str(x)\n        for k in l:\n            if k in s:\n                return m\n        x *= 3\n    return 'search limit reached'\n\n"}
{"sequence_id": "A215728", "text": "a(n) is the smallest m for which 5^m contains n consecutive identical digits.", "sequence": "0,11,50,95,125,1087,2786,2790,2796,2797,2802,2803,1040703,5547565,7761841,17876345", "code": "\ndef A215728(n):\n    l, x = [str(d)*n for d in range(10)], 1\n    for m in range(10**9):\n        s = str(x)\n        for k in l:\n            if k in s:\n                return m\n        x *= 5\n    return 'search limit reached'\n\n"}
{"sequence_id": "A215729", "text": "a(n) is the smallest m for which 6^m contains (at least) n consecutive identical digits.", "sequence": "0,5,5,115,226,371,1503,8533,27717,27717,69936,848255,1308931,8255246", "code": "\ndef A215729(n):\n....l, x = [str(d)*n for d in range(10)], 1\n....for m in range(10**9):\n........s = str(x)\n........for k in l:\n............if k in s:\n................return m\n........x *= 6\n....return 'search limit reached'\n\n"}
{"sequence_id": "A215730", "text": "a(n) is the smallest m for which 7^m contains n consecutive identical digits.", "sequence": "0,6,31,71,172,175,1961,6176,33836,61282,305871,856635,2135396,7291510,11032874", "code": "\ndef a(n):\n..st = \"0123456789\"\n..for k in range(10**6):\n....s = str(7**k)\n....tot = 0\n....for i in st:\n......if s.count(i*n) > 0:\n........tot += 1\n........break\n....if tot > 0:\n......return k\nn = 1\nwhile n < 10:\n..print(a(n),end=', ')\n..n += 1\n\n"}
{"sequence_id": "A215730", "text": "a(n) is the smallest m for which 7^m contains n consecutive identical digits.", "sequence": "0,6,31,71,172,175,1961,6176,33836,61282,305871,856635,2135396,7291510,11032874", "code": "\ndef A215730(n):\n....l, x = [str(d)*n for d in range(10)], 1\n....for m in range(10**9):\n........s = str(x)\n........for k in l:\n............if k in s:\n................return m\n........x *= 7\n....return 'search limit reached'\n\n"}
{"sequence_id": "A215731", "text": "a(n) is the smallest m for which the decimal representation of 11^m contains n consecutive identical digits.", "sequence": "0,1,8,39,156,482,1323,2983,9443,39879,214747,296095,296095,5541239,8621384", "code": "\ndef A215731(n):\n    l, x = [str(d)*n for d in range(10)], 1\n    for m in range(10**9):\n        s = str(x)\n        for k in l:\n            if k in s:\n                return m\n        x *= 11\n    return 'search limit reached'\n\n"}
{"sequence_id": "A215732", "text": "a(n) is the first digit to appear n times in succession in a power of 2.", "sequence": "1,5,7,5,6,8,7,1,9,9,6,3,2,9,1", "code": "\ndef A215732(n):\n    l, x = [str(d)*n for d in range(10)], 1\n    for m in range(10**9):\n        s = str(x)\n        for k in range(10):\n            if l[k] in s:\n                return k\n        x *= 2\n    return 'search limit reached'\n\n"}
{"sequence_id": "A215733", "text": "a(n) is the first digit to appear n times in succession in a power of 3.", "sequence": "1,7,8,5,5,8,2,1,2,2,2,4,5,8,2,4,4", "code": "\ndef A215733(n):\n....l, x = [str(d)*n for d in range(10)], 1\n....for m in range(10**9):\n........s = str(x)\n........for k in range(10):\n............if l[k] in s:\n................return k\n........x *= 3\n....return 'search limit reached'\n\n"}
{"sequence_id": "A215737", "text": "a(n) is the first digit to appear n times in succession in a power of 11.", "sequence": "1,1,8,7,6,0,6,0,9,6,6,2,2,7,6", "code": "\ndef A215737(n):\n    a, s = 1, tuple(str(i)*n for i in range(10))\n    while True:\n        a *= 11\n        t = str(a)\n        for i, x in enumerate(s):\n            if x in t:\n                return i \n"}
{"sequence_id": "A215747", "text": "a(n) = (-2)^n mod n.", "sequence": "0,0,1,0,3,4,5,0,1,4,9,4,11,4,7,0,15,10,17,16,13,4,21,16,18,4,1,16,27,4,29,0,25,4,17,28,35,4,31,16,39,22,41,16,28,4,45,16,19,24,43,16,51,28,12,32,49,4,57,16,59,4,55,0,33,64,65,16,61,44,69,64,71,4,7", "code": "\nfor n in range(1, 333):\n    print((-2)**n % n, end=',')\n"}
{"sequence_id": "A215775", "text": "Numbers k such that 2*k!! + 1 is a prime.", "sequence": "0,1,2,3,4,5,6,7,8,10,13,17,18,24,28,30,39,51,149,197,355,444,623,908,1084,1125,1577,1748,2584,2628,2702,3973,5046", "code": "\nfrom sympy import isprime\ndef afind(startat=0, limit=10**9):\n  df, dfm1 = 1, 1\n  for k in range(startat):\n    df, dfm1 = (k+1)*dfm1, df\n  for k in range(startat, limit+1):\n    if isprime(2*df+1): print(k, end=\", \")\n    df, dfm1 = (k+1)*dfm1, df\nafind(limit=625) \n"}
{"sequence_id": "A215852", "text": "Number of simple labeled graphs on n nodes with exactly 2 connected components that are trees or cycles.", "sequence": "1,3,19,135,1267,15029,218627,3783582,75956664,1734309929,44357222772,1255715827483,38971877812380,1315634598619830,47994245894462576,1881406032047006812,78870928008704884848,3520953336130828001295,166762291211479030734580", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial, factorial as f\n@cacheit\ndef T(n, k): return 0 if k<0 or k>n else 1 if n==0 else sum([binomial(n - 1, i)*T(n - 1 - i, k - 1)*(1 if i<2 else f(i)//2 + (i + 1)**(i - 1)) for i in range(n - k + 1)])\ndef a(n): return T(n , 2)\nprint([a(n) for n in range(2, 51)]) \n"}
{"sequence_id": "A215892", "text": "a(n) = 2^n - n^k, where k is the largest integer such that 2^n >= n^k.", "sequence": "0,5,0,7,28,79,192,431,24,717,2368,5995,13640,29393,0,47551,157168,393967,888576,1902671,3960048,1952265,8814592,23788807,55227488,119868821,251225088,516359763,344741824,1259979967,3221225472,7298466623,15635064768", "code": "\nfor n in range(2,100):\n    a = 2**n\n    k = 0\n    while n**(k+1) <= a:\n        k += 1\n    print(a - n**k, end=',')\n"}
{"sequence_id": "A215894", "text": "a(n) = floor(2^n / n^k), where k is the largest integer such that 2^n >= n^k.", "sequence": "1,2,1,1,1,2,4,6,1,1,2,3,5,9,1,1,2,4,6,10,17,1,2,3,5,9,15,26,1,2,4,6,11,18,31,1,2,4,6,11,19,32,1,2,3,5,9,16,28,49,1,2,4,7,13,22,38,1,1,3,5,9,16,27,47,1,2,3,5,10,17,30,51,1,2,3,5,10", "code": "\nimport math\ndef modiv(a,b):\n    return a - b*(a//b)\ndef modlg(a,b):\n    return a // b**int(math.log(a,b))\nfor n in range(2,100):\n    a = 2**n\n    print(modlg(a,n), end=',')\n"}
{"sequence_id": "A215977", "text": "Number T(n,k) of simple unlabeled graphs on n nodes with exactly k connected components that are trees or cycles; triangle T(n,k), n >= 0, 0 <= k <= n, read by rows.", "sequence": "1,0,1,0,1,1,0,2,1,1,0,3,3,1,1,0,4,5,3,1,1,0,7,10,6,3,1,1,0,12,17,12,6,3,1,1,0,24,33,23,13,6,3,1,1,0,48,62,47,25,13,6,3,1,1,0,107,127,92,53,26,13,6,3,1,1,0,236,267,189,106,55,26,13,6,3,1,1", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial, divisors\n@cacheit\ndef b(n): return n if n<2 else sum([sum([d*b(d) for d in divisors(j)])*b(n - j) for j in range(1, n)])//(n - 1)\n@cacheit\ndef g(n): return (1 if n>2 else 0) + b(n) - (sum(b(k)*b(n - k) for k in range(n + 1)) - (b(n//2) if n%2==0 else 0))//2\n@cacheit\ndef p(n, i, t): return 0 if n<t else 1 if n==t else 0 if min(i, t)<1 else sum(binomial(g(i) + j - 1, j)*p(n - i*j, i - 1, t - j) for j in range(min(n//i, t) + 1))\ndef T(n, k): return p(n, n, k)\nfor n in range(21): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A215978", "text": "Number of simple unlabeled graphs on n nodes with connected components that are trees or cycles.", "sequence": "1,1,2,4,8,14,28,52,104,206,429,903,1982,4430,10206,23966,57522,140236,347302,870682,2207819,5651437,14590703,37948338,99358533,261684141,692906575,1843601797,4926919859,13220064562,35604359531,96218568474,260850911485", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial, divisors\n@cacheit\ndef b(n): return n if n<2 else sum([sum([d*b(d) for d in divisors(j)])*b(n - j) for j in range(1, n)])//(n - 1)\n@cacheit\ndef g(n): return (1 if n>2 else 0) + b(n) - (sum([b(k)*b(n - k) for k in range(n + 1)]) - (b(n//2) if n%2==0 else 0))//2\n@cacheit\ndef p(n, i): return 1 if n==0 else 0 if i<1 else sum([binomial(g(i) + j - 1, j)*p(n - i*j, i - 1) for j in range(n//i + 1)])\ndef a(n): return p(n, n)\nprint([a(n) for n in range(41)]) \n"}
{"sequence_id": "A215982", "text": "Number of simple unlabeled graphs on n nodes with exactly 2 connected components that are trees or cycles.", "sequence": "1,1,3,5,10,17,33,62,127,267,587,1326,3085,7326,17731,43585,108563,273544,696113,1787042,4623125,12043071,31565842,83200763,220413272,586625403,1567930743,4207181144,11329835687,30613313339,82975300030,225552632043,614787508640", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial, divisors\n@cacheit\ndef b(n): return n if n<2 else sum([sum([d*b(d) for d in divisors(j)])*b(n - j) for j in range(1, n)])//(n - 1)\n@cacheit\ndef g(n): return (1 if n>2 else 0) + b(n) - (sum([b(k)*b(n - k) for k in range(n + 1)]) - (b(n//2) if n%2==0 else 0))//2\n@cacheit\ndef p(n, i, t): return 0 if n<t else 1 if n==t else 0 if min(i, t)<1 else sum([binomial(g(i) + j - 1, j)*p(n - i*j, i - 1, t - j) for j in range(min(n//i, t) + 1)])\ndef a(n): return p(n, n, 2)\nprint([a(n) for n in range(2, 41)]) \n"}
{"sequence_id": "A216021", "text": "a(n) = modlg(n^n, 2^n), where modlg is the function defined in A215894: modlg(a,b) = floor(a / b^floor(logb(a))), logb is the logarithm base b.", "sequence": "1,1,3,1,3,11,50,1,2,9,33,129,550,2526,12445,1,2,8,26,86,302,1103,4216,16834,70064,303520,1366413,6383595,30907397,154895272,802588710,1,2,7,23,69,215,685,2242,7523,25881,91237,329377,1217078,4600595,17781207,70234475", "code": "\nimport math\ndef modiv(a,b):\n    return a - b*int(a/b)\ndef modlg(a,b):\n    return a // b**int(math.log(a,b))\nfor n in range(1,77):\n    print modlg(n**n,2**n),\n"}
{"sequence_id": "A216090", "text": "Numbers n such that k^(n-1) == k (mod n) for every k = 1, 2, ..., n-1.", "sequence": "1,2,6,10,14,22,26,30,34,38,46,58,62,74,82,86,94,106,118,122,134,142,146,158,166,178,182,194,202,206,214,218,226,254,262,274,278,298,302,314,326,334,346,358,362,382,386,394,398,422,446,454,458,466,478,482", "code": "\nfrom sympy.ntheory.factor_ import core\nfrom sympy import primefactors\ndef ok(n):\n    if n<3: return True\n    if core(n) == n:\n        for p in primefactors(n):\n            if (n - 2)%(p - 1): return False\n        return True\n    return False\nprint([n for n in range(1, 501) if ok(n)]) \n"}
{"sequence_id": "A216167", "text": "Composite numbers which yield a prime whenever a 5 is inserted anywhere in them, excluding at the end.", "sequence": "9,21,57,63,69,77,87,93,153,231,381,407,413,417,501,531,581,651,669,741,749,783,791,987,1241,1551,1797,1971,2189,2981,3381,3419,3591,3951,4083,4503,4833,4949,4959,5049,5117,5201,5229,5243,5529,5547,5603,5691,5697", "code": "\nfrom sympy import isprime\ndef ok(n):\n    if n < 2 or n%10 not in {1, 3, 7, 9} or isprime(n): return False\n    s = str(n)\n    return all(isprime(int(s[:i] + '5' + s[i:])) for i in range(len(s)))\nprint(list(filter(ok, range(5698)))) \n"}
{"sequence_id": "A216234", "text": "Cumulated number of increasing admissible cuts of rooted plane trees of size n.", "sequence": "0,1,2,8,44,312,2772,30024,385688,5737232,96959396,1834244296,38390799592,880648730416,21968596282440,592083291341520,17144219069647920,530774988154571040,17495673315094986180,611738880367145595720,22614424027640541372360", "code": "\ndef a(n):\n   if n < 3:\n      return n\n   l = [0,1,2]\n   for i in range(n-2):\n      l[i%3] = ( (16*i-64*i**3)*l[i%3]+(12+72*i+112*i**2+32*i**3)*l[(i+1)%3]+(-26-62*i-4*i**3-36*i**2)*l[(i+2)%3] ) / (-5-7*i-2*i**2)\n   return l[i%3]\n"}
{"sequence_id": "A216248", "text": "T(n,k)=((n+k)^2-4*k+3-(-1)^k-(n+k-2)*(-1)^(n+k))/2-1, if k=1 and (n mod 2)=1; T(n,k)=((n+k)^2-4*k+3-(-1)^k-(n+k-2)*(-1)^(n+k))/2, else. Table T(n,k) read by antidiagonals; n, k > 0.", "sequence": "1,2,5,3,4,6,7,10,11,14,8,9,12,13,15,16,19,20,23,24,27,17,18,21,22,25,26,28,29,32,33,36,37,40,41,44,30,31,34,35,38,39,42,43,45,46,49,50,53,54,57,58,61,62,65,47,48,51,52,55,56,59,60,63,64,66,67", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=((t+2)**2-4*j+3-(-1)**j-(t)*(-1)**t)/2\nif j==1 and (i%2)==1:\n   result=result-1\n"}
{"sequence_id": "A216249", "text": "T(n,k) = ((n+k)^2-4*k+3-2*(-1)^n+(-1)^k-(n+k-4)*(-1)^(n+k))/2-2, if k=1 and (n mod 2)=1; T(n,k)=((n+k)^2-4*k+3-2*(-1)^n+(-1)^k-(n+k-4)*(-1)^(n+k))/2, else. Table T(n,k) read by antidiagonals; n , k > 0.", "sequence": "1,3,2,4,5,6,8,7,12,11,9,10,13,14,15,17,16,21,20,25,24,18,19,22,23,26,27,28,30,29,34,33,38,37,42,41,31,32,35,36,39,40,43,44,45,47,46,51,50,55,54,59,58,63,62,48,49,52,53,56,57,60,61,64,65,66,68,67,72,71,76,75,80,79,84,83,88,87", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=((t+2)**2-4*j+3+(-1)**j-2*(-1)**i-(t-2)*(-1)**t)/2\nif j==1 and (i%2)==1:\n   result=result-2\n"}
{"sequence_id": "A216250", "text": "T(n,k)=((n+k)^2-4*k+3-2*(-1)^n-(-1)^k-(n+k-4)*(-1)^(n+k))/2-3, if k=1 and (n mod 2)=1; T(n,k)=((n+k)^2-4*k+3-2*(-1)^n-(-1)^k-(n+k-4)*(-1)^(n+k))/2, else. Table T(n,k) read by antidiagonals; n , k > 0.", "sequence": "1,2,3,5,4,6,7,8,11,12,10,9,14,13,15,16,17,20,21,24,25,19,18,23,22,27,26,28,29,30,33,34,37,38,41,42,32,31,36,35,40,39,44,43,45,46,47,50,51,54,55,58,59,62,63,49,48,53,52,57,56,61,60,65,64,66,67", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=((t+2)**2-4*j+3-(-1)**j-2*(-1)**i-(t-2)*(-1)**t)/2\nif j==1 and (i%2)==1:\n   result=result-3\n"}
{"sequence_id": "A216252", "text": "A213196 as table read layer by layer clockwise.", "sequence": "1,4,5,2,3,7,10,8,6,11,9,17,20,23,14,12,13,16,26,38,43,39,21,24,15,22,25,30,42,58,63,48,35,31,27,18,19,29,34,57,53,69,76,70,64,49,36,32,28,37,33,47,52,81,75,95,102,109,88,82,54,59,44,40,41,46,62", "code": "\nt=int((math.sqrt(n-1)))+1\ni=min(t,n-(t-1)**2)\nj=min(t,t**2-n+1)\nm1=(3*i+j-1-(-1)**i+(i+j-2)*(-1)**(i+j))/4\nm2=((1+(-1)**i)*((1+(-1)**j)*2*int((j+2)/4)-(-1+(-1)**j)*(2*int((i+4)/4)+2*int(j/2)))-(-1+(-1)**i)*((1+(-1)**j)*(1+2*int(i/4)+2*int(j/2))-(-1+(-1)**j)*(1+2*int(j/4))))/4\nm=(m1+m2-1)*(m1+m2-2)/2+m1\n"}
{"sequence_id": "A216253", "text": "A213196 as table read layer by layer - layer clockwise, layer counterclockwise and so on.", "sequence": "1,2,5,4,3,7,10,8,6,12,14,23,20,17,9,11,13,16,26,38,43,39,21,24,15,18,27,31,35,48,63,58,42,30,25,22,19,29,34,57,53,69,76,70,64,49,36,32,28,40,44,59,54,82,88,109,102,95,75,81,52,47,33,37,41,46,62", "code": "\nt=int((math.sqrt(n-1)))+1\ni=(t % 2)*min(t,n-(t-1)**2) + ((t+1) % 2)*min(t,t**2-n+1)\nj=(t % 2)*min(t,t**2-n+1) + ((t+1) % 2)*min(t,n-(t-1)**2)\nm1=(3*i+j-1-(-1)**i+(i+j-2)*(-1)**(i+j))/4\nm2=((1+(-1)**i)*((1+(-1)**j)*2*int((j+2)/4)-(-1+(-1)**j)*(2*int((i+4)/4)+2*int(j/2)))-(-1+(-1)**i)*((1+(-1)**j)*(1+2*int(i/4)+2*int(j/2))-(-1+(-1)**j)*(1+2*int(j/4))))/4\nm=(m1+m2-1)*(m1+m2-2)/2+m1\n"}
{"sequence_id": "A216267", "text": "Numbers that are both tetrahedral and pronic.", "sequence": "0,20,56,7140,1414910", "code": "\ndef rootPronic(a):\n    sr = 1L<<33\n    while a < sr*(sr+1):\n      sr>>=1\n    b = sr>>1\n    while b:\n        s = sr+b\n        if a >= s*(s+1):\n          sr = s\n        b>>=1\n    return sr\nfor i in range(1<<20):\n      a = i*(i+1)*(i+2)/6\n      t = rootPronic(a)\n      if a == t*(t+1):\n        print a,\n"}
{"sequence_id": "A216268", "text": "Tetrahedral numbers of the form n^2 - 1.", "sequence": "0,35,120,2024,2600,43680,435730689800", "code": "\nimport math\nfor i in range(1L<<33):\n    t = i*(i+1)*(i+2)/6 + 1\n    sr = int(math.sqrt(t))\n    if sr*sr == t:\n        print t-1,\n"}
{"sequence_id": "A216269", "text": "Numbers n such that n^2 - 1 is a tetrahedral number (A000292).", "sequence": "1,6,11,45,51,209,660099", "code": "\nimport math\nfor i in range(1L<<30):\n    t = i*(i+1)*(i+2)/6 + 1\n    sr = int(math.sqrt(t))\n    if sr*sr == t:\n        print sr,\n"}
{"sequence_id": "A216377", "text": "The most significant digit in base n representation of n!.", "sequence": "1,2,1,4,3,2,1,6,3,2,1,7,4,2,1,10,5,2,1,15,8,4,2,1,13,6,3,1,25,12,6,3,1,25,12,6,3,1,28,13,6,3,1,33,16,7,3,1,41,20,9,4,2,1,26,12,6,2,1,38,18,8,3,1,57,27,12,5,2,1,43,20,9,4,2,72,33,15,7,3,1", "code": "\nimport math\ndef modlg(a,b):\n    return a // b**int(math.log(a,b))\nfor n in range(2,88):\n    print modlg(math.factorial(n),n),\n"}
{"sequence_id": "A216384", "text": "Numbers that can be expressed as the sum of their first k consecutive arithmetic derivatives for some k > 1.", "sequence": "6,38,42,62,146,1145,4214,15590,47058,121935,464834,4049465,4759314,7756755,15838490,18284105,127137997,132734042,141393578,353493351,435485242,470458377,1056410914", "code": "\nfrom sympy import factorint\nA216384 = []\nfor n in range(1,10**5):\n....ndsum = nd = sum([int(n*e/p) for p,e in factorint(n).items()])\n....while ndsum <= n and nd > 1:\n........nd = sum([int(nd*e/p) for p,e in factorint(nd).items()])\n........ndsum += nd\n........if ndsum == n:\n............A216384.append(n)\n\n"}
{"sequence_id": "A216394", "text": "Number of values of k for which phi(k) is a permutation of decimal digits of k, for 2^(n-1) < k < 2^n.", "sequence": "1,0,0,0,1,1,0,0,2,0,0,3,11,2,13,21,26,49,91,186,108,335,937,500,1681,4208,4156", "code": "\nfrom sympy import totient\ndef A216394(n):\n....if n == 1:\n........return 1\n....c = 0\n....for i in range(2**(n-1)+1,2**n):\n........s1, s2 = sorted(str(i)),sorted(str(totient(i)))\n........if len(s1) == len(s2) and s1 == s2:\n............c += 1\n....return c \n"}
{"sequence_id": "A216395", "text": "Number of values of k for which sigma(k) is a permutation of decimal digits of k, for 2^(n-1) < k < 2^n.", "sequence": "1,0,0,0,0,0,1,0,3,2,0,6,3,5,14,22,26,60,64,71,179,333,274,751,1653,1726,3032", "code": "\nfrom sympy import divisor_sigma\ndef A216395(n):\n....if n == 1:\n........return 1\n....c = 0\n....for i in range(2**(n-1)+1,2**n):\n........s1, s2 = sorted(str(i)),sorted(str(divisor_sigma(i)))\n........if len(s1) == len(s2) and s1 == s2:\n............c += 1\n....return c \n"}
{"sequence_id": "A216396", "text": "Number of values of k for which sigma(k)-k is a permutation of decimal digits of k, for 2^(n-1) < k < 2^n.", "sequence": "0,0,1,0,1,0,0,0,2,1,1,2,5,4,15,15,16,35,91,90,158,345,586,694,1549,2700,3363", "code": "\nfrom sympy import divisor_sigma\ndef A216396(n):\n....c = 0\n....for i in range(2**(n-1)+1,2**n):\n........s1, s2 = sorted(str(i)),sorted(str(divisor_sigma(i)-i))\n........if len(s1) == len(s2) and s1 == s2:\n............c += 1\n....return c \n"}
{"sequence_id": "A216431", "text": "a(0)=0; thereafter a(n+1) = a(n) + 1 + number of 0's in binary representation of a(n), counted with A023416.", "sequence": "0,2,4,7,8,12,15,16,21,24,28,31,32,38,42,46,49,53,56,60,63,64,71,75,79,82,87,90,94,97,102,106,110,113,117,120,124,127,128,136,143,147,152,158,162,168,174,178,183,186,190,193,199,203,207,210,215,218,222", "code": "\na = 0\nfor n in range(100):\n    print a,\n    ta = a\n    c0 = (a==0)\n    while ta>0:\n        c0 += 1-(ta&1)\n        ta >>= 1\n    a += 1 + c0\n(Scheme, with memoizing definec-macro from Antti Karttunen's IntSeq-library)\n(definec (A216431 n) (if (< n 2) (+ n n) (A233272 (A216431 (- n 1)))))\n;; _Antti Karttunen_, Dec 12 2013\n"}
{"sequence_id": "A216476", "text": "Number of iterations of the \"Oware\" operation until the initial position n is reproduced.", "sequence": "1,1,1,1,1,1,1,1,1,2,4,3,6,10,12,4,8,18,6,4,3,6,10,12,4,8,18,6,11,3,2,10,12,4,8,18,3,11,20,6,10,12,4,8,18,6,11,20,18,10,12,2,8,18,6,11,4,18,28,12,4,8,18,3,11,20,6,28,5,4,8,18,2,11,20,18,28,5,10,8,18,6,11,20,18,28,5,10,12,18", "code": "\nfor n in range(1,1001):\n..digits = [int(i) for i in str(n)]\n..piv, step, arr = 0, 0, digits.copy()\n..while not (step and piv == 0 and arr == digits):\n....hand = arr[piv]\n....arr[piv] = 0\n....for k in range(hand):\n......piv = (piv+1)%len(arr)\n......arr[piv] += 1\n....step += 1\n..print(n,step) \n"}
{"sequence_id": "A216479", "text": "a(n) is the least multiple of n which uses only the digit 1, or a(n) = -1 if no such multiple exists.", "sequence": "1,-1,111,-1,-1,-1,111111,-1,111111111,-1,11,-1,111111,-1,-1,-1,1111111111111111,-1,111111111111111111,-1,111111,-1,1111111111111111111111,-1,-1,-1,111111111111111111111111111,-1,1111111111111111111111111111,-1,111111111111111,-1,111111,-1,-1,-1,111,-1,111111,-1,11111,-1", "code": "\ndef A216479(n):\n    if n % 2 == 0 or n % 5 == 0:\n        return -1\n    rem = 1\n    while rem % n != 0:\n        rem = rem*10 + 1\n    return rem\n\n"}
{"sequence_id": "A216488", "text": "Numbers k such that the last 9 digits of the k-th Lucas number are 1-9 pandigital.", "sequence": "3352,3837,7239,18503,19344,22628,29363,30994,37514,47058,48201,50371,51702,51857,53586,55469,56248,56668,60560,65206,70610,72171,76554,78310,78380,82628,82952,82993,93615,99751,101179,104469,105347,105379,106327,113251,114970,116751,117313", "code": "\ndef afind(limit):\n    bkm1, bk = 2, 1\n    for k in range(2, limit+1):\n        bkm1, bk = bk, bkm1 + bk\n        if set(str(bk)[-9:]) == set(\"123456789\"): print(k, end=\", \")\nafind(10**6)) \n"}
{"sequence_id": "A216685", "text": "A(n) is the number of 1's in binary expansion of n + a(n-1), with a(0)=0.", "sequence": "0,1,2,2,2,3,2,2,2,3,3,3,4,2,1,1,2,3,3,3,4,3,3,3,4,4,4,5,2,5,3,2,2,3,3,3,4,3,3,3,4,4,4,5,3,2,2,3,4,4,4,5,4,4,4,5,5,5,6,2,5,2,1,1,2,3,3,3,4,3,3,3,4,4,4,5,3,2,2,3,4,4,4,5,4,4,4", "code": "\na=0\nfor n in range(1,333):\n    print a,\n    x = a+n\n    a = 0\n    while x:\n        a += x & 1\n        x >>= 1\n"}
{"sequence_id": "A216822", "text": "Numbers n such that 2^n == 2 (mod n*(n+1)).", "sequence": "1,5,13,29,37,61,73,157,181,193,277,313,397,421,457,541,561,613,661,673,733,757,877,997,1093,1153,1201,1213,1237,1289,1321,1381,1453,1621,1657,1753,1873,1905,1933,1993,2017,2137,2341,2473,2557,2593,2797,2857,2917", "code": "\nA216822_list = [n for n in range(1,10**6) if n == 1 or pow(2,n,n*(n+1)) == 2] \n"}
{"sequence_id": "A216873", "text": "Numbers n such that 2^n in decimal has at least 9 of the digits 0-9 appearing a prime number of times.", "sequence": "88,104,113,114,120,141", "code": "\nfrom sympy import isprime\nA216873_list, n = [], 1\nfor i in range(2*10**6):\n    s = str(n)\n    if sum(isprime(s.count(d)) for d in '0123456789') >= 9:\n        A216873_list.append(i)\n    n *= 2 \n"}
{"sequence_id": "A216995", "text": "Multiples of 11 whose digit sum is a multiple of 11.", "sequence": "209,308,407,506,605,704,803,902,2090,2299,2398,2497,2596,2695,2794,2893,2992,3080,3289,3388,3487,3586,3685,3784,3883,3982,4070,4279,4378,4477,4576,4675,4774,4873,4972,5060,5269,5368,5467,5566,5665,5764,5863,5962,6050", "code": "\ndef sd(n): return sum(map(int, str(n)))\ndef ok(n): return n%11 == 0 and sd(n)%11 == 0\nprint(list(filter(ok, range(1, 6051)))) \n"}
{"sequence_id": "A217010", "text": "Permutation of natural numbers arising from applying the walk of a square spiral (e.g., A214526) to the data of right triangular type-1 spiral (defined in A214230).", "sequence": "1,2,13,3,5,6,7,8,9,10,12,32,61,33,14,4,18,19,20,21,22,23,24,25,26,27,11,31,60,98,145,99,62,34,15,17,40,41,42,43,44,45,46,47,48,49,50,51,52,53,28,30,59,97,144,200,265,201,146,100,63,35,16,39,71", "code": "\nSIZE = 33       \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk(0, -1,  1,  1)    \n    walk( 1, 1, -1,  0)    \n    if posX==SIZE-1:\n        break\n    walk(-1, 0,  0, -1)    \nimport sys\ngrid2 = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid2[posY*SIZE+posX]=1\ndef walk2(stepX, stepY, chkX, chkY):\n  global posX, posY\n  while 1:\n    a = grid[posY*SIZE+posX]\n    if a==0:\n        sys.exit(1)\n    print a,\n    posX+=stepX\n    posY+=stepY\n    grid2[posY*SIZE+posX]=1\n    if grid2[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posX:\n    walk2(0, -1, 1, 0)    \n    walk2(1, 0, 0, 1)     \n    walk2(0, 1, -1, 0)    \n    walk2(-1, 0, 0, -1)   \n"}
{"sequence_id": "A217011", "text": "Permutation of natural numbers arising from applying the walk of a square spiral (e.g. A214526) to the data of right triangular type-2 spiral (defined in A214251).", "sequence": "1,5,19,6,8,9,10,2,3,4,18,41,73,42,20,7,24,25,26,27,28,11,12,13,14,15,17,40,72,113,163,114,74,43,21,23,49,50,51,52,53,54,55,29,30,31,32,33,34,35,16,39,71,112,162,221", "code": "\nSIZE = 33       \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk(-1, 0,  0, -1)    \n    walk(0, -1,  1,  1)    \n    if posY==0:\n        break\n    walk( 1, 1, -1,  0)    \nimport sys\ngrid2 = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid2[posY*SIZE+posX]=1\ndef walk2(stepX, stepY, chkX, chkY):\n  global posX, posY\n  while 1:\n    a = grid[posY*SIZE+posX]\n    if a==0:\n        sys.exit(1)\n    print a,\n    posX+=stepX\n    posY+=stepY\n    grid2[posY*SIZE+posX]=1\n    if grid2[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk2(0, -1, 1, 0)    \n    walk2(1, 0, 0, 1)     \n    walk2(0, 1, -1, 0)    \n    walk2(-1, 0, 0, -1)   \n"}
{"sequence_id": "A217012", "text": "Permutation of natural numbers arising from applying the walk of a square spiral (e.g. A214526) to the data of right triangular type-3 spiral (defined in A214252).", "sequence": "1,8,25,9,2,3,4,5,6,7,24,50,85,51,26,10,12,13,14,15,16,17,18,19,20,21,23,49,84,128,181,129,86,52,27,11,31,32,33,34,35,36,37,38,39,40,41,42,43,44,22,48,83,127,180,242", "code": "\nSIZE = 33       \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posY!=0:\n    walk( 1, 1, -1,  0)    \n    walk(-1, 0,  0, -1)    \n    walk(0, -1,  1,  1)    \nimport sys\ngrid2 = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid2[posY*SIZE+posX]=1\ndef walk2(stepX, stepY, chkX, chkY):\n  global posX, posY\n  while 1:\n    a = grid[posY*SIZE+posX]\n    if a==0:\n        sys.exit(1)\n    print a,\n    posX+=stepX\n    posY+=stepY\n    grid2[posY*SIZE+posX]=1\n    if grid2[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk2(0, -1, 1, 0)    \n    walk2(1, 0, 0, 1)     \n    walk2(0, 1, -1, 0)    \n    walk2(-1, 0, 0, -1)   \n"}
{"sequence_id": "A217013", "text": "Permutation of natural numbers arising from applying the walk of a square spiral (e.g. A214526) to the data of triangular horizontal-first spiral (defined in A214250).", "sequence": "1,3,14,4,6,7,8,2,12,30,13,32,59,33,15,5,19,20,21,22,23,9,11,29,55,89,56,31,58,93,136,94,60,34,16,18,40,41,42,43,44,45,46,24,10,28,54,88,130,180,131,90,57,92,135,186,245,187,137,95,61,35,17,39,69", "code": "\nSIZE = 33       \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posX<SIZE-2:\n    walk(-1, 0,  1, -1)    \n    walk(1, -1,  1,  1)    \n    walk(1,  1, -1,  0)    \n    walk(-1, 0,  1, -1)    \nimport sys\ngrid2 = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid2[posY*SIZE+posX]=1\ndef walk2(stepX, stepY, chkX, chkY):\n  global posX, posY\n  while 1:\n    a = grid[posY*SIZE+posX]\n    if a==0:\n        sys.exit(1)\n    print a,\n    posX+=stepX\n    posY+=stepY\n    grid2[posY*SIZE+posX]=1\n    if grid2[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk2(0, -1, 1, 0)    \n    walk2(1, 0, 0, 1)     \n    walk2(0, 1, -1, 0)    \n    walk2(-1, 0, 0, -1)   \n"}
{"sequence_id": "A217014", "text": "Permutation of natural numbers arising from applying the walk of a square spiral (e.g. A214526) to the data of triangular horizontal-last spiral (defined in A214226).", "sequence": "1,7,22,8,2,3,4,6,20,42,21,44,75,45,23,9,11,12,13,14,15,5,19,41,71,109,72,43,74,113,160,114,76,46,24,10,28,29,30,31,32,33,34,16,18,40,70,108,154,208,155,110,73,112,159,214", "code": "\nSIZE = 33       \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk(1,  1, -1,  0)    \n    walk(-1, 0,  1, -1)    \n    walk(-1, 0,  1, -1)    \n    if posX<2:\n        break\n    walk(1, -1,  1,  1)    \nimport sys\ngrid2 = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid2[posY*SIZE+posX]=1\ndef walk2(stepX, stepY, chkX, chkY):\n  global posX, posY\n  while 1:\n    a = grid[posY*SIZE+posX]\n    if a==0:\n        sys.exit(1)\n    print a,\n    posX+=stepX\n    posY+=stepY\n    grid2[posY*SIZE+posX]=1\n    if grid2[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk2(0, -1, 1, 0)    \n    walk2(1, 0, 0, 1)     \n    walk2(0, 1, -1, 0)    \n    walk2(-1, 0, 0, -1)   \n"}
{"sequence_id": "A217015", "text": "Permutation of natural numbers arising from applying the walk of a square spiral (e.g. A214526) to the data of rotated-square spiral (defined in A215468).", "sequence": "1,5,6,2,8,3,10,4,12,24,13,14,27,15,7,17,31,18,9,20,35,21,11,23,39,59,40,25,26,43,64,44,28,16,30,48,70,49,32,19,34,53,76,54,36,22,38,58,82,110,83,60,41,42,63,88,117,89,65,45,29,47,69,95,125,96,71,50", "code": "\nSIZE = 33       \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nposX += 1\ngrid[posY*SIZE+posX]=2\nn = 3\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posX!=SIZE-1:\n    walk(-1,  1, -1, -1)    \n    walk(-1, -1,  1, -1)    \n    walk( 1, -1,  1,  0)    \n    walk( 1,  0,  1,  1)    \n    walk( 1,  1, -1,  1)    \nimport sys\ngrid2 = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid2[posY*SIZE+posX]=1\ndef walk2(stepX, stepY, chkX, chkY):\n  global posX, posY\n  while 1:\n    a = grid[posY*SIZE+posX]\n    if a==0:\n        sys.exit(1)\n    print a,\n    posX+=stepX\n    posY+=stepY\n    grid2[posY*SIZE+posX]=1\n    if grid2[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk2(0, -1, 1, 0)    \n    walk2(1, 0, 0, 1)     \n    walk2(0, 1, -1, 0)    \n    walk2(-1, 0, 0, -1)   \n"}
{"sequence_id": "A217040", "text": "Bases b in which the increasing concatenation of all primes smaller than b forms a prime number.", "sequence": "3,4,5,9,10,15,244,676,14870,23526", "code": "\nfrom sympy import primerange, isprime\ndef fromdigits(d, b):\n  n = 0\n  for di in d: n *= b; n += di\n  return n\ndef ok(b): return isprime(fromdigits([p for p in primerange(1, b)], b))\nprint([b for b in range(3, 700) if ok(b)]) \n"}
{"sequence_id": "A217049", "text": "Least prime p such that all ten base-10 digits have prime counts in (p^prime(n))*(q^prime(n+1)), where q is the next prime after p.", "sequence": "18329,1913,1063,109,932839,85061,29729989,5653759,1958731,20891539,35008723,28265837,2,3,6238777,276624683,92343187,24205651,49598321,17722981,46741657,219329923,297614029,106791577,621528749,217893821,113824657,122670287,81263857", "code": "\nfrom sympy import isprime, nextprime, prime\nfrom sympy.ntheory import count_digits\ndef a(n):\n    pn = prime(n); qn = nextprime(pn)\n    p, q = 2, 3; c = count_digits(p**pn*q**qn)\n    while not all(isprime(c[i]) for i in range(10)):\n        p, q = q, nextprime(q); c = count_digits(p**pn*q**qn)\n    return p\nprint([a(n) for n in range(1, 7)]) \n"}
{"sequence_id": "A217165", "text": "a(n) is the least value of k such that the decimal expansion of Fibonacci(k) contains n consecutive identical digits.", "sequence": "0,10,49,66,118,883,2202,6493,62334,135241,353587", "code": "\ndef A217165(n):\n....if n == 1:\n........return 0\n....else:\n........l, y, x = [str(d)*n for d in range(10)], 0, 1\n........for m in range(1,10**9):\n............s = str(x)\n............for k in l:\n................if k in s:\n....................return m\n............y, x = x, y+x\n........return 'search limit reached'\n\n"}
{"sequence_id": "A217166", "text": "a(n) is the least value of k such that the decimal expansion of Lucas(k) contains n consecutive identical digits.", "sequence": "0,5,36,78,112,538,3139,6436,17544,82864,328448", "code": "\ndef A217166(n):\n....if n == 1:\n........return 0\n....else:\n........l, y, x = [str(d)*n for d in range(10)], 2, 1\n........for m in range(1,10**9):\n............s = str(x)\n............for k in l:\n................if k in s:\n....................return m\n............y, x = x, y+x\n........return 'search limit reached'\n\n"}
{"sequence_id": "A217175", "text": "a(n) is the first digit (from the left) to appear n times in succession in the decimal representation of the Fibonacci(A217165(n)).", "sequence": "0,5,7,7,1,5,7,7,3,2,4", "code": "\ndef A217175(n):\n....if n == 1:\n........return 0\n....else:\n........l, y, x = [str(d)*n for d in range(10)], 0, 1\n........for m in range(1,10**9):\n............s = str(x)\n............for k in range(10):\n................if l[k] in s:\n....................return k\n............y, x = x, y+x\n........return 'search limit reached'\n\n"}
{"sequence_id": "A217176", "text": "a(n) is the first digit (from the left) to appear n times in succession in the decimal representation of the Lucas(A217166(n)).", "sequence": "2,1,3,0,2,2,9,7,2,1,1", "code": "\ndef A217176(n):\n....if n == 1:\n........return 2\n....else:\n........l, y, x = [str(d)*n for d in range(10)], 2, 1\n........for m in range(1,10**9):\n............s = str(x)\n............for k in range(10):\n................if l[k] in s:\n....................return k\n............y, x = x, y+x\n........return 'search limit reached'\n\n"}
{"sequence_id": "A217186", "text": "a(n) is the number of digits in the decimal representation of the smallest power of 3 that contains n consecutive identical digits.", "sequence": "1,6,16,16,131,257,1014,3684,10875,51142,51142,304989", "code": "\ndef A217186(n):\n....l, x = [str(d)*n for d in range(10)], 1\n....for m in range(10**9):\n........s = str(x)\n........for k in l:\n............if k in s:\n................return len(s)\n........x *= 3\n....return 'search limit reached'\n\n"}
{"sequence_id": "A217191", "text": "a(n) is the number of digits in the decimal representation of the smallest Fibonacci number that contains n consecutive identical digits.", "sequence": "1,2,10,14,25,185,460,1357,13027,28264,73895", "code": "\ndef A217191(n):\n....if n == 1:\n........return 1\n....else:\n........l, y, x = [str(d)*n for d in range(10)], 0, 1\n........for m in range(1,10**9):\n............s = str(x)\n............for k in l:\n................if k in s:\n....................return len(s)\n............y, x = x, y+x\n........return 'search limit reached'\n\n"}
{"sequence_id": "A217192", "text": "a(n) is the number of digits in the decimal representation of the smallest Lucas number that contains n consecutive identical digits.", "sequence": "1,2,8,17,24,113,657,1346,3667,17318,68642", "code": "\ndef A217192(n):\n....if n == 1:\n........return 1\n....else:\n........l, y, x = [str(d)*n for d in range(10)], 2, 1\n........for m in range(1,10**9):\n............s = str(x)\n............for k in l:\n................if k in s:\n....................return len(s)\n............y, x = x, y+x\n........return 'search limit reached'\n\n"}
{"sequence_id": "A217291", "text": "Permutation of natural numbers arising from applying the walk of right triangular type-1 spiral (defined in A214230) to the data of square spiral (e.g. A214526).", "sequence": "1,2,4,16,5,6,7,8,9,10,27,11,3,15,35,63,36,17,18,19,20,21,22,23,24,25,26,51,84,52,28,12,14,34,62,98,142,99,64,37,38,39,40,41,42,43,44,45,46,47,48,49,50,83,124,173,125,85,53,29,13,33,61,97,141,193,253", "code": "\nSIZE = 29    \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posX:\n    walk(0, -1, 1, 0)    \n    walk(1, 0, 0, 1)     \n    walk(0, 1, -1, 0)    \n    walk(-1, 0, 0, -1)   \nimport sys\ngrid2 = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid2[posY*SIZE+posX]=1\ndef walk2(stepX, stepY, chkX, chkY):\n  global posX, posY\n  while 1:\n    a = grid[posY*SIZE+posX]\n    if a==0:\n        sys.exit(1)\n    print a,\n    posX+=stepX\n    posY+=stepY\n    grid2[posY*SIZE+posX]=1\n    if grid2[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk2(0, -1,  1,  1)    \n    walk2( 1, 1, -1,  0)    \n    if posX==SIZE-1:\n        break\n    walk2(-1, 0,  0, -1)    \n"}
{"sequence_id": "A217292", "text": "Permutation of natural numbers arising from applying the walk of right triangular type-2 spiral (defined in A214251) to the data of square spiral (e.g. A214526).", "sequence": "1,8,9,10,2,4,16,5,6,7,22,23,24,25,26,51,27,11,3,15,35,63,36,17,18,19,20,21,44,45,46,47,48,49,50,83,124,84,52,28,12,14,34,62,98,142,99,64,37,38,39,40,41,42,43,74,75,76,77,78,79,80,81,82,123,172,229", "code": "\nSIZE = 29    \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posX:\n    walk(0, -1, 1, 0)    \n    walk(1, 0, 0, 1)     \n    walk(0, 1, -1, 0)    \n    walk(-1, 0, 0, -1)   \nimport sys\ngrid2 = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid2[posY*SIZE+posX]=1\ndef walk2(stepX, stepY, chkX, chkY):\n  global posX, posY\n  while 1:\n    a = grid[posY*SIZE+posX]\n    if a==0:\n        sys.exit(1)\n    print a,\n    posX+=stepX\n    posY+=stepY\n    grid2[posY*SIZE+posX]=1\n    if grid2[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk2(-1, 0,  0, -1)    \n    walk2(0, -1,  1,  1)    \n    if posY==0:\n        break\n    walk2( 1, 1, -1,  0)    \n"}
{"sequence_id": "A217293", "text": "Permutation of natural numbers arising from applying the walk of right triangular type-3 spiral (defined in A214252) to the data of square spiral (e.g. A214526).", "sequence": "1,5,6,7,8,9,10,2,4,16,36,17,18,19,20,21,22,23,24,25,26,51,27,11,3,15,35,63,99,64,37,38,39,40,41,42,43,44,45,46,47,48,49,50,83,124,84,52,28,12,14,34,62,98,142,194,143,100,65,66,67,68,69,70,71,72", "code": "\nSIZE = 29    \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posX:\n    walk(0, -1, 1, 0)    \n    walk(1, 0, 0, 1)     \n    walk(0, 1, -1, 0)    \n    walk(-1, 0, 0, -1)   \nimport sys\ngrid2 = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid2[posY*SIZE+posX]=1\ndef walk2(stepX, stepY, chkX, chkY):\n  global posX, posY\n  while 1:\n    a = grid[posY*SIZE+posX]\n    if a==0:\n        sys.exit(1)\n    print a,\n    posX+=stepX\n    posY+=stepY\n    grid2[posY*SIZE+posX]=1\n    if grid2[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posY!=0:\n    walk2( 1, 1, -1,  0)    \n    walk2(-1, 0,  0, -1)    \n    walk2(0, -1,  1,  1)    \n"}
{"sequence_id": "A217294", "text": "Permutation of natural numbers arising from applying the walk of triangular horizontal-first spiral (defined in A214250) to the data of square spiral (e.g. A214526).", "sequence": "1,8,2,4,16,5,6,7,22,45,23,9,11,3,15,35,63,36,17,18,19,20,21,44,75,114,76,46,24,10,28,12,14,34,62,98,142,99,64,37,38,39,40,41,42,43,74,113,160,215,161,115,77,47,25,27,53,29,13,33,61,97,141,193,253", "code": "\nSIZE = 29    \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posX:\n    walk(0, -1, 1, 0)    \n    walk(1, 0, 0, 1)     \n    walk(0, 1, -1, 0)    \n    walk(-1, 0, 0, -1)   \nimport sys\ngrid2 = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid2[posY*SIZE+posX]=1\ndef walk2(stepX, stepY, chkX, chkY):\n  global posX, posY\n  while 1:\n    a = grid[posY*SIZE+posX]\n    if a==0:\n        sys.exit(1)\n    print a,\n    posX+=stepX\n    posY+=stepY\n    grid2[posY*SIZE+posX]=1\n    if grid2[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posX<SIZE-2:\n    walk2(-1, 0,  1, -1)    \n    walk2(1, -1,  1,  1)    \n    walk2(1,  1, -1,  0)    \n    walk2(-1, 0,  1, -1)    \n"}
{"sequence_id": "A217295", "text": "Permutation of natural numbers arising from applying the walk of triangular horizontal-last spiral (defined in A214226) to the data of square spiral (e.g. A214526).", "sequence": "1,5,6,7,22,8,2,4,16,36,17,18,19,20,21,44,75,45,23,9,11,3,15,35,63,99,64,37,38,39,40,41,42,43,74,113,160,114,76,46,24,10,28,12,14,34,62,98,142,194,143,100,65,66,67,68,69,70,71,72,73,112,159,214,277", "code": "\nSIZE = 29    \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posX:\n    walk(0, -1, 1, 0)    \n    walk(1, 0, 0, 1)     \n    walk(0, 1, -1, 0)    \n    walk(-1, 0, 0, -1)   \nimport sys\ngrid2 = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid2[posY*SIZE+posX]=1\ndef walk2(stepX, stepY, chkX, chkY):\n  global posX, posY\n  while 1:\n    a = grid[posY*SIZE+posX]\n    if a==0:\n        sys.exit(1)\n    print a,\n    posX+=stepX\n    posY+=stepY\n    grid2[posY*SIZE+posX]=1\n    if grid2[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile 1:\n    walk2(1,  1, -1,  0)    \n    walk2(-1, 0,  1, -1)    \n    walk2(-1, 0,  1, -1)    \n    if posX<2:\n        break\n    walk2(1, -1,  1,  1)    \n"}
{"sequence_id": "A217296", "text": "Permutation of natural numbers arising from applying the walk of rotated-square spiral (defined in A215468) to the data of square spiral (e.g. A214526).", "sequence": "1,4,6,8,2,3,15,5,19,7,23,9,11,12,14,34,16,18,40,20,22,46,24,10,28,29,13,33,61,35,17,39,69,41,21,45,77,47,25,27,53,54,30,32,60,96,62,36,38,68,106,70,42,44,76,116,78,48,26,52,86,87,55,31,59,95,139", "code": "\nSIZE = 29    \ngrid = [0] * (SIZE*SIZE)\nposX = posY = SIZE//2\ngrid[posY*SIZE+posX]=1\nn = 2\ndef walk(stepX, stepY, chkX, chkY):\n  global posX, posY, n\n  while 1:\n    posX+=stepX\n    posY+=stepY\n    grid[posY*SIZE+posX]=n\n    n+=1\n    if grid[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posX:\n    walk(0, -1, 1, 0)    \n    walk(1, 0, 0, 1)     \n    walk(0, 1, -1, 0)    \n    walk(-1, 0, 0, -1)   \ngrid2 = [0] * (SIZE*SIZE)\nposY = SIZE//2\nposX = posY+1\ngrid2[posY*SIZE+posX-1] = grid2[posY*SIZE+posX] = 1\nprint(1, end=',')\ndef walk2(stepX, stepY, chkX, chkY):\n  global posX, posY\n  while 1:\n    a = grid[posY*SIZE+posX]\n    if a==0:\n        raise ValueError\n    print(a, end=',')\n    posX+=stepX\n    posY+=stepY\n    grid2[posY*SIZE+posX]=1\n    if grid2[(posY+chkY)*SIZE+posX+chkX]==0:\n        return\nwhile posX!=SIZE-1:\n    walk2(-1,  1, -1, -1)    \n    walk2(-1, -1,  1, -1)    \n    walk2( 1, -1,  1,  0)    \n    walk2( 1,  0,  1,  1)    \n    walk2( 1,  1, -1,  1)    \n"}
{"sequence_id": "A217317", "text": "Number of primes between n^2 and n^2 + log_2(n)^2 (inclusive).", "sequence": "0,1,1,2,1,2,1,3,2,4,2,2,3,2,4,4,1,2,3,2,3,4,2,3,3,3,4,2,4,3,4,4,5,3,4,6,2,5,3,7,4,4,5,2,4,5,4,3,3,3,4,6,3,3,3,4,5,4,3,5,3,5,3,4,7,4,6,6,4,6,3,3,3,6,7,6,2,5,6,2,6,4,4,3,5,3,7", "code": "\nimport math\ndef isprime(k):\n  s = 3\n  while s*s <= k:\n    if k%s==0:  return 0\n    s+=2\n  return 1\nfor n in range(1, 333):\n  c = 0\n  top = n*n + int(math.log(n, 2)**2) + 1\nfor i in range(n*n+1, top):\n    if i&1:  c += isprime(i)\n  print str(c)+',',\n"}
{"sequence_id": "A217338", "text": "Number of inequivalent ways to color a 4 X 4 checkerboard using at most n colors allowing rotations and reflections.", "sequence": "0,1,8548,5398083,537157696,19076074375,352654485156,4154189102413,35184646816768,231628411446741,1250002537502500,5743722797690911,23110548002468928,83177110918426603,272244240093265636,821051189587805625,2305843285702230016,6082649491072763593", "code": " def A217338(n): return (n**16 + 2*n**4 + 3*n**8 + 2*n**10)/8 \n"}
{"sequence_id": "A217394", "text": "Numbers starting with 2.", "sequence": "2,20,21,22,23,24,25,26,27,28,29,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242", "code": "\ndef agen():\n  yield 2\n  digits, adder = 1, 20\n  while True:\n    for i in range(10**digits): yield adder + i\n    digits, adder = digits+1, adder*10\ng = agen()\nprint([next(g) for i in range(54)]) \n"}
{"sequence_id": "A217395", "text": "Numbers starting with 3.", "sequence": "3,30,31,32,33,34,35,36,37,38,39,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342", "code": "\ndef agen():\n  yield 3\n  digits, adder = 1, 30\n  while True:\n    for i in range(10**digits): yield adder + i\n    digits, adder = digits+1, adder*10\ng = agen()\nprint([next(g) for i in range(54)]) \n"}
{"sequence_id": "A217465", "text": "Composite integers n such that 2^n == 2 (mod n*(n+1)).", "sequence": "561,1905,4033,4681,5461,6601,8481,11305,13741,13981,16705,23377,30121,31417,41041,49141,52633,57421,88357,88561,101101,107185,121465,130561,162193,196021,196093,204001,208465,219781,266305,276013,278545,282133,285541,314821,334153,341497,390937,399001", "code": "\nfrom sympy import isprime\nA217465_list = [n for n in range(1,10**6) if pow(2,n,n*(n+1)) == 2 and not isprime(n)] \n"}
{"sequence_id": "A217466", "text": "Primes p such that 2^p == 2 (mod p*(p+1)).", "sequence": "5,13,29,37,61,73,157,181,193,277,313,397,421,457,541,613,661,673,733,757,877,997,1093,1153,1201,1213,1237,1289,1321,1381,1453,1621,1657,1753,1873,1933,1993,2017,2137,2341,2473,2557,2593,2797,2857,2917,3061", "code": "\nfrom sympy import primerange\nA217466_list = [p for p in primerange(1,10**6) if pow(2,p,p*(p+1)) == 2] \n"}
{"sequence_id": "A217565", "text": "The smallest prime p that with its successor q gives prime counts of all ten base-10 digits for the expression (q^prime(n))*(p^prime(n+1)).", "sequence": "33581,673,571,1987,915199,441799,2115761,961943,15406687,77123341,4098427,5526679,54560189,22291639,371594479,126499693,229299227,103196347,37851677,1198387109,801422893,966240103,281430131,926679973,154019941,196449137,243985993", "code": "\nfrom sympy import isprime, nextprime, prime\nfrom sympy.ntheory import count_digits\ndef a(n):\n    pn = prime(n); qn = nextprime(pn)\n    p, q = 2, 3; c = count_digits((q**pn)*(p**qn))\n    while not all(isprime(c[i]) for i in range(10)):\n        p, q = q, nextprime(q); c = count_digits((q**pn)*(p**qn))\n    return p\nprint([a(n) for n in range(1, 7)]) \n"}
{"sequence_id": "A217623", "text": "a(n) = prime(prime(n^2)).", "sequence": "3,17,83,241,509,877,1433,2063,2897,3911,4943,6353,8011,9661,11909,13693,16141,18787,21727,24781,28307,32261,35801,40093,44621,49139,54251,59417,64853,70621,77047,83617,90203,97039,103991,112097,120223,128683,136813,145903", "code": "\nfrom sympy import prime\ndef a(n): return prime(prime(n**2))\nprint([a(n) for n in range(1, 41)]) \n"}
{"sequence_id": "A217721", "text": "Number of primes between n^2 - log_2(n)^2 and n^2 (inclusive).", "sequence": "0,1,1,1,1,1,2,2,3,2,1,2,3,2,2,2,3,4,4,3,3,2,3,4,4,3,3,3,5,4,4,4,2,2,4,5,2,5,2,3,4,4,3,4,5,5,3,5,7,2,3,6,6,4,5,3,3,5,6,4,5,3,3,4,4,4,4,4,4,3,5,5,4,4,2,4,4,5,5,6,5,6,5,4,6,2,7", "code": "\nimport math\ndef isprime(k):\n  s = 3\n  while s*s <= k:\n    if k%s==0:  return 0\n    s+=2\n  return 1\nfor n in range(1, 333):\n  c = 0\n  top = n*n\nfor i in range(top - int(math.log(n, 2)**2), top):\n    if i&1:  c += isprime(i)\n  print str(c)+',',\n"}
{"sequence_id": "A217734", "text": "Primes of the form x^2 + y^3 + 1 where x and y are prime.", "sequence": "13,37,53,149,151,197,317,353,389,487,557,967,1087,1381,1453,1621,1693,1709,1861,1877,2207,2237,2293,2837,3181,3541,3607,3847,4517,4813,5167,5443,5821,6269,6367,6373,6661,6763,6869,6917,7573,7723,7949,8221,9403,9437", "code": "\nfrom sympy import isprime, primerange\ndef aupto(lim):\n    sq = list(p**2 for p in primerange(1, int(lim**(1/2))+2))\n    cb = list(p**3 for p in primerange(1, int(lim**(1/3))+2))\n    s3 = set(s for s in (a + b + 1 for a in sq for b in cb) if s <= lim)\n    return list(filter(isprime, sorted(s3)))\nprint(aupto(9999)) \n"}
{"sequence_id": "A217737", "text": "a(n) = Fibonacci(n) mod n*(n+1).", "sequence": "1,1,2,3,5,8,13,21,34,55,89,144,51,167,130,171,67,190,1,45,320,1,505,168,275,649,614,319,59,620,125,837,376,407,485,1296,1331,419,466,1435,1231,1420,1289,1653,830,2069,2161,1344,1849,1975,746,1167,1589,872,2645,2205", "code": "\nprpr, prev = 0, 1\nfor i in range(1, 333):\n    cur = prpr + prev\n    print str(prev % (i*(i+1))) + ',',\n    prpr, prev = prev, cur\n"}
{"sequence_id": "A217738", "text": "Numbers k such that Fibonacci(k) is divisible by k*(k+1).", "sequence": "60,108,180,240,540,600,660,768,1008,1200,1320,1620,1800,1860,2160,2520,2688,2736,3000,3060,3300,3360,3528,3888,4200,4800,4860,4968,5280,5520,5580,5880,6120,6480,6600,6720,6840,7320,7560,7680,8100,8208,8640,9000,9180,9240,9600", "code": "\nprpr, prev = 0, 1\nfor i in range(1, 1000):\n    cur = prpr + prev\n    a = prev % (i*(i+1))\n    if a==0:\n      print(str(i), end=', ')\n    prpr, prev = prev, cur\n"}
{"sequence_id": "A217973", "text": "Niven (or Harshad) numbers not containing the digit 0.", "sequence": "1,2,3,4,5,6,7,8,9,12,18,21,24,27,36,42,45,48,54,63,72,81,84,111,112,114,117,126,132,133,135,144,152,153,156,162,171,192,195,198,216,222,224,225,228,234,243,247,252,261,264,266,285,288,312,315,322,324,333,336", "code": "\ndef ok(n): s = str(n); return '0' not in s and n%sum(map(int, s)) == 0\nprint([k for k in range(337) if ok(k)]) \n"}
{"sequence_id": "A218013", "text": "Numbers that divide the product of the nonzero digits (in base 10) of their square.", "sequence": "1,2,3,5,6,8,28,36,42,54,75,192,216,288,486,525,648,768,864,882,1728,2160,3024,6048,6075,7056,7680,17280,18144,20736,30240,40824,56448,60480,61236,62208,64512,84672,122472,138915,150528,387072,408240,497664,622080", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom gmpy2 import t_mod, mpz\nA218013 = [n for n in range(1,10**6) if not t_mod(reduce(mul,(mpz(d) for d in str(n**2) if d != '0')),n)] \n"}
{"sequence_id": "A218035", "text": "Number of n-digit palindromes with squares that are also palindromes.", "sequence": "4,2,5,3,8,5,13,9,22,16,37,27,60,43,93,65,138,94,197,131,272,177,365,233,478,300,613,379,772,471,957,577,1170,698,1413,835,1688,989,1997,1161,2342,1352,2725,1563,3148,1795,3613,2049,4122,2326,4677,2627,5280,2953", "code": "\nfrom itertools import product\ndef ispal(n): s = str(n); return s == s[::-1]\ndef pals(n):\n  midrange = [[\"\"], [str(i) for i in range(10)]]\n  for p in product(\"0123456789\", repeat=n//2):\n    left = \"\".join(p)\n    if len(left) and left[0] == '0': continue\n    for middle in midrange[n%2]: yield left+middle+left[::-1]\ndef a(n): return sum(ispal(int(strpal)**2) for strpal in pals(n))\nprint([a(n) for n in range(1, 13)]) \n"}
{"sequence_id": "A218035", "text": "Number of n-digit palindromes with squares that are also palindromes.", "sequence": "4,2,5,3,8,5,13,9,22,16,37,27,60,43,93,65,138,94,197,131,272,177,365,233,478,300,613,379,772,471,957,577,1170,698,1413,835,1688,989,1997,1161,2342,1352,2725,1563,3148,1795,3613,2049,4122,2326,4677,2627,5280,2953", "code": "\ndef A218035(n): return 4 if n == 1 else (n**3-9*n**2+59*n-3)//24 if n % 2 else (n**3-6*n**2+32*n+48)//48 \n"}
{"sequence_id": "A218218", "text": "Table read downwards by antidiagonals: T(n,k) is the number of partitions of k into n distinct positive parts, k, n >= 0.", "sequence": "1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,2,0,0,0,0,0,0,1,2,0,0,0,0,0,0,0,1,3,1,0,0,0,0,0,0,0,1,3,1,0,0,0,0,0,0,0,0,1,4,2,0,0,0,0,0,0,0,0,0,1,4,3,0,0,0,0,0,0,0,0,0,0,1,5,4,0,0,0,0,0,0,0,0,0,0", "code": "import math; L = 10\ndef HW(x):\n..if x==0: return 0\n..return sum([ (x>>i)&1 for i in range(int(math.log(x, 2))+1) ])\ndef TW(x):\n..if x==0: return 0\n..return sum([ ((x>>i)&1)*(i+1) for i in range(int(math.log(x, 2))+1) ])\nmax_h = L+1; max_t = lambda h: L + (h-1)*h/2 + 1\nT = [None] * max_h\nfor h in range(max_h): T[h] = [0] * max_t(h)\nfor i in range(2**L):\n..h = HW(i); t = TW(i)\n..if t < max_t(h): T[h][t] = T[h][t] + 1\nfor h in range(max_h):\n..for t in range(max_t(h)): print T[h][t], ';',\n..print\n"}
{"sequence_id": "A218346", "text": "Numbers of the form a^a + b^b, with a > b > 0.", "sequence": "5,28,31,257,260,283,3126,3129,3152,3381,46657,46660,46683,46912,49781,823544,823547,823570,823799,826668,870199,16777217,16777220,16777243,16777472,16780341,16823872,17600759,387420490,387420493,387420516,387420745,387423614,387467145", "code": "\nfrom itertools import count, takewhile\ndef aupto(lim):\n  pows = list(takewhile(lambda x: x < lim, (i**i for i in count(1))))\n  sums = (aa+bb for i, bb in enumerate(pows) for aa in pows[i+1:])\n  return sorted(set(s for s in sums if s <= lim))\nprint(aupto(387467145))  \n"}
{"sequence_id": "A218828", "text": "Reluctant sequence of reverse reluctant sequence A004736.", "sequence": "1,1,2,1,2,1,1,2,1,3,1,2,1,3,2,1,2,1,3,2,1,1,2,1,3,2,1,4,1,2,1,3,2,1,4,3,1,2,1,3,2,1,4,3,2,1,2,1,3,2,1,4,3,2,1,1,2,1,3,2,1,4,3,2,1,5,1,2,1,3,2,1,4,3,2,1,5,4,1,2,1,3,2,1,4,3,2,1,5,4,3,1,2,1,3,2,1,4,3,2,1,5,4,3,2,1,2,1,3,2,1,4,3,2,1,5,4,3,2", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\nn1=n-t*(t+1)/2\nt1=int((math.sqrt(8*n1-7) - 1)/ 2)\nm=(t1*t1+3*t1+4)/2-n1\n"}
{"sequence_id": "A218890", "text": "T(n,k) = ((n + k - 1)*(n + k - 2) - (-1 + (-1)^floor((n + k)/2))*n + (1 +(-1)^floor((n + k)/2))*k)/2; n , k > 0, read by antidiagonals.", "sequence": "1,2,3,6,5,4,10,9,8,7,11,12,13,14,15,16,17,18,19,20,21,28,27,26,25,24,23,22,36,35,34,33,32,31,30,29,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,66,65,64,63,62,61,60,59,58,57,56,78", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nz=i+j\nresult=((z-1)*(z-2)-(-1+(-1)**int(z/2))*i+(1+(-1)**int(z/2))*j)/2\n"}
{"sequence_id": "A219032", "text": "Number of distinct squares as subwords of decimal representation of n-th square.", "sequence": "1,1,1,1,2,1,1,3,2,2,3,2,3,4,3,2,2,2,2,3,3,3,2,2,1,2,1,2,2,3,3,3,4,4,2,4,3,4,4,2,4,4,4,5,4,3,3,3,3,4,3,3,3,3,4,3,3,5,4,4,3,2,2,2,4,4,2,3,2,3,6,4,3,2,2,3,1,2,3,3,5,2,2,2,2,3", "code": "\nfrom sympy import integer_nthroot\ndef A219032(n):\n    s = str(n*n)\n    m = len(s)\n    return len(set(filter(lambda x: integer_nthroot(x,2)[1], (int(s[i:j]) for i in range(m) for j in range(i+1,m+1))))) \n"}
{"sequence_id": "A219043", "text": "Numbers n such that 3^n - 22 is prime.", "sequence": "3,4,9,13,28,45,46,184,285,688,697,1257,1785,2368,3721,7444,51613", "code": "\nfrom sympy import isprime\ndef ok(n): return isprime(3**n - 22)\nprint([m for m in range(700) if ok(m)]) \n"}
{"sequence_id": "A219159", "text": "Natural numbers placed in table T(n,k) layer by layer. The order of placement - at the beginning 2 layers counterclockwise, next 2 layers clockwise and so on. T(n,k) read by antidiagonals.", "sequence": "1,4,2,5,3,9,10,6,8,16,25,11,7,15,17,36,24,12,14,18,26,37,35,23,13,19,27,49,50,38,34,22,20,28,48,64,81,51,39,33,21,29,47,63,65,100,80,52,40,32,30,46,62,66,82,101,99,79,53,41,31,45,61,67,83,121", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nif j >= i:\n   result=((1+(-1)**int((j-1)/2))*(j**2-i+1)-(-1+(-1)**int((j-1)/2))*((j-1)**2 +i))/2\nelse:\n   result=((1+(-1)**(int((i-1)/2)+1))*(i**2-j+1)-(-1+(-1)**(int((i-1)/2)+1))*((i-1)**2 +j))/2\n"}
{"sequence_id": "A219219", "text": "Numbers k such that 2^k (mod k^2) is prime.", "sequence": "5,21,53,55,61,95,111,155,165,189,193,213,221,227,245,249,257,289,291,303,305,307,317,339,345,355,363,383,385,423,429,437,457,465,477,505,577,597,601,607,621,653,655,679,705,715,727,749,751,765,781,849,889,939", "code": "\nfrom sympy import isprime\ndef aupto(limit):\n  alst = []\n  for k in range(1, limit+1):\n    if isprime(pow(2, k, k*k)): alst.append(k)\n  return alst\nprint(aupto(939)) \n"}
{"sequence_id": "A219222", "text": "Numbers that can be expressed as the sum of 2 positive squares but not as the sum of 3 positive squares.", "sequence": "2,5,8,10,13,20,25,32,37,40,52,58,80,85,100,128,130,148,160,208,232,320,340,400,512,520,592,640,832,928,1280,1360,1600,2048,2080,2368,2560,3328,3712,5120,5440,6400,8192,8320,9472,10240,13312,14848,20480,21760", "code": "\nlimit = 21760\nsquares_lst = [i*i for i in range(1, int(limit**0.5)+2) if i*i <= limit]\nsquares_set = set(squares_lst)\ndef sum2squares(n):\n  for s in squares_lst:\n    if n - s in squares_set: return True\n    if n - s < 0: return False\nalst = []\nfor m in range(2, limit+1):\n  if sum2squares(m):\n    sum3 = False\n    for s in squares_lst:\n      if sum2squares(m - s): sum3 = True; break\n      if m - s < 0: break\n    if not sum3: alst.append(m)\nprint(alst) \n"}
{"sequence_id": "A219324", "text": "Positive integers n that are equal to the determinant of the circulant matrix formed by the decimal digits of n.", "sequence": "1,2,3,4,5,6,7,8,9,247,370,378,407,481,518,592,629,1360,3075,26027,26933,45018,69781,80487,154791,1920261,2137616,2716713,3100883,3480140,3934896,4179451,4830936,5218958,11955168,80651025,95738203,257059332,278945612,456790123,469135802,493827160,494376160", "code": "\nfrom sympy import Matrix\nA219324_list = []\nfor n in range(1,10**4):\n    s = [int(d) for d in str(n)]\n    m = len(s)\n    if n == Matrix(m, m, lambda i, j: s[(i-j) % m]).det():\n        A219324_list.append(n) \n"}
{"sequence_id": "A219326", "text": "Positive integers m that are equal to the determinant of the circulant matrix formed by the decimal digits of m in reverse order.", "sequence": "1,2,3,4,5,6,7,8,9,48,247,370,378,407,481,518,592,629,1547,26027,26933,45018,69781,80487,123823,289835,1920261,2137616,2716713,3100883,3480140,3934896,4179451,4830936,5218958,23203827", "code": "\nfrom sympy import Matrix\nA219326_list = []\nfor n in range(1,10**6):\n    s = [int(d) for d in str(n)][::-1]\n    m = len(s)\n    if n == Matrix(m, m, lambda i, j: s[(i-j) % m]).det():\n        A219326_list.append(n) \n"}
{"sequence_id": "A219327", "text": "Positive integers k that are equal to the absolute value of the determinant of the circulant matrix formed by the decimal digits of k.", "sequence": "1,2,3,4,5,6,7,8,9,48,247,370,378,407,481,518,592,629,1360,1547,3075,26027,26933,45018,69781,80487,123823,154791,289835,1920261,2137616,2716713,3100883,3480140,3934896,4179451,4830936,5218958,11955168,23203827,80651025,95738203", "code": "\nfrom sympy import Matrix\nA219327_list = []\nfor n in range(1,10**6):\n    s = [int(d) for d in str(n)]\n    m = len(s)\n    if n == abs(Matrix(m, m, lambda i, j: s[(i-j) % m]).det()):\n        A219327_list.append(n) \n"}
{"sequence_id": "A219531", "text": "a(n) = Sum_{k=0..11} C(n, k).", "sequence": "1,2,4,8,16,32,64,128,256,512,1024,2048,4095,8178,16278,32192,63019,121670,230964,430104,784626,1401292,2449868,4194304,7036530,11576916,18696432,29666704,46295513,71116846,107636402,160645504,236618693,344212906,494889092", "code": "\nA219531_list, m = [], [1, -9, 37, -91, 148, -166, 130, -70, 25, -5, 1, 1]\nfor _ in range(10**2):\n    A219531_list.append(m[-1])\n    for i in range(11):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A219612", "text": "Numbers k that divide the sum of the first k Fibonacci numbers (beginning with F(0)).", "sequence": "1,4,6,9,11,19,24,29,31,34,41,46,48,59,61,71,72,79,89,94,96,100,101,106,109,120,129,131,139,144,149,151,166,179,181,191,192,199,201,211,214,216,220,226,229,239,240,241,249,251,269,271,274,281,288,311", "code": "\nsum, prpr, prev = 0, 0, 1\nfor i in range(1, 1000):\n  sum += prpr\n  if sum % i == 0:  print i,\n  prpr, prev = prev, prpr+prev\n"}
{"sequence_id": "A219641", "text": "a(n) = n minus (number of 1's in Zeckendorf expansion of n).", "sequence": "0,0,1,2,2,4,4,5,7,7,8,9,9,12,12,13,14,14,16,16,17,20,20,21,22,22,24,24,25,27,27,28,29,29,33,33,34,35,35,37,37,38,40,40,41,42,42,45,45,46,47,47,49,49,50,54,54,55,56,56,58,58,59,61,61,62,63,63,66", "code": "\nfrom sympy import fibonacci\ndef a(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return str(x).count(\"1\")\nprint([n - a(n) for n in range(101)]) \n"}
{"sequence_id": "A219642", "text": "Number of steps to reach 0 starting with n and using the iterated process: x -> x - (number of 1's in Zeckendorf expansion of x).", "sequence": "0,1,2,3,3,4,4,5,6,6,7,7,7,8,8,9,9,9,10,10,10,11,11,12,12,12,13,13,13,14,14,14,15,15,16,16,17,17,17,18,18,18,19,19,19,20,20,21,21,21,22,22,22,22,23,24,24,25,25,25,26,26,26,27,27,27,28,28,29,29", "code": "\nfrom sympy import fibonacci\ndef a007895(n):\n    k=0\n    x=0\n    while n>0:\n        k=0\n        while fibonacci(k)<=n: k+=1\n        x+=10**(k - 3)\n        n-=fibonacci(k - 1)\n    return str(x).count(\"1\")\ndef a219641(n): return n - a007895(n)\nl=[0]\nfor n in range(1, 101):\n    l.append(1 + l[a219641(n)])\nprint(l) \n"}
{"sequence_id": "A219696", "text": "Numbers k such that the trajectory of 3k + 1 under the '3x + 1' map reaches k.", "sequence": "1,2,4,8,10,14,16,20,22,26,40,44,52,106,184,206,244,274,322,526,650,668,790,866,976,1154,1300,1438,1732,1780,1822,2308,2734,3238,7288", "code": "\ndef ok(n):\n    if n==1: return [1]\n    N=3*n + 1\n    l=[N, ]\n    while True:\n        if N%2==1: N = 3*N + 1\n        else: N/=2\n        l+=[N, ]\n        if N<2: break\n    if n in l: return 1\n    return 0 \n"}
{"sequence_id": "A219835", "text": "Number of terms of 2^j + 3^k <= 10^n.", "sequence": "7,29,64,118,181,254,354,453,565,708,878,1033,1224,1403,1594,1828,2046,2274,2553,2808,3139,3467,3765,4073,4443,4779,5124,5537,5911,6294,6690,7266,7693,8129,8650,9114,9588,10153,10654,11167,11776,12449,13005,13662,14243", "code": "\ndef a(n):\n    s, pow3, lim = set(), 1, 10**n\n    while pow3 < lim:\n        for j in range((lim-pow3).bit_length()):\n            s.add(2**j + pow3)\n        pow3 *= 3\n    return len(s)\nprint([a(n) for n in range(1, 46)]) \n"}
{"sequence_id": "A220161", "text": "a(n) = 1 + 2^(2^n) + 2^(2^(n+1)).", "sequence": "7,21,273,65793,4295032833,18446744078004518913,340282366920938463481821351505477763073,115792089237316195423570985008687907853610267032561502502920958615344897851393", "code": "\ndef a(n): return 1 + 2**(2**n) + 2**(2**(n+1))\nprint([a(n) for n in range(8)]) \n"}
{"sequence_id": "A220168", "text": "Numbers k that divide Fibonacci(k+2).", "sequence": "1,4,34,46,88,94,106,166,214,226,274,334,346,394,454,466,514,526,586,634,646,694,706,754,766,886,934,1006,1114,1126,1174,1186,1234,1294,1306,1354,1366,1486,1546,1594,1654,1714,1726,1774,1894,1906,1954,1966,2026", "code": "\nprpr = prev = 1\nfor i in range(3, 3000):\n    prpr, prev = prev, prpr+prev\n    if prev % (i-2) == 0:  print i-2,\n"}
{"sequence_id": "A220236", "text": "Binary palindromic numbers with only two 0 bits, both in the middle.", "sequence": "9,51,231,975,3999,16191,65151,261375,1047039,4191231,16771071,67096575,268410879,1073692671,4294868991,17179672575,68719083519,274877120511,1099510054911,4398043365375,17592179752959,70368731594751,281474951544831,1125899856510975", "code": "\nfor n in range(1,77):\n    print (2**(2*n+2)-2**n-2**(n+1)-1),\n"}
{"sequence_id": "A220280", "text": "Reluctant sequence of reluctant sequence A002260.", "sequence": "1,1,1,1,1,2,1,1,2,1,1,1,2,1,2,1,1,2,1,2,3,1,1,2,1,2,3,1,1,1,2,1,2,3,1,2,1,1,2,1,2,3,1,2,3,1,1,2,1,2,3,1,2,3,4,1,1,2,1,2,3,1,2,3,4,1,1,1,2,1,2,3,1,2,3,4,1,2,1,1,2,1,2,3,1,2,3", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\nn1=n-t*(t+1)/2\nt1=int((math.sqrt(8*n1-7) - 1)/ 2)\na=n1-t1*(t1+1)/2\n"}
{"sequence_id": "A220415", "text": "Table T(n,k)= floor(n/k)+ floor(k/n), n,k >0 read by antidiagonals.", "sequence": "2,2,2,3,2,3,4,1,1,4,5,2,2,2,5,6,2,1,1,2,6,7,3,1,2,1,3,7,8,3,2,1,1,2,3,8,9,4,2,1,2,1,2,4,9,10,4,2,1,1,1,1,2,4,10,11,5,3,2,1,2,1,2,3,5,11", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\na = n-t*(t+1)/2\nb= (t*t+3*t+4)/2-n\nm= int(a/b)+int(b/a)\n"}
{"sequence_id": "A220416", "text": "Table T(n,k) = ((n+k-1)*(n+k-2)/2+n)^n, n,k >0 read by antidiagonals.", "sequence": "1,2,9,4,25,216,7,64,729,10000,11,144,2197,38416,759375,16,289,5832,130321,3200000,85766121,22,529,13824,390625,11881376,387420489,13492928512,29,900,29791,1048576,39135393,1544804416,64339296875,2821109907456", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\nm=n**(n-t*(t+1)/2)\n"}
{"sequence_id": "A220417", "text": "Table T(n,k) = k^n - n^k, n, k > 0, read by descending antidiagonals.", "sequence": "0,1,-1,2,0,-2,3,1,-1,-3,4,0,0,0,-4,5,-7,-17,17,7,-5,6,-28,-118,0,118,28,-6,7,-79,-513,-399,399,513,79,-7,8,-192,-1844,-2800,0,2800,1844,192,-8,9,-431,-6049,-13983,-7849,7849,13983,6049,431,-9,10,-924,-18954,-61440,-61318,0,61318,61440,18954,924,-10", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\nm=((t*t+3*t+4)/2-n)**(n-t*(t+1)/2)-(n-t*(t+1)/2)**((t*t+3*t+4)/2-n)\n"}
{"sequence_id": "A220442", "text": "a(n) = 3^n + 6^n + 9^n + 12^n.", "sequence": "4,30,270,2700,28674,315900,3564810,40896900,474714594,5557298220,65464673850,774752404500,9200707298514,109548133495740,1306873625950890,15613382906014500,186740100236842434,2235305215228688460,26773529476526331930,320831460449198190900,3845921314068458898354", "code": "\ndef a(n): return 3**n + 6**n + 9**n + 12**n\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A220464", "text": "Reverse reluctant sequence of reluctant sequence A002260.", "sequence": "1,1,1,2,1,1,1,2,1,1,2,1,2,1,1,3,2,1,2,1,1,1,3,2,1,2,1,1,2,1,3,2,1,2,1,1,3,2,1,3,2,1,2,1,1,4,3,2,1,3,2,1,2,1,1,1,4,3,2,1,3,2,1,2,1,1,2,1,4,3,2,1,3,2,1,2,1,1,3,2,1,4,3,2,1,3,2,1,2,1,1,4,3,2,1,4,3,2,1,3,2,1,2,1,1,5,4,3,2,1,4,3,2,1,3,2,1,2,1,1,1,5,4,3", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\nn1=(t*t+3*t+4)/2-n\nt1=int((math.sqrt(8*n1-7) - 1)/ 2)\nm=n1-t1*(t1+1)/2\n"}
{"sequence_id": "A220465", "text": "Reverse reluctant sequence of reverse reluctant sequence A004736.", "sequence": "1,2,1,1,2,1,3,1,2,1,2,3,1,2,1,1,2,3,1,2,1,4,1,2,3,1,2,1,3,4,1,2,3,1,2,1,2,3,4,1,2,3,1,2,1,1,2,3,4,1,2,3,1,2,1,5,1,2,3,4,1,2,3,1,2,1,4,5,1,2,3,4,1,2,3,1,2,1,3,4,5,1,2,3,4,1,2,3,1,2,1,2,3,4,5,1,2,3,4,1,2,3,1,2,1,1,2,3,4,5,1,2,3,4,1,2,3,1,2,1,6,1,2,3", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\nn1=(t*t+3*t+4)/2-n\nt1=int((math.sqrt(8*n1-7) - 1)/ 2)\nm=(t1*t1+3*t1+4)/2-n1\n"}
{"sequence_id": "A220556", "text": "Table T(n,k) = ((n+k-1)*(n+k-2)/2+n)^k, n,k >0 read by antidiagonals.", "sequence": "1,4,3,64,25,6,2401,512,81,10,161051,20736,2197,196,15,16777216,1419857,104976,6859,400,21,2494357888,148035889,7962624,390625,17576,729,28,500246412961,21870000000,887503681,33554432,1185921,39304,1225,36", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\nm=n**((t*t+3*t+4)/2-n)\n"}
{"sequence_id": "A220603", "text": "First inverse function (numbers of rows) for pairing function A081344.", "sequence": "1,2,2,1,1,2,3,3,3,4,4,4,4,3,2,1,1,2,3,4,5,5,5,5,5,6,6,6,6,6,6,5,4,3,2,1,1,2,3,4,5,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,7,6,5,4,3,2,1,1,2,3,4,5,6,7,8,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,9,8,7,6,5,4,3,2,1", "code": "\nt=int(math.sqrt(n-1))+1\ni=(t % 2)*min(t,n-(t-1)**2) + ((t+1) % 2)*min(t,t**2-n+1)\n"}
{"sequence_id": "A220604", "text": "Second inverse function (numbers of columns) for pairing function A081344.", "sequence": "1,1,2,2,3,3,3,2,1,1,2,3,4,4,4,4,5,5,5,5,5,4,3,2,1,1,2,3,4,5,6,6,6,6,6,6,7,7,7,7,7,7,7,6,5,4,3,2,1,1,2,3,4,5,6,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,8,7,6,5,4,3,2,1,1,2,3,4,5,6,7,8,9,10,10,10,10,10,10,10,10,10,10", "code": "\nt=int(math.sqrt(n-1))+1\nj=(t % 2)*min(t,t**2-n+1) + ((t+1) % 2)*min(t,n-(t-1)**2)\n"}
{"sequence_id": "A220627", "text": "Prime numbers that are not Brazilian.", "sequence": "2,3,5,11,17,19,23,29,37,41,47,53,59,61,67,71,79,83,89,97,101,103,107,109,113,131,137,139,149,151,163,167,173,179,181,191,193,197,199,223,227,229,233,239,251,257,263,269,271,277,281,283,293,311,313,317", "code": "\nfrom sympy.ntheory.factor_ import digits\nfrom sympy import isprime, primerange\ndef B(n):\n    l=[]\n    for b in range(2, n - 1):\n        d=digits(n, b)[1:]\n        if max(d)==min(d): l.append(n)\n    return l\nprint([n for n in primerange(2, 1001) if not B(n)]) \n"}
{"sequence_id": "A220689", "text": "Triangular numbers generated in A224218. That is, the triangular numbers generated by the operation triangular(i) XOR triangular(i+1) along increasing i.", "sequence": "1,21,21,105,105,105,105,946,946,666,1653,666,1378,946,1225,946,4005,1378,4005,1378,7381,1225,1378,1653,2485,4005,31125,4005,4005,4005,2485,13861,13861,5356,4005,7381,5356,5356,7381,4005,5356,29161,12561,12561,4186,4186,4186,4186", "code": "\ndef rootTriangular(a):\n    sr = 1<<33\n    while a < sr*(sr+1)//2:\n      sr>>=1\n    b = sr>>1\n    while b:\n        s = sr+b\n        if a >= s*(s+1)//2:\n          sr = s\n        b>>=1\n    return sr\nfor i in range(1<<12):\n        s = (i*(i+1)//2) ^ ((i+1)*(i+2)//2)\n        t = rootTriangular(s)\n        if s == t*(t+1)//2:\n            print(str(s), end=',')\n"}
{"sequence_id": "A220698", "text": "Indices of triangular numbers generated in A224218.", "sequence": "1,6,6,14,14,14,14,43,43,36,57,36,52,43,49,43,89,52,89,52,121,49,52,57,70,89,249,89,89,89,70,166,166,103,89,121,103,103,121,89,103,241,158,158,91,91,91,91,241,166,166,103,121,103,103,121,103,121,225,225,497,216,334", "code": "\ndef rootTriangular(a):\n    sr = 1<<33\n    while a < sr*(sr+1)//2:\n      sr>>=1\n    b = sr>>1\n    while b:\n        s = sr+b\n        if a >= s*(s+1)//2:\n          sr = s\n        b>>=1\n    return sr\nfor i in range(1<<12):\n        s = (i*(i+1)//2) ^ ((i+1)*(i+2)//2)\n        t = rootTriangular(s)\n        if s == t*(t+1)//2:\n            print(str(t), end=',')\n"}
{"sequence_id": "A221018", "text": "Number n such that Fibonacci(n) is divisible by n, n + 1 and n - 1.", "sequence": "108,2688,3528,4968,6480,15288,18048,20808,21000,25308,35448,47520,62928,68208,81648,82008,97608,103968,108288,116928,137088,139968,151848,162288,196560,197568,200928,235008,238728,253368,278208,363888,379008,400248,444528,449568,457608", "code": "\nprpr, prev = 0, 1\nfor n in range(2, 100000):\n    prpr, prev = prev, prpr+prev\n    if n%2: continue\n    if (prev % n, prev % (n-1), prev % (n+1)) == (0, 0, 0):\n        print(n, end=\", \")\n"}
{"sequence_id": "A221158", "text": "Fibonacci numbers with two 1's in the binary representation.", "sequence": "3,5,34,144", "code": "\nprev = 0\ncurr = 1\nfor n in range(3000000):\n  c = 0         \n  p = 1\n  while p<=prev:\n    c += ((prev & p) > 0)\n    if c>2:\n      break\n    p += p\n  if n&1023==0:\n    print '.',\n  if c==2:\n    print prev,\n  prev, curr = curr, prev+curr\n"}
{"sequence_id": "A221215", "text": "T(n,k)= ((n+k)^2-2*(n+k)+4-(n+3*k-2)*(-1)^(n+k))/2; n , k > 0, read by antidiagonals.", "sequence": "1,6,5,2,3,4,15,14,13,12,7,8,9,10,11,28,27,26,25,24,23,16,17,18,19,20,21,22,45,44,43,42,41,40,39,38,29,30,31,32,33,34,35,36,37,66,65,64,63,62,61,60,59,58,57,46,47,48,49,50,51,52,53,54,55,56,91", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=((t+2)**2-2*(t+2)+4-(i+3*j-2)*(-1)**t)/2\n"}
{"sequence_id": "A221216", "text": "T(n,k)= ((n+k)^2-2*(n+k)+4-(3*n+k-2)*(-1)^(n+k))/2; n , k > 0, read by antidiagonals.", "sequence": "1,5,6,4,3,2,12,13,14,15,11,10,9,8,7,23,24,25,26,27,28,22,21,20,19,18,17,16,38,39,40,41,42,43,44,45,37,36,35,34,33,32,31,30,29,57,58,59,60,61,62,63,64,65,66,56,55,54,53,52,51,50,49,48,47,46,80", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=((t+2)**2-2*(t+2)+4-(3*i+j-2)*(-1)**t)/2\n"}
{"sequence_id": "A221217", "text": "T(n,k) = ((n+k)^2-2*n+3-(n+k-1)*(1+2*(-1)^(n+k)))/2; n , k > 0, read by antidiagonals.", "sequence": "1,6,5,4,3,2,15,14,13,12,11,10,9,8,7,28,27,26,25,24,23,22,21,20,19,18,17,16,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,91", "code": "\nt=int((math.sqrt(8*n-7) - 1)/ 2)\ni=n-t*(t+1)/2\nj=(t*t+3*t+4)/2-n\nresult=((t+2)**2-2*i+3-(t+1)*(1+2*(-1)**t))/2\n"}
{"sequence_id": "A221220", "text": "Numbers with more than one prime factor such that concatenation of its prime factors (without multiplicity) is a prime.", "sequence": "6,12,18,21,22,24,33,36,39,44,46,48,51,54,58,63,66,70,72,82,88,92,93,96,99,108,111,115,116,117,132,133,140,141,142,144,147,153,154,159,162,164,165,166,176,177,182,184,187,189,192,198,201,205,210,216,219", "code": "\nfrom sympy import isprime, primefactors\ndef ok(n):\n    pf = primefactors(n)\n    if len(pf) < 2: return False\n    return isprime(int(\"\".join(str(p) for p in pf)))\nprint(list(filter(ok, range(2, 220)))) \n"}
{"sequence_id": "A221643", "text": "Numbers k such that k^2 XOR (k+1)^2 is a square, where XOR is the bitwise XOR operator.", "sequence": "0,3,4,23,24,43,44,76,111,112,115,139,164,180,183,248,264,323,327,348,411,479,480,499,611,699,747,787,943,976,1072,1103,1111,1176,1268,1388,1447,1576,1684,1851,1983,1984,2008,2243,2692,3271,3383,3452,3464,3532,3679,3804,3867", "code": "\nimport math\nfor i in range(1<<16):\n    s = (i*i) ^ ((i+1)*(i+1))\n    t = int(math.sqrt(s))\n    if s == t*t:\n        print(str(i), end=',')\n"}
{"sequence_id": "A221697", "text": "Numbers n such that largest digit of all divisors of n is 2.", "sequence": "2,22,121,202,211,1021,1201,2011,2111,2221,2222,10201,10211,12011,12101,12211,12221,20011,20021,20101,20201,20222,21001,21011,21101,21121,21211,21221,22111,22121,101021,101221,102001,102101,102121,110221,111121,111211,111221,112111,112121", "code": "\nfrom sympy import divisors\ndef ok(n): return '2' == max(\"\".join(map(str, divisors(n))))\nprint([m for m in range(1, 112122) if ok(m)]) \n"}
{"sequence_id": "A221714", "text": "Numbers written in base 2 with digits rearranged to be in decreasing order.", "sequence": "0,1,10,11,100,110,110,111,1000,1100,1100,1110,1100,1110,1110,1111,10000,11000,11000,11100,11000,11100,11100,11110,11000,11100,11100,11110,11100,11110,11110,11111,100000,110000,110000,111000,110000", "code": "\ndef a(n):\n     return \"\".join(sorted(bin(n)[2:],reverse=True)) \n"}
{"sequence_id": "A222029", "text": "Triangle of number of functions in a size n set for which the sequence of composition powers ends in a length k cycle.", "sequence": "1,1,3,1,16,9,2,125,93,32,6,1296,1155,480,150,24,20,16807,17025,7880,3240,864,840,262144,292383,145320,71610,24192,26250,720,0,0,504,0,420,4782969,5752131,3009888,1692180,653184,773920,46080,5040,0,32256,0,26880,0,0,2688", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial, Symbol, lcm, factorial as f, Poly, flatten\nx=Symbol('x')\n@cacheit\ndef b(n, m): return x**m if n==0 else sum([f(j - 1)*b(n - j, lcm(m, j))*binomial(n - 1, j - 1) for j in range(1, n + 1)])\ndef T(n): return Poly(sum([b(j, 1)*n**(n - j)*binomial(n - 1, j - 1) for j in range(n + 1)]),x).all_coeffs()[::-1][1:]\nprint([T(n) for n in range(11)]) \n"}
{"sequence_id": "A222118", "text": "Number of terms in Collatz (3x+1) trajectory of n that did not appear in previous trajectories.", "sequence": "1,1,6,0,0,1,10,0,3,0,0,1,0,0,9,0,0,1,5,0,3,0,0,1,3,0,95,0,0,1,0,0,3,0,0,1,3,0,12,0,0,1,8,0,3,0,0,1,0,0,5,0,0,1,7,0,3,0,0,1,0,0,13,0,0,1,0,0,3,0,0,1,3,0,8,0,0,1,9,0,1,0,0,1,0,0,7", "code": "\ns = set([1])\nprint(1)\nfor n in range(2, 100):\n    m, r = n, 0\n    while m not in s:\n        s.add(m)\n        m = (m//2 if m%2==0 else 3*m+1)\n        r += 1\n    print(r)\n\n"}
{"sequence_id": "A222251", "text": "In the number n, replace all (decimal) digits '6' with '9' and vice versa.", "sequence": "0,1,2,3,4,5,9,7,8,6,10,11,12,13,14,15,19,17,18,16,20,21,22,23,24,25,29,27,28,26,30,31,32,33,34,35,39,37,38,36,40,41,42,43,44,45,49,47,48,46,50,51,52,53,54,55,59,57,58,56,90,91,92,93,94,95,99,97,98,96,70,71,72,73,74,75", "code": "\ndef flp69(s): return s.replace(\"6\", \"-\").replace(\"9\", \"6\").replace(\"-\", \"9\")\ndef aupto(lim): return [int(flp69(s)) for s in map(str, range(lim+1))]\nprint(aupto(75)) \n"}
{"sequence_id": "A222423", "text": "Sum of (n AND k) for k = 0, 1, 2, ..., n, where AND is the bitwise AND operator.", "sequence": "0,1,2,6,4,11,18,28,8,21,34,50,60,79,98,120,16,41,66,94,116,147,178,212,216,253,290,330,364,407,450,496,32,81,130,182,228,283,338,396,424,485,546,610,668,735,802,872,816,889,962,1038,1108,1187,1266,1348,1400", "code": "\nfor n in range(99):\n    s = 0\n    for k in range(n+1):\n        s += n & k\n    print(s, end=\",\")\n"}
{"sequence_id": "A222559", "text": "a(0) = 0. If n is odd, a(n) = a(n-1) * n, otherwise a(n) = a(n-1) + n.", "sequence": "0,0,2,6,10,50,56,392,400,3600,3610,39710,39722,516386,516400,7746000,7746016,131682272,131682290,2501963510,2501963530,52541234130,52541234152,1208448385496,1208448385520,30211209638000,30211209638026,815702660226702,815702660226730", "code": "\na=0\nfor n in range(1,33):\n    print(a, end=',')\n    if n&1:\n        a *= n\n    else:\n        a += n\n"}
{"sequence_id": "A222810", "text": "Number of n-digit numbers N with distinct digits such that the reversal of N divides N.", "sequence": "9,9,3,5,3,2,0,0,0", "code": "\nimport collections\ncol = []\ncount = 0\nfor n in range(0,9):\n....a = 10**n\n....stop = 10**(n+1)\n....while a < stop:\n........b = str(a)\n........c = list(b)\n........d = c[::-1]\n........e = int(\"\".join(c))\n........f = int(\"\".join(d))\n........counter = collections.Counter(c)\n........if e % f == 0 and counter.most_common(1)[0][1] == 1:\n............count += 1\n............col.append(a)\n........a += 1\n....print(n+1,\" digits: \",count,\" elements: \",col)\n....count = 0\n....col = []\n\n"}
{"sequence_id": "A224212", "text": "Number of nonnegative solutions to x^2 + y^2 <= n.", "sequence": "1,3,4,4,6,8,8,8,9,11,13,13,13,15,15,15,17,19,20,20,22,22,22,22,22,26,28,28,28,30,30,30,31,31,33,33,35,37,37,37,39,41,41,41,41,43,43,43,43,45,48,48,50,52,52,52,52,52,54,54,54,56,56,56,58,62,62,62,64", "code": "\nfor n in range(99):\n  k = 0\n  for x in range(99):\n    s = x*x\n    if s>n: break\n    for y in range(99):\n        sy = s + y*y\n        if sy>n: break\n        k+=1\n  print(str(k), end=', ')\n"}
{"sequence_id": "A224213", "text": "Number of nonnegative solutions to x^2 + y^2 + z^2 + u^2 <= n.", "sequence": "1,5,11,15,20,32,44,48,54,70,88,100,108,124,148,160,165,189,219,235,253,281,305,317,329,357,399,427,439,475,523,539,545,581,623,659,688,716,764,792,810,858,918,946,970,1030,1078,1102,1110,1154,1226,1274,1304,1352", "code": "\nfor n in range(99):\n  k = 0\n  for x in range(99):\n    s = x*x\n    if s>n: break\n    for y in range(99):\n        sy = s + y*y\n        if sy>n: break\n        for z in range(99):\n            sz = sy + z*z\n            if sz>n: break\n            for u in range(99):\n              su = sz + u*u\n              if su>n: break\n              k+=1\n  print(str(k), end=', ')\n"}
{"sequence_id": "A224214", "text": "Number of nonnegative solutions to x^3 + y^3 <= n^3.", "sequence": "1,3,6,11,18,26,37,50,63,80,96,115,136,159,186,210,239,268,301,336,368,407,444,487,526,574,619,664,717,764,820,875,930,989,1047,1112,1175,1238,1307,1375,1444,1521,1592,1669,1745,1828,1907,1988,2073,2161,2252", "code": "\nfor a in range(99):\n  n = a*a*a\n  k = 0\n  for x in range(99):\n    s = x*x*x\n    if s>n: break\n    for y in range(99):\n        sy = s + y*y*y\n        if sy>n: break\n        k+=1\n  print(str(k), end=',')\n"}
{"sequence_id": "A224215", "text": "Number of nonnegative solutions to x^3 + y^3 + z^3 <= n^3.", "sequence": "1,4,11,30,66,115,200,302,441,619,829,1085,1395,1771,2200,2666,3228,3843,4564,5351,6185,7143,8158,9349,10526,11934,13375,14896,16652,18381,20370,22411,24629,26963,29406,32101,34840,37766,40920,44164,47587,51200", "code": "\nfor a in range(99):\n  n = a*a*a\n  k = 0\n  for x in range(99):\n    s = x*x*x\n    if s>n: break\n    for y in range(99):\n        sy = s + y*y*y\n        if sy>n: break\n        for z in range(99):\n            sz = sy + z*z*z\n            if sz>n: break\n            k+=1\n  print(str(k),end=',')\n"}
{"sequence_id": "A224218", "text": "Indices of XOR-positive triangular numbers. That is, numbers n such that triangular(n) XOR triangular(n+1) is a triangular number, where XOR is the bitwise logical XOR operator.", "sequence": "0,12,18,24,40,86,102,177,333,357,628,665,669,689,840,845,860,861,1124,1185,1196,1206,1377,1418,1706,1890,1906,1956,2138,2204,2388,2524,2588,2843,2970,2994,3035,3107,3154,3234,3299,3606,3824,3854,4005,4021,4169,4185,4568,4580", "code": "\ndef rootTriangular(a):\n    sr = 1<<33\n    while a < sr*(sr+1)//2:\n      sr>>=1\n    b = sr>>1\n    while b:\n        s = sr+b\n        if a >= s*(s+1)//2:\n          sr = s\n        b>>=1\n    return sr\nfor i in range(1<<12):\n        s = (i*(i+1)//2) ^ ((i+1)*(i+2)//2)\n        t = rootTriangular(s);\n        if s == t*(t+1)//2:\n            print(str(i), end=',')\n"}
{"sequence_id": "A224252", "text": "Nonpalindromic n such that the factorizations of n and its digital reverse differ only for the exponents order.", "sequence": "277816,618772,14339143,34193341,1125355221,1225535211,2613391326,6231933162,26157457326,62375475162,100504263021,102407325111,111523704201,120362405001,144326261443,275603902756,277816277816,344162623441,392739273927,392875758639", "code": "\nfrom sympy import primefactors, factorint\nA224252 = [n for n in range(1,10**6) if n != int(str(n)[::-1]) and primefactors(n) == primefactors(int(str(n)[::-1])) and sorted(factorint(n).values()) == sorted(factorint(int(str(n)[::-1])).values())] \n"}
{"sequence_id": "A224254", "text": "Full cycle lengths in the Collatz (3x+1) problem when the negative integers are used.", "sequence": "2,2,2,2,5,2,5,2,5,5,2,2,5,5,2,2,18,5,5,5,18,2,18,2,18,5,5,5,2,2,18,2,18,18,5,5,18,5,2,5,18,18,2,2,18,18,5,2,18,18,5,5,2,5,18,5,2,2,2,2,18,18,5,2,2,18,18,18,2,5,2,5,18,18,5,5,2,2,2,5,5", "code": "\nimport sympy\ndef A224254(n):\n  return next(sympy.cycle_length(lambda x:3*x+1 if x%2 else x//2,-n))[0] \n"}
{"sequence_id": "A224326", "text": "Number of partitions of n into 3 distinct triangular numbers.", "sequence": "0,0,0,0,1,0,0,1,0,1,1,1,0,1,1,0,2,1,1,2,0,1,2,0,2,2,1,1,2,1,1,3,2,0,2,1,1,4,1,3,1,1,2,2,2,1,4,1,1,4,1,2,4,1,2,2,2,2,3,2,2,4,1,2,3,2,3,4,1,2,4,2,3,3,2,1,5,2,0,5,1,4,5,2,4,2,2", "code": "\nTOP = 777\nfor n in range(TOP):\n  k = 0\n  for x in range(TOP):\n    s = x*(x+1)//2\n    if s>n: break\n    for y in range(x+1,TOP):\n        sy = s + y*(y+1)//2\n        if sy>n: break\n        for z in range(y+1,TOP):\n          sz = sy + z*(z+1)//2\n          if sz>n: break\n          if sz==n: k+=1\n  print(str(k), end=',')\n"}
{"sequence_id": "A224362", "text": "Number of partitions of n into a prime and a triangular number.", "sequence": "0,0,1,2,1,2,2,1,3,1,1,2,2,3,2,1,1,4,2,2,3,1,2,4,2,1,3,1,2,3,2,2,4,2,3,2,0,2,4,3,2,4,1,3,4,1,2,6,2,2,3,2,3,4,1,1,3,3,4,4,2,1,6,1,3,3,1,3,6,3,1,4,2,4,6,1,3,4,1,4,3,3,4,5,2,3,4", "code": "\nimport math\nprimes = [2]*2\nprimes[1] = 3\ndef isprime(k):\n  for p in primes:\n    if k%p==0:  return 0\n  primes.append(k)\n  return 1\ndef rootTriangular(a):\n    sr = 2**(int(math.log(a,2))+2)\n    while a < sr*(sr+1)/2:\n          sr>>=1\n    b = sr>>1\n    while b:\n      s = sr+b\n      if a >= s*(s+1)/2:\n        sr = s\n      b>>=1\n    return sr\nfor i in range(1L<<10):\n    k = 0\n    for p in primes:\n      if i <= p:  continue\n      r = rootTriangular(i - p)\n      if r*(r+1)/2 == i-p:  k+=1\n    if i>1:\n      if i<=3:  k += 1\n      else:     k += isprime(i)\n    print str(k)+',',\n"}
{"sequence_id": "A224419", "text": "Numbers n such that triangular(n) + triangular(2*n) is a square.", "sequence": "0,1,25,216,1849,36481,311904,2666689,52606009,449765784,3845364121,75857828929,648561949056,5545012396225,109386936710041,935225880773400,7995904029992761,157735886878050625,1348595071513294176,11530088066237165569,227455039491212291641,1944673157896289428824,16626378995609962758169,327990009210441246496129", "code": "\nimport math\nfor i in range(1L<<30):\n        s = i*(i+1)/2 + i*(2*i+1)\n        t = int(math.sqrt(s))\n        if s == t*t:  print i,\n"}
{"sequence_id": "A224511", "text": "Roots of squares generated in A221643. That is, S = i^2 XOR (i+1)^2; increment i; if S is a square then square root of S is appended to a(n). Initially i=0. XOR is the binary logical exclusive-or operator.", "sequence": "1,5,3,9,7,13,11,21,17,15,43,45,29,19,41,25,23,59,39,27,35,33,31,85,37,61,51,53,47,81,79,49,55,121,83,75,57,73,77,67,65,63,71,69,125,89,87,123,105,107,95,101,163,93,91,99,97,349,243,103,169,109,233,115,119,171", "code": "\nimport math\nfor i in range(1<<16):\n    s = (i*i) ^ ((i+1)*(i+1))\n    r = int(math.sqrt(s));\n    if s == r*r:\n        print str(r)+',',\n"}
{"sequence_id": "A224515", "text": "a(n) = least k such that sqrt(k^2 XOR (k+1)^2) = 2*n+1, a(n) = -1 if there is no such k.", "sequence": "0,4,3,24,23,44,43,112,111,180,76,264,248,348,164,480,479,411,611,327,183,115,139,943,1103,747,787,1111,1447,323,699,1984,1983,1851,2243,2008,1576,1388,1684,1072,976,1268,499,3383,3271,4124,4068,3679,4511,4315,3804,4999", "code": "\nimport math\nneedTerms = n = 1024\ni = 0\nterms = [-1] * n\nwhile n:\n  s = (i*i) ^ ((i+1)*(i+1))\n  r = int(math.sqrt(s))\n  if s == r*r:\n    if (r&1)==0:  break\n    r = (r-1)/2\n    if r < needTerms:\n        if terms[r] >= 0:  break\n        terms[r] = i\n        n -= 1\n  i += 1\nif n:  print 'Error'\nelse:\n  for i in range(needTerms):\n    t = terms[i]\n    print str(t)+', ',  \n"}
{"sequence_id": "A224520", "text": "Numbers a(n) with property a(n) + a(n+4) = 2^(n+4) - 1 = A000225(n+4).", "sequence": "0,1,3,7,15,30,60,120,240,481,963,1927,3855,7710,15420,30840,61680,123361,246723,493447,986895,1973790,3947580,7895160,15790320,31580641,63161283,126322567,252645135,505290270,1010580540", "code": " print([2**(n+4)//17 for n in range(31)]) \n"}
{"sequence_id": "A224521", "text": "Numbers a(n) with property a(n) + a(n+5) = 2^(n+5) - 1 = A000225(n+5).", "sequence": "0,1,3,7,15,31,62,124,248,496,992,1985,3971,7943,15887,31775,63550,127100,254200,508400,1016800,2033601,4067203,8134407,16268815,32537631,65075262,130150524,260301048,520602096,1041204192,2082408385,4164816771,8329633543", "code": " print([2**(n+5)//33 for n in range(31)]) \n"}
{"sequence_id": "A224694", "text": "Numbers n such that n^2 AND n = 0, where AND is the bitwise logical AND operator.", "sequence": "0,2,4,8,10,12,16,18,24,26,32,34,36,40,44,48,50,56,64,66,68,76,80,90,96,98,100,108,112,128,130,132,136,138,144,146,152,160,164,168,176,184,192,194,196,208,224,228,240,256,258,260,264,266,268,280,282,288,290,296,312", "code": "\nfor i in range(333):\n    if ((i*i) & i)==0:\n      print str(i)+',',\n"}
{"sequence_id": "A224869", "text": "a(n) = n*( a(n-1)+1 ), initialized by a(1) = -1.", "sequence": "-1,0,3,16,85,516,3619,28960,260649,2606500,28671511,344058144,4472755885,62618582404,939278736075,15028459777216,255483816212689,4598708691828420,87375465144739999,1747509302894800000,36697695360790800021,807349297937397600484", "code": "\na=-1\nfor n in range(2,24):\n  print str(a)+',',\n  a= n*(a+1)\n"}
{"sequence_id": "A224915", "text": "a(n) = Sum_{k=0..n} n XOR k where XOR is the bitwise logical exclusive-or operator.", "sequence": "0,1,5,6,22,23,27,28,92,93,97,98,114,115,119,120,376,377,381,382,398,399,403,404,468,469,473,474,490,491,495,496,1520,1521,1525,1526,1542,1543,1547,1548,1612,1613,1617,1618,1634,1635,1639,1640,1896,1897,1901,1902,1918", "code": "\nfor n in range(59):\n    s = 0\n    for k in range(n):  s += n ^ k\n    print(s, end=',')\n"}
{"sequence_id": "A224923", "text": "Sum_{i=0..n} Sum_{j=0..n} (i XOR j), where XOR is the binary logical exclusive-or operator.", "sequence": "0,2,12,24,68,114,168,224,408,594,788,984,1212,1442,1680,1920,2672,3426,4188,4952,5748,6546,7352,8160,9096,10034,10980,11928,12908,13890,14880,15872,18912,21954,25004,28056,31140,34226,37320,40416,43640,46866,50100,53336,56604", "code": "\nfor n in range(99):\n    s = 0\n    for i in range(n+1):\n        for j in range(n+1):\n            s += i ^ j\n    print(s, end=\",\") \n"}
{"sequence_id": "A224923", "text": "Sum_{i=0..n} Sum_{j=0..n} (i XOR j), where XOR is the binary logical exclusive-or operator.", "sequence": "0,2,12,24,68,114,168,224,408,594,788,984,1212,1442,1680,1920,2672,3426,4188,4952,5748,6546,7352,8160,9096,10034,10980,11928,12908,13890,14880,15872,18912,21954,25004,28056,31140,34226,37320,40416,43640,46866,50100,53336,56604", "code": " \ndef countPots2Until(n):\n    nbPots = {1:n>>1}\n    lftMask = ~3\n    rgtMask = 1\n    digit = 2\n    while True:\n        lft = (n & lftMask) >> 1\n        rgt = n & rgtMask\n        nbDigs = lft\n        if n & digit:\n            nbDigs |= rgt\n        if nbDigs == 0:\n            return nbPots\n        nbPots[digit] = nbDigs\n        rgtMask |= digit\n        digit <<= 1\n        lftMask = lftMask ^ digit\ndef sumXorSquare(n):\n    \"\"\"Returns sum(i^j for i, j <= n)\"\"\"\n    n += 1\n    nbPots = countPots2Until(n)\n    return 2 * sum(pot * freq * (n - freq) for pot, freq in nbPots.items())\nprint([sumXorSquare(n) for n in range(100)])  \n"}
{"sequence_id": "A224924", "text": "Sum_{i=0..n} Sum_{j=0..n} (i AND j), where AND is the binary logical AND operator.", "sequence": "0,1,3,12,16,33,63,112,120,153,211,300,408,553,735,960,976,1041,1155,1324,1536,1809,2143,2544,2952,3433,3987,4620,5320,6105,6975,7936,7968,8097,8323,8652,9072,9601,10239,10992,11800,12729,13779,14956,16248,17673,19231,20928", "code": "\nfor n in range(99):\n    s = 0\n    for i in range(n+1):\n      for j in range(n+1):\n        s += i & j\n    print(s, end=',')\n"}
{"sequence_id": "A225117", "text": "Triangle read by rows, coefficients of the generalized Eulerian polynomials A_{n, 3}(x) in descending order.", "sequence": "1,2,1,4,13,1,8,93,60,1,16,545,1131,251,1,32,2933,14498,10678,1018,1,64,15177,154113,262438,88998,4089,1,128,77101,1475736,4890287,3870352,692499,16376,1,256,388321,13270807,77404933,117758659,50476003,5175013,65527,1", "code": "\nfrom sympy import binomial\ndef T(n,k): return sum((-1)**(n - k - j)* binomial(n + 1, n - k - j)*(1 + 3*j)**n for j in range(n - k + 1))\nfor n in range(11): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A225190", "text": "(n+2)^(n+2) mod n^n.", "sequence": "0,0,0,20,64,1668,27712,355279,779264,170190707,6100448256,159424073982,2545667031040,239361355053790,812743283245056,58702956893404802,17949710147773530112,488189490082385976772,38768887410023899070464,313775221076492698014434,11531764219557396646723584", "code": "\nfor i in range(21):  print str((i+2)**(i+2) % (i**i))+',',\n"}
{"sequence_id": "A225259", "text": "Number of distinct values of the sum of 2 products of three 0..n integers", "sequence": "3,12,36,75,157,254,434,635,911,1237,1734,2162,2908,3611,4461,5435,6734,7879,9568,10964,12861,14913,17438,19426,22381,25251,28482,31624,35879,39100,44165,48267,53463,58590,64476,69214,76693,83132,90303,96766", "code": "\ndef a(n):\n  zn = list(range(n+1))\n  prod3 = list(set(i*j*k for i in zn for j in zn[i:] for k in zn[j:]))\n  return len(set(a+b for i, a in enumerate(prod3) for b in prod3[i:]))\nprint([a(n) for n in range(1, 42)]) \n"}
{"sequence_id": "A225261", "text": "Number of distinct values of the sum of 4 products of three 0..n integers.", "sequence": "5,28,90,205,409,694,1123,1668,2396,3298,4442,5741,7410,9266,11443,13937,16857,20031,23746,27694,32236,37143,42619,48390,55021,62036,69617,77815,86744,96000,106372,117136,128823,141110,154192,167871,182867,198285", "code": "\nfrom itertools import combinations_with_replacement as mc\ndef a(n):\n  prods = set(a*b*c for a, b, c in mc(range(n+1), 3))\n  return len(set(sum(p) for p in mc(prods, 4)))\nprint([a(n) for n in range(1, 11)]) \n"}
{"sequence_id": "A225404", "text": "10-adic integer x such that x^3 == 3 mod 10^n for all n.", "sequence": "7,8,5,4,3,1,5,9,8,7,8,0,0,5,8,3,2,4,0,6,1,5,6,6,2,9,4,8,1,3,0,3,6,1,8,4,8,4,6,1,9,2,2,1,3,3,8,6,8,7,8,8,9,0,6,5,9,6,3,5,3,0,2,4,2,3,0,9,0,5,2,1,6,0,7,0,1,9,9,4,7,5,7,9,3,4,8,6,6,3,3,1,1,4,3,3,6,6,2,4", "code": " n=7;p=1;i=1;exec(\"print(i,n//p);i+=1;p*=10;n+=n**3//p*7%10*p;\"*10000) \n"}
{"sequence_id": "A225466", "text": "Triangle read by rows, 3^k*S_3(n, k) where S_m(n, k) are the Stirling-Frobenius subset numbers of order m; n >= 0, k >= 0.", "sequence": "1,2,3,4,21,9,8,117,135,27,16,609,1431,702,81,32,3093,13275,12015,3240,243,64,15561,115479,171990,81405,13851,729,128,77997,970515,2238327,1655640,479682,56133,2187,256,390369,7998111,27533142,29893941,13121514,2561706", "code": "\nfrom sympy import binomial, factorial\ndef T(n, k): return sum(binomial(k, j)*(-1)**(j - k)*(2 + 3*j)**n//factorial(k) for j in range(k + 1))\nfor n in range(11): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A225467", "text": "Triangle read by rows, T(n, k) = 4^k*S_4(n, k) where S_m(n, k) are the Stirling-Frobenius subset numbers of order m; n >= 0, k >= 0.", "sequence": "1,3,4,9,40,16,27,316,336,64,81,2320,4960,2304,256,243,16564,63840,54400,14080,1024,729,116920,768496,1071360,485120,79872,4096,2187,821356,8921136,19144384,13502720,3777536,430080,16384,6561,5758240,101417920,322850304", "code": "\nfrom sympy import binomial, factorial\ndef T(n, k): return sum(binomial(k, m)*(-1)**(m - k)*((3 + 4*m)**n)//factorial(k) for m in range(k + 1))\nfor n in range(11): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A225505", "text": "a(n) = triangular(a(n-1)+a(n-2)) if n > 1, else a(n) = n.", "sequence": "0,1,1,3,10,91,5151,13741903,94490753712985,4464252567106907867941273716,9964775491460730298984873904585383048580645394630925051", "code": "\nprpr, prev = 0, 1\nfor i in range(1, 17):\n  print str(prpr)+',',\n  n = prpr+prev\n  cur = n*(n+1)/2\n  prpr, prev = prev, cur\n"}
{"sequence_id": "A225581", "text": "a(n) is the minimal odd prime q such that prime(n)*q + prime(n) + q is prime.", "sequence": "3,5,3,3,3,5,3,3,7,5,3,3,3,5,3,7,3,11,3,5,5,5,5,3,5,11,17,3,3,5,47,11,5,5,3,3,3,5,13,11,3,3,5,5,5,11,11,11,3,3,7,5,3,5,3,5,5,3,5,13,11,7,3,5,11,5,3,5,5,3,19,3,3,5,29,17,3,23,3,5,7,5,5,71,3,5,5,3,3,47,3,5,3,11,3,5,3,3,11,5,23", "code": "\nfrom sympy import isprime, nextprime, prime\ndef a(n):\n    q, p = 3, prime(n)\n    while not isprime(p*q + p + q): q = nextprime(q)\n    return q\nprint([a(n) for n in range(1, 102)]) \n"}
{"sequence_id": "A225592", "text": "a(n) = size of the network of triangular(n). Distinct triangular numbers T and R are directly connected if R = T*k, and k>0 is a triangular number less than T. Numbers belong to the same network if there is a chain of direct connections between them.", "sequence": "1,1,1,1,2,7,1,1,2,8,2,3,7,7,1,1,1,5,4,7,2,3,4,1,1,1,1,2,2,1,1,1,3,8,7,2,4,6,3,2,1,1,1,2,1,1,1,1,1,2,3,1,1,1,8,1,1,1,2,1,4,1,2,2,1,1,1,3,2,3,1,1,1,1,4,3,2,5,2,1,1,1,1,8,1,1,1,1,1,7,2", "code": "\ndef isTriangular(a):\n    sr = 1L << (long.bit_length(a) >> 1)\n    a += a\n    while a < sr*(sr+1):  sr>>=1\n    b = sr>>1\n    while b:\n      s = sr+b\n      if a >= s*(s+1):  sr = s\n      b>>=1\n    return (a==sr*(sr+1))\nnetwork = [0]*1000\nreadPos = writePos = 0\ndef addConnection(R):\n  global writePos\n  if isTriangular(R):\n    for j in range(readPos):\n      if network[j]==R:  return\n    network[writePos] = R\n    writePos += 1\nfor i in range(1, 1000000):\n    readPos, writePos = 0, 1\n    network[0] = i*(i+1)/2\n    while readPos < writePos:\n      T = long(network[readPos])\n      readPos += 1\n      n = k = 3\n      while k < T:\n        addConnection(T*k)\n        if T % k == 0 and T/k > k:  addConnection(T/k)\n        k += n\n        n += 1\n    print str(readPos)+',',\n"}
{"sequence_id": "A225603", "text": "Palindromic primes whose square is also a palindrome.", "sequence": "2,3,11,101,100111001,110111011,111010111,1100011100011,1100101010011,1101010101011,100110101011001,101000010000101,101011000110101,101110000011101,10000010101000001,10011010001011001,10100110001100101,10110010001001101,10111000000011101", "code": "\nfrom __future__ import division\nfrom sympy import isprime\ndef paloddgenrange(t,l,b=10): \n....if t == 0:\n........yield 0\n....else:\n........for x in range(t+1,l+1):\n............n = b**(x-1)\n............n2 = n*b\n............for y in range(n,n2):\n................k, m = y//b, 0\n................while k >= b:\n....................k, r = divmod(k,b)\n....................m = b*m + r\n................yield y*n + b*m + k\nA225603_list = [2,3,11]\nfor i in paloddgenrange(1,10):\n....s = str(i*i)\n....if s == s[::-1] and isprime(i):\n........A225603_list.append(i) \n"}
{"sequence_id": "A225671", "text": "Largest prime p(k) > p(n) such that 1/p(n) + 1/p(n+1) + ... + 1/p(k) < 1, where p(n) is the n-th prime.", "sequence": "3,23,107,337,853,1621,2971,4919,7757,11657,16103,22193,29251,37699,48523,61051,75479,91459,110563,131641,155501,183581,214177,248593,286063,325883,369979,419449,473647,534029,600623,667531,739523,816769,900997,988651,1083613", "code": "\nfrom sympy import prime\ndef A225671(n):\n....xn, xd, k, p = 1, prime(n), n, prime(n)\n....while xn < xd:\n........k += 1\n........po, p = p, prime(k)\n........xn = xn*p + xd\n........xd *= p\n....return po \n"}
{"sequence_id": "A225684", "text": "Nonpalindromic numbers n with property that the sum of the reversed divisors of n is equal to n+1.", "sequence": "965,8150,12966911,625261742", "code": "\nfrom sympy import divisors\ndef ispal(n): s = str(n); return s == s[::-1]\ndef ok(n):\n  return not ispal(n) and n+1 == sum(int(str(d)[::-1]) for d in divisors(n))\nprint([m for m in range(10**4) if ok(m)]) \n"}
{"sequence_id": "A225727", "text": "Numbers n such that sum of first n primorials (A143293) is divisible by n.", "sequence": "1,3,17,51,967,2901,16439,49317,147951,1331559", "code": "\nprimes = [2]*2\nprimes[1] = 3\ndef addPrime(k):\n  for p in primes:\n    if k%p==0:  return\n    if p*p > k:  break\n  primes.append(k)\nfor n in range(5,10000000,6):\n  addPrime(n)\n  addPrime(n+2)\nsum = 0\nprimorial = n = 1\nfor p in primes:\n  sum += primorial\n  primorial *= p\n  if sum % n == 0:  print n,\n  n += 1\n"}
{"sequence_id": "A225728", "text": "Primes p such that sum of primorials (A143293) not including p as a factor is divisible by p.", "sequence": "3,17,967", "code": "\nprimes = [2]*2\nprimes[1] = 3\ndef addPrime(k):\n  for p in primes:\n    if k%p==0:  return\n    if p*p > k:  break\n  primes.append(k)\nfor n in range(5,100000000,6):\n  addPrime(n)\n  addPrime(n+2)\nsum = 0\nprimorial = 1\nfor p in primes:\n  sum += primorial\n  primorial *= p\n  if sum % p == 0:  print p,\n"}
{"sequence_id": "A225790", "text": "Rubik's Square sequence.", "sequence": "1,24,96,165888,663552,165112971264,660451885056,23665185138564661248,94660740554258644992,488428629217633346355864797184,1953714516870533385423459188736,1451626239969468099340993140755597642170368,5806504959877872397363972563022390568681472", "code": "\na1,n = 1,1\nprint(n,a1)\nwhile n < 12:\n    n = n+1\n    if n%2 == 0:\n        nn = n//2\n        a = 2**(2*nn*nn+2*nn-1)*3**(nn*nn)\n        a1 = a\n    else:\n        a = 4*a1\n    print(n,a) \n"}
{"sequence_id": "A225841", "text": "Numbers n such that the sum of first n primorial numbers is divisible by n.", "sequence": "1,2,4,523,1046,2092", "code": "\nprimes = []\nn = 1\nsum = 2\nprimorial = 6\ndef addPrime(k):\n  global n, sum, primorial\n  for p in primes:\n    if k%p==0:  return\n    if p*p > k:  break\n  primes.append(k)\n  sum += primorial\n  primorial *= k\n  n += 1\n  if sum % n == 0:  print(n, end=',')\nprint(1, end=',')\nfor p in range(5, 100000, 6):\n  addPrime(p)\n  addPrime(p+2)\n"}
{"sequence_id": "A225844", "text": "Least k>0 such that triangular(n) + k*(k+1) is a triangular number.", "sequence": "2,1,3,5,7,2,11,13,5,17,19,3,6,25,27,9,31,33,35,4,9,41,8,45,47,10,14,53,9,5,59,61,21,18,67,69,21,73,75,14,22,6,11,13,87,15,91,26,20,34,12,101,26,105,30,7,20,33,115,117,119,34,21,125,37,129,29,133,14,137", "code": "\ndef isTriangular(a):\n    sr = 1L << (long.bit_length(long(a)) >> 1)\n    a += a\n    while a < sr*(sr+1):  sr>>=1\n    b = sr>>1\n    while b:\n      s = sr+b\n      if a >= s*(s+1):  sr = s\n      b>>=1\n    return (a==sr*(sr+1))\nn = tn = 0\nwhile 1:\nfor m in range(1, 1000000000):\n    if isTriangular(tn + m*(m+1)): break\n  print str(m)+',',\n  n += 1\n  tn += n\n"}
{"sequence_id": "A225864", "text": "Composite numbers for which both sum and product of digits are primes.", "sequence": "12,21,115,511,1112,1121,1211,11711,13111,17111,31111,71111,111112,121111,211111,1111115,1111117,1111171,1111511,1115111,1151111,1511111,1711111,5111111,7111111,111111115,111111151,111111311,111111511,111115111,111131111,111151111", "code": "\nfrom __future__ import division\nfrom sympy import isprime\nA225864_list = []\nfor l in range(1,20):\n    plist, q = [p for p in [2,3,5,7] if isprime(l-1+p)], (10**l-1)//9\n    for i in range(l):\n        for p in plist:\n            r = q+(p-1)*10**i\n            if not isprime(r):\n                A225864_list.append(r) \n"}
{"sequence_id": "A225901", "text": "Write n in factorial base, then replace each nonzero digit d of radix k with k-d.", "sequence": "0,1,4,5,2,3,18,19,22,23,20,21,12,13,16,17,14,15,6,7,10,11,8,9,96,97,100,101,98,99,114,115,118,119,116,117,108,109,112,113,110,111,102,103,106,107,104,105,72,73,76,77,74,75,90,91,94,95,92,93,84,85,88,89,86,87,78,79,82,83,80,81,48,49,52,53,50,51,66,67,70,71,68", "code": "\nfrom sympy import factorial as f\ndef a(n):\n    s=0\n    k=2\n    while(n):\n        d=n%k\n        n=(n//k)\n        if d: s=s+(k - d)*f(k - 1)\n        k+=1\n    return s\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A225944", "text": "Numbers n such that prime(n) divides n^n-1.", "sequence": "1,2,5,124,181,696,261800,3834909,18836480,51432542,69709961,332054520,3140421767", "code": "\nprimes = []\nn = 0\ndef addPrime(k):\n  global n\n  for p in primes:\n    if k%p==0:  return\n    if p*p > k:  break\n  primes.append(k)\n  n += 1\n  if (n**n-1) % k == 0: print n,\naddPrime(2)\naddPrime(3)\nfor i in range(5, 10000000, 6):\n  addPrime(i)\n  addPrime(i+2)\n"}
{"sequence_id": "A226019", "text": "Primes whose binary reversal is a square.", "sequence": "2,19,79,149,569,587,1237,2129,2153,2237,2459,2549,4129,4591,4657,4999,8369,8999,9587,9629,9857,10061,17401,17659,17737,18691,20149,20479,33161,33347,34631,35117,35447,39023,40427,40709,66403,68539,74707,75703,79063,79333,80071", "code": "\nimport math\nprimes = []\ndef addPrime(k):\n  for p in primes:\n    if k%p==0:  return\n    if p*p > k:  break\n  primes.append(k)\n  r = 0\n  p = k\n  while k:\n    r = r*2 + (k&1)\n    k>>=1\n  s = int(math.sqrt(r))\n  if s*s == r:  print str(p)+',',\naddPrime(2)\naddPrime(3)\nfor i in range(5, 1000000000, 6):\n  addPrime(i)\n  addPrime(i+2)\n"}
{"sequence_id": "A226019", "text": "Primes whose binary reversal is a square.", "sequence": "2,19,79,149,569,587,1237,2129,2153,2237,2459,2549,4129,4591,4657,4999,8369,8999,9587,9629,9857,10061,17401,17659,17737,18691,20149,20479,33161,33347,34631,35117,35447,39023,40427,40709,66403,68539,74707,75703,79063,79333,80071", "code": "\nfrom sympy import isprime\nA226019_list, i, j = [2], 0, 0\nwhile j < 2**34:\n    p = int(format(j,'b')[::-1],2)\n    if j % 2 and isprime(p):\n        A226019_list.append(p)\n    j += 2*i+1\n    i += 1\nA226019_list = sorted(A226019_list) \n"}
{"sequence_id": "A226019", "text": "Primes whose binary reversal is a square.", "sequence": "2,19,79,149,569,587,1237,2129,2153,2237,2459,2549,4129,4591,4657,4999,8369,8999,9587,9629,9857,10061,17401,17659,17737,18691,20149,20479,33161,33347,34631,35117,35447,39023,40427,40709,66403,68539,74707,75703,79063,79333,80071", "code": "\nfrom sympy import integer_nthroot, primerange\ndef ok(p): return integer_nthroot(int(bin(p)[:1:-1], 2), 2)[1]\ndef aupto(lim): return [p for p in primerange(2, lim+1) if ok(p)]\nprint(aupto(80071)) \n"}
{"sequence_id": "A226104", "text": "Numbers n such that phi(n)+3 divides n+3.", "sequence": "1,30,42,66,78,102,114,138,174,186,195,222,246,258,282,318,354,366,402,426,438,474,498,534,582,606,618,642,654,678,762,786,822,834,894,906,942,978,1002,1038,1074,1086,1146,1158,1182,1194,1266,1338,1362,1374,1398", "code": "\nfrom sympy import totient as phi\ndef ok(n): return (n+3) % (phi(n)+3) == 0\nprint([m for m in range(1, 1400) if ok(m)]) \n"}
{"sequence_id": "A226305", "text": "Numerator of Product_{d|n} b(d)^Moebius(n/d), where b() = A100371().", "sequence": "1,1,3,3,15,1,63,5,21,1,1023,5,4095,1,17,17,65535,1,262143,17,65,1,4194303,17,69905,1,4161,65,268435455,1,1073741823,257,1025,1,53261,13,68719476735,1,4097,257,1099511627775,1,4398046511103,1025,3133,1,70368744177663,257,69810262081,1,65537,4097", "code": "\nfrom sympy import divisors, totient, mobius, prod\ndef a(n): return prod((2**totient(d) - 1)**mobius(n//d) for d in divisors(n)).numerator()\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A226306", "text": "Denominator of Product_{d|n} b(d)^Moebius(n/d), where b() = A100371().", "sequence": "1,1,1,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,3,3,1,1,5,1,1,1,3,1,1,1,1,3,1,3,1,1,1,3,5,1,1,1,3,1,1,1,17,1,1,3,3,1,1,3,5,3,1,1,85,1,1,7,1,15,1,1,3,3,1,1,1,1,1,1,3,3,1,1,17,1,1,1,325,15,1,3,5,1,1,21,3,3,1,3,257,1,1,1,1", "code": "\nfrom sympy import divisors, totient, mobius, prod\ndef a(n): return prod((2**totient(d) - 1)**mobius(n//d) for d in divisors(n)).denominator()\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A226308", "text": "a(n) = a(n-1) + a(n-2) + 2*a(n-3) with a(0)=2, a(1)=1, a(2)=5.", "sequence": "2,1,5,10,17,37,74,145,293,586,1169,2341,4682,9361,18725,37450,74897,149797,299594,599185,1198373,2396746,4793489,9586981,19173962,38347921,76695845,153391690,306783377,613566757,1227133514,2454267025,4908534053,9817068106,19634136209", "code": "\na0, a1, a2 = 2, 1, 5\nfor n in range(77):\n  a = a2 + a1 + 2*a0\n  print a0,\n  a0, a1, a2 = a1, a2, a \n"}
{"sequence_id": "A226351", "text": "Number of ways to tile a fixed 3 X n square grid with 1 X 1, 2 X 2, and 1 X 2 tiles.", "sequence": "1,3,26,163,1125,7546,51055,344525,2326760,15709977,106079739,716273960,4836475953,32657123299,220509407586,1488936665619,10053686907525,67885102598386,458377829683919,3095086053853821,20898824215523616", "code": "\n\n\n\nn=5; rows=3\ncount=0; result=[]\ndef f(b,row=0,col=-1):\n..global count\n..for i in range(row,len(b)):\n....for j in range((col+1 if i==row else 0),len(b[0])):\n......if b[i][j]==' ':\n........if i<len(b)-1:\n..........if b[i+1][j]==' ':\n............f(b[:i]+[b[i][:j]+'^'+b[i][j+1:],b[i+1][:j]+'V'+b[i+1][j+1:]]+b[i+2:],i,j)\n............if j<len(b[0])-1:\n..............if b[i][j+1]==' ' and b[i+1][j:j+2]==' ':\n................f(b[:i]+[b[i][:j]+'/\\\\'+b[i][j+2:],b[i+1][:j]+'\\\\/'+b[i+1][j+2:]]+b[i+2:],i,j)\n........if j<len(b[0])-1:\n..........if b[i][j+1]==' ':\n............f(b[:i]+[b[i][:j]+'<>'+b[i][j+2:]]+b[i+1:],i,j)\n..count+=1\n..result.append(b) \nf([' '*n]*rows); print(count)\n"}
{"sequence_id": "A226459", "text": "a(n) = Sum_{d|n} phi(d^d), where phi(n) is the Euler totient function A000010(n).", "sequence": "1,3,19,131,2501,15573,705895,8388739,258280345,4000002503,259374246011,2972033498453,279577021469773,4762288640230761,233543408203127519,9223372036863164547,778579070010669895697,13115469358432437487707,1874292305362402347591139", "code": "\nfrom sympy import totient, divisors\ndef A226459(n):\n    return sum(totient(d)*d**(d-1) for d in divisors(n,generator=True)) \n"}
{"sequence_id": "A226470", "text": "a(n) = n^2 XOR triangular(n), where XOR is the bitwise logical exclusive-or operator.", "sequence": "0,0,7,15,26,22,49,45,100,124,83,59,222,242,173,153,392,440,495,471,322,350,281,773,876,820,1019,931,646,762,597,561,1552,1648,1751,1727,1930,2022,1857,1789,1396,1484,1379,1163,1102,994,3197,3273,3480,3496,3391,3847,4082", "code": "\nfor n in range(99):\n    print((n*n) ^ (n*(n+1)//2), end=\", \")\n"}
{"sequence_id": "A226471", "text": "Numbers n such that n^2 XOR triangular(n) is a triangular number. XOR is the bitwise logical exclusive-or operator.", "sequence": "0,1,3,7,15,25,31,63,113,127,189,200,255,381,481,499,511,765,1004,1011,1023,1533,1785,1808,1985,2023,2035,2047,3069,3199,3255,3577,3810,4071,4083,4095,4446,6141,6399,7161,8065,8135,8167,8179,8191,12285,12799,14279,14280", "code": "\nimport math\nfor n in range(100000000):\n  a = (n*n) ^ (n*(n+1)/2)\n  r = int(math.sqrt(a*2))\n  if r*(r+1)==a*2:  print n,\n"}
{"sequence_id": "A226499", "text": "Triangular numbers representable as m * triangular(m).", "sequence": "0,1,6,4851", "code": "\ndef isTriangular(a):\n    sr = 1 << (int.bit_length(int(a)) >> 1)\n    a += a\n    while a < sr*(sr+1):  sr>>=1\n    b = sr>>1\n    while b:\n      s = sr+b\n      if a >= s*(s+1):  sr = s\n      b>>=1\n    return (a==sr*(sr+1))\nfor n in range(10000):\n  product = n*n*(n+1)//2\n  if isTriangular(product):  print(product, end=',')\n"}
{"sequence_id": "A226561", "text": "a(n) = Sum_{d|n} d^n * phi(d), where phi(n) is the Euler totient function A000010(n).", "sequence": "1,5,55,529,12501,94835,4941259,67240193,2324562301,40039063525,2853116706111,35668789979107,3634501279107037,66676110291801575,3503151245145885315,147575078498173255681,13235844190181388226833,236079349222711695887225,35611553801885644604231623", "code": "\nfrom sympy import totient, divisors\ndef A226561(n):\n    return sum(totient(d)*d**n for d in divisors(n,generator=True)) \n"}
{"sequence_id": "A226718", "text": "n! mod tetrahedral(n), that is A000142(n) mod A000292(n).", "sequence": "0,2,6,4,15,48,0,0,45,120,66,168,0,0,120,288,153,360,0,0,231,528,0,0,0,0,378,840,435,960,0,0,0,0,630,1368,0,0,780,1680,861,1848,0,0,1035,2208,0,0,0,0,1326,2808,0,0,0,0,1653,3480,1770,3720,0,0,0,0,2145,4488", "code": "\nf = 1\nfor i in range(1, 100):\n    f *= i\n    print str(f % (i*(i+1)*(i+2)/6))+',',\n"}
{"sequence_id": "A226734", "text": "A002110(n) mod A000217(n).", "sequence": "0,0,0,0,0,0,14,30,15,0,0,0,0,0,90,34,102,57,0,0,0,0,138,210,195,156,84,0,0,0,434,198,0,0,420,222,0,0,390,410,0,0,0,330,345,0,846,546,560,765,0,0,159,165,770,798,0,0,0,0,0,1302,798,1170,0,0,0,0,0,0,2130", "code": "\nprimes = []\nn = 2\nprimorial = 6\ndef addPrime(k):\n  global n, primorial\n  for p in primes:\n    if k%p==0:  return\n    if p*p > k:  break\n  primes.append(k)\n  print(primorial % (n*(n+1)/2), end=',')\n  primorial *= k\n  n += 1\nprint(0, end=',')  \nfor p in range(5, 1000, 6):\n  addPrime(p)\n  addPrime(p+2)\n"}
{"sequence_id": "A226752", "text": "Possible total sums of three 3-digit primes that together use all nonzero digits 1-9.", "sequence": "999,1089,1107,1197,1269,1287,1323,1341,1359,1377,1413,1431,1449,1467,1521,1539,1557,1593,1611,1629,1647,1683,1701,1737,1773,1791,1809,1827,1863,1881,1899,1917,1953,1971,1989,2007,2043,2061,2133,2151,2223,2241,2331,2421", "code": "\nfrom sympy import isprime\nfrom itertools import permutations\naset = set()\nfor p in permutations(\"123456789\"):\n    p = [int(\"\".join(p[i*3:(i+1)*3])) for i in range(3)]\n    if all(isprime(pi) for pi in p): aset.add(sum(p))\nprint(sorted(aset)) \n"}
{"sequence_id": "A226789", "text": "Triangular numbers obtained as the concatenation of n+1 and n.", "sequence": "10,21,26519722651971,33388573338856,69954026995401,80863378086336", "code": "\nfrom math import isqrt\ndef istri(n): t = 8*n+1; return isqrt(t)**2 == t\ndef afind(klimit, kstart=0):\n    strk = \"0\"\n    for k in range(kstart, klimit+1):\n        strkp1 = str(k+1)\n        t = int(strkp1 + strk)\n        if istri(t):\n            print(t, end=\", \")\n        strk = strkp1\nafind(81*10**5) \n"}
{"sequence_id": "A226789", "text": "Triangular numbers obtained as the concatenation of n+1 and n.", "sequence": "10,21,26519722651971,33388573338856,69954026995401,80863378086336", "code": " \ndef isconcat(n):\n    if n < 10: return False\n    s = str(n)\n    mid = (len(s)+1)//2\n    lft, rgt = int(s[:mid]), int(s[mid:])\n    return lft - 1 == rgt\ndef afind(tlimit, tstart=0):\n    for t in range(tstart, tlimit+1):\n        trit = t*(t+1)//2\n        if isconcat(trit):\n            print(trit, end=\", \")\nafind(13*10**6) \n"}
{"sequence_id": "A226898", "text": "Hooley's Delta function: maximum number of divisors of n in [u, eu] for all u. (Here e is Euler's number 2.718... = A001113.)", "sequence": "1,2,1,2,1,2,1,2,1,2,1,3,1,2,2,2,1,2,1,3,2,2,1,4,1,2,1,2,1,3,1,2,1,2,2,3,1,2,1,4,1,3,1,2,2,2,1,4,1,2,1,2,1,2,2,3,1,2,1,4,1,2,2,2,2,2,1,2,1,3,1,4,1,2,2,2,2,2,1,4,1,2,1,4,1,2,1,2,1,4,2,2", "code": "\nfrom sympy import divisors, exp\ndef a(n):\n    d = divisors(n)\n    m = 1\n    for i in range(len(d) - 1):\n        t = exp(1)*d[i]\n        m = max(sum(1 for j in range(i, len(d)) if d[j]<t), m)\n    return m\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A227052", "text": "a(n) = (n^2)! / (n^2-n)! = number of ways of placing n labeled balls into n^2 labeled boxes with at most one ball in each box.", "sequence": "1,1,12,504,43680,6375600,1402410240,432938943360,178462987637760,94670977328928000,62815650955529472000,50963773003971232204800,49633807532904958383820800,57141374006987657125324185600,76763145767753986733306290176000,119005648371962652004288345681920000", "code": "\nimport math\nfor n in range(20):\n    print str(math.factorial(n*n)/math.factorial(n*n-n))+',',\n"}
{"sequence_id": "A227053", "text": "a(n) = (n^3)! / (n^3-n)! = number of ways of placing n labeled balls into n^3 labeled boxes with at most one ball in each box.", "sequence": "1,1,56,17550,15249024,28143753000,94689953674560,525169893772283760,4469844204191484518400,55337211594165488805417600,955860613004397508326213120000,22282564877342299983672172489536000,682182070950002359574696677978908672000,26812831292465310201469047550286967518976000", "code": "\nimport math\nfor n in range(20):\n  print str(math.factorial(n**3)/math.factorial(n**3-n))+',',\n"}
{"sequence_id": "A227062", "text": "Numbers whose base-5 sum of digits is 5.", "sequence": "9,13,17,21,29,33,37,41,45,53,57,61,65,77,81,85,101,105,129,133,137,141,145,153,157,161,165,177,181,185,201,205,225,253,257,261,265,277,281,285,301,305,325,377,381,385,401,405,425,501,505,525,629,633,637", "code": "\nfrom sympy.utilities.iterables import multiset_permutations\ndef auptodigs(maxdigits_base5):\n    alst = []\n    for d in range(2, maxdigits_base5 + 1):\n        fulldigset = list(\"0\"*(d-2) + \"111112234\")\n        for firstdig in \"1234\":\n            target_sum, restdigset = 5 - int(firstdig), fulldigset[:]\n            restdigset.remove(firstdig)\n            for p in multiset_permutations(restdigset, d-1):\n                if sum(map(int, p)) == target_sum:\n                  alst.append(int(firstdig+\"\".join(p), 5))\n                  if int(p[0]) == target_sum:\n                      break\n    return alst\nprint(auptodigs(5)) \n"}
{"sequence_id": "A227119", "text": "Number of ways to select a set partition, P of {1,2,...,n} and then select a subset, S of {1,2,...,n} such that for all i in {1,2,...,n-1} if i and i+1 are in S then i and i+1 are in different blocks of P.", "sequence": "1,2,7,31,163,985,6676,49918,406820,3580011,33764544,339222866,3612046889,40588278875,479542299692,5938050050297,76848380886090,1036869475470365,14553056889254517,212063804824260167,3202482669648363619,50039504959872274840", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import fibonacci as F, binomial\n@cacheit\ndef a(n): return 1 if n==0 else sum([binomial(n - 1, j - 1)*F(j + 2)*a(n - j) for j in range(1, n + 1)])\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A227153", "text": "Product of nonzero digits of n in factorial base.", "sequence": "1,1,1,1,2,2,1,1,1,1,2,2,2,2,2,2,4,4,3,3,3,3,6,6,1,1,1,1,2,2,1,1,1,1,2,2,2,2,2,2,4,4,3,3,3,3,6,6,2,2,2,2,4,4,2,2,2,2,4,4,4,4,4,4,8,8,6,6,6,6,12,12,3,3,3,3,6,6,3,3,3,3,6,6,6,6,6,6", "code": "\nfrom operator import mul\ndef A(n, p=2):\n    return n if n<p else A(n//p, p+1)*10 + n%p\ndef a(n):\n    return 1 if n<2 else reduce(mul, [int(i) for i in str(A(n - 1)) if i!=\"0\"])\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A227183", "text": "a(n) = sum of parts of the unique unordered partition encoded in the run lengths of the binary expansion of n; row sums of A227739 for n>=1.", "sequence": "0,1,2,2,4,3,3,3,6,5,4,6,5,4,4,4,8,7,6,8,8,5,7,9,7,6,5,7,6,5,5,5,10,9,8,10,10,7,9,11,12,9,6,10,11,8,10,12,9,8,7,9,9,6,8,10,8,7,6,8,7,6,6,6,12,11,10,12,12,9,11,13,14,11,8,12,13,10,12,14", "code": "\ndef A227183(n):\n  '''Sum of parts of the unique unordered partition encoded in the run lengths of the binary expansion of n.'''\n  s = 0\n  b = n%2\n  i = 1\n  while (n != 0):\n    n >>= 1\n    if ((n%2) == b): \n      i += 1\n    else: \n      b = n%2\n      s += i\n  return(s)\n"}
{"sequence_id": "A227184", "text": "a(n) = product of parts of the unordered partition encoded with the runlengths of binary expansion of n.", "sequence": "1,1,1,2,4,1,2,3,9,4,1,8,6,2,3,4,16,9,4,18,16,1,8,27,12,6,2,12,8,3,4,5,25,16,9,32,36,4,18,48,81,16,1,32,54,8,27,64,20,12,6,24,24,2,12,36,15,8,3,16,10,4,5,6,36,25,16,50,64,9,32,75,144,36,4,72", "code": "\ndef A227184(n):\n  '''Product of parts of the unique unordered partition encoded in the run lengths of the binary expansion of n.'''\n  p = 1\n  b = n%2\n  i = 1\n  while (n != 0):\n    n >>= 1\n    if ((n%2) == b): i += 1\n    else:\n      b = n%2\n      p *= i\n  return(p)\n"}
{"sequence_id": "A227192", "text": "Sum of the partial sums of the run lengths of binary expansion of n, when starting scanning from the least significant end; Row sums of A227188 and A227738.", "sequence": "1,3,2,5,6,4,3,7,8,10,9,6,7,5,4,9,10,12,11,14,15,13,12,8,9,11,10,7,8,6,5,11,12,14,13,16,17,15,14,18,19,21,20,17,18,16,15,10,11,13,12,15,16,14,13,9,10,12,11,8,9,7,6,13,14,16,15,18,19,17,16", "code": "\ndef A227192(n):\n  '''Sum of the partial sums of the run lengths of binary expansion of n, starting from the least significant end.'''\n  s = 0\n  b = n%2\n  i = 0\n  while (n != 0):\n    n >>= 1\n    i += 1\n    if((n%2) != b):\n      b = n%2\n      s += i\n  return(s)\n"}
{"sequence_id": "A227217", "text": "Primes p such that p + (product of digits of p) is prime and p - (product of digits of p) is prime.", "sequence": "23,29,83,101,103,107,109,293,307,347,349,401,409,431,439,503,509,601,607,653,659,677,701,709,743,809,907,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1123,1201,1297,1301,1303,1307,1409,1423,1489,1523", "code": "\nfrom sympy import isprime, primerange\ndef DP(n):\n    p = 1\n    for i in str(n):\n        p *= int(i)\n    return p\nfor pn in primerange(1, 2000):\n    dpn = DP(pn)\n    if isprime(pn-dpn) and isprime(pn+dpn):\n        print(pn, end=', ')\n\n"}
{"sequence_id": "A227224", "text": "Numbers n such that n*(sum of digits of n) is a perfect square.", "sequence": "0,1,2,3,4,5,6,7,8,9,12,24,36,48,75,81,100,121,144,147,150,169,192,196,200,225,242,288,300,320,324,363,375,400,441,484,500,507,512,529,600,640,648,700,704,735,800,832,882,900,960,961,1014,1083,1088,1200,1250,1452,1458,1521,1681,1815", "code": "\ndef DS(n):\n    s = 0\n    for i in str(n):\n        s += int(i)\n    return s\nfor n in range(10**3):\n    k = 0\n    while k**2 <= n*DS(n):\n        if k**2 == n*DS(n):\n            print(n,end=', ')\n            break\n        else:\n            k += 1\n\n"}
{"sequence_id": "A227225", "text": "Numbers n such that (sum of digits of n) + (product of digits of n) is a perfect cube.", "sequence": "0,4,10,22,36,63,80,100,107,113,128,131,170,177,182,206,218,260,269,281,296,305,311,350,404,440,503,530,602,620,629,692,701,710,717,771,800,812,821,926,962,1000,1007,1016,1025,1034,1043,1052,1061,1070,1106,1160,1168,1186,1205,1233,1250,1304,1323,1332,1340,1349,1394,1403,1430", "code": "\ndef DS(n):\n..s = 0\n..for i in str(n):\n....s += int(i)\n..return s\ndef DP(n):\n..p = 1\n..for i in str(n):\n....p *= int(i)\n..return p\nfor n in range(2000):\n..k = 0\n..while k**3 <= DS(n)+DP(n):\n....if k**3 == DS(n)+DP(n):\n......print(n,end=', ')\n......break\n....else:\n......k += 1\n\n"}
{"sequence_id": "A227227", "text": "Numbers k such that k*sum_of_digits(k) is a perfect cube.", "sequence": "0,1,8,81,125,512,1000,1331,2592,6400,8000,10125,19683,20736,34300,35937,36125,46656,59319,74088,81000,123823,125000,157464,185193,268912,279936,328509,373248,421875,431244,469567,474552,481474,512000,592704,658503,795906", "code": "\ndef DS(n):\n    return sum(int(i) for i in str(n))\ndef a(n):\n    k = 0\n    nDSn = n * DS(n)\n    while k <= n:\n        if k**3 == nDSn:\n            return True\n        if k**3 > nDSn:\n            return False\n        k += 1\n[n for n in range(10**5) if a(n)]\n\n"}
{"sequence_id": "A227228", "text": "Palindromes greater than 10 whose sum of proper divisors is also a palindrome greater than 10.", "sequence": "333,646,656,979,1001,3553,10801,11111,18581,31713,34943,48484,57375,95259,99099,158851,262262,569965,1173711,1216121,1399931,1439341,1502051,1925291,3203023,3436343,3659563,3662663,3803083,3888883,5185815,5352535,5893985", "code": "\nfrom sympy import divisors\ndef rev(n):\n..r = ''\n..for i in str(n):\n....r = i + r\n..return int(r)\nfor i in range(10**6):\n..s = sum(divisors(i))-i\n..if rev(i) == i and s > 10 and rev(s) == s:\n....print(i,end=', ')\n\n"}
{"sequence_id": "A227324", "text": "Result of changing both the prime indices and the exponents in the prime factorization of n: increment odd values, decrement even values.", "sequence": "1,9,4,3,49,36,25,81,2,441,169,12,121,225,196,27,361,18,289,147,100,1521,841,324,7,1089,16,75,529,1764,1369,729,676,3249,1225,6,961,2601,484,3969,1849,900,1681,507,98,7569,2809,108,5,63,1444,363,2209,144", "code": "\nprimes = [2]*2\nprimes[1] = 3\ndef addPrime(k):\n  for p in primes:\n    if k%p==0:  return\n    if p*p > k:  break\n  primes.append(k)\nfor n in range(5, 1000000, 6):\n  addPrime(n)\n  addPrime(n+2)\nfor n in range(1,99):\n  p = 1\n  j = n\n  i = 0\n  while j>1:\n    e = 0\n    while j % primes[i] == 0:\n      j /= primes[i]\n      e+=1\n    if e:\n      e = ((e-1)^1) + 1\n      p*= primes[i^1]**e\n    i += 1\n  print str(p)+',',\n"}
{"sequence_id": "A227349", "text": "Product of lengths of runs of 1-bits in binary representation of n.", "sequence": "1,1,1,2,1,1,2,3,1,1,1,2,2,2,3,4,1,1,1,2,1,1,2,3,2,2,2,4,3,3,4,5,1,1,1,2,1,1,2,3,1,1,1,2,2,2,3,4,2,2,2,4,2,2,4,6,3,3,3,6,4,4,5,6,1,1,1,2,1,1,2,3,1,1,1,2,2,2,3,4,1,1,1,2,1,1,2,3,2,2,2,4,3,3,4,5,2,2,2,4,2,2,4,6,2,2,2,4,4,4,6,8,3,3,3,6,3,3,6,9,4", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom re import split\ndef A227349(n):\n    return reduce(mul, (len(d) for d in split('0+',bin(n)[2:]) if d)) if n > 0 else 1 \n"}
{"sequence_id": "A227363", "text": "a(n) = n + (n-1)*(n-2) + (n-3)*(n-4)*(n-5) + (n-6)*(n-7)*(n-8)*(n-9) + ... + ...*(n-n).", "sequence": "0,1,2,5,10,17,32,61,110,185,316,557,986,1705,2840,4661,7702,12881,21620,35965,58706,94217,150016,239045,382670,614401,984332,1564301,2458810,3826745,5918936,9136597,14115686,21842225,33803620,52181021,80128082,122221801,185211440", "code": "\nfor n in range(55):\n  sum = i = 0\n  k = 1\n  while i<=n:\n    product = 1\n    for x in range(k):\n      product *= n-i\n      i += 1\n      if i>n: break\n    sum += product\n    k += 1\n  print(str(sum), end=',')\n"}
{"sequence_id": "A227364", "text": "a(n) = 1 + 2*3 + 4*5*6 + 7*8*9*10 + ... + ...*n  (see Example lines).", "sequence": "0,1,3,7,11,27,127,134,183,631,5167,5178,5299,6883,29191,365527,365543,365799,370423,458551,2226007,39435607,39435629,39436113,39447751,39739207,47329207,252562807,6006997207,6006997236,6006998077,6007024177,6007860247,6035477527,6975328087", "code": "\nfor n in range(55):\n  sum = 0\n  i = k = 1\n  while i<=n:\n    product = 1\n    for x in range(k):\n      product *= i\n      i += 1\n      if i>n: break\n    sum += product\n    k += 1\n  print(str(sum), end=',')\n"}
{"sequence_id": "A227365", "text": "a(n) = 0 + 1*2 + 3*4*5 + 6*7*8*9 + ... + ...*n.", "sequence": "0,1,2,5,14,62,68,104,398,3086,3096,3196,4406,20246,243326,243341,243566,247406,316766,1638686,28150526,28150547,28150988,28161152,28405550,34526126,193916126,4503821726,4503821754,4503822538,4503846086,4504576886,4527986846,5301270686", "code": "\nfor n in range(55):\n  sum = i = 0\n  k = 1\n  while i<=n:\n    product = 1\n    for x in range(k):\n      product *= i\n      i += 1\n      if i>n: break\n    sum += product\n    k += 1\n  print(str(sum), end=',')\n"}
{"sequence_id": "A227366", "text": "a(0)=1, a(n+1) = a(n) + a(n-1)*a(n-2) + a(n-3)*a(n-4)*a(n-5) + a(n-6)*a(n-7)*a(n-8)*a(n-9) + ... + ...*a(0).", "sequence": "1,1,2,3,6,13,33,118,584,4714,76206,2879841,364389490,220150411628,1049813737275512,80222580570107370160,231117086585854944888597249,84218767584329653007205530276477742,18540809099930664963747242025045529905738135516", "code": "\na = [1]*99\nfor n in range(20):\n  sum = i = 0\n  k = 1\n  while i<=n:\n    product = 1\n    for x in range(k):\n      product *= a[n-i]\n      i += 1\n      if i>n: break\n    sum += product\n    k += 1\n  a[n+1] = sum\n  print(str(a[n]),end=',')\n"}
{"sequence_id": "A227367", "text": "a(0)=1, a(n+1) = a(0) + a(1)*a(2) + a(3)*a(4)*a(5) + a(6)*a(7)*a(8)*a(9) + ... + ...*a(n).", "sequence": "1,1,2,3,6,21,381,762,290703,84397476747,7122934049104967061783,14245868098209934123566,101472378935797762635619628499635817245339961,10296643686890133479148472187437767614663729545766251948487237380959682684821520304732841", "code": "\na = [1]*99\nfor n in range(20):\n  sum = i = 0\n  k = 1\n  while i<=n:\n    product = 1\n    for x in range(k):\n      product *= a[i]\n      i += 1\n      if i>n: break\n    sum += product\n    k += 1\n  a[n+1] = sum\n  print(str(a[n]),end=',')\n"}
{"sequence_id": "A227368", "text": "a(n) = Index k where A227183(k) for the first time gets value n; the runlength binary code for minimally runlength-encoded unordered partition of size n.", "sequence": "0,1,2,5,4,9,8,17,16,23,32,39,40,71,72,87,80,151,144,167,160,295,288,327,320,351,576,607,640,671,672,1183,1184,1311,1312,1375,1344,2399,2368,2655,2624,2719,2688,4767,4736,5279,5248,5407,5376,5503,9472,9599,10496", "code": "\ndef A227368(n):\n  '''Index k where A227183(k) for the first time gets value n. A naive implementation.'''\n  k = 0\n  while(A227183(k) != n): k += 1\n  return(k)\n"}
{"sequence_id": "A227415", "text": "a(n) = (n+1)!! mod n!!.", "sequence": "0,0,1,2,7,3,9,69,177,60,2715,4500,42975,104580,91665,186795,3493665,13497435,97345395,442245825,2601636975,13003053525,70985324025,64585694250,57891366225,3576632909850,9411029102475,147580842959550,476966861546175,5708173568847750", "code": "\nfor n in range(2, 77):\n    prOdd = prEven = 1\n    for i in range(1, n, 2): prOdd *= i\n    for i in range(2, n, 2): prEven *= i\n    if n&1: print str(prEven % prOdd)+',',\n    else:   print str(prOdd % prEven)+',',\n"}
{"sequence_id": "A227428", "text": "Number of twos in row n of triangle A083093.", "sequence": "0,0,1,0,0,2,1,2,4,0,0,2,0,0,4,2,4,8,1,2,4,2,4,8,4,8,13,0,0,2,0,0,4,2,4,8,0,0,4,0,0,8,4,8,16,2,4,8,4,8,16,8,16,26,1,2,4,2,4,8,4,8,13,2,4,8,4,8,16,8,16,26,4,8,13,8,16,26,13,26,40", "code": "\nfrom sympy import binomial\ndef a(n):\n    return sum(1 for k in range(n + 1) if binomial(n, k) % 3 == 2)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A227491", "text": "The hyper-Wiener index of the nanostar dendrimer D_n, defined pictorially in the Ghorbani et al. references and recursively in the Deutsch et al. reference.", "sequence": "1932,305592,6162360,67702236,555929988,3858461844,24038223540,139011929844,761612920692,4005957732468,20412297267828,101407748443764,493489861416564,2360705148118644,11131067755529844,51842363941865076,238902338228766324", "code": "\ndef A227491(n): return 2**n*(2**n*(526338*n**2 - 2685555*n + 4790367) - 5719932)//8 + 116340 \n"}
{"sequence_id": "A227510", "text": "Numbers such that product of digits of n is positive and a substring of n.", "sequence": "1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,21,31,41,51,61,71,81,91,111,112,113,114,115,116,117,118,119,121,126,131,141,151,153,161,171,181,191,211,236,243,311,315,324,362,411,511,611,612", "code": "\nfrom operator import mul\nfrom functools import reduce\nA227510 = [int(n) for n in (str(x) for x in range(1,10**5)) if\n..........not n.count('0') and str(reduce(mul,(int(d) for d in n))) in n]\n\n"}
{"sequence_id": "A227774", "text": "Triangular array read by rows: T(n,k) is the number of rooted identity trees with n nodes having exactly k subtrees from the root.", "sequence": "1,1,1,1,1,2,1,3,3,6,5,1,12,11,2,25,22,5,52,49,12,113,104,28,2,247,232,65,4,548,513,152,13,1226,1159,351,34,2770,2619,818,91,1,6299,5989,1907,225,6,14426,13734,4460,571,18,33209,31729,10453,1403,57,76851", "code": "\nfrom sympy import binomial, Poly, Symbol\nfrom sympy.core.cache import cacheit\nx=Symbol('x')\n@cacheit\ndef b(n, i):return 1 if n==0 else 0 if i<1 else sum([binomial(b(i - 1, i - 1), j)*b(n - i*j, i - 1) for j in range(n//i + 1)])\n@cacheit\ndef g(n, i):return 1 if n==0 else 0 if i<1 else sum([x**j*binomial(b(i - 1, i - 1), j)*g(n - i*j, i - 1) for j in range(n//i + 1)])\ndef T(n): return [1] if n==1 else Poly(g(n - 1, n - 1)).all_coeffs()[::-1][1:]\nfor n in range(1, 26): print(T(n)) \n"}
{"sequence_id": "A227788", "text": "Sum of indices of Fibonacci numbers in Zeckendorf representation of n, assuming the units place is Fibonacci(2).", "sequence": "0,2,3,4,6,5,7,8,6,8,9,10,12,7,9,10,11,13,12,14,15,8,10,11,12,14,13,15,16,14,16,17,18,20,9,11,12,13,15,14,16,17,15,17,18,19,21,16,18,19,20,22,21,23,24,10,12,13,14,16,15,17,18,16,18,19,20,22,17,19,20", "code": "\nA003714 = [n for n in range(1, 300) if 2*n & n == 0]\nprint(0, end=',')\nfor a in A003714:\n  sum = 0\n  i = 2\n  while a:\n    if a&1:  sum += i\n    a >>= 1\n    i += 1\n  print(sum, end=',')\n"}
{"sequence_id": "A227802", "text": "Positive numbers of the form a^b +- 1 where a is in the sequence and b>1.", "sequence": "1,2,3,5,7,8,9,10,15,17,24,26,28,31,33,48,50,63,65,80,82,99,101,124,126,127,129,224,226,242,244,255,257,288,290,342,344,511,513,575,577,624,626,675,677,728,730,783,785,960,962,999,1001,1023,1025,1088,1090", "code": "\ndef func(i):\n.a=[2]\n.pows={2:2}\n.for rep in range(i):\n..for x in a[:]:\n...if not x**pows[x]-1 in a:\n....a.append(x**pows[x]-1)\n....pows[x**pows[x]-1]=2\n...if not x**pows[x]+1 in a:\n....a.append(x**pows[x]+1)\n....pows[x**pows[x]+1]=2\n...pows[x]+=1\n..a.sort()\n.return a\n"}
{"sequence_id": "A227864", "text": "Smallest base in which n's digital reversal is prime, or 0 if no such base exists.", "sequence": "0,0,3,2,0,2,2,2,4,6,2,2,2,2,2,3,8,2,3,3,2,3,2,2,2,2,2,9,2,2,6,2,4,3,2,3,12,2,6,3,2,2,6,2,2,3,2,2,2,3,2,9,2,2,3,2,2,3,2,4,12,2,2,3,12,3,6,2,2,3,10,2,6,2,2,3,10,2,26,3,2,27,2,2", "code": "\nfrom sympy import isprime\nfrom sympy.ntheory.digits import digits\ndef okb(n, b):\n    return isprime(sum(d*b**i for i, d in enumerate(digits(n, b)[1:])))\ndef a(n):\n    for b in range(2, n+2):\n        if okb(n, b): return b\n    return 0\nprint([a(n) for n in range(84)]) \n"}
{"sequence_id": "A227870", "text": "Numbers with equal number of even and odd digits.", "sequence": "10,12,14,16,18,21,23,25,27,29,30,32,34,36,38,41,43,45,47,49,50,52,54,56,58,61,63,65,67,69,70,72,74,76,78,81,83,85,87,89,90,92,94,96,98,1001,1003,1005,1007,1009,1010,1012,1014,1016,1018,1021,1023,1025", "code": "\ndef ok(i):\n  stri = str(i)\n  se = sum(1 for d in stri if d in \"02468\")\n  so = sum(1 for d in stri if d in \"13579\")\n  return se == so\ndef aupto(nn):\n  alst, an = [None], 0\n  for n in range(1, nn+1):\n    while len(alst) < nn+1:\n      if ok(an): alst.append(an)\n      an += 1\n  return alst[1:] \nprint(aupto(58))  \n"}
{"sequence_id": "A227902", "text": "Numbers n such that triangular(n) divides binomial(2n,n).", "sequence": "1,2,4,6,15,20,24,28,40,42,45,66,72,77,88,91,104,110,126,140,153,156,170,187,190,204,209,210,220,228,231,238,240,266,276,299,304,308,312,315,322,325,330,345,368,378,414,420,429,435,440,442,450,459,460,464,468,476,480", "code": "\nfrom sympy import binomial\nfor n in range(1, 444):\n    CBC = binomial(2 * n, n)\n    if not CBC % binomial(n + 1, 2):\n       print(n, end=\",\")\n"}
{"sequence_id": "A227947", "text": "Each term is a palindrome such that the sum of its proper divisors is a palindrome > 1.", "sequence": "4,6,8,9,333,646,656,979,1001,3553,10801,11111,18581,31713,34943,48484,57375,95259,99099,158851,262262,569965,1173711,1216121,1399931,1439341,1502051,1925291,3203023,3436343,3659563,3662663,3803083,3888883,5185815,5352535,5893985,5990995,6902096,9341439,9452549", "code": "\nfrom sympy import divisors\ndef pal(n):\n..r = ''\n..for i in str(n):\n....r = i + r\n..return r == str(n)\n{print(n,end=', ') for n in range(1,10**7) if pal(n) and pal(sum(divisors(n))-n) and len(divisors(n)) > 2}\n\n"}
{"sequence_id": "A227948", "text": "Zeroless numbers n such that n + (product of digits of n) and n - (product of digits of n) are prime.", "sequence": "21,23,27,29,81,83,253,293,299,343,347,349,431,437,439,471,473,477,529,623,653,659,677,743,893,1123,1219,1253,1257,1297,1423,1489,1521,1523,1529,1587,1589,1657,1763,1853,1867,1927,2151,2167,2239,2277,2279,2321,2327,2329,2377,2413,2443,2459,2467,2497,2543,2569", "code": "\nfrom sympy import isprime\ndef DP(n):\n..p = 1\n..for i in str(n):\n....p *= int(i)\n..return p\n{print(n,end=', ') for n in range(5000) if DP(n) and isprime(n+DP(n)) and isprime(n-DP(n))}\n\n"}
{"sequence_id": "A228000", "text": "Smallest prime factor of 144396166620968*n + 1.", "sequence": "3,7,5,3,17,11,3,5,7,3,29,47,3,2021546332693553,401,3,11,5,3,1013,31,3,5,27301567,3,23,419,3,179,7,3,13,5,3,61,1093,3,5,11,3,25665929,757,3,7,13,3,331,5,3,11,7,3,5,3613,3,17,6977,3,47,349,3,151,5,3,7", "code": "\nfrom sympy import factorint\ndef A228000(n):\n    return min(factorint(144396166620968*n + 1)) \n"}
{"sequence_id": "A228122", "text": "Smallest nonnegative number x such that x^2 + x + 41 has exactly n prime factors counting multiplicities.", "sequence": "0,40,420,1721,14144,139563,3019035,24304266,206583092,3838101265", "code": "\nfrom sympy import factorint\ndef A228122(n):\n    k = 0\n    while sum(factorint(k*(k+1)+41).values()) != n:\n        k += 1\n    return k \n"}
{"sequence_id": "A228126", "text": "Sum of prime divisors of n (with repetition) is one less than the sum of prime divisors (with repetition) of n+1.", "sequence": "2,3,4,9,20,24,98,170,1104,1274,2079,2255,3438,4233,4345,4716,5368,7105,7625,10620,13350,13775,14905,20220,21385,23408,25592,26123,28518,30457,34945,35167,38180,45548,49230,51911,52206,53456,56563,61456,65429,66585", "code": "\n\n\ni=2\nwhile i < 100000:\n..sdi=sumdivisors(i)\n..sdip=sumdivisors(i+1)\n..if sdi==sdip-1:\n....print i,i+1\n..i=i+1\n"}
{"sequence_id": "A228162", "text": "Number of bangbangs (!!) in shell substitution when starting with : '!!' and : \"!!\" '!!'", "sequence": "1,2,2,3,5,17,161,15681,159591041,16866847940875521,189345699699803478502456213711361", "code": "\nfor i, ai in enumerate([1, 2, 2, 3, 5]):\n....print '%d %d' % (i, ai)\np, q = 2, 4\nfor i in range(5, 15):\n....print '%d %d' % (i, 4*p + 2*q + 1)\n....p, q = 3*p*p + 2*p + p*q, 2*p*p + 2*p*q + 2*q\n"}
{"sequence_id": "A228196", "text": "A triangle formed like Pascal's triangle, but with n^2 on the left border and 2^n on the right border instead of 1.", "sequence": "0,1,2,4,3,4,9,7,7,8,16,16,14,15,16,25,32,30,29,31,32,36,57,62,59,60,63,64,49,93,119,121,119,123,127,128,64,142,212,240,240,242,250,255,256,81,206,354,452,480,482,492,505,511,512,100,287,560,806,932,962,974,997,1016,1023,1024", "code": "\ndef funcL(n):\n   q = n**2\n   return q\ndef funcR(n):\n   q = 2**n\n   return q\nfor n in range (1,9871):\n   t=int((math.sqrt(8*n-7) - 1)/ 2)\n   i=n-t*(t+1)/2-1\n   j=(t*t+3*t+4)/2-n-1\n   sum1=0\n   sum2=0\n   for m1 in range (1,i+1):\n      sum1=sum1+funcR(m1)*binomial(i+j-m1-1,i-m1)\n   for m2 in range (1,j+1):\n      sum2=sum2+funcL(m2)*binomial(i+j-m2-1,j-m2)\n   sum=sum1+sum2\n"}
{"sequence_id": "A228295", "text": "The 'Honeycomb' or 'Beehive' sequence: a(n) = ceiling(12^(1/4)*n).", "sequence": "0,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28,30,32,34,36,38,40,41,43,45,47,49,51,53,54,56,58,60,62,64,66,68,69,71,73,75,77,79,81,82,84,86,88,90,92,94,95,97,99,101,103,105,107,108,110,112,114,116,118,120,121", "code": "\nfrom sympy import integer_nthroot\ndef A228295(n): return 0 if n == 0 else 1+integer_nthroot(12*n**4,4)[0] \n"}
{"sequence_id": "A228369", "text": "Triangle read by rows in which row n lists the compositions (ordered partitions) of n in lexicographic order.", "sequence": "1,1,1,2,1,1,1,1,2,2,1,3,1,1,1,1,1,1,2,1,2,1,1,3,2,1,1,2,2,3,1,4,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,3,1,2,1,1,1,2,2,1,3,1,1,4,2,1,1,1,2,1,2,2,2,1,2,3,3,1,1,3,2,4,1,5,1,1,1,1,1,1", "code": "\na = [[[]], [[1]]]\nfor s in range(2, 9):\n    a.append([])\n    for k in range(1, s+1):\n        for ss in a[s-k]:\n            a[-1].append([k]+ss)\nprint(a)\n\n"}
{"sequence_id": "A228403", "text": "The number of boundary twigs for complete binary twigs. A twig is a vertex with one edge on the boundary and only one other descendant.", "sequence": "1,4,10,28,84,264,858,2860,9724,33592,117572,416024,1485800,5348880,19389690,70715340,259289580,955277400,3534526380,13128240840,48932534040,182965127280,686119227300,2579808294648,9723892802904,36734706144304,139067101832008,527495903500720,2004484433302736", "code": "\nfrom itertools import accumulate\ndef A228403_list(size):\n    if size < 1: return []\n    L, accu = [1], [2]\n    for _ in range(size-1):\n        accu = list(accumulate(accu + [accu[-1]]))\n        L.append(accu[-1])\n    return L\nprint(A228403_list(29))\n"}
{"sequence_id": "A228407", "text": "The digits of a(n) and a(n+1) together can be reordered to form a palindromic integer; the lexicographically earliest injective sequence of nonnegative integers with this property.", "sequence": "0,11,1,10,100,12,2,20,101,22,3,13,31,103,30,110,33,4,14,41,104,40,114,24,42,112,21,102,120,201,210,1000,105,15,5,25,52,115,35,53,113,23,32,121,26,6,16,61,106,60,116,36,63,131,34,43,134,143,314", "code": "\nfrom collections import Counter\nA228407_list, l, s, b = [0, 11], Counter('11'), 1, set([11])\nfor _ in range(10**2):\n....i = s\n....while True:\n........if i not in b:\n............li, o = Counter(str(i)), 0\n............for d in (l+li).values():\n................if d % 2:\n....................if o > 0:\n........................break\n....................o += 1\n............else:\n................A228407_list.append(i)\n................l = li\n................b.add(i)\n................while s in b:\n....................b.remove(s)\n....................s += 1\n................break\n........i += 1 \n"}
{"sequence_id": "A228410", "text": "The digits of a(n) and a(n+1) together can be reordered to form a palindrome; lexicographically least injective sequence of positive integers with this property.", "sequence": "1,10,100,11,2,12,21,102,20,101,22,3,13,31,103,30,110,33,4,14,41,104,40,114,24,42,112,23,32,113,34,43,131,35,5,15,51,105,50,115,25,52,121,26,6,16,61,106,60,116,36,63,136,163,316,361,613,631,1003,111,17,7,27,72,117,37,73,137,71,107", "code": "\nfrom collections import Counter\nA228410_list, l, s, b = [1], Counter('1'), 2, set()\nfor _ in range(10**2):\n....i = s\n....while True:\n........if i not in b:\n............li, o = Counter(str(i)), 0\n............for d in (l+li).values():\n................if d % 2:\n....................if o > 0:\n........................break\n....................o += 1\n............else:\n................A228410_list.append(i)\n................l = li\n................b.add(i)\n................while s in b:\n....................b.remove(s)\n....................s += 1\n................break\n........i += 1 \n"}
{"sequence_id": "A228421", "text": "Count of the first 10^n primes which do not contain the digit 9.", "sequence": "1,8,69,620,5010,45732,418142,3785060,32579606,296601070,2683254222,24354108057", "code": "\ndef a(n):\n    count = 0\n    for k in range(1,10**n+1):\n        if '9' not in str(prime(k)):\n            count += 1\n    return count\nn = 0\nwhile n < 10:\n    print(a(n), end=', ')\n    n += 1\n\n"}
{"sequence_id": "A228448", "text": "a(n) = floor(n!/3^n).", "sequence": "1,0,0,0,0,0,0,2,6,18,61,225,901,3905,18226,91134,486048,2754274,16525645,104662422,697749481,4884246371,35817806721,274603184861,2196825478892,18306878990770,158659617920008,1427936561280078,13327407905280733,128831609751047086", "code": "\nimport math\nfor n in range(99): print str(math.factorial(n)/(3**n))+',',\n"}
{"sequence_id": "A228449", "text": "floor(n! / 4^n).", "sequence": "1,0,0,0,0,0,0,0,0,1,3,9,28,92,324,1217,4871,20703,93166,442542,2212711,11616735,63892044,367379253,2204275523,13776722023,89548693155,604453678799,4231175751597,30676024199079,230070181493096,1783043906571497,14264351252571976", "code": "\nimport math\nfor n in range(99): print str(math.factorial(n)/(4**n))+',',\n"}
{"sequence_id": "A228628", "text": "9's complement of prime(n).", "sequence": "7,6,4,2,88,86,82,80,76,70,68,62,58,56,52,46,40,38,32,28,26,20,16,10,2,898,896,892,890,886,872,868,862,860,850,848,842,836,832,826,820,818,808,806,802,800,788,776,772,770,766,760,758,748,742,736,730,728", "code": "\nfrom sympy import primerange\ndef nc(n): return 10**len(str(n)) - 1 - n\ndef auptop(limit): return [nc(p) for p in primerange(1, limit+1)]\nprint(auptop(271)) \n"}
{"sequence_id": "A228640", "text": "a(n) = Sum_{d|n} phi(d)*n^(n/d).", "sequence": "0,1,6,33,280,3145,46956,823585,16781472,387422001,10000100440,285311670721,8916103479504,302875106592409,11112006930972780,437893890382391745,18446744078004651136,827240261886336764449,39346408075494964903956,1978419655660313589124321", "code": "\nfrom sympy import totient, divisors\ndef A228640(n):\n    return sum(totient(d)*n**(n//d) for d in divisors(n,generator=True)) \n"}
{"sequence_id": "A228768", "text": "Smallest number that is an emirp in all bases from 2 through n.", "sequence": "11,11,53,61,193,193,193,193,93836531,1963209431,14322793967831,14322793967831", "code": "\nfrom gmpy2 import is_prime, next_prime\ndef isemirp(n,b=10): \n....x, y = n, 0\n....while x >= b:\n........x, r = divmod(x,b)\n........y = y*b + r\n....y = y*b + x\n....return n != y and is_prime(y)\ndef A228768(n):\n....m = 1\n....while True:\n........m = next_prime(m)\n........for b in range(2,n+1):\n............if not isemirp(m,b):\n................break\n........else:\n............return m \n"}
{"sequence_id": "A228988", "text": "Smallest missing number in first 10^n digits after the decimal point in the expansion of Pi.", "sequence": "0,12,103,1001,10000,14523,106945,1001823,10007363,100023783,1000020346", "code": "\nstart = 0\nfor a in range(1,10):\n....with open(\"pi-billion.txt\",\"r\") as f:\n........g = f.read(10**a)\n....while g.find(str(start)) != -1:\n........start += 1\n....print(a,start)\n\n\n"}
{"sequence_id": "A229031", "text": "Number of 5-colorings of the strong product of the complete graph K2 and the cycle graph Cn.", "sequence": "120,0,2400,3840,63360,215040,1943040,9031680,64665600,346030080,2243911680,12792299520,79437987840,465890181120,2838290104320,16857940623360,101834835886080,608260231004160,3660556491816960,21919358464819200,131692072607416320,789448748118835200,4739507238312345600,28425784430470103040", "code": " def A229031(n) : return (2**n) * (3**n + 4*(-2)**n +5) \n"}
{"sequence_id": "A229037", "text": "The \"forest fire\": sequence of positive integers where each is chosen to be as small as possible subject to the condition that no three terms a(j), a(j+k), a(j+2k) (for any j and k) form an arithmetic progression.", "sequence": "1,1,2,1,1,2,2,4,4,1,1,2,1,1,2,2,4,4,2,4,4,5,5,8,5,5,9,1,1,2,1,1,2,2,4,4,1,1,2,1,1,2,2,4,4,2,4,4,5,5,8,5,5,9,9,4,4,5,5,10,5,5,10,2,10,13,11,10,8,11,13,10,12,10,10,12,10,11,14,20,13", "code": "\nA229037_list = []\nfor n in range(10**6):\n....i, j, b = 1, 1, set()\n....while n-2*i >= 0:\n........b.add(2*A229037_list[n-i]-A229037_list[n-2*i])\n........i += 1\n........while j in b:\n............b.remove(j)\n............j += 1\n....A229037_list.append(j) \n"}
{"sequence_id": "A229047", "text": "Replace all '11' => '101' in the binary representation of n, treat the result as representation of a(n) in base of Fibonacci numbers (A014417).", "sequence": "0,1,2,4,3,4,7,12,5,6,7,12,11,12,20,33,8,9,10,17,11,12,20,33,18,19,20,33,32,33,54,88,13,14,15,25,16,17,28,46,18,19,20,33,32,33,54,88,29,30,31,51,32,33,54,88,52,53,54,88,87,88,143,232,21,22,23,38,24,25,41", "code": "\nfib = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]\nfor n in range(333):\n  res = 0\n  bit = resbit = 1\n  while bit<=n:\n    if n&bit:  res += resbit\n    resbit*=2\n    if (n&bit) and (n&(bit*2)):  resbit*=2\n    bit*=2\n  \n  an = i = 0\n  while res:\n    if res&1:  an += fib[2+i]\n    i += 1\n    res >>= 1\n  print an,\n"}
{"sequence_id": "A229134", "text": "Square numbers that are the sum of two non-consecutive triangular numbers.", "sequence": "16,36,81,121,196,225,256,289,361,441,484,529,576,625,676,841,900,961,1024,1156,1225,1296,1444,1521,1600,1681,1849,1936,2116,2304,2401,2500,2601,2704,2809,2916,3136,3249,3481,3721,4096,4356,4624,4761,4900,5041,5184", "code": "\nfrom gmpy2 import is_square\nA229134_list = []\nfor i in range(10**3):\n    m, m2, j, k = 2, 4, 4*i**2+1, 2*i**2\n    while k >= m2 + m:\n        if is_square(j-m2):\n            A229134_list.append(i**2)\n            break\n        m2 += 2*m+1\n        m += 1 \n"}
{"sequence_id": "A229176", "text": "Primes p with nonzero digits such that p + product_of_digits and p - product_of_digits are both prime.", "sequence": "23,29,83,293,347,349,431,439,653,659,677,743,1123,1297,1423,1489,1523,1657,1867,2239,2377,2459,2467,2543,2579,2663,2753,3163,3253,3271,3329,3457,3461,3581,3691,3727,3833,3947,3967,4129,4253,4297,4423,4567,4957,5323,5381,5651", "code": "\nimport sympy\nfrom sympy import isprime\ndef DP(n):\n..p = 1\n..for i in str(n):\n....p *= int(i)\n..return p\n{print(n,end=', ') for n in range(10**4) if DP(n) and isprime(n) and isprime(n+DP(n)) and isprime(n-DP(n))}\n\n"}
{"sequence_id": "A229183", "text": "a(n) = n*(n^2 + 3)/2.", "sequence": "0,2,7,18,38,70,117,182,268,378,515,682,882,1118,1393,1710,2072,2482,2943,3458,4030,4662,5357,6118,6948,7850,8827,9882,11018,12238,13545,14942,16432,18018,19703,21490,23382,25382,27493,29718,32060,34522,37107,39818", "code": "\n{print((n**3+3*n)/2,end=', ') for n in range(0,100)} \n"}
{"sequence_id": "A229184", "text": "Numbers decremented by their digit product produce a cube.", "sequence": "0,1,2,3,4,5,6,7,8,9,71,145,167,264,361,757,1000,1439,1791,2233,3525,3627,3959,4096,4864,4995,6677,8000,8128,8672,9575,10648,14848,23488,24976,25199,25829,26549,27000,27224,35648,39304,43235,50653,53893,64000,74088,79507,91215,93285,94365", "code": "\ndef DP(n):\n..p = 1\n..for i in str(n):\n....p *= int(i)\n..return p\nfor n in range(10**4):\n..k = 0\n..P = n - DP(n)\n..while P >= k**3:\n....if P == k**3:\n......print(n,end=', ')\n......break\n....k += 1\n\n"}
{"sequence_id": "A229185", "text": "Numbers incremented by their digit product produce a cube.", "sequence": "0,4,85,168,184,212,368,549,681,919,999,1000,1283,1593,2181,3664,4096,4717,6811,7497,8000,9919,10648,12143,15275,15425,21664,21728,21824,27000,39304,42427,42811,47629,50653,63424,64000,74088,79507,84416,103823,110592", "code": "\ndef DP(n):\n..p = 1\n..for i in str(n):\n....p *= int(i)\n..return p\nfor n in range(10**4):\n..k = 0\n..P = n + DP(n)\n..while P >= k**3:\n....if P == k**3:\n......print(n, end=', ')\n......break\n....k += 1\n\n"}
{"sequence_id": "A229190", "text": "Beginning position of n in the decimal expansion of the Copeland-Erdos constant.", "sequence": "48,5,1,2,21,3,31,4,41,12,47,5,62,7,22,77,32,9,95,11,589,110,113,1,128,131,137,63,149,15,158,8,14,123,24,2,188,19,42,72,206,21,215,23,227,233,236,25,248,75,257,78", "code": "\nfrom sympy import primerange\nfrom itertools import count, takewhile\ndef afind(plimit):\n  s = \"\".join(str(p) for p in primerange(1, plimit+1))\n  return [1+s.find(str(n)) for n in takewhile(lambda i: str(i) in s, count(0))]\nprint(afind(10**4)) \n"}
{"sequence_id": "A229221", "text": "Numbers n such that n - (product of digits of n) is prime.", "sequence": "21,23,27,29,41,43,47,49,81,83,87,89,101,103,107,109,127,141,143,149,181,187,223,227,229,241,247,251,253,263,271,277,293,299,307,343,347,349,367,383,389,401,409,413,417,419,431,433,437,439,451,457,471,473,477,479,481,487,503,509,527,529,541", "code": "\nfrom sympy import isprime\ndef DP(n):\n    p = 1\n    for i in str(n):\n        p *= int(i)\n    return p\n{print(n,end=', ') for n in range(10**3) if isprime(n-DP(n))}\n\n"}
{"sequence_id": "A229269", "text": "Numbers n for which n-n' is prime, n' being the arithmetic derivative of n.", "sequence": "3,9,10,14,15,21,26,33,35,38,39,50,51,62,65,66,69,70,77,78,86,91,93,95,102,110,111,114,122,123,129,130,133,138,146,154,159,161,170,174,190,201,203,206,209,213,215,217,218,221,222,230,238,249,258,278,282,287", "code": "\nfrom sympy import isprime, factorint\nA229269 = [n for n in range(1,10**4) if isprime(n-sum([int(n*e/p) for p,e in factorint(n).items()]))] \n"}
{"sequence_id": "A229270", "text": "Numbers n for which n\u2019-n is prime, n' being the arithmetic derivative of n.", "sequence": "18,210,315,330,390,462,510,546,690,726,798,870,930,966,1110,1218,1230,1290,1302,1554,1590,1770,2010,2130,2190,2310,2370,2490,2730,2910,3030,3210,3270,3570,3810,4110,4290,4470,4530,4830,4890,5010,5430,5790,5910,5970", "code": "\nfrom sympy import isprime, factorint\nA229270 = [n for n in range(1,10**5) if isprime(sum([int(n*e/p) for p,e in factorint(n).items()])-n)] \n"}
{"sequence_id": "A229272", "text": "Numbers n for which n' + n and n' - n are both prime, n' being the arithmetic derivative of n.", "sequence": "210,330,390,690,798,966,1110,1230,2190,2310,2730,3270,4110,4530,4890,5430,6090,6270,6810,6990,7230,7890,8310,8490,9030,9210,9282,10470,10590,10770,12090,12210,12270,12570,12810,12930,13110,13830,14070,17070,17094,17310", "code": "\nfrom sympy import isprime, factorint\nA229272 = []\nfor n in range(1,10**5):\n....np = sum([int(n*e/p) for p,e in factorint(n).items()]) if n > 1 else 0\n....if isprime(np+n) and isprime(np-n):\n........A229272.append(n)\n\n"}
{"sequence_id": "A229294", "text": "Number of solutions to x^2 + y^2 + z^2 + t^2 == n (mod 2*n) for x,y,z,t in [0, 2*n).", "sequence": "8,96,264,384,1160,3168,3080,1536,7560,13920,11528,12672,18824,36960,38280,6144,41480,90720,57608,55680,101640,138336,101384,50688,149000,225888,208008,147840,201608,459360,245768,24576,380424,497760,446600,362880,415880", "code": "\ndef A229294(n):\n    ndict = {}\n    n2 = 2*n\n    for i in range(n2):\n        i3 = pow(i,2,n2)\n        for j in range(i+1):\n            j3 = pow(j,2,n2)\n            m = (i3+j3) % n2\n            if m in ndict:\n                if i == j:\n                    ndict[m] += 1\n                else:\n                    ndict[m] += 2\n            else:\n                if i == j:\n                    ndict[m] = 1\n                else:\n                    ndict[m] = 2\n    count = 0\n    for i in ndict:\n        j = (n-i) % n2\n        if j in ndict:\n            count += ndict[i]*ndict[j]\n    return count \n"}
{"sequence_id": "A229544", "text": "Numbers n such that n*product_of_digits(n) is a nonzero cube.", "sequence": "1,8,243,784,7776,9826,13122,24389,26244,39366,47628,55566,59895,71442,82944,122825,124416,226981,263424,275625,316368,323433,333396,588245,663255,774144,843648,1339893,1492992,1613472,2341344,3816336,3981312,8719893,8992364,9393931,9927988,11212884,11239424,14823774", "code": "\ndef DP(n):\n..p = 1\n..for i in str(n):\n....p *= int(i)\n..return p\ndef a(n):\n..k = 0\n..while k < n:\n....if k**3 == n*DP(n):\n......return n\n....if k**3 > n*DP(n):\n......return 0\n....k += 1\nn = 1\nwhile n < 10**6:\n..if a(n):\n....print(n, end=', ')\n..n += 1\n\n"}
{"sequence_id": "A229545", "text": "Numbers n such that n + (sum of digits of n) is a palindrome.", "sequence": "0,1,2,3,4,10,20,30,40,50,60,70,80,90,91,96,100,105,124,129,143,148,162,167,181,191,196,200,205,224,229,243,248,262,267,281,291,296,300,305,324,329,343,348,362,367,381,391,396,400,405,424,429,443,448,462", "code": "\ndef ispal(n):\n..r = ''\n..for i in str(n):\n....r = i + r\n..return n == int(r)\ndef DS(n):\n..s = 0\n..for i in str(n):\n....s += int(i)\n..return s\n{print(n,end=', ') for n in range(10**3) if ispal(n+DS(n))}\n\n"}
{"sequence_id": "A229546", "text": "Numbers n such that n + product_of_digits(n) is a palindrome.", "sequence": "0,1,2,3,4,16,28,39,43,64,89,101,127,163,166,174,179,188,202,214,236,247,252,296,303,329,341,348,354,359,366,372,385,387,393,404,426,442,445,455,463,465,489,505,525,536,546,567,568,571,578,589,591,606,618,622,629,658,659,664,667,707,734,749,753,808,812", "code": "\ndef rev(n):\n    return int(''.join(reversed(str(n))))\ndef DP(n):\n    p = 1\n    for i in str(n):\n        p *= int(i)\n    return p\n{print(n,end=', ') for n in range(10**3) if rev(n+DP(n))==n+DP(n)}\n\n"}
{"sequence_id": "A229547", "text": "Numbers n such that n - product_of_digits(n) is a palindrome.", "sequence": "0,1,2,3,4,5,6,7,8,9,29,34,46,57,61,78,82,93,101,129,143,187,202,218,226,244,247,252,269,294,297,303,319,336,348,357,361,364,386,404,412,419,437,453,462,488,505,514,519,524,534,539,544,554,564,574,584,594,597,606,613,615,617,619,625,635,638,645,655,663", "code": "\ndef rev(n):\n    return int(''.join(reversed(str(n))))\ndef DP(n):\n    p = 1\n    for i in str(n):\n        p *= int(i)\n    return p\n{print(n, end=', ') for n in range(10**3) if n-DP(n)==rev(n-DP(n))}\n\n"}
{"sequence_id": "A229549", "text": "Numbers n such that n*(sum of digits of n) is a palindrome.", "sequence": "0,1,2,3,11,22,42,53,56,101,111,113,121,124,182,187,202,272,353,434,515,572,616,683,739,829,888,1001,1111,1357,1507,1508,1624,1717,2002,2074,2852,3049,3146,3185,3326,3342,3687,3747,4058,4066,4391,4719,4724,5038,7579,8569,9391,9471", "code": "\ndef ispal(n):\n..r = ''\n..for i in str(n):\n....r = i + r\n..return n == int(r)\ndef DS(n):\n..s = 0\n..for i in str(n):\n....s += int(i)\n..return s\n{print(n, end=', ') for n in range(10**4) if ispal(n*DS(n))}\n\n"}
{"sequence_id": "A229550", "text": "Numbers n with nonzero digits such that n*(product of digits of n) is a palindrome.", "sequence": "1,2,3,11,19,22,35,37,77,111,115,116,121,131,212,464,671,731,1111,1221,1229,2112,4136,4147,6346,9832,11111,11151,11161,11211,11311,12121,12477,12692,12734,17951,18619,21112,22622", "code": "\ndef ispal(n):\n..r = ''\n..for i in str(n):\n....r = i + r\n..return n == int(r)\ndef DP(n):\n..p = 1\n..for i in str(n):\n....p *= int(i)\n..return p\n{print(n,end=', ') for n in range(10**4) if DP(n) and ispal(n*DP(n))}\n\n"}
{"sequence_id": "A229621", "text": "Numbers n such that n - (sum of digits of n) is a palindrome.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,100,101,102,103,104,105,106,107,108,109,180,181,182,183,184,185,186,187,188,189,260,261,262,263,264,265,266,267,268,269,340,341,342,343,344,345,346,347,348,349,420,421,422,423,424,425,426", "code": "\ndef ispal(n):\n..r = ''\n..for i in str(n):\n....r = i + r\n..return n == int(r)\ndef DS(n):\n..s = 0\n..for i in str(n):\n....s += int(i)\n..return s\n{print(n,end=', ') for n in range(10**3) if ispal(n-DS(n))}\n\n"}
{"sequence_id": "A229622", "text": "Palindromes m such that m + (sum of digits of m) is also a palindrome.", "sequence": "0,1,2,3,4,181,191,262,343,424,505,696,767,848,929,28999999999982,37999999999973,46999999999964,55999999999955,64999999999946,73999999999937,82999999999928,91999999999919,1099999999999901", "code": "\ndef ispal(n):\n..r = ''\n..for i in str(n):\n....r = i + r\n..return n == int(r)\ndef DS(n):\n..s = 0\n..for i in str(n):\n....s += int(i)\n..return s\n{print(n,end=', ') for in range(10**7) if ispal(n) and ispal(n+DS(n))}\n\n"}
{"sequence_id": "A229623", "text": "Palindromes m such that m - sum_of_digits(m) is also a palindrome.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,101,181,262,343,424,686,767,848,929,1001,10001,100001,1000001,10000001,100000001,1000000001,10000000001,100000000001,1000000000001", "code": "\ndef pal(n):\n..r = ''\n..for i in str(n):\n....r = i + r\n..return r == str(n)\ndef DS(n):\n..s = 0\n..for i in str(n):\n....s += int(i)\n..return s\n{print(n,end=', ') for n in range(10**6) if pal(n) and pal(n-DS(n))}\n\n"}
{"sequence_id": "A229761", "text": "Zeroless numbers n such that n and n - (product of digits of n) are both palindromes.", "sequence": "1,2,3,4,5,6,7,8,9,252,676,777,838,868,919,929,939,15451,15851,25152,25252,25352,25452,25552,25652,25752,25852,25952,29592,36563,51415,51815,52125,52225,52325,52425,52525,52625,52725,52825,52925,63536,92529,93939,97779,1455541,1545451,1558551,1594951", "code": "\ndef DP(n):\n..p = 1\n..for i in str(n):\n....p *= int(i)\n..return p\ndef pal(n):\n..r = ''\n..for i in str(n):\n....r = i + r\n..return r == str(n)\n{print(n,end=', ') for n in range(1,10**6) if DP(n) and pal(n) and pal(n-DP(n))}\n\n"}
{"sequence_id": "A229762", "text": "a(n) = (n XOR floor(n/2)) AND floor(n/2), where AND and XOR are bitwise logical operators.", "sequence": "0,0,1,0,2,2,1,0,4,4,5,4,2,2,1,0,8,8,9,8,10,10,9,8,4,4,5,4,2,2,1,0,16,16,17,16,18,18,17,16,20,20,21,20,18,18,17,16,8,8,9,8,10,10,9,8,4,4,5,4,2,2,1,0,32,32,33,32,34,34,33,32,36,36,37,36,34,34,33", "code": "\nfor n in range(333): print (n ^ (n>>1)) & (n>>1),\n"}
{"sequence_id": "A229763", "text": "a(n) = (2*n) XOR n AND n, where AND and XOR are bitwise logical operators.", "sequence": "0,1,2,1,4,5,2,1,8,9,10,9,4,5,2,1,16,17,18,17,20,21,18,17,8,9,10,9,4,5,2,1,32,33,34,33,36,37,34,33,40,41,42,41,36,37,34,33,16,17,18,17,20,21,18,17,8,9,10,9,4,5,2,1,64,65,66,65,68,69,66,65,72,73,74", "code": "\nfor n in range(333): print (2*n ^ n) & n,\n"}
{"sequence_id": "A229804", "text": "Zeroless numbers n such that n and n*product_of_digits(n) are both palindromes.", "sequence": "1,2,3,11,22,77,111,121,131,212,464,1111,1221,2112,11111,11211,11311,12121,21112,22622,111111,112211,121121,211112,1111111,1112111,1113111,1121211,1211121,2111112,2223222,4213124,11111111,11122111,11211211,12111121,21111112", "code": "\ndef pal(n):\n..r = ''\n..for i in str(n):\n....r = i + r\n..return r == str(n)\ndef DP(n):\n..p = 1\n..for i in str(n):\n....p *= int(i)\n..return p\n{print(n,end=', ') for n in range(1,10**6) if DP(n)*pal(n)*pal(n*DP(n))}\n\n"}
{"sequence_id": "A229805", "text": "Palindromes m such that m*(sum of digits of m) is also a palindrome.", "sequence": "0,1,2,3,11,22,101,111,121,202,272,353,434,515,616,888,1001,1111,2002,10001,10101,10201,10901,11011,11111,11711,12521,13331,14141,20002,20702,21512,22322,23132,30503,31313,32123,40304,41114,50105,100001,101101,110011,111111,200002,888888", "code": "\ndef pal(n):\n..r = ''\n..for i in str(n):\n....r = i + r\n..return r == str(n)\ndef DS(n):\n..s = 0\n..for i in str(n):\n....s += int(i)\n..return s\n{print(n,end=', ') for n in range(10**6) if pal(n)*pal(n*DS(n))}\n\n"}
{"sequence_id": "A229836", "text": "Number of primes between n! and n^n inclusive.", "sequence": "0,2,6,45,415,4693,65010,1073640,20669837,454793822,11259684418,309761863916,9373389023182,309374515194621,11059527891811334,425655578031419604", "code": "\nimport math\nimport sympy\nfrom sympy import sieve\nx = 1\nwhile x < 50:\n....y = [i for i in sieve.primerange(math.factorial(x),x**x)]\n....print(len(y))\n....x += 1\n"}
{"sequence_id": "A229909", "text": "Triangular numbers t such that the following are three triangular numbers: x, y, x+y, where x and y are distances from t to the two nearest squares.", "sequence": "1,2080,8038045", "code": "\nimport math\ndef isTriangular(a):\n    a+=a\n    sr = int(math.sqrt(a))\n    return (a==sr*(sr+1))\nfor n in range(1,1000000000L):\n    tn = n*(n+1)/2  \n    if tn&1:\n        k = tn>>1\n        k*= k       \n        a = int(math.sqrt(k*2))\n        t = a*(a+1)/2\n        if t <= k:\n            a+=1\n            t+=a\n        ktn = k+tn   \n        while t <= ktn:  \n            if isTriangular(t-k) and isTriangular(ktn-t):\n                print t\n            a+=1\n            t+=a\n    if (n&0xfffff)==0: print '.',\n"}
{"sequence_id": "A229970", "text": "Numbers n such that the product of their proper divisors is a palindrome > 1 and not equal to n.", "sequence": "4,9,25,49,121,212,1001,2636,10201,17161,22801,32761,36481,97969,110011,124609,139129,146689,528529,573049,619369,635209,844561,863041,1100011,10100101,11000011,101000101,106110601,110000011,110271001,112381201,127938721,130210921", "code": "\nfrom sympy import divisors\ndef PD(n):\n..p = 1\n..for i in divisors(n):\n....if i != n:\n......p *= i\n..return p\ndef pal(n):\n..r = ''\n..for i in str(n):\n....r = i + r\n..return r == str(n)\n{print(n,end=', ') for n in range(1,10**4) if pal(PD(n)) and (PD(n)-1) and PD(n)-n}\n\n"}
{"sequence_id": "A229971", "text": "Palindromes n whose product of proper divisors is a palindrome > 1 and not equal to n.", "sequence": "4,9,121,212,1001,10201,110011,1100011,10100101,11000011,101000101,110000011,1010000101,1100000011,10000000001,10100000101,1000000000001,10000000000001,10011100000111001,10022212521222001,10100101110100101,10101100100110101", "code": "\nfrom sympy import divisors\ndef PD(n):\n..p = 1\n..for i in divisors(n):\n....if i != n:\n......p *= i\n..return p\n....return p\ndef pal(n):\n..r = ''\n..for i in str(n):\n....r = i + r\n..return r == str(n)\n{print(n,end=', ') for n in range(1,10**6) if pal(n) and pal(PD(n)) and (PD(n)-1) and PD(n)-n}\n\n"}
{"sequence_id": "A229972", "text": "Nonprime numbers n such that the product of their proper divisors is a perfect cube.", "sequence": "1,8,16,24,27,30,40,42,54,56,64,66,70,78,81,88,102,104,105,110,114,125,128,130,135,136,138,152,154,165,170,174,182,184,186,189,190,192,195,216,222,230,231,232,238,240,246,248,250,255,258,266,273,282,285", "code": "\nfrom gmpy2 import iroot\nfrom sympy import divisor_count, isprime\nA229972_list = [i for i in range(1,10**3) if not isprime(i) and (iroot(i,3)[1] or divisor_count(i) % 3 == 2)] \n"}
{"sequence_id": "A230026", "text": "Primes p such that f(f(p)) is prime, where f(n) = n^2-n-1 = A165900(n).", "sequence": "3,13,23,53,59,83,107,167,173,179,211,223,229,257,317,349,367,431,443,487,503,509,541,571,613,617,673,677,683,751,823,1021,1031,1093,1103,1109,1123,1201,1231,1289,1301,1319,1361,1373,1427,1451", "code": "\nimport sympy\nfrom sympy import isprime\ndef f(x):\n    return x**2-x-1\n{p for p in range(10**4) if isprime(p) and isprime(f(f(p)))}\n"}
{"sequence_id": "A230027", "text": "Primes p such that f(f(p)) is prime, where f(x) = x^3-x^2-x-1.", "sequence": "29,53,79,83,149,167,193,227,283,311,317,401,709,907,953,1093,1327,1427,1511,1579,1613,1663,1801,1901,1987,2027,2029,2293,2341,2741,2887,3083,3163,3229,3329,3511,3733,4007,4127,4153,4337,4789,5531", "code": "\nimport sympy\nfrom sympy import isprime\ndef f(x):\n..return x**3-x**2-x-1\n{print(p) for p in range(10**4) if isprime(p) and isprime(f(f(p)))}\n"}
{"sequence_id": "A230029", "text": "Primes p such that f(f(p)) is prime, where f(x) = x^4-x^3-x^2-x-1.", "sequence": "3,487,547,877,1063,1291,1579,1657,2287,2797,3343,3793,4909,4957,6163,6571,7393,8461,8521,8563,9631,11257,11863,12211,12757,12907,13063,13567,13999,14983,15427,15739,16087,16651,16699,17419,17713,17977", "code": "\nimport sympy\nfrom sympy import isprime\ndef f(x):\n..return x**4-x**3-x**2-x-1\n{print(p) for p in range(10**5) if isprime(p) and isprime(f(f(p)))}\n"}
{"sequence_id": "A230115", "text": "Numbers n such that tau(n+1) - tau(n) = 2; where tau(n) = the number of divisors of n (A000005).", "sequence": "5,7,13,27,37,51,61,62,73,74,91,115,123,146,153,157,164,187,188,193,206,235,245,267,274,277,278,284,291,313,355,356,362,369,386,397,403,411,421,422,423,425,427,428,451,457,538,541,605,613,637,657,661,667,673", "code": "\nfrom sympy.ntheory import divisor_count\n[n for n in range(1000) if divisor_count(n + 1) - divisor_count(n) == 2] \n"}
{"sequence_id": "A230282", "text": "Largest k such that (k*n)! >= (k!)^(n+1).", "sequence": "1,1,6,64,679,8468,126784,2238565,45605124,1053117974,27182818156,775557529509,24236473829015,823299898542083,30205566231626957,1190319005015526817,50143449209799256306,2248672171655330927835", "code": "\nimport math\nfor n in range(8):\n  for k in range(10000000):\n    if math.factorial(n*k) < math.factorial(k)**(n+1):\n      print k-1,\n      break\n"}
{"sequence_id": "A230319", "text": "Least positive k such that k! > k^n.", "sequence": "2,3,4,6,7,8,10,11,12,14,15,16,18,19,20,22,23,24,25,27,28,29,31,32,33,34,36,37,38,39,41,42,43,44,46,47,48,49,51,52,53,54,55,57,58,59,60,62,63,64,65,67,68,69,70,71,73,74,75,76,78,79,80,81,82,84,85,86,87,88", "code": "\nimport math\nfor n in range(333):\nfor k in range(1,100000):\n    if math.factorial(k) > k**n:\n      print str(k)+',',\n      break\n"}
{"sequence_id": "A230363", "text": "Factorials representable as b^2 + triangular(c).", "sequence": "1,1,2,6,24,120,362880,3628800,39916800,479001600,6227020800,1307674368000,121645100408832000", "code": "\nimport math\nf=1\nfor n in range(1, 1000000):\n    f *= n\n    t = b = 0\n    while t<=f:\n        x = f-t\n        a = int(math.sqrt(x))\n        if a*a==x:\n            print str(f)+',',\n            break\n        b += 1\n        t = b*(b+1)/2\n"}
{"sequence_id": "A230364", "text": "Triangular numbers representable as b! + c^2.", "sequence": "1,3,6,10,15,28,55,66,105,120,136,171,231,325,406,465,561,820,1081,1770,2016,2145,2211,3160,3321,5778,7750,11026,13041,13695,15400,17020,23220,34716,41616,55945,60031,70876,75078,100576,106953,126756,196251,260281,263175,374545", "code": "\nimport math\nfactorials = [1] * 1024\nf = 1\nfor n in range(2, 1025):\n    f *= n\n    factorials[n-1] = f\nfor n in range(1L<<30):\n    t = n*(n+1)/2\n    for a in factorials:\n        r = t - a\n        if r<0: break\n        b = int(math.sqrt(r))\n        if b*b==r:\n            print str(t)+',',\n            break\n"}
{"sequence_id": "A230365", "text": "Squares representable as b! + triangular(c).", "sequence": "1,4,9,16,25,121,144,196,225,256,324,441,529,900,1296,4096,4489,5041,5476,6561,7056,10609,14884,15625,17956,28561,42025,44100,46656,53361,136900,139129,143641,152100,184041,220900,222784,360000,370881,404496,443556,505521,609961", "code": "\nimport math\nfactorials = [1] * 1024\nf = 1\nfor n in range(2, 1025):\n    f *= n\n    factorials[n-1] = f\nfor n in range(1L<<30):\n    t = n*n\n    for a in factorials:\n        r = t - a\n        if r<0: break\n        b = int(math.sqrt(2*r))\n        if b*(b+1)==r*2:\n            print str(t)+',',\n            break\n"}
{"sequence_id": "A230625", "text": "Concatenate prime factorization written in binary, convert back to decimal.", "sequence": "1,2,3,10,5,11,7,11,14,21,11,43,13,23,29,20,17,46,19,85,31,43,23,47,22,45,15,87,29,93,31,21,59,81,47,174,37,83,61,93,41,95,43,171,117,87,47,83,30,86,113,173,53,47,91,95,115,93,59,349,61,95,119,22", "code": "\nimport sympy\n[int(''.join([bin(y)[2:] for x in sorted(sympy.ntheory.factorint(n).items()) for y in x if y != 1]),2) for n in range(2,100)] \n\n"}
{"sequence_id": "A230664", "text": "Floor(3^n / n^2).", "sequence": "3,2,3,5,9,20,44,102,243,590,1464,3690,9433,24402,63772,168151,446851,1195742,3219560,8716961,23719621,64836900,177964421,490329056,1355661775,3760156550,10460353203,29179582212,81605680576,228767924549,642740266684,1809590028175", "code": "\nfor n in range(1,100):  print str(3**n // n**2)+',',\n"}
{"sequence_id": "A230891", "text": "Working in base 2: a(0)=0, thereafter a(n+1) is the smallest number not already in the sequence such that the bits of a(n) and a(n+1) together can be rearranged to form a palindrome.", "sequence": "0,11,1,10,100,111,1000,101,110,1001,1010,1100,1111,10000,1011,1101,1110,10001,10010,10100,10111,11000,11011,11101,11110,100000,10011,10101,10110,11001,11010,11100,11111,100001,100010,100100,100111,101000,101011,101101,101110,110000,110011,110101,110110,111001", "code": "\nfrom collections import Counter\nA230891_list, l, s, b = [0, 11], Counter('11'), 1, {3}\nfor _ in range(30001):\n    i = s\n    while True:\n        if i not in b:\n            li, o = Counter(bin(i)[2:]), 0\n            for d in (l+li).values():\n                if d % 2:\n                    if o > 0:\n                        break\n                    o += 1\n            else:\n                A230891_list.append(int(bin(i)[2:]))\n                l = li\n                b.add(i)\n                while s in b:\n                    b.remove(s)\n                    s += 1\n                break\n        i += 1 \n"}
{"sequence_id": "A230892", "text": "Terms of A230891 written in base 10: the binary expansions of a(n) and a(n+1) taken together can be rearranged to form a palindrome.", "sequence": "0,3,1,2,4,7,8,5,6,9,10,12,15,16,11,13,14,17,18,20,23,24,27,29,30,32,19,21,22,25,26,28,31,33,34,36,39,40,43,45,46,48,51,53,54,57,58,60,63,64,35,37,38,41,42,44,47,49,50,52,55,56,59,61,62,65,66,68,71", "code": "\nfrom collections import Counter\nA230892_list, l, s, b = [0, 3], Counter('11'), 1, {3}\nfor _ in range(30001):\n    i = s\n    while True:\n        if i not in b:\n            li, o = Counter(bin(i)[2:]), 0\n            for d in (l+li).values():\n                if d % 2:\n                    if o > 0:\n                        break\n                    o += 1\n            else:\n                A230892_list.append(i)\n                l = li\n                b.add(i)\n                while s in b:\n                    b.remove(s)\n                    s += 1\n                break\n        i += 1 \n"}
{"sequence_id": "A230962", "text": "Values of x such that x^2 + y^2 = 73^n with x and y coprime and 0 < x < y.", "sequence": "3,48,296,721,10072,213785,1958709,7613760,21165597,894454032,12278087704,59926173839,62518379032,3374316625735,58552907681096,416603004343680,1261259807092797,10231862403603888,255781764375436389,2697529798981443601,11543491568219853608", "code": "\nfrom sympy import I, re, im\nprint([min(abs(re((3 + 8*I)**n)), abs(im((3 + 8*I)**n))) for n in range(1, 31)]) \n"}
{"sequence_id": "A230963", "text": "Values of y such that x^2 + y^2 = 73^n with x and y coprime and 0 < x < y.", "sequence": "8,55,549,5280,44403,325008,2685304,27358559,241709752,1870181225,12766175931,138963670560,1291487885997,10519458225072,74032715923371,690521409218881,6773980286782088,57975621715535095,433109386513469096,3345582274543898400", "code": "\nfrom sympy import I, re, im\nprint([max(abs(re((3 + 8*I)**n)), abs(im((3 + 8*I)**n))) for n in range(1, 31)]) \n"}
{"sequence_id": "A231354", "text": "Least k such that n - triangular(k) is a square, or -1 if no such k exists.", "sequence": "0,0,1,2,0,1,3,2,-1,0,1,4,2,-1,4,3,0,1,-1,2,-1,6,3,-1,5,0,1,-1,2,7,6,3,7,-1,-1,4,0,1,-1,2,5,-1,3,-1,7,8,4,-1,-1,0,1,5,2,7,9,3,10,6,-1,4,-1,8,-1,-1,0,1,11,2,-1,-1,3,10,8,-1,4,11,-1,7,12,5,10,0", "code": "\nimport math\nfor n in range(333):\nfor k in range(1000000):\n    t = n - k*(k+1)/2\n    if t<0:\n      print '-1,',\n      break\n    r = int(math.sqrt(t))\n    if r*r==t:\n      print str(k)+',',\n      break\n"}
{"sequence_id": "A231426", "text": "Least prime such that at most n digits may be appended to the right, preserving primality at each step.", "sequence": "53,11,97,17,71,43,13,2,19,103,409,1457011,2744903797,5232781111", "code": "\nfrom sympy import isprime, nextprime\ndef a(n):\n    p = 2\n    while True:\n        extends, reach = -1, {p}\n        while len(reach) > 0:\n            candidates = (int(str(e)+d) for d in \"1379\" for e in reach)\n            reach1 = set(filter(isprime, candidates))\n            extends, reach = extends + 1, reach1\n        if extends == n: return p\n        p = nextprime(p)\nfor n in range(12): print(a(n), end=\", \") \n"}
{"sequence_id": "A231550", "text": "Permutation of nonnegative integers: for each bit[i] in the binary representation, except the most and the least significant bits, set bit[i] = bit[i] XOR bit[i-1], where bit[i-1] is the less significant bit, XOR is the binary logical exclusive or operator.", "sequence": "0,1,2,3,4,7,6,5,8,11,14,13,12,15,10,9,16,19,22,21,28,31,26,25,24,27,30,29,20,23,18,17,32,35,38,37,44,47,42,41,56,59,62,61,52,55,50,49,48,51,54,53,60,63,58,57,40,43,46,45,36,39,34,33,64,67,70,69,76", "code": "\nfor n in range(99):\n  bits = [0]*64\n  orig = [0]*64\n  l = int.bit_length(int(n))\n  t = n\n  for i in range(l):\n    bits[i] = orig[i] = t&1\n    t>>=1\n  for i in range(1, l-1):  bits[i] ^= orig[i-1]   \n  \n  \n  \n  t = 0\n  for i in range(l):  t += bits[i]<<i\n  print(str(t), end=',')\n"}
{"sequence_id": "A231551", "text": "Position of n in A231550.", "sequence": "0,1,2,3,4,7,6,5,8,15,14,9,12,11,10,13,16,31,30,17,28,19,18,29,24,23,22,25,20,27,26,21,32,63,62,33,60,35,34,61,56,39,38,57,36,59,58,37,48,47,46,49,44,51,50,45,40,55,54,41,52,43,42,53,64,127,126,65", "code": "\nfor n in range(99):\n  bits = [0]*64\n  orig = [0]*64\n  l = long.bit_length(long(n))\n  t = n\n  for i in range(l):\n    bits[i] = orig[i] = t&1\n    t>>=1\n  \n  for i in range(1, l-1):  bits[i] ^= bits[i-1]   \n  \n  \n  t = 0\n  for i in range(l):  t += bits[i]<<i\n  print str(t)+',',\n"}
{"sequence_id": "A231599", "text": "T(n,k) is the coefficient of x^k in Product_{i=1..n} (1-x^i); triangle T(n,k), n >= 0, 0 <= k <= A000217(n), read by rows.", "sequence": "1,1,-1,1,-1,-1,1,1,-1,-1,0,1,1,-1,1,-1,-1,0,0,2,0,0,-1,-1,1,1,-1,-1,0,0,1,1,1,-1,-1,-1,0,0,1,1,-1,1,-1,-1,0,0,1,0,2,0,-1,-1,-1,-1,0,2,0,1,0,0,-1,-1,1,1,-1,-1,0,0,1,0,1,1,0,-1,-1,-2,0", "code": "\nfrom sympy import poly, symbols\ndef a231599_row(n):\n    if n == 0:\n        return [1]\n    x = symbols('x')\n    p = 1\n    for i in range(1, n+1):\n        p *= poly(1-x**i)\n    p = p.all_coeffs()\n    return p[::-1]\n\n"}
{"sequence_id": "A231829", "text": "Square array read by antidiagonals: T(m,n) = number of ways of creating a closed, simple loop on an m X n rectangular lattice.", "sequence": "1,3,3,6,13,6,10,40,40,10,15,108,213,108,15,21,275,1049,1049,275,21,28,681,5034,9349,5034,681,28,36,1664,23984,80626,80626,23984,1664,36,45,4040,114069,692194,1222363,692194,114069,4040,45", "code": "\n\nfrom graphillion import GraphSet\nimport graphillion.tutorial as tl\ndef A231829(n, k):\n    universe = tl.grid(n, k)\n    GraphSet.set_universe(universe)\n    cycles = GraphSet.cycles()\n    return cycles.len()\nprint([A231829(j + 1, i - j + 1) for i in range(9) for j in range(i + 1)])  \n"}
{"sequence_id": "A232115", "text": "a(n) is the Manhattan distance between n and n(n+1)/2 in a square spiral of positive integers with 1 at the center.", "sequence": "0,1,3,4,2,3,5,6,4,5,9,6,6,7,11,8,8,15,9,10,10,13,11,12,22,11,15,18,12,15,17,22,12,21,25,10,26,21,19,18,24,27,15,34,24,21,31,20,28,21,31,24,28,41,19,36,36,23,35,26,38,23,41,36,28,53,29,38,40,31,39", "code": "\nimport math\ndef get_x_y(n):\n  sr = int(math.sqrt(n-1))\n  sr = sr-1+(sr&1)\n  rm = n-sr*sr\n  d = (sr+1)/2\n  if rm<=sr+1:\n     return -d+rm,d\n  if rm<=sr*2+2:\n     return d,d-(rm-(sr+1))\n  if rm<=sr*3+3:\n     return d-(rm-(sr*2+2)),-d\n  return -d,-d+rm-(sr*3+3)\nfor n in range(1,333):\n  x0,y0 = get_x_y(n)\n  x1,y1 = get_x_y(n*(n+1)/2)\n  print str(abs(x1-x0)+abs(y1-y0))+',',\n"}
{"sequence_id": "A232116", "text": "Primes such that the sum of each nonzero digit raised to itself is prime.", "sequence": "11,23,41,43,47,101,113,131,157,263,311,401,571,751,829,997,1013,1031,1103,1187,1301,1433,1583,1619,1871,2003,2063,2089,2111,2221,2357,2579,2683,2753,2957,3011,3257,3343,3413,3433,3527,3581,3637,3673,3851,4001,4003,4007,4133,4441,4481,4597,4649", "code": "\nfrom sympy import isprime,primerange\ndef Pow(n):\n    s = 0\n    for i in str(n):\n        k = int(i)\n        if k:\n            s += k**k\n    return s\n{print(pn, end=', ') for pn in primerange(1,2000) if isprime(Pow(pn))}\n\n"}
{"sequence_id": "A232125", "text": "Smallest prime such that the n numbers obtained by removing 1 digit on the right are also prime, while no digit can be added on the right to get another prime.", "sequence": "53,53,317,2393,23333,373393,2399333,23399339,1979339333,103997939939,4099339193933,145701173999399393,2744903797739993993333,52327811119399399313393,13302806296379339933399333", "code": "\nfrom sympy import isprime, nextprime\ndef a(n):\n    p, oo = 2, float('inf')\n    while True:\n        extends, reach, r1 = 0, [str(p)], []\n        while len(reach) > 0 and extends <= n:\n            minnotext = oo\n            for s in reach:\n                wasextended = False\n                for d in \"1379\":\n                    if isprime(int(s+d)): r1.append(s+d); wasextended = True\n                if not wasextended: minnotext = min(minnotext, int(s))\n            if extends == n and minnotext < oo: return minnotext\n            if len(r1) > 0: extends += 1\n            reach, r1 = r1, []\n        p = nextprime(p)\nfor n in range(12): print(a(n), end=\", \") \n"}
{"sequence_id": "A232127", "text": "Maximal number of digits that can be appended to prime(n) preserving primality at each step.", "sequence": "7,7,7,7,1,6,3,8,6,6,3,6,1,5,3,0,6,5,5,4,6,1,1,0,2,4,9,0,4,0,5,1,1,5,3,1,2,1,0,2,0,4,2,3,7,5,2,3,4,3,5,4,5,0,4,3,4,5,3,1,1,5,1,2,2,0,6,3,0,4,5,2,4,5,1,2,0,0,3,10,0,3,0,2,4,0,3,0,0,6", "code": "\nfrom sympy import isprime, prime\ndef a(n):\n  pn = prime(n); ftr = {pn}; ext = 0\n  while len(ftr) > 0:\n    r1 = set(filter(isprime, (int(str(e)+d) for d in \"1379\" for e in ftr)))\n    ext, ftr = ext+1, r1\n  return ext - 1\nprint([a(n) for n in range(1, 91)]) \n"}
{"sequence_id": "A232127", "text": "Maximal number of digits that can be appended to prime(n) preserving primality at each step.", "sequence": "7,7,7,7,1,6,3,8,6,6,3,6,1,5,3,0,6,5,5,4,6,1,1,0,2,4,9,0,4,0,5,1,1,5,3,1,2,1,0,2,0,4,2,3,7,5,2,3,4,3,5,4,5,0,4,3,4,5,3,1,1,5,1,2,2,0,6,3,0,4,5,2,4,5,1,2,0,0,3,10,0,3,0,2,4,0,3,0,0,6", "code": " \nfrom sympy import isprime, prime, primerange\ndef aupton(terms):\n  alst = []\n  for p in primerange(1, prime(terms)+1):\n    r = {p}; e = 0\n    while len(r) > 0:\n      r1 = set(filter(isprime, (int(str(e)+d) for d in \"1379\" for e in r)))\n      e, r = e+1, r1\n    alst.append(e - 1)\n  return alst\nprint(aupton(90)) \n"}
{"sequence_id": "A232128", "text": "Maximal number of digits that can be appended to n such that each step yields a prime.", "sequence": "9,7,7,6,7,6,7,2,3,10,1,6,6,4,3,2,3,5,8,0,3,5,6,6,5,5,6,2,6,2,3,0,7,5,6,5,6,3,1,11,1,4,5,4,1,7,3,4,6,4,0,5,0,6,4,4,6,2,6,7,5,0,4,2,3,3,5,2,5,4,4,1,6,2,4,4,1,7,1,4,4,10,1,0,5,1,6,5,0,1,4", "code": "\nfrom sympy import isprime, nextprime\ndef a(n):\n    while True:\n        extends, reach, maxp = -1, {n}, 0\n        while len(reach) > 0:\n            candidates = (int(str(e)+d) for d in \"1379\" for e in reach)\n            reach1 = set(filter(isprime, candidates))\n            extends, reach, maxp = extends+1, reach1, max({maxp}|reach1)\n        return extends\nprint([a(n) for n in range(1, 92)]) \n"}
{"sequence_id": "A232129", "text": "Largest prime that can be obtained from n by successively appending digits to the right with the constraint that each of the numbers obtained that way must be prime; a(n)=0 if there is no such prime at all.", "sequence": "1979339339,29399999,37337999,4391339,59393339,6733997,73939133,839,9719,103997939939,113,12791333,13999133,149399,15797,1637,17333,1811993,1979339339,0,21139,2273993,23399339,24179399,2579939,2699393,27191939,2837,29399999,3079,31379,0,331999799,3491333,35393999", "code": "\nfrom sympy import isprime, nextprime\ndef a(n):\n    while True:\n        extends, reach, maxp = -1, {n}, 0\n        while len(reach) > 0:\n            candidates = (int(str(e)+d) for d in \"1379\" for e in reach)\n            reach1 = set(filter(isprime, candidates))\n            extends, reach, maxp = extends+1, reach1, max({maxp}|reach1)\n        return maxp\nprint([a(n) for n in range(1, 36)]) \n"}
{"sequence_id": "A232175", "text": "Least positive k such that n^3 + k^2 is a square, or 0 if there is no such k.", "sequence": "0,1,3,6,10,3,21,8,36,15,55,6,78,35,15,48,136,27,171,10,42,99,253,10,300,143,81,42,406,15,465,64,88,255,35,63,666,323,91,3,820,21,903,55,66,483,1081,48,1176,125,85,39,1378,81,165,28,76,783,1711,15,1830,899,63", "code": "\nimport math\nfor n in range(77):\n   n3 = n*n*n\n   y=1\nfor k in range(1,10000001):\n     sum = n3 + k*k\n     r = int(math.sqrt(sum))\n     if r*r == sum:\n       print str(k)+',',\n       y=0\n       break\n   if y: print '-,',\n"}
{"sequence_id": "A232175", "text": "Least positive k such that n^3 + k^2 is a square, or 0 if there is no such k.", "sequence": "0,1,3,6,10,3,21,8,36,15,55,6,78,35,15,48,136,27,171,10,42,99,253,10,300,143,81,42,406,15,465,64,88,255,35,63,666,323,91,3,820,21,903,55,66,483,1081,48,1176,125,85,39,1378,81,165,28,76,783,1711,15,1830,899,63", "code": "\nfrom __future__ import division\nfrom sympy import divisors\ndef A232175(n):\n    n3 = n**3\n    ds = divisors(n3)\n    for i in range(len(ds)//2-1,-1,-1):\n        x = ds[i]\n        y = n3//x\n        a, b = divmod(y-x,2)\n        if not b:\n            return a\n    return 0 \n"}
{"sequence_id": "A232176", "text": "Least positive k such that n^2 + triangular(k) is a square.", "sequence": "1,2,6,10,14,18,7,5,8,34,6,42,46,15,54,16,14,66,70,74,23,82,9,90,17,98,102,10,110,15,25,122,126,16,39,48,40,21,150,34,158,29,54,48,30,13,182,63,55,194,56,202,14,45,214,63,222,26,41,234,31,42,39,250,32,63", "code": "\nimport math\nfor n in range(77):\n  n2 = n*n\n  y=1\n  for k in range(1,10000001):\n    sum = n2 + k*(k+1)//2\n    r = int(math.sqrt(sum))\n    if r*r == sum:\n      print(str(k), end=',')\n      y=0\n      break\n  if y: print('-', end=',')\n"}
{"sequence_id": "A232177", "text": "Least positive k such that triangular(n) + triangular(k) is a square.", "sequence": "1,2,1,2,3,1,5,6,7,8,9,5,2,12,13,1,15,16,17,3,5,20,2,22,23,8,4,26,12,3,29,30,1,5,33,34,4,36,37,15,6,29,22,5,43,19,45,7,15,48,6,50,11,52,8,41,22,7,57,58,59,9,26,62,8,64,19,66,10,68,5,9,71,2", "code": "\nimport math\nfor n in range(77):\n  tn = n*(n+1)//2\n  for k in range(1, n+9):\n    sum = tn + k*(k+1)//2\n    r = int(math.sqrt(sum))\n    if r*r == sum:\n      print(str(k), end=',')\n      break\n"}
{"sequence_id": "A232178", "text": "Least k>=0 such that triangular(n) + k^2 is a square, or -1 if no such k exists.", "sequence": "0,0,1,-1,-1,1,2,6,0,2,3,-1,-1,3,4,1,15,4,5,-1,-1,5,6,20,10,6,7,-1,-1,7,8,27,1,8,9,-1,-1,9,10,2,36,10,11,-1,-1,11,12,41,7,0,13,-1,-1,13,6,24,2,14,15,-1,-1,15,16,3,6,8,17,-1,-1,17,18,62,64,18,19", "code": "\nfrom __future__ import division\nfrom sympy import divisors\ndef A232178(n):\n    if n == 0:\n        return 0\n    t = n*(n+1)//2\n    ds = divisors(t)\n    l, m = divmod(len(ds),2)\n    if m:\n        return 0\n    for i in range(l-1,-1,-1):\n        x = ds[i]\n        y = t//x\n        a, b = divmod(y-x,2)\n        if not b:\n            return a\n    return -1 \n"}
{"sequence_id": "A232179", "text": "Least k >= 0 such that n^2 + triangular(k) is a triangular number.", "sequence": "0,0,3,1,15,2,0,3,63,4,8,5,11,6,20,3,255,8,1,9,3,10,38,11,59,12,45,13,8,14,2,15,1023,16,59,0,24,18,66,19,51,20,3,21,44,10,80,23,251,24,42,25,68,26,4,27,39,28,101,29,10,30,108,8,4095,32,5,33,128", "code": "\nfrom __future__ import division\nfrom sympy import divisors\ndef A232179(n):\n    if n == 0:\n        return 0\n    t = 2*n**2\n    ds = divisors(t)\n    for i in range(len(ds)//2-1,-1,-1):\n        x = ds[i]\n        y = t//x\n        a, b = divmod(y-x,2)\n        if b:\n            return a\n    return -1 \n"}
{"sequence_id": "A232271", "text": "Start with positive integers (A000027), and at each step n >= 1 subtract from the term at position n + a(n) the value a(n).", "sequence": "1,1,2,4,3,6,7,1,8,10,11,6,13,7,15,16,9,12,30,10,14,11,23,24,25,4,27,28,29,-11,31,16,22,34,21,36,37,19,39,40,41,42,43,44,45,23,47,8,49,25,51,52,53,27,34,-1,38,29,59,60,61,31,63,64,65,66,67,34,307,70,71", "code": "\nTOP = 2**30  \na = [1]*TOP\nfor n in range(1,TOP):\n  a[n]=n\nfor n in range(1,TOP):\n  if n+a[n]<TOP and n+a[n]>0: a[n+a[n]] -= a[n]\nfor n in range(1,1000):\n  print str(a[n])+',',\n"}
{"sequence_id": "A232444", "text": "Numbers n such that sigma(n) and sigma(n^2) are primes.", "sequence": "2,4,64,289,729,15625,7091569,7778521,11607649,15912121,43546801,56957209,138980521,143688169,171845881,210801361,211673401,253541929,256224049,275792449,308810329,329386201,357172201,408807961,499477801,531625249,769341169,1073741824,1260747049", "code": "\nfrom sympy import isprime, divisor_sigma\nA232444_list = [2]+[n for n in (d**2 for d in range(1,10**4)) if isprime(divisor_sigma(n)) and isprime(divisor_sigma(n**2))] \n"}
{"sequence_id": "A232462", "text": "Number of iterations of the map n -> f(f(f(...f(n)...))) to reach the end of the cycle, where f(n) = A006666(n), the initial number n is not counted.", "sequence": "0,1,4,2,3,0,6,5,8,4,5,7,7,8,8,3,9,9,9,1,1,6,6,6,4,6,7,8,8,8,11,4,10,5,5,9,9,9,7,7,7,7,2,8,8,8,11,9,10,10,10,9,9,12,12,9,7,9,7,9,9,7,7,1,10,10,10,6,6,6,11,4,0,4,6,4,4,7,7,6,4,7,7,6,6,2,2,8,2,8,8,8,8,11,11,5,7,10,10,10,10,10,10,5,7,5,2,5,5,5,9,9,5,7,7,9,9,7,7,9", "code": "\n\n.\n\noutputStr = \"b232462.txt\"\n.\n\nmaxIndex = 10000\n.\n\nsep=\" \"\neol=\"\\n\"\n.\n.\n\ndef collatz (n, k):\n.\n....\n....list = [n]\n.\n....\n....while (n > 1):\n.\n........\n........if (n%2 == 0):\n............n = n // 2\n........else:\n............n = (3*n + 1) // k  \n.\n........\n........list.append(n);\n.\n....\n....return list\n.\n.\n\n\ndef composition (n, k):\n.\n....\n....list = [n]\n.\n....\n....l = len (collatz(n, k))-1\n.\n....\n....while ((l >= 1) and (not l in list)):\n.\n........\n........list.append(l)\n.\n........\n........l = len (collatz(l, k))-1\n.\n....\n....return list\n.\n.\n\noutput = open (outputStr, 'w')\n.\n\nfor i in range (1, maxIndex+1):\n.\n....\n....list = composition(i, 2)\n.\n....\n....l = len(list)-1\n.\n....\n....output.write (str(i)+sep+str(l)+eol)\n.\n\noutput.close ()\n"}
{"sequence_id": "A232505", "text": "Sum of odd quadratic residues of prime(n).", "sequence": "1,1,1,1,18,13,38,50,26,83,66,137,224,242,147,303,509,395,578,364,714,563,965,1046,1254,1155,1043,1565,1323,1676,1667,2440,2456,2589,2563,2284,2827,3362,2526,3503,4408,3765,3271,4902,4557,4005,5829,5380,6952,6093,7046,5288,7626,8691,8552,6871,8563,7622,9007,10250,10365,10233", "code": "\nfrom sympy.ntheory.residue_ntheory import quadratic_residues as q\nfrom sympy import prime\ndef a(n): return sum(i for i in q(prime(n)) if i%2)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A232541", "text": "Multiplicative Smith numbers: Composite numbers n such that the product of nonzero digits of n = product of nonzero digits of prime factors of n.", "sequence": "4,6,8,9,95,159,195,249,326,762,973,995,998,1057,1086,1111,1189,1236,1255,1337,1338,1383,1389,1395,1419,1509,2139,2248,2623,2679,2737,2928,2949,3029,3065,3202,3344,3345,3419,3432,3437,3464,3706,3945,4344,4502", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import factorint\ndef DigitProd(x):\n    prod = 1\n    for i in str(x):\n        if i != '0':\n            prod *= int(i)\n    return prod\ndef f(x):\n    lst = []\n    for n in range(len(list(factorint(x)))):\n        lst.append(str(list(factorint(x))[n])*list(factorint(x).values())[n])\n    string = ''\n    for i in lst:\n        string += i\n    prod = 1\n    for a in string:\n        if a != '0':\n            prod *= int(a)\n    if prod == DigitProd(x):\n        return True\nx = 4\nwhile x < 10**3:\n    if not isprime(x):\n        if f(x):\n            print(x)\n    x += 1\n"}
{"sequence_id": "A232617", "text": "Product of first n odd numbers plus product of first n even numbers: (2n-1)!! + (2n)!!, where k!! = A006882(k).", "sequence": "3,11,63,489,4785,56475,780255,12348945,220253985,4370620275,95498916975,2278224696825,58917607974225,1641787169697675,49040157044253375,1563094742062478625,52953322446161762625,1899986948191060603875,71977860935783603175375,2870913642898706235455625", "code": "\no=e=1\nfor n in range(1,99,2):\n  o*=n\n  e*=n+1\n  print(str(e+o), end=',')\n"}
{"sequence_id": "A232618", "text": "a(n) = (2n)!! mod (2n-1)!! where k!! = A006882(k).", "sequence": "0,2,3,69,60,4500,104580,186795,13497435,442245825,13003053525,64585694250,3576632909850,147580842959550,5708173568847750,27904470362393625,2292043480058957625,126842184377462428875,6371504674680470700375,312265748715684068930625", "code": "\no=e=1\nfor n in range(1,99,2):\n  o*=n\n  e*=n+1\n  print(str(e%o), end=',')\n"}
{"sequence_id": "A232620", "text": "Numbers n such that (2n)!! mod (2n-1)!! is greater than (2n+2)!! mod (2n+1)!!.", "sequence": "4,615,9090,11011", "code": "\no=e=1  \nprev=0\nfor n in range(1,1000000000,2):\n  o*=n\n  e*=n+1\n  cur = e%o\n  if prev>cur: print str(n//2)+',',\n  prev=cur\n  if (n&8191)==8191: print '.',\n"}
{"sequence_id": "A232701", "text": "a(n) = (2*n-1)!! mod n!, where double factorial is A006882.", "sequence": "0,1,3,9,105,315,4095,11025,348705,1545075,17931375,93087225,3764185425,45589819275,1060569885375,15877899662625,900941666625,5722531807867875,90088576482279375,1688777976676415625,18148954872023600625,320586579951629866875,11054393914490520969375", "code": "\nimport math\no=1\nfor n in range(1,99,2):\n  o*=n\n  print str(o % math.factorial(n//2+1))+',',\n"}
{"sequence_id": "A232709", "text": "Nonnegative integers such that the sum of digits mod 10 equals the product of digits mod 10.", "sequence": "0,1,2,3,4,5,6,7,8,9,22,48,84,109,123,132,137,145,154,159,173,178,187,190,195,208,213,228,231,233,235,237,239,248,253,268,273,280,282,284,286,288,293,307,312,317,321,323,325,327,329,332,337,347,352,357,367,370,371,372,373,374,375,376,377", "code": "\nfrom math import prod\ndef ok(n): d = list(map(int, str(n))); return sum(d)%10 == prod(d)%10\nprint([k for k in range(378) if ok(k)]) \n"}
{"sequence_id": "A232725", "text": "Numbers n such that the concatenation 123456789n is prime.", "sequence": "1,23,29,49,133,143,167,191,199,217,257,311,403,409,419,433,437,451,457,473,563,587,601,623,629,653,671,689,721,761,769,779,803,809,851,871,881,893,913,943,947,959,1003,1013,1027,1069,1079,1091,1153,1163,1177", "code": "\nfrom sympy import isprime\n{print(n,end=', ') for n in range(2000) if isprime(int(\"123456789\"+str(n)))}\n\n"}
{"sequence_id": "A232726", "text": "Primes p such that the concatenation 123456789p is prime.", "sequence": "23,29,167,191,199,257,311,409,419,433,457,563,587,601,653,761,769,809,881,947,1013,1069,1091,1153,1163,1187,1223,1259,1283,1307,1433,1489,1511,1723,1787,1789,1913,1993,2039,2137", "code": "\nfrom sympy import isprime\nfor n in range(5000):\n    if isprime(n) and isprime(int(\"123456789\" + str(n))):\n        print(n, end=', ') \n"}
{"sequence_id": "A232727", "text": "Numbers n such that the concatenation n123456789 is prime.", "sequence": "28,32,41,55,56,59,74,95,100,116,119,122,124,142,154,161,164,179,184,193,200,215,217,220,230,241,259,265,278,296,298,314,332,382,392,406,409,416,424,425,439,452,455,458,460,466,475,493,496,514,515,530,536,559,572,574,598,602,613,629,634", "code": "\nfrom sympy import isprime\n{print(n,end=', ') for n in range(1,10**3) if isprime(int(str(n)+'123456789'))}\n\n"}
{"sequence_id": "A232728", "text": "Primes p such that the concatenation p123456789 is prime.", "sequence": "41,59,179,193,241,409,439,613,653,661,719,739,787,853,881,887,997,1091,1103,1129,1181,1213,1381,1409,1459,1487,1489,1571,1579,1669,1741,1801,1823,1861,1871,1879,1889,1907,1913,1993,2039,2083,2099,2243,2417,2593,2659,2663,2729,2741,2833,3079,3119", "code": "\nfrom sympy import prime,isprime\n{print(prime(n),end=', ') for n in range(1,10**3) if isprime(int(str(prime(n))+'123456789'))}\n\n"}
{"sequence_id": "A232764", "text": "Numbers n such that the concatenation A000461(d_1)//A000461(d_2)//...//A000461(d_k) is prime, where d_i is the i-th digit of n and n is k digits long.", "sequence": "11,31,53,101,110,131,149,159,169,189,223,231,243,249,283,297,301,310,311,313,327,331,361,381,397,429,437,453,463,503,513,530,533,561,627,641,651,657,691,779,813,861,937,941,951,961,973,1001,1010,1031,1049,1059,1069", "code": "\nimport sympy\nfrom sympy import isprime\ndef a():\n..for n in range(1,10**4):\n....num = ''\n....lst = list(str(n))\n....for i in lst:\n......num += i*int(i)\n....if isprime(int(num)):\n......print(n)\na()\n"}
{"sequence_id": "A232766", "text": "Numbers n such that the concatenation n987654321 is prime.", "sequence": "28,32,44,50,55,58,97,100,107,112,130,149,152,154,179,193,208,233,259,265,271,287,310,314,320,326,341,359,365,376,404,413,421,439,449,455,457,466,469,491,499,536,538,545,547,548,557,565,568,574,593,614,616", "code": "\nfrom sympy import isprime\n{print(n,end=', ') for n in range(2000) if isprime(int(str(n)+\"987654321\"))}\n\n"}
{"sequence_id": "A232767", "text": "Primes p such that the concatenation p987654321 is prime.", "sequence": "97,107,149,179,193,233,271,359,421,439,449,457,491,499,547,557,593,673,677,701,769,821,839,947,971,1019,1021,1051,1069,1087,1091,1093,1103,1117,1163,1297,1301,1307,1327,1399,1409,1439,1453,1483,1493,1579,1597,1609", "code": "\nfrom sympy import isprime\n{print(n,end=', ') for n in range(10**4) if isprime(n) and isprime(int(str(n)+\"987654321\"))}\n\n"}
{"sequence_id": "A232821", "text": "a(n) = n^(n-1) - Sum_{k=1..n-1} k^(k-1).", "sequence": "1,1,6,52,549,7075,109172,1971026,40823443,954730001,24892154602,716025676088,22528094057193,769646697066375,28375143175948712,1122910795732014438,47478259662185188967,2136067435649547983973,101891594614083396452878", "code": "\ndef sub(n):\n..num = n**(n-1)\n..for i in range(0,n-1):\n......num -= (i+1)**i\n..return num\nn = 1\nwhile n < 100:\n..print(sub(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A232863", "text": "Numbers k such that (2*k-1)!! mod k! is greater than (2k+1)!! mod (k+1)!.", "sequence": "16,75,82,572,5260,33232,99589,200413,2940392", "code": "\no = f = 1\nprev = 0\nfor n in range(1,1000000):\n  o *= 2*n-1\n  f *= n\n  cur = o % f\n  if prev>cur:  print str(n-1)+',',\n  prev=cur\n  if (n&8191)==0:  print '.',\n"}
{"sequence_id": "A233003", "text": "(n!)^2 mod Pt(n), where Pt(n) is product of first n positive triangular numbers (A000217).", "sequence": "0,1,0,36,900,8100,0,25401600,514382400,12859560000,6224027040000,56016243360000,9466745127840000,1855482045056640000,0,6679735362203904000000,13513104637738497792000000,156365925093831188736000000,225792395835492236534784000000,22579239583549223653478400000000", "code": "\ns=t=1\nfor n in range(1,33):\n  s*=n*n\n  t*=n*(n+1)/2\n  print str(s%t)+',',\n"}
{"sequence_id": "A233004", "text": "Pt(n) mod n!, where Pt(n) is product of first n positive triangular numbers (A000217).", "sequence": "0,1,0,12,60,540,0,20160,181440,907200,19958400,359251200,1556755200,32691859200,0,10461394944000,177843714048000,1600593426432000,60822550204416000,608225502044160000,38318206628782080000,702500454861004800000,12926008369442488320000", "code": "\nf=t=1\nfor n in range(1,33):\n  t*=n*(n+1)/2\n  f*=n\n  print str(t%f)+',',\n"}
{"sequence_id": "A233005", "text": "floor(Pt(n)/n!), where Pt(n) is product of first n positive triangular numbers (A000217).", "sequence": "1,1,3,7,22,78,315,1417,7087,38981,233887,1520268,10641881,79814109,638512875,5427359437,48846234937,464039231906,4640392319062,48724119350156,535965312851718,6163601097794765,73963213173537187,924540164669214843,12019022140699792968", "code": "\nf=t=1\nfor n in range(1,33):\n  t*=n*(n+1)/2\n  f*=n\n  print str(t/f)+',',\n"}
{"sequence_id": "A233007", "text": "Numbers k such that (k-1)^2 + k^2 + (k+1)^2 is a palindrome.", "sequence": "0,1,5,12,38,567,1737,8340,16085,17553,17933,36998,40442,119812,173737,378812,1328121,1751497,1775707,4427781,8211880,17909283,40439558,441564381,828223250,5602945243,8227749490,12900321392,16028474345,17552348197,37196982752", "code": "\na = 0\nwhile a < 10000000000:\n....q = (a-1)**2 + a**2 + (a+1)**2\n....if str(q) == str(q)[::-1]:\n........print(a,q)\n....a+=1\n\n"}
{"sequence_id": "A233075", "text": "Numbers that are midway between the nearest square and the nearest cube.", "sequence": "6,26,123,206,352,498,1012,1350,1746,2203,2724,3428,4977,5804,6874,8050,9335,10732,12244,13874,17500,19782,21928,24519,26948,29860,32946,35829,39254,42862,50639,54814,59184,63752,69045,74036,79234,85224,90863,97340,104076", "code": "\ndef isqrt(a):\n    sr = 1 << (int.bit_length(int(a)) >> 1)\n    while a < sr*sr:  sr>>=1\n    b = sr>>1\n    while b:\n        s = sr + b\n        if a >= s*s:  sr = s\n        b>>=1\n    return sr\na=[]\nfor c in range(1, 10000):\n    cube = c*c*c\n    srB = isqrt(cube)\n    srB2= srB**2\n    if srB2==cube: continue\n    if ((srB2^cube)&1)==0:\n        n = (srB2+cube)//2\n    else:\n        n = (srB2+2*srB+1+cube)//2\n    a.append(n)\nprint(a)\n"}
{"sequence_id": "A233203", "text": "Floor(n^n / 2^n).", "sequence": "1,0,1,3,16,97,729,6433,65536,756680,9765625,139312339,2176782336,36972058910,678223072849,13363461010158,281474976710656,6311342330065435,150094635296999121,3773536025353076151,100000000000000000000,2785962590401641140642,81402749386839761113321", "code": "\nfor n in range(33):  print str(n**n >> n)+',',\n"}
{"sequence_id": "A233279", "text": "Permutation of nonnegative integers: a(n) = A054429(A006068(n)).", "sequence": "0,1,2,3,4,5,7,6,8,9,11,10,15,14,12,13,16,17,19,18,23,22,20,21,31,30,28,29,24,25,27,26,32,33,35,34,39,38,36,37,47,46,44,45,40,41,43,42,63,62,60,61,56,57,59,58,48,49,51,50,55,54,52,53,64,65,67,66", "code": "\nfrom sympy import floor\ndef a006068(n):\n    s=1\n    while True:\n        ns=n>>s\n        if ns==0: break\n        n=n^ns\n        s<<=1\n    return n\ndef a054429(n): return 1 if n==1 else 2*a054429(floor(n/2)) + 1 - n%2\ndef a(n): return 0 if n==0 else a054429(a006068(n)) \n"}
{"sequence_id": "A233280", "text": "Permutation of nonnegative integers: a(n) = A003188(A054429(n)).", "sequence": "0,1,2,3,4,5,7,6,8,9,11,10,14,15,13,12,16,17,19,18,22,23,21,20,28,29,31,30,26,27,25,24,32,33,35,34,38,39,37,36,44,45,47,46,42,43,41,40,56,57,59,58,62,63,61,60,52,53,55,54,50,51,49,48,64,65,67,66", "code": "\nfrom sympy import floor\ndef a003188(n): return n^(n>>1)\ndef a054429(n): return 1 if n==1 else 2*a054429(floor(n/2)) + 1 - n%2\ndef a(n): return 0 if n==0 else a003188(a054429(n)) \n"}
{"sequence_id": "A233397", "text": "floor(n^n / 3^n).", "sequence": "1,0,0,1,3,12,64,376,2557,19683,169350,1610592,16777216,189970982,2323244584,30517578125,428528437130,6405755132013,101559956668416,1702215647540101,30072865982171749,558545864083284007,10880062101736647492,221794805104450672070", "code": "\nfor n in range(33):  print str(n**n // 3**n)+',',\n"}
{"sequence_id": "A233398", "text": "n^n mod 3^n.", "sequence": "0,1,4,0,13,209,0,1231,739,0,51850,129587,0,657067,868120,0,8400886,91426058,0,859535812,1483912651,0,30374372956,68688648677,0,422259655777,2129293909882,0,11623487749588,44275834126985,0,329933248712302,971441847750184,0,927342285792613", "code": "\nfor n in range(55):  print str(n**n % 3**n)+',',\n"}
{"sequence_id": "A233400", "text": "Number n such that a2 - n^3 is a triangular number (A000217), where a2 is the least square above n^3.", "sequence": "0,1,2,9,12,107,109,120,244,337,381,407,565,592,937,1209,1224,1341,1717,2032,2402,3280,4957,5149,5265,5644,7065,7240,8181,8820,9712,10732,11901,15059,18300,19120,20436,22672,24516,25139,28044,28550,36145,38221,66201,72335,77100", "code": "\ndef isqrt(a):\n    sr = 1L << (long.bit_length(long(a)) >> 1)\n    while a < sr*sr:  sr>>=1\n    b = sr>>1\n    while b:\n      s = sr+b\n      if a >= s*s:  sr = s\n      b>>=1\n    return sr\ndef isTriangular(a):\n  a+=a\n  sr = isqrt(a)\n  return (a==sr*(sr+1))\nfor n in range(77777):\n  n3 = n*n*n\n  a = isqrt(n3)+1\n  if isTriangular(a*a-n3):  print str(n)+',',\n"}
{"sequence_id": "A233401", "text": "Numbers k such that k^3 - b2 is a triangular number (A000217), where b2 is the largest square less than k^3.", "sequence": "1,4,8,21,37,40,56,112,113,204,280,445,481,560,688,709,1933,1945,3601,3805,3861,4156,4333,4365,7096,8408,8516,11064,12688,13609,13945,16501,17080,18901,21464,23125,27244,27364,28141,45228,45549,58321,60061,66245,70585,78688", "code": "\ndef isqrt(a):\n    sr = 1L << (long.bit_length(long(a)) >> 1)\n    while a < sr*sr:  sr>>=1\n    b = sr>>1\n    while b:\n      s = sr+b\n      if a >= s*s:  sr = s\n      b>>=1\n    return sr\ndef isTriangular(a):\n  a+=a\n  sr = isqrt(a)\n  return (a==sr*(sr+1))\nfor n in range(1,79999):\n  n3 = n*n*n\n  b = isqrt(n3)\n  if b*b==n3: b-=1\n  if isTriangular(n3-b*b):  print str(n)+',',\n"}
{"sequence_id": "A233410", "text": "a(n) = smallest multiple m of n such that there are at most m/n perfect powers <= m.", "sequence": "1,2,3,20,45,60,77,96,117,180,209,276,312,378,420,464,510,594,646,700,756,814,874,936,1050,1118,1188,1260,1363,1440,1519,1632,1716,1836,1925,2016,2183,2394,2496,2600,2788,2898,3010,3124,3330", "code": "\na = A001597 'list of ordered perfect powers' = [1, 4, 8, 9, 16, 25, 27, 32, 36, ...]\nA233410 = {}\nn = 1\nk = 1\nwhile True\n....while n * k >= a[k]:\n........k += 1\n....A233410[n] = n * k\n....n += 1\n"}
{"sequence_id": "A233422", "text": "Numbers n such that m - n^3 is a square, where m is the least square above n^3.", "sequence": "0,2,3,6,12,20,24,30,40,42,56,60,68,75,78,84,87,120,126,160,180,248,264,270,273,308,312,318,330,336,351,360,396,564,570,588,615,620,630,635,720,738,780,840,912,1008,1016,1032,1284,1308,1320,1334,1344,1404,1540,1617", "code": "\ndef isqrt(a):\n    sr = 1L << (long.bit_length(long(a)) >> 1)\n    while a < sr*sr:  sr>>=1\n    b = sr>>1\n    while b:\n      s = sr+b\n      if a >= s*s:  sr = s\n      b>>=1\n    return sr\ndef isSquare(a):\n  sr = isqrt(a)\n  return (a==sr*sr)\nfor n in range(77777):\n  n3 = n*n*n\n  a = isqrt(n3)+1\n  if isSquare(a*a-n3):  print str(n)+',',\n"}
{"sequence_id": "A233441", "text": "Floor(2^n / n^3).", "sequence": "2,0,0,0,0,0,0,0,0,1,1,2,3,5,9,16,26,44,76,131,226,393,689,1213,2147,3818,6818,12228,22012,39768,72084,131072,239027,437102,801393,1472896,2713342,5009438,9267786,17179869,31906432,59362467,110632938,206519839,386111079", "code": "\nfor n in range(1,100):  print str(2**n // n**3)+',',\n"}
{"sequence_id": "A233442", "text": "2^n mod n^3.", "sequence": "0,4,8,16,32,64,128,256,512,24,717,640,1601,2664,2393,0,3334,5536,3004,576,4166,9640,5545,8704,7557,3696,19034,6400,20244,5824,29204,0,21293,12176,13493,40960,41146,25008,16154,11776,55680,56008,20642,79040,14957,1016", "code": "\nfor n in range(1,100):  print str(2**n % n**3)+',',\n"}
{"sequence_id": "A233468", "text": "The digital root of prime(n+1) minus the digital root of prime(n).", "sequence": "1,2,2,-5,2,4,-7,4,-3,2,-3,4,2,-5,6,-3,2,-3,4,-7,6,-5,6,-1,-5,2,4,-7,4,-4,4,-3,2,1,2,-3,-3,4,-3,6,-7,1,2,4,-7,3,3,-5,2,4,-3,2,1,-3,-3,6,-7,6,-5,2,1,-4,4,2,-5,5,-3,1,2,-5,6", "code": "\ndd=[]\ndef prim(end):\n....num=3\n....primes=[2,3]\n....while (len(primes)<=end):\n........num+=1\n........prime=False\n........length=len(primes)\n........for y in range(0,length):\n............if (num % primes[y]!=0):\n................prime=True\n............else:\n................prime=False\n................break\n........if (prime):\n............primes.append(num)\n....for x in range(len(primes)-1):\n........dd.append((primes[x+1]%9) - (primes[x]%9))\n....return dd\n"}
{"sequence_id": "A233471", "text": "a(n) = 3^n mod n^2.", "sequence": "0,1,0,1,18,9,31,33,0,49,3,81,146,177,207,65,224,81,307,1,342,9,118,225,68,529,0,753,467,549,623,641,27,757,607,81,632,389,846,801,905,981,261,81,243,1757,1554,2241,2383,249,792,1329,851,729,1332,2529,1737,2793,298", "code": "\nfor n in range(1,100):  print(str(3**n % n**2), end=',')\n"}
{"sequence_id": "A233525", "text": "Start with a(1) = 1, a(2) = 1, then a(n)*3^k = a(n+1) + a(n+2), with 3^k the smallest power of 3 (k>0) such that all terms a(n) are positive integers.", "sequence": "1,1,2,1,5,4,11,1,32,49,47,100,41,259,110,667,323,1678,1229,3805,7256,4159,17609,19822,33005,26461,72554,6829,210833,342316,290183,736765,133784,2076511,1535657", "code": "\ndef minDivisionRich(n, a=1, b=1):\n....yield a\n....yield b\n....for i in range(2, n):\n........a *= 3\n........while a <= b:\n............a *= 3\n........a, b = b, a - b\n........yield b\n"}
{"sequence_id": "A233526", "text": "Start with a(1) = 1, a(2) = 3, then a(n)*2^k = a(n+1) + a(n+2), with 2^k the smallest power of 2 (k>0) such that all terms a(n) are positive integers.", "sequence": "1,3,1,5,3,7,5,9,1,17,15,19,11,27,17,37,31,43,19,67,9,125,19,231,73,389,195,583,197,969,607,1331,1097,1565,629,2501", "code": "\ndef minDivisionRich(n, a=1, b=3):\n....yield a\n....yield b\n....for i in range(2, n):\n........a *= 2\n........while a <= b:\n............a *= 2\n........a, b = b, a - b\n........yield b\n"}
{"sequence_id": "A233744", "text": "Numbers p = a(n) such that p divided by (n-1)! is equal to the average number of elements of partition sets of n elements excluding sets with a singleton.", "sequence": "1,2,8,36,200,1300,9720,82180,775520,8082180,92205800,1143084580,15302486160,220019440420,3381685263320,55333244924100,960361672886720,17622501030879940,340893902373527880,6933456765092580580,147919915357498809200,3303011756746128625380", "code": "\nfrom sympy import factorial, Integer\nangel=[0,0,1,1]\nA233744=[1,2]\nn = 20\nfor i in range(4,n):\n    new = 1+sum(angel[:-1])/Integer(i-1)\n    angel.append(new)\n    A233744.append(new*factorial(i-1))\nprint(A233744)\n"}
{"sequence_id": "A233821", "text": "Smallest zeroless number x such that x^n has exactly n zero digits.", "sequence": "245,126,245,321,351,1244,194,4648,951,4357,3757,2169,2392,7399,8379,9723,8683,13867,6152,24887,18898,55825,54631,29647,35586,46564,67743,84789,119421,72296,43642,92233,44411,142553,126693,135852,52299,229626,143951", "code": "\ndef GetNums(x):\n..for n in range(10**6):\n....if str(n).count(\"0\") == 0:\n......if str(n**x).count(\"0\") == x:\n........return n\nx = 2\nwhile x < 50:\n..print(GetNums(x),end=', ')\n..x += 1\n"}
{"sequence_id": "A234016", "text": "Partial sums of the characteristic function of A055938.", "sequence": "0,0,1,1,1,2,3,3,3,4,4,4,5,6,7,7,7,8,8,8,9,10,10,10,11,11,11,12,13,14,15,15,15,16,16,16,17,18,18,18,19,19,19,20,21,22,22,22,23,23,23,24,25,25,25,26,26,26,27,28,29,30,31,31,31,32,32,32,33,34", "code": "\nfrom sympy import factorial\ndef a046699(n):\n    if n<3: return 1\n    s=1\n    while factorial(2*s)%(2**(n - 1)): s+=1\n    return s\ndef a(n): return n - (a046699(n + 2) - 1)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A234022", "text": "a(n) = A000120(A193231(n)); number of 1-bits in blue code for n.", "sequence": "0,1,2,1,2,1,2,3,4,3,2,3,2,3,2,1,2,1,2,3,2,3,4,3,4,5,4,3,4,3,2,3,4,3,2,3,4,5,4,3,4,5,6,5,4,3,4,5,2,3,2,1,4,3,2,3,4,3,4,5,2,3,4,3,4,3,4,5,2,3,4,3,4,5,4,3,6,5,4,5,2,3,4,3,2,1,2", "code": "\ndef a065621(n): return n^(2*(n - (n&-n)))\ndef a048724(n): return n^(2*n)\nl=[0, 1]\nz=[0, 1]\nfor n in range(2, 101):\n    if n%2==0: l.append(a048724(l[n//2]))\n    else: l.append(a065621(1 + l[(n - 1)//2]))\n    z.append(bin(l[-1])[2:].count(\"1\"))\nprint(z) \n"}
{"sequence_id": "A234023", "text": "Positions n where abs(A234022(n)-A234022(n+1)) > 1.", "sequence": "47,51,59,67,75,79,175,179,187,195,203,207,291,299,339,347,419,427,467,475,531,539,611,619,659,667,739,747,767,771,779,815,831,847,883,891,899,907,943,959,975,1011,1019,1027,1035,1087,1139,1147,1155,1163,1215", "code": "\ndef a065621(n): return n^(2*(n - (n&-n)))\ndef a048724(n): return n^(2*n)\ndef a193231(n):\n    if n<2: return n\n    if n%2==0: return a048724(a193231(n//2))\n    else: return a065621(1 + a193231((n - 1)//2))\ndef a234022(n): return bin(a193231(n))[2:].count(\"1\")\ndef ok(n): return abs(a234022(n) - a234022(n + 1))>1\nprint([n for n in range(1, 1501) if ok(n)]) \n"}
{"sequence_id": "A234025", "text": "Permutation of nonnegative integers: a(n) = A054429(A193231(n)).", "sequence": "0,1,2,3,6,7,5,4,8,9,11,10,13,12,14,15,30,31,29,28,27,26,24,25,17,16,18,19,20,21,23,22,44,45,47,46,41,40,42,43,35,34,32,33,38,39,37,36,61,60,62,63,56,57,59,58,50,51,49,48,55,54,52,53,106,107,105", "code": "\ndef a065621(n): return n^(2*(n - (n&-n)))\ndef a048724(n): return n^(2*n)\ndef a054429(n): return 1 if n==1 else 2*a054429(int(n/2)) + 1 - n%2\ndef a193231(n):\n    if n<2: return n\n    if n%2==0: return a048724(a193231(n/2))\n    else: return a065621(1 + a193231((n - 1)/2))\ndef a(n): return n if n<2 else a054429(a193231(n)) \n"}
{"sequence_id": "A234027", "text": "Self-inverse permutation of nonnegative integers, A054429-conjugate of blue code: a(n) = A054429(A193231(A054429(n))).", "sequence": "0,1,3,2,4,5,7,6,15,14,12,13,10,11,9,8,22,23,21,20,19,18,16,17,25,24,26,27,28,29,31,30,53,52,54,55,48,49,51,50,58,59,57,56,63,62,60,61,36,37,39,38,33,32,34,35,43,42,40,41,46,47,45,44,64,65,67,66", "code": "\ndef a065621(n): return n^(2*(n - (n&-n)))\ndef a048724(n): return n^(2*n)\ndef a054429(n): return 1 if n==1 else 2*a054429(int(n/2)) + 1 - n%2\ndef a193231(n):\n    if n<2: return n\n    if n%2==0: return a048724(a193231(n/2))\n    else: return a065621(1 + a193231((n - 1)/2))\ndef a(n): return n if n<2 else a054429(a193231(a054429(n))) \n"}
{"sequence_id": "A234143", "text": "Numbers k such that triangular(k) - x and y - triangular(k) are both triangular numbers (A000217), where x is the nearest square below triangular(k), y is the nearest square above triangular(k).", "sequence": "1,4,5,19,22,25,40,64,85,89,110,124,127,148,263,552,688,700,705,790,1804,2101,4009,4108,8680,11830,15889,22125,23611,23710,27571,32902,34536,39520,47327,62329,68374,98896,100933,112660,137614,137989,138191,159124,205004", "code": "\nimport math\ndef isTriangular(n):  \n  n+=n\n  sr = int(math.sqrt(n))\n  return (n==sr*(sr+1))\nfor n in range(1,264444):\n  tn = n*(n+1)//2\n  r = int(math.sqrt(tn-1))\n  i = tn-r*r\n  r = int(math.sqrt(tn))\n  j = (r+1)*(r+1)-tn\n  if isTriangular(i) and isTriangular(j):  print(str(n), end=',')\n"}
{"sequence_id": "A234317", "text": "Number of primes <= R_n where R_n is 11...111 with n 1's.", "sequence": "0,5,29,186,1345,10544,86537,733409,6363181,56196113,503193256,4555800188,41621368073,383118399785,3549047966156,33056584174789,309353882390965,2907021742443974,27417323062119920,259423936749134301,2461813897281353729,23422580231698331834", "code": "\nimport sympy\nfrom sympy import primepi\nfor n in range(1,50):\n..print(primepi((10**n-1)/9),end=', ')\n"}
{"sequence_id": "A234362", "text": "Floor(AGM(n^2, n^3)), where AGM denotes the arithmetic-geometric mean.", "sequence": "0,1,5,16,35,65,106,161,231,318,425,551,700,872,1069,1293,1545,1827,2140,2486,2866,3281,3734,4225,4755,5327,5942,6601,7306,8057,8856,9706,10606,11558,12565,13626,14744,15919,17154,18449,19805,21225,22709,24259,25876,27561", "code": "\nimport math\nfor n in range(67):\n  x = n*n\n  y = x*n\n  a = (x+y)*0.5\n  g = math.sqrt(x*y)\n  while abs(a-g)>0.00000000001:\n    x = a\n    y = g\n    a = (x+y)*0.5\n    g = math.sqrt(x*y)\n  print str(int(a))+',',\n"}
{"sequence_id": "A234422", "text": "Number of primes <= 123...n.", "sequence": "0,5,30,202,1474,11601,95360,809227,7027260,556442057,46063874346,3930144647471,342720306370180,30384643585371049,2728974793135786013,247673123284120245960,22671892206713857205404", "code": "\ndef Num(x):\n..num = ''\n..for n in range(x):\n....num += str(n+1)\n..return num\nfrom sympy import primepi\nx = 1\nwhile x < 10:\n..print(primepi(int(Num(x))), end=', ')\n..x += 1\n\n"}
{"sequence_id": "A234537", "text": "Number of nontrivial non-Goldbach partitions of 2n into two odd parts (with smaller part greater than 1).", "sequence": "0,0,0,0,0,1,1,1,2,2,2,2,3,4,4,5,4,4,7,6,6,7,7,6,8,9,8,10,10,8,12,10,10,14,12,11,13,13,12,15,15,12,16,17,13,18,18,16,21,18,17,20,20,18,21,20,18,22,23,17,26,25,21,28,25,23,27,28,26,27,27,24", "code": "\nfrom sympy import isprime\ndef a(n): return sum(1 for k in range(3, n + 1, 2) if not isprime(k) or not isprime(2*n - k))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A234612", "text": "Self-inverse permutation of nonnegative integers, \"blue-gray\" code: a(n) = A003188(A193231(n)).", "sequence": "0,1,2,3,7,6,5,4,8,9,10,11,15,14,13,12,25,24,27,26,30,31,28,29,17,16,19,18,22,23,20,21,42,43,40,41,45,44,47,46,34,35,32,33,37,36,39,38,51,50,49,48,52,53,54,55,59,58,57,56,60,61,62,63,127,126,125", "code": "\ndef a065621(n): return n^(2*(n - (n&-n)))\ndef a048724(n): return n^(2*n)\ndef a003188(n): return n^(n>>1)\ndef a193231(n):\n    if n<2: return n\n    if n%2==0: return a048724(a193231(n/2))\n    else: return a065621(1 + a193231((n - 1)/2))\ndef a(n): return n if n<2 else a003188(a193231(n)) \n"}
{"sequence_id": "A234616", "text": "Numbers of undirected cycles in the complete tripartite graph K_{n,n,n}.", "sequence": "1,63,6705,1960804,1271288295,1541975757831,3135880743480163,9904953891455450640,45915662047529291081589,299038026557168514632822455,2642895689915240835222121682301,30814273315381549790551229559722628", "code": "\nfrom sympy import binomial, factorial\ndef c(n, k, i, j, p): return binomial(n, k)*binomial(n, i + p)*binomial(n, j + p)*binomial(k, i)*binomial(k - i, j)*factorial(k - 1)*factorial(i + p)*factorial(j + p)*2**(k - i - j)*binomial(p + i + j - 1, k - 1)\ndef a(n): return (sum([sum([sum([sum([c(n, k, i, j, p) for p in range(k - i - j, n + 1)]) for j in range(k - i + 1)]) for i in range(k + 1)]) for k in range(1, n + 1)]) + sum(binomial(n, k)**2*factorial(k)*factorial(k - 1) for k in range(2, n + 1)))/2 - n**2\nprint([a(k) for k in range(1, 13)]) \n"}
{"sequence_id": "A234953", "text": "Normalized total height of all rooted trees on n labeled nodes.", "sequence": "0,1,5,37,357,4351,64243,1115899,22316409,505378207,12789077631,357769603027,10965667062133,365497351868767,13163965052815515,509522144541045811,21093278144993719665,930067462093579181119,43518024090910884374263,2153670733766937656155699", "code": "\nfrom sympy import binomial\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n, h): return 1 if min(n, h)==0 else sum([binomial(n - 1, j - 1)*j*b(j - 1, h - 1)*b(n - j, h) for j in range(1, n + 1)])\ndef T(n, k): return b(n - 1, k - 1) - b(n - 1, k - 2)\ndef a(n): return sum([k*T(n, k) for k in range(1, n)])\nprint([a(n) for n in range(1, 31)]) \n"}
{"sequence_id": "A234964", "text": "Numbers of the form 123...n - (n+1)", "sequence": "9,119,1229,12339,123449,1234559,12345669,123456779,12345678899,1234567890999,123456789101099,12345678910111199,1234567891011121299,123456789101112131399,12345678910111213141499,1234567891011121314151599,123456789101112131415161699", "code": "\ndef Concatenate(x):\n..num = ''\n..for n in range(1,x+1):\n....num += str(n)\n..return int(num)\n{print(Concatenate(x)-(x+1)) for x in range(1,50)}\n"}
{"sequence_id": "A234965", "text": "Numbers n such that 123...n - (n+1) is prime.", "sequence": "4,6,10,12,63,270,466,898,1647", "code": "\ndef Concatenate(x):\n..num = ''\n..for n in range(1,x+1):\n....num += str(n)\n..return int(num)\nimport sympy\nfrom sympy import isprime\n{print(x) for x in range(1,10**3) if isprime(Concatenate(x)-(x+1))}\n"}
{"sequence_id": "A234966", "text": "Least number k with at least one zero such that k^n contains no zero, or 0 if no such number exists.", "sequence": "0,106,104,104,105,102,102,408,104,107,203,109,103,103,1056,3703,4604,207,606,11018,3069,20064", "code": "\ndef f(x):\n    for n in range(10**7):\n        if \"0\" in str(n):\n            if \"0\" not in str(n**x):\n                return n\nfor x in range(1, 75):\n    if f(x) is None:\n        print(0)\n    else:\n        print(f(x))\n"}
{"sequence_id": "A234967", "text": "Smallest zeroless number such that a(n)^n has at least one zero.", "sequence": "32,16,7,4,4,8,5,6,2,2,2,4,5,3,3,2,3,4,2,2,2,2,4,3,2,4,4,2,2,4,3,3,4,3,3,3,2,3,2,2,2,2,2,2,2,2,2,3,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,3,2,2", "code": "\ndef f(x):\n..for n in range(10**7):\n....if str(n).find(\"0\") == -1:\n......if str(n**x).find(\"0\") > -1:\n........return n\nx = 1\nwhile x < 75:\n..if f(x) == None:\n....print(0)\n..else:\n....print(f(x))\n..x += 1\n"}
{"sequence_id": "A235000", "text": "Primes which become palindromic primes when the digits are rotated once to the right.", "sequence": "2,3,5,7,11,199,277,311,577,733,811,877,911,977,10133,13177,22277,27211,27277,28211,32377,33311,40499,43411,43499,45433,46499,49499,55511,60611,62633,63611,65633,67699,72733,79777,80833,84811,87833,87877,93911,98911", "code": "\nfrom sympy import isprime\ndef palQgen10(l): \n....if l > 0:\n........yield 0\n........for x in range(1,l+1):\n............for y in range(10**(x-1),10**x):\n................s = str(y)\n................yield int(s+s[-2::-1])\n............for y in range(10**(x-1),10**x):\n................s = str(y)\n................yield int(s+s[::-1])\nA235000_list = []\nfor x in palQgen10(5):\n....s = str(x)\n....y = int(s[1:]+s[0])\n....if (s[1] if len(s) > 1 else []) != '0' and isprime(x) and isprime(y):\n........A235000_list.append(y)\nA235000_list = sorted(A235000_list) \n"}
{"sequence_id": "A235052", "text": "a(n) = smallest number > 1 such that a(n)^n contains a(n) as a substring.", "sequence": "2,5,4,5,2,4,2,2,2,2,2,3,2,4,2,3,2,2,2,3,2,3,3,2,2,3,2,2,2,2,2,2,2,4,3,3,2,2,3,2,2,3,2,2,2,3,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2", "code": "\ndef f(x):\n..for n in range(2,10**3):\n....if str(n**x).count(str(n)) > 0:\n......return n\nx = 1\nwhile x < 200:\n..print(f(x))\n..x += 1\n"}
{"sequence_id": "A235053", "text": "Numbers n of the form p^2 + 1 (for prime p) where n^2 + 1 is also prime.", "sequence": "10,26,170,1850,2210,16130,69170,76730,85850,113570,120410,157610,196250,218090,237170,253010,332930,351650,368450,452930,528530,537290,597530,734450,786770,822650,1329410,2036330,2211170", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n**2+1) for n in range(10**7) if isprime(n) if isprime((n**2+1)**2+1)}\n"}
{"sequence_id": "A235163", "text": "Number of positive integers with n digits in which adjacent digits differ by at most 1.", "sequence": "9,26,75,217,629,1826,5307,15438,44941,130900,381444,1111926,3242224,9455987,27583372,80472698,234799873,685149328,1999414181,5835044495,17029601028,49702671494,145066398937,423412132499,1235854038791,3607255734629,10529101874491", "code": "\nfrom functools import cache\n@cache\ndef u(n, r):\n    if r < 0 or r > 9: return 0\n    if n == 1: return (r > 0)\n    return u(n-1, r-1) + u(n-1, r) + u(n-1, r+1)\ndef a(n): return sum(u(n, r) for r in range(10))\nprint([a(n) for n in range(1, 28)]) \n"}
{"sequence_id": "A235164", "text": "Numbers whose digits, when the number is written in base n+1, are a permutation of 1...n, and such that for all k in {1,...,n} the first k digits (still in base n+1) form a number divisible by k.", "sequence": "1,27,57,2285,7465,874615,1391089,1538257,381654729,559922224824157", "code": "\ndef vgen(n,b):\n....if n == 1:\n........t = list(range(1,b))\n........for i in range(1,b):\n............u = list(t)\n............u.remove(i)\n............yield i, u\n....else:\n........for d, v in vgen(n-1,b):\n............for g in v:\n................k = d*b+g\n................if not k % n:\n....................u = list(v)\n....................u.remove(g)\n....................yield k, u\nA235164_list = [a for n in range(2,15,2) for a, b in vgen(n-1,n)] \n"}
{"sequence_id": "A235269", "text": "floor(s*t/(s+t)), where s(n) are the squares, t(n) the triangular numbers.", "sequence": "0,1,3,6,9,13,17,23,28,35,42,50,59,68,78,88,100,111,124,137,151,166,181,197,213,231,248,267,286,306,327,348,370,392,416,439,464,489,515,542,569,597,625,655,684,715,746,778,811,844,878,912,948,983,1020,1057", "code": "\nfor n in range(1, 99):\n  s = n*n\n  t = n*(n+1)/2\n  print str(s*t//(s+t))+',',\n"}
{"sequence_id": "A235347", "text": "Series reversion of x*(1-3*x^2)/(1-x^2) in odd-order powers.", "sequence": "1,2,14,130,1382,15906,192894,2427522,31405430,415086658,5580629870,76080887042,1049295082630,14613980359010,205246677882078,2903566870820610,41337029956899222,591796707042765954,8514525059135909070,123048063153362454402", "code": "\n\nm = len(a)+1\nd = 0\nfor i in range (1,m):\n....for j in range (1,m):\n........if (i+j)%m ==0 and (i+j) <= m:\n............d = d + a[i-1]*a[j-1]\ng = 0\nfor i in range (1,m):\n....for j in range (1,m):\n........for k in range (1,m):\n............if (i+j+k)%(m+1) ==0 and (i+j+k) <= (m+1):\n................g = g + a[i-1]*a[j-1]*a[k-1]\ny = 3*g - d\n\n"}
{"sequence_id": "A235348", "text": "Series reversion of x*(1-2*x-5*x^2)/(1-x^2).", "sequence": "1,2,12,82,636,5266,45684,409706,3768132,35346082,336854844,3252391170,31746462732,312755404818,3105750620772,31054695744570,312404601250644,3159598296022978,32108181705850860,327682918265502002,3357089384702757276", "code": "\n\nm = len(a)\nif m%2 ==0:\n....b = (a[m/2-1])**2\nelse:\n....b = 0\nd = 0\nfor i in range (1,m+3):\n....for j in range (1,m+3):\n........if (i+j)%m ==0 and (i+j) <= m and i!=j:\n............d = d + a[i-1]*a[j-1]\nf = 0\nfor i in range (1,m+1):\n....for j in range (1,m+1):\n........if (i+j)%(m+1) ==0 and (i+j) <= (m+1):\n............f = f + a[i-1]*a[j-1]\ng = 0\nfor i in range (1,m+1):\n....for j in range (1,m+1):\n........for k in range (1,m+1):\n............if (i+j+k)%(m+1) ==0 and (i+j+k) <= (m+1):\ng = g + a[i-1]*a[j-1]*a[k-1]\ny = 5*g + 2*f - b - d\n\n"}
{"sequence_id": "A235349", "text": "Series reversion of x*(1-x-2*x^2)/(1-x).", "sequence": "0,1,0,2,2,14,30,146,434,1862,6470,26586,99946,406366,1593774,6492450,26100578,106979894,436906902,1803472874,7446478746,30945624910,128821054846,538584390834,2256485249682,9483898177574", "code": "\n\nm = len(a)\nd = 0\nfor i in range (1,m+1):\n....for j in range (1,m+1):\n........if (i+j)%(m+1) ==0 and (i+j) <= (m+1):\n............d = d + a[i-1]*a[j-1]\ng = 0\nfor i in range (1,m):\n....for j in range (1,m):\n........for k in range (1,m):\n............if (i+j+k)%(m+1) ==0 and (i+j+k) <= (m+1):\n................g = g + a[i-1]*a[j-1]*a[k-1]\ny = 2*g + d - a[m-1]\n\n"}
{"sequence_id": "A235350", "text": "Series reversion of x*(1-2*x-x^2)/(1-x^2).", "sequence": "1,2,8,42,248,1570,10416,71474,503088,3612226,26353720,194806458,1455874792,10982013250,83504148192,639360351074,4925190101600,38144591091970,296837838901992,2319880586624714,18200693844341720,143294043656426082,1131747417739664528", "code": "\n\nm = len(a)\nd = 0\nfor i in range (1,m+3):\n....for j in range (1,m+3):\n........if (i+j)%m ==0 and (i+j) <= m:\n............d = d + a[i-1]*a[j-1]\nf = 0\nfor i in range (1,m+1):\n....for j in range (1,m+1):\n........if (i+j)%(m+1) ==0 and (i+j) <= (m+1):\n............f = f + a[i-1]*a[j-1]\ng = 0\nfor i in range (1,m+1):\n....for j in range (1,m+1):\n........for k in range (1,ip):\n............if (i+j+k)%(m+1) ==0 and (i+j+k) <= (m+1):\n................g = g + a[i-1]*a[j-1]*a[k-1]\ny = g + 2*f - d\n\n"}
{"sequence_id": "A235351", "text": "Series reversion of x*(1-3*x-2*x^2)/(1-x).", "sequence": "1,2,12,84,660,5548,48836,444412,4147220,39471436,381671204,3738957148,37028943860,370123733932,3729092573060,37831802166076,386135110256852,3962278590508812,40852572573083364,423006921400424988,4396894566694687924", "code": "\n\nm = len(a)+1\nd = 0\nfor i in range (1,m):\n....for j in range (1,m):\n........if (i+j)%m ==0 and (i+j) <= m:\n............d = d + a[i-1]*a[j-1]\ng = 0\nfor i in range (1,m):\n....for j in range (1,m):\n........for k in range (1,m):\n............if (i+j+k)%m ==0 and (i+j+k) <= m:\n................g = g + a[i-1]*a[j-1]*a[k-1]\ny = 2*g + 3*d - a[m-2]\n\n"}
{"sequence_id": "A235452", "text": "Take the union of all the sequences Collatz(i) for i <= n. The number a(n) is the largest of consecutive numbers beginning with 1.", "sequence": "1,2,5,5,5,6,8,8,11,11,11,14,14,14,17,17,17,18,20,20,23,23,23,24,26,26,29,29,29,32,32,32,35,35,35,36,38,38,41,41,41,42,44,44,47,47,47,50,50,50,53,53,53,54,56,56,59,59,59,62,62,62,65,65,65", "code": "\ndef A235452(n=100):\n....a=set([])\n....A235452={1:1}\n....for i in range(2,n):\n........c = i\n........a.add(c)\n........while c <> 1:\n............if c%2 == 1:\n................c = 3*c + 1\n................a.add(c)\n............c = c/2\n............a.add(c)\n........k = 1\n........while k in a:\n............k +=1\n........A235452[i]=k-1\n....return A235452\n"}
{"sequence_id": "A235532", "text": "a(n) = floor(n^2 * (4-Pi)).", "sequence": "0,0,3,7,13,21,30,42,54,69,85,103,123,145,168,193,219,248,278,309,343,378,415,454,494,536,580,625,672,721,772,824,879,934,992,1051,1112,1175,1239,1305,1373,1442,1514,1587,1661,1738,1816,1896,1977,2061,2146,2232,2321", "code": "\nimport math\nfor n in range(77): print(str(int(n*n*(4-math.pi))), end=',')\n"}
{"sequence_id": "A235540", "text": "Composite numbers m such that (4^m - 2^m + 8*m^2 - 2) / (2*m*(2*m + 1)) is an integer.", "sequence": "243,891,1539,2211,2511,13203,19683,87723,92583,150851,202851,292923,321651,399771,412623,452051,1325843,1330551,1441091,1566891,3026871,4422231,4954851,4974971,5016191,5845851,5971239,6773139,11050911,11720511,12602871,14666751", "code": "\nfrom gmpy2 import is_prime, powmod, t_mod\nA235540_list = []\nfor i in range(1,10**9+1):\n....if not is_prime(i):\n........d = 2*i*(2*i+1)\n........n = t_mod(powmod(4,i,d)-powmod(2,i,d)+8*i*i-2,d)\n........if not n:\n............A235540_list.append(i) \n"}
{"sequence_id": "A235595", "text": "Triangle read by rows: the triangle in A034855, with the n-th row normalized by dividing it by n.", "sequence": "1,1,2,1,9,6,1,40,60,24,1,195,560,420,120,1,1056,5550,6240,3240,720,1,6321,59472,94710,68880,27720,5040,1,41392,692440,1527456,1426320,792960,262080,40320,1,293607,8753040,26418168,30560544,21213360,9676800,2721600,362880,1,2237920,119723130,490458240,691331760,570810240,323114400,125798400,30844800,3628800", "code": "\nfrom sympy import binomial\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n, h): return 1 if min(n, h)==0 else sum([binomial(n - 1, j - 1)*j*b(j - 1, h - 1)*b(n - j, h) for j in range(1, n + 1)])\ndef T(n, k): return b(n - 1, k - 1) - b(n - 1, k - 2)\nfor n in range(2, 13): print([T(n, d) for d in  range(1, n)]) \n"}
{"sequence_id": "A235596", "text": "Second column of triangle in A235595.", "sequence": "0,0,2,9,40,195,1056,6321,41392,293607,2237920,18210093,157329096,1436630091,13810863808,139305550065,1469959371232,16184586405327,185504221191744,2208841954063317,27272621155678840,348586218389733555,4605223387997411872,62797451641106266329,882730631284319415504", "code": "\nfrom sympy import binomial\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n, h): return 1 if min(n, h)==0 else sum([binomial(n - 1, j - 1)*j*b(j - 1, h - 1)*b(n - j, h) for j in range(1, n + 1)])\ndef a(n): return b(n - 1, 1) - b(n - 1, 0)\nprint([a(n) for n in range(1, 31)]) \n"}
{"sequence_id": "A235707", "text": "Floor(n^2 * log(n)).", "sequence": "0,2,9,22,40,64,95,133,177,230,290,357,433,517,609,709,818,936,1062,1198,1342,1496,1658,1830,2011,2202,2402,2612,2831,3061,3300,3548,3807,4076,4355,4644,4943,5252,5572,5902,6242,6593,6954,7326,7708,8101,8504,8919", "code": "\nimport math\nfor n in range(1,100):  print str(int(n*n*math.log(n)))+',',\n"}
{"sequence_id": "A235713", "text": "Least number k such that 2^k begins with exactly n identical digits.", "sequence": "1,25,143,1598,10627,194220,26399,37811757,15689797,1609719151,42001126081,42116737194,2277292670319,8475536580225,57483036385216,1185808703658960,2800250032195382,203292337502775829,294180235677139843,28666496154250702728", "code": "\ndef b(n):\n..for k in range(1,2*10**5):\n....st = str(2**k)\n....count = 0\n....if len(st) >= n:\n......for i in range(len(st)):\n........if st[i] == st[0]:\n..........count += 1\n........else:\n..........break\n......if count == n:\n........return k\nn = 1\nwhile n < 10:\n..print(b(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A235791", "text": "Irregular triangle read by rows: T(n,k), n >= 1, k >= 1, in which column k lists k copies of every positive integer in nondecreasing order, and the first element of column k is in row k(k+1)/2.", "sequence": "1,2,3,1,4,1,5,2,6,2,1,7,3,1,8,3,1,9,4,2,10,4,2,1,11,5,2,1,12,5,3,1,13,6,3,1,14,6,3,2,15,7,4,2,1,16,7,4,2,1,17,8,4,2,1,18,8,5,3,1,19,9,5,3,1,20,9,5,3,2,21,10,6,3,2,1,22,10,6,4,2,1,23,11,6,4,2,1,24,11,7,4,2,1", "code": "\nfrom sympy import sqrt\nimport math\ndef T(n, k): return int(math.ceil((n + 1)/k - (k + 1)/2))\nfor n in range(1, 21): print([T(n, k) for k in range(1, int(math.floor((sqrt(8*n + 1) - 1)/2)) + 1)]) \n"}
{"sequence_id": "A235800", "text": "Length of n-th vertical line segment from left to right in a diagram of a two-dimensional version of the Collatz (or 3x + 1) problem.", "sequence": "3,1,7,2,11,3,15,4,19,5,23,6,27,7,31,8,35,9,39,10,43,11,47,12,51,13,55,14,59,15,63,16,67,17,71,18,75,19,79,20,83,21,87,22,91,23,95,24,99,25,103,26,107,27,111,28,115,29,119,30,123,31,127,32", "code": "\nfrom __future__ import division\nA235800_list = [4*(n//2) + 3 if n % 2 else n//2 for n in range(1,10**4)] \n"}
{"sequence_id": "A235801", "text": "Length of n-th horizontal line segment in a diagram of a two-dimensional version of the Collatz (or 3x + 1) problem.", "sequence": "0,1,2,3,7,5,6,7,8,9,17,11,12,13,14,15,27,17,18,19,20,21,37,23,24,25,26,27,47,29,30,31,32,33,57,35,36,37,38,39,67,41,42,43,44,45,77,47,48,49,50,51,87,53,54,55,56,57,97,59,60,61,62,63,107,65,66", "code": "\nfrom __future__ import division\nA235801_list = [n if n % 6 != 4 else 10*(n//6)+7 for n in range(10**4)] \n"}
{"sequence_id": "A235807", "text": "Numbers n such that n^3 has one or more occurrences of exactly five different digits.", "sequence": "22,24,27,29,32,35,38,41,47,48,49,51,52,54,55,57,61,63,65,71,72,82,85,87,89,94,96,102,103,104,105,108,109,119,120,123,125,126,127,130,133,134,136,137,138,141,143,144,149,152,153,154,155,158,162,165,167", "code": "\nA235807_list, m = [], [6, -6, 1, 0]\nfor n in range(1,10**5+1):\n....for i in range(3):\n........m[i+1] += m[i]\n....if len(set(str(m[-1]))) == 5:\n........A235807_list.append(n) \n"}
{"sequence_id": "A235808", "text": "Numbers n such that n^3 has one or more occurrences of exactly six different digits.", "sequence": "59,66,69,73,75,76,84,88,93,97,107,112,113,115,116,118,124,128,129,131,139,147,148,151,156,159,161,166,168,169,174,178,181,183,184,187,189,193,194,196,207,219,226,232,234,235,236,238,240,241,246,253,255,262", "code": "\nA235808_list, m = [], [6, -6, 1, 0]\nfor n in range(1,10**4+1):\n....for i in range(3):\n........m[i+1] += m[i]\n....if len(set(str(m[-1]))) == 6:\n........A235808_list.append(n) \n"}
{"sequence_id": "A235810", "text": "Numbers n such that n^3 has one or more occurrences of exactly eight different digits.", "sequence": "289,297,302,319,467,494,515,557,562,595,621,623,676,682,709,712,721,862,887,909,939,945,949,963,984,987,1012,1015,1016,1025,1029,1043,1049,1065,1075,1087,1104,1106,1107,1114,1118,1132,1137,1154,1161,1167,1178", "code": "\nA235810_list, m = [], [6, -6, 1, 0]\nfor n in range(1,10**3+1):\n....for i in range(3):\n........m[i+1] += m[i]\n....if len(set(str(m[-1]))) == 8:\n........A235810_list.append(n) \n"}
{"sequence_id": "A235811", "text": "Numbers n such that n^3 has one or more occurrences of exactly nine different digits.", "sequence": "1018,1028,1112,1452,1475,1484,1531,1706,1721,1733,1818,1844,1895,1903,2008,2033,2208,2214,2217,2223,2257,2274,2277,2327,2329,2336,2354,2394,2403,2524,2525,2589,2647,2686,2691,2694,2727,2733,2784,2842,2866,2884,2890", "code": "\nA235811_list, m = [], [6, -6, 1, 0]\nfor n in range(1,10**4+1):\n....for i in range(3):\n........m[i+1] += m[i]\n....if len(set(str(m[-1]))) == 9:\n........A235811_list.append(n) \n"}
{"sequence_id": "A235869", "text": "Least number k such that 3^k begins with exactly n identical digits.", "sequence": "1,19,33,2061,6563,17853,2319050,2061700,57587802,2725111202,6121395677,79432391610,5689239922828,9667911135850,253066675679888,959406299366116,2267148455007422,182092146481798583,1074950828335499452,3586769629515088106,72389675081649855753", "code": "\ndef b(n):\n..for k in range(1,2*10**5):\n....st = str(3**k)\n....count = 0\n....if len(st) >= n:\n......for i in range(len(st)):\n........if st[i] == st[0]:\n..........count += 1\n........else:\n..........break\n......if count == n:\n........return k\nn = 1\nwhile n < 10:\n..print(b(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A235913", "text": "a(n) is the Manhattan distance between n^3 and (n+1)^3 in a square spiral of positive integers with 1 at the center.", "sequence": "1,3,11,15,13,9,5,21,33,59,71,49,47,35,15,13,43,73,109,123,117,109,167,141,113,77,43,5,51,95,145,201,263,281,397,413,317,333,269,239,183,121,63,11,81,147,219,307,379,471,567,623,517,569,683,503,545,473,395,311", "code": "\nimport math\ndef get_x_y(n):\n  sr = int(math.sqrt(n-1))  \n  sr = sr-1+(sr&1)\n  rm = n-sr*sr\n  d = (sr+1)/2\n  if rm<=sr+1:\n     return -d+rm, d\n  if rm<=sr*2+2:\n     return d, d-(rm-(sr+1))\n  if rm<=sr*3+3:\n     return d-(rm-(sr*2+2)), -d\n  return -d, -d+rm-(sr*3+3)\nfor n in range(1, 77):\n  x0, y0 = get_x_y(n**3)\n  x1, y1 = get_x_y((n+1)**3)\n  print str(abs(x1-x0)+abs(y1-y0))+',',\n"}
{"sequence_id": "A235915", "text": "a(1) = 1, a(n) = a(n-1) + (digsum(a(n-1)) mod 5) + 1, digsum = A007953.", "sequence": "1,3,7,10,12,16,19,20,23,24,26,30,34,37,38,40,45,50,51,53,57,60,62,66,69,70,73,74,76,80,84,87,88,90,95,100,102,106,109,110,113,114,116,120,124,127,128,130,135,140,141", "code": "def adddigits(i):..s = str(i)...t=0...for j in s:......t = t+int(j)...return t.n = 1.a = [].for i in range(0, 100):...r = adddigits(n)%5+1...n = n+r...a.append(n).print(a)\n"}
{"sequence_id": "A235982", "text": "Numbers n of the form p^4 + 1 (for prime p) such that n^4 + 1 is also prime.", "sequence": "82,38950082,47458322,131079602,1982119442,25856961602,58120048562,602425897922,1053022816562,1267247769842,3491998578722,7181161893362,7759350084722,10756569837842,16948379819282,28424689653362,33122338550402,36562351115762,50897394646082", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n**4+1) for n in range(10000) if isprime(n) if isprime((n**4+1)**4+1)}\n"}
{"sequence_id": "A235983", "text": "Numbers n of the form p^8 + 1 (for prime p) such that n^8 + 1 is also prime.", "sequence": "5764802,146830437604322,498311414318121122,554786279519086052117762,830149880552636599409282,12628864335244989661982882,33144490094099439467757602,47203563969247823515902242,179357590196404221918909122,397370823547272766854136322,2043714066708245412886790402,139717795608648816763227344162", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n**8+1) for n in range(10000) if isprime(n) if isprime((n**8+1)**8+1)}\n"}
{"sequence_id": "A236042", "text": "Primes p such that 100*p+1, 100*p+3, 100*p+7, and 100*p+9 are all prime.", "sequence": "1657,2437,6073,10687,11677,13297,13399,33289,35869,40927,46093,57601,61933,77743,97927,125119,127447,130411,140827,141397,189229,217207,246439,271573,289987,292867,292969,297469,329803", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**6) if isprime(p) and isprime(100*p+1) and isprime(100*p+3) and isprime(100*p+7) and isprime(100*p+9)}\n"}
{"sequence_id": "A236043", "text": "Number of triangular numbers <= 10^n.", "sequence": "5,14,45,141,447,1414,4472,14142,44721,141421,447214,1414214,4472136,14142136,44721360,141421356,447213595,1414213562,4472135955,14142135624,44721359550,141421356237,447213595500,1414213562373,4472135955000,14142135623731", "code": "\ndef Tri(x):\n..count = 0\n..for n in range(10**40):\n....if n*(n+1)/2 <= 10**x:\n......count += 1\n....else:\n......return count\nx = 1\nwhile x < 50:\n..print(Tri(x))\n..x += 1\n"}
{"sequence_id": "A236044", "text": "Primes p such that p^4 + p + 1 is prime.", "sequence": "2,5,11,47,89,107,131,191,197,239,347,641,701,839,941,977,1049,1061,1289,1709,1847,1871,1949,1979,2129,2789,2897,3371,3557,3719,3761,3917,4001,4091,4211,4289,4337,4397,4547,4751", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**5) if isprime(p) and isprime(p**4+p+1)}\n"}
{"sequence_id": "A236045", "text": "Primes p such that p^1+p+1, p^2+p+1, p^3+p+1, and p^4+p+1 are all prime.", "sequence": "2,5,131,2129,9689,27809,36821,46619,611729,746171,987491,1121189,1486451,2215529,2701931,4202171,4481069,4846469,5162141,5605949,6931559,7181039,8608571,9276821,9762611,11427491,11447759,12208019", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**8) if isprime(p) and isprime(p**1+p+1) and isprime(p**2+p+1) and isprime(p**3+p+1) and isprime(p**4+p+1)}\n"}
{"sequence_id": "A236056", "text": "Numbers k such that k^2 +- k +- 1 is prime for all four possibilities.", "sequence": "3,6,21,456,1365,2205,2451,2730,8541,18486,32199,32319,32781,45864,61215,72555,72561,82146,83259,86604,91371,95199,125334,149331,176889,182910,185535,210846,225666,226254,288420,343161,350091,403941,411501,510399,567204", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**6) if isprime(p**2+p+1) and isprime(p**2-p+1) and isprime(p**2+p-1) and isprime(p**2-p-1)}\n"}
{"sequence_id": "A236067", "text": "a(n) is the least number m such that m = n^d_1 + n^d_2 + ... + n^d_k where d_k represents the k-th digit in the decimal expansion of m, or 0 if no such number exists.", "sequence": "1,0,12,4624,3909511,0,13177388,1033,10,0,0,0,0,0,2758053616,1053202,7413245658,419370838921,52135640,1347536041,833904227332,5117557126,3606012949057,5398293152472,31301,0,15554976231978,405287637330,35751665247,19705624111111", "code": "\ndef Min(n):\n..for k in range(1,10**3):\n....if n+k <= 10**k:\n......return 10**k\ndef Max(n):\n..for k in range(1,10**3):\n....if k*(n**9) <= 10**k-1:\n......return 10**(k-1)\ndef div10(n):\n..for j in range(10**3):\n....if n%10**j!=0:\n......return j\ndef a(n):\n..k = Min(n)\n..while k <= Max(n):\n....tot = 0\n....for i in str(k):\n......tot += n**(int(i))\n....if tot == k:\n......return k\n....if tot < k:\n......k += 1\n....if tot > k-1:\n......k = (1+k//10**div10(k))*10**div10(k)\nn = 1\nwhile n < 100:\n..if a(n):\n....print(a(n),end=', ')\n..else:\n....print(0,end=', ')\n..n += 1\n\n"}
{"sequence_id": "A236068", "text": "Primes p such that f(f(p)) is prime, where f(x) = x^2 + 1.", "sequence": "3,5,13,43,47,127,263,277,293,337,347,397,443,467,487,503,577,593,607,673,727,733,773,857,887,907,1153,1427,1487,1567,1583,1637,1777,2003,2213,2243,2477,2503,2557,2633,2687,2777", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**4) if isprime(p) and isprime((p**2+1)**2+1)}\n"}
{"sequence_id": "A236069", "text": "Primes p such that f(f(p)) is prime where f(x) = x^4 + 1.", "sequence": "3,79,83,107,211,401,491,881,1013,1061,1367,1637,1669,1811,2029,2309,2399,2459,2671,2713,2963,3109,3203,3407,3593,3709,3733,3929,4219,4457,4513,4639,4703,4729,5417,5641,6047,6113", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**4) if isprime(p) and isprime((p**4+1)**4+1)}\n"}
{"sequence_id": "A236070", "text": "Primes p such that f(f(p)) is prime where f(x) = x^8 + 1.", "sequence": "7,59,163,929,977,1373,1549,1619,1913,2113,2593,4397,5417,5651,6397,6659,6833,7351,7793,7883,8641,9719,10091,10477,10949,11243,12239,13441,13457,13691,14753,15349,15467,15971,17747,19051", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**5) if isprime(p) and isprime((p**8+1)**8+1)}\n"}
{"sequence_id": "A236071", "text": "Primes p such that p^4 - p - 1 is prime.", "sequence": "2,5,7,11,13,23,53,61,71,79,137,139,193,229,239,251,293,317,373,433,523,599,601,683,727,859,877,887,911,991,1009,1163,1229,1297,1303,1429,1481,1483,1789,1801,1871,1999,2011", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**4) if isprime(p**4-p-1) and isprime(p)}\n"}
{"sequence_id": "A236072", "text": "Numbers n such that n^4 + n + 1 and n^4 - n - 1 are prime.", "sequence": "2,5,6,9,11,26,44,60,77,147,239,384,545,690,770,779,1071,1127,1190,1271,1296,1331,1506,1659,1707,1871,1880,1986,2037,2442,2520,2541,2714,2960,2982,3045,3060,3110,3189,3287,3464,3609", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**4) if isprime(p**4-p-1) and isprime(p**4+p+1)}\n"}
{"sequence_id": "A236073", "text": "Primes p such that p^4 + p + 1 and p^4 - p - 1 are also prime.", "sequence": "2,5,11,239,1871,4001,4397,6971,12647,12689,13337,13619,15401,19391,19559,19739,20201,20297,22871,22937,28307,30029,32561,36299,36929,39569,44279,45497,47441,48767,50069,53897,55871", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**5) if isprime(p**4+p+1) and isprime(p**4-p-1) and isprime(p)}\n"}
{"sequence_id": "A236104", "text": "Triangle read by rows: T(n,k), n >= 1, k >= 1, in which column k lists k copies of the positive squares in nondecreasing order, and the first element of column k is in row k(k+1)/2.", "sequence": "1,4,9,1,16,1,25,4,36,4,1,49,9,1,64,9,1,81,16,4,100,16,4,1,121,25,4,1,144,25,9,1,169,36,9,1,196,36,9,4,225,49,16,4,1,256,49,16,4,1,289,64,16,4,1,324,64,25,9,1,361,81,25,9,1,400,81,25,9,4", "code": "\nfrom sympy import sqrt\nimport math\ndef T(n, k): return int(math.ceil((n + 1)/k - (k + 1)/2))\nfor n in range(1, 21): print([T(n, k)**2 for k in range(1, int(math.floor((sqrt(8*n + 1) - 1)/2)) + 1)]) \n"}
{"sequence_id": "A236167", "text": "Numbers k such that (47^k + 1)/48 is prime.", "sequence": "5,19,23,79,1783,7681", "code": "\nfrom sympy import isprime\ndef afind(startat=0, limit=10**9):\n  pow47 = 47**startat\n  for k in range(startat, limit+1):\n    q, r = divmod(pow47+1, 48)\n    if r == 0 and isprime(q): print(k, end=\", \")\n    pow47 *= 47\nafind(limit=300) \n"}
{"sequence_id": "A236168", "text": "Primes p such that p^3 - p - 1 is prime.", "sequence": "2,3,11,23,29,31,41,59,71,113,151,163,191,239,241,269,359,431,433,499,503,521,541,563,661,683,701,751,773,829,883,983,1039,1259,1483,1499,1511,1549,1571,1609,1693,1721,1759,1913", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**4) if isprime(p) and isprime(p**3-p-1)}\n"}
{"sequence_id": "A236171", "text": "Numbers k such that k^2 - k - 1, k^3 - k - 1, and k^4 - k - 1 are all prime.", "sequence": "4,9,11,16,55,60,71,189,361,450,469,669,1261,1351,1490,1591,2101,2254,2396,2594,3774,3866,4011,5375,5551,5840,6070,7336,7545,7666,7735,8105,8255,9825,10525,11621,12100,13084,13454", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**5) if isprime(n**2-n-1) and isprime(n**3-n-1) and isprime(n**4-n-1)}\n"}
{"sequence_id": "A236173", "text": "Primes p such that p^2 - p - 1, p^3 - p - 1 and p^4 - p - 1 are all prime.", "sequence": "11,71,11621,28151,32089,37501,39209,45329,66161,76649,114599,122131,136949,154991,202999,228901,243391,270269,296911,313909,318679,333701,343309,359291,369979,371281,371981,373171,373459", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**6) if isprime(p) and isprime(p**2-p-1) and isprime(p**3-p-1) and isprime(p**4-p-1)}\n"}
{"sequence_id": "A236174", "text": "Maximal prime among the base-k representations of the n-th prime, read in decimal, for k=2,3,...,10.", "sequence": "2,11,101,13,23,31,101,103,10111,131,43,211,131,223,101111,311,113,331,2111,1013,1021,2221,1103,1011001,1201,1100101,10211,1223,1231,1301,331,2003,211,12011,10010101,2113,10011101,10100011,2213,10101101,10110011,20201,2333,21011,3011,11000111,21211,337,3203,11100101", "code": "\nfrom sympy import prime, isprime\ndef A236174(n):\n....p = prime(n)\n....for b in range(2,11):\n........x, y, z = p, 0, 1\n........while x >= b:\n............x, r = divmod(x,b)\n............y += r*z\n............z *= 10\n........y += x*z\n........if isprime(y):\n............return y \n"}
{"sequence_id": "A236246", "text": "Indices n for which A229037(n)=1.", "sequence": "1,2,4,5,10,11,13,14,28,29,31,32,37,38,40,41,82,83,85,86,92,93,96,105,111,112,115,116,122,177,236,237,244,245,247,266,267,270,276,277,283,294,301,302,347,558,628,638,646,647,649,655,669,674,685,686", "code": "\nA236246_list, A229037_list = [], []\nfor n in range(10**6):\n....i, j, b = 1, 1, set()\n....while n-2*i >= 0:\n........b.add(2*A229037_list[n-i]-A229037_list[n-2*i])\n........i += 1\n........while j in b:\n............b.remove(j)\n............j += 1\n....A229037_list.append(j)\n....if j == 1:\n........A236246_list.append(n+1) \n"}
{"sequence_id": "A236247", "text": "Sequence of distinct least squares such that the arithmetic mean of the first n squares is also a square.", "sequence": "1,49,25,121,784,196,33124,4900,4,4356,2304324,213444,2371600,379456,87616,360000,3802500,562500,100,532900,5456896,767376,5934096,992016,9947716,1350244,32467204,44100,2414916,10458756,2683044", "code": "\ndef Sq(x):\n..for n in range(10**15):\n....if x == n**2:\n......return True\n....if x < n**2:\n......return False\n..return False\ndef SqAve(init):\n..print(init)\n..lst = []\n..lst.append(init)\n..n = 1\n..while n < 10**9:\n....if n**2 not in lst:\n......if Sq(((sum(lst)+n**2)/(len(lst)+1))):\n........print(n**2)\n........lst.append(n**2)\n........n = 1\n......else:\n........n += 1\n....else:\n......n += 1\nSqAve(1)\n"}
{"sequence_id": "A236312", "text": "a(n) = floor((n + e)^2), where e is the natural logarithm base.", "sequence": "7,13,22,32,45,59,76,94,114,137,161,188,216,247,279,313,350,388,429,471,516,562,610,661,713,768,824,883,943,1006,1070,1136,1205,1275,1348,1422,1499,1577,1657,1740,1824,1911,1999,2090,2182,2277,2373,2471,2572,2674,2779", "code": "\nimport math\nfor n in range(99): print(str(int((n+math.e)**2)), end=\",\")\n"}
{"sequence_id": "A236314", "text": "Number of non-overlapping occurrences of n in the decimal representation of n^n.", "sequence": "1,0,0,0,1,3,0,0,1,1,2,0,0,0,0,2,1,0,2,0,2,0,0,1,2,0,0,1,0,0,2,2,2,0,3,1,1,0,1,0,1,1,1,0,3,1,0,1,1,1,1,2,2,1,0,1,1,0,1,3,2,0,1,1,0,2,0,0,0,0,1,0,1,1,2,5,2,1,2,0,3,3,2,1,0,1,0", "code": "\nfrom itertools import count\na=(str(n**n).count(str(n)) for n in count(1))\n"}
{"sequence_id": "A236322", "text": "Number of (potentially overlapping) occurrences of n in the decimal representation of n^n.", "sequence": "1,0,0,0,1,3,0,0,1,1,2,0,0,0,0,2,1,0,2,0,2,0,0,1,2,0,0,1,0,0,2,2,2,0,3,1,1,0,1,0,1,1,1,0,3,1,0,1,1,1,1,2,2,1,0,1,1,0,1,3,2,0,1,1,0,2,0,0,0,0,1,0,1,1,2,5,2,1,2,0,3,3,2,1,0,1,0,0,0,0,5,1,3,4,2,2,1,1,10", "code": "\nfrom itertools import count\ndef occurrences(string, sub):\n....count = start = 0\n....while True:\n........start = string.find(sub, start) + 1\n........if start > 0:\n............count+=1\n........else:\n............return count\ndef a(n):\n....return occurrences(str(n**n),str(n))\n"}
{"sequence_id": "A236345", "text": "a(n) is the Manhattan distance between n and n^2 in a left-aligned triangle with next M natural numbers in row M: 1, 2 3, 4 5 6, 7 8 9 10, etc.", "sequence": "0,1,3,3,6,10,9,14,9,15,11,18,26,17,26,19,29,40,27,39,24,42,27,39,54,35,51,36,53,71,48,67,42,62,83,56,85,56,79,48,72,97,64,90,55,90,118,81,110,71,101,68,91,123,80,122,77,111,146,99,135,86,123,88,110", "code": "\nimport math\ndef getXY(n):\n  y = int(math.sqrt(n*2))\n  if n<=y*(y+1)//2: y-=1\n  x = n - y*(y+1)//2\n  return x, y\nfor n in range(1,77):\n  ox, oy = getXY(n)\n  nx, ny = getXY(n*n)\n  print(str(abs(nx-ox)+abs(ny-oy)), end=',')\n"}
{"sequence_id": "A236346", "text": "Manhattan distances between n^2 and (n+1)^2 in a left-aligned triangle with next M natural numbers in row M: 1, 2 3, 4 5 6, 7 8 9 10, etc.", "sequence": "2,3,4,4,5,6,6,8,7,10,8,9,12,10,14,11,12,16,13,18,14,20,15,16,22,17,24,18,19,26,20,28,21,22,30,23,32,24,34,25,26,36,27,38,28,29,40,30,42,31,44,32,33,46,34,48,35,36,50,37,52,38,54,39,40,56,41,58", "code": "\nimport math\ndef getXY(n):\n  y = int(math.sqrt(n*2))\n  if n<=y*(y+1)/2: y-=1\n  x = n - y*(y+1)/2\n  return x, y\nfor n in range(1, 77):\n  ox, oy = getXY(n*n)\n  nx, ny = getXY((n+1)**2)\n  print str(abs(nx-ox)+abs(ny-oy))+',',\n"}
{"sequence_id": "A236347", "text": "Manhattan distances between n and 2*n in a left-aligned triangle with next M natural numbers in row M: 1, 2 3, 4 5 6, 7 8 9 10, etc.", "sequence": "1,1,2,2,3,3,4,3,2,3,2,3,4,5,6,5,6,7,5,4,3,9,4,3,4,5,6,10,5,6,7,8,9,8,7,6,10,11,12,6,5,4,5,6,7,4,5,6,7,8,9,10,12,11,10,10,11,12,13,14,9,8,7,6,5,6,17,18,6,5,6,7,8,9,10,11,16,15,9,10,11,12", "code": "\nimport math\ndef getXY(n):\n  y = int(math.sqrt(n*2))\n  if n<=y*(y+1)/2: y-=1\n  x = n - y*(y+1)/2\n  return x, y\nfor n in range(1,88):\n  ox, oy = getXY(n)\n  nx, ny = getXY(2*n)\n  print str(abs(nx-ox)+abs(ny-oy))+',',\n"}
{"sequence_id": "A236359", "text": "Pseudoperfect (or semiperfect) numbers in which a sum of contiguous proper divisors of n equals n.", "sequence": "6,18,24,28,36,42,54,66,78,102,108,114,126,132,138,162,174,186,196,198,222,234,246,258,282,288,294,306,318,324,342,354,360,366,378,402,414,426,432,438,462,474,486,496,498,504,522,534,540,546,558,582,594,600,606,618,642,654,666,678,684,690,696,702,714,726", "code": "\nfrom sympy import divisors\nA236359_list = []\nfor n in range(1,10**3):\n....d = divisors(n)\n....d.pop()\n....ld = len(d)\n....if sum(d) >= n:\n........s, j = d[0], 1\n........for i in range(ld-1):\n............while s < n and j < ld:\n................s += d[j]\n................j += 1\n............if s == n:\n................A236359_list.append(n)\n................break\n............j -= 1\n............s -= d[i]+d[j] \n"}
{"sequence_id": "A236402", "text": "Numbers with property that the sum of any pair of adjacent digits is a substring of the number.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100,101,102,103,104,105,106,107,108,109,200,201,202,203,204,205,206,207,208,209,300,301,302,303,304,305,306,307,308,309,400,401,402,403,404,405,406,407", "code": "\ndef ok(n):\n  s = str(n)\n  return all(str(sum(map(int, s[i:i+2]))) in s for i in range(len(s)-1))\nprint(list(filter(ok, range(408)))) \n"}
{"sequence_id": "A236415", "text": "Sequence of distinct least triangular numbers such that the arithmetic mean of the first n terms is also a triangular number. Initial term is 0.", "sequence": "0,6,3,15,741,153,25878,3828,16653,253,4753,23653,6328,53956,9730,191890,21115,140185,1225,26335,317206,3160,38503,2108431,37950,121278,1440905403,53483653,201733741,58595725,22663524351,787786971,23483020686,1475521326", "code": "\ndef Tri(x):\n..for n in range(10**10):\n....if x == n*(n+1)/2:\n......return True\n....if x < n*(n+1)/2:\n......return False\n..return False\ndef TriAve(init):\n..print(init)\n..lst = []\n..lst.append(init)\n..n = 1\n..while n*(n+1)/2 < 10**10:\n....if n*(n+1)/2 not in lst:\n......if Tri(((sum(lst)+int(n*(n+1)/2))/(len(lst)+1))):\n........print(int(n*(n+1)/2))\n........lst.append(int(n*(n+1)/2))\n........n = 1\n......else:\n........n += 1\n....else:\n......n += 1\n"}
{"sequence_id": "A236416", "text": "Sequence of distinct least positive triangular numbers such that the arithmetic mean of the first n terms is also a triangular number. Initial term is 1.", "sequence": "1,55,28,136,6670,1378,18528,3828,3,3403,39340,75466,12403,179101,24310,6,22791,290703,37675,679195,10,66430,550107865,23981275,188170300,30548836,2303731,721801,28474831,311538241,13741903,37130653,441149289778,278657028", "code": "\ndef Tri(x):\n..for n in range(10**10):\n....if x == n*(n+1)/2:\n......return True\n....if x < n*(n+1)/2:\n......return False\n..return False\ndef TriAve(init):\n..print(init)\n..lst = []\n..lst.append(init)\n..n = 1\n..while n*(n+1)/2 < 10**10:\n....if n*(n+1)/2 not in lst:\n......if Tri(((sum(lst)+int(n*(n+1)/2))/(len(lst)+1))):\n........print(int(n*(n+1)/2))\n........lst.append(int(n*(n+1)/2))\n........n = 1\n......else:\n........n += 1\n....else:\n......n += 1\n"}
{"sequence_id": "A236437", "text": "Primes which occur in their proper place in A236174.", "sequence": "2,263,269,347,397,431,461,479,499,569,599,607,677,683,719,769,797,821,929,941,1019,1031,1049,1051,1061,1069,1103,1181,1223,1229,1237,1297,1307,1367,1399,1409,1439,1453,1487,1489,1523,1553,1559,1571,1619,1637,1733,1759,1811,1823,1949,1973,1997", "code": "\nfrom sympy import prime, isprime\ndef A236174(n):\n....p = prime(n)\n....for b in range(2,11):\n........x, y, z = p, 0, 1\n........while x >= b:\n............x, r = divmod(x,b)\n............y += r*z\n............z *= 10\n........y += x*z\n........if isprime(y):\n............return y\nA236437_list = [prime(n) for n in range(1,10**6) if A236174(n) == prime(n)]\n\n"}
{"sequence_id": "A236443", "text": "Primes which start a Cunningham chain of length 4 where every entity of the chain is smallest of twin prime.", "sequence": "253679,1138829,58680929,90895769,124253009,269877299,392071679,613813199,1014342209,1277981669,1413015029,1453978679,1753585679,2919331379,3424037189,3538972709,4025789039,4175762009,4362439199,4843208789,5708418869,5795508599", "code": "\np1=2\nn=4\nmx=10\ncount=0\nwhile p1>2:\n....\n....cc=[]\n....cc.append(p1)\n....for i in range(1,n):\n........cc.append((2**(i)*p1+((2**i)-1)))\n....\n....cc2=[c+2 for c in cc]\n....\n....\n....\n....\n....pcc=pf.isp_list(cc)\n....pcc2=pf.isp_list(cc2)\n....\n....npcc=pcc.count(True)\n....\n....npcc2=pcc2.count(True)\n....if npcc==n and npcc2==n:\n........print \"For length \",n,\" the series is : \",cc,\" and \",cc2\n....p1=pf.nextp(p1)\n"}
{"sequence_id": "A236475", "text": "Numbers k such that k^3 + k - 1 is prime.", "sequence": "3,4,7,10,15,16,18,21,25,27,33,36,39,43,46,51,52,55,63,73,78,81,87,93,94,96,100,103,105,109,112,115,117,120,124,127,129,135,139,145,150,151,165,166,171,178,189,192,198,199", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**3) if isprime(n**3+n-1)}\n"}
{"sequence_id": "A236476", "text": "Primes p such that p^3 + p - 1 is prime.", "sequence": "3,7,43,73,103,109,127,139,151,199,223,241,283,313,367,379,421,541,631,661,733,739,751,769,829,991,1117,1129,1201,1231,1249,1297,1303,1429,1471,1663,1669,1693,1699,1741,1789,1867,1933", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n) and isprime(n**3+n-1)}\n"}
{"sequence_id": "A236477", "text": "Numbers k such that k^3 - k + 1 is prime.", "sequence": "2,4,6,7,10,11,14,15,19,21,22,25,26,31,35,39,41,42,45,50,52,54,57,62,75,77,84,85,87,90,92,95,99,101,102,106,111,116,120,125,129,130,132,134,136,139,140,141,147,155,167,169,176,189,195,202,221,230,237", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**3) if isprime(n**3-n+1)}\n"}
{"sequence_id": "A236478", "text": "Primes p such that p^3 - p + 1 is prime.", "sequence": "2,7,11,19,31,41,101,139,167,239,271,277,307,347,419,449,479,491,521,547,557,587,617,619,631,647,739,757,761,769,787,809,827,839,857,971,977,991,1019,1069,1187,1201,1217,1231,1277,1487,1621,1637,1709,1747,1861", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n) and isprime(n**3-n+1)}\n"}
{"sequence_id": "A236510", "text": "Numbers whose prime factorization viewed as a tuple of powers is palindromic, when viewed from the least to the largest prime present, including also any zero-exponents for the intermediate primes.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,21,22,23,25,26,27,29,30,31,32,33,34,35,36,37,38,39,41,43,46,47,49,51,53,55,57,58,59,61,62,64,65,67,69,71,73,74,77,79,81,82,83,85,86,87,89,90,91,93,94,95", "code": "\nimport re\n...\ndef factorize(n):\n...for prime in primes:\n......power = 0\n......while n%prime==0:\n.........n /= prime\n.........power += 1\n......yield power\n...\nre_zeros = re.compile('(?P<zeros>0*)(?P<middle>.*[^0])(?P=zeros)')\n...\nis_palindrome = lambda s: s==s[::-1]\n...\ndef has_palindromic_factorization(n):\n...if n==1:\n......return True\n...s = ''.join(str(x) for x in factorize(n))\n...try:\n......middle = re_zeros.match(s).group('middle')\n......if is_palindrome(middle):\n.........return True\n...except AttributeError:\n......return False\n...\na = has_palindromic_factorization\n"}
{"sequence_id": "A236513", "text": "The n-th prime with n 1-bits in its binary expansion.", "sequence": "2,5,13,53,79,373,379,983,1783,6007,7151,21503,31231,98207,129919,259967,507839,1564159,1830911,4193263,8355583,25157567,33288191,92274671,134180863,394264447,536838139,1072693243,2145382399,6442188791,8522825599,17179836413", "code": "\nfrom itertools import combinations\nfrom sympy import isprime\ndef A236513(n):\n    l, k, c = n-1, 2**n, 0\n    while True:\n        for d in combinations(range(l-1,-1,-1),l-n+1):\n            m = k-1 - sum(2**(e) for e in d)\n            if isprime(m):\n                c += 1\n                if c == n:\n                    return m\n        l += 1\n        k *= 2 \n"}
{"sequence_id": "A236524", "text": "Numbers n such that n^3 - n +/- 1 are twin primes.", "sequence": "2,4,11,14,15,21,31,35,41,45,111,130,136,140,155,176,189,221,230,239,274,316,406,414,441,465,466,504,521,561,570,580,584,591,686,689,696,759,834,836,860,869,904,960,1026,1159,1379,1539,1614,1625,1660", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**3-n-1) and isprime(n**3-n+1)}\n"}
{"sequence_id": "A236526", "text": "Numbers k such that k^3 + k +- 1 are twin primes.", "sequence": "3,15,18,21,39,87,117,120,135,243,360,366,381,426,429,615,642,723,879,1002,1023,1170,1173,1224,1458,1506,1518,1530,1731,1896,1920,1965,2007,2025,2058,2133,2160,2376,2379,2382,2406,2553,2577,2673,2703,2727", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**3+n-1) and isprime(n**3+n+1)}\n"}
{"sequence_id": "A236527", "text": "Primes obtained by concatenating to the end of previous term the next smallest number that will produce a prime, starting with 3.", "sequence": "3,31,311,3119,31193,3119317,31193171,311931713,3119317139,311931713939,31193171393933,3119317139393353,31193171393933531,3119317139393353121,311931713939335312127,311931713939335312127113,31193171393933531212711399,31193171393933531212711399123", "code": "\nimport sympy\nfrom sympy import isprime\ndef b(x):\n..num = str(x)\n..n = 1\n..while n < 10**3:\n....new_num = str(x) + str(n)\n....if isprime(int(new_num)):\n......print(int(new_num))\n......x = new_num\n......n = 1\n....else:\n......n += 1\nb(3)\n"}
{"sequence_id": "A236528", "text": "Start with 4; thereafter, primes obtained by concatenating to the end of previous term the next smallest number that will produce a prime.", "sequence": "4,41,419,41911,4191119,41911193,419111933,41911193341,4191119334151,419111933415151,41911193341515187,4191119334151518719,419111933415151871963,41911193341515187196323,4191119334151518719632313,419111933415151871963231329", "code": "\nimport sympy\nfrom sympy import isprime\ndef b(x):\n..num = str(x)\n..n = 1\n..while n < 10**3:\n....new_num = str(x) + str(n)\n....if isprime(int(new_num)):\n......print(int(new_num))\n......x = new_num\n......n = 1\n....else:\n......n += 1\nb(4)\n"}
{"sequence_id": "A236529", "text": "Primes arising in A069607.", "sequence": "5,53,5323,53231,532313,5323139,532313921,5323139219,532313921921,53231392192123,5323139219212343,53231392192123433,5323139219212343323,53231392192123433237,5323139219212343323721,532313921921234332372189,53231392192123433237218937,5323139219212343323721893721", "code": "\nimport sympy\nfrom sympy import isprime\ndef b(x):\n..num = str(x)\n..n = 1\n..while n < 10**3:\n....new_num = str(x) + str(n)\n....if isprime(int(new_num)):\n......print(int(new_num))\n......x = new_num\n......n = 1\n....else:\n......n += 1\nb(5)\n"}
{"sequence_id": "A236532", "text": "Triangle T(n,k) read by rows: T(n,k) = floor(n*k/(n+k)), with 1 <= k <= n.", "sequence": "0,0,1,0,1,1,0,1,1,2,0,1,1,2,2,0,1,2,2,2,3,0,1,2,2,2,3,3,0,1,2,2,3,3,3,4,0,1,2,2,3,3,3,4,4,0,1,2,2,3,3,4,4,4,5,0,1,2,2,3,3,4,4,4,5,5,0,1,2,3,3,4,4,4,5,5,5,6,0,1,2,3,3,4,4,4,5,5", "code": "\nfor n in range(1, 21):\n  for k in range(1, n+1):\n    print n*k // (n+k),\n  \n"}
{"sequence_id": "A236564", "text": "Difference between 2^(2n-1) and the nearest square.", "sequence": "1,-1,-4,7,-17,23,-89,7,28,112,448,1792,-4417,5503,22012,-4633,-18532,-74128,-296512,296863,1187452,-1181833,-4727332,4817239,19268956,-17830441,-71321764,94338007,377352028,-9092137,-36368548,-145474192,-581896768,-2327587072,-9310348288", "code": "\ndef isqrt(a):\n    sr = 1 << (int.bit_length(int(a)) >> 1)\n    while a < sr*sr:  sr>>=1\n    b = sr>>1\n    while b:\n        s = sr + b\n        if a >= s*s:  sr = s\n        b>>=1\n    return sr\nfor n in range(47):\n    nn = 2**(2*n+1)\n    a = isqrt(nn)\n    d1 = nn - a*a\n    d2 = (a+1)**2 - nn\n    if d2 < d1:  d1 = -d2\n    print(str(d1), end=',')\n"}
{"sequence_id": "A236670", "text": "Start with 6; thereafter, primes obtained by concatenating to the end of previous term the next smallest number that will produce a prime.", "sequence": "6,61,613,6131,613141,61314119,6131411917,61314119171,6131411917181,613141191718127,61314119171812789,613141191718127893,61314119171812789379,6131411917181278937929,61314119171812789379291,61314119171812789379291111", "code": "\nimport sympy\nfrom sympy import isprime\ndef b(x):\n..num = str(x)\n..n = 1\n..while n < 10**3:\n....new_num = str(x) + str(n)\n....if isprime(int(new_num)):\n......print(int(new_num))\n......x = new_num\n......n = 1\n....else:\n......n += 1\nb(6)\n"}
{"sequence_id": "A236671", "text": "Start with 8; thereafter, primes obtained by concatenating to the end of previous term the next smallest number that will produce a prime.", "sequence": "8,83,839,83911,839117,83911721,8391172123,83911721233,839117212337,83911721233729,839117212337293,83911721233729399,839117212337293999,83911721233729399993,839117212337293999931,83911721233729399993139", "code": "\nimport sympy\nfrom sympy import isprime\ndef b(x):\n..num = str(x)\n..n = 1\n..while n < 10**3:\n....new_num = str(x) + str(n)\n....if isprime(int(new_num)):\n......print(int(new_num))\n......x = new_num\n......n = 1\n....else:\n......n += 1\nb(8)\n"}
{"sequence_id": "A236672", "text": "Start with 9; thereafter, primes obtained by concatenating to the end of previous term the next smallest number that will produce a prime.", "sequence": "9,97,971,9719,971917,97191713,9719171333,971917133323,9719171333237,971917133323777,97191713332377731,9719171333237773159,971917133323777315951,97191713332377731595127,971917133323777315951277,971917133323777315951277269", "code": "\nimport sympy\nfrom sympy import isprime\ndef b(x):\n..num = str(x)\n..n = 1\n..while n < 10**3:\n....new_num = str(x) + str(n)\n....if isprime(int(new_num)):\n......print(int(new_num))\n......x = new_num\n......n = 1\n....else:\n......n += 1\nb(9)\n"}
{"sequence_id": "A236673", "text": "Exponents of powers of 3 that contain all ten decimal digits.", "sequence": "39,45,47,48,53,57,60,61,62,63,64,65,67,69,70,71,72,73,74,76,77,78,79,80,82,83,85,86,87,88,89,90,92,93,94,95,96,97,98,99,102,103,105,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123", "code": "\ndef PanDig(x):\n..a = '1234567890'\n..for n in range(10**3):\n....count = 0\n....for i in a:\n......if str(x**n).count(i) > 0:\n........count += 1\n......else:\n........break\n....if count == len(a):\n......print(n)\n"}
{"sequence_id": "A236674", "text": "Exponents of powers of 3 that do not contain all ten decimal digits.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,40,41,42,43,44,46,49,50,51,52,54,55,56,58,59,66,68,75,81,84,91,100,101,104,106", "code": "\ndef PanDigNot(x):\n..a = '1234567890'\n..for n in range(10**4):\n....count = 0\n....for i in a:\n......if str(x**n).count(i) > 0:\n........count += 1\n....if count < len(a):\n......print(n)\n"}
{"sequence_id": "A236685", "text": "Numbers n such that n^A062518(n) is missing more than one digit.", "sequence": "14,17,43,57,75,78,93,102,138,139,149,152,165,167,176,177,196,228,248,253,265,276,289,347,351,352,357,382,395,424,430,432,437,438,449,455,456,462,477,489,492,502,511,554,570,605,634,649,656,679,682", "code": "\ndef PanDigNum(x):\n..a = '1234567890'\n..lst = []\n..if DigitSum(x) == 1:\n....return None\n..for n in range(-200,0):\n....count = 0\n....for i in a:\n......if str(x**(-n)).count(i) > 0:\n........count += 1\n......else:\n........lst.append(i)\n....if count < len(a):\n......if len(lst) > 1:\n........return x\n......else:\n........break\n"}
{"sequence_id": "A236692", "text": "Numbers n such that n+1, 2n+1 and n^2+1 are primes.", "sequence": "1,2,6,36,156,210,270,306,576,690,936,966,2136,2310,2550,2706,2850,3390,3966,4026,4176,4260,4566,4590,5226,5430,5850,6120,6216,6360,6420,6546,7410,7536,8940,9126,9240,9276,9900,10530,10836,11286,11586,11886,12390,13680", "code": "\nimport sympy\nfrom sympy import isprime\nfor n in range(100000):\n    if isprime(n+1) and isprime(n*2+1) and isprime(n*n+1): print str(n)+',',\n"}
{"sequence_id": "A236759", "text": "Numbers n such that n^4+n-1 is prime.", "sequence": "2,3,6,9,10,12,13,16,17,20,23,26,28,31,33,40,43,44,54,58,72,77,92,93,98,105,110,117,119,120,122,125,132,143,157,164,182,201,204,205,229,231,266,275,279,286,288,290,292,293,304,309,318", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**3) if isprime(n**4+n-1)}\n"}
{"sequence_id": "A236760", "text": "Numbers n such that n^4 + n +- 1 are twin primes.", "sequence": "2,6,9,12,26,44,72,77,119,204,266,290,351,506,539,542,561,644,741,807,861,924,992,996,1016,1032,1049,1356,1412,1556,1640,1794,1847,1862,1871,1895,1980,2036,2129,2222,2289,2354,2445,2616,2630", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**4+n-1) and isprime(n**4+n+1)}\n"}
{"sequence_id": "A236761", "text": "Numbers n such that n^4-n+1 is prime.", "sequence": "3,6,9,13,16,18,19,24,33,39,43,45,46,60,63,64,69,75,78,79,85,91,94,105,106,108,109,115,121,129,138,174,175,183,195,198,205,210,220,249,250,276,289,295,300,309,313,318,324,343,346,348", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**3) if isprime(n**4-n+1)}\n"}
{"sequence_id": "A236763", "text": "Numbers n such that n^4 - n +/- 1 are twin primes.", "sequence": "6,9,13,16,39,60,79,174,183,198,295,361,393,481,540,669,705,715,765,781,889,975,1078,1149,1218,1260,1288,1294,1351,1363,1503,1600,1611,1701,1713,1911,2041,2254,2298,2484,2553,2625,2899,2946,2959", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**4-n+1) and isprime(n**4-n-1)}\n"}
{"sequence_id": "A236764", "text": "Numbers k such that k^3 +/- k +/- 1 are prime for all four possibilities.", "sequence": "15,21,15375,25164,53361,95190,110685,115140,133701,139425,140430,140844,189336,217686,220650,266916,272469,289341,344880,364665,377805,382221,390270,415779,454905,539700,561186,567645,575799,584430,603651,722484", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**6) if isprime(n**3+n+1) and isprime(n**3-n+1) and isprime(n**3+n-1) and isprime(n**3-n-1)}\n"}
{"sequence_id": "A236766", "text": "Numbers n such that n^4 +/- n +/- 1 are prime for all four possibilities.", "sequence": "6,9,7266,115131,380529,536646,636609,818526,922734,1389015,1660119,2045415,2085726,2262420,2469396,2722260,2836374,2954250,3146904,3614226,3949770,4062465,4110834,4211499,4400100,5081055,5324424,5434794,5436090", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**7) if isprime(n**4+n+1) and isprime(n**4-n+1) and isprime(n**4+n-1) and isprime(n**4-n-1)}\n"}
{"sequence_id": "A236854", "text": "Self-inverse permutation of natural numbers: a(1)=1, then a(p_n)=c_{a(n)}, a(c_n)=p_{a(n)}, where p_n = n-th prime, c_n = n-th composite.", "sequence": "1,4,9,2,16,7,6,23,3,53,26,17,14,13,83,5,12,241,35,101,59,43,8,41,431,11,37,1523,75,149,39,547,277,191,19,179,27,3001,31,157,24,12763,22,379,859,167,114,3943,1787,1153,67,1063,10,103,27457,127,919,89,21", "code": "\nfrom sympy import primepi, prime, isprime\ndef a002808(n):\n    m, k = n, primepi(n) + 1 + n\n    while m != k: m, k = k, primepi(k) + 1 + n\n    return m \ndef a(n): return n if n<2 else a002808(a(primepi(n))) if isprime(n) else prime(a(n - primepi(n) - 1))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A236866", "text": "Positions of primes in A007775 (numbers not divisible by 2, 3 or 5).", "sequence": "2,3,4,5,6,7,8,9,10,11,12,13,15,16,17,18,19,20,22,23,24,26,27,28,29,30,31,34,35,37,38,40,41,42,44,45,47,48,49,51,52,53,54,57,60,61,62,63,64,65,67,69,71,72,73,74,75,76,79,82,83,84,85,89,90,93,94,95", "code": "\nimport sympy\nfrom sympy import isprime\ni=0\nfor n in range(1000):\n    if n%2 and n%3 and n%5:\n        i+=1   \n        if isprime(n):  print str(i)+',',\n(Scheme, with Antti Karttunen's IntSeq-library):\n(define A236866 (MATCHING-POS 1 1 (lambda (n) (prime? (A007775 n)))))\n;; Where a slow version of A007775 can be defined for example like this:\n(define A007775 (MATCHING-POS 1 1 (lambda (n) (= 1 (gcd n 30)))))\n;; from _Antti Karttunen_, Feb 01 2014\n"}
{"sequence_id": "A236940", "text": "Primes p such that p^4-p+1 is prime.", "sequence": "3,13,19,43,79,109,313,379,613,709,1171,1213,1399,1543,1693,1759,1861,1933,2089,2239,2341,2371,2503,2521,2731,2749,3001,3061,3229,3433,3571,3739,3769,4219,4801,4933,4951,4993,5011,5023,5209,5281", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n) and isprime(n**4-n+1)}\n"}
{"sequence_id": "A236950", "text": "Primes p such that p^4+p-1 is prime.", "sequence": "2,3,13,17,23,31,43,157,229,293,353,373,397,409,463,521,577,619,727,743,857,883,953,1049,1087,1123,1171,1319,1409,1423,1429,1459,1499,1511,1543,1619,1693,1847,1871,1931,1951,1993,2017,2029,2129", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n) and isprime(n**4+n-1)}\n"}
{"sequence_id": "A236951", "text": "Primes p such that p^4 + p +/- 1 are twin primes.", "sequence": "2,1049,1847,1871,2129,2789,5351,10709,11279,13907,14321,17627,27179,27809,29921,30029,31859,37511,39359,40559,40841,43577,46091,46301,58271,62207,62981,66347,66947,68777,72341,75617,79397,85091,86579", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**6) if isprime(p) and isprime(p**4+p+1) and isprime(p**4+p-1)}\n"}
{"sequence_id": "A236952", "text": "Primes p such that p^4 - p +/- 1 are twin primes.", "sequence": "13,79,3571,3739,5023,5443,7459,7621,10243,13339,14251,17359,17551,17863,17971,18061,19483,21481,27631,32611,37501,38821,48463,49711,54709,56443,57073,57751,69313,71353,72883,74293,81883,82051,84223", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**6) if isprime(n) and isprime(n**4-n-1) and isprime(n**4-n+1)}\n"}
{"sequence_id": "A236965", "text": "Number of nonzero quartic residues modulo the n-th prime.", "sequence": "1,1,1,3,5,3,4,9,11,7,15,9,10,21,23,13,29,15,33,35,18,39,41,22,24,25,51,53,27,28,63,65,34,69,37,75,39,81,83,43,89,45,95,48,49,99,105,111,113,57,58,119,60,125,64,131,67,135,69,70,141,73,153,155,78", "code": "\nfrom sympy import prime\nfrom fractions import Fraction\ndef a(n): return (Fraction(1, 2) - Fraction(1, (prime(n)+1))).numerator\nprint([a(n) for n in range(1, 66)]) \n"}
{"sequence_id": "A237017", "text": "Primes which start a Cunningham chain of length 4 where every entity of the chain is smallest of the prime number pair (p, p+8).", "sequence": "359,1069199,1392269,2614169,10528649,16981379,18287309,19463519,21071489,21171509,22121579,24857639,40887569,41809259,76130129,88362479,118136279,128893049,131612609,153318449,289743689,315495539", "code": "\np1=2\nn=4\nmx=10\ncount=0\nwhile p1>2:\n....\n....cc=[]\n....cc.append(p1)\n....for i in range(1, n):\n........cc.append((2**(i)*p1+((2**i)-1)))\n....\n....cc2=[c+8 for c in cc]\n....\n....\n....\n....\n....pcc=pf.isp_list(cc)\n....pcc2=pf.isp_list(cc2)\n....\n....npcc=pcc.count(True)\n....\n....npcc2=pcc2.count(True)\n....if npcc==n and npcc2==n:\n........print \"For length \", n, \" the series is : \", cc, \" and \", cc2\n....p1=pf.nextp(p1)\n"}
{"sequence_id": "A237048", "text": "Irregular triangle read by rows: T(n,k), n >= 1, k >= 1, in which column k lists 1's interleaved with k-1 zeros, and the first element of column k is in row k(k+1)/2.", "sequence": "1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,1,1,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,0", "code": "\nfrom sympy import sqrt\nimport math\ndef T(n, k): return (n%k == 0)*1 if k%2 == 1 else (((n - k/2)%k) == 0)*1\nfor n in range(1, 21): print([T(n, k) for k in range(1, int(math.floor((sqrt(8*n + 1) - 1)/2)) + 1)]) \n"}
{"sequence_id": "A237054", "text": "a(1)=1, a(n) = (a(n-1) + n) XOR n.", "sequence": "1,1,7,15,17,17,31,47,49,49,55,79,81,81,111,111,145,177,215,255,257,257,271,319,321,321,327,383,385,385,447,511,513,513,519,527,529,529,543,623,689,753,823,847,849,849,943,1007,1041,1137,1175,1279,1281,1281", "code": "\na=1\nfor n in range(2, 77):\n  print str(a)+',',\n  a = (a+n) ^ n\n"}
{"sequence_id": "A237188", "text": "Smallest member of Sophie Germain pair, where each member of the prime pair is the smallest of its prime triple (p, p+2, p+8).", "sequence": "5,29,2549,6269,41609,259379,418349,492059,514049,521879,819029,1171199,1659809,1994339,2014139,2325509,2327399,2392139,2420699,2481179,2844269,3142829,3393359,3637169,3990029", "code": "\np1=2\nn=2\ncount=0\nwhile p1>2:\n....\n....cc=[]\n....cc.append(p1)\n....for i in range(1, n):\n........cc.append((2**(i)*p1+((2**i)-1)))\n....\n....cc2=[c+2 for c in cc]\n....\n....cc8=[c+8 for c in cc]\n....\n....\n....\n....\n....pcc=pf.isp_list(cc)\n....pcc2=pf.isp_list(cc2)\n....pcc8=pf.isp_list(cc8)\n....\n....npcc=pcc.count(True)\n....\n....npcc2=pcc2.count(True)\n....\n....npcc8=pcc8.count(True)\n....if npcc==n and npcc2==n and npcc8==n:\n........print \"For length \", n, \" the series is : \", cc, \" ,\", cc2,\" and \",cc8\n....p1=pf.nextp(p1)\n"}
{"sequence_id": "A237189", "text": "Numbers k such that k+1, 2k+1, 3k+1, 4k+1 are all prime.", "sequence": "330,1530,3060,4260,4950,6840,10830,15390,18120,23010,25410,26040,31770,33300,40110,41490,45060,49830,53880,59340,65850,70140,73770,78540,88740,95460,96930,109470,111720,112620,117720,131310,133200,134730,135300,150150,165900", "code": "\nimport sympy\nfrom sympy import isprime\nfor n in range(0,100000,2):\n    if isprime(n+1) and isprime(2*n+1) and isprime(3*n+1) and isprime(4*n+1):\n        print(str(n), end=',')\n"}
{"sequence_id": "A237190", "text": "Numbers n such that n+1, 2n+1, 3n+1, 4n+1, 5n+1 are five primes.", "sequence": "10830,25410,26040,88740,165900,196560,211050,224400,230280,247710,268500,268920,375480,377490,420330,451410,494340,512820,592620,604170,735750,751290,765780,799170,808080,952680,975660,1053690,1064190,1132860,1156170,1532370,1559580", "code": "\nimport sympy\nfrom sympy import isprime\nfor n in range(2000000):\n    if isprime(n+1) and isprime(2*n+1) and isprime(3*n+1) and isprime(4*n+1) and isprime(5*n+1):\n        print str(n)+',',\n"}
{"sequence_id": "A237191", "text": "Numbers n such that n+1, n+3, n^2+1, n^2+3, n^4+1, n^4+3 are six primes.", "sequence": "2,520360,14320216,30527896,119668186,120506050,131448430,142493926,211158676,254574706,276368680,306216940,315122416,421132180,472731400,506213890,540271396,616078786,629310346,646308250,741176296,752897860,800587480,851425030,897745996", "code": "\nimport sympy\nfrom sympy import isprime\nfor n in range(0,1000000000,2):\n    if isprime(n+1) and isprime(n*n+1) and isprime(n**4+1):\n        if isprime(n+3) and isprime(n*n+3) and isprime(n**4+3):\n            print str(n)+',',\n"}
{"sequence_id": "A237196", "text": "a(n) = index j of the first composite number in the sequence prime(1)*...*prime(n-1)*prime(n+1)*...*prime(j) + prime(n).", "sequence": "4,5,7,1,4,1,5,1,1,2,1,1,9,1,1,1,2,1,1,2,1,1,1,1,1,6,1,8,1,1,1,1,2,1,2,1,1,1,1,1,2,1,3,1,2,1,1,1,4,1,1,2,1,1,1,1,2,1,1,2,1,1,1,3,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,1", "code": " see Python program link\n"}
{"sequence_id": "A237201", "text": "Smallest integer m such that the n consecutive numbers m, m+1, ..., m+n-1 have n prime factors each, counted with multiplicity; a(n) = 0 if no such number exists.", "sequence": "2,9,170,4023,632148,4843161124,1981162639374", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import factorint\ndef PrimeFact(x):\n..n = 9930000\n..lst = []\n..while n < 10**10:\n....if not isprime(n):\n......count = 0\n......for i in range(n,n+x):\n........if sum(factorint(i).values()) == x:\n..........count += 1\n........else:\n..........n += 1\n..........break\n......if count == x:\n........return n\n....else:\n......n += 1\n"}
{"sequence_id": "A237256", "text": "Smallest member of Sophie Germain pair, wherein each member of the prime pair is the smallest of its prime quadruplets (p, p+2, p+8, p+12).", "sequence": "5,29,41609,4287599,16254449,87130709,118916729,157119089,173797289,180210059,207959879,309740999,349066439,356259989,401519399,473953229,705480749,912950249,994719629", "code": "\np1=2\nn=2\ncount=0\nwhile p1>2:\n....\n....cc=[]\n....cc.append(p1)\n....for i in range(1, n):\n........cc.append((2**(i)*p1+((2**i)-1)))\n....\n....cc2=[c+2 for c in cc]\n....\n....cc8=[c+8 for c in cc]\n....\n....cc12=[c+12 for c in cc]\n....\n....\n....\n....\n....pcc=pf.isp_list(cc)\n....pcc2=pf.isp_list(cc2)\n....pcc8=pf.isp_list(cc8)\n....pcc12=pf.isp_list(cc12) ....\n....npcc=pcc.count(True)\n....\n....npcc2=pcc2.count(True)\n....\n....npcc8=pcc8.count(True)\n....\n....npcc12=pcc12.count(True)\n....if npcc==n and npcc2==n and npcc8==n and npcc12==n:\n........print \"For length \", n, \" the series is : \", cc, \" ,\", cc2,\" , \",cc8, \" and \" cc12\n....p1=pf.nextp(p1)\n"}
{"sequence_id": "A237360", "text": "Numbers n of the form p^2+p+1 (for prime p) such that n^2+n+1 is also prime.", "sequence": "57,381,993,4557,16257,32943,49953,58323,109893,135057,167691,214833,237657,453603,503391,564753,658533,678153,780573,995007,1248807,1516593,1746363,2218611,2400951,3465183,3738423,4340973,4750221,5232657,6118203", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n**2+n+1) for n in range(10**4) if isprime(n) and isprime((n**2+n+1)**2+(n**2+n+1)+1)}\n"}
{"sequence_id": "A237361", "text": "Numbers n of the form n = Phi_5(p) (for prime p) such that Phi_5(n) is also prime.", "sequence": "4435770414505,30562950873505,32152890387805,60700878873905,936037312559305,1279875801783805,3780430049614405,6055088920612205,10370026462436905,12160851727605005,16956369914710105,18746881534017005,20813869508536105,30740855019988405", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n**4+n**3+n**2+n+1) for n in range(10**5) if isprime(n) and isprime((n**4+n**3+n**2+n+1)**4+(n**4+n**3+n**2+n+1)**3+(n**4+n**3+n**2+n+1)**2+(n**4+n**3+n**2+n+1)+1)}\n"}
{"sequence_id": "A237364", "text": "Numbers n of the form n=Phi(7,p) (for prime p) such that Phi(7,n) is also prime.", "sequence": "616067011,58749951412747,93054242152309543,146945091162352770847,2224989620406870255043,43184085337135904888293,53224134341571172990843,109539169818149034933067,308295173856880401026941,6197901576526752380316343,14789135287218506962379317", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n**6+n**5+n**4+n**3+n**2+n+1) for n in range(10**5) if isprime(n) and isprime((n**6+n**5+n**4+n**3+n**2+n+1)**6+(n**6+n**5+n**4+n**3+n**2+n+1)**5+(n**6+n**5+n**4+n**3+n**2+n+1)**4+(n**6+n**5+n**4+n**3+n**2+n+1)**3+(n**6+n**5+n**4+n**3+n**2+n+1)**2+(n**6+n**5+n**4+n**3+n**2+n+1)+1)}\n"}
{"sequence_id": "A237366", "text": "Primes p such that f(f(p)) is prime where f(x) = x^2+x+1.", "sequence": "7,19,31,67,127,181,223,241,331,367,409,463,487,673,709,751,811,823,883,997,1117,1231,1321,1489,1549,1861,1933,2083,2179,2287,2473,2551,2707,2803,2851,2857,2917,2971,3067,3361,3499,3559,3691,3847,3931", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n) and isprime((n**2+n+1)**2+(n**2+n+1)+1)}\n"}
{"sequence_id": "A237426", "text": "Number of distinct edge-magic total labelings of path P_n.", "sequence": "1,3,12,28,48,240,944,5344,23408,133808,751008,5222768,37898776,292271304,2346665448", "code": "\nfrom itertools import permutations\nprint(\"0\",\" \",\"1\")\nprint(\"1\",\" \",\"3\")\nfor j in range(5,27,2):\n    x = list(range(1,j+1))\n    sum2 = 0\n    for a in permutations(x):\n        x = list(a)\n        sum1 = x[0]+x[1]+x[2]\n        d = 1\n        for i in range(2,j-2,2):\n            if (sum1== x[i]+x[i+1]+x[i+2]):\n                d = 1\n            else:\n                d = 0\n                break\n        if (d==1):\n            if (a[0]<a[j-1]):\n                sum2 = sum2+1\n    print((j-1)//2, \" \", sum2)\n"}
{"sequence_id": "A237445", "text": "Primes p such that f(f(p)) is prime, where f(x) = x^4 + x^3 + x^2 + x + 1 = A053699(x).", "sequence": "1451,2351,2381,2791,5531,5981,7841,8821,10091,10501,11411,11701,12011,13241,15271,15331,16691,17231,18341,18671,19891,20981,21911,23071,23131,23561,23741,24061,25321,27361,29221,30851,30941,31271,32141,33931", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**5) if isprime(n) and isprime((n**4+n**3+n**2+n+1)**4+(n**4+n**3+n**2+n+1)**3+(n**4+n**3+n**2+n+1)**2+(n**4+n**3+n**2+n+1)+1)}\n"}
{"sequence_id": "A237446", "text": "Primes p such that f(f(p)) is prime where f(x) = Phi_6(x).", "sequence": "29,197,673,2297,3613,5923,6133,6917,8219,13553,15667,17137,21911,30941,33587,35407,38053,44017,45557,46663,51241,53453,65731,67187,82349,94151,115361,132287,143711,164011,164291,165523,178613,180797,182141", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**6) if isprime(n) and isprime((n**6+n**5+n**4+n**3+n**2+n+1)**6+(n**6+n**5+n**4+n**3+n**2+n+1)**5+(n**6+n**5+n**4+n**3+n**2+n+1)**4+(n**6+n**5+n**4+n**3+n**2+n+1)**3+(n**6+n**5+n**4+n**3+n**2+n+1)**2+(n**6+n**5+n**4+n**3+n**2+n+1)+1)}\n"}
{"sequence_id": "A237495", "text": "Primes which start a Cunningham chain of length 5 where every prime in the chain is the smaller of a pair of twin primes.", "sequence": "41887255409,364223689829,376655795669,790031896499,1558600513469,2180283962009,3266149150109,4424063189699,4655123392919,6924093600269", "code": "\np1=2\nn=4\nmx=10\ncount=0\nwhile p1>2:\n....\n....cc=[]\n....cc.append(p1)\n....for i in range(1, n):\n........cc.append((2**(i)*p1+((2**i)-1)))\n....\n....cc2=[c+2 for c in cc]\n....\n....\n....\n....\n....pcc=pf.isp_list(cc)\n....pcc2=pf.isp_list(cc2)\n....\n....npcc=pcc.count(True)\n....\n....npcc2=pcc2.count(True)\n....if npcc==n and npcc2==n:\n........print \"For length \", n, \" the series is : \", cc, \" and \", cc2\n....p1=pf.nextp(p1)\n"}
{"sequence_id": "A237500", "text": "Number of binary strings of length 2n which contain the ones' complement of each of their two halves.", "sequence": "2,6,12,28,58,118,244,500,1004,2024,4070,8150,16340,32720,65450,130986,262056,524136,1048422,2096982,4194000", "code": " \nfrom itertools import product as prod\ndef comp(s): z, o = ord('0'), ord('1'); return s.translate({z:o, o:z})\ndef ok(s): return comp(s[:len(s)//2]) in s and comp(s[len(s)//2:]) in s\ndef a(n): return 2*sum(ok(\"0\"+\"\".join(p)) for p in prod(\"01\", repeat=2*n-1))\nprint([a(n) for n in range(1, 12)]) \n"}
{"sequence_id": "A237501", "text": "Number of binary strings of length 2n which contain the reversals of each of their two halves.", "sequence": "4,12,42,106,300,654,1664,3300,7940,15018,34948,64396,147130,267404,604722,1090998,2453492,4409000,9886266,17729222", "code": " \nfrom itertools import product as prod\ndef ok(s): return s[:len(s)//2][::-1] in s and s[len(s)//2:][::-1] in s\ndef a(n): return 2*sum(ok(\"0\"+\"\".join(p)) for p in prod(\"01\", repeat=2*n-1))\nprint([a(n) for n in range(1, 12)]) \n"}
{"sequence_id": "A237502", "text": "Number of binary strings of length 2n which contain the ones' complements and the reversals of each of their two halves.", "sequence": "2,6,8,16,26,46,72,116,184,288,434,646,980,1444,2122,3066,4500,6452,9362,13294", "code": " \nfrom itertools import product as prod\ndef comp(s): z, o = ord('0'), ord('1'); return s.translate({z:o, o:z})\ndef ok(s):\n  a, b = s[len(s)//2:], s[:len(s)//2]\n  return comp(a) in s and comp(b) in s and a[::-1] in s and b[::-1] in s\ndef a(n): return 2*sum(ok(\"0\"+\"\".join(p)) for p in prod(\"01\", repeat=2*n-1))\nprint([a(n) for n in range(1, 12)]) \n"}
{"sequence_id": "A237525", "text": "Numbers k such that the sum of digits of k^3 is a cube.", "sequence": "0,1,2,5,8,10,11,20,27,33,36,39,42,50,54,57,69,72,75,78,80,84,87,93,100,101,105,108,110,111,114,135,138,147,162,165,168,174,177,200,219,222,225,228,231,234,258,267,270,273,276,285,291,294,312", "code": "\ndef DigitSum(x):\n..total = 0\n..for i in str(x):\n....total += int(i)\n..return total\ndef DigSumCube(x):\n..for n in range(10**10):\n....if DigitSum(x**3) == n**3:\n......return True\n....if DigitSum(x**3) < n**3:\n......return False\n..return False\nx = 1\nwhile x < 1000:\n..if DigSumCube(x):\n....print(x)\n..x += 1\n"}
{"sequence_id": "A237527", "text": "Numbers n of the form p^2-p-1 = A165900(p), for prime p, such that n^2-n-1 = A165900(n) is also prime.", "sequence": "5,155,505,2755,3421,6805,11341,27721,29755,31861,44309,49505,52211,65791,100171,121451,134321,185329,195805,236681,252505,258571,292139,325469,375155,380071,452255,457651,465805,563249,676505,1041419,1061929", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n**2-n-1) for n in range(10**4) if isprime(n) and isprime((n**2-n-1)**2-(n**2-n-1)-1)}\n"}
{"sequence_id": "A237528", "text": "Numbers n of the form p^3-p^2-p-1 (for prime p) such that n^3-n^2-n-1 is prime.", "sequence": "23518,146014,486718,564814,3285598,4629406,7151614,11645326,22584814,29983198,31754206,64319998,355897438,745319086,864614014,1304555614,2334990526,2903803726,3447511198,3934332718,4194050014,4596374014,5838479998,6866219998", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n**3-n**2-n-1) for n in range(10**4) if isprime(n) and isprime((n**3-n**2-n-1)**3-(n**3-n**2-n-1)**2-(n**3-n**2-n-1)-1)}\n"}
{"sequence_id": "A237591", "text": "Triangle read by rows: T(n,k) = A235791(n,k) - A235791(n,k+1), assuming that the virtual right border of triangle A235791 is A000004.", "sequence": "1,2,2,1,3,1,3,2,4,1,1,4,2,1,5,2,1,5,2,2,6,2,1,1,6,3,1,1,7,2,2,1,7,3,2,1,8,3,1,2,8,3,2,1,1,9,3,2,1,1,9,4,2,1,1,10,3,2,2,1,10,4,2,2,1,11,4,2,1,2,11,4,3,1,1,1,12,4,2,2,1,1,12,5,2,2,1,1,13,4,3,2,1,1,13,5,3,1,2,1,14,5,2,2,2,1", "code": "\nfrom sympy import sqrt\nimport math\ndef T(n, k): return int(math.ceil((n + 1)/k - (k + 1)/2)) - int(math.ceil((n + 1)/(k + 1) - (k + 2)/2))\nfor n in range(1, 29): print([T(n, k) for k in range(1, int((sqrt(8*n + 1) - 1)/2) + 1)]) \n"}
{"sequence_id": "A237593", "text": "Triangle read by rows in which row n lists the elements of the n-th row of A237591 and then the elements of the same row but in reverse order.", "sequence": "1,1,2,2,2,1,1,2,3,1,1,3,3,2,2,3,4,1,1,1,1,4,4,2,1,1,2,4,5,2,1,1,2,5,5,2,2,2,2,5,6,2,1,1,1,1,2,6,6,3,1,1,1,1,3,6,7,2,2,1,1,2,2,7,7,3,2,1,1,2,3,7,8,3,1,2,2,1,3,8,8,3,2,1,1,1,1,2,3,8", "code": "\nfrom sympy import sqrt\nimport math\ndef row(n): return int(math.floor((sqrt(8*n + 1) - 1)/2))\ndef s(n, k): return int(math.ceil((n + 1)/k - (k + 1)/2)) - int(math.ceil((n + 1)/(k + 1) - (k + 2)/2))\ndef T(n, k): return s(n, k) if k<=row(n) else s(n, 2*row(n) + 1 - k)\nfor n in range(1, 11): print [T(n, k) for k in range(1, 2*row(n) + 1)] \n"}
{"sequence_id": "A237600", "text": "Right-truncatable primes in base 16.", "sequence": "2,3,5,7,11,13,37,41,43,47,53,59,61,83,89,113,127,179,181,191,211,223,593,599,601,607,659,661,691,701,757,761,853,857,859,863,947,953,977,983,991,1427,1429,1433,1439,1811,1823,2039,2879,2897,2903,2909,3061", "code": "\nfrom gmpy2 import is_prime\nA237600_list = []\nfor n in range(1,10**9):\n    if is_prime(n):\n        s = format(n,'x')\n        for i in range(1,len(s)):\n            if not is_prime(int(s[:-i],16)):\n                break\n        else:\n            A237600_list.append(n) \n"}
{"sequence_id": "A237600", "text": "Right-truncatable primes in base 16.", "sequence": "2,3,5,7,11,13,37,41,43,47,53,59,61,83,89,113,127,179,181,191,211,223,593,599,601,607,659,661,691,701,757,761,853,857,859,863,947,953,977,983,991,1427,1429,1433,1439,1811,1823,2039,2879,2897,2903,2909,3061", "code": "\nfrom sympy import primerange\np = lambda x: list(primerange(x,x+16)); A237600 = p(0); i=0\nwhile i<len(A237600): A237600+=p(A237600[i]*16); i+=1 \n"}
{"sequence_id": "A237639", "text": "Numbers n = p^4-p^3-p^2-p-1 (for prime p) such that n^4-n^3-n^2-n-1 is prime.", "sequence": "41,56133395601,89362058601,590884122501,1275627652881,2775672202617,6212311361721,7534036143501,27344792789601,61180709716101,124857759197601,206926840439901,580608824590341,603653936046501,1442441423278281,1864059458505657", "code": "\nimport sympy\nfrom sympy import isprime\ndef poly4(x):\n..if isprime(x):\n....f = x**4-x**3-x**2-x-1\n....if isprime(f**4-f**3-f**2-f-1):\n......return True\n..return False\nx = 1\nwhile x < 10**5:\n..if poly4(x):\n....print(x**4-x**3-x**2-x-1)\n..x += 1\n"}
{"sequence_id": "A237640", "text": "Numbers n of the form p^5 - Phi_5(p) (for prime p) such that n^5 - Phi_5(n) is also prime.", "sequence": "122,340352,830519696,11479086422,266390469692,310503441398,2718130415306,14837993872846,59538248604388,889257663626476,2496623039993996,6427431330617746,7120028814392596,10777302002014868,12942591289426088,24039736320940828", "code": "\nimport sympy\nfrom sympy import isprime\ndef poly5(x):\n..if isprime(x):\n....f = x**5-x**4-x**3-x**2-x-1\n....if isprime(f**5-f**4-f**3-f**2-f-1):\n......return True\n..return False\nx = 1\nwhile x < 10**5:\n..if poly5(x):\n....print(x**5-x**4-x**3-x**2-x-1)\n..x += 1\n"}
{"sequence_id": "A237641", "text": "Primes p of the form n^2-n-1 (for prime n) such that p^2-p-1 is also prime.", "sequence": "5,236681,380071,457651,563249,1441199,1660231,2491661,3050261,4106701,5137021,5146091,5329171,10617821,15574861,19860391,20852921,21349019,21497131,23025601,24507449,32495699,36342811,48867089,51129649,59082281", "code": "\nimport sympy\nfrom sympy import isprime\ndef poly2(x):\n..if isprime(x):\n....f = x**2-x-1\n....if isprime(f**2-f-1):\n......return True\n..return False\nx = 1\nwhile x < 10**5:\n..if poly2(x):\n....if isprime(x**2-x-1):\n......print(x**2-x-1)\n..x += 1\n"}
{"sequence_id": "A237642", "text": "Primes of the form n^2-n-1 (for some n) such that p^2-p-1 is also prime.", "sequence": "5,11,29,71,131,181,379,419,599,1979,2069,3191,4159,13339,14519,17291,19739,20879,21169,26731,30449,31151,39799,48619,69959,70489,112559,122849,132859,139501,149381,183611,186191,198469,212981,222311,236681", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n**2-n-1) for n in range(10**3) if isprime(n**2-n-1) and isprime((n**2-n-1)**2-(n**2-n-1)-1)}\n"}
{"sequence_id": "A237671", "text": "Let m_n denote the number which is obtained from n-base representation of m if its digits are written in nondecreasing order; then a(n) is the smallest period of the sequence which is defined by the recurrence b(0)=0, b(1)=1, b(k)=(b(k-1) + b(k-2))_n, for k>=2, or a(n)=0, if there is no such period.", "sequence": "1,3,16,6,20,24,16,36,120,300,20,288,28,192,200,552,180,192,180,1380,224,60,1728,912,3800,756,576,1776,4102,15480,3540,1344,10800,14328,800,2304,1520,1890,1232,11280,9040,31152,49544,3660,6360,3696,13248,21408", "code": "\nimport sympy,functools\ndef digits2int(x,b):\n  return functools.reduce(lambda n,d:b*n+d,x,0)\ndef A237671(n):\n  return next(sympy.cycle_length(lambda x:(x[1],digits2int(sorted(sympy.ntheory.factor_.digits(sum(x),n)[1:]),n)),(0,1)))[0] \n"}
{"sequence_id": "A237766", "text": "Least initial number of n consecutive integers that are not divisible by any of their nonzero digits.", "sequence": "23,37,56,56,866", "code": "\ndef DivDig(x):\n..total = 0\n..for i in str(x):\n....if i != '0':\n......if x/int(i) % 1 == 0:\n........return True\n..return False\ndef Nums(x):\n..n = 1\n..while n < 10**3:\n....count = 0\n....for i in range(n,n+x):\n......if not DivDig(i):\n........count += 1\n......else:\n........break\n....if count == x:\n......return n\n....else:\n......n += 1\nx = 1\nwhile x < 10:\n..print(Nums(x))\n..x += 1\n"}
{"sequence_id": "A237767", "text": "Product of digits of n is a nonzero cube.", "sequence": "1,8,11,18,24,39,42,81,88,93,111,118,124,139,142,181,188,193,214,222,241,248,284,319,333,389,391,398,412,421,428,444,469,482,496,555,649,666,694,777,811,818,824,839,842,881,888,893,913,931", "code": "\ndef DigitProd(x):\n..total = 1\n..for i in str(x):\n....total *= int(i)\n..return total\ndef Cube(x):\n..for n in range(1,10**3):\n....if DigitProd(x) == n**3:\n......return True\n....if DigitProd(x) < n**3:\n......return False\n..return False\nx = 1\nwhile x < 1000:\n..if Cube(x):\n....print(x)\n..x += 1\n"}
{"sequence_id": "A237882", "text": "Numbers k such that LR0(k) > LR1(k), where LR0(k) = A087117(k) is the length of the longest run of zeros in the binary representation of k, LR1(k) = A038374(k) is the length of the longest run of ones.", "sequence": "0,4,8,9,16,17,18,20,24,32,33,34,35,36,37,40,41,48,49,64,65,66,67,68,69,70,72,73,74,80,81,82,84,88,96,97,98,99,104,112,128,129,130,131,132,133,134,135,136,137,138,139,140,141,144,145,146,148,149,152,160", "code": "\nfor n in range(1000):\n    b = bin(n).lstrip(\"0b\")\n    L0 = L1 = 0\n    s = '0'\n    if n==0: b=s\n    while b.find(s)>=0:\n        s += '0'\n        L0 += 1\n    s = '1'\n    while b.find(s)>=0:\n        s += '1'\n        L1 += 1\n    if L0>L1: print str(n)+',',\n"}
{"sequence_id": "A237912", "text": "Smallest number m (not ending in a 0) such that m and the digit reversal of m have n prime factors (counted with multiplicity).", "sequence": "13,15,117,126,1386,2576,21708,25515,21168,46848,295245,2937856,6351048,21989376,217340928,2154281472,2196652032,21120051456,21122906112,40915058688,274148425728", "code": "\nimport sympy\nfrom sympy import factorint\ndef rev(x):\n..rev = ''\n..for i in str(x):\n....rev = i + rev\n..return int(rev)\ndef RevFact(x):\n..n = 1\n..while n < 10**8:\n....if rev(n) != n:\n......if n % 10 != 0:\n........if sum(list(factorint(n).values())) == x:\n..........if sum(list(factorint(rev(n)).values())) == x:\n............return n\n..........else:\n............n += 1\n........else:\n..........n += 1\n......else:\n........n += 1\n....else:\n......n += 1\nx = 1\nwhile x < 100:\n..print(RevFact(x))\n..x += 1\n"}
{"sequence_id": "A237913", "text": "Smallest number m > 1 (not ending in a 0) such that m and the digit reversal of m have n prime factors (counted with multiplicity). Palindromes are included.", "sequence": "2,4,8,88,252,2576,21708,2112,4224,8448,44544,48384,2977792,21989376,405504,4091904,441606144,405909504,886898688,677707776,4285005824", "code": "\nimport sympy\nfrom sympy import factorint\ndef rev(x):\n..rev = ''\n..for i in str(x):\n....rev = i + rev\n..return int(rev)\ndef RevFact(x):\n..n = 2\n..while n < 10**8:\n....if n % 10 != 0:\n......if sum(list(factorint(n).values())) == x:\n........if sum(list(factorint(rev(n)).values())) == x:\n..........return n\n........else:\n..........n += 1\n......else:\n........n += 1\n....else:\n......n += 1\nx = 1\nwhile x < 100:\n..print(RevFact(x))\n..x += 1\n"}
{"sequence_id": "A237929", "text": "Numbers n such that (i) the sum of prime divisors of n (with repetition) is one less than the sum of prime divisors (with repetition) of n+1, and (ii) n and n+1 have the same number of prime divisors (with repetition).", "sequence": "2,9,98,170,1274,4233,4345,7105,7625,14905,21385,30457,34945,66585,69874,77314,82946,98841,175354,177122,233090,236282,238017,263145,265225,295274,298082,322234,335793,336106", "code": "\n\n\n\n\ni=2\nwhile i < 100000:\n..sdi=sumdivisors(i)\n..sdip=sumdivisors(i+1)\n..ndi=numdivisors(i)\n..ndip=numdivisors(i+1)\n..if sdi==sdip-1 and ndi==ndip:\n....print i, i+1\n..i=i+1\n"}
{"sequence_id": "A238380", "text": "Numbers k such that the average of the divisors of k and k+1 is the same.", "sequence": "5,14,91,1334,1634,2685,3478,5452,9063,13915,16225,20118,20712,33998,42818,47795,64665,79338,84134,103410,106144,109214,111683,122073,123497,133767,166934,170884,203898,224561,228377,267630,289454,383594,384857,391348,440013", "code": "\nfrom sympy import divisors\nfrom fractions import Fraction\ndef aupto(limit):\n  alst, prev_divavg = [], 1\n  for n in range(2, limit+2):\n    divs = divisors(n)\n    divavg = Fraction(sum(divs), len(divs))\n    if divavg == prev_divavg: alst.append(n-1)\n    prev_divavg = divavg\n  return alst\nprint(aupto(440013)) \n"}
{"sequence_id": "A238392", "text": "Triangle read by rows: each row is an initial segment of the terms of A000123 followed by its reflection.", "sequence": "1,1,1,1,2,1,1,2,2,1,1,2,4,2,1,1,2,4,4,2,1,1,2,4,6,4,2,1,1,2,4,6,6,4,2,1,1,2,4,6,10,6,4,2,1,1,2,4,6,10,10,6,4,2,1,1,2,4,6,10,14,10,6,4,2,1,1,2,4,6,10,14,14,10,6,4,2,1,1,2,4,6,10,14,20,14,10,6,4,2,1", "code": "\ndef a(n): return 1 if n==0 else a(n - 1) + a(n/2)\ni=0\nfor n in range(0,126):\n....for k in range(0, n+1):\n........print str(i)+\" \"+str(a(min(k, n - k)))\n........i+=1 \n"}
{"sequence_id": "A238445", "text": "Primes p such that f(f(p)) is prime, where f(x) = x^5-x^4-x^3-x^2-x-1.", "sequence": "3,13,61,103,193,199,307,431,569,977,1201,1451,1481,1609,1669,1889,2371,2381,2711,2819,3083,3469,4289,4337,4567,5231,5501,6733,7043,7253,7351,7549,8707,9257,9497,10039,10687,11491,12227,12517,12941,13397", "code": "\nimport sympy\nfrom sympy import isprime, primerange\ndef f(x):\n    return x**5-x**4-x**3-x**2-x-1\n[p for p in primerange(2, 10**5) if isprime(f(f(p)))]\n"}
{"sequence_id": "A238447", "text": "Primes p such that f(p) and f(f(p)) are both prime, where f(x) = x^2-x-1.", "sequence": "3,487,617,677,751,1201,1289,1579,1747,2027,2267,2269,2309,3259,3947,4457,4567,4621,4637,4799,4951,5701,6029,6991,7151,7687,7867,9187,9209,9341,9587,9829,11321,12301,12541,12781,13177,13649,15919,16349", "code": "\nimport sympy\nfrom sympy import isprime\ndef f(x):\n..return x**2-x-1\n{print(p) for p in range(10**5) if isprime(p) and isprime(f(p)) and isprime(f(f(p)))}\n"}
{"sequence_id": "A238448", "text": "Smallest number m such that 2^m contains a string of n consecutive increasing digits in its decimal representation.", "sequence": "0,7,28,135,391,992,5837,9485,15975,244178", "code": "\ndef Str(x):\n..for n in range(10**5):\n....count = 0\n....i = 0\n....if len(str(2**n)) == x and x == 1:\n......return n\n....while i < len(str(2**n))-1:\n......if int(str(2**n)[i]) == int(str(2**n)[i+1])-1:\n........count += 1\n........i += 1\n......else:\n........if count == x-1:\n..........return n\n........else:\n..........count = 0\n..........i += 1\n....if count == x-1:\n......return n\nx = 1\nwhile x < 50:\n..print(Str(x))\n..x += 1\n"}
{"sequence_id": "A238449", "text": "Smallest numbers m such that 2^m contains a string of n consecutive decreasing integers in its decimal representation.", "sequence": "0,5,25,78,161,341,1315,28238,56047,283789", "code": "\ndef StrDec(x):\n..for n in range(10**5):\n....count = 0\n....i = 0\n....if len(str(2**n)) == x and x == 1:\n......return n\n....while i < len(str(2**n))-1:\n......if int(str(2**n)[i]) == int(str(2**n)[i+1])-1:\n........count += 1\n........i += 1\n......else:\n........if count == x-1:\n..........return n\n........else:\n..........count = 0\n..........i += 1\n....if count == x-1:\n......return n\nx = 1\nwhile x < 50:\n..print(StrDec(x))\n..x += 1\n"}
{"sequence_id": "A238454", "text": "Difference between 2^(2*n-1) and the next larger square.", "sequence": "2,1,4,16,17,68,89,356,697,1337,2449,4001,4417,17668,24329,4633,18532,74128,296512,1186048,1778369,1181833,4727332,18909328,28184177,17830441,71321764,285287056,381898097,9092137,36368548,145474192,581896768,2327587072,9310348288", "code": "\ndef isqrt(a):\n    sr = 1 << (int.bit_length(int(a)) >> 1)\n    while a < sr*sr:  sr>>=1\n    b = sr>>1\n    while b:\n        s = sr + b\n        if a >= s*s:  sr = s\n        b>>=1\n    return sr\ndef a(n):\n    nn = 2**(2*n+1)\n    s = isqrt(nn)\n    return (s+1)**2-nn\nfor n in range(77):  print(str(a(n)), end=',')\n"}
{"sequence_id": "A238455", "text": "Difference between 4^n and the nearest triangular number.", "sequence": "0,1,1,-2,3,-11,1,-87,-167,-306,-500,-552,688,-3041,-579,20854,37075,55618,37108,-222296,-147729,891994,602155,-3523022,-2228805,14811346,11792251,-47737262,-1136517,375078994,741065851,1445763154,2746052116,4910207464,7492827856", "code": "\ndef isqrt(a):\n    sr = 1 << (int.bit_length(int(a)) >> 1)\n    while a < sr*sr:  sr>>=1\n    b = sr>>1\n    while b:\n        s = sr + b\n        if a >= s*s:  sr = s\n        b>>=1\n    return sr\nfor n in range(77):\n    nn = 4**n\n    s = isqrt(2*nn)\n    if s*(s+1)//2 > nn:  s-=1\n    d1 = nn - s*(s+1)//2\n    d2 = (s+1)*(s+2)//2 - nn\n    if d2 < d1:  d1 = -d2\n    print(str(d1), end=',')\n"}
{"sequence_id": "A238456", "text": "Triangular numbers t such that t+x+y is a square, where x and y are the two squares nearest to t.", "sequence": "0,2211,5151,1107816,20959575,4237107540,1564279847151,61066162885575,2533192954461975,2774988107938203,90728963274006291,18765679728507154152720", "code": "\ndef isqrt(a):\n    sr = 1 << (int.bit_length(int(a)) >> 1)\n    while a < sr*sr:  sr>>=1\n    b = sr>>1\n    while b:\n        s = sr + b\n        if a >= s*s:  sr = s\n        b>>=1\n    return sr\nt = i = 0\nwhile 1:\n    t += i\n    i += 1\n    s = isqrt(t)\n    if s*s==t:  s-=1\n    txy = t + 2*s*(s+1) + 1   \n    r = isqrt(txy)\n    if r*r==txy:  print(str(t), end=',')\n"}
{"sequence_id": "A238462", "text": "2-adic valuation of A052129.", "sequence": "0,0,1,2,6,12,25,50,103,206,413,826,1654,3308,6617,13234,26472,52944,105889,211778,423558,847116,1694233,3388466,6776935,13553870,27107741,54215482,108430966,216861932,433723865,867447730", "code": "\nn=4000; val=[0]*(n+1); exp=2\nwhile exp <= n:\n    for j in range(exp,n+1,exp): val[j] += 1\n    exp *= 2\nres = 0; i = 0\nwhile len(str(res)) <= 1000: print(i,res); i += 1; res = res * 2 + val[i]\n\n"}
{"sequence_id": "A238489", "text": "Numbers k such that k+x+y is a square, where x and y are the two squares nearest to k.", "sequence": "0,4,11,23,56,80,103,135,204,248,339,395,444,508,576,635,711,860,948,1119,1219,1304,1412,1619,1739,1968,2100,2211,2351,2495,2616,2768,3055,3219,3528,3704,3851,4035,4223,4380,4576,4943,5151,5540,5760,5943,6171,6596,6836,7283", "code": " \nfrom math import isqrt\nfor k in range(7777):\n    s = isqrt(k)\n    if s*s==k:  s-=1\n    kxy = k + 2*s*(s+1) + 1   \n    r = isqrt(kxy)\n    if r*r==kxy:  print(str(k), end=',')\n"}
{"sequence_id": "A238507", "text": "Smallest number m such that 3^m contains a string of n consecutive increasing integers in its decimal representation.", "sequence": "0,8,20,57,332,332,6814,7926,16724,200633", "code": "\ndef StrInc(x):\n..for n in range(10**5):\n....count = 0\n....i = 0\n....string = str(3**n)\n....if len(string) == x and x == 1:\n......return n\n....while i < len(string)-1:\n......if int(string[i]) == int(string[i+1])-1:\n........count += 1\n........i += 1\n......else:\n........if count >= x-1:\n..........return n\n........else:\n..........count = 0\n..........i += 1\n....if count >= x-1:\n......return n\nx = 1\nwhile x < 15:\n..print(StrInc(x))\n..x += 1\n"}
{"sequence_id": "A238508", "text": "Smallest number m such that 3^m contains a string of n consecutive decreasing integers in its decimal representation.", "sequence": "0,5,13,50,213,536,536,4582,63202,163984", "code": "\ndef StrDec(x):\n..for n in range(10**5):\n....count = 0\n....i = 0\n....string = str(3**n)\n....if len(string) == x and x == 1:\n......return n\n....while i < len(string)-1:\n......if int(string[i]) == int(string[i+1])-1:\n........count += 1\n........i += 1\n......else:\n........if count >= x-1:\n..........return n\n........else:\n..........count = 0\n..........i += 1\n....if count >= x-1:\n......return n\nx = 1\nwhile x < 15:\n..print(StrDec(x))\n..x += 1\n"}
{"sequence_id": "A238530", "text": "Position of first occurrence of n in A238529 (Recursive depth of n modulo sopfr(n)).", "sequence": "2,8,22,166,778,4962,29922,179682,688078,7060198,42361338,674524645", "code": "\ndef primfacs(n):\n    i = 2\n    primfacs = []\n    while i * i <= n:\n        while n % i == 0:\n            primfacs.append(i)\n            n = n / i\n        i = i + 1\n    if n > 1:\n        primfacs.append(n)\n    return primfacs\ndef sopfr(n):\n    plist = list(primfacs(n))\n    l = len(plist)\n    s = 0\n    while l > 0:\n        s += plist[l - 1]\n        l -= 1\n    return s\ndef sd(n):\n    d = 1\n    s = n % sopfr(n)\n    if s > 1:\n        d += sd(s)\n    return d\nn=2\nmax=1000\nrec = 0\nlst = []\nwhile n <= max:\n    r = sd(n)\n    if r > rec:\n        lst.append(n)\n        rec = r\n    n += 1\nprint(lst)\n"}
{"sequence_id": "A238599", "text": "Numbers k such that k+x+y is a perfect cube, where x and y are the two cubes nearest to k.", "sequence": "0,29,171,476,1015,1044,1907,3142,4815,7093,9882,13313,17452,22580,28393,35118,42821,43120,51939,61874,72991,85835,99604,114759,131366,150192,170009,191482,214677,240625,267588,296477,327358,361568,396775,434178,473843,475306,517455", "code": "\ndef icbrt(a):\n    sr = 1 << (int.bit_length(int(a)) >> 1)\n    while a < sr*sr*sr:  sr>>=1\n    b = sr>>1\n    while b:\n        s = sr + b\n        if a >= s*s*s:  sr = s\n        b>>=1\n    return sr\nfor k in range(1000000):\n    s = icbrt(k)\n    if k and s*s*s==k:  s-=1\n    d1 = abs(k-s**3)\n    d2 = abs(k-(s+1)**3)\n    d3 = abs(k-(s-1)**3)\n    kxy = k + s**3 + (s+1)**3\n    if s and d3<d2:  kxy = k + s**3 + (s-1)**3\n    r = icbrt(kxy)\n    if r*r*r==kxy:  print(str(k), end=',')\n"}
{"sequence_id": "A238714", "text": "Final divisor of A238529(n).", "sequence": "2,3,4,5,5,7,2,3,3,11,5,13,5,7,8,17,2,19,2,10,3,23,5,5,11,9,5,29,10,31,2,5,7,11,5,37,17,7,7,41,5,43,5,11,10,47,4,7,2,11,17,53,3,7,4,13,9,59,12,61,29,11,4,11,2,67,5,17,14,71,12,73,11,3,7,5,5", "code": "\ndef primfacs(n):\n   i = 2\n   primfac = []\n   while i * i <= n:\n       while n % i == 0:\n           primfac.append(i)\n           n //= i\n       i += 1\n   if n > 1:\n       primfac.append(n)\n   return primfac\ndef sopfr(n):\n   plist = primfacs(n)\n   l = len(plist)\n   s = 0\n   while l > 0:\n       s += plist[l - 1]\n       l -= 1\n   return s\nn = 2\nmax = 1000\nlst = []\nwhile n <= max:\n   rem = n\n   while rem > 1:\n       last = sopfr(rem)\n       rem = rem % last\n   lst.append(last)\n   n += 1\nprint(lst)\n"}
{"sequence_id": "A238847", "text": "Smallest k such that k*n^3 + 1 is prime.", "sequence": "1,2,4,3,2,2,4,15,2,3,2,2,6,3,10,3,26,3,4,2,2,15,26,7,4,2,2,6,2,2,10,2,20,4,2,3,4,3,4,6,6,4,10,2,14,16,12,3,4,9,10,6,24,3,4,6,2,3,2,2,18,6,6,3,14,5,16,9,18,3,2,2,4,3,10,6", "code": "\nimport sympy\nfrom sympy import isprime\ndef f(n):\n..for k in range(1,10**3):\n....if isprime(k*(n**3)+1):\n......return k\nn = 1\nwhile n < 10**3:\n..print(f(n))\n..n += 1\n"}
{"sequence_id": "A238848", "text": "Smallest k such that k*n^3 - 1 is prime.", "sequence": "3,1,2,2,4,2,14,7,6,2,4,4,14,3,4,2,16,4,12,9,2,5,16,2,2,3,16,6,10,4,2,4,22,2,6,3,6,10,6,3,22,5,2,3,4,2,18,4,26,10,4,5,6,2,2,7,6,2,10,5,2,9,4,2,16,3,6,9,2,3,30,5,14,6,24,5,16,5", "code": "\nimport sympy\nfrom sympy import isprime\ndef f(n):\n..for k in range(1,10**3):\n....if isprime(k*(n**3)-1):\n......return k\nn = 1\nwhile n < 10**3:\n..print(f(n))\n..n += 1\n"}
{"sequence_id": "A238849", "text": "Smallest k such that k*n^3 - 1 and k*n^3 + 1 are twin primes.", "sequence": "4,9,4,3,24,2,24,30,58,3,12,19,96,3,10,165,114,11,390,159,2,30,114,10,18,12,24,6,42,19,72,24,30,72,24,3,150,189,40,54,348,5,24,93,14,33,324,9,150,81,70,39,354,3,138,42,56,51,180,16,18,9", "code": "\nimport sympy\nfrom sympy import isprime\ndef f(n):\n..for k in range(1,10**4):\n....if isprime(k*(n**3)-1) and isprime(k*(n**3)+1):\n......return k\nn = 1\nwhile n < 10**3:\n..print(f(n))\n..n += 1\n"}
{"sequence_id": "A239016", "text": "Numbers not larger than any rotation of their digits.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,22,23,24,25,26,27,28,29,33,34,35,36,37,38,39,44,45,46,47,48,49,55,56,57,58,59,66,67,68,69,77,78,79,88,89,99,111,112,113,114,115,116,117,118,119,122,123,124,125,126,127,128,129,132", "code": "\ndef ok(n):\n    s = str(n)\n    if \"\".join(sorted(s)) == s: return True\n    return all(n <= int(s[i:] + s[:i]) for i in range(1, len(s)))\nprint(list(filter(ok, range(133)))) \n"}
{"sequence_id": "A239020", "text": "Smallest number k such that k*n +/- 1 and k*n^2 +/- 1 are two sets of twin primes. a(n) = 0 if no such number exists.", "sequence": "4,3,2,15,6,2,150,75,20,6,78,85,2490,30,18,195,5160,490,330,12,2,870,330,13,42,105,2280,375,12,41,1632,720,90,3,216,2,1380,615,98,84,438,65,600,210,148,735,3870,115,138,39,182,2715,16590,48,60,63,210,120", "code": "\nimport sympy\nfrom sympy import isprime\ndef b(n):\n..for k in range(10**5):\n....if isprime(k*n+1) and isprime(k*n-1) and isprime(k*(n**2)+1) and isprime(k*(n**2)-1):\n......return k\nn = 1\nwhile n < 100:\n..print(b(n))\n..n += 1\n"}
{"sequence_id": "A239021", "text": "Smallest number k such that k*n +/- 1, k*n^2 +/- 1, and k*n^3 +/- 1 are three sets of twin primes. a(n) = 0 if no such number exists.", "sequence": "4,105525,10990,15855,344190,2,74580,11580,165592,3759,204918,12670,99090,78,3978,11655,8979180,10605,55188,1221,2,23340,4431420,39158,58464,87318,45420,15780,210,91,289422,19740,186410,1293,137664,747,443730,94920,278278", "code": "\nimport sympy\nfrom sympy import isprime\ndef b(n):\n..for k in range(10**8):\n....if isprime(k*n+1) and isprime(k*n-1) and isprime(k*(n**2)+1) and isprime(k*(n**2)-1) and isprime(k*(n**3)+1) and isprime(k*(n**3)-1):\n......return k\nn = 1\nwhile n < 100:\n..print(b(n))\n..n += 1\n"}
{"sequence_id": "A239071", "text": "Numbers k such that k+x+y is a triangular number (A000217), where x and y are the two triangular numbers nearest to k.", "sequence": "0,2,6,11,19,39,53,84,104,122,146,195,225,285,321,352,392,434,470,516,605,657,757,815,864,926,990,1044,1112,1241,1315,1455,1535,1602,1686,1844,1934,2103,2199,2279,2379,2481,2566,2672,2870,2982,3191,3309,3407,3529", "code": "\ndef isqrt(a):\n    sr = 1 << (int.bit_length(int(a)) >> 1)\n    while a < sr*sr:  sr>>=1\n    b = sr>>1\n    while b:\n        s = sr + b\n        if a >= s*s:  sr = s\n        b>>=1\n    return sr\ndef isTriang(x):\n    x+=x\n    r = isqrt(x)\n    return r*(r+1)==x\nprint('0', end=', ')\nfor n in range(777):\n    tn = n*(n+1)//2\n    tn1 = (n+1)*(n+2)//2\n    for t in range(tn+1, tn1+1):\n        if isTriang(tn+t+tn1): print(str(t), end=',')\n"}
{"sequence_id": "A239103", "text": "Triangular array read by rows, arising from enumeration of binary words containing n 0's and k 1's that avoid the pattern 1011101.", "sequence": "1,2,1,6,3,1,20,10,4,1,70,35,15,5,1,248,123,54,20,6,1,894,442,198,78,26,7,1,3264,1611,732,300,108,33,8,1,12036,5936,2727,1150,437,146,41,9,1,44722,22047,10214,4398,1736,617,192,50,10,1", "code": "\nfrom itertools import combinations\nA239103_list = []\nfor n in range(16):\n....for k in range(n,-1,-1):\n........c, d0 = 0, ['0']*(n+k)\n........for x in combinations(range(n+k),n):\n............d = list(d0)\n............for i in x:\n................d[i] = '1'\n............if not '1011101' in ''.join(d):\n................c += 1\n........A239103_list.append(c) \n"}
{"sequence_id": "A239133", "text": "Numbers n such that n^p_1 + n^p_2 + ... + n^p_k + 1 is prime where p_1,...p_k denote each prime factor of n, not necessarily distinct.", "sequence": "2,8,9,12,20,28,39,48,72,90,92,96,120,128,162,272,308,340,408,472,486,510,572,690,810,912,936,972,1107,1224,1312,1444,1632,1734,1870,1890,2002,2106,2432,2592,2912,2916,3004,3068,3768,3834,4256,4394,4557,4725", "code": "\nimport sympy\nfrom sympy import factorint\nfrom sympy import isprime\ndef Exp(x):\n..lst = []\n..for i in range(len(factorint(x).values())):\n....for a in range(list(factorint(x).values())[i]):\n......lst.append(list(factorint(x))[i])\n..num = 1\n..for n in lst:\n....num += x**n\n..if isprime(num):\n....return True\nx = 1\nwhile x < 10**4:\n..if Exp(x):\n....print(x)\n..x += 1\n"}
{"sequence_id": "A239134", "text": "Smallest k such that n^k contains k as a substring in its decimal representation.", "sequence": "1,6,7,6,2,6,3,4,5,1,1,1,1,1,1,1,1,1,1,6,1,4,2,3,2,4,2,4,3,7,1,2,3,3,2,2,3,5,2,6,1,8,4,4,2,2,2,2,2,2,1,2,2,2,2,4,2,4,3,6,1,3,5,6,2,4,3,2,3,3,1,3,2,6,2,3,2,6,2,4,1,2,4,4", "code": "\ndef Sub(x):\n..for n in range(10**3):\n....if str(x**n).find(str(n)) > -1:\n......return n\nx = 1\nwhile x < 10**3:\n..print(Sub(x))\n..x += 1\n"}
{"sequence_id": "A239146", "text": "Smallest k>0 such that n +/- k and n^2 +/- k are all prime. a(n) = 0 if no such number exists.", "sequence": "0,0,0,0,0,0,0,3,2,3,0,5,0,3,2,0,0,13,12,0,2,0,0,0,6,15,10,0,12,0,0,15,20,0,12,5,0,15,22,21,12,0,0,0,14,27,0,35,0,0,8,15,0,0,24,27,0,0,48,7,48,0,50,3,6,7,0,0,28,0,18,0,0,27,34", "code": "\nimport sympy\nfrom sympy import isprime\ndef c(n):\n..for k in range(1,n):\n....if isprime(n+k) and isprime(n-k) and isprime(n**2+k) and isprime(n**2-k):\n......return k\nn = 1\nwhile n < 100:\n..if c(n) == None:\n....print(0)\n..else:\n....print(c(n))\n..n += 1\n"}
{"sequence_id": "A239147", "text": "Numbers n such that there exists a k>0 such that all six of n +/- k, n^2 +/- k, and n^3 +/- k are prime.", "sequence": "12,25,29,36,45,55,78,87,105,109,111,130,140,141,155,160,190,196,209,216,231,245,246,265,274,280,289,294,311,315,329,356,364,385,409,441,444,465,475,489,494,531,535,572,582,600,624,629,650,665", "code": "\nimport sympy\nfrom sympy import isprime\ndef c(n):\n..for k in range(n):\n....if isprime(n+k) and isprime(n-k) and isprime(n**2+k) and isprime(n**2-k) and isprime(n**3+k) and isprime(n**3-k):\n......return k\nn = 1\nwhile n < 10**3:\n..if c(n) != None:\n....print(n)\n..n += 1\n"}
{"sequence_id": "A239210", "text": "Numbers k such that k^2 is not divisible by any of its nonzero digits.", "sequence": "7,17,23,26,47,53,67,73,76,77,83,86,94,97,143,157,163,167,173,176,187,193,194,197,223,233,236,244,253,256,257,260,274,277,283,287,293,307,313,314,457,473,493,503,517,523,527,533,547,553,577,583,587,607,613", "code": "\ndef ok(n): return not any(n*n%int(d) == 0 for d in str(n*n) if d != '0')\nprint(list(filter(ok, range(1, 614)))) \n"}
{"sequence_id": "A239236", "text": "Numbers n such that d_1^n + d_2^n + ... + d_k^n is prime where d_i represents the i-th digit in the decimal representation of n.", "sequence": "11,101,110,111,353,1001,1010,1011,1100,1101,1110,10001,10010,10011,10100,10101,10110,11000,11001,11010,11100,11111,62315,100001,100010,100011,100100,100101,100110,101000,101001,101010,101100,101111,110000,110001,110010", "code": "\nimport sympy\nfrom sympy import isprime\ndef Pow(x):\n..num = 0\n..for i in str(x):\n....num += int(i)**x\n..if isprime(num):\n....return True\nx = 1\nwhile x < 10**5:\n..if Pow(x):\n....print(x)\n..x += 1\n"}
{"sequence_id": "A239237", "text": "Numbers n such that n^d_1 + n^d_2 + ... n^d_k is prime where d_i is the i-th digit in the decimal representation of n.", "sequence": "10,20,203,230,308,309,330,350,503,603,650,960,1068,1110,1206,1350,1404,1480,1730,1802,1860,1910,2032,2038,2044,2054,2250,2320,2502,3044,3082,3402,3970,4032,4046,4072,4120,4340,4450,4540,4650,4908,5204,5310,5402", "code": "\nimport sympy\nfrom sympy import isprime\ndef PowOpp(x):\n..if str(x).find('0') > -1:\n....num = 0\n....for i in str(x):\n......num += x**int(i)\n....if isprime(num):\n......return True\nx = 1\nwhile x < 10**4:\n..if PowOpp(x):\n....print(x)\n..x += 1\n"}
{"sequence_id": "A239275", "text": "a(n) = numerator(2^n * Bernoulli(n, 1)).", "sequence": "1,1,2,0,-8,0,32,0,-128,0,2560,0,-1415168,0,57344,0,-118521856,0,5749735424,0,-91546451968,0,1792043646976,0,-1982765704675328,0,286994513002496,0,-3187598700536922112,0,4625594563496048066560,0,-16555640873195841519616,0,22142170101965089931264,0", "code": "\nfrom sympy import bernoulli\ndef a(n): return (2**n * bernoulli(n, 1)).numerator()\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A239278", "text": "Smallest k > 1 such that n*(n+1)*...*(n+k-1) / (n+(n+1)+...+(n+k-1)) is an integer.", "sequence": "3,5,3,3,5,3,3,7,3,3,5,3,3,5,3,3,5,3,3,5,3,3,7,3,3,5,3,3,5,3,3,5,3,3,5,3,3,7,3,3,5,3,3,5,3,3,5,3,3,5,3,3,9,3,3,5,3,3,5,3,3,5,3,3,5,3,3,7,3,3,5,3,3,5,3,3,5,3,3,5,3,3,7,3,3,5,3,3,5,3,3,5,3,3,5,3,3,7,3", "code": "\ndef Divi(x):\n..k = 2\n..while k < 100:\n....prod = 1\n....total = 0\n....for i in range(x,x+k):\n......prod *= i\n......total += i\n......if prod/total % 1 == 0:\n........return k\n....else:\n......k += 1\nx = 1\nwhile x < 100:\n..print(Divi(x))\n..x += 1\n"}
{"sequence_id": "A239279", "text": "Smallest k such that n^k - k^n is prime, or 0 if no such number exists.", "sequence": "5,1,1,14,1,20,1,10,273,14,1,38,1,68,0", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import gcd\ndef Min(x):\n..k = 1\n..while k < 5000:\n....if gcd(k,x) == 1:\n......if isprime(x**k-k**x):\n........return k\n......else:\n........k += 1\n....else:\n......k += 1\nx = 1\nwhile x < 100:\n..print(Min(x))\n..x += 1\n"}
{"sequence_id": "A239287", "text": "Triangle T(n,k), 0 <= k <= n, read by rows: T(n,k) = floor(n/2) - min(k,n-k).", "sequence": "0,0,0,1,0,1,1,0,0,1,2,1,0,1,2,2,1,0,0,1,2,3,2,1,0,1,2,3,3,2,1,0,0,1,2,3,4,3,2,1,0,1,2,3,4,4,3,2,1,0,0,1,2,3,4,5,4,3,2,1,0,1,2,3,4,5,5,4,3,2,1,0,0,1,2,3,4,5,6,5,4,3,2,1,0,1,2", "code": "\ni=0\nfor n in range(0,20):\n....for k in range(0, n+1):\n........print str(i)+\" \"+str((n/2) - min(k, n - k))\n........i+=1 \n"}
{"sequence_id": "A239316", "text": "Index of the first occurrence of a string of exactly n consecutive odd digits in the decimal expansion of Pi.", "sequence": "18,1,4,13,282,342,783,43,4424,412,940,8337,44968,61667,33821,106904,336404,421527,31488,1850725,5854551,8996526,11709660,2493200,105887707,86401248,701257139,546257302,92438127", "code": "\nwith open(\"pib.txt\") as f:\n....digits = f.read(1000000000)\n....for a in range(1,30):\n........found = False\n........place = 0\n........now = 0\n........while place < 999999999:\n............b = int(digits[place])\n............c = int(digits[place+1])\n............if b % 2 == 1:\n................now += 1\n............else:\n................now = 0\n............if now == a and c%2 == 0:\n................print(a,place-a+2)\n................found = True\n................break\n............place += 1\n........if not found:\n............print(\"Not found in first billion digits.\")\n\n\n"}
{"sequence_id": "A239317", "text": "Index of the first occurrence of a string of n even numbers in the decimal expansion of Pi.", "sequence": "3,7,53,117,33,19,965,373,1834,70,5876,8878,9288,1279,173580,248625,652113,678288,2199379,1656691,3455554,30021792,18707922,26568757,189709607,36454145,255896738,388817627", "code": "\nwith open(\"pib.txt\") as f:\n....digits = f.read(1000000000)\n....for a in range(1,30):\n........found = False\n........place = 0\n........now = 0\n........while place < 999999999:\n............b = int(digits[place])\n............c = int(digits[place+1])\n................if b % 2 == 0:\n....................now += 1\n................else:\n....................now = 0\n................if now == a and c%2 == 1:\n....................print(a,place-a+2)\n....................found = True\n....................break\n................place += 1\n........if not found:\n............print(\"Not found in first billion digits.\")\n\n"}
{"sequence_id": "A239321", "text": "Numbers n such that n - k! is never prime; or A175940(n) = 0.", "sequence": "1,2,10,16,22,28,34,36,40,46,50,51,52,56,57,58,64,66,70,76,78,82,86,87,88,92,93,94,96,100,101,106,112,116,117,118,120,124,126,130,134,135,136,142,144,146,147,148,154,156,160,162,166,170,171,172,176,177", "code": "\nimport sympy\nfrom sympy import isprime\nimport math\ndef Prf(x):\n..count = 0\n..for i in range(x):\n....if isprime(x-math.factorial(i)):\n......count += 1\n..return count\nx = 1\nwhile x < 10**3:\n..if Prf(x) == 0:\n....print(x)\n..x += 1\n"}
{"sequence_id": "A239343", "text": "Numbers n such that n^5+5 is prime.", "sequence": "0,2,36,42,56,72,98,122,134,156,162,182,212,302,338,386,486,492,576,642,666,672,698,708,722,734,782,828,846,878,882,888,896,938,962,974,986,992,1052,1062,1104,1106,1148,1182,1224,1244,1266,1284,1304,1338,1394", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**5+5)}\n"}
{"sequence_id": "A239344", "text": "Numbers n such that n^7+7 is prime.", "sequence": "0,16,48,66,76,94,114,120,214,216,270,346,454,496,516,594,598,606,628,730,780,786,808,936,948,1030,1044,1104,1168,1248,1258,1270,1276,1396,1474,1506,1548,1594,1728,1746,1830,1870,1900,1908,1914,1936,1968,2040,2070,2104,2118,2136,2158,2278,2320,2376,2518,2586,2610,2736", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**7+7)}\n"}
{"sequence_id": "A239345", "text": "Numbers n such that n^8+8 is prime.", "sequence": "3,33,105,129,165,201,231,351,363,393,447,543,687,861,951,1107,1149,1227,1257,1269,1293,1359,1389,1515,1557,1605,1647,1689,1761,1803,1815,1941,1977,2073,2127,2145,2163,2289,2355,2415,2445,2481,2571,2607,2619,2775,2811,2859,2973,3141,3171,3321,3327,3333,3393,3471,3501,3513", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**8+8)}\n"}
{"sequence_id": "A239346", "text": "Numbers n such that n^9+9 is prime.", "sequence": "2,4,10,20,40,98,100,118,122,134,140,164,190,262,272,362,400,410,494,592,602,632,638,664,830,860,862,880,938,944,962,1120,1148,1162,1202,1288,1340,1360,1408,1498,1594,1642,1772,1802,1840,1870,1874,1882,1960,2078,2092,2158,2170,2188,2348,2368,2462,2474,2482,2488,2498", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**9+9)}\n"}
{"sequence_id": "A239347", "text": "Numbers n such that n^10+10 is prime.", "sequence": "1,539,583,1023,1903,2277,2893,3047,4433,4587,4983,5181,6567,7271,7359,10857,10989,11341,12221,12507,13167,13277,13453,13739,14443,14729,17347,17919,17941,18381,19151,19437,19481,21131,21197,21307,22561,23331,24871,25003,25289,27643,28391,29161,29469,31339,33077,35057,36597", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**5) if isprime(n**10+10)}\n"}
{"sequence_id": "A239413", "text": "Numbers n such that n^5-5 is prime.", "sequence": "4,12,16,42,102,124,132,144,184,232,274,288,306,316,336,352,406,438,478,582,606,622,706,742,754,762,814,832,916,922,964,984,996,1026,1044,1072,1086,1096,1156,1174,1204,1258,1272,1366,1408,1416,1428,1432,1456", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**5-5)}\n"}
{"sequence_id": "A239414", "text": "Numbers n such that n^6-6 is prime.", "sequence": "5,7,17,37,113,137,157,173,175,203,223,227,295,337,395,407,475,487,503,535,605,617,707,743,797,833,857,863,865,877,905,943,947,965,973,995,1037,1043,1057,1103,1217,1243,1247,1277,1295,1337,1357,1363,1375,1403", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**6-6)}\n"}
{"sequence_id": "A239415", "text": "Numbers n such that n^7-7 is prime.", "sequence": "60,66,132,212,242,246,290,296,312,326,380,384,446,516,524,554,654,704,740,782,834,1026,1086,1142,1154,1172,1182,1214,1424,1430,1464,1482,1494,1500,1524,1604,1682,1686,1752,1794,1796,1844,1854,1940,1952,1980,2000,2010", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**7-7)}\n"}
{"sequence_id": "A239416", "text": "Numbers n such that n^8-8 is prime.", "sequence": "3,7,19,39,73,75,101,107,145,147,171,213,235,247,263,285,319,353,359,369,399,443,445,521,523,557,613,675,693,707,733,781,791,805,815,829,837,879,927,943,961,999,1033,1097,1103,1109,1129,1137,1141,1155,1157", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**8-8)}\n"}
{"sequence_id": "A239417", "text": "Numbers n such that n^9-9 is prime.", "sequence": "2,62,86,88,116,152,266,292,310,326,338,356,406,436,466,470,518,550,568,616,626,650,688,700,722,812,850,926,956,992,1058,1076,1126,1186,1252,1430,1550,1570,1642,1672,1682,1766,1808,1852,1868,1888,2138,2210,2306", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**9-9)}\n"}
{"sequence_id": "A239418", "text": "Numbers n such that n^10 - 10 is prime.", "sequence": "21,201,267,321,369,459,537,651,669,699,723,753,1071,1113,1197,1203,1209,1323,1401,1503,1587,1647,1773,1791,1797,1917,1941,2007,2139,2223,2427,2493,2613,2733,2769,2787,2847,3147,3249,3267,3297,3399,3423,3441,3771", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n**10-10)}\n"}
{"sequence_id": "A239429", "text": "Numbers n such that n^6+6 and n^6-6 are prime.", "sequence": "175,12635,18445,30275,32585,38885,41125,46235,53165,71785,74935,92645,108115,117775,121625,146125,151655,173635,184765,191765,196175,204505,208705,229775,237965,241255,243635,246365,283115,335755,344365,345485,352625,353395,354445", "code": "\nimport sympy\nfrom sympy import isprime\ndef TwoBoth(x):\n..for k in range(10**6):\n....if isprime(k**x+x) and isprime(k**x-x):\n......print(k)\nTwoBoth(6)\n"}
{"sequence_id": "A239437", "text": "Least number that is pandigital in some base >= n but not pandigital in bases 3 through n-1.", "sequence": "11,78,698,12280,179685,5518135,1037845296,1037845296,46935813565,2860727439460,285947759601954,1018897102759406,672654273047783383", "code": "\nfrom itertools import permutations\nfrom gmpy2 import digits\ndef A239437(n): \n....m = n\n....while True:\n........s = ''.join([digits(i,m) for i in range(m)])\n........for d in permutations(s,m):\n............if d[0] != '0':\n................c = mpz(''.join(d),m)\n................for b in range(3,n):\n....................if len(set(digits(c,b))) == b:\n........................break\n................else:\n....................return int(c)\n........m += 1 \n"}
{"sequence_id": "A239447", "text": "Partial sums of A030101.", "sequence": "0,1,2,5,6,11,14,21,22,31,36,49,52,63,70,85,86,103,112,137,142,163,176,205,208,227,238,265,272,295,310,341,342,375,392,441,450,491,516,573,578,615,636,689,702,747,776,837,840,875,894,945,956,999,1026,1085", "code": " A = {0: 0, 1: 1, 2: 2, 3: 5}\n.\ndef a(n):\n....a_n = A.get(n)\n....if a_n is not None:\n........return a_n\n.\n....q, r = divmod(n, 4)\n....if r == 0:\n........a_n = a(q*2)*6 - a(q)*5 - a(q - 1)*3 - 1\n....elif r == 1:\n........a_n = a(q*2 + 1)*2 + a(q*2)*4 - a(q)*6 - a(q - 1)*2 - 1\n....elif r == 2:\n........a_n = a(q*2 + 1)*3 + a(q*2)*3 - a(q)*6 - a(q - 1)*2 - 1\n....else:\n........a_n = a(q*2 + 1)*6 - a(q)*8 - 1\n.\n....A[n] = a_n  \n.\n....return a_n\n"}
{"sequence_id": "A239452", "text": "Smallest integer m > 1 such that m^n == m (mod n).", "sequence": "2,2,2,4,2,3,2,8,8,5,2,4,2,7,4,16,2,9,2,5,6,11,2,9,7,13,26,4,2,6,2,32,10,17,6,9,2,19,12,16,2,7,2,12,8,23,2,16,18,25,16,9,2,27,10,8,18,29,2,16,2,31,8,64,5,3,2,17,22,11,2,9,2,37,24,20,21", "code": "\nL=[];\nfor n in range(1,101):\n...a=2\n...while (a**n - a) % n != 0:\n......a+=1\n...L=L+[a]\nL\n"}
{"sequence_id": "A239472", "text": "Least number k such that k^n-(k-1)^n-...-3^n-2^n is prime. a(n) = 0 if no such number exists.", "sequence": "2,3,3,7,3,0,0,0,0,7,7,0,4,0,8,11,3,16,15,0,4,7,0,23,0,19,12,11,3,0,3,7,12,0,12,0,0,0,0,0,16,0,0,0,59,11,44,32,16,0,0,0,3,0,23,0,20,75,3,0,28,0,0,0,36,0,60,0,0,0,36,0,0,0,0,19,0,0,0,0,0,91,75,0,0,0,32,108,7,0,60,0,40,39,0,0,0,0,80", "code": "\nimport sympy\nfrom sympy import isprime\ndef Lep(n):\n..for k in range(2*10**3):\n....num = k**n\n....for i in range(2,k):\n......num -= i**n\n......if num < 0:\n........return None\n....if isprime(num):\n......return k\nn = 1\nwhile n < 100:\n..if Lep(n) == None:\n....print(0)\n..else:\n....print(Lep(n))\n..n += 1\n"}
{"sequence_id": "A239474", "text": "Smallest k >= 1 such that k^n-n is prime. a(n) = 0 if no such k exists.", "sequence": "3,2,2,0,4,5,60,3,2,21,28,5,2,199,28,0,234,11,2,3,2,159,10,31,68,145,0,69,186,163,32,253,26,261,4,0,8,11,62,3,22,43,6,7,8,945,76,7,116,129,382,93,330,361,2,555,224,1359,78,29,62,39,110,0,1032,37,462,29", "code": "\nimport sympy\nfrom sympy import isprime\ndef TwoMin(x):\n..for k in range(1,5000):\n....if isprime(k**x-x):\n......return k\nx = 1\nwhile x < 100:\n..print(TwoMin(x))\n..x += 1\n"}
{"sequence_id": "A239475", "text": "Least number k such that k^n + n and k^n - n are both prime, or 0 if no such number exists.", "sequence": "4,3,2,0,42,175,66,3,2,4983,1770,55055,28686,18765,8456,0,594,128345,136080,81,92,1163409,18810,10415,11754,3855,0,86043,38880,17639,26088,37293,5540,612015,6876,0,44220,130425,110,9292527,1004850,1812149,442404,1007445,570658", "code": "\nimport sympy\nfrom sympy import isprime\ndef TwoBoth(x):\n..for k in range(1,10**7):\n....if isprime(k**x+x) and isprime(k**x-x):\n......return k\nx = 1\nwhile x < 100:\n..if TwoBoth(x) != None:\n....print(TwoBoth(x))\n..else:\n....print(0)\n..x += 1\n"}
{"sequence_id": "A239503", "text": "Numbers n such that n^8+8 and n^8-8 are prime.", "sequence": "3,1515,1689,3327,4461,4641,4965,5043,5583,5709,6183,7089,9291,9369,9699,10125,11109,14175,15081,18393,20295,26955,27009,27219,29067,30513,30807,35355,35889,36003,37935,40107,43461,48045,49005,51783,53289,55527,58833,61203", "code": "\nimport sympy\nfrom sympy import isprime\ndef TwoBoth(x):\n..for k in range(10**6):\n....if isprime(k**x+x) and isprime(k**x-x):\n......print(k)\nTwoBoth(8)\n"}
{"sequence_id": "A239505", "text": "Numbers n such that n^9+9 and n^9-9 are prime.", "sequence": "2,1642,2870,2948,4238,5480,5920,7502,8210,8248,9328,11572,13538,13610,14818,14908,19298,21022,21890,21988,22340,23000,23252,26282,26380,29168,31660,32602,33338,33650,36220,38248,38422,43490,43910,44948,45188,46048", "code": "\nimport sympy\nfrom sympy import isprime\ndef TwoBoth(x):\n..for k in range(10**6):\n....if isprime(k**x+x) and isprime(k**x-x):\n......print(k)\nTwoBoth(9)\n"}
{"sequence_id": "A239506", "text": "Numbers n such that n^10+10 and n^10-10 are prime.", "sequence": "4983,105369,113289,150051,191829,208131,277167,305349,363957,400323,494241,541233,577269,656271,668547,995247,1141503,1218261,1360623,1494537,1501863,1528857,1531959,1534533,1535919,1621653,1651551,1864863,1950597,1969539,2130513", "code": "\nimport sympy\nfrom sympy import isprime\ndef TwoBoth(x):\n..for k in range(10**8):\n....if isprime(k**x+x) and isprime(k**x-x):\n......print(k)\nTwoBoth(10)\n"}
{"sequence_id": "A239519", "text": "a(n) = n + (n-1)*(n-2) + (n-3)*(n-4)*(n-5) + (n-6)*(n-7)*(n-8)*(n-9) + ... + ...*1.", "sequence": "0,1,3,5,11,19,32,62,112,191,316,558,988,1711,2864,4661,7703,12883,21626,35989,58826,94217,150017,239047,382676,614425,984452,1565021,2458810,3826746,5918938,9136603,14115710,21842345,33804340,52186061,80128082,122221802", "code": "\nfor n in range(55):\n  sum = i = 0\n  k = 1\n  while i<n:\n    product = 1\n    for x in range(k):\n      product *= n - i\n      i += 1\n      if i>=n:  break\n    sum += product\n    k += 1\n  print str(sum)+',',\n"}
{"sequence_id": "A239580", "text": "Numbers n such that A227364(n) = 1 + 2*3 + 4*5*6 + 7*8*9*10 + ... + ...*n  is a prime.", "sequence": "2,3,4,6,9,10,13,14,15,18,30,32,54,58,59,81,85,128,140,203,204,206,209,223,286,305,343,350,367,397,399,451,453,506,534,656,676,698,730,756,845,849,878,944,1020,1040,1091,1248,1256,1300,1310,1326,1364,1406,1535", "code": "\nimport sympy\nfrom sympy import isprime\nfor n in range(10000):\n  sum = 0\n  i = k = 1\n  while i<=n:\n    product = 1\n    for x in range(k):\n      product *= i\n      i += 1\n      if i>n: break\n    sum += product\n    k += 1\n  if isprime(sum):  print str(n)+',',\n"}
{"sequence_id": "A239638", "text": "Numbers n such that the semiprime 2^n-1 is divisible by 2n+1.", "sequence": "11,23,83,131,3359,130439", "code": "\nfrom sympy import isprime, nextprime\nA239638_list, p = [], 5\nwhile p < 10**6:\n    if (p % 6) == 5:\n        n = (p-1)//2\n        if pow(2,n,p) == 1 and isprime((2**n-1)//p):\n            A239638_list.append(n)\n    p = nextprime(p) \n"}
{"sequence_id": "A239676", "text": "Least k such that k*3^n+1 is prime.", "sequence": "1,2,2,4,2,2,2,8,6,2,8,28,10,12,4,4,2,2,10,20,26,24,8,48,16,34,14,14,18,6,2,26,26,14,22,26,16,22,12,4,62,64,68,88,70,56,34,96,32,50,20,24,8,6,2,18,6,2,8,6,2,42,14,18,6,2,98,66,22,70,74,80,68,52", "code": "\nimport sympy\nfrom sympy import isprime\ndef Pow3(n):\n..for k in range(10**4):\n....if isprime(k*(3**n)+1):\n......return n\nn = 1\nwhile n < 100:\n..print(Pow3(n))\n..n += 1\n"}
{"sequence_id": "A239677", "text": "Least numbers k such that k*3^n-1 is prime.", "sequence": "1,2,2,8,4,6,2,2,16,8,6,2,16,10,4,14,8,18,6,2,18,6,2,20,18,6,2,38,30,10,16,20,18,6,2,60,20,10,10,40,58,48,16,12,4,32,90,30,10,8,130,62,26,10,6,2,30,10,32,18,6,2,74,28,46,18,6,2,30,10,46,80,94,52", "code": "\nimport sympy\nfrom sympy import isprime\ndef Pow_3(n):\n..for k in range(10**4):\n....if isprime(k*(3**n)-1):\n......return n\nn = 1\nwhile n < 100:\n..print(Pow_3(n))\n..n += 1\n"}
{"sequence_id": "A239678", "text": "Least numbers k such that k*2^n+1 is a square.", "sequence": "3,4,2,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151,4194303,8388607,16777215,33554431,67108863,134217727,268435455,536870911,1073741823,2147483647,4294967295", "code": "\nimport sympy\nfrom sympy import isprime\ndef TwoSq(n):\n..for k in range(1,10**10):\n....for i in range(10**4):\n......if k*(2**n)+1 == i**2:\n........return k\n......if k*(2**n)+1 < i**2:\n........break\nn = 1\nwhile n < 100:\n..print(TwoSq(n))\n..n += 1\n"}
{"sequence_id": "A239679", "text": "Least number k > 0 such that k*2^n+1 is a cube.", "sequence": "7,13,31,91,307,1123,4291,16771,66307,263683,1051651,4200451,16789507,67133443,268484611,1073840131,4295163907,17180262403,68720263171,274879479811,1099514773507,4398052802563,17592198627331,70368769343491,281475027042307,1125900007505923", "code": " {print(3+3*(2**n)+2**(2*n)) for n in range(100)}\n"}
{"sequence_id": "A239696", "text": "Smallest number m such that m and reverse(m) each have n distinct prime factors.", "sequence": "2,6,66,858,6006,204204,10444434,208888680,6172882716", "code": "\nimport sympy\nfrom sympy import factorint\ndef Rev(x):\n..rev = ''\n..for i in str(x):\n....rev = i + rev\n..return int(rev)\ndef RevFact(x):\n..n = 2\n..while n < 10**8:\n....if len(list(factorint(n).values())) == x:\n......if len(list(factorint(Rev(n)).values())) == x:\n........return n\n......else:\n........n += 1\n....else:\n......n += 1\nx = 1\nwhile x < 50:\n..print(RevFact(x))\n..x += 1\n"}
{"sequence_id": "A239697", "text": "Smallest m such that m and reverse(m) each have n (not necessarily distinct) prime factors.", "sequence": "2,4,8,88,252,2576,8820,2112,4224,8448,44544,48384,846720,4078080,405504,4091904,441606144,405909504,886898688,677707776,4285005824,63769149440,21128282112,633498894336,2701312131072,6739855589376,29142024192,65892155129856,4815463645184,445488555884544,23088546155855872", "code": "\nimport sympy\nfrom sympy import factorint\nfrom sympy import primorial\ndef Rev(x):\n..rev = ''\n..for i in str(x):\n....rev = i + rev\n..return int(rev)\ndef RevFact(x):\n..n = 2\n..while n <= primorial(x):\n....if sum(list(factorint(n).values())) == x:\n......if sum(list(factorint(Rev(n)).values())) == x:\n........return n\n......else:\n........n += 1\n....else:\n......n += 1\nx = 1\nwhile x < 50:\n..print(RevFact(x))\n..x += 1\n"}
{"sequence_id": "A239732", "text": "Primes p such that 2p+9 and 9p+2 are both prime.", "sequence": "5,11,19,29,31,71,101,109,131,151,179,211,229,239,269,281,311,491,521,541,719,739,751,809,919,929,971,1051,1061,1129,1181,1291,1361,1439,1481,1621,1741,1811,1831,2111,2131,2221,2371,2389,2411,2521,2539,2549,2689,2791", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(5000) if isprime(2*n+9) and isprime(9*n+2) and isprime(n)}\n"}
{"sequence_id": "A239733", "text": "Primes p such that 4p+9 and 9p+4 are both prime.", "sequence": "7,11,23,37,41,67,71,97,113,137,163,191,197,263,307,317,401,421,491,617,653,683,727,823,881,883,907,947,953,967,1031,1087,1103,1217,1231,1297,1451,1493,1523,1567,1693,1747,1933,1973,2053,2141,2207,2221,2281,2293", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(5000) if isprime(4*n+9) and isprime(9*n+4) and isprime(n)}\n"}
{"sequence_id": "A239734", "text": "Primes p such that 8p+9 and 9p+8 are both prime.", "sequence": "11,29,71,79,151,211,251,401,419,461,541,599,601,659,881,1129,1231,1381,1831,1901,2309,2521,2741,2851,2879,2969,3011,3121,3301,3319,3511,3581,3719,3761,3779,3851,4099,4241,4561,4649,4691,4969,5021,5209,5531,5641", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(5000) if isprime(8*n+9) and isprime(9*n+8) and isprime(n)}\n"}
{"sequence_id": "A239787", "text": "Numbers n such that 3n^3 - 1 is prime.", "sequence": "1,2,4,6,10,14,26,34,36,40,44,54,64,66,70,84,86,92,100,102,116,122,134,146,150,152,156,160,172,174,176,180,190,194,200,216,252,254,262,274,306,320,322,334,336,350,352,374,384,402,414,440,442,444,460", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**3) if isprime(3*(n**3)-1)}\n"}
{"sequence_id": "A239788", "text": "Numbers n such that 3n^3 +/- 1 are twin primes.", "sequence": "4,10,14,36,54,64,70,86,150,174,176,180,200,306,384,440,494,650,706,800,824,924,976,980,986,1020,1026,1054,1360,1464,1504,1506,1536,1564,1604,1680,1724,1736,2066,2076,2116,2134,2136,2166,2200,2220,2314,2380,2456", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(3*(n**3)+1) and isprime(3*(n**3)-1)}\n"}
{"sequence_id": "A239878", "text": "Numbers n with digit_sum(n*n) + 1 = digit_sum((n+1)*(n+1)).", "sequence": "0,18,27,36,45,72,81,108,153,198,216,225,243,252,270,297,306,342,369,396,423,441,450,477,486,495,504,513,522,549,558,576,603,630,639,657,693,702,729,747,756,783,801,846,891,918,954,963,972,981", "code": "\ndef digit_Sum(n):\n...integerString = str(n)\n...digit_Sum=0\n...for digitLetter in integerString:\n......digit_Sum = digit_Sum + int(digitLetter)\n...return digit_Sum\ncount = 0;\nfor i in range(20000):\n...if(digit_Sum(i*i) + 1 == digit_Sum((i+1)*(i+1))):\n......count = count +1\n......print(anz,\"   \",i);\n"}
{"sequence_id": "A239879", "text": "Primes p such that either x divides y, or y divides x, where x = nextprime(p) - p, and y = p - prevprime(p).", "sequence": "3,5,7,11,13,17,19,29,31,41,43,53,59,61,71,73,97,101,103,107,109,137,139,149,151,157,173,179,181,191,193,197,199,211,223,227,229,239,241,257,263,269,271,281,283,311,313,347,349,373,397,401,419,421,431,433,457", "code": "\nimport sympy\nprpr = 2\nprev = 3\nfor i in range(5,1000,2):\n    if sympy.isprime(i):\n        x = i - prev\n        y = prev - prpr\n        if x%y==0 or y%x==0: print str(prev)+',',\n        prpr = prev\n        prev = i\n"}
{"sequence_id": "A239942", "text": "Prime(n)! - prime(n - 1)!.", "sequence": "4,114,4920,39911760,6187104000,355681201075200,121289412980736000,25851895093784567808000,8841761967887685215658639360000,8213996892184183115771019264000000,13763753083003506392138056763855339520000000", "code": "\nfrom gmpy2 import mpz,fac\nfrom sympy import prime\ndef A239942(n):\n....return fac(mpz(prime(n))) - fac(mpz(prime(n-1))) \n"}
{"sequence_id": "A239975", "text": "Least k>0 such that n^2 + (n+k)^2 is a square, or -1 if no such k exists.", "sequence": "7,2,17,7,3,14,49,4,71,34,5,14,127,6,161,1,7,98,241,8,35,142,9,17,391,10,449,28,11,254,49,12,647,322,13,2,799,14,881,73,15,482,1057,7,119,70,17,113,1351,18,77,34,19,782,1681,3,1799,898,21,56,7,22,2177,217,23", "code": "\nfrom sympy.ntheory.primetest import is_square\ndef a(n):\n    k = 1\n    while not is_square(n**2 + (n+k)**2): k += 1\n    return k\nprint([a(n) for n in range(5, 70)]) \n"}
{"sequence_id": "A240081", "text": "Least number k such that k^n-(k-1)^n-...-3^n-2^n-1 is prime.", "sequence": "0,2,2,5,2,6,2,5,0,0,0,6,2,0,0,6,2,0,2,0,0,0,0,0,0,0,0,0,0,0,2,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,6,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0", "code": "\nimport sympy\nfrom sympy import isprime\ndef Leq(n):\n..for k in range(1000):\n....num = k**n\n....for i in range(2, k):\n......num -= i**n\n......if num < 1:\n........return None\n....if isprime(num-1):\n......return k\nn = 1\nwhile n < 100:\n..if Leq(n) == None:\n....print(0)\n..else:\n....print(Leq(n))\n..n += 1\n"}
{"sequence_id": "A240082", "text": "Numbers n such that k^n-(k-1)^n-...-3^n-2^n-1 is prime for some k.", "sequence": "2,3,4,5,6,7,8,12,13,16,17,19,31,34,48,61,68,72,89,107,112,124,127,236,260,288,384,396,432,520,521,576,607,1080,1244,1279,1424,1500,1660,2203,2281,2640,2730,2808,3190,3217,4150,4253,4423,4428,5016,5892", "code": "\nimport sympy\nfrom sympy import isprime\ndef Leq(n):\n..for k in range(1000):\n....num = k**n\n....for i in range(2, k):\n......num -= i**n\n......if num < 1:\n........return None\n....if isprime(num-1):\n......return k\nn = 1\nwhile n < 10**3:\n..if Leq(n) != None:\n....print(n)\n..n += 1\n"}
{"sequence_id": "A240083", "text": "Numbers n such that k^n-(k-1)^n-...-3^n-2^n is prime for some k.", "sequence": "1,2,3,4,5,10,11,13,15,16,17,18,19,21,22,24,26,27,28,29,31,32,33,35,41,45,46,47,48,49,53,55,57,58,59,61,65,67,71,76,82,83,87,88,89,91,93,94,99,101,103,107,108,110,111,114,115,116,119,123,127,130,132,134,138,141", "code": "\nimport sympy\nfrom sympy import isprime\ndef Lep(n):\n..for k in range(2*10**3):\n....num = k**n\n....for i in range(2, k):\n......num -= i**n\n......if num < 0:\n........return None\n....if isprime(num):\n......return k\nn = 1\nwhile n < 10**3:\n..if Lep(n) != None:\n....print(n)\n..n += 1\n"}
{"sequence_id": "A240084", "text": "Primes p such that p^4-p^3-p^2-p-1 is prime.", "sequence": "3,11,17,41,59,71,101,113,179,233,293,347,389,449,461,503,521,617,641,683,797,953,1319,1439,1487,1493,1823,1877,1973,2087,2339,2351,2633,2663,2789,2801,2909,2927,2957,2963,2999,3011,3167,3467,3527,3677,3851,3881,3923", "code": "\nimport sympy\nfrom sympy import isprime\n{print(p) for p in range(10**4) if isprime(p**4-p**3-p**2-p-1) and isprime(p)}\n"}
{"sequence_id": "A240167", "text": "Lesser of the first cousin prime pair with n digits.", "sequence": "3,13,103,1009,10099,100189,1000033,10000453,100000123,1000000093,10000000597,100000000069,1000000000189,10000000000279,100000000001173,1000000000000399,10000000000001719,100000000000002733,1000000000000002493,10000000000000000087", "code": "\nimport sympy\nfor i in range(100):\n    a=(10**i)\n    p=sympy.nextprime(a)\n    while not sympy.isprime(p+4):\n        p=sympy.nextprime(p)\n    print(p)\n"}
{"sequence_id": "A240170", "text": "Larger of the greatest cousin prime pair with n digits.", "sequence": "7,83,971,9887,99881,999983,9999401,99999551,999999761,9999999707,99999999947,999999998867,9999999999083,99999999999467,999999999997841,9999999999997031,99999999999998717,999999999999999161,9999999999999996587,99999999999999999803", "code": "\nimport sympy\nfor i in range(1,100):\n....a=(10**i)\n....p=sympy.prevprime(a)\n....while sympy.isprime(p-4)==False:\n........p=sympy.prevprime(p)\n....print(p)\n"}
{"sequence_id": "A240173", "text": "Numbers n such that k^n - 2^k is not prime for any k.", "sequence": "1,2,13,43,45,51,53,55,57,63,72,77,81,84,85,89,93,103,108,117,121,129,147,149,151,163,171,173,177,183,191,213,229,231", "code": "\ndef a(n):\n..k = 2\n..count = 0\n..while k**n > 2**k:\n....if sympy.isprime(k**n-2**k):\n......count += 1\n....k += 1\n..return count\nn = 1\nwhile n < 1000:\n..if not a(n):\n....print(n,end=', ')\n..n += 1 \n"}
{"sequence_id": "A240454", "text": "Smallest prime divisors of the palindromes with an even number of digits.", "sequence": "11,2,3,2,5,2,7,2,3,7,11,3,11,11,3,11,7,3,11,2,2,2,2,2,2,2,2,2,2,3,11,11,3,11,11,3,7,11,3,2,2,2,2,2,2,2,2,2,2,5,3,5,5,3,5,5,3,5,5,2,2,2,2,2,2,2,2,2,2,7,11,3,11,11,3,11,7,3,11,2,2,2", "code": "\nfrom sympy import primefactors\ndef a(n): s = str(n); return min(primefactors(int(s + s[::-1])))\nprint([a(n) for n in range(1, 83)]) \n"}
{"sequence_id": "A240507", "text": "Numbers n such that 6^n - 5^n - 4^n - 3^n - 2^n - 1 is prime.", "sequence": "4,6,12,16,34,48,68,384,1080,5892,9816", "code": "\nfrom sympy import isprime\ndef afind(limit, k0=1):\n    pow6, pow5, pow4, pow3, pow2 = 6**k0, 5**k0, 4**k0, 3**k0, 2**k0\n    for k in range(k0, limit+1):\n        if isprime(pow6 - pow5 - pow4 - pow3 - pow2 - 1): print(k, end=\", \")\n        pow6 *= 6; pow5 *= 5; pow4 *= 4; pow3 *= 3; pow2 *= 2\nafind(1100) \n"}
{"sequence_id": "A240532", "text": "Numbers k such that (k+1)^(k-1) - k is prime.", "sequence": "3,5,8,17,30,66,86,100,122,160,2282", "code": "\nfrom sympy import isprime\ndef afind(limit, startk=1):\n    for k in range(startk, limit+1):\n        if isprime((k+1)**(k-1) - k): print(k, end=\", \")\nafind(200) \n"}
{"sequence_id": "A240542", "text": "The midpoint of the (rotated) Dyck path from (0, n) to (n, 0) defined by A237593 has coordinates (a(n), a(n)). Also a(n) is the alternating sum of the n-th row of A235791.", "sequence": "1,2,2,3,3,5,5,6,7,7,7,9,9,9,11,12,12,13,13,15,15,15,15,17,18,18,18,20,20,22,22,23,23,23,25,26,26,26,26,28,28,30,30,30,32,32,32,34,35,36,36,36,36,38,38,40,40,40,40,42,42,42,44,45,45,47,47,47,47,49,49,52,52", "code": "\nfrom sympy import sqrt\nimport math\ndef a(n): return sum((-1)**(k + 1) * int(math.ceil((n + 1)/k - (k + 1)/2)) for k in range(1, int(math.floor(-1/2 + 1/2*sqrt(8*n + 1))) + 1))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A240601", "text": "Recursive palindromes in base 10: palindromes n where each half of the digits of n is also a recursive palindrome.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,141,151,161,171,181,191,202,212,222,232,242,252,262,272,282,292,303,313,323,333,343,353,363,373,383,393,404,414,424,434,444,454,464,474,484,494,505,515,525,535,545,555,565,575,585,595,606,616,626,636,646,656,666,676,686,696,707,717,727,737,747,757,767,777,787,797,808,818,828,838,848,858,868,878,888,898,909,919,929,939,949,959,969,979,989,999,1111", "code": "\nfrom itertools import product\ndef pals(d, base=10): \n  digits = \"\".join(str(i) for i in range(base))\n  for p in product(digits, repeat=d//2):\n    if d//2 > 0 and p[0] == \"0\": continue\n    left = \"\".join(p); right = left[::-1]\n    for mid in [[\"\"], digits][d%2]: yield left + mid + right\ndef auptod(dd):\n  for d in range(1, dd+1):\n    for p in pals(d//2):\n      if d//2 == 0: p = \"\"\n      elif p[0] == \"0\": continue\n      for mid in [[\"\"], \"0123456789\"][d%2]: yield int(p+mid+p[::-1])\nprint([rp for rp in auptod(6)]) \n"}
{"sequence_id": "A240693", "text": "Primes p such that p^10 + p^9 + p^8 + p^7 + p^6 + p^5 + p^4 + p^3 + p^2 + p + 1 is prime.", "sequence": "5,17,53,137,229,389,467,619,709,787,1091,1103,1213,1249,1433,1459,1601,1993,2029,2039,2087,2089,2393,2687,3217,3299,3529,3547,3691,3793,4019,4091,4099,4231,4507,4561,4679,5351,5399,5471,5521,5581,5669,5783,5813,5861,5939,6247,6841,6899,6961", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n) for n in range(10**4) if isprime(n) and isprime(n**10+n**9+n**8+n**7+n**6+n**5+n**4+n**3+n**2+n+1)}\n"}
{"sequence_id": "A240754", "text": "Numbers k with digit_sum(k*k) - 1 = digit_sum((k+1)*(k+1)).", "sequence": "8,26,53,98,107,143,161,170,179,188,224,233,242,260,269,278,287,296,350,368,386,404,413,431,449,476,494,503,539,548,557,584,593,629,638,647,674,683,737,746,773,791,818,827,863,872,908,926,944,998,1007,1043", "code": "\ndef ds(n): return sum(map(int, str(n)))\ndef ok(n): return ds(n*n) - 1 == ds((n+1)*(n+1))\nprint(list(filter(ok, range(1044)))) \n"}
{"sequence_id": "A240923", "text": "a(n) = numerator(sigma(n)/n) - sigma(denominator(sigma(n)/n)).", "sequence": "0,0,0,0,0,1,0,0,0,3,0,3,0,4,2,0,0,1,0,3,0,6,0,2,0,7,0,1,0,6,0,0,4,9,0,0,0,10,0,2,0,8,0,9,2,12,0,3,0,0,6,7,0,7,0,7,0,15,0,8,0,16,0,0,0,12,0,9,8,24,0,5,0,19,0,15,0,14,0,3,0,21,0", "code": "\nfrom gmpy2 import mpq\nfrom sympy import divisors\nmap(lambda x: x.numerator-sum(divisors(x.denominator)),[mpq(sum(divisors(n)),n) for n in range(1,10**5)]) \n"}
{"sequence_id": "A240924", "text": "Digital root of squares of numbers not divisible by 2, 3 or 5.", "sequence": "1,4,4,7,1,1,7,4,7,1,7,4,4,7,1,7,4,7,1,1,7,4,4,1,1,4,4,7,1,1,7,4,7,1,7,4,4,7,1,7,4,7,1,1,7,4,4,1,1,4,4,7,1,1,7,4,7,1,7,4,4,7,1,7,4,7,1,1,7,4,4,1", "code": "\nA240924 = [1 + (n*n-1) % 9 for n in range(1,10**3,2) if n % 3 and n % 5 ]\n\n"}
{"sequence_id": "A240960", "text": "Numbers m such that sigma(m) - phi(m) = tau(m)^omega(m), where sigma=A000203, phi=A000010, tau=A000005 and omega=A001221.", "sequence": "2,3,5,7,11,13,15,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269", "code": "\nfrom sympy import totient,divisors,divisor_count,primefactors\nfilter(lambda x:sum(divisors(x))-totient(x)==divisor_count(x)**len(primefactors(x)), range(1,10**5)) \n"}
{"sequence_id": "A240962", "text": "Number of zeros in the decimal expansion of n^n.", "sequence": "0,0,0,0,0,0,0,0,1,10,1,2,2,3,2,2,1,2,1,21,1,0,5,2,3,6,3,1,1,32,6,5,7,7,3,3,6,8,6,42,5,6,10,10,5,11,4,12,11,53,5,6,12,10,8,11,15,9,5,64,12,15,14,16,13,12,13,9,16,79,12,16,15,12,14,15", "code": "\nfor n in range(1,10**3):\n..print(str(n**n).count('0'),end=', ') \n"}
{"sequence_id": "A240975", "text": "The number of distinct prime factors of n^3-1.", "sequence": "0,1,2,2,2,2,3,2,3,2,4,2,3,2,3,4,2,2,3,2,3,3,4,2,4,3,3,2,4,3,4,3,2,3,4,4,4,2,4,3,3,3,4,3,4,4,4,3,4,2,4,3,4,2,4,4,3,4,3,3,5,2,4,4,3,3,5,3,3,3,4,3,3,4,3,3,3,3,5,2", "code": "\nfrom sympy import primefactors\ndef A240975(n):\n....return len(primefactors(n**3-1)) \n"}
{"sequence_id": "A240983", "text": "Integers of the form 2^p*p^2 where p is the lesser of a pair of twin primes.", "sequence": "72,800,247808,37879808,451508436992,3696558092582912,2006659878768217161728,11902724720072940761120768,25862607545856336249335738796081152,1857706460417663797470176639788777472,3270020989306416138620967939526071071138643968", "code": "\nfrom sympy import prime, isprime\nA240983 = [2**p*p*p for p in (prime(n) for n in range(1,2*10**3)) if isprime(p+2)] \n"}
{"sequence_id": "A240986", "text": "Determinants of n X n matrices of sets of distinct primes selected by increasing prime gaps (see comments).", "sequence": "3,6,-36,-216,1296,-5184,-145152,-3856896,-170325504,-6133211136,1094593056768,26742290558976,-497681937801216,-14357497419546624,657148066947072000,12008320398059765760,1322255096225695531008,70546799432003423698944,-6537119853797882157072384,-27940593871362459110473728", "code": " See link for code.\n"}
{"sequence_id": "A241100", "text": "Smallest prime with length n having at least n-1 identical digits.", "sequence": "2,11,101,1117,10111,101111,1111151,11110111,101111111,1111111121,11111111113,101111111111,1111111118111,11111111111411,111111111116111,1111111111111181,11111111101111111,101111111111111111,1111111111111111111,11011111111111111111", "code": "\nfrom __future__ import division\nfrom sympy import isprime\ndef A241100(n):\n    for i in range(1,10):\n        x = i*(10**n-1)//9\n        for j in range(n-1,-1,-1):\n            for k in range(i,-1,-1):\n                if j < n-1 or k < i:\n                    y = x-k*(10**j)\n                    if isprime(y):\n                        return y\n        for j in range(n):\n            for k in range(1,9-i+1):\n                y = x+k*(10**j)\n                if isprime(y):\n                    return y \n"}
{"sequence_id": "A241206", "text": "Greatest n-digit prime having at least n-1 identical digits.", "sequence": "7,97,997,9949,99991,999979,9999991,99999989,999999929,9999999929,99999999599,999999999989,9999999999799,99999999999959,999999999999989,9999999999999199,99999999999999997,999999999999999989,9999999999999999919,99999999999999999989", "code": "\nfrom __future__ import division\nfrom sympy import isprime\ndef A241206(n):\n    for i in range(9,0,-1):\n        x = i*(10**n-1)//9\n        for j in range(n-1,-1,-1):\n            for k in range(9-i,-1,-1):\n                y = x + k*(10**j)\n                if isprime(y):\n                    return y\n        for j in range(n):\n            for k in range(1,i+1):\n                if j < n-1 or k < i:\n                    y = x-k*(10**j)\n                    if isprime(y):\n                        return y \n"}
{"sequence_id": "A241208", "text": "Number of binary strings of length 2n having exactly 1 factorization as a concatenation of one or more even-length palindromes.", "sequence": "2,4,12,36,96,288,836,2412,7000,20404,59256,172236,500776,1455908,4232288,12305028", "code": "\nfrom functools import lru_cache\nfrom itertools import product\ndef ispal(s): return s == s[::-1]\n@lru_cache(maxsize=2*10**7)\ndef f(b): \n    factorizations = int(len(b) >= 2 and ispal(b))\n    for i in range(2, len(b)-1, 2):\n        factorizations += ispal(b[:i]) * f(b[i:])\n        if factorizations >= 2: return 2 \n    return factorizations\ndef a(n):\n    return 2*sum(f(\"0\"+\"\".join(b))==1 for b in product(\"01\", repeat=2*n-1))\nprint([a(n) for n in range(1, 11)]) \n"}
{"sequence_id": "A241210", "text": "Number of binary strings of length n having a factorization as a concatenation of palindromes of length at least 2.", "sequence": "0,2,4,6,20,32,88,162,360,758,1564,3290,6692,13898,28356,57954,117948,239378,485472,981374,1982324,3997004,8051432,16201164,32570108,65431734,131358932,263572810,528600668,1059691960,2123635312,4254511910,8521368640,17063718174,34163130608", "code": "\nfrom functools import lru_cache\ndef ispal(s): return s == s[::-1]\n@lru_cache(maxsize=None)\ndef ok(b): \n    if len(b) >= 2 and ispal(b): return True\n    for i in range(2, len(b)-1):\n        if ispal(b[:i]) and ok(b[i:]): return True\n    return False\ndef a(n): return 2*sum(1 for m in range(2**(n-1), 2**n) if ok(bin(m)[2:]))\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A241211", "text": "Number of binary strings of length n having exactly one factorization as a concatenation of palindromes of length >= 2.", "sequence": "0,2,4,4,18,22,64,96,188,388,648,1248,2040,3784,6544,11162,19356,32396,55768,93678,157308,263308,438512,731198,1211304,2004076,3306552,5445588,8955544,14690980,24061172,39360032", "code": "\nfrom functools import lru_cache\nfrom itertools import product\ndef ispal(s): return s == s[::-1]\n@lru_cache(maxsize=None)\ndef f(b): \n    factorizations = int(len(b) >= 2 and ispal(b))\n    for i in range(2, len(b)-1):\n        factorizations += ispal(b[:i]) * f(b[i:])\n        if factorizations >= 2: return 2 \n    return factorizations\ndef a(n):\n    return 2*sum(f(\"0\"+\"\".join(b))==1 for b in product(\"01\", repeat=n-1))\nprint([a(n) for n in range(1, 16)]) \n"}
{"sequence_id": "A241489", "text": "Least number k not divisible by 10 such that k^3 contains n zeros.", "sequence": "16,52,101,252,1002,1001,10003,10002,10001,100003,100002,100001,1000003,1000002,1000001,10000003,10000002,10000001,100000003,100000002,100000001,1000000003,1000000002,1000000001,10000000003,10000000002,10000000001,100000000003,100000000002", "code": "\ndef Cu(n):\n..for k in range(10**100):\n....if k % 10 != 0:\n......if str(k**3).count(\"0\") == n:\n........return k\nn = 1\nwhile n < 100:\n..print(Cu(n))\n..n += 1\n"}
{"sequence_id": "A241490", "text": "Least zeroless number k such that k^3 contains n zeros.", "sequence": "16,52,126,252,3138,5852,58752,71138,493352,1916568,11696559,58633193,191293929,464296543,386826983,5886958939,46493141317,115356679131,79633784516,2154578383152,6694429222569", "code": "\ndef Cu(n):\n..k = 0\n..while k < 10**50:\n....if str(k).count(\"0\") > 0:\n......c = []\n......d = ''\n......for i in list(str(k).partition(\"0\")):\n........if int(i) == 0:\n..........c.append('1'*len(i))\n........else:\n..........c.append(i)\n......for j in c:\n........d += j\n......k = int(d)\n....if str(k**3).count(\"0\") == n:\n......return k\n....else:\n......k += 1\nn = 1\nwhile n < 50:\n..print(Cu(n))\n..n += 1\n"}
{"sequence_id": "A241495", "text": "Least number k not divisible by 10 such that k^n contains n zeros.", "sequence": "101,101,101,101,101,351,1244,194,4648,951,4357,3757,2169,2392,7399,7501,9723,8683,13867,6152,15204,18898,40141,54631,29647,35586,46564,67743,84789,119421,43055,43642,83055,44411,142553,94501,135852,52299,174062,121201,196205", "code": "\ndef Cu(n):\n..for k in range(10**10):\n....if k% 10 != 0:\n......if str(k**n).count(\"0\") == n:\n........return k\nn = 1\nwhile n < 100:\n..print(Cu(n))\n..n += 1\n"}
{"sequence_id": "A241557", "text": "Numbers k that do not have prime anti-divisors.", "sequence": "1,2,6,30,36,54,90,96,114,120,156,174,210,216,300,330,414,510,516,546,576,660,714,726,744,804,810,834,894,936,966,1014,1044,1056,1134,1170,1296,1344,1356,1500,1560,1584,1626,1650,1680,1686,1734,1764,1770,1836,1884,1926,2010,2046,2064", "code": "\nfrom sympy import isprime, divisors\nA241557 = [n for n in range(1,10**6) if not any([isprime(x) for x in\n..........[2*d for d in divisors(n) if n > 2*d and n % (2*d)] +\n..........[d for d in divisors(2*n-1) if n > d >=2 and n % d] +\n..........[d for d in divisors(2*n+1) if n > d >=2 and n % d]])]\n\n"}
{"sequence_id": "A241665", "text": "Number of iterations of A241663 needed to reach either 0 or 1.", "sequence": "1,1,1,1,1,1,2,1,1,1,3,1,2,1,1,1,3,1,2,1,1,1,3,1,2,1,1,1,3,1,2,1,1,1,2,1,2,1,1,1,3,1,2,1,1,1,3,1,2,1,1,1,3,1,3,1,1,1,4,1,2,1,1,1,2,1,2,1,1,1,3,1,2,1,1,1,2,1,2,1,1,1,3,1,3,1,1,1,4,1,2,1,1,1,2,1,2,1,1,1,3,1,2,1,1", "code": " See Defant link. Enter m=4, as well as starting and ending values of n. The third string of numbers will be this sequence.\n"}
{"sequence_id": "A241666", "text": "Gives the value (either 0 or 1) that the trajectory of n under A241663 eventually reaches.", "sequence": "0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1", "code": " \n(Scheme, with memoization-macro definec)\n(definec (A241666 n) (if (<= n 1) n (A241666 (A241663 n)))) ;; _Antti Karttunen_, Nov 05 2017\n"}
{"sequence_id": "A241816", "text": "a(n) is the largest number smaller than n that can be obtained by swapping two adjacent bits in n, or n if no such number exists.", "sequence": "0,1,1,3,2,3,5,7,4,5,9,7,10,11,13,15,8,9,17,11,18,19,21,15,20,21,25,23,26,27,29,31,16,17,33,19,34,35,37,23,36,37,41,39,42,43,45,31,40,41,49,43,50,51,53,47,52,53,57,55,58,59,61,63,32,33,65,35,66,67,69", "code": "\ndef bitswap(n):\n..\n..m = n\n..i = 0\n..while (m > 0):\n....if m % 2 == 0:\n......break\n....m = m >> 1\n....i = i + 1\n..if m == 0:\n.....return n\n..\n..while (m > 0):\n....if m % 2 == 1:\n......break\n....m = m >> 1\n....i = i + 1\n..\n..return n & ~(1 << i) | (1 << (i-1))\n"}
{"sequence_id": "A241816", "text": "a(n) is the largest number smaller than n that can be obtained by swapping two adjacent bits in n, or n if no such number exists.", "sequence": "0,1,1,3,2,3,5,7,4,5,9,7,10,11,13,15,8,9,17,11,18,19,21,15,20,21,25,23,26,27,29,31,16,17,33,19,34,35,37,23,36,37,41,39,42,43,45,31,40,41,49,43,50,51,53,47,52,53,57,55,58,59,61,63,32,33,65,35,66,67,69", "code": "\ndef A241816(n):\n....s = bin(n)[2:]\n....for i in range(len(s)-2,-1,-1):\n........if s[i:i+2] == '10':\n............return int(s[:i]+'01'+s[i+2:],2)\n....else:\n........return n\n\n(Scheme, with memoization-macro definec)\n(definec (A241816 n) (cond ((zero? n) n) ((odd? n) (+ 1 (* 2 (A241816 (/ (- n 1) 2))))) ((zero? (modulo n 4)) (* 2 (A241816 (/ n 2)))) (else (- n 1))))\n;; _Antti Karttunen_, Feb 21 2015\n"}
{"sequence_id": "A241886", "text": "a(n) = smallest prime p such that there is a gap of n*(n+1) between p and the next prime.", "sequence": "3,23,199,887,4297,16141,82073,31397,404851,1468277,1357201,17983717,36271601,20831323,391995431,1851255191,3917587237,12010745569,23323808741,82490815123,400729567081,1339347750707,2210401546601,4872634110067,5120731250207", "code": "\nimport sympy\nn=1\nwhile n>=0:\n....p=2\n....while  sympy.nextprime(p)-p!=(n*(n+1))\n........p=sympy.nextprime(p)\n....print(p)\n....n=n+1\n....p=sympy.nextprime(p)\n"}
{"sequence_id": "A241917", "text": "If n is a prime with index i, p_i, a(n) = i, (with a(1)=0), otherwise difference (i-j) of the indices of the two largest primes p_i, p_j, i >= j in the prime factorization of n: a(n) = A061395(n) - A061395(A052126(n)).", "sequence": "0,1,2,0,3,1,4,0,0,2,5,1,6,3,1,0,7,0,8,2,2,4,9,1,0,5,0,3,10,1,11,0,3,6,1,0,12,7,4,2,13,2,14,4,1,8,15,1,0,0,5,5,16,0,2,3,6,9,17,1,18,10,2,0,3,3,19,6,7,1,20,0,21,11,0,7,1,4,22,2,0,12,23", "code": "\nfrom sympy import primefactors, primepi\ndef a061395(n): return 0 if n==1 else primepi(primefactors(n)[-1])\ndef a052126(n): return 1 if n==1 else n/primefactors(n)[-1]\ndef a(n): return 0 if n==1 else a061395(n) - a061395(a052126(n)) \n"}
{"sequence_id": "A241919", "text": "If n is a prime power, p_i^e, a(n) = i, (with a(1)=0), otherwise difference (i-j) of the indices of the two largest distinct primes p_i, p_j, i > j in the prime factorization of n: a(n) = A061395(n) - A061395(A051119(n)).", "sequence": "0,1,2,1,3,1,4,1,2,2,5,1,6,3,1,1,7,1,8,2,2,4,9,1,3,5,2,3,10,1,11,1,3,6,1,1,12,7,4,2,13,2,14,4,1,8,15,1,4,2,5,5,16,1,2,3,6,9,17,1,18,10,2,1,3,3,19,6,7,1,20,1,21,11,1,7,1,4,22,2,2,12,23", "code": "\nfrom sympy import factorint, primefactors, primepi\ndef a061395(n): return 0 if n==1 else primepi(primefactors(n)[-1])\ndef a053585(n):\n    if n==1: return 1\n    p = primefactors(n)[-1]\n    return p**factorint(n)[p]\ndef a051119(n): return n/a053585(n)\ndef a(n): return a061395(n) - a061395(a051119(n)) \n"}
{"sequence_id": "A241989", "text": "Positive numbers n that are divisible by the sum of the digits of n in base 16.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,18,20,30,32,33,35,36,40,45,48,50,54,60,64,65,66,70,72,75,80,90,96,99,100,105,108,112,120,126,128,130,132,135,140,144,150,160,165,175,176,180,192,195,198,200", "code": "\nfrom gmpy2 import digits\nA241989 = [n for n in range(1,10**3) if not n % sum([int(d,16) for d in digits(n,16)])]\n(MIT/GNU Scheme, with _Antti Karttunen_'s IntSeq-library)\n(define A241989 (MATCHING-POS 1 1 (lambda (n) (zero? (modulo n (A053836 n))))))\n(define (A053836 n) (let loop ((n n) (i 0)) (if (zero? n) i (loop (floor->exact (/ n 16)) (+ i (modulo n 16))))))\n"}
{"sequence_id": "A241991", "text": "Decimal expansion of the infinite product for n >= 1 of (1+1/n^2)^(n^2)/e.", "sequence": "5,4,5,7,8,1,8,3,8,8,3,3,9,8,7,0,8,2,5,2,3,4,9,0,3,9,7,2,5,5,6,5,8,7,7,4,0,3,3,6,8,7,9,1,3,2,9,8,0,4,3,9,3,2,7,6,7,5,9,5,2,6,2,3,5,0,6,1,8,4,4,6,8,7,4,1,0,8,4,0,5,2,5,1,2,7,0,3,1,0,6,0,2,6,1,0,0,3,0,6,6,0,0", "code": "\nfrom mpmath import *\nmp.dps=104\nC = exp(1/2 + 2*pi/3 - zeta(3)/(2*pi**2) + polylog(3, exp(-2*pi))/(2*pi**2) + polylog(2, exp(-2*pi))/pi)/2/sinh(pi)\nprint([int(n) for n in list(str(C)[2:-1])]) \n"}
{"sequence_id": "A242018", "text": "Starting with a(0) = 0, a(1) = 0, a(2) = 1, repeatedly append to this sequence the last half of the currently-existing terms, taking the longer half if there are an odd number of terms.", "sequence": "0,0,1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,1,0,1,1,0,1", "code": "\nA242018 = [0,0,1]\nfor n in range(1,20):\n....A242018 += A242018[int(len(A242018)/2):] \n"}
{"sequence_id": "A242028", "text": "Numbers k such that the least common multiple of the anti-divisors of k is less than k.", "sequence": "3,4,6,9,36,54,96,216,576,1296,69984,236196,393216,497664,28697814,31850496", "code": "\nfrom sympy import divisors, lcm\nA242028 = [n for n in range(3,10**5) if lcm(\n..........[2*d for d in divisors(n) if n > 2*d and n % (2*d)] +\n..........[d for d in divisors(2*n-1) if n > d >=2 and n % d] +\n..........[d for d in divisors(2*n+1) if n > d >=2 and n % d]) < n]\n\n"}
{"sequence_id": "A242038", "text": "Integer part of square root of A010809(n) = n^21.", "sequence": "0,1,1448,102275,2097152,21836601,148111277,747359260,3037000499,10460353203,31622776601,86024705429,214488041413,497055861119,1082291816449,2233357359474,4398046511104,8312155792152,15148209527700,26724698233906", "code": "\nfrom decimal import *\ngetcontext().prec = 100\nfor n in range(0,1001): print int(Decimal(n**21).sqrt())\n"}
{"sequence_id": "A242067", "text": "Number of triangular numbers between n^2 and n^3 (excluding the bounds).", "sequence": "0,0,1,3,5,9,12,16,21,25,31,36,42,48,54,61,68,75,83,90,98,106,115,123,132,142,150,160,170,180,190,200,211,221,232,243,254,266,277,289,301,313,326,338,351,363,376,390,402,416,429,443,456,471,485,499,514,528,543,558", "code": "\nfor n in range(60):\n  sq=n*n\n  cb=n**3\n  s = t = 0\n  while 1:\n    tn = t*(t+1)/2\n    if tn>sq and tn<cb:  s+=1\n    elif tn>=cb:  break\n    t+=1\n  print str(s)+',',\n"}
{"sequence_id": "A242092", "text": "Numbers n such that n and the digital reversal of the n-th prime in base 10 have the same distinct prime factors.", "sequence": "86,1357,24146,1028736826,33667786628,2132089369082", "code": "\nfrom sympy import primefactors, prime\nA242092 = [n for n in range(1,10**7) if primefactors(n) == primefactors(int(str(prime(n))[::-1]))]\n"}
{"sequence_id": "A242098", "text": "Numbers n such that the residue of n modulo floor(sqrt(n)) is prime.", "sequence": "11,14,18,19,22,23,27,28,32,33,38,39,41,44,45,47,51,52,54,58,59,61,66,67,69,71,74,75,77,79,83,84,86,88,92,93,95,97,102,103,105,107,112,113,115,117,123,124,126,128,134,135,137,139,146,147,149", "code": "\nfrom sympy import isprime\nfrom math import sqrt, floor\nfrom itertools import count\nsequence=(_ in count(1) if isprime(_ % floor(sqrt(_))))\n[next(sequence) for i in range(50)]\n"}
{"sequence_id": "A242107", "text": "Reduced division polynomials associated with elliptic curve y^2 + x*y = x^3 - x^2 - x + 1 and multiples of point (0, 1).", "sequence": "0,1,1,1,1,-1,2,-3,1,-5,-7,-13,-16,11,-57,131,-113,389,670,2311,3983,9,23647,-81511,140576,-484247,-833503,-5751815,-14871471,-17124617,-147165662,710017141,-2273917871,9644648819,11396432249,204006839259,808162720720", "code": "\nfrom gmpy2 import divexact\nA242107 = [0,1,1,1,1,-1]\nfor n in range(6,321):\n....A242107.append(divexact(-A242107[n-1]*A242107[n-4]+A242107[n-2]*A242107[n-3],A242107[n-5])) \n"}
{"sequence_id": "A242108", "text": "a(n) = abs(A242107(n)).", "sequence": "0,1,1,1,1,1,2,3,1,5,7,13,16,11,57,131,113,389,670,2311,3983,9,23647,81511,140576,484247,833503,5751815,14871471,17124617,147165662,710017141,2273917871,9644648819,11396432249,204006839259,808162720720,2405317965859", "code": "\nfrom gmpy2 import divexact\nA242107 = [0,1,1,1,1,-1]\nfor n in range(6,321):\n....A242107.append(divexact(-A242107[n-1]*A242107[n-4]+\n........A242107[n-2]*A242107[n-3],A242107[n-5]))\nA242108 = [int(abs(x)) for x in A242107] \n"}
{"sequence_id": "A242118", "text": "Number of unit squares that intersect the circumference of a circle of radius n centered at (0,0).", "sequence": "0,4,12,20,28,28,44,52,60,68,68,84,92,92,108,108,124,124,140,148,148,164,172,180,188,180,196,212,220,220,228,244,252,260,260,268,284,284,300,300,308,316,332,340,348,348,364,372,380,388,380", "code": "\na = lambda n: sum(4 for x in range(n) for y in range(n)\n                    if x**2 + y**2 < n**2 and (x+1)**2 + (y+1)**2 > n**2)\n"}
{"sequence_id": "A242118", "text": "Number of unit squares that intersect the circumference of a circle of radius n centered at (0,0).", "sequence": "0,4,12,20,28,28,44,52,60,68,68,84,92,92,108,108,124,124,140,148,148,164,172,180,188,180,196,212,220,220,228,244,252,260,260,268,284,284,300,300,308,316,332,340,348,348,364,372,380,388,380", "code": "\nfrom sympy import factorint\ndef a(n):\n    r = 1\n    for p, e in factorint(n).items():\n        if p%4 == 1: r *= 2*e + 1\n    return 8*n - 4*r if n > 0 else 0\n"}
{"sequence_id": "A242137", "text": "Numbers n such that there are no triangular numbers strictly between n^2 and n^2 + n.", "sequence": "0,1,2,4,6,9,11,14,16,21,23,26,28,33,35,38,40,45,50,52,55,57,62,64,67,69,74,79,81,84,86,91,93,96,98,103,108,110,115,120,122,125,127,132,134,137,139,144,149,151,154,156,161,163,166,168,173,178,180,185,190", "code": "\nt = prev = 0\nfor n in range(1000000):\n  sq = n*n\n  ob = sq + n\n  s = 0\n  while 1:\n    tn = t*(t+1)/2\n    if tn > sq:\n        if tn < ob:\n            s = 1\n        break\n    t+=1\n  t-=1\n  if s==0:\n    print str(n)+',',\n    \n    \n    \n"}
{"sequence_id": "A242171", "text": "Least prime divisor of B(n) which does not divide any B(k) with k < n, or 1 if such a primitive prime divisor of B(n) does not exist, where B(n) is the n-th Bell number given by A000110.", "sequence": "1,2,5,3,13,7,877,23,19,4639,22619,37,27644437,1800937,251,241,255755771,19463,271,61,24709,17,89,123419,367,101,157,67,75979,107,11,179167,5694673,111509,980424262253,193,44101,5399,6353,3221", "code": "\n\nfrom itertools import accumulate\nfrom sympy import primefactors\nA242171_list, bell, blist, b = [1], [1,1], [1], 1\nfor _ in range(20):\n....blist = list(accumulate([b]+blist))\n....b = blist[-1]\n....fs = primefactors(b)\n....for p in fs:\n........if all([n % p for n in bell]):\n............A242171_list.append(p)\n............break\n....else:\n........A242171_list.append(1)\n....bell.append(b) \n"}
{"sequence_id": "A242214", "text": "Numbers n not divisible by 10 such that n^3 contains at least one 0.", "sequence": "16,22,34,37,42,43,47,48,52,59,63,67,69,73,74,79,84,86,87,89,93,94,99,101,102,103,106,107,109,112,115,116,117,118,123,124,126,127,128,131,134,135,138,141,143,145,149,152,159,163,164,169,171,172,174,182,184", "code": "\n{print(n) for n in range(10**3) if n%10 != 0 and str(n**3).find(\"0\") > 0}\n"}
{"sequence_id": "A242268", "text": "Squares not ending in 00 that remain squares if prefixed with the digit 1.", "sequence": "225,5625,5405625,23765625,2127515625,58503515625,51921031640625,250727431640625,20090404775390625,608180644775390625,498431438615478515625,2642208974615478515625,189450791534674072265625,6319494849134674072265625,9981411957966851806640625", "code": "\nimport math\ndef power(a,n):\n...pow = 1\n...for i in range(0, n):\n......pow = pow * a\n...return pow\nend = 50\nfor n in range(1, end):\n...l1 = 1/math.log(5)*(math.log(math.sqrt(2)-1)+(n-2)/2*math.log(2))+ n/2\n...u1 = 1/math.log(5)*(math.log(math.sqrt(11)-1)+(n-3)/2*math.log(2))+ (n-1)/2\n...if math.ceil(l1) == math.floor(u1) and math.ceil(l1)>0:\n......p = math.ceil(l1)\n......x = power(5,p)*(-1)+power(2,n-2)*power(5,n-p)\n......print(x*x)\n...l2 = 1/math.log(5)*(math.log(math.sqrt(11)+1)+(n-3)/2*math.log(2))+ (n-1)/2\n...u2 = 1/math.log(5)*(math.log(math.sqrt(2)+1)+(n-2)/2*math.log(2))+ n/2\n...if math.ceil(l2) == math.floor(u2) and math.ceil(l2)>0:\n......p = math.ceil(l2)\n......x = power(5,p)-power(2,n-2)*power(5,n-p)\n......print(x*x)\nprint('End.')\n"}
{"sequence_id": "A242281", "text": "Smaller member of a Sophie Germain pair in which each member of the pair is the smaller of its prime pair (p, (p*p*p)+2).", "sequence": "419,761,911,1601,2351,6269,6551,9029,22259,28559,28949,37139,52571,56531,67559,70379,78509,108359,114641,133571,135119,138179,146669,153449,176021,187409,193841,200639,252761,288731,303581,312551,333479,337349,407639,408389", "code": "\np1=2\nn=2\ncount=0\nwhile p1>2:\n....\n....cc=[]\n....cc.append(p1)\n....for i in range(1, n):\n........cc.append((2**(i)*p1+((2**i)-1)))\n....\n....cc2=[(c*c*c)+2 for c in cc]\n....\n....\n....\n....\n....pcc=pf.isp_list(cc)\n....pcc2=pf.isp_list(cc2)\n....\n....npcc=pcc.count(True)\n....\n....npcc2=pcc2.count(True)\n....if npcc==n and npcc2==n:\n........print \"For length \", n, \" the series is : \", cc, \" and \", cc2\n....p1=pf.nextp(p1)\n"}
{"sequence_id": "A242326", "text": "Primes p for which p + 2, p^3 + 2 and p^5 + 2 are prime.", "sequence": "419,2339,14081,45821,46349,51419,56039,68489,70379,108191,112601,115319,131891,132749,256391,267611,278879,314159,328511,342449,361001,385139,424841,433259,470651,489689,519371,573761,664691,691181,694271", "code": "\nn=2\nco=1\nwhile n>1:\n....n1=n+2\n....n2=((n*n*n)+2)\n....n3=((n*n*n*n*n)+2)\n....\n....if pf.isp(n1)== True and pf.isp(n2)== True and pf.isp(n3)== True:\n........print(n, \" , \" ,n1,\" , \",n2,\" , \",n3)\n....n=pf.nextp(n)\n"}
{"sequence_id": "A242327", "text": "Primes p for which (p^n) + 2 is prime for n = 1, 3, 5, and 7.", "sequence": "132749,1175411,3940799,5278571,11047709,12390251,15118769,21967241,22234871,26568929,31809959,32229341,32969591,35760551,38704661,43124831,43991081,49248971,50227211,51140861,53221631,55568171,59446109,63671651,71109161,76675589", "code": "\nimport sympy\nfrom sympy.ntheory import isprime, nextprime\nn=2\nwhile True:\n    n1=n+2\n    n2=n**3+2\n    n3=n**5+2\n    n4=n**7+2\n    \n    if all(isprime(x) for x in [n1, n2, n3, n4]):\n        print(n, \", \", n1, \", \", n2, \", \", n3, \", \", n4)\n    n=nextprime(n)\n"}
{"sequence_id": "A242334", "text": "Primes with property that when their binary representation is reversed we obtain a Fibonacci number.", "sequence": "2,3,5,11,59,151,317,5441,18427,9033691613,12756420479903,1211140566276649,401010813707734082716979,74347828543021309956757002467819,16538021251556158042076145869636347596983087", "code": "\nimport math\ndef is_prime(n):\n....if n % 2 == 0 and n > 2:\n........return False\n....return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))\ndef dec_to_bin(x):\n....return (bin(x)[2:])\nfib = [1,1]\nfor i in range(100):\n....fib.append(fib[-1] + fib[-2])\nfor a in fib[3:]:\n....b = dec_to_bin(a)\n....c = b[::-1]\n....d = int(c,2)\n....if is_prime(d) and c[0] != '0':\n........print(d,c,b,a)\n\n"}
{"sequence_id": "A242346", "text": "Smaller member of a Sophie Germain pair in which each member of the pair is the smallest of its prime triple (p, (p^3)+2, (p^5)+2).", "sequence": "8629739,77115359,173508869,343621919,419597309,573556349,763154039,770676239,847344419,851521949,951418229,1014432869,1252780829,1260053939,1322933519,1529921909,1569236309,1861760819,1954231199,2048205689,2071334939,2583377789,2658083819", "code": "\np1=2\nn=2\ncount=0\nwhile p1>2:\n....\n....cc=[]\n....cc.append(p1)\n....for i in range(1, n):\n........cc.append((2**(i)*p1+((2**i)-1)))\n....\n....cc2=[(c*c*c)+2 for c in cc]\n....\n....cc3=[(c**5)+2 for c in cc]\n....\n....\n....\n....\n....pcc=pf.isp_list(cc)\n....pcc2=pf.isp_list(cc2)\n....pcc3=pf.isp_list(cc3)\n....\n....npcc=pcc.count(True)\n....npcc2=pcc2.count(True)\n....npcc3=pcc3.count(True)\n....if npcc==n and npcc2==n and npcc3==n:\n........print \"For length \", n, \" the series is : \", cc, \",\", cc2 ,\" and \", cc3\n....p1=pf.nextp(p1)\n"}
{"sequence_id": "A242347", "text": "Number of decimal digits of A008559.", "sequence": "1,2,4,10,31,100,330,1093,3628,12049,40023,132951,441651,1467130,4873698,16190071,53782249,178660761,593498199,1971558339", "code": "\nA242347_list, l = [1], 2\nfor _ in range(10):\n....l = int(bin(l)[2:])\n....A242347_list.append(len(str(l))) \n"}
{"sequence_id": "A242411", "text": "If n is a prime power, p_i^e, a(n) = 0, otherwise difference (i-j) of the indices of the two largest distinct primes p_i, p_j, i > j in the prime factorization of n: a(n) = A061395(n) - A061395(A051119(n)).", "sequence": "0,0,0,0,0,1,0,0,0,2,0,1,0,3,1,0,0,1,0,2,2,4,0,1,0,5,0,3,0,1,0,0,3,6,1,1,0,7,4,2,0,2,0,4,1,8,0,1,0,2,5,5,0,1,2,3,6,9,0,1,0,10,2,0,3,3,0,6,7,1,0,1,0,11,1,7,1,4,0,2,0,12,0,2,4,13,8,4,0", "code": "\nfrom sympy import factorint, primefactors, primepi\ndef a061395(n): return 0 if n==1 else primepi(primefactors(n)[-1])\ndef a053585(n):\n    if n==1: return 1\n    p = primefactors(n)[-1]\n    return p**factorint(n)[p]\ndef a051119(n): return n/a053585(n)\ndef a(n): return 0 if n==1 or len(primefactors(n))==1 else a061395(n) - a061395(a051119(n)) \n"}
{"sequence_id": "A242426", "text": "floor(n! / n^3).", "sequence": "1,0,0,0,0,3,14,78,497,3628,29990,277200,2834328,31770514,387459072,5108103000,72397196844,1097800704000,17735107218083,304112751022080,5516784599040000,105559797875432727,2124765080865042873,44881973505008640000,992717442773183102976", "code": "\nimport math\nfor i in range(1,32): print str(math.factorial(i)/(i**3))+',',\n"}
{"sequence_id": "A242427", "text": "n! mod n^3.", "sequence": "0,2,6,24,120,72,238,384,567,800,110,0,2184,784,0,0,1428,0,703,0,0,2904,4209,0,0,13520,0,0,15109,0,18228,0,0,30056,0,0,9546,14440,0,0,26855,0,23994,0,0,25392,13207,0,0,0,0,0,95453,0,0,0,0,148016,93928,0,208315", "code": "\nimport math\nfor i in range(1,77): print str(math.factorial(i) % (i**3))+',',\n"}
{"sequence_id": "A242437", "text": "Numbers not appearing in the sequence of integers, beginning with 1, that can be formed by adding any digit of any previous term to that previous term.", "sequence": "3,5,6,7,9,10,11,12,13,14,15,21,23,25,27,29,31,43,47,51,65,71,87,95", "code": "\ncomplete = []\ncomplete.append(1)\ncomplete.append(2)\ncomplete.append(4)\ncomplete.append(8)\nfinal = []\nfor a in range(2,10000000):\n....b = str(a)\n....for c in reversed(range(1,10)):\n........d = str(a-c)\n........if a - c in complete[-9:] and str(c) in d:\n............complete.append(a)\n............break\n........if c == 1:\n............final.append(a)\nprint(final)\n"}
{"sequence_id": "A242473", "text": "Binomial(2p-1,p-1) modulo p^4, with p=prime(n).", "sequence": "3,10,126,1716,1332,2198,14740,61732,158172,268280,29792,557184,2343315,2623732,3218514,5657327,11911983,12710937,7218313,12526886,24119055,18735483,13151102,19034164,87616609", "code": "\nfrom __future__ import division\nfrom sympy import isprime\nA242473_list, b = [], 1\nfor n in range(1,10**4):\n    if isprime(n):\n        A242473_list.append(b % n**4)\n    b = b*2*(2*n+1)//(n+1) \n"}
{"sequence_id": "A242517", "text": "List of primes p for which p^n - 2 is prime for n = 1, 3, and 5.", "sequence": "31,619,2791,4801,15331,33829,40129,63421,69151,98731,127291,142789,143569,149971,151849,176599,184969,201829,210601,225289,231841,243589,250951,271279,273271,277549,280591,392269,405439,441799,472711,510709,530599,568441,578689", "code": "\nimport sympy\nn=2\nwhile n>1:\n....n1=n-2\n....n2=((n**3)-2)\n....n3=((n**5)-2)\n....\n....if sympy.ntheory.isprime(n1)== True and sympy.ntheory.isprime(n2)== True and sympy.ntheory.isprime(n3)== True:\n........print(n, \" , \" , n1, \" , \", n2, \" , \", n3)\n....n=sympy.ntheory.nextprime(n)\n"}
{"sequence_id": "A242518", "text": "Primes p for which p^n - 2 is prime for n = 1, 3, 5 and 7.", "sequence": "201829,2739721,6108679,7883329,9260131,9309721,9917389,14488249,15386491,15876481,16685299,16967191,18145279,20566969,20869129,21150991,23194909,25510189,28406929,34669909,35039311,36795169,37912141,39083521,39805639", "code": "\nimport sympy\nn=2\nwhile n>1:\n....n1=n-2\n....n2=((n**3)-2)\n....n3=((n**5)-2)\n....n4=((n**7)-2)\n....\n....if sympy.ntheory.isprime(n1)== True and sympy.ntheory.isprime(n2)== True and sympy.ntheory.isprime(n3)== True and sympy.ntheory.isprime(n4)== True:\n........print(n, \" , \" , n1, \" , \", n2, \" , \", n3, \" , \", n4)\n....n=sympy.ntheory.nextprime(n)\n"}
{"sequence_id": "A242552", "text": "Least number k such that n^4+k^4 is prime.", "sequence": "1,1,2,1,2,1,2,3,2,7,2,13,4,5,8,1,2,5,2,1,10,15,2,1,6,3,2,1,12,7,12,5,14,1,6,7,2,3,14,9,2,5,10,21,2,1,4,1,2,7,2,11,6,1,14,1,2,7,2,11,2,11,8,23,16,29,12,3,10,27,2,5,8,1,8,3,20,17,2,1,10,1,10", "code": "\nimport sympy\nfrom sympy import isprime\ndef a(n):\n..for k in range(10**4):\n....if isprime(n**4+k**4):\n......return k\nn = 1\nwhile n < 100:\n..print(a(n))\n..n += 1\n"}
{"sequence_id": "A242553", "text": "Least number k such that n^8+k^8 is prime.", "sequence": "1,1,10,1,6,5,12,13,16,3,24,7,2,3,8,9,4,17,4,7,2,3,20,7,8,19,10,3,10,19,14,17,32,11,8,25,6,25,40,7,10,43,16,5,68,7,30,5,8,19,58,17,26,17,2,11,10,3,4,49,6,71,22,15,14,47,30,9,2,19,6,19,6,5,28,13,2", "code": "\nimport sympy\nfrom sympy import isprime\ndef a(n):\n..for k in range(10**4):\n....if isprime(n**8+k**8):\n......return k\nn = 1\nwhile n < 100:\n..print(a(n))\n..n += 1\n"}
{"sequence_id": "A242554", "text": "Least number k such that n^16+k^16 is prime.", "sequence": "1,1,4,3,6,5,6,7,22,13,16,5,8,5,14,11,10,7,16,31,8,9,10,11,38,29,10,9,22,61,20,5,4,3,16,11,6,25,28,7,6,17,16,1,46,9,58,61,22,41,92,3,14,19,14,23,56,37,20,109,6,121,10,39,4,67,34,11,26,9,30,11,12,1", "code": "\nimport sympy\nfrom sympy import isprime\ndef a(n):\n..for k in range(10**4):\n....if isprime(n**16+k**16):\n......return k\nn = 1\nwhile n < 100:\n..print(a(n))\n..n += 1\n"}
{"sequence_id": "A242555", "text": "Least number k such that k^32+n^32 is prime.", "sequence": "1,29,40,33,34,131,50,9,8,11,10,13,12,97,166,221,200,13,10,61,176,23,22,65,94,151,352,87,2,1,38,39,4,5,48,137,18,11,4,3,60,55,40,9,106,33,10,29,134,7,44,33,50,1,38,5,148,37,2,41,10,11,94,75,4,5,100,5,22", "code": "\nimport sympy\nfrom sympy import isprime\ndef a(n):\n..for k in range(10**4):\n....if isprime(n**32+k**32):\n......return k\nn = 1\nwhile n < 100:\n..print(a(n))\n..n += 1\n"}
{"sequence_id": "A242556", "text": "Least number k such that k^64+n^64 is prime.", "sequence": "1,37,32,39,118,13,16,11,154,41,8,29,6,17,64,7,14,107,66,63,58,87,38,397,282,69,32,129,12,67,210,3,200,227,82,55,2,7,4,541,10,103,64,167,286,71,60,593,6,459,14,3,2,91,4,81,98,21,164,47,36,51,10,15,84,19,30", "code": "\nimport sympy\nfrom sympy import isprime\ndef a(n):\n..for k in range(10**4):\n....if isprime(n**64+k**64):\n......return k\nn = 1\nwhile n < 100:\n..print(a(n))\n..n += 1\n"}
{"sequence_id": "A242557", "text": "Least number k such that n^128+k^128 is prime.", "sequence": "1,113,106,259,304,85,212,135,158,47,62,985,84,47,518,485,178,169,106,27,88,139,632,47,44,643,20,209,606,1529,32,31,1094,139,754,647,38,37,262,69,94,631,90,25,38,195,10,277,232,187,554,189,10,47,216,131,1132,173,390", "code": "\nimport sympy\nfrom sympy import isprime\ndef a(n):\n    for k in range(10**4):\n        if isprime(n**128+k**128):\n            return k\nn = 1\nwhile n < 100:\n    print(a(n))\n    n += 1\n"}
{"sequence_id": "A242559", "text": "Zeroless numbers n such that n^3 contains a 0.", "sequence": "16,22,34,37,42,43,47,48,52,59,63,67,69,73,74,79,84,86,87,89,93,94,99,112,115,116,117,118,123,124,126,127,128,131,134,135,138,141,143,145,149,152,159,163,164,169,171,172,174,182,184,187,192,193,194,199,214,216", "code": "\n{print(n) for n in range(10**3) if str(n).count(\"0\")==0 and str(n**3).count(\"0\")>0}\n"}
{"sequence_id": "A242562", "text": "Primes p such that 1000p+1, 1000p+3, 1000p+7 and 1000p+9 are prime.", "sequence": "13,1447,5527,28201,36217,75079,81157,95911,187423,188677,202327,210643,248077,263323,282589,283267,423043,466897,472597,478189,478603,631273,640261,695749,730111,736279,806929,808021,917641,964303,1018177,1026547,1064263,1108489,1150861", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import prime\n{print(prime(n)) for n in range(1,10**5) if isprime(1000*prime(n)+1) and isprime(1000*prime(n)+3) and isprime(1000*prime(n)+7) and isprime(1000*prime(n)+9)}\n"}
{"sequence_id": "A242564", "text": "Least prime p such that p*10^n+1, p*10^n+3, p*10^n+7 and p*10^n+9 are all prime.", "sequence": "19,1657,13,9001,283,115201,61507,249439,375127,472831,786823,172489,1237,2359033,163063,961981,1442017,457,1208833,4845583,1146877,11550193,436831,1911031,581047,4504351,215737,3685051,27805381,1343791,82491967,15696349,20446423", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import prime\ndef Pr(n):\n..for p in range(1,10**7):\n....if isprime(prime(p)*(10**n)+1) and isprime(prime(p)*(10**n)+3) and isprime(prime(p)*(10**n)+7) and isprime(prime(p)*(10**n)+9):\n......return prime(p)\nn = 1\nwhile n < 50:\n..print(Pr(n))\n..n += 1\n"}
{"sequence_id": "A242569", "text": "n!-2n.", "sequence": "-1,-2,0,16,110,708,5026,40304,362862,3628780,39916778,479001576,6227020774,87178291172,1307674367970,20922789887968,355687428095966,6402373705727964,121645100408831962,2432902008176639960,51090942171709439958,1124000727777607679956,25852016738884976639954,620448401733239439359952", "code": "\nimport math\n{print(math.factorial(n)-2*n) for n in range(1,25)}\n"}
{"sequence_id": "A242603", "text": "Largest divisor of n not divisible by 7. Remove factors 7 from n.", "sequence": "1,2,3,4,5,6,1,8,9,10,11,12,13,2,15,16,17,18,19,20,3,22,23,24,25,26,27,4,29,30,31,32,33,34,5,36,37,38,39,40,41,6,43,44,45,46,47,48,1,50,51,52,53,54,55,8,57,58,59,60,61,62,9,64,65,66,67,68,69,10,71,72,73,74,75,76,11", "code": "\ndef A242603(n):\n....for i in range(n,0,-1):\n........if n%i==0 and i%7!=0:\n............return i \n"}
{"sequence_id": "A242788", "text": "Numbers n such that (n^n-3)/(n-3) is an integer.", "sequence": "1,2,4,5,6,7,9,11,13,15,16,27,31,33,36,55,73,91,133,241,249,366,367,491,513,577,733,757,871,913,971,991,1233,1333,1576,1711,1927,2071,2346,2593,2731,3307,3391,3529,4005,4591,5113,5371,5409,5671,5793,6567,6801,7465,7591", "code": "\nA242788_list = [1,2,4,5,6] + [n for n in range(7,10**6) if pow(n, n, n-3) == 3]\n\n"}
{"sequence_id": "A242800", "text": "Numbers n such that (n^n+3)/(n+3) is an integer.", "sequence": "1,3,4,5,9,13,17,21,25,37,41,45,49,57,65,73,77,89,109,113,117,121,145,151,161,169,185,205,209,233,237,241,261,265,277,281,289,313,329,337,353,361,385,401,409,425,433,449,481,489,505,517,521,545,553,586,593", "code": "\nA242800_list = [n for n in range(10**6) if pow(n, n, n+3) == n] \n"}
{"sequence_id": "A242877", "text": "Number of points of norm <= n in square lattice which can be built as entire powers of points of the square lattice seen as image of the complex plane C* (excluding (0,0)).", "sequence": "4,6,10,12,16,20,20,24,26,30,30,42,42,46,46,48,52,52,54,58,58,58,62,62,68,70,76,76,78,80,80,92,92,96,96,98,98,102,102,106,110,110,110,110", "code": "\nfrom math import *\ni0=complex(1,0)\ni1=complex(0,1)\nf0={0,i0,i1,-i0,-i1}\ndef A242877(n):\n....if n==0: return 0\n....if n==1: return 4\n....f0={0,i0,i1,-i0,-i1}\n....k=2\n....while True:\n........ro=n**(1/k)\n........if ro<sqrt(1.9999):break\n........ro_int = int(ro)\n........for a in range(-ro_int,ro_int+1):\n............b_max = int(sqrt(ro*ro-a*a))\n............for b in range(-b_max,b_max+1):\n................c=complex(a,b)\n................f0.add(c**k)\n........k+=1\n....return len(f0)-1\n"}
{"sequence_id": "A242886", "text": "Smallest prime p_n which generates n primes of the form (p^i + 2) where i represents the first n odd numbers.", "sequence": "3,3,419,132749,514664471,1164166301,364231372931", "code": "\nimport sympy\n\n\ndef isp_list(ls):\n....pt=[]\n....for a in ls:\n........if sympy.ntheory.isprime(a)==True:\n............pt.append(True)\n....return(pt)\nco=1\nwhile co < 7:\n....al=0\n....n=2\n....while al!=co:\n........d=[]\n........for i in range(0,co):\n............d.append(int(n**((2*i)+1))+2)\n........al=isp_list(d).count(True)\n........if al==co:\n............\n............print(n,d)\n........n=sympy.ntheory.nextprime(n)\n....co=co+1\n"}
{"sequence_id": "A242930", "text": "Primes of the form (k^2+7)/11.", "sequence": "37,53,193,373,421,673,1061,2213,2753,3637,4481,5237,5413,7333,7541,8513,8737,9781,11393,12853,14401,15733,17761,19237,21121,25153,25537,27701,29537,34273,34721,39841,42533,47653,50593,51137", "code": "\nimport sympy\n[(k**2+7)/11 for k in range(10**6) if sympy.ntheory.isprime((k**2+7)/11) & ((k**2+7)/11).is_integer()]\n"}
{"sequence_id": "A242949", "text": "Number of distinct ternary squarefree words of length 2n that can be obtained as the self-shuffle of a ternary squarefree word of length n.", "sequence": "0,0,6,12,30,24,42,78,138,228,396,588,1008,1494,2634", "code": "\nfrom itertools import product, combinations\ndef issquarefree(s):\n    for l in range(1, len(s)//2 + 1):\n        for i in range(len(s)-2*l+1):\n            if s[i:i+l] == s[i+l:i+2*l]: return False\n    return True\ndef squarefree(n): \n    if n == 0: yield \"\"; return\n    if n == 1: yield \"0\"; return\n    squares = [\"\".join(u) + \"\".join(u)\n      for r in range(1, n//2 + 1) for u in product(\"012\", repeat = r)]\n    words = (\"0\"+\"\".join(w) for w in product(\"012\", repeat=n-1))\n    yield from [w for w in words if all(s not in w for s in squares)]\ndef a(n):\n    range2n, set2n = list(range(2*n)), set(range(2*n))\n    allset, ssw = set(), [0 for i in range(2*n)]\n    for w in squarefree(n):\n        if w.count(\"1\") > w.count(\"2\"): continue\n        for s in combinations(range2n, n):\n            nots = sorted(set2n-set(s))\n            for i, c in enumerate(w): ssw[s[i]] = ssw[nots[i]] = c\n            t = \"\".join(ssw)\n            if issquarefree(t): allset.add(t)\n    num2g1 = sum(w.count(\"1\") < w.count(\"2\") for w in allset)\n    return 3*(len(allset) + num2g1)\nprint([a(n) for n in range(1, 10)]) \n"}
{"sequence_id": "A242951", "text": "Number of ternary squarefree words x of length n for which some self-shuffle of x is also squarefree.", "sequence": "0,0,6,6,12,18,30,42,36,54,138,168,234,294,390,540", "code": "\nfrom itertools import product, combinations\ndef issquarefree(s):\n    for l in range(1, len(s)//2 + 1):\n        for i in range(len(s)-2*l+1):\n            if s[i:i+l] == s[i+l:i+2*l]: return False\n    return True\ndef squarefree(n): \n    if n == 0: yield \"\"; return\n    if n == 1: yield \"0\"; return\n    squares = [\"\".join(u) + \"\".join(u)\n      for r in range(1, n//2 + 1) for u in product(\"012\", repeat = r)]\n    words = (\"0\"+\"\".join(w) for w in product(\"012\", repeat=n-1))\n    yield from [w for w in words if all(s not in w for s in squares)]\ndef a(n):\n    range2n, set2n = list(range(2*n)), set(range(2*n))\n    allset, ssw = set(), [0 for i in range(2*n)]\n    for w in squarefree(n):\n        if w.count(\"1\") > w.count(\"2\"): continue\n        for s in combinations(range2n, n):\n            nots = sorted(set2n-set(s))\n            for i, c in enumerate(w): ssw[s[i]] = ssw[nots[i]] = c\n            t = \"\".join(ssw)\n            if issquarefree(t): allset.add(w); break\n    num2g1 = sum(w.count(\"1\") < w.count(\"2\") for w in allset)\n    return 3*(len(allset) + num2g1)\nprint([a(n) for n in range(1, 10)]) \n"}
{"sequence_id": "A242966", "text": "Composite numbers whose anti-divisors are all primes.", "sequence": "4,8,16,64,1024,4096,65536,262144,4194304,1073741824,1152921504606846976,1267650600228229401496703205376,85070591730234615865843651857942052864,93536104789177786765035829293842113257979682750464", "code": "\nfrom sympy import isprime, divisors\nA242966 = [n for n in range(3,10**5) if not isprime(n) and list(filter(lambda x: not isprime(x), [2*d for d in divisors(n) if n > 2*d and n % (2*d)] + [d for d in divisors(2*n-1) if n > d >=2 and n % d] + [d for d in divisors(2*n+1) if n > d >=2 and n % d])) == []]\n\n"}
{"sequence_id": "A242987", "text": "Numbers n such that concatenating 1 with two instances of n produces a prime.", "sequence": "9,17,23,47,59,63,81,87,107,117,131,137,143,153,167,173,179,189,191,197,201,209,213,221,231,239,261,263,281,297,299,311,317,323,339,369,377,381,399,401,411,413,417,453,473,477,479,491,501,503,509,519,533", "code": "\nfrom sympy import isprime\nfor n in range(1,10**3):\n    if isprime(int('1'+str(n)+str(n))):\n        print(n,end=', ')\n\n"}
{"sequence_id": "A242988", "text": "Numbers n such that concatenating 1 with three instances of n produces a prime.", "sequence": "7,9,21,39,53,57,61,63,67,69,139,149,161,163,173,187,189,201,207,219,233,247,259,269,273,279,291,293,299,301,347,363,413,447,451,453,467,473,481,511,531,537,539,549,583,609,623,629,633,637,649,663,691,697", "code": "\nfrom sympy import isprime\nfor n in range(10**3):\n..if isprime(int('1'+3*str(n))):\n....print(n,end=', ')\n\n"}
{"sequence_id": "A242989", "text": "Numbers n such that concatenating 1 with four instances of n produces a prime.", "sequence": "37,39,49,73,97,123,139,159,211,213,219,253,273,291,313,327,337,339,369,399,409,477,481,511,529,531,579,589,607,633,643,663,697,717,723,733,753,787,789,819,831,841,891,909,919,967,987,1041,1117,1131,1281,1377", "code": "\nfrom sympy import isprime\nfor n in range(10**3):\n..if isprime('1'+4*str(n)):\n....print(n,end=', ')\n\n"}
{"sequence_id": "A242990", "text": "Numbers n such that concatenating 1 with five instances of n produces a prime.", "sequence": "9,21,41,101,143,171,249,251,297,329,333,347,357,489,509,531,537,557,569,611,629,653,657,669,731,773,821,843,861,941,957,983,993,1133,1143,1209,1229,1239,1313,1361,1409,1427,1451,1497,1539,1647,1673,1791,1833", "code": "\nfrom sympy import isprime\nfor n in range(2*10**3):\n..if isprime(int('1'+5*str(n))):\n....print(n,end=', ')\n\n"}
{"sequence_id": "A243071", "text": "Permutation of nonnegative integers: a(1) = 0, a(2) = 1, a(2n) = 2*a(n), a(2n+1) = 1 + 2*a(A064989(2n+1)).", "sequence": "0,1,3,2,7,6,15,4,5,14,31,12,63,30,13,8,127,10,255,28,29,62,511,24,11,126,9,60,1023,26,2047,16,61,254,27,20,4095,510,125,56,8191,58,16383,124,25,1022,32767,48,23,22,253,252,65535,18,59,120,509,2046,131071", "code": "\nfrom functools import reduce\nfrom sympy import factorint, prevprime\nfrom operator import mul\ndef a064989(n):\n    f = factorint(n)\n    return 1 if n==1 else reduce(mul, (1 if i==2 else prevprime(i)**f[i] for i in f))\ndef a(n): return n - 1 if n<3 else 2*a(n//2) if n%2==0 else 1 + 2*a(a064989(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A243076", "text": "Let f(p,i) = smallest m > p such that m == i mod p; a(n) = Sum_{i=0..p-1) f(p,i), where p = n-th prime.", "sequence": "5,15,55,119,341,533,901,1387,1909,3103,4061,5365,6601,7783,9635,12455,16343,17507,20033,24069,27083,29941,33283,42453,47433,53631,54693,60241,66163,69721,86741,92879,104805,102443,126203,130011,136119,143603,157147", "code": "\nfrom sympy import prime, isprime\ndef a(n):\n    if n==1: return 5\n    p=prime(n)\n    i=0\n    s=0\n    while i<p:\n        q=(2 if i%2 else 1)*p + i\n        while not isprime(q): q+=2*p\n        s+=q\n        i+=1\n    return s\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A243093", "text": "Least number k > n such that n concatenated with k is a perfect power.", "sequence": "6,5,6,9,12,25,29,41,61,24,56,25,31,44,21,81,28,49,36,25,87,201,104,336,281,244,44,224,241,276,36,49,64,81,344,100,249,44,69,96,209,436,56,89,369,225,61,400,284,176,84,441,361,76,225,169,76,564,319,84,504,500,504,516,536,564", "code": "\nfrom sympy import perfect_power\ndef a(n):\n    s, k = str(n), n+1\n    while not perfect_power(int(s+str(k))): k += 1\n    return k\nprint([a(n) for n in range(1, 67)]) \n"}
{"sequence_id": "A243097", "text": "Digit sums of the nontrivial reversal numbers (numbers which are integer multiples of their reversal), excluding palindromes and multiples of 10.", "sequence": "18,18,27,27,36,36,45,45,36,54,36,54,36,63,36,63,36,54,72,36,54,72,36,54,81,36,54,81,36,54,54,72,90,36,54,54,72,90,36,63,54,72,99,36,63,54,72,99,36,54,72,54,72,72,90,108,36,54,72,54,72,72,90,108", "code": "\nA243097 = []\nfor n in range(1,10**7):\n....if n % 10:\n........s1 = str(n)\n........s2 = s1[::-1]\n........if s1 != s2 and not n % int(s2):\n............A243097.append(sum(int(d) for d in s1))\n\n"}
{"sequence_id": "A243102", "text": "Numbers n such that the digits of (n + product of digits of n) are a nontrivial permutation of the digits of n.", "sequence": "239,326,364,497,563,598,613,637,695,819,1239,1326,1364,1497,1563,1598,1613,1637,1695,1819,2139,2313,2356,2369,2419,2594,2639,2791,3126,3213,3235,3238,3259,3354,3365,3561,4219,4346,4353,4395,4559,4569,4592,4595,4719,4953,4967,5129,5233", "code": "\nfrom operator import mul\nfrom functools import reduce\nA243102 = [int(n) for n in (str(x) for x in range(1,10**5)) if not n.count('0') and sorted(str(int(n)+reduce(mul, (int(d) for d in n)))) == sorted(n)]\n\n"}
{"sequence_id": "A243103", "text": "Product of numbers m with 2 <= m <= n whose prime divisors all divide n.", "sequence": "1,2,3,8,5,144,7,64,27,3200,11,124416,13,6272,2025,1024,17,35831808,19,1024000,3969,247808,23,859963392,125,346112,729,2809856,29,261213880320000000,31,32768,264627,18939904,30625,26748301344768,37,23658496,369603,32768000000,41", "code": "\nfrom sympy import primefactors\ndef A243103(n):\n    y, pf = 1, set(primefactors(n))\n    for m in range(2,n+1):\n        if set(primefactors(m)) <= pf:\n            y *= m\n    return y \n"}
{"sequence_id": "A243104", "text": "Odd numbers in A192274.", "sequence": "945,1575,2205,2835,3465,4095,4725,6435,6615,6825,7245,7425,7875,8085,8505,8925,9135,9555,9765,10395,11655,12285,12915,13545,14805,15015,16065,16695,17955,18585,19215,19635,19845,20475,21105,21735,22275,22365,22995,23205", "code": "\nfrom sympy import divisors\nimport numpy as np\nA243104 = []\nfor n in range(3,10**4,2):\n....d = divisors(n)\n....s = sum(d)\n....if not s % 2 and 2*n <= s:\n........d.remove(n)\n........s2, ld = int(s/2-n), len(d)\n........z = np.zeros((ld+1,s2+1),dtype=int)\n........for i in range(1,ld+1):\n............y = min(d[i-1],s2+1)\n............z[i,range(y)] = z[i-1,range(y)]\n............z[i,range(y,s2+1)] = np.maximum(z[i-1,range(y,s2+1)],z[i-1,range(0,s2+1-y)]+y)\n............if z[i,s2] == s2:\n................d2 = [2*x for x in d if n > 2*x and n % (2*x)] + \\\n................[x for x in divisors(2*n-1) if n > x >=2 and n % x] + \\\n................[x for x in divisors(2*n+1) if n > x >=2 and n % x]\n................s, dmax = sum(d2), max(d2)\n................if not s % 2 and 2*dmax <= s:\n....................d2.remove(dmax)\n....................s2, ld = int(s/2-dmax), len(d2)\n....................z = np.zeros((ld+1,s2+1),dtype=int)\n....................for i in range(1,ld+1):\n........................y = min(d2[i-1],s2+1)\n........................z[i,range(y)] = z[i-1,range(y)]\n........................z[i,range(y,s2+1)] = np.maximum(z[i-1,range(y,s2+1)],z[i-1,range(0,s2+1-y)]+y)\n........................if z[i,s2] == s2:\n............................A243104.append(n)\n............................break\n................break\n"}
{"sequence_id": "A243112", "text": "a(n) is the smallest number that requires at least n adjacent bit swaps in order to pack all the ones to the right.", "sequence": "0,2,4,8,12,20,24,40,48,56,88,104,112,176,208,224,240,368,432,464,480,736,864,928,960,992,1504,1760,1888,1952,1984,3008,3520,3776,3904,3968,4032,6080,7104,7616,7872,8000,8064,12160,14208,15232,15744,16000,16128", "code": "\nA243112, a = [0], 0\nfor n in range(1,2**30):\n....s = bin(n)[2:]\n....b = sum(s[i:].count('0') for i,d in enumerate(s,start=1) if d == '1')\n....if b > a:\n........A243112.append(n)\n........a = b \n"}
{"sequence_id": "A243145", "text": "Least positive number k such that n+k and n+k^2 are both prime.", "sequence": "1,1,2,1,6,1,4,3,2,1,6,1,4,3,2,1,6,1,12,3,16,1,6,7,4,15,2,1,12,1,6,9,8,3,6,1,4,3,2,1,30,1,4,3,8,1,6,5,10,3,10,1,6,5,4,15,2,1,42,1,6,21,4,3,6,1,4,15,2,1,30,1,6,33,8,25,6,1,10,3,16,1,24,5,4,15", "code": "\nfrom sympy import isprime, nextprime\ndef A243145(n):\n    m = n\n    while True:\n        m = nextprime(m)\n        k = m-n\n        if isprime(n+k**2):\n            return k \n"}
{"sequence_id": "A243150", "text": "Least number k > 0 such that 2^k contains an n-digit long substring of the infinite string \"0123456789012345678901234567890123456....\".", "sequence": "1,7,28,106,391,992,1178,7255,15975,67143,333212,333212,1641257", "code": "\ndef a(n):\n..for k in range(1,10**5):\n....for i in range(10):\n......s = ''\n......for j in range(i,i+n):\n........dig=j%10\n........s+=str(dig)\n......if str(2**k).find(s) > -1:\n........return k\nn=1\nwhile n < 10:\n..print(a(n))\n..n+=1\n"}
{"sequence_id": "A243151", "text": "Least number k not divisible by 10 such that the decimal expansion of k^n contains some digit exactly n times.", "sequence": "1,11,36,34,99,258,391,163,341,951,867,1692,1114,793,4792,3019,1935,5469,6398,6152,8906,1987,15815,19603,16292,26216,32113,19718,24354,45903,15776,42202,34572,44411,46911,67972,39291,52299,30499,28383,38001,89782,95017,55954", "code": "\ndef c(n):\n..for k in range(10**5):\n....if k%10 !=0:\n......count = 0\n......for i in range(10):\n........if str(k**n).count(str(i)) == n:\n..........return k\nn = 1\nwhile n < 100:\n..print(c(n))\n..n+=1\n"}
{"sequence_id": "A243152", "text": "a(n) = the digit that is repeated exactly n times in the string A243151(n)^n.", "sequence": "1,1,6,3,9,4,1,1,6,0,8,5,4,8,7,1,4,1,6,0,6,3,8,9,3,4,9,6,7,6,7,4,6,0,3,9,6,0,9,5,1,3,1,6,2,7,7,9,4,8,9,2,7,7,7,9,9,4,9,9,1,0,9,5,9,5,5,6,4,3,2,6,3,7,4,7,2,0,1,2,8,1,9,6,9,9,1,9,3,0", "code": "\ndef c(n):\n..for k in range(10**7):\n....if k % 10 == 0:\n......lst = []\n......count = 0\n......for i in range(10):\n........if str(k**n).count(str(i)) == n:\n..........return i\nn = 1\nwhile n < 100:\n..print(c(n),end=', ')\n..n+=1\n"}
{"sequence_id": "A243269", "text": "Smallest prime p such that p^k - 2 is prime for all odd exponents k from 1 up to 2*n-1 (inclusive).", "sequence": "5,19,31,201829,131681731,954667531,8998333416049", "code": "\nimport sympy\n\n\ndef isp_list(ls):\n....pt=[]\n....for a in ls:\n........if sympy.ntheory.isprime(a)==True:\n............pt.append(True)\n....return(pt)\nco=1\nwhile co < 7:\n....al=0\n....n=2\n....while al!=co:\n........d=[]\n........for i in range(0, co):\n............d.append(int(n**((2*i)+1))-2)\n........al=isp_list(d).count(True)\n........if al==co:\n............\n............print(n, d)\n........n=sympy.ntheory.nextprime(n)\n....co=co+1\n"}
{"sequence_id": "A243285", "text": "Number of integers 1 <= k <= n which are not divisible by the square of their largest noncomposite divisor.", "sequence": "0,1,2,2,3,4,5,5,5,6,7,8,9,10,11,11,12,12,13,14,15,16,17,18,18,19,19,20,21,22,23,23,24,25,26,26,27,28,29,30,31,32,33,34,35,36,37,38,38,38,39,40,41,41,42,43,44,45,46,47,48,49,50,50,51,52,53,54,55,56,57", "code": "\nfrom sympy import primefactors\ndef a243285(n): return 0 if n==1 else sum([1 for k in range(2, n + 1) if k%(primefactors(k)[-1]**2)!=0]) \n"}
{"sequence_id": "A243294", "text": "Least number k > 1 such that a number composed of k consecutive ascending digits starting with n is prime.", "sequence": "171,2,179,4,29,2,5,2,13", "code": "\nimport sympy\nfrom sympy import isprime\ndef a(n):\n....num = str(n)\n....for i in range(n+1,10**3):\n........num += str(i%10)\n........if isprime(int(num)):\n............return len(num)\nn=1\nwhile n < 10:\n....print(a(n),end=', ')\n....n+=1\n"}
{"sequence_id": "A243295", "text": "Least number k > 0 such that 3^k contains an n-digit long substring of the infinite string \"0123456789012345678901234567890123456...\"", "sequence": "1,8,15,57,102,332,2345,2345,10110,118745,127188,326758,2258910", "code": "\ndef a(n):\n..for k in range(1, 10**5):\n....for i in range(10):\n......s = ''\n......for j in range(i, i+n):\n........dig=j%10\n........s+=str(dig)\n......if str(3**k).find(s) > -1:\n........return k\nn=1\nwhile n < 10:\n..print(a(n))\n..n+=1\n"}
{"sequence_id": "A243297", "text": "Numbers k such that k^8 - k^7 - k^6 - k^5 - k^4 - k^3 - k^2 - k - 1 is prime.", "sequence": "4,5,18,23,24,25,39,41,49,61,68,73,100,102,103,109,111,114,125,140,150,157,158,167,181,210,228,242,245,259,282,286,287,290,294,299,300,303,307,311,315,325,341,347,364,367,371,385,390,395,403,406,415,430,437,441,444", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n,end=', ') for n in range(10**3) if isprime(n**8-n**7-n**6-n**5-n**4-n**3-n**2-n-1)}\n"}
{"sequence_id": "A243298", "text": "Numbers k such that k^9 - k^8 - k^7 - k^6 - k^5 - k^4 - k^3 - k^2 - k - 1 is prime.", "sequence": "4,16,18,28,76,84,88,118,146,180,258,272,274,282,316,380,384,400,462,464,468,476,548,586,588,610,616,644,646,702,708,756,786,810,826,944,954,956,988,1000,1016,1052,1104,1138,1166,1178,1194,1212,1226,1240,1258,1356", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n,end=', ') for n in range(10**4) if isprime(n**9-n**8-n**7-n**6-n**5-n**4-n**3-n**2-n-1)}\n"}
{"sequence_id": "A243298", "text": "Numbers k such that k^9 - k^8 - k^7 - k^6 - k^5 - k^4 - k^3 - k^2 - k - 1 is prime.", "sequence": "4,16,18,28,76,84,88,118,146,180,258,272,274,282,316,380,384,400,462,464,468,476,548,586,588,610,616,644,646,702,708,756,786,810,826,944,954,956,988,1000,1016,1052,1104,1138,1166,1178,1194,1212,1226,1240,1258,1356", "code": "\nfrom sympy import isprime\nA243298_list, m = [], [362880, -1491840, 2464560, -2082240, 945000, -220248, 22560, -680, 1, -1]\nfor n in range(1,10**5+1):\n....for i in range(9):\n........m[i+1]+= m[i]\n....if isprime(m[-1]):\n........A243298_list.append(n) \n"}
{"sequence_id": "A243300", "text": "Numbers k such that k^6 - k^5 - k^4 - k^3 - k^2 - k - 1 is prime.", "sequence": "4,5,7,9,17,30,37,39,42,62,69,72,79,82,85,90,92,95,99,104,110,157,170,175,177,182,187,194,195,215,217,220,234,239,240,242,255,262,269,272,277,319,334,339,342,344,359,365,369,370,374,377,387,392,400,417,419,449", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n,end=', ') for n in range(10**3) if isprime(n**6-n**5-n**4-n**3-n**2-n-1)}\n"}
{"sequence_id": "A243301", "text": "Numbers k such that k^7 - k^6 - k^5 - k^4 - k^3 - k^2 - k - 1 is prime.", "sequence": "30,38,66,110,144,156,164,174,194,210,222,230,266,278,282,318,354,374,392,432,474,528,540,552,588,630,636,650,704,714,716,812,918,960,1076,1086,1122,1142,1190,1224,1322,1362,1388,1394,1418,1452,1506,1508,1532,1538,1596", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n, end=', ') for n in range(10**3) if isprime(n**7-n**6-n**5-n**4-n**3-n**2-n-1)}\n"}
{"sequence_id": "A243303", "text": "Least number k > 0 such that 2^k contains an n-digit long substring of the infinite string \"98765432109876543210987654...\"", "sequence": "1,5,25,78,161,341,1076,16361,19383,56047,132903,862935,862935,4381548", "code": "\ndef Rev(n):\n..rev = ''\n..for i in str(n):\n....rev = i + rev\n..return rev\ndef a(n):\n..lst = []\n..for b in range(1,10**n):\n....if len(str(2**b)) >= n:\n......lst.append(b)\n......break\n..for k in range(lst[0],50000):\n....for i in range(10):\n......s = ''\n......s += str(i)\n......for j in range(i+1,i+n):\n........dig = j%10\n........s+=str(dig)\n......if str(2**k).find(Rev(s)) > -1:\n........return k\nn = 1\nwhile n < 100:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A243304", "text": "Least number k > 0 such that 3^k contains at least an n-digit long substring of the infinite string \"98765432109876543210987654...\".", "sequence": "1,5,13,50,213,536,536,536,9354,63202,117150,1314904", "code": "\ndef Rev(n):\n..rev = ''\n..for i in str(n):\n....rev = i + rev\n..return rev\ndef a(n):\n..lst = []\n..for b in range(1,10**n):\n....if len(str(3**b)) >= n:\n......lst.append(b)\n......break\n..for k in range(lst[0],50000):\n....for i in range(10):\n......s = ''\n......s += str(i)\n......for j in range(i+1,i+n):\n........dig = j%10\n........s+=str(dig)\n......if str(3**k).find(Rev(s)) > -1:\n........return k\nn = 1\nwhile n < 100:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A243312", "text": "The total T(d,n) of expressions with n instances of a digit d between 6 and 9 (and using the four arithmetic operators) which have a defined value when evaluated.", "sequence": "1,4,31,305,3345,39505,487935,6245118", "code": "\n\n.\nimport itertools\n.\n.\ndef all_expressions(generic_expression, operation_combinations):\n....\"\"\"\n....Merges a source expression and combinations of binary operators to generate a list of all possible expressions.\n....@param ((str,)) operation_combinations: all combinations of binary operators to consider\n....@param str generic_expression: source expression with placeholder binary operators\n....@rtype: (str,)\n....\"\"\"\n....expression_combinations = []\n....for combination in operation_combinations:\n........expression_combinations.append(generic_expression.format(*combination))\n....return expression_combinations\n.\n.\ndef all_bracketings(expr):\n....\"\"\"\n....Generates all possible permutations of parentheses for an expression.\n....@param str expr: the non-bracketed source expression\n....@rtype: str\n....\"\"\"\n....if len(expr) == 1:\n........yield expr\n....else:\n........for i in range(1, len(expr), 2):\n............for left_expr in all_bracketings(expr[:i]):\n................for right_expr in all_bracketings(expr[i + 1:]):\n....................yield \"({}{}{})\".format(left_expr, expr[i], right_expr)\n.\n.\ndef num_valid_expressions(num_digits):\n....\"\"\"Perform all calculations with the given operations and in the range of digits specified.\n....@param int num_digits: the number of digits in the expression\n....@rtype: int\n....\"\"\"\n....operations = [\"+\", \"-\", \"*\", \"/\"]\n....digit = 9\n....operation_iterable = itertools.product(*[operations] * (num_digits - 1))\n....operation_combinations = []\n....valid_expression_count = 0\n....template = \" \".join(str(digit) * num_digits)\n....for operation in operation_iterable:\n........operation_combinations.append(operation)\n....for bracketed_expression in all_bracketings(template):\n........for expression in all_expressions(bracketed_expression.replace(\" \", \"{}\"), operation_combinations):\n............try:\n................eval(expression)\n................valid_expression_count += 1\n............except ZeroDivisionError:\n................pass\n....return valid_expression_count\n.\n.\nif __name__ == \"__main__\":\n....min_num_digits = 1\n....max_num_digits = 6\n....operation_set = [\"+\", \"-\", \"*\", \"/\"]\n....for num in range(min_num_digits, max_num_digits + 1):\n........print(num_valid_expressions(num))\n"}
{"sequence_id": "A243318", "text": "Numbers n such that n^10 - n^9 - n^8 - n^7 - n^6 - n^5 - n^4 - n^3 - n^2 - n - 1 is prime.", "sequence": "15,56,65,74,87,104,132,150,171,185,186,204,225,234,360,429,449,455,459,476,485,512,675,746,770,780,795,816,836,839,840,846,857,876,902,930,939,941,944,977,1109,1152,1161,1190,1262,1289,1295,1316,1355,1362,1374,1395,1401,1425", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n, end=', ') for n in range(10**4) if isprime(n**10-n**9-n**8-n**7-n**6-n**5-n**4-n**3-n**2-n-1)}\n"}
{"sequence_id": "A243318", "text": "Numbers n such that n^10 - n^9 - n^8 - n^7 - n^6 - n^5 - n^4 - n^3 - n^2 - n - 1 is prime.", "sequence": "15,56,65,74,87,104,132,150,171,185,186,204,225,234,360,429,449,455,459,476,485,512,675,746,770,780,795,816,836,839,840,846,857,876,902,930,939,941,944,977,1109,1152,1161,1190,1262,1289,1295,1316,1355,1362,1374,1395,1401,1425", "code": "\nfrom sympy import isprime\nA243318_list, m = [], [3628800, -16692480, 31651200, -31827600, 18163440, -5826240, 971232, -69720, 1362, -2, -1]\nfor n in range(1,10**5+1):\n....for i in range(10):\n........m[i+1]+= m[i]\n....if isprime(m[-1]):\n........A243318_list.append(n) \n"}
{"sequence_id": "A243353", "text": "Permutation of natural numbers which maps between the partitions as encoded in A227739 (binary based system, zero-based) to A112798 (prime-index based system, one-based).", "sequence": "1,2,4,3,9,8,6,5,25,18,16,27,15,12,10,7,49,50,36,75,81,32,54,125,35,30,24,45,21,20,14,11,121,98,100,147,225,72,150,245,625,162,64,243,375,108,250,343,77,70,60,105,135,48,90,175,55,42,40,63,33,28,22,13,169,242,196,363,441,200,294,605,1225,450,144", "code": "\nfrom sympy import prime\nimport math\ndef A(n): return n - 2**int(math.floor(math.log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a005940(n): return b(n - 1)\ndef a003188(n): return n^int(n/2)\ndef a243353(n): return a005940(1 + a003188(n)) \n"}
{"sequence_id": "A243374", "text": "Least number k such that n//k and k//n are both prime where // is the concatenation function, or 0 if no such k exists.", "sequence": "1,0,1,0,0,0,1,0,7,0,3,0,1,0,0,0,3,0,7,0,13,0,11,0,0,0,1,0,27,0,1,0,7,0,0,0,3,0,7,0,9,0,39,0,0,0,9,0,1,0,19,0,51,0,0,0,1,0,3,0,7,0,1,0,0,0,3,0,49,0,9,0,3,0,0,0,17,0,19,0,1,0,9,0,0,0,7,0,23", "code": "\nimport sympy\nfrom sympy import isprime\ndef a(n):\n..for k in range(1,10**5):\n....if isprime(int(str(k)+str(n))) and isprime(int(str(n)+str(k))):\n......return k\nn = 1\nwhile n < 100:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A243400", "text": "Primes p such that p^6 - p^5 - p^4 - p^3 - p^2 - p - 1 is prime.", "sequence": "5,7,17,37,79,157,239,269,277,359,419,449,467,557,677,739,787,829,857,977,1319,1399,1597,1657,2069,2269,2297,2377,2437,2459,2819,2969,2999,3019,3137,3299,3389,3407,3967,4007,4099,4357,4547,4729,4987,5179,5419,5569,5779,6637", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n,end=', ') for n in range(10**4) if isprime(n**6-n**5-n**4-n**3-n**2-n-1) and isprime(n)}\n"}
{"sequence_id": "A243401", "text": "Primes p such that p^8 - p^7 - p^6 - p^5 - p^4 - p^3 - p^2 - p - 1 is prime.", "sequence": "5,23,41,61,73,103,109,157,167,181,307,311,347,367,467,577,593,601,677,709,739,839,863,1039,1181,1201,1279,1381,1399,1621,1627,1789,1847,1861,1871,1913,1997,2063,2287,2347,2371,2657,2699,2797,2887,2963,3209,3343,3359,3623", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n,end=', ') for n in range(10**4) if isprime(n**8-n**7-n**6-n**5-n**4-n**3-n**2-n-1) and isprime(n)}\n"}
{"sequence_id": "A243402", "text": "Primes p such that p^10 - p^9 - p^8 - p^7 - p^6 - p^5 - p^4 - p^3 - p^2 - p - 1 is prime.", "sequence": "449,839,857,941,977,1109,1289,1607,1901,2591,2711,3041,3299,4007,4349,4721,5531,5849,6311,6779,6911,7451,7829,7907,8369,8597,8999,9419,9767,11351,12917,13421,14321,14969,15077,15131,15227,15551,15809,16649,16979,17021,17291,17417", "code": "\nimport sympy\nfrom sympy import isprime\n{print(n,end=', ') for n in range(5*10**4) if isprime(n**10-n**9-n**8-n**7-n**6-n**5-n**4-n**3-n**2-n-1) and isprime(n)}\n"}
{"sequence_id": "A243408", "text": "Primes p such that 10p-1, 10p-3, 10p-7 and 10p-9 are all prime.", "sequence": "2,11,83,149,347,1301,1607,2531,6299,7727,8273,17117,20183,21737,24371,26669,39227,40277,53951,54917,63347,66359,66467,73637,82217,82373,101537,102251,106397,106871,117203,132971,134033,135221,140237,144701,146141,151433,152597", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import prime\n{print(prime(n),end=', ') for n in range(1,10**5) if isprime(10*prime(n)-1) and isprime(10*prime(n)-3) and isprime(10*prime(n)-7) and isprime(10*prime(n)-9)}\n"}
{"sequence_id": "A243409", "text": "Primes p such that 100p-1, 100p-3, 100p-7, and 100p-9 are all prime.", "sequence": "2,797,1193,6803,15773,28793,35507,41579,53189,53279,57347,60161,70457,77549,81839,140549,143387,150779,151241,164447,170627,201011,255083,285287,293831,300317,316073,336671,343661,449921,470087,486947,488603,518801,556289,569243,602087", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import prime\n{print(prime(n),end=', ') for n in range(1,10**5) if isprime(100*prime(n)-1) and isprime(100*prime(n)-3) and isprime(100*prime(n)-7) and isprime(100*prime(n)-9)}\n"}
{"sequence_id": "A243410", "text": "Primes p such that 1000p-1, 1000p-3, 1000p-7 and 1000p-9 are all prime.", "sequence": "10193,13217,34457,36767,57773,76631,103043,157823,191033,194813,212243,229799,242273,242867,249377,256889,261563,264071,361511,457871,486293,502841,508517,647837,653621,694409,697511,777437,798143,825611,847031", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import prime\n{print(prime(n),end=', ') for n in range(1,10**5) if isprime(1000*prime(n)-1) and isprime(1000*prime(n)-3) and isprime(1000*prime(n)-7) and isprime(1000*prime(n)-9)}\n"}
{"sequence_id": "A243411", "text": "Least prime p such that p*10^n-1, p*10^n-3, p*10^n-7 and p*10^n-9 are all prime.", "sequence": "2,2,10193,24851,20549,719,22133,230471,46679,432449,114689,227603,305297,61463,1866467,866309,1189403,362081,2615783,493433,966353,4154363,6562931,9096203,3701627,3128813,20983727,303593,24437537,1068491", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import prime\ndef a(n):\n..for k in range(1,10**8):\n....if isprime(prime(k)*10**n-1) and isprime(prime(k)*10**n-3) and isprime(prime(k)*10**n-7) and isprime(prime(k)*10**n-9):\n......return prime(k)\nn = 1\nwhile n < 100:\n..print(a(n),end=', ')\n..n+=1\n"}
{"sequence_id": "A243583", "text": "Primes p for which p + 4 and p^3 + 4 are primes.", "sequence": "3,7,19,79,103,109,277,379,487,967,1489,1663,1867,2857,3019,3253,3613,3697,4003,4783,4969,5413,5437,5503,5569,5647,5923,7477,7669,7687,7699,7789,7933,8233,8779,9007,9319,9547,9739,10597,11257,11467,11593,11827,12037", "code": "\nimport sympy.ntheory as snt\nn=2\nwhile n>1:\n....n1=n+4\n....n2=((n**3)+4)\n....\n....if snt.isprime(n1)== True and snt.isprime(n2)== True:\n........print(n, \" , \" , n1, \" , \", n2)\n....n=snt.nextprime(n)\n"}
{"sequence_id": "A243589", "text": "Numbers returned when each binary digit of n is replaced by the sum modulo 2 of the digits to its (wrapped) left and (wrapped) right.", "sequence": "0,0,0,3,5,6,0,5,15,0,10,15,5,10,0,9,27,12,30,3,17,6,20,29,15,24,10,23,5,18,0,17,51,20,54,27,57,30,60,5,39,0,34,15,45,10,40,57,27,60,30,51,17,54,20,45,15,40,10,39,5,34,0,33,99,36,102,43,105,46", "code": "\nfor n in range(1, 100):\n    BL = len(bin(n))-2\n    x = (n>>1) + ((n&1) << (BL-1))   \n    x^= (n*2) - (1<<BL) + 1   \n    print str(x)+',',\n"}
{"sequence_id": "A243734", "text": "Primes p for which p + 4, p^2 + 4 and p^3 + 4 are primes.", "sequence": "3,7,103,277,487,967,4783,5503,5923,8233,21013,26317,27943,41593,55213,78307,78853,86197,89653,94723,99013,123727,148153,157177,166627,172867,177883,179107,185893,192883,194713,203767,204517,223633,225217,227593,236893", "code": "\nimport sympy.ntheory as snt\nn=2\nwhile n>1:\n....n1=n+4\n....n2=((n**2)+4)\n....n3=((n**3)+4)\n....\n....if snt.isprime(n1)== True and snt.isprime(n2)== True and snt.isprime(n2)== True:\n........print(n, \" , \" , n1, \" , \", n2, \" , \", n3)\n....n=snt.nextprime(n)\n"}
{"sequence_id": "A243780", "text": "Primes p for which p^i + 4 is prime for i = 1, 3 and 5.", "sequence": "7,5503,8779,14629,15877,21013,23599,51199,61483,70237,78163,79333,80149,96667,113089,113359,133153,140053,149377,150889,184039,198967,228199,251287,255637,295843,301123,303613,356929,382843,385393,393709,420037,457363,458119", "code": "\nimport sympy.ntheory as snt\nn=2\nwhile n>1:\n....n1=n+4\n....n2=((n**3)+4)\n....n3=((n**5)+4)\n....\n....if snt.isprime(n1)== True and snt.isprime(n2)== True and snt.isprime(n3)== True:\n........print(n,n1,n2,n3)\n....n=snt.nextprime(n)\n"}
{"sequence_id": "A243817", "text": "Primes p for which p - 4 and p^3 - 4 are primes.", "sequence": "11,17,23,41,83,101,131,227,311,383,491,503,773,827,881,887,971,1097,1283,1301,1451,1493,1877,2141,2243,2273,2351,2687,2861,2957,3533,3881,3947,4007,4517,4643,5231,5237,5573,5741,6203,7211,7541,7883,7937,8741,9137,9551,10337,11447", "code": "\nimport sympy.ntheory as snt\nn=5\nwhile n>1:\n....n1=n-4\n....n2=((n**3)-4)\n....\n....if snt.isprime(n1)== True and snt.isprime(n2)== True:\n........print(n, n1, n2)\n....n=snt.nextprime(n)\n"}
{"sequence_id": "A243818", "text": "Primes p for which p^i - 4 is prime for i = 1, 3 and 5.", "sequence": "11,971,1877,2861,8741,12641,13163,16763,28283,29021,30707,36713,41957,42227,58967,98717,105971,115127,128663,138641,160817,164093,167441,190763,205607,210173,211067,228341,234197,237977,246473,249107,276557,295433,312233", "code": "\nimport sympy.ntheory as snt\nn=5\nwhile n>1:\n....n1=n-4\n....n2=((n**3)-4)\n....n3=((n**5)-4)\n....\n....if snt.isprime(n1)== True and snt.isprime(n2)== True and snt.isprime(n3)== True:\n........print(n, n1, n2, n3)\n....n=snt.nextprime(n)\n"}
{"sequence_id": "A243844", "text": "Primes p such that p^5 + p^3 + p + 2 is prime.", "sequence": "5,7,17,67,109,127,199,359,389,467,599,647,727,829,877,887,919,947,1187,1259,1429,1789,1889,1987,1997,2099,2129,2309,2399,2417,2557,2647,2837,2909,3187,3329,3359,3469,3517,3527,3769,3917,3967,4049,4217,4289,4349,4357,4507,4517,4937,5309,5507,5527,5879,6247,6337", "code": "\nimport sympy.ntheory as snt\np=1\nwhile p>0:\n....p=snt.nextprime(p)\n....pp=p+(p**3)+(p**5)+2\n....if snt.isprime(pp) == True:\n........print(p,pp)\n"}
{"sequence_id": "A243859", "text": "Primes p for which p^i + 4 is prime for i = 1, 3, 5 and 7.", "sequence": "7,133153,184039,356929,469363,982843,2154487,2552713,2686573,3378103,3847867,4270069,4341373,4564363,4584847,4964899,5366017,5600989,6185173,6592609,6595597,6629683,6768409,8232277,9028429,9964177,10009339,12107089,13266553,13600189", "code": "\nimport sympy.ntheory as snt\nn=2\nwhile n>1:\n....n1=n+4\n....n2=((n**3)+4)\n....n3=((n**5)+4)\n....n4=((n**7)+4)\n....\n....if snt.isprime(n1)== True and snt.isprime(n2)== True and snt.isprime(n3)== True and snt.isprime(n4)== True:\n........print(n, n1, n2, n3, n4)\n....n=snt.nextprime(n)\n"}
{"sequence_id": "A243861", "text": "Primes p for which p^i - 4 is prime for i = 1, 3, 5 and 7.", "sequence": "971,12641,205607,228341,276557,412343,1012217,1101323,1902881,2171021,2477411,2692121,4116377,4311677,6060953,6182993,6388913,6444863,8341121,8551451,9507527,10523141,10997411,11444093,14101361,14656307,14813147,15435587,17337521", "code": "\nimport sympy.ntheory as snt\nn=2\nwhile n>1:\n....n1=n-4\n....n2=((n**3)-4)\n....n3=((n**5)-4)\n....n4=((n**7)-4)\n....\n....if snt.isprime(n1)== True and snt.isprime(n2)== True and snt.isprime(n3)== True and snt.isprime(n4)== True:\n........print(n, n1, n2, n3, n4)\n....n=snt.nextprime(n)\n"}
{"sequence_id": "A243885", "text": "Smallest prime p_n which generates n primes of the form (p_n^i - 4) when i runs through the first n odd numbers.", "sequence": "7,11,11,971,71394923,959316767,13342820302307", "code": "\nimport sympy\n\n\ndef isp_list(ls):\n....pt=[]\n....for a in ls:\n........if sympy.ntheory.isprime(a)==True:\n............pt.append(True)\n....return(pt)\nco=1\nwhile co > 0:\n....al=0\n....n=2\n....while al!=co:\n........d=[]\n........for i in range(0, co):\n............d.append(int(n**((2*i)+1))-4)\n........al=isp_list(d).count(True)\n........if al==co:\n............\n............print(n, d)\n........n=sympy.ntheory.nextprime(n)\n....co=co+1\n"}
{"sequence_id": "A243897", "text": "Primes p such that p^5 + p^3 + p - 2 is prime.", "sequence": "3,5,11,13,23,43,131,311,353,401,491,761,1051,1063,1091,1151,1201,1433,1523,1531,1723,1733,1811,1831,1951,1973,2053,2081,2221,2333,2543,2591,2621,2663,2953,2963,3191,3433,3571,3623,3643,3821,3911,4051,4273,4391,4973,5273,5393,5591,6101,6131,6173,6203,6263,6473", "code": "\nimport sympy.ntheory as snt\np=1\nwhile p>0:\n....p=snt.nextprime(p)\n....pp=p+(p**3)+(p**5)-2\n....if snt.isprime(pp) == True:\n........print(p,pp)\n"}
{"sequence_id": "A243898", "text": "Prime p such that p^5 + p^3 + p + 4 is prime.", "sequence": "3,5,19,23,41,59,101,109,137,139,191,223,229,233,277,293,307,311,331,349,419,499,563,599,641,647,751,797,811,839,859,881,1021,1117,1181,1193,1259,1301,1427,1453,1549,1571,1609,1619,1621,1637,1697,1721,1811,1871,1889,1907,1949,1973,2039,2153,2309,2579,2609,2663", "code": "\nimport sympy.ntheory as snt\np=1\nwhile p>0:\n....p=snt.nextprime(p)\n....pp=p+(p**3)+(p**5)+4\n....if snt.isprime(pp) == True:\n........print(p,pp)\n"}
{"sequence_id": "A243899", "text": "Prime p such that p^5 + p^3 + p - 4 is prime.", "sequence": "3,5,11,19,23,37,43,103,127,193,199,239,269,277,283,373,397,457,467,509,751,761,887,919,947,977,1019,1039,1051,1069,1087,1277,1307,1481,1531,1549,1559,1613,1759,2003,2017,2243,2311,2357,2417,2447,2467,2473,2671,2851,2963,3089,3253,3257,3323,3433,3463,3511,3539", "code": "\nimport sympy.ntheory as snt\np=1\nwhile p>0:\n....p=snt.nextprime(p)\n....pp=p+(p**3)+(p**5)-4\n....if snt.isprime(pp) == True:\n........print(p, pp)\n"}
{"sequence_id": "A243900", "text": "Prime p such that p^5 + p^3 + p - 4 and p^5 + p^3 + p + 4 are primes.", "sequence": "3,5,19,23,277,751,1549,2851,2963,3089,3463,3511,4057,6067,6619,7873,9257,10937,11161,11321,11483,12589,13997,15139,25121,25939,26113,26861,30971,33889,37139,38119,39251,39979,40763,41851,42359,44293,50753,50867,51907,54331,54401,55871,56921,58321,60611,62459", "code": "\nimport sympy.ntheory as snt\np=1\nwhile p>0:\n....p=snt.nextprime(p)\n....pp=p+(p**3)+(p**5)-4\n....qq=p+(p**3)+(p**5)+4\n....if snt.isprime(pp) == True and snt.isprime(qq) == True:\n........print(p)\n"}
{"sequence_id": "A243911", "text": "Least number k such that n^k ends in two identical digits, or 0 if no such number exists.", "sequence": "18,0,9,0,0,0,6,0,2,1,2,17,3,0,0,11,0,5,2,0,1,0,0,0,0,0,14,0,2,7,0,1,7,0,0,7,2,5,2,0,3,0,1,0,0,0,9,0,2,0,18,3,9,1,0,0,6,5,2,0,2,0,3,0,1,0,0,0,2,3,7,11,0,0,0,1,14,5,2,0,0,0,7,0,0,0,1,0,2,9,3,0,11", "code": "\ndef b(n,p):\n..lst = []\n..count = 0\n..lst1 = []\n..for i in range(1,5**(n+2)):\n....st = str(p**i)\n....if len(st) >= n:\n......if int(st[len(st)-n:len(st)]) not in lst:\n........lst.append(int(st[len(st)-n:len(st)]))\n........lst1.append(i)\n......else:\n........return len(lst)+min(lst1)\ndef a(p):\n..for i in range(1,b(2,p)+2):\n....st = str(p**i)\n....if int(st[len(st)-2:len(st)])%11==0:\n......return i\np = 2\nwhile p < 100:\n..if a(p):\n....print(a(p),end=', ')\n..else:\n....print(0,end=', ')\n..p += 1\n"}
{"sequence_id": "A243912", "text": "Numbers n > 1 such that n^k never ends in 2 or more identical digits for any k.", "sequence": "3,5,6,7,9,15,16,18,21,23,24,25,26,27,29,32,35,36,41,43,45,46,47,49,51,56,57,61,63,65,67,68,69,74,75,76,81,82,83,85,86,87,89,93,95,96,101,103,105,106,107,109,115,116,118,121,123,124,125,126,127,129,132,135,136,141", "code": "\ndef b(n,p):\n..lst = []\n..count = 0\n..lst1 = []\n..for i in range(1,5**(n+2)):\n....st = str(p**i)\n....if len(st) >= n:\n......if int(st[len(st)-n:len(st)]) not in lst:\n........lst.append(int(st[len(st)-n:len(st)]))\n........lst1.append(i)\n......else:\n........return len(lst)+min(lst1)\ndef a(p):\n..for i in range(1,b(2,p)+2):\n....st = str(p**i)\n....if int(st[len(st)-2:len(st)])%11==0:\n......return i\np = 2\nwhile p < 200:\n..if not a(p):\n....print(p,end=', ')\n..p += 1\n"}
{"sequence_id": "A243916", "text": "Largest safe prime less than 2^n.", "sequence": "7,11,23,59,107,227,503,1019,2039,4079,8147,16223,32603,65267,130787,262127,524243,1048343,2097143,4194287,8388287,16776899,33553799,67108187,134217323,268435019,536870723,1073740439,2147483579,4294967087", "code": "\nfrom sympy import isprime\ndef a(n):\n    if n<3: return 0\n    i=2**n - 1\n    while True:\n        if isprime(i) and isprime((i - 1)/2): return i\n        else: i-=2 \n"}
{"sequence_id": "A243972", "text": "Least number k such that 2^k contains exactly n identical digits.", "sequence": "1,16,22,23,53,70,74,93,122,147,156,167,168,222,214,221,283,315,311,312,313,314,426,466,427,474,439,563,630,576,554,575,626,627,793,722,809,766,861,889,925,893,989,890,1077,891,983,892,1130,1128,1135,1134,1217,1129,1238", "code": "\ndef b():\n..n = 1\n..k = 1\n..while k < 50000:\n....st = str(2**k)\n....if len(st) >= n:\n......for a in range(10):\n........count = 0\n........for i in range(len(st)):\n..........if st[i] == str(a):\n............count += 1\n........if count == n:\n..........print(k,end=', ')\n..........n += 1\n..........k = 0\n..........break\n......k += 1\n....else:\n......k += 1\nb()\n"}
{"sequence_id": "A243973", "text": "a(n) is the repeating digit in 2^A243972(n).", "sequence": "2,5,4,8,9,1,8,9,1,8,3,5,1,6,7,3,1,4,7,5,1,2,8,0,7,7,8,1,4,1,8,5,7,5,9,4,8,1,6,7,3,5,0,4,9,8,6,7,4,1,6,3,0,2,9,8,4,5,8,9,2,3,0,3,3,5,1,6,3,4,6,6,8,6,4,8,4,6,5,7,4,1,1,7,1,1,9,3,2,5,2,2,3", "code": "\ndef b():\n..n = 1\n..k = 1\n..while k < 50000:\n....st = str(2**k)\n....if len(st) >= n:\n......for a in range(10):\n........count = 0\n........for i in range(len(st)):\n..........if st[i] == str(a):\n............count += 1\n........if count == n:\n..........print(a,end=', ')\n..........n += 1\n..........k = 0\n..........break\n......k += 1\n....else:\n......k += 1\nb()\n"}
{"sequence_id": "A243975", "text": "Least number k such that 3^k contains exactly n identical digits.", "sequence": "1,8,11,29,32,47,34,33,90,98,112,136,128,172,111,168,146,211,241,218,220,290,278,298,323,355,329,316,344,446,427,395,410,528,481,443,498,523,574,540,531,538,618,549,694,669,733,717,788,707,740,734,831,743,857,850,864", "code": "\ndef b():\n..n = 1\n..k = 1\n..while k < 50000:\n....st = str(3**k)\n....if len(st) >= n:\n......for a in range(10):\n........count = 0\n........for i in range(len(st)):\n..........if st[i] == str(a):\n............count += 1\n........if count == n:\n..........print(k,end=', ')\n..........n += 1\n..........k = 0\n..........break\n......k += 1\n....else:\n......k += 1\nb()\n"}
{"sequence_id": "A243976", "text": "a(n) is the repeating digit in 3^A243975(n).", "sequence": "3,6,7,3,8,8,6,5,7,8,3,4,1,3,1,7,7,7,5,4,9,8,9,1,9,6,3,2,7,0,3,3,8,1,8,2,7,7,3,0,3,5,7,0,0,3,9,7,1,7,2,9,6,1,1,3,0,9,3,0,0,9,5,9,5,0,1,6,6,2,0,9,2,1,5,6,4,6,8,6,9,9,3,2,7,7,7,0,3,1,8,5,3,0", "code": "\ndef b():\n..n = 1\n..k = 1\n..while k < 50000:\n....st = str(3**k)\n....if len(st) >= n:\n......for a in range(10):\n........count = 0\n........for i in range(len(st)):\n..........if st[i] == str(a):\n............count += 1\n........if count == n:\n..........print(a,end=', ')\n..........n += 1\n..........k = 0\n..........break\n......k += 1\n....else:\n......k += 1\nb()\n"}
{"sequence_id": "A243977", "text": "a(n) is the largest run of identical digits that n^k can end with for some k, or 0 if there is no limit to such runs.", "sequence": "3,1,2,1,1,1,3,1,0,2,3,3,2,1,1,5,1,2,0,1,3,1,1,1,1,1,3,1,0,3,1,4,2,1,1,3,3,3,0,1,3,1,2,1,1,1,3,1,0,1,3", "code": "\ndef a(n,p):\n..lst = []\n..for c in range(10**p+1):\n....m = n**c%10**p\n....if m in lst:\n......return [c,c-lst.index(m)]\n....else:\n......lst.append(m)\ndef cou(n):\n..if n % 10 == 0:\n....return 0\n..ww = []\n..p = 2\n..aa = a(n,p)[0]\n..ww.extend(range(aa))\n..while p < 100:\n....newlst = ww\n....w = []\n....for i in newlst:\n......m = n**i%10**p\n......if len(str(m))==p and m%int('1'*p)==0:\n........w.append(i)\n....if w:\n......ww = []\n......for k in w:\n........j = k\n........while j <= a(n,p+1)[0]:\n..........ww.append(j)\n..........j += a(n,p)[1]\n......ww.sort()\n......p += 1\n....else:\n......return p-1\nn = 2\nwhile n < 100:\n..if cou(n):\n....print(cou(n),end=', ')\n..else:\n....print(0,end=', ')\n..n += 1\n"}
{"sequence_id": "A244040", "text": "Sum of digits of n in fractional base 3/2.", "sequence": "0,1,2,2,3,4,3,4,5,3,4,5,5,6,7,4,5,6,5,6,7,7,8,9,5,6,7,5,6,7,7,8,9,8,9,10,5,6,7,7,8,9,6,7,8,7,8,9,9,10,11,9,10,11,5,6,7,7,8,9,8,9,10,6,7,8,8,9,10,8,9,10,9,10,11,11,12,13,10,11,12,5", "code": " a244040 = lambda n: a244040((n // 3) * 2) + (n % 3) if n else 0 \n"}
{"sequence_id": "A244042", "text": "In ternary representation of n, replace 2's with 0's.", "sequence": "0,1,0,3,4,3,0,1,0,9,10,9,12,13,12,9,10,9,0,1,0,3,4,3,0,1,0,27,28,27,30,31,30,27,28,27,36,37,36,39,40,39,36,37,36,27,28,27,30,31,30,27,28,27,0,1,0,3,4,3,0,1,0,9,10,9,12,13,12,9,10,9", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a(n):return int(\"\".join(map(str, digits(n, 3)[1:])).replace('2', '0'), 3) \n"}
{"sequence_id": "A244060", "text": "Sum of digits of (2^n)!.", "sequence": "1,2,6,9,63,108,324,828,1989,4635,10845,24363,54279,118827,258705,565389,1216134,2611359,5584518,11875977,25184205,53209728,112069377,235502361,493827687,1033041267,2156974227,4495662081,9355185828,19437382512,40329016200", "code": "\nfrom math import factorial\ndef A244060(n): return sum(int(d) for d in str(factorial(2**n))) \n"}
{"sequence_id": "A244112", "text": "Reverse digit count of n in decimal representation.", "sequence": "10,11,12,13,14,15,16,17,18,19,1110,21,1211,1311,1411,1511,1611,1711,1811,1911,1210,1211,22,1312,1412,1512,1612,1712,1812,1912,1310,1311,1312,23,1413,1513,1613,1713,1813,1913,1410,1411,1412,1413,24,1514,1614,1714", "code": "\ndef A244112(n):\n    return int(''.join([str(str(n).count(d))+d for d in '9876543210' if str(n).count(d) > 0])) \n"}
{"sequence_id": "A244160", "text": "a(0)=0, and for n >= 1, a(n) = the largest k such that k-th Catalan number <= n.", "sequence": "0,1,2,2,2,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6", "code": "\nfrom sympy import catalan\ndef a(n):\n    if n==0: return 0\n    i=1\n    while True:\n        if catalan(i)>n: break\n        else: i+=1\n    return i - 1\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A244161", "text": "Greedy Catalan Base (A014418) interpreted as base-4 numbers, then shown in decimal.", "sequence": "0,1,4,5,8,16,17,20,21,24,32,33,36,37,64,65,68,69,72,80,81,84,85,88,96,97,100,101,128,129,132,133,136,144,145,148,149,152,160,161,164,165,256,257,260,261,264,272,273,276,277,280,288,289,292,293,320,321,324,325", "code": "\nfrom sympy import catalan\ndef a244160(n):\n    if n==0: return 0\n    i=1\n    while True:\n        if catalan(i)>n: break\n        else: i+=1\n    return i - 1\ndef a(n):\n    if n==0: return 0\n    x=a244160(n)\n    return 4**(x - 1) + a(n - catalan(x))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A244189", "text": "a(n) = most common final digit for a prime with n digits, or 0 if there is a tie.", "sequence": "0,3,7,3,7,3,7,7,3,3,1,7,3,7", "code": "\nimport sympy\nfrom sympy import isprime\ndef end(d,n):\n..lst = []\n..for k in range(10**(d-1),10**d):\n....num = ''\n....count = 0\n....for i in range(10**(n-d-1),10**(n-d)):\n......if isprime(int(str(i)+str(k))):\n........count += 1\n....lst.append(count)\n..a = max(lst)\n..lst[lst.index(a)] = 0\n..b = max(lst)\n..if a == b:\n....return 0\n..else:\n....return max(a,b) + 10**(d-1)\nn = 2\nwhile n < 10:\n..print(end(1,n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244190", "text": "a(n) = most common 2-digit ending for a prime with n digits, or 0 if there is a tie.", "sequence": "0,57,0,97,71,93,59,73,47,51,19,27", "code": "\nimport sympy\nfrom sympy import isprime\ndef end(d,n):\n..lst = []\n..for k in range(10**(d-1),10**d):\n....num = ''\n....count = 0\n....for i in range(10**(n-d-1),10**(n-d)):\n......if isprime(int(str(i)+str(k))):\n........count += 1\n....lst.append(count)\n..a = max(lst)\n..lst[lst.index(a)] = 0\n..b = max(lst)\n..if a == b:\n....return 0\n..else:\n....return max(a,b) + 10**(d-1)\nn = 3\nwhile n < 10:\n..print(end(2,n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244191", "text": "a(n) = most common final digit for a prime < 10^n, or 0 if there is a tie.", "sequence": "0,3,7,3,7,3,3,7,3,3,7,7,3,3", "code": "\nimport sympy\nfrom sympy import isprime\ndef prend(d,n):\n..lst = []\n..for k in range(10**n):\n....if isprime(k):\n......lst.append((k%10**d))\n..new = 0\n..newlst = []\n..for i in range(10**(d-1),10**d):\n....new = lst.count(i)\n....newlst.append(new)\n..newlst1 = newlst.copy()\n..a = max(newlst1)\n..newlst1[newlst1.index(a)] = 0\n..b = max(newlst1)\n..if a == b:\n....return 0\n..else:\n....return newlst.index(max(a,b)) + 10**(d-1)\nn = 2\nwhile n < 10:\n..print(prend(1,n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244192", "text": "a(n) = most common 2-digit ending for a prime < 10^n, or 0 if there is a tie.", "sequence": "0,0,0,97,71,91,77,61,47,47,19,27,37", "code": "\nimport sympy\nfrom sympy import isprime\ndef prend(d,n):\n..lst = []\n..for k in range(10**n):\n....if isprime(k):\n......lst.append((k%10**d))\n..new = 0\n..newlst = []\n..for i in range(10**(d-1),10**d):\n....new = lst.count(i)\n....newlst.append(new)\n..newlst1 = newlst.copy()\n..a = max(newlst1)\n..newlst1[newlst1.index(a)] = 0\n..b = max(newlst1)\n..if a == b:\n....return 0\n..else:\n....return newlst.index(max(a,b)) + 10**(d-1)\nn = 3\nwhile n < 10:\n..print(prend(2,n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244220", "text": "Binary complement of Greedy Catalan Base reduced modulo 2: a(n) = 1 - (A014418(n) modulo 2).", "sequence": "1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,1", "code": "\nfrom sympy import catalan\ndef a244160(n):\n    if n==0: return 0\n    i=1\n    while True:\n        if catalan(i)>n: break\n        else: i+=1\n    return i - 1\ndef a(n):\n    if n==0: return 0\n    x=a244160(n)\n    return 10**(x - 1) + a(n - catalan(x))\nprint([1 - a(n)%2 for n in range(101)]) \n"}
{"sequence_id": "A244221", "text": "Parity of Greedy Catalan Base representation for n: a(n) = A014418(n) reduced modulo 2.", "sequence": "0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0", "code": "\nfrom sympy import catalan\ndef a244160(n):\n    if n==0: return 0\n    i=1\n    while True:\n        if catalan(i)>n: break\n        else: i+=1\n    return i - 1\ndef a(n):\n    if n==0: return 0\n    x=a244160(n)\n    return 10**(x - 1) + a(n - catalan(x))\nprint([a(n)%2 for n in range(101)]) \n"}
{"sequence_id": "A244253", "text": "a(n) = the frequency of the most common final digit of a prime with n digits.", "sequence": "1,6,40,268,2103,17623,146590,1274284,11272025,101053126,915755611,8372478663,77114448042,714719245204", "code": "\nimport sympy\nfrom sympy import isprime\ndef end1(d,n):\n..lst = []\n..for k in range(10**(d-1),10**d):\n....num = ''\n....count = 0\n....for i in range(10**(n-d-1),10**(n-d)):\n......if isprime(int(str(i)+str(k))):\n........count += 1\n....lst.append(count)\n..return max(lst)\nn = 2\nwhile n < 10:\n..print(end1(1,n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244255", "text": "a(n) = the frequency of the most common 2-digit ending of a prime with n digits.", "sequence": "1,6,31,220,1748,14746,127601,1127869,10107163,91579392,837273621", "code": "\nimport sympy\nfrom sympy import isprime\ndef end1(d,n):\n..lst = []\n..for k in range(10**(d-1),10**d):\n....num = ''\n....count = 0\n....for i in range(10**(n-d-1),10**(n-d)):\n......if isprime(int(str(i)+str(k))):\n........count += 1\n....lst.append(count)\n..return max(lst)\nn = 3\nwhile n < 10:\n..print(end1(2,n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244265", "text": "Frequency of the most common final digit of a prime < 10^n.", "sequence": "1,7,46,310,2411,19665,166230,1440495,12712499,113765625,1029518337,9401997000,86516427946,801235615814", "code": "\nimport sympy\nfrom sympy import isprime\ndef prend1(d,n):\n..lst = [ ]\n..for k in range(10**n):\n....if isprime(k):\n......lst.append((k%10**d))\n..new = 0\n..newlst = [ ]\n..for i in range(10**(d-1),10**d):\n....new = lst.count(i)\n....newlst.append(new)\n..return max(newlst)\nn = 2\nwhile n < 10:\n..print(prend1(1,n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244267", "text": "a(n) = the frequency of the most common 2-digit ending of a prime < 10^n.", "sequence": "1,6,35,250,1986,16716,144183,1271765,11378311,102956670,940224567,8651691637,80123673992", "code": "\nimport sympy\nfrom sympy import isprime\ndef prend1(d,n):\n..lst = [ ]\n..for k in range(10**n):\n....if isprime(k):\n......lst.append((k%10**d))\n..new = 0\n..newlst = [ ]\n..for i in range(10**(d-1),10**d):\n....new = lst.count(i)\n....newlst.append(new)\n..return max(newlst)\nn = 3\nwhile n < 10:\n..print(prend1(2,n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244281", "text": "Answer to Red, Green and Blue Tiles Problem.", "sequence": "0,0,1,4,11,23,43,75,126,207,335,536,852,1350,2136,3378,5344,8462,13416,21300,33866,53923,85979,137274,219444,351203,562667,902327,1448298,2326472,3739820,6015701,9682260,15591825,25120251,40489004,65285631,105304917,169908475", "code": "\nimport math\nfor n in range(1, 40):\n    ans = 0\n    for k in range(0, n):\n        for i in range(2, 5):\n            for j in range(1, ((k/i)+1)):\n                c = k - (i * j) + j\n                ans = ans + (math.factorial(c) / (math.factorial(j) * math.factorial(k-(i*j))))\n    print ans\n"}
{"sequence_id": "A244356", "text": "Numbers n such that n and n+1 are not divisible by any of their nonzero digits.", "sequence": "37,46,53,56,57,58,67,68,73,78,86,97,307,337,346,358,373,376,379,388,397,406,429,433,446,457,466,469,473,477,478,489,493,498,506,507,508,538,553,556,557,558,577,578,586,587,588,596,597,598,646,656,657,658,667,668,669", "code": "\ndef a(n):\n..for i in range(10**3):\n....tot = 0\n....for k in range(i,i+n):\n......c = 0\n......for b in str(k):\n........if b != '0':\n..........if k%int(b)!=0:\n............c += 1\n......if c == len(str(k))-str(k).count('0'):\n........tot += 1\n....if tot == n:\n......print(i,end=', ')\na(2)\n"}
{"sequence_id": "A244357", "text": "Numbers n such that n, n+1, and n+2 are not divisible by any of their nonzero digits.", "sequence": "56,57,67,477,506,507,556,557,577,586,587,596,597,656,657,667,668,697,757,758,778,787,788,857,858,866,867,868,877,897,956,957,976,977,978,4077,4097,4457,4477,4497,4657,4677,4757,4857,4897,4997,5056,5057,5066,5067,5077,5096", "code": "\ndef a(n):\n..for i in range(10**4):\n....tot = 0\n....for k in range(i,i+n):\n......c = 0\n......for b in str(k):\n........if b != '0':\n..........if k%int(b)!=0:\n............c += 1\n......if c == len(str(k))-str(k).count('0'):\n........tot += 1\n....if tot == n:\n......print(i,end=', ')\na(3)\n"}
{"sequence_id": "A244358", "text": "Numbers n such that n, n+1, n+2, and n+3 are not divisible by any of their nonzero digits.", "sequence": "56,506,556,586,596,656,667,757,787,857,866,867,956,976,977,5056,5066,5096,5506,5666,5756,5776,5876,5906,5986,5996,6056,6067,6506,6697,6986,7057,7556,7576,7597,7757,7786,7787,7876,7897,7906,7976,7996,8066,8067,8506,8596,8666,8697", "code": "\ndef a(n):\n..for i in range(10**4):\n....tot = 0\n....for k in range(i,i+n):\n......c = 0\n......for b in str(k):\n........if b != '0':\n..........if k%int(b)!=0:\n............c += 1\n......if c == len(str(k))-str(k).count('0'):\n........tot += 1\n....if tot == n:\n......print(i,end=', ')\na(4)\n"}
{"sequence_id": "A244359", "text": "Numbers n such that n, n+1, n+2, n+3, and n+4 are not divisible by any of their nonzero digits.", "sequence": "866,976,7786,8066,8786,8986,9976,70786,77786,79976,80066,80986,87866,89066,89986,98786,99866,99976,700786,707786,709976,770786,778786,778996,780866,788986,789986,799786,799976,800066,800986,809986,879986,887986,888986,889786,890066,890786,890986", "code": "\ndef a(n):\n..for i in range(10**4):\n....tot = 0\n....for k in range(i,i+n):\n......c = 0\n......for b in str(k):\n........if b != '0':\n..........if k%int(b)!=0:\n............c += 1\n......if c == len(str(k))-str(k).count('0'):\n........tot += 1\n....if tot == n:\n......print(i,end=', ')\na(5)\n"}
{"sequence_id": "A244369", "text": "Palindromic right-angled primes.", "sequence": "101,787,34543,7654567,345676543,34567876543", "code": "\nfrom sympy import isprime\nA244369 = []\nfor n in range(1,10):\n....for m in range(n-1,-1,-1):\n........l = ''.join([str(d) for d in range(n,m-1,-1)])\n........p = int(l+l[-2::-1])\n........if isprime(p):\n............A244369.append(p)\n....for m in range(n+1,10):\n........l = ''.join([str(d) for d in range(n,m+1)])\n........p = int(l+l[-2::-1])\n........if isprime(p):\n............A244369.append(p)\nA244369 = sorted(A244369) \n"}
{"sequence_id": "A244411", "text": "Nonprimes n such that the product of its divisors is a palindrome.", "sequence": "1,4,22,26,49,111,121,202,1001,1111,2285,10001,10201,11111,100001,1000001,1001001,1012101,1100011,1101011,1109111,1111111,3069307,10000001,12028229,12866669,100000001,101000101,110000011,110091011,200010002,10000000001,10011111001", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import divisors\ndef rev(n):\n..r = \"\"\n..for i in str(n):\n....r = i + r\n..return int(r)\ndef a():\n..for n in range(1,10**8):\n....if not isprime(n):\n......p = 1\n......for i in divisors(n):\n........p*=i\n......if rev(p)==p:\n........print(n,end=', ')\na()\n"}
{"sequence_id": "A244411", "text": "Nonprimes n such that the product of its divisors is a palindrome.", "sequence": "1,4,22,26,49,111,121,202,1001,1111,2285,10001,10201,11111,100001,1000001,1001001,1012101,1100011,1101011,1109111,1111111,3069307,10000001,12028229,12866669,100000001,101000101,110000011,110091011,200010002,10000000001,10011111001", "code": "\nfrom sympy import divisor_count, sqrt\nA244411_list = [1]\nfor n in range(1,10**5):\n    d = divisor_count(n)\n    if d > 2:\n        q, r = divmod(d,2)\n        s = str(n**q*(sqrt(n) if r else 1))\n        if s == s[::-1]:\n            A244411_list.append(n) \n"}
{"sequence_id": "A244423", "text": "Nonprime palindromes n such that the product of divisors of n is also a palindrome.", "sequence": "1,4,22,111,121,202,1001,1111,10001,10201,11111,100001,1000001,1001001,1012101,1100011,1101011,1111111,10000001,100000001,101000101,110000011,200010002,10000000001,10011111001,11000100011,11001010011,11100100111,11101010111,20000100002", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import divisors\ndef rev(n):\n..r = \"\"\n..for i in str(n):\n....r = i + r\n..return int(r)\ndef a():\n..for n in range(1,10**8):\n....if rev(n) == n and not isprime(n):\n......p = 1\n......for i in divisors(n):\n........p*=i\n......if rev(p)==p:\n........print(n,end=', ')\na()\n"}
{"sequence_id": "A244423", "text": "Nonprime palindromes n such that the product of divisors of n is also a palindrome.", "sequence": "1,4,22,111,121,202,1001,1111,10001,10201,11111,100001,1000001,1001001,1012101,1100011,1101011,1111111,10000001,100000001,101000101,110000011,200010002,10000000001,10011111001,11000100011,11001010011,11100100111,11101010111,20000100002", "code": "\nfrom sympy import divisor_count, sqrt\ndef palgen(l,b=10): \n    if l > 0:\n        yield 0\n        for x in range(1,l+1):\n            n = b**(x-1)\n            n2 = n*b\n            for y in range(n,n2):\n                k, m = y//b, 0\n                while k >= b:\n                    k, r = divmod(k,b)\n                    m = b*m + r\n                yield y*n + b*m + k\n            for y in range(n,n2):\n                k, m = y, 0\n                while k >= b:\n                    k, r = divmod(k,b)\n                    m = b*m + r\n                yield y*n2 + b*m + k\nA244423_list = [1]\nfor n in palgen(6):\n    d = divisor_count(n)\n    if d > 2:\n        q, r = divmod(d,2)\n        s = str(n**q*(sqrt(n) if r else 1))\n        if s == s[::-1]:\n            A244423_list.append(n) \n"}
{"sequence_id": "A244428", "text": "Sum of divisors of n and product of divisors of n are both perfect cubes.", "sequence": "1,1164,8148,11596,12028,28128,32980,34144,34528,36244,38764,39916,41164,41516,73200,75252,81172,84196,94023,100348,181948,182430,192175,193380,193612,194044,195780,196896,200574,204180,208416,211620,214176,217668,220116,225696,230860,235716", "code": "\nfrom gmpy2 import iroot\nfrom sympy import divisor_sigma\nA244428_list = [i for i in range(1,10**4) if (iroot(i,3)[1] or not divisor_sigma(i,0) % 3) and iroot(int(divisor_sigma(i,1)),3)[1]] \n"}
{"sequence_id": "A244440", "text": "Numbers n such that n + phi(n) is a power of 10.", "sequence": "68,668,6668,67744,72352,666668,7143040,66666752,71430400,666666752,714304000,6666666668,7143040000,71430400000,666666666668,666666668032,714304000000,714499133440,7143040000000,7144991334400", "code": " from sympy import totient\n[n for n in range(1,10**7) if 10**(int(log10(n+totient(n)))) == n+totient(n)] \n"}
{"sequence_id": "A244444", "text": "Numbers n such that n+sigma(n) is a repunit number.", "sequence": "4,5,506311,4761903,506767303,5517762660583,5554746531623,5555541480743", "code": " from sympy import divisors\n[n for n in range(1,10**6) if len(set(str(n+sum(divisors(n))))) == 1 and str(n+sum(divisors(n)))[0] == '1'] \n"}
{"sequence_id": "A244466", "text": "Nonprimes n such that mu(phi(n)) = 1.", "sequence": "1,9,14,18,22,46,94,118,166,214,334,358,422,454,526,662,694,718,766,926,934,958,961,1006,1094,1126,1142,1174,1382,1438,1678,1718,1726,1774,1822,1849,1922,1934,1966,2038,2246,2374,2462,2566,2582,2606,2614,2638,2654,2734,2878,2966,2974,3046", "code": "\nfrom sympy import totient,factorint,primefactors,isprime\n[n for n in range(1,10**5) if n == 1 or (not isprime(n) and max(factorint(totient(n)).values()) < 2 and (-1)**len(primefactors(totient(n))) == 1)] \n"}
{"sequence_id": "A244505", "text": "Greater of twin primes of (40n-23,40n-21).", "sequence": "19,139,619,859,1699,2659,3259,4219,4339,5419,5659,7459,8539,9859,10459,10939,11059,11779,12379,13219,13339,15139,15739,17419,17659,19699,20899,21019,21379,21739,22699,23059,23539,24979,25579,27739,28099,30139,32059", "code": " from sympy import isprime\nfor n in range(1,2001):\n..if isprime(40*n-23) and isprime(40*n-21): print(40*n-21,end=\",\")\n"}
{"sequence_id": "A244551", "text": "Numbers k such that k +- (sum of digits of k) are both palindromes.", "sequence": "1,2,3,4,10,100,105,181,262,267,343,348,424,429,681,762,767,843,848,924,929,1000,10000,100000,1000000,10000000,63999991,72999982,81999973,90999964,100000000,1000000000,10000000000,100000000000,1000000000000,10000000000000,100000000000000,1000000000000000,10000000000000000", "code": "\ndef palgen(l,b=10): \n    if l > 0:\n        yield 0\n        for x in range(1,l+1):\n            n = b**(x-1)\n            n2 = n*b\n            for y in range(n,n2):\n                k, m = y//b, 0\n                while k >= b:\n                    k, r = divmod(k,b)\n                    m = b*m + r\n                yield y*n + b*m + k\n            for y in range(n,n2):\n                k, m = y, 0\n                while k >= b:\n                    k, r = divmod(k,b)\n                    m = b*m + r\n                yield y*n2 + b*m + k\nA244551_list = []\nfor p in palgen(9):\n    l = len(str(p))\n    for i in range(1,l*9+1):\n        n = p-i\n        if n > 0:\n            if sum((int(d) for d in str(n))) == i:\n                s = str(n-i)\n                if s == s[::-1]:\n                    A244551_list.append(n) \n"}
{"sequence_id": "A244603", "text": "Least number k such that n^k contains the digit n n times.", "sequence": "1,18,21,32,30,38,33,55,69", "code": "\ndef tes(n):\n..for k in range(1,10**3):\n....if(str(n**k).count(str(n)) == n:\n......return k\nn = 1\nwhile n < 10:\n..print(tes(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244604", "text": "Least number k such that k^n contains the digit n n times.", "sequence": "1,1,15,179,261,435,426,1083,2169,2137", "code": "\ndef tes(n):\n..for k in range(1,10**4):\n....if(str(k**n).count(str(n)) == n:\n......return k\nn = 0\nwhile n < 10:\n..print(tes(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244606", "text": "Least number k > 1 such that k^n contains the digit k k times, or 0 if no such digit exists.", "sequence": "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,2,0,0,0,0,0,2,0,0,5,3,2,7,0,0,5,3,6,4,0,3,5,3,0,2,6,5,3,0,0,0,6,2,3,4,2,4,2,2,2,3,4,3,5,2,2,4,5,2,2,0,4,0,3,7,2,5,3,4,0,4,2,4,2,7,7,7,2,0,3,2,8,6,6,2,0,3,7,2,4,0,6,0,0,0,8,5,4,3,0,0,6,5,2,5,0,8,3", "code": "\ndef tes(n):\n..for k in range(2,10):\n....if str(k**n).count(str(k)) == k:\n......return k\nn = 1\nwhile n < 200:\n..if tes(n):\n....print(tes(n),end=', ')\n..else:\n....print(0,end=', ')\n..n += 1\n"}
{"sequence_id": "A244613", "text": "Least number k > 0 such that 2^k ends in exactly n consecutive increasing digits.", "sequence": "1,8,28,328,1328,11328", "code": "\ndef a(n):\n..for k in range(1,10**5):\n....st = str(2**k)\n....if len(st) > n:\n......count = 0\n......for i in range(len(st)):\n........if int(st[len(st)-1-i]) == int(st[len(st)-2-i])+1:\n..........count += 1\n........else:\n..........break\n......if count == n:\n........return k\nn = 0\nwhile n < 10:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244655", "text": "Least number k such that 3^k ends in exactly n consecutive decreasing digits.", "sequence": "1,5,27,496,4996,49996,499996,4999996,49999996", "code": "\ndef a(n):\n..for k in range(1, 10**9):\n....st = str(3**k)\n....if len(st) > n:\n......count = 0\n......for i in range(len(st)):\n........if int(st[len(st)-1-i]) == int(st[len(st)-2-i])-1:\n..........count += 1\n........else:\n..........break\n......if count == n:\n........return k\nn = 0\nwhile n < 10:\n..print(a(n), end=', ')\n..n += 1\n"}
{"sequence_id": "A244660", "text": "Numbers x such that the base 10 representation of x^2 forms an arithmetic sequence when split into equal-sized chunks.", "sequence": "11142,11553,14088,16713,18801,22284,23097,23718,26787,28818,323589,327939,328992,416103,438357,459069,502149,595194,617928,647178,656457,665853,677019,682230,747099,767748,775782,799233,813861,832986,847266,855897,858648,862014,924366,970767,10174023,10240146", "code": "\nfrom itertools import count\n.\ndef check(n,power):\n...np = str(n**power)\n...l=len(np)\n...for chunks in range(3,5):\n......if l%chunks==0:\n.........step = l//chunks\n.........bits = [int(np[i:i+step]) for i in range(0,l,step)]\n.........diff = bits[1]-bits[0]\n.........old=bits[1]\n.........go = True\n.........for bit in bits[2:]:\n............if bit-old!=diff:\n...............go=False\n...............break\n............old = bit\n.........if go:\n............return True\n.\nfor n in count(1):\n...if check(n,2):\n......print(n)\n"}
{"sequence_id": "A244761", "text": "Numbers obtained by concatenating the squares of the digits of Lucas(n).", "sequence": "4,1,9,16,49,11,164,481,1649,4936,149,18181,944,2541,64169,193616,44049,925491,25494964,8191681,1251449,416164936,9813609,361604981,10936644,1364949361,449116169,169814016,4910361649,11168164251,164360168164,901091681", "code": "\nfrom sympy import lucas\ndef a(n):  return int(\"\".join(str(int(d)**2) for d in str(lucas(n))))\nprint([a(n) for n in range(32)]) \n"}
{"sequence_id": "A244848", "text": "Least number k > 0 such that 2^k begins with exactly n consecutive decreasing digits.", "sequence": "1,5,201,664,37025,78171,3944467,138044449,1910108568,1641098748", "code": "\ndef a(n):\n..for k in range(1,10**5):\n....st = str(2**k)\n....count = 0\n....if len(st) > n:\n......for i in range(len(st)):\n........if int(st[i]) == int(st[i+1])+1:\n..........count += 1\n........else:\n..........break\n......if count == n:\n........return k\nn = 0\nwhile n < 10:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244849", "text": "Least number k > 0 such that 2^k begins with exactly n consecutive increasing digits.", "sequence": "1,7,90,155,8290,63293,4338436,5194868,62759188", "code": "\ndef a(n):\n..for k in range(1,10**5):\n....st = str(2**k)\n....count = 0\n....if len(st) > n:\n......for i in range(len(st)):\n........if int(st[i]) == int(st[i+1])-1:\n..........count += 1\n........else:\n..........break\n......if count == n:\n........return k\nn = 0\nwhile n < 10:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244851", "text": "Least number k > 0 such that 3^k begins with exactly n consecutive decreasing digits.", "sequence": "1,7,314,1655,11569,383374,3052836,31843469,458415111,164840426684", "code": "\ndef a(n):\n..for k in range(1,10**5):\n....st = str(3**k)\n....count = 0\n....if len(st) > n:\n......for i in range(len(st)):\n........if int(st[i]) == int(st[i+1])+1:\n..........count += 1\n........else:\n..........break\n......if count == n:\n........return k\nn = 0\nwhile n < 10:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244852", "text": "Least number k > 0 such that 3^k begins with exactly n consecutive increasing digits.", "sequence": "1,17,149,146,7997,45419,3972963,27487124,406680034", "code": "\ndef a(n):\n..for k in range(1,10**5):\n....st = str(3**k)\n....count = 0\n....if len(st) > n:\n......for i in range(len(st)):\n........if int(st[i]) == int(st[i+1])-1:\n..........count += 1\n........else:\n..........break\n......if count == n:\n........return k\nn = 0\nwhile n < 10:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244912", "text": "Sum of leading digit in representations of n in bases 2,3,...,n.", "sequence": "1,2,3,4,6,7,9,9,11,12,15,16,18,20,20,21,25,26,29,31,33,34,38,36,38,39,42,43,47,48,52,54,56,58,58,59,61,63,67,68,72,73,76,79,81,82,88,84,88,90,93,94,99,101,105,107,109,110,116,117,119,122,117,119,123", "code": "\nimport math\ndef modlg(a, b):\n....return a // b**int(math.log(a, b))\nfor n in range(1,77):\n....s=0\n....for k in range(2,n+1):\n........s += modlg(n,k)\n....print str(s)+',',\n"}
{"sequence_id": "A244915", "text": "Smallest positive integer a(n) such that b(n) = a(n)^2 + a(n-1)^2 is a prime different from the primes b(1), b(2), ..., b(n-1), where a(0) = 1.", "sequence": "1,1,2,3,8,5,2,7,8,13,2,15,4,1,6,5,4,9,10,1,14,9,16,1,20,3,10,7,12,13,10,17,2,27,10,19,6,11,4,21,10,29,4,25,6,29,16,5,18,7,20,11,14,15,22,5,24,1,26,5,28,13,20,19,14,25,12,17,8,23,12,43,8", "code": "\nfrom sympy import isprime\nA244915 = [1]\nblist = []\nfor n in range(1,100):\n....a, b = 1, 1 + A244915[-1]**2\n....while not isprime(b) or b in blist:\n........b += 2*a+1\n........a += 1\n....blist.append(b)\n....A244915.append(a)\n\n"}
{"sequence_id": "A244932", "text": "Least number k > n such that k^8 + n^8 is prime.", "sequence": "2,13,10,17,6,37,12,13,16,27,24,71,16,31,64,43,18,43,26,23,32,29,24,79,32,53,34,61,92,47,40,33,34,57,36,47,40,53,40,79,44,43,68,91,68,57,66,61,60,53,58,83,60,91,94,61,82,61,70,101,82,71,68,145,82,67,76,69,100", "code": "\nimport sympy\nfrom sympy import isprime\ndef a(n):\n..for k in range(n+1,10**4):\n....if isprime(k**8+n**8):\n......return k\nn = 1\nwhile n < 100:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244947", "text": "Least number k > n such that k^16 + n^16 is prime.", "sequence": "2,85,4,33,6,7,8,13,22,13,16,41,28,15,22,19,24,23,54,31,22,27,56,61,38,29,40,37,34,61,32,35,82,35,46,43,40,49,58,67,42,55,58,49,46,61,58,61,68,73,92,63,94,77,166,57,82,63,72,109,76,121,82,79,86,67,72,77,82,71,98", "code": "\nimport sympy\nfrom sympy import isprime\ndef a(n):\n..for k in range(n+1,10**4):\n....if isprime(k**16+n**16):\n......return k\nn = 1\nwhile n < 100:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244948", "text": "Least number k > n such that k^32 + n^32 is prime.", "sequence": "30,29,40,33,34,131,50,9,44,11,38,13,18,97,166,221,200,37,82,61,176,23,102,65,94,151,352,87,38,37,38,39,46,37,48,137,54,55,68,43,60,55,146,51,106,87,82,65,134,53,106,103,90,71,96,71,148,91,94,139,74,69,94,75,86,169,100", "code": "\nimport sympy\nfrom sympy import isprime\ndef a(n):\n..for k in range(n+1,10**4):\n....if isprime(k**32+n**32):\n......return k\nn = 1\nwhile n < 100:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244949", "text": "Least number k > n such that k^64 + n^64 is prime.", "sequence": "102,37,32,39,118,13,16,11,154,41,94,29,158,17,64,291,70,107,66,63,58,87,38,397,282,69,32,129,142,67,210,87,200,227,82,55,70,137,388,541,140,103,64,167,286,71,60,593,262,459,62,69,92,91,128,81,98,149,164,107,192,103", "code": "\nimport sympy\nfrom sympy import isprime\ndef a(n):\n..for k in range(n+1,10**4):\n....if isprime(k**64+n**64):\n......return k\nn = 1\nwhile n < 100:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A244950", "text": "Least number k > n such that k^128 + n^128 is prime.", "sequence": "120,113,106,259,304,85,212,135,158,47,62,985,84,47,518,485,178,169,106,27,88,139,632,47,44,643,194,209,606,1529,32,113,1094,139,754,647,38,45,262,69,94,631,90,527,326,195,54,277,232,187,554,189,78,799,216,131,1132,173", "code": "\nimport sympy\nfrom sympy import isprime\ndef a(n):\n    for k in range(n+1,10**4):\n        if isprime(k**128+n**128):\n            return k\nfor n in range(1, 100):\n    print(a(n), end=', ')\n"}
{"sequence_id": "A244959", "text": "Smallest positive multiple of n whose base 8 representation contains only 0's and 1's.", "sequence": "0,1,8,9,8,65,72,299593,8,9,520,4169,72,65,2396744,585,64,4097,72,513,520,17044041,33352,33281,72,266825,520,513,2396744,266249,4680,4681,64,32769,32776,16814665,72,262145,4104,585,520,32841,136352328,36937,33352,585", "code": "\ndef A244959(n):\n....if n > 0:\n........for i in range(1,2**n):\n............x = int(bin(i)[2:],8)\n............if not x % n:\n................return x\n....return 0 \n"}
{"sequence_id": "A245018", "text": "Decimal expansion of the infinite product of (1+1/n^2)^(n^2)/e for n >= 1.", "sequence": "5,4,5,7,8,1,8,3,8,8,3,3,9,8,7,0,8,2,5,2,3,4,9,0,3,9,7,2,5,5,6,5,8,7,7,4,0,3,3,6,8,7,9,1,3,2,9,8,0,4,3,9,3,2,7,6,7,5,9,5,2,6,2,3,5,0,6,1,8,4,4,6,8,7,4,1,0,8,4,0,5,2,5,1,2,7,0,3,1,0,6,0,2,6,1,0,0,3,0,6", "code": "\nfrom mpmath import *\nmp.dps=101\nC = exp(1/2 + 2*pi/3 - zeta(3)/(2*pi**2) + polylog(3, e**(-2*pi))/(2*pi**2) + polylog(2, e**(-2*pi))/pi)/(2*sinh(pi))\nprint([int(n) for n in list(str(C)[2:-1])]) \n"}
{"sequence_id": "A245042", "text": "Primes of the form (k^2+4)/5.", "sequence": "17,73,89,193,337,521,953,1009,1249,1657,2377,2833,3329,3433,4441,4561,5849,6553,7297,8081,8737,9769,11617,12401,12601,13417,15569,16937,17881,18121,20353,21649,27529,28729,29033,30577,33457,35449,36809,46273,49801", "code": "\nimport sympy\nL = (k**2 + 4 for k in range(10**3))\n[n//5 for n in L if n % 5 == 0 and sympy.ntheory.isprime(n//5)]\n"}
{"sequence_id": "A245045", "text": "Primes of the form (k^2+2)/6.", "sequence": "3,11,17,43,67,113,131,193,241,353,523,641,683,1291,1601,1667,1873,2017,2243,2731,3083,3361,3851,4483,4817,4931,5281,5521,7211,8363,8513,8971,9283,9923,10753,11971,13633,16433,17713,18371,18593,19267,21841,22571", "code": "\nimport sympy\n[(k**2+2)/6 for k in range(10**6) if sympy.ntheory.isprime((k**2+2)/6) & ((k**2+2)/6).is_integer()]\n"}
{"sequence_id": "A245048", "text": "Primes p such that p^2 + 28 is prime.", "sequence": "3,5,11,13,17,19,23,41,43,47,53,67,79,83,89,97,109,131,137,149,157,163,167,179,181,193,211,223,239,241,251,263,277,281,311,317,331,379,397,401,409,421,431,439,443,449,457,467,479,541,569,599,643,647,673", "code": "\nimport sympy\n[sympy.prime(n) for n in range(1,10**6) if sympy.ntheory.isprime(sympy.prime(n)**2+28)]\n"}
{"sequence_id": "A245061", "text": "Prime numbers p such that p - primepi(p) is a square, where primepi is the prime counting function.", "sequence": "2,3,37,541,647,881,1151,1301,1627,2377,3271,5179,5641,10501,11597,11821,18503,20543,23339,31259,35461,38669,39499,42901,43331,44201,45523,51973,53407,67213,67757,70489,72169,77291,98893,99551,128291,139721,145207,150011", "code": "\nimport sympy,gmpy2\n[sympy.prime(n) for n in range(1,10**6) if gmpy2.is_square(sympy.prime(n)-n)] \n"}
{"sequence_id": "A245085", "text": "Maximal t in [2, prime(n)-1] such that all the smallest positive residues of 2!,3!,...,t! modulo prime(n) are distinct.", "sequence": "4,5,3,8,5,4,7,5,9,12,6,10,9,11,4,15,7,8,7,13,18,9,18,13,17,9,10,10,23,11,11,18,17,17,18,21,15,14,28,13,26,36,8,13,32,22,16,6,24,15,22,28,21,15,28,16,42,23,32,25,8,20,18,20,33,26,10,35,14,5,29", "code": "\nfrom sympy import prime\ndef A245085(n):\n....p, f, fv = prime(n), 1, {}\n....for i in range(2,p):\n........f = (f*i) % p\n........if f in fv:\n............return i-1\n........else:\n............fv[f] = i\n....return p-1 \n"}
{"sequence_id": "A245195", "text": "a(n) = 2^A014081(n).", "sequence": "1,1,1,2,1,1,2,4,1,1,1,2,2,2,4,8,1,1,1,2,1,1,2,4,2,2,2,4,4,4,8,16,1,1,1,2,1,1,2,4,1,1,1,2,2,2,4,8,2,2,2,4,2,2,4,8,4,4,4,8,8,8,16,32,1,1,1,2,1,1,2,4,1,1,1,2,2,2,4,8,1,1,1,2,1,1,2,4,2,2,2,4,4,4,8,16,2,2,2,4,2", "code": "\nfrom __future__ import division\ndef A277560(n):\nreturn sum(int(not (~n & 2*k) | (~n & k)) for k in range(n//2+1))\n"}
{"sequence_id": "A245199", "text": "Numbers n where phi(n) and tau(n) are perfect squares.", "sequence": "1,8,10,34,57,74,85,125,185,202,219,394,451,456,489,505,514,546,570,629,640,679,680,802,985,1000,1026,1057,1154,1285,1354,1365,1387,1417,1480,1717,1752,1938,2005,2016,2047,2176,2190,2340,2457,2509,2565,2594,2649", "code": "\nfrom sympy import totient, divisor_count\nfrom gmpy2 import is_square\n[n for n in range(1,10**4) if is_square(int(divisor_count(n))) and is_square(int(totient(n)))] \n"}
{"sequence_id": "A245200", "text": "Smallest positive solution to k == 0 mod 3 and k == 1 mod prime(n).", "sequence": "6,15,12,27,18,39,24,30,63,75,42,87,48,54,60,123,135,72,147,159,84,90,195,102,207,108,219,114,255,132,138,279,150,303,315,327,168,174,180,363,192,387,198,399,423,447,228,459,234,240,483,252,258,264,270,543", "code": "\nfrom sympy import prime, primerange\ndef f(p): return 2*p+1 if p%3 == 1 else p+1\ndef aupton(nn): return [f(p) for p in primerange(5, prime(nn)+1)]\nprint(aupton(58)) \n"}
{"sequence_id": "A245202", "text": "Numbers n such that tau(n) + phi(n) is a perfect square.", "sequence": "3,9,21,24,26,30,51,72,77,84,90,93,100,119,122,162,168,174,194,210,213,221,276,282,291,301,381,384,386,408,414,437,469,510,527,533,564,594,597,616,723,731,744,770,791,794,858,869,896,917,930,948,952,954", "code": "\nfrom sympy import totient, divisor_count\nfrom gmpy2 import is_square\n[n for n in range(1,10**4) if is_square(int(divisor_count(n)+totient(n)))] \n"}
{"sequence_id": "A245270", "text": "Like A067599 but write everything in binary, then display the answer in base 10.", "sequence": "5,7,10,11,47,15,11,14,91,23,87,27,95,123,20,35,94,39,171,127,183,47,95,22,187,15,175,59,763,63,21,247,355,191,174,75,359,251,187,83,767,87,343,235,367,95,167,30,182,483,347,107,95,375,191,487,379,119", "code": "\nimport sympy\n[int(''.join([bin(y)[2:] for x in sorted(sympy.ntheory.factorint(n).items()) for y in x]),2) for n in range(2,200)] \n\n"}
{"sequence_id": "A245364", "text": "Let p  =  first digit of n, q  =  number obtained if p is removed from n; let r  =  last digit of n, s  =  number obtained if r is removed from n; sequence give n such that p*q = r*s != 0, p! = q, and r! = s.", "sequence": "111,164,195,222,265,333,444,498,555,666,777,888,999,1111,1664,1995,2222,2665,3333,4444,4847,4998,5555,6545,6666,7424,7777,8888,9999,11111,16664,19995,22222,26665,33333,43243,44444,49998,55555,66666,77777,86486,88888,99999,111111,166664", "code": "\nfor n in range(100,10**5):\n..s = str(n)\n..num = int(s[:1])*int(s[1:])\n..if num != 0 and num == int(s[:len(s)-1])*int(s[len(s)-1:]):\n....print(n,end=', ')\n"}
{"sequence_id": "A245385", "text": "Numbers N such that N = P//Q = R//S, where // is the concatenation function, satisfying the following properties: P and S are m-digit integers, Q and R are k-digit integers, k and m are distinct positive integers, and P*Q = R*S.", "sequence": "111,164,195,222,265,333,444,498,555,666,777,888,999,1111,1664,1995,2222,2665,3333,4444,4847,4998,5555,6545,6666,7424,7777,8888,9999,11111,16664,19995,21775,22222,24996,26665,33333,43243,44444,49998,55555,66666,77777,86486,88888,99999", "code": "\nfor n in range(1,10**5):\n..s = str(n)\n..count = 0\n..for i in range(1,len(s)):\n....num = int(s[:i])*int(s[i:])\n....if i != len(s) - i:\n......if num != 0:\n........if num == int(s[:len(s)-i])*int(s[len(s)-i:]):\n..........count += 1\n..........break\n..if count > 0:\n....print(n,end=', ')\n"}
{"sequence_id": "A245386", "text": "Numbers in A245385 where P, Q, R, and S are all distinct.", "sequence": "164,195,265,498,1664,1995,2665,4847,4998,6545,7424,16664,19995,21775,24996,26665,43243,49998,86486,148480,166664,175150,199995,217775,249996,266665,368180,484847,499998,654545,742424,1001001,1081075,1216216,1249992,1297290,1451850,1471468,1481477", "code": "\nfor n in range(1,10**7):\n..s = str(n)\n..count = 0\n..for i in range(1,len(s)):\n....if i != len(s) - i:\n......if int(s[:i]) != int(s[len(s)-i:]):\n........num = int(s[:i])*int(s[i:])\n........if num != 0:\n..........if num == int(s[:len(s)-i])*int(s[len(s)-i:]):\n............count += 1\n............break\n..if count > 0:\n....print(n,end=', ')\n"}
{"sequence_id": "A245390", "text": "Number of ways to build an expression using non-redundant parentheses in an expression of n variables, counted in decreasing sub-partitions of equal size.", "sequence": "1,1,3,11,39,145,514,1901,6741,24880,87791,325634,1152725,4251234,15052387,55750323,197031808,729360141,2579285955,9539017676,33822222227,124889799518,440743675148,1635528366655,5790967247863,21360573026444,75643815954959,280096917425535", "code": "\nimport math\nimport operator as op\ndef binom(n, r):\n....r = min(r, n-r)\n....if r == 0: return 1\n....numer = reduce(op.mul, range(n, n-r, -1))\n....denom = reduce(op.mul, range(1, r+1))\n....return numer//denom\nmax = 100\nseq = [0,1,1]\nfor n in range(3, max) :\n....sum = 0\n....for choose in range(2, n+1):\n........f = math.ceil(n/choose)\n........f+=1\n........for times in range(1, int(f)) :\n............if choose*times > n :\n................continue\n............if choose==n and times==1 :\n................sum += 1\n............else :\n................sum += binom(n - (choose*times) + times, times) * (seq[choose]**times)\n....seq.append(sum)\nfor (i, x) in enumerate(seq) :\n....if i==0:\n........continue\n....print i, x\n"}
{"sequence_id": "A245459", "text": "Number of primes of the form k^n - 2^k for positive integers k.", "sequence": "0,0,1,4,3,2,3,5,1,4,2,4,0,6,2,2,1,2,3,5,1,9,1,4,2,3,1,2,2,2,1,4,1,5,1,2,3,3,1,2,2,1,0,3,0,1,1,2,1,4,0,1,0,3,0,3,0,2,1,4,5,3,0,3,5,9,1,5,1,6,1,0,1,4,1,1,0,4,1,4,0,3,1,0,0,7,1,4", "code": "\nimport sympy\ndef a(n):\n..k = 2\n..count = 0\n..while k**n > 2**k:\n....if sympy.isprime(k**n-2**k):\n......count += 1\n....k += 1\n..return count\nn = 1\nwhile n < 100:\n..print(a(n),end=', ')\n..n += 1 \n"}
{"sequence_id": "A245562", "text": "Table read by rows: row n gives list of lengths of runs of 1's in binary expansion of n, starting with high-order bits.", "sequence": "0,1,1,2,1,1,1,2,3,1,1,1,1,1,1,2,2,2,1,3,4,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,3,2,2,1,2,1,2,2,3,3,1,4,5,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,3,1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,1,3,1,4,2,2,1", "code": "\nfrom re import split\nA245562_list = [0]\nfor n in range(1,100):\n....A245562_list.extend(len(d) for d in split('0+',bin(n)[2:]) if d != '')\n\n"}
{"sequence_id": "A245563", "text": "Table read by rows: row n gives list of lengths of runs of 1's in binary expansion of n, starting with low-order bits.", "sequence": "0,1,1,2,1,1,1,2,3,1,1,1,1,1,2,1,2,1,2,3,4,1,1,1,1,1,2,1,1,1,1,1,1,2,1,3,1,2,1,2,1,2,2,2,3,1,3,4,5,1,1,1,1,1,2,1,1,1,1,1,1,2,1,3,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,3,1,4,1,2,1,2,1,2,2,2,1,2,1,1,2,2,2,3,2,3,1,3,1,3,2,3,4,1,4,5,6,1,1,1,1,1,2,1,1,1,1,1,1,2,1,3,1,1,1,1,1,1,1", "code": "\nfrom re import split\nA245563_list = [0]\nfor n in range(1,100):\n....A245563_list.extend(len(d) for d in split('0+',bin(n)[:1:-1]) if d != '')\n\n"}
{"sequence_id": "A245568", "text": "Initial members of prime quadruples (n, n+2, n+24, n+26).", "sequence": "5,17,617,857,1277,1427,1697,2087,2687,3557,4217,5417,5477,7307,8837,9437,10067,13877,17657,18287,20747,21587,23537,25577,27917,28547,30467,32117,32297,35507,37337,37547,40127,41177,41387,41957", "code": "\nfrom sympy import isprime\nfor n in range(1,10000001,2):\n..if isprime(n) and isprime(n+2) and isprime(n+24) and isprime(n+26): print(n,end=', ')\n"}
{"sequence_id": "A245571", "text": "a(n) is the smallest prime number with at least two digits formed by the concatenation of the subsequent digits of Pi, starting at the n-th digit, ignoring the decimal point.", "sequence": "31,14159,41,1592653,59,9265358979323,26535897932384626433832795028841971693993751058209,653,53,35897,5897,89,97,79,9323,32384626433832795028841971693993751058209749445923078164062862089986280348253421,23,38462643383", "code": "\nfrom sympy.mpmath import *\nfrom sympy import isprime\ndef A245571(n):\n....mp.dps = 1000+n\n....s = nstr(pi,mp.dps)[:-1].replace('.','')[n-1:]\n....for i in range(len(s)-1):\n........p = int(s[:i+2])\n........if p > 10 and isprime(p):\n............return p\n....else:\n........return 'Ran out of digits'\n\n"}
{"sequence_id": "A245576", "text": "Primes p such that p and p^2 lack the zero digit in their decimal expansions.", "sequence": "2,3,5,7,11,13,17,19,23,29,31,37,41,43,59,61,67,73,79,83,89,113,127,131,137,139,157,163,167,173,181,191,193,211,223,227,229,233,239,263,269,271,277,281,293,311,313,337,359,367,373,379,383,389,419,421,431,433", "code": "\nfrom sympy import prime\nA245576_list = [p for p in (prime(i) for i in range(1,10**4)) if not(str(p).count('0') or str(p**2).count('0'))]\n\n"}
{"sequence_id": "A245579", "text": "Number of odd divisors of n multiplied by n.", "sequence": "1,2,6,4,10,12,14,8,27,20,22,24,26,28,60,16,34,54,38,40,84,44,46,48,75,52,108,56,58,120,62,32,132,68,140,108,74,76,156,80,82,168,86,88,270,92,94,96,147,150,204,104,106,216,220,112,228,116,118,240,122", "code": "\nfrom sympy import divisors\ndef a(n): return n*len(list(filter(lambda i: i%2==1, divisors(n)))) \n"}
{"sequence_id": "A245622", "text": "Primes having more 1's digits than 3's.", "sequence": "11,17,19,41,61,71,101,107,109,113,127,131,149,151,157,167,179,181,191,197,199,211,241,251,271,281,311,401,419,421,461,491,521,541,571,601,617,619,641,661,691,701,719,751,761,811,821,881,911,919,941,971,991", "code": "\nimport sympy\nfrom sympy import prime\nfor n in range(1,10**3):\n..s = str(prime(n))\n..if s.count('1') > s.count('3'):\n....print(int(s),end=', ')\n\n"}
{"sequence_id": "A245623", "text": "Primes having more digits 3's than 1's.", "sequence": "3,23,37,43,53,73,83,223,233,239,263,283,293,307,313,331,337,347,349,353,359,367,373,379,383,389,397,433,439,443,463,503,523,563,593,643,653,673,683,733,739,743,773,823,839,853,863,883,937,953,983,1033,1303", "code": "\nimport sympy\nfrom sympy import prime\nfor n in range(1,10**3):\n..s = str(prime(n))\n..if s.count('3') > s.count('1'):\n....print(int(s),end=', ')\n\n"}
{"sequence_id": "A245632", "text": "Least number k such that n concatenated with k is a perfect power.", "sequence": "6,5,2,9,12,4,29,1,61,0,56,1,31,4,21,9,28,49,6,25,6,5,104,3,6,244,44,9,16,25,25,4,64,3,344,1,21,44,69,0,209,25,56,1,369,24,61,4,13,41,2,9,29,76,225,25,6,32,29,84,504,5,504,516,61,564,6,59,169,56,289,9,96,529,69,176,44,4,21,656", "code": "\nfrom sympy import perfect_power\ndef a(n):\n    s, k = str(n), 0\n    while not perfect_power(int(s+str(k))): k += 1\n    return k\nprint([a(n) for n in range(1, 81)]) \n"}
{"sequence_id": "A245639", "text": "Prime numbers P such that 8*P^2-1 is also prime.", "sequence": "2,3,5,11,17,19,23,31,59,67,79,89,103,107,137,173,193,229,233,241,257,263,271,311,317,353,359,383,409,431,479,509,521,523,541,563,569,577,593,599,613,641,709,739,751,787,829,887,907,919,947,971,983,1033", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import prime\nfor n in range(1,10**3):\n..p = prime(n)\n..if isprime(8*p**2-1):\n....print(p,end=', ')\n\n"}
{"sequence_id": "A245644", "text": "Numbers n such that n^3 is an arithmetic number.", "sequence": "1,3,5,7,11,13,14,15,17,19,21,23,24,29,31,33,35,37,39,41,42,43,46,47,51,52,53,55,56,57,59,61,62,65,66,67,69,70,71,73,77,79,80,83,85,87,89,91,93,94,95,97,101,103,105,107,109,111,113,114,115,117,119,120,123,127,129,131,133,137,138,139", "code": " from sympy import divisors, divisor_count\n[n for n in range(1,10**3) if not sum(divisors(n**3)) % divisor_count(n**3)] \n"}
{"sequence_id": "A245657", "text": "Primes p for which none of the concatenations  p3, p9, 3p, 9p are primes.", "sequence": "3,107,113,179,317,443,487,599,641,653,751,773,937,977,991,1021,1087,1103,1187,1201,1213,1217,1301,1409,1427,1439,1483,1553,1559,1579,1609,1637,1693,1747,1777,1787,1789,1861,1949,1987,1993,2081,2129,2239,2281,2287,2293,2351,2393,2477", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import prime\nfor n in range(1,10**3):\n..p = str(prime(n))\n..if not isprime(p+'3') and not isprime(p+'9') and not isprime('3'+p) and not isprime('9'+p):\n....print(int(p),end=', ') \n"}
{"sequence_id": "A245680", "text": "Numbers x whose digits can be permuted to produce a multiple of x.", "sequence": "1035,1089,1359,1386,1782,2178,2475,10035,10089,10350,10449,10890,10899,10989,11688,11883,12375,12903,13029,13359,13449,13590,13599,13659,13860,13986,14085,14247,14724,14859,15192,16782,17604,17802,17820,17832,17982,18027", "code": "\nimport itertools\nfrom itertools import permutations\nfor n in range(1,10**5):\n..plist = list(permutations(str(n)))\n..for i in plist:\n....num = ''\n....for j in range(len(i)):\n......num += i[j]\n....if int(num)%n==0 and int(num)/n > 1:\n......print(n,end=', ') \n"}
{"sequence_id": "A245682", "text": "Numbers x whose digits can be permuted to produce more than a single multiple of x.", "sequence": "123876,142857,153846,230769,285714,1028574,1218753,1238760,1239876,1246878,1294857,1402857,1420785,1425897,1428507,1428570,1428597,1428705,1429857,1485792,1492857,1538460,1539846,1570284,1584297,2300769,2307690,2307699,2309769,2857014,2857140,2859714,2985714,10028574,10178649", "code": "\nimport itertools\nfrom itertools import permutations\nfor n in range(1,10**8):\n..plist = list(permutations(str(n)))\n..count = 0\n..lst = []\n..for i in plist:\n....num = ''\n....for j in range(len(i)):\n......num += i[j]\n....if int(num)%n==0 and int(num)/n > 1:\n......if int(num) not in lst:\n........lst.append(int(num))\n........count += 1\n..if count > 1:\n....print(n,end=', ') \n"}
{"sequence_id": "A245726", "text": "The digit occurring n times in A225842.", "sequence": "0,1,5,7,7,2,4,7,9,7,0,3,6,6,1,2,4,4,8,8,0,8,8,0,9,1,8,8,6,8,0,8,5,6,9,5,9,7,9,9,0,1,0,3,1,3,8,3,7,6,0,5,0,6,6,1,7,7,4,5,0,8,6,4,9,1,0,1,2,0,0,1,4,6,4,2,6,5,1,7,0,9,2,7,3,1,8,1,7,7,0,4,1,1,0,9,1", "code": "\ndef a(n):\n..b = '0123456789'\n..for k in range(10**4):\n....s = str(n**k)\n....for i in b:\n......if s.count(i) >= n:\n........return int(i)\nn = 0\nwhile n < 150:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A245727", "text": "Least number k >= 0 such that n concatenated with n + k is prime.", "sequence": "0,1,4,3,4,1,2,1,2,3,6,1,6,9,8,3,4,5,12,7,8,15,10,13,6,7,2,5,10,7,6,19,10,15,4,1,2,9,4,9,12,1,6,3,2,3,4,13,2,1,2,9,28,17,2,1,22,3,22,7,2,1,4,5,4,7,12,1,2,9,6,11,20,3,2,5,12,1,14,1,10,5,4,37,12,3,16,5,10", "code": "\ndef a(n):\n..for k in range(n,10**4):\n....if isprime(str(n)+str(k)):\n......return k-n\nn = 1\nwhile n < 150:\n..print(a(n),end=', ')\n..n += 1\n"}
{"sequence_id": "A245730", "text": "Primes of the form 1+2^k+2^(2*k)+...+2^((n-1)*k) for some k>0, n>0.", "sequence": "3,5,7,17,31,73,127,257,8191,65537,131071,262657,524287,2147483647,4432676798593,2305843009213693951,618970019642690137449562111,162259276829213363391578010288127,170141183460469231731687303715884105727", "code": " from sympy2 import isprime\nsorted([int(('0'*m+'1')*n,2) for m in range(50) for n in range(1,50) if isprime(int(('0'*m+'1')*n,2))])\n"}
{"sequence_id": "A245763", "text": "Primes p such that the concatenation of p with its digit sum and the concatenation of the digit sum of p with p are both prime.", "sequence": "61,337,353,449,577,881,937,971,991,1091,1129,1217,1297,1381,1543,1657,1693,2069,2137,2539,2621,2791,3347,3727,3943,4157,4201,4243,4513,4861,5077,5431,5701,5927,6043,6317,6353,6421,6449,6661,6917,7109,7127,7507,7547", "code": "\nfrom sympy import prime, isprime\nA245763 = [int(n) for n in (str(prime(x)) for x in range(1,10**3))\n..........if isprime(int(str(sum([int(d) for d in n]))+n)) and\n..........isprime(int(n+str(sum([int(d) for d in n]))))]\n\n"}
{"sequence_id": "A245770", "text": "Prime sieve of Pi.", "sequence": "1,9,6,5,93,84626,3,2,502884,69399,5105820,4944,2,816406286,986,4825342,70,9,480865,2,66,93,55058,25,4081284,174,270,85,555964462,4895,9644288,7566,344,28475648,8,65,201,45648,23,4543,393,2602,412,724,660,55,74881,20962,25,1715364,892,600", "code": "\ndef arccot(x, unity):\n....sum = xpower = unity // x\n....n = 3\n....sign = -1\n....while 1:\n........xpower = xpower // (x*x)\n........term = xpower // n\n........if not term:\n............break\n........sum += sign * term\n........sign = -sign\n........n += 2\n....return sum\ndef pi(digits):\n....unity = 10**(digits + 10)\n....pi = 4 * (4*arccot(5, unity) - arccot(239, unity))\n....return pi // 10**10\ndef primes(n):\n....\"\"\" Returns  a list of primes < n \"\"\"\n....sieve = [True] * n\n....for i in range(3,int(n**0.5)+1,2):\n........if sieve[i]:\n............sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1)\n....return [2] + [i for i in range(3,n,2) if sieve[i]]\na = pi(370)\nb = primes(100000000)\ny = str(a)\nfor x in b:\n....if str(x) in y:\n........y = y.replace(str(x),\" \",1)\n........\nwhile \"  \" in y:\n....y = y.replace(\"  \",\" \")\nz = y.split(\" \")\nz = filter(None, z)\nf = map(int,z)\nprint(f[0:-1])\n\n"}
{"sequence_id": "A245788", "text": "n times the number of 1's in the binary expansion of n.", "sequence": "0,1,2,6,4,10,12,21,8,18,20,33,24,39,42,60,16,34,36,57,40,63,66,92,48,75,78,108,84,116,120,155,32,66,68,105,72,111,114,156,80,123,126,172,132,180,184,235,96,147,150,204,156,212,216,275,168,228,232,295,240", "code": " [n*bin(n)[2:].count('1') for n in range(1000)] \n"}
{"sequence_id": "A245799", "text": "Lucas(3*n) - Fibonacci(n).", "sequence": "2,3,17,74,319,1359,5770,24463,103661,439170,1860443,7881107,33385138,141422091,599074201,2537720026,10749956135,45537547527,192900151034,817138159415,3461452801237,14662949384658,62113250372707,263115950928619,1114577054173154", "code": "\nimport sympy\n{print(sympy.lucas(3*n)-sympy.fibonacci(n),end=', ') for n in range(50)}\n\n"}
{"sequence_id": "A245800", "text": "a(n) is the least number k such that Sum_{j=S(n)+1..S(n)+k} 1/j >= 1/2, where S(n) = Sum_{i=1..n-1} a(i) and S(1) = 0.", "sequence": "1,1,2,3,5,9,14,24,39,64,106,175,288,475,783,1291,2129,3510,5787,9541,15730,25935,42759,70498,116232,191634,315951,520915,858844,1415994,2334579,3849070,6346044,10462858,17250336,28440996,46891275,77310643,127463701,210152115,346482262", "code": "\nimport math\ntotal = 0\nprev = 1\ncount = 0\nfor n in range(1, 10**7):\n....total = total + 1/n\n....count = count + 1\n....if (total >= 0.5):\n........print(count,end=', ')\n........prev = count\n........total = 0\n........count = 0\n.\nprint(\"\\ndone\")\nprint(math.sqrt(math.e))\n\n"}
{"sequence_id": "A245800", "text": "a(n) is the least number k such that Sum_{j=S(n)+1..S(n)+k} 1/j >= 1/2, where S(n) = Sum_{i=1..n-1} a(i) and S(1) = 0.", "sequence": "1,1,2,3,5,9,14,24,39,64,106,175,288,475,783,1291,2129,3510,5787,9541,15730,25935,42759,70498,116232,191634,315951,520915,858844,1415994,2334579,3849070,6346044,10462858,17250336,28440996,46891275,77310643,127463701,210152115,346482262", "code": "\ndef a(n):\n..if n == 1:\n....return 1\n..tot,c,k = 0,0,0\n..for x in range(1,10**7):\n....tot += 1/x\n....if tot >= 0.5:\n......k += 1\n......tot = 0\n....if k == n-1:\n......c += 1\n....if k == n:\n......return c\nn = 1\nwhile n < 100:\n..print(a(n),end=', ')\n..n += 1\n\n"}
{"sequence_id": "A245801", "text": "Positive n such that Lucas(3*n) - Fibonacci(n) is a prime.", "sequence": "1,2,28,58,98,118,212,238,350,478,883,2660,3971,21491", "code": "\nimport sympy\n{print(n,end=', ') for n in range(10**3) if sympy.isprime(sympy.lucas(3*n)-sympy.fibonacci(n))} \n"}
{"sequence_id": "A245802", "text": "Numbers that are divisible by the sum of their base 8 digits.", "sequence": "1,2,3,4,5,6,7,8,14,16,21,24,28,32,35,40,42,48,49,56,64,66,70,72,75,77,84,88,90,91,98,105,112,120,126,128,129,132,133,135,140,144,145,147,150,154,161,165,168,176,180,182,192,196,198,200,203,210,216,217", "code": "\nfrom gmpy2 import digits\nA245802 = [n for n in range(1,10**3) if not n % sum([int(d) for d in digits(n,8)])]\n(MIT/GNU Scheme, with _Antti Karttunen_'s IntSeq-library)\n(define A245802 (MATCHING-POS 1 1 (lambda (n) (zero? (modulo n (A053829 n))))))\n(define (A053829 n) (let loop ((n n) (i 0)) (if (zero? n) i (loop (floor->exact (/ n 8)) (+ i (modulo n 8))))))\n"}
{"sequence_id": "A245812", "text": "Self-inverse permutation of natural numbers: a(0) = 0, a(1) = 1, and for n > 1, if A065620(n) < 0, a(n) = A065621(1+a(-(A065620(n)))), otherwise a(n) = A048724(a(A065620(n)-1)).", "sequence": "0,1,3,2,6,7,4,5,15,14,13,12,11,10,9,8,24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,57,56,59,58,61,60,63,62,49,48,51,50,53,52,55,54,41,40,43,42,45,44,47,46,33,32,35,34,37,36,39,38,106,107,104,105,110,111,108,109,98,99,96,97,102,103,100", "code": "\ndef a048724(n): return n^(2*n)\ndef a065620(n): return n if n<3 else 2*a065620(n//2) if n%2==0 else -2*a065620((n - 1)//2) + 1\ndef a065621(n): return n^(2*(n - (n & -n)))\ndef a(n):\n    x=a065620(n)\n    return n if n<2 else a065621(1 + a(-x)) if x<0 else a048724(a(x - 1))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A245877", "text": "Primes p such that p - d and p + d are also primes, where d is the largest digit of p.", "sequence": "263,563,613,653,1613,1663,3463,4643,5563,5653,6263,6323,12653,13463,14633,16063,16223,21163,21563,25463,26113,30643,32063,33623,36313,41263,41603,44263,53623,54623,56003,60133,61553,62213,62633,64013,65413,105613,106213", "code": "\nimport sympy\nfrom sympy import prime\nfrom sympy import isprime\nfor n in range(1,10**5):\n..s=prime(n)\n..lst = []\n..for i in str(s):\n....lst.append(int(i))\n..if isprime(s+max(lst)) and isprime(s-max(lst)):\n....print(s,end=', ')\n\n"}
{"sequence_id": "A245878", "text": "Primes p such that p - d and p + d are also primes, where d is the smallest nonzero digit of p.", "sequence": "67,607,6977,68897,69067,69997,79867,80677,88867,97967,609607,660067,669667,676987,678767,697687,707677,766867,777677,786697,866087,879667,880667,886987,899687,906707,909767,966997,990967,6069977,6096907,6097997,6678877", "code": "\nimport sympy\nfrom sympy import isprime\nfrom sympy import prime\nfor n in range(1,10**6):\n..s=prime(n)\n..lst = []\n..for i in str(s):\n....if i != '0':\n......lst.append(int(i))\n..if isprime(s+min(lst)) and isprime(s-min(lst)):\n....print(s,end=', ')\n\n"}
{"sequence_id": "A245909", "text": "The number of distinct prime factors of prime(n)^3-1.", "sequence": "1,2,2,3,4,3,2,3,4,4,4,4,3,4,4,4,3,5,5,4,3,5,4,3,3,3,4,5,4,4,4,4,5,5,5,5,4,5,3,3,4,5,6,4,4,4,7,4,4,5,4,5,4,4,3,5,5,4,6,5,5,3,5,5,4,4,6,5,5,5,4,5,5,6,5,3,4,5,4,4,5,5,6,4,5,5,4", "code": " from sympy import primefactors,prime\ndef A245909(n):\n....return len(primefactors(prime(n)**3-1)) \n"}
{"sequence_id": "A245967", "text": "Decimal expansion of a constant appearing in a theorem by \u00c1rp\u00e1d Baricz about Mills' ratio of the standard normal distribution.", "sequence": "1,1,6,1,5,2,7,8,8,9,2,7,4,4,7,7,3,6,7,0,0,4,5,9,5,0,3,1,0,9,6,3,1,7,9,0,5,5,2,4,8,1,7,3,4,3,0,0,9,6,3,2,3,4,2,4,7,6,9,9,5,5,4,1,4,3,8,2,2,6,9,1,7,1,6,0,8,7,3,1,9,4,6,0,7,7,5,5,6,1,2,7,2,9,8,3,5,7,1,6,8,4", "code": "\nfrom mpmath import *\nmp.dps=103\nprint([int(n) for n in list(str(findroot(lambda x: x*(x**2+2)*exp(x**2/2)*sqrt(pi/2)*erfc(x/sqrt(2))-x**2-1, (1, 2))).replace('.', ''))]) \n"}
{"sequence_id": "A246028", "text": "a(n) = Product_{i in row n of A245562} Fibonacci(i+1).", "sequence": "1,1,1,2,1,1,2,3,1,1,1,2,2,2,3,5,1,1,1,2,1,1,2,3,2,2,2,4,3,3,5,8,1,1,1,2,1,1,2,3,1,1,1,2,2,2,3,5,2,2,2,4,2,2,4,6,3,3,3,6,5,5,8,13,1,1,1,2,1,1,2,3,1,1,1,2,2,2,3,5,1,1,1,2,1,1,2,3,2,2,2,4,3,3,5,8,2,2,2,4,2", "code": "\ndef A246028(n): return sum(int(not (~(n-k) & 2*k) | (~n & k)) for k in range(n+1)) \n"}
{"sequence_id": "A246029", "text": "a(n) = Product_{i in row n of A245562} prime(i).", "sequence": "1,2,2,3,2,4,3,5,2,4,4,6,3,6,5,7,2,4,4,6,4,8,6,10,3,6,6,9,5,10,7,11,2,4,4,6,4,8,6,10,4,8,8,12,6,12,10,14,3,6,6,9,6,12,9,15,5,10,10,15,7,14,11,13,2,4,4,6,4,8,6,10,4,8,8,12,6,12,10,14,4,8,8,12,8,16,12,20,6,12,12,18", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom re import split\nfrom sympy import prime\ndef A246029(n):\nreturn reduce(mul,(prime(len(d)) for d in split('0+',bin(n)[2:]) if d != '')) if n > 0 else 1 \n"}
{"sequence_id": "A246044", "text": "Monoprimatic permutable primes: Decimal prime numbers whose digits cannot be rearranged to form another prime number. No leading zeros allowed.", "sequence": "2,3,5,7,11,19,23,29,41,43,47,53,59,61,67,83,89,101,103,109,151,211,223,227,229,233,257,263,269,307,353,383,401,409,431,433,443,449,487,499,503,509,523,541,557,599,601,607,661,677,773,809,827,829,853,859,881,883,887,929,997,1447,1451,1481,2003,2017,2029,2087", "code": "\nfrom itertools import permutations\nfrom sympy import prime, isprime\nA246044 = []\nfor n in range(1,10**6):\n    p = prime(n)\n    for x in permutations(str(p)):\n        if x[0] != '0':\n            p2 = int(''.join(x))\n            if p2 != p and isprime(p2):\n                break\n    else:\n        A246044.append(p) \n"}
{"sequence_id": "A246135", "text": "Primes that are palindromic right angle numbers in base 9", "sequence": "173,191,373,719,50767,1270271,30890747159", "code": "\nfrom sympy import isprime\nA246135 = []\nfor n in range(1,9):\n....for m in range(n-1,-1,-1):\n........l = ''.join([str(d) for d in range(n,m-1,-1)])\n........p = int(l+l[-2::-1],9)\n........if isprime(p):\n............A246135.append(p)\n....for m in range(n+1,9):\n........l = ''.join([str(d) for d in range(n,m+1)])\n........p = int(l+l[-2::-1],9)\n........if isprime(p):\n............A246135.append(p)\nA246135 = sorted(A246135)\n"}
{"sequence_id": "A246136", "text": "Numbers that are palindromic right angle numbers in base 8.", "sequence": "211,227,373,503,32119,856147,2054519,131479927", "code": "\nfrom sympy import isprime\nA246136 = []\nfor n in range(1,8):\n....for m in range(n-1,-1,-1):\n........l = ''.join([str(d) for d in range(n,m-1,-1)])\n........p = int(l+l[-2::-1],8)\n........if isprime(p):\n............A246136.append(p)\n....for m in range(n+1,8):\n........l = ''.join([str(d) for d in range(n,m+1)])\n........p = int(l+l[-2::-1],8)\n........if isprime(p):\n............A246136.append(p)\nA246136 = sorted(A246136)\n"}
{"sequence_id": "A246159", "text": "Inverse function to the injection A048724.", "sequence": "0,0,0,1,0,3,2,0,0,7,6,0,4,0,0,5,0,15,14,0,12,0,0,13,8,0,0,9,0,11,10,0,0,31,30,0,28,0,0,29,24,0,0,25,0,27,26,0,16,0,0,17,0,19,18,0,0,23,22,0,20,0,0,21,0,63,62,0,60,0,0,61,56,0,0,57,0,59,58,0,48,0,0,49,0,51,50,0,0,55,54,0,52,0,0,53,32", "code": "\ndef a065620(n): return n if n<3 else 2*a065620(n//2) if n%2==0 else -2*a065620((n - 1)//2) + 1\ndef a(n): return -(bin(n)[2:].count(\"1\")%2==0)*a065620(n)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A246160", "text": "Inverse function to the injection A065621.", "sequence": "0,1,2,0,4,0,0,3,8,0,0,7,0,5,6,0,16,0,0,15,0,13,14,0,0,9,10,0,12,0,0,11,32,0,0,31,0,29,30,0,0,25,26,0,28,0,0,27,0,17,18,0,20,0,0,19,24,0,0,23,0,21,22,0,64,0,0,63,0,61,62,0,0,57,58,0,60,0,0,59,0,49,50,0,52", "code": "\ndef a065620(n): return n if n<3 else 2*a065620(n//2) if n%2==0 else -2*a065620((n - 1)//2) + 1\ndef a(n): return (bin(n)[2:].count(\"1\")%2)*a065620(n)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A246198", "text": "Half-Zumkeller numbers: numbers n whose proper positive divisors can be partitioned into two disjoint sets whose sums are equal.", "sequence": "6,12,20,24,28,30,40,42,48,54,56,60,66,70,78,80,84,88,90,96,102,104,108,112,114,120,126,132,138,140,150,156,160,168,174,176,180,186,192,198,204,208,210,216,220,222,224,225,228,234,240,246,252,258,260,264", "code": "\nfrom sympy.combinatorics.subsets import Subset\nfrom sympy import divisors\nA246198 = []\nfor n in range(2,10**3):\n....d = divisors(n)\n....d.remove(n)\n....s, dmax = sum(d), max(d)\n....if not s % 2 and 2*dmax <= s:\n........d.remove(dmax)\n........s2 = s/2-dmax\n........for x in range(2**len(d)):\n............if sum(Subset.unrank_binary(x,d).subset) == s2:\n................A246198.append(n)\n................break\n"}
{"sequence_id": "A246198", "text": "Half-Zumkeller numbers: numbers n whose proper positive divisors can be partitioned into two disjoint sets whose sums are equal.", "sequence": "6,12,20,24,28,30,40,42,48,54,56,60,66,70,78,80,84,88,90,96,102,104,108,112,114,120,126,132,138,140,150,156,160,168,174,176,180,186,192,198,204,208,210,216,220,222,224,225,228,234,240,246,252,258,260,264", "code": "\nfrom sympy import divisors\nimport numpy as np\nA246198 = []\nfor n in range(2,10**3):\n....d = divisors(n)\n....d.remove(n)\n....s, dmax = sum(d), max(d)\n....if not s % 2 and 2*dmax <= s:\n........d.remove(dmax)\n........s2, ld = int(s/2-dmax), len(d)\n........z = np.zeros((ld+1,s2+1),dtype=int)\n........for i in range(1,ld+1):\n............y = min(d[i-1],s2+1)\n............z[i,range(y)] = z[i-1,range(y)]\n............z[i,range(y,s2+1)] = np.maximum(z[i-1,range(y,s2+1)],z[i-1,range(0,s2+1-y)]+y)\n............if z[i,s2] == s2:\n................A246198.append(n)\n................break\n\n"}
{"sequence_id": "A246199", "text": "Odd half-Zumkeller numbers.", "sequence": "225,441,1225,2025,3969,5625,11025,18225,21609,27225,35721,38025,50625,53361,65025,74529,81225,99225,119025,127449,140625,148225,159201,164025,184041,189225,194481,207025,216225,233289,245025,275625,308025,314721,321489", "code": "\nfrom sympy import divisors\nimport numpy as np\nA246199 = []\nfor n in range(3,10**5,2):\n....d = divisors(n)\n....d.remove(n)\n....s, dmax = sum(d), max(d)\n....if not s % 2 and 2*dmax <= s:\n........d.remove(dmax)\n........s2, ld = int(s/2-dmax), len(d)\n........z = np.zeros((ld+1,s2+1),dtype=int)\n........for i in range(1,ld+1):\n............y = min(d[i-1],s2+1)\n............z[i,range(y)] = z[i-1,range(y)]\n............z[i,range(y,s2+1)] = np.maximum(z[i-1,range(y,s2+1)],z[i-1,range(0,s2+1-y)]+y)\n............if z[i,s2] == s2:\n................A246199.append(n)\n................break\n"}
{"sequence_id": "A246200", "text": "Self-inverse permutation of natural numbers: a(n) = A057889(3*n) / 3.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,11,12,19,14,15,16,17,18,13,20,21,22,27,24,35,38,23,28,39,30,31,32,33,34,25,36,41,26,29,40,37,42,43,44,75,54,59,48,67,70,51,76,83,46,55,56,71,78,47,60,79,62,63,64,65,66,49,68,81,50,57,72,73,82,45,52,77,58,61,80,69", "code": "\ndef a057889(n):\n    x=bin(n)[2:]\n    y=x[::-1]\n    return int(str(int(y))+(len(x) - len(str(int(y))))*'0', 2)\ndef a(n): return a057889(3*n)//3\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A246207", "text": "Permutation of nonnegative integers: a(0) = 0, a(1) = 1, a(2n) = A117968(a(n)), a(2n+1) = A117967(1+a(n)).", "sequence": "0,1,2,5,7,3,22,15,23,11,6,4,71,35,66,52,58,33,25,12,21,16,8,17,172,99,73,36,213,148,194,137,197,152,75,43,59,29,24,13,69,49,68,47,19,9,64,45,587,419,225,127,173,104,72,37,516,304,620,431,643,447,601,462,640,441,577,423,177,103,203,155,211,150,61,30,57,34,26,53", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a004488(n): return int(\"\".join([str((3 - i)%3) for i in digits(n, 3)[1:]]), 3)\ndef a117968(n):\n    if n==1: return 2\n    if n%3==0: return 3*a117968(n/3)\n    elif n%3==1: return 3*a117968((n - 1)/3) + 2\n    else: return 3*a117968((n + 1)/3) + 1\ndef a117967(n): return 0 if n==0 else a117968(-n) if n<0 else a004488(a117968(n))\ndef a(n): return n if n<2 else a117968(a(n/2)) if n%2==0 else a117967(1 + a((n - 1)/2)) \n"}
{"sequence_id": "A246208", "text": "Permutation of nonnegative integers: a(0) = 0, a(1) = 1, and for n > 1, if A117966(n) < 1, a(n) = 2*a(-(A117966(n))), otherwise a(n) = 1 + 2*a(A117966(n)-1).", "sequence": "0,1,2,5,11,3,10,4,22,45,91,9,19,39,183,7,21,23,90,44,182,20,6,8,38,18,78,157,315,37,75,151,631,17,77,13,27,55,155,311,623,111,1263,35,303,47,181,43,365,41,89,367,15,79,314,156,630,76,16,36,150,74,302,180,46,88,14,366,42,40,364,12,54,26,110,34", "code": "\ndef a117966(n):\n    if n==0: return 0\n    if n%3==0: return 3*a117966(n//3)\n    elif n%3==1: return 3*a117966((n - 1)//3) + 1\n    else: return 3*a117966((n - 2)//3) - 1\ndef a(n):\n    if n<2: return n\n    x=a117966(n)\n    if x<1: return 2*a(-x)\n    else: return 1 + 2*a(x - 1)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A246209", "text": "Permutation of nonnegative integers: a(0) = 0, a(1) = 1, a(2n) = A117967(1+a(n)), a(2n+1) = A117968(a(n)).", "sequence": "0,1,5,2,15,22,3,7,52,66,35,71,4,6,11,23,137,194,148,213,36,73,99,172,17,8,16,21,12,25,33,58,462,601,447,643,431,620,304,516,37,72,104,173,127,225,419,587,45,64,9,19,47,68,49,69,13,24,29,59,43,75,152,197,1273,1734,1334,1940,1294,1740,899,1556,1404,1837,945,1567,389,698,1246,1761,41", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a004488(n): return int(\"\".join(str((3 - i)%3) for i in digits(n, 3)[1:]), 3)\ndef a117968(n):\n    if n==1: return 2\n    if n%3==0: return 3*a117968(n//3)\n    elif n%3==1: return 3*a117968((n - 1)//3) + 2\n    else: return 3*a117968((n + 1)//3) + 1\ndef a117967(n): return 0 if n==0 else a117968(-n) if n<0 else a004488(a117968(n))\ndef a(n): return n if n<2 else a117967(1 + a(n//2)) if n%2==0 else a117968(a((n - 1)//2))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A246210", "text": "Permutation of nonnegative integers: a(0) = 0, a(1) = 1, and for n > 1, if A117966(n) < 1, a(n) = 1 + 2*a(-(A117966(n))), otherwise a(n) = 2*a(A117966(n)-1).", "sequence": "0,1,3,6,12,2,13,7,25,50,100,14,28,56,200,4,26,24,101,51,201,27,5,15,57,29,113,226,452,58,116,232,904,30,114,10,20,40,228,456,912,80,1808,60,464,48,202,52,402,54,102,400,8,112,453,227,905,115,31,59,233,117,465,203,49,103,9,401,53,55,403,11,41,21,81,61", "code": "\ndef a117966(n):\n    if n==0: return 0\n    if n%3==0: return 3*a117966(n//3)\n    elif n%3==1: return 3*a117966((n - 1)//3) + 1\n    else: return 3*a117966((n - 2)//3) - 1\ndef a(n):\n    if n<2: return n\n    x=a117966(n)\n    if x<1: return 1 + 2*a(-x)\n    else: return 2*a(x - 1)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A246261", "text": "Numbers n such that A003961(n) is of the form 4k+1.", "sequence": "1,3,4,9,10,11,12,13,14,16,23,25,27,30,31,33,34,35,36,37,38,39,40,42,44,47,48,49,52,56,58,59,64,69,71,75,81,82,83,85,86,89,90,92,93,95,97,99,100,102,105,106,107,108,109,110,111,114,117,119,120,121,122,124,126,130,131,132,133,134,136,139,140,141,143,144", "code": "\nfrom sympy import factorint, prime, primepi\nfrom operator import mul\ndef a003961(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [prime(primepi(i) + 1)**f[i] for i in f])\nprint([n for n in range(1, 201) if a003961(n)%4==1]) \n"}
{"sequence_id": "A246277", "text": "Column index of n in A246278: a(1) = 0, a(2n) = n, a(2n+1) = a(A064989(2n+1)).", "sequence": "0,1,1,2,1,3,1,4,2,5,1,6,1,7,3,8,1,9,1,10,5,11,1,12,2,13,4,14,1,15,1,16,7,17,3,18,1,19,11,20,1,21,1,22,6,23,1,24,2,25,13,26,1,27,5,28,17,29,1,30,1,31,10,32,7,33,1,34,19,35,1,36,1,37,9,38,3,39,1,40,8,41,1,42", "code": "\nfrom sympy import factorint, prevprime\nfrom operator import mul\nfrom functools import reduce\ndef a064989(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==2 else prevprime(i)**f[i] for i in f])\ndef a(n): return 0 if n==1 else n//2 if n%2==0 else a(a064989(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A246298", "text": "Numbers k such that sin(k) > sin(k+1) > sin(k+2) < sin(k+3).", "sequence": "3,9,15,22,28,34,40,47,53,59,66,72,78,84,91,97,103,110,116,122,128,135,141,147,154,160,166,172,179,185,191,197,204,210,216,223,229,235,241,248,254,260,267,273,279,285,292,298,304,311,317,323,329,336,342", "code": "\nfrom sympy import sin\ndef ok(n):\n    s0, s1, s2, s3 = sin(n), sin(n + 1), sin(n + 2), sin(n + 3)\n    return s0>s1 and s1>s2 and s2<s3\nprint([n for n in range(1, 501) if ok(n)]) \n"}
{"sequence_id": "A246337", "text": "Numbers n which when expressed in base 16 are palindromes whose digit sum and digit product both divide n.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,273,69905,78129,200979,17903889,4581298449,1172816597265,1174959919377,300240008712465,300240176484625,370608786444625", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom gmpy2 import t_mod, digits, mpz\nA246337 = sorted([mpz(n,16) for n in (digits(x,16)+digits(x,16)[::-1]\n....for x in range(1,16**7)) if not (n.count('0') or\n....t_mod(mpz(n,16), sum((mpz(d,16) for d in n)))\n....or t_mod(mpz(n,16), reduce(mul,(mpz(d,16) for d in n))))] +\n....[mpz(n,16) for n in (digits(x,16)+digits(x,16)[-2::-1]\n....for x in range(16**7)) if not (n.count('0') or\n....t_mod(mpz(n,16), sum((mpz(d,16) for d in n)))\n....or t_mod(mpz(n,16), reduce(mul,(mpz(d,16) for d in n))))])\n"}
{"sequence_id": "A246338", "text": "Numbers n which when expressed in base 8 are palindromes whose digit sum and digit product both divide n.", "sequence": "1,2,3,4,5,6,7,105,4809,299593,1227264585,1231525449,1495765593,21734674907255625,128700665796293199,129237637608018639", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom gmpy2 import t_mod, digits, mpz\nA246338 = sorted([mpz(n,8) for n in (digits(x,8)+digits(x,8)[::-1]\n....for x in range(1,8**6)) if not (n.count('0') or\n....t_mod(mpz(n,8), sum((mpz(d,8) for d in n)))\n....or t_mod(mpz(n,8), reduce(mul,(mpz(d,8) for d in n))))] +\n....[mpz(n,8) for n in (digits(x,8)+digits(x,8)[-2::-1]\n....for x in range(8**6)) if not (n.count('0') or\n....t_mod(mpz(n,8), sum((mpz(d,8) for d in n)))\n....or t_mod(mpz(n,8), reduce(mul,(mpz(d,8) for d in n))))])\n"}
{"sequence_id": "A246359", "text": "Maximum digit in the factorial base expansion of n (A007623).", "sequence": "0,1,1,1,2,2,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,1,1,1,1,2,2,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4", "code": "\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a(n): return int(max(str(a007623(n))))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A246419", "text": "Numbers n such that n^6 - 2 is not squarefree.", "sequence": "10,22,50,143,204,267,311,312,423,455,461,479,506,556,579,600,649,818,845,889,987,1008,1104,1108,1134,1178,1258,1273,1333,1343,1416,1423,1467,1537,1610,1637,1712,1756,1779,2001,2005,2045,2065,2066,2104,2166,2205", "code": "\nfrom sympy import factorint\n[i for i in range(1, 500) if any(v>1 for v in factorint(i**6-2).values())]\n"}
{"sequence_id": "A246421", "text": "Numbers n such that (n + digit sum of n) and (n + digit product of n) are nontrivial permutations of the digits of n.", "sequence": "5769,14346,27369,41346,52569,56925,94725,122346,126135,129213,143658,152469,154269,155169,157914,162135,192213,212346,216135,219213,221346,236124,238959,245925,261135,263124,291213,326124,328536,344925,361647,362124,367425,368892,392436,413658", "code": "\nfrom operator import mul\nfrom functools import reduce\nA246421_list = []\nfor n in range(1,10**6):\n....s = str(n)\n....if not s.count('0'):\n........s2 = sorted(s)\n........if s2 == sorted(str(n+sum(int(d) for d in s))) and s2 == sorted(str(n+reduce(mul, (int(d) for d in s)))):\n............A246421_list.append(n) \n"}
{"sequence_id": "A246428", "text": "Primes p such that concatenation of the digit sum of p with p is also prime.", "sequence": "11,19,23,29,31,41,43,53,59,61,67,89,97,113,149,151,163,173,181,211,229,233,271,293,317,331,337,347,349,353,359,379,389,419,431,433,443,449,463,467,479,521,547,563,577,599,613,619,631,653,673,683,691,739,751", "code": "\nfrom sympy import prime, isprime\nA246428 = [int(n) for n in (str(prime(x)) for x in range(1,10**3))\n..........if isprime(int(str(sum([int(d) for d in n]))+n))]\n\n"}
{"sequence_id": "A246447", "text": "The odd primes squared plus 1 and the composites squared minus 1.", "sequence": "10,15,26,35,50,63,80,99,122,143,170,195,224,255,290,323,362,399,440,483,530,575,624,675,728,783,842,899,962,1023,1088,1155,1224,1295,1370,1443,1520,1599,1682,1763,1850,1935,2024,2115,2210,2303,2400,2499,2600", "code": "\nfor n in range(3,10**3):\n..if isprime(n):\n....print(n**2+1,end=', ')\n..else:\n....print(n**2-1,end=', ') \n"}
{"sequence_id": "A246488", "text": "Gridgeman pairs in increasing order: pairs of palindromic primes which differ only in their middle digits whose difference is equal to 1.", "sequence": "2,3,181,191,373,383,787,797,919,929,10501,10601,11311,11411,12721,12821,13831,13931,15451,15551,16561,16661,19891,19991,30103,30203,30703,30803,32323,32423,35053,35153,38083,38183,70507,70607,77377,77477,78787,78887,93139", "code": "\nfrom sympy import isprime\nA246488 = [2,3]\nfor n in range(1,10**4):\n....s1 = str(n)\n....s2 = s1[::-1]\n....for m in range(10-1):\n........p1 = int(s1+str(m)+s2)\n........p2 = int(s1+str(m+1)+s2)\n........if isprime(p1) and isprime(p2):\n............A246488.append(p1), A246488.append(p2)\n.\nA246488 = sorted(set(A246488)) \n"}
{"sequence_id": "A246503", "text": "Numbers m such that m^2 divides 2^k - 1 for some k, 0 < k <= m.", "sequence": "1,1093,3279,3511,5465,7651,9837,10533,14209,16395,17555,18581,22953,24577,31599,31697,38255,38621,42627,45643,46999,49185,52665,53557,55743,57929,60115,62301,66709,68859,71045,73731,84161,86347,92905,94797,95091,99463", "code": "\nA246503_list = [1]\nfor i in range(2,10**4):\n....d, n = i*i, 1\n....for _ in range(i):\n........n = (2*n) % d\n........if n == 1:\n............A246503_list.append(i)\n............break \n"}
{"sequence_id": "A246519", "text": "Primes p such that 4+p, 4+p^2, 4+p^3 and 4+p^5 are all prime.", "sequence": "7,5503,21013,301123,303613,420037,469363,679153,771427,991957,999667,1524763,1707367,2030653,2333083,2540563,2552713,2710933,3009967,3378103,3441817,3592213,4419937,4704613,4840723,5177797,5691547,6227587,6275887,6395677,6595597,6597163", "code": "\nfrom sympy import prime, isprime\nA246519_list = [p for p in (prime(n) for n in range(1,10**5)) if all([isprime(4+p**z) for z in (1,2,3,5)])]\n\n"}
{"sequence_id": "A246520", "text": "Largest number that can be written in binary as concatenation of (n - k) and (n + k), 0 <= k <= n.", "sequence": "0,3,10,20,36,45,72,104,136,153,170,208,272,336,400,464,528,561,594,627,660,693,800,928,1056,1184,1312,1440,1568,1696,1824,1952,2080,2145,2210,2275,2340,2405,2470,2535,2600,2665,2730,2880,3136,3392,3648,3904", "code": "\ndef A246520(n):\n....return(max(int(bin(n-k)[2:]+bin(n+k)[2:],2) for k in range(n+1)))\n\n"}
{"sequence_id": "A246544", "text": "Consider the aliquot parts, in ascending order, of a composite number. Take their sum and repeat the process deleting the minimum number and adding the previous sum. The sequence lists the numbers that after some iterations reach a sum equal to themselves.", "sequence": "6,21,28,85,496,2133,8128,19521,77125,97273,176661,615281,4948133,33550336,68353213,129127041,8589869056", "code": "\nimport math\n.\ndef divs(n):\n....large_divisors = []\n....for i in range(1, int(math.sqrt(n) + 1)):\n........if n % i is 0:\n............yield i\n............if i is not n / i:\n................large_divisors.insert(0, n / i)\n....for divisor in large_divisors:\n........yield divisor\n.\na = 2\nwhile a < 1000000000:\n....q = list(divs(a))[:-1]\n....r = sum(q)\n....if r > a or len(q) == 1:\n........pass\n....elif r == a:\n........print(a)\n....else:\n........c = 1\n........while r < a:\n............q.append(r)\n............r = sum(q[c:])\n............c += 1\n........if r == a:\n............print(a)\n....a += 1\n\n"}
{"sequence_id": "A246544", "text": "Consider the aliquot parts, in ascending order, of a composite number. Take their sum and repeat the process deleting the minimum number and adding the previous sum. The sequence lists the numbers that after some iterations reach a sum equal to themselves.", "sequence": "6,21,28,85,496,2133,8128,19521,77125,97273,176661,615281,4948133,33550336,68353213,129127041,8589869056", "code": "\nfrom sympy import divisors, isprime\nA246544_list = []\nfor n in range(2,10**5):\n....if not isprime(n):\n........x = divisors(n)\n........x.pop()\n........y = sum(x)\n........while y < n:\n............x, y = x[1:]+[y], 2*y-x[0]\n........if y == n:\n............A246544_list.append(n)\n\n"}
{"sequence_id": "A246588", "text": "Run Length Transform of S(n) = wt(n) = 0,1,1,2,1,2,2,3,1,... (cf. A000120).", "sequence": "1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,2,2,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,2,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,2,2,1,2,1,1,1,1,1", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom re import split\ndef A246588(n):\n    return reduce(mul,(bin(len(d)).count('1') for d in split('0+',bin(n)[2:]) if d)) if n > 0 else 1 \n"}
{"sequence_id": "A246591", "text": "Smallest number that can be obtained by swapping 2 bits in the binary expansion of n.", "sequence": "0,1,1,3,1,3,3,7,1,3,3,7,5,7,7,15,1,3,3,7,5,7,7,15,9,11,11,15,13,15,15,31,1,3,3,7,5,7,7,15,9,11,11,15,13,15,15,31,17,19,19,23,21,23,23,31,25,27,27,31,29,31,31,63,1,3,3,7,5,7,7,15,9,11,11", "code": "\nfrom itertools import combinations\ndef A246591(n):\n....if n <= 1:\n........return n\n....else:\n........s = bin(n)[2:]\n........l = len(s)\n........y = 2**l-1\n........for i in combinations(range(l),2):\n............s2 = int(s[:i[0]]+s[i[1]]+s[i[0]+1:i[1]]+s[i[0]]+s[i[1]+1:],2)\n............if s2 < y:\n................y = s2\n........return y\n\n"}
{"sequence_id": "A246591", "text": "Smallest number that can be obtained by swapping 2 bits in the binary expansion of n.", "sequence": "0,1,1,3,1,3,3,7,1,3,3,7,5,7,7,15,1,3,3,7,5,7,7,15,9,11,11,15,13,15,15,31,1,3,3,7,5,7,7,15,9,11,11,15,13,15,15,31,17,19,19,23,21,23,23,31,25,27,27,31,29,31,31,63,1,3,3,7,5,7,7,15,9,11,11", "code": "\ndef A246591(n):\n....s = bin(n)[2:]\n....s2 = s.rstrip('1')\n....return(int(s2[1:-1]+'1'+s[len(s2):],2) if (len(s2) > 0 and n > 1) else n)\n\n"}
{"sequence_id": "A246592", "text": "Smallest number that can be obtained by swapping 2 adjacent bits in the binary expansion of n.", "sequence": "0,1,1,3,2,3,5,7,4,5,6,7,10,11,13,15,8,9,10,11,12,13,14,15,20,21,22,23,26,27,29,31,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,40,41,42,43,44,45,46,47,52,53,54,55,58,59,61,63,32,33,34,35,36", "code": "\ndef A246592(n):\n....s = bin(n)[2:]\n....for i in range(len(s)-1):\n........if s[i:i+2] == '10':\n............return int(s[:i]+'01'+s[i+2:], 2)\n....else:\n........return n \n"}
{"sequence_id": "A246593", "text": "a(n)=n for n <= 2; for n >= 3, a(n) = largest number that can be obtained by swapping two bits in the binary expansion of n.", "sequence": "0,1,2,3,4,6,6,7,8,12,12,14,12,14,14,15,16,24,24,26,24,28,28,30,24,28,28,30,28,30,30,31,32,48,48,50,48,52,52,54,48,56,56,58,56,60,60,62,48,56,56,58,56,60,60,62,56,60,60,62,60,62,62,63,64,96,96", "code": "\nfrom itertools import combinations\ndef A246593(n):\n....if n <= 1:\n........return n\n....else:\n........s, y = bin(n)[2:], n\n........for i in combinations(range(len(s)),2):\n............s2 = int(s[:i[0]]+s[i[1]]+s[i[0]+1:i[1]]+s[i[0]]+s[i[1]+1:],2)\n............if s2 > y:\n................y = s2\n........return y\n\n"}
{"sequence_id": "A246593", "text": "a(n)=n for n <= 2; for n >= 3, a(n) = largest number that can be obtained by swapping two bits in the binary expansion of n.", "sequence": "0,1,2,3,4,6,6,7,8,12,12,14,12,14,14,15,16,24,24,26,24,28,28,30,24,28,28,30,28,30,30,31,32,48,48,50,48,52,52,54,48,56,56,58,56,60,60,62,48,56,56,58,56,60,60,62,56,60,60,62,60,62,62,63,64,96,96", "code": "\n\ndef A246593(n):\n....s = bin(n)[2:]\n....s2 = s.rstrip('0')\n....s3 = s2.lstrip('1')\n....return(int(s2[:-len(s3)]+'1'+s3[1:-1]+'0'+s[len(s2):],2) if (len(s3) > 0 and n > 1) else n)\n\n"}
{"sequence_id": "A246594", "text": "a(n)=n for n <= 2; for n >= 3, a(n) = largest number that can be obtained by swapping two adjacent bits in the binary expansion of n.", "sequence": "0,1,2,3,4,6,6,7,8,10,12,13,12,14,14,15,16,18,20,21,24,25,26,27,24,26,28,29,28,30,30,31,32,34,36,37,40,41,42,43,48,49,50,51,52,53,54,55,48,50,52,53,56,57,58,59,56,58,60,61,60,62,62,63,64,66,68", "code": "\ndef A246594(n):\n....s = bin(n)[2:]\n....for i in range(len(s)-1):\n........if s[i:i+2] == '01':\n............return int(s[:i]+'10'+s[i+2:],2)\n....else:\n........return n \n"}
{"sequence_id": "A246595", "text": "Run Length Transform of squares.", "sequence": "1,1,1,4,1,1,4,9,1,1,1,4,4,4,9,16,1,1,1,4,1,1,4,9,4,4,4,16,9,9,16,25,1,1,1,4,1,1,4,9,1,1,1,4,4,4,9,16,4,4,4,16,4,4,16,36,9,9,9,36,16,16,25,36,1,1,1,4,1,1,4,9,1,1,1,4,4,4,9,16,1,1,1,4,1,1", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom re import split\ndef A246595(n):\n    return reduce(mul,(len(d)**2 for d in split('0+',bin(n)[2:]) if d != '')) if n > 0 else 1 \n"}
{"sequence_id": "A246596", "text": "Run Length Transform of Catalan numbers A000108.", "sequence": "1,1,1,2,1,1,2,5,1,1,1,2,2,2,5,14,1,1,1,2,1,1,2,5,2,2,2,4,5,5,14,42,1,1,1,2,1,1,2,5,1,1,1,2,2,2,5,14,2,2,2,4,2,2,4,10,5,5,5,10,14,14,42,132,1,1,1,2,1,1,2,5,1,1,1,2,2,2,5,14,1,1,1,2,1,1,2,5", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom gmpy2 import divexact\nfrom re import split\ndef A246596(n):\n    s, c = bin(n)[2:], [1, 1]\n    for m in range(1, len(s)):\n        c.append(divexact(c[-1]*(4*m+2),(m+2)))\n    return reduce(mul,(c[len(d)] for d in split('0+',s))) if n > 0 else 1\n\n"}
{"sequence_id": "A246600", "text": "Number of divisors d of n with property that the binary representation of d can be obtained from the binary representation of n by changing any number of 1's to 0's.", "sequence": "1,1,2,1,2,2,2,1,2,2,2,2,2,2,4,1,2,2,2,2,2,2,2,2,2,2,4,2,2,4,2,1,2,2,2,2,2,2,3,2,2,2,2,2,4,2,2,2,2,2,4,2,2,4,3,2,2,2,2,4,2,2,6,1,2,2,2,2,2,2,2,2,2,2,3,2,2,3,2,2,2,2,2,2,4,2,3,2,2,4,2", "code": "\nfrom sympy import divisors\ndef A246600(n):\n....return sum(1 for d in divisors(n) if n|d == n)\n\n"}
{"sequence_id": "A246601", "text": "Sum of divisors d of n with property that the binary representation of d can be obtained from the binary representation of n by changing any number of 1's to 0's.", "sequence": "1,2,4,4,6,8,8,8,10,12,12,16,14,16,24,16,18,20,20,24,22,24,24,32,26,28,40,32,30,48,32,32,34,36,36,40,38,40,43,48,42,44,44,48,60,48,48,64,50,52,72,56,54,80,61,64,58,60,60,96,62,64,104,64,66,68,68,72,70,72", "code": "\nfrom sympy import divisors\ndef A246601(n):\n....return sum(d for d in divisors(n) if n|d == n)\n\n"}
{"sequence_id": "A246655", "text": "Prime powers: numbers of the form p^k where p is a prime and k >= 1.", "sequence": "2,3,4,5,7,8,9,11,13,16,17,19,23,25,27,29,31,32,37,41,43,47,49,53,59,61,64,67,71,73,79,81,83,89,97,101,103,107,109,113,121,125,127,128,131,137,139,149,151,157,163,167,169,173,179,181,191,193,197,199,211", "code": "\nfrom sympy import primerange\nm = 10**5\nA246655 = []\nfor p in primerange(1,m):\n    pe = p\n    while pe < m:\n        A246655.append(pe)\n        pe *= p\nA246655 = sorted(A246655) \n"}
{"sequence_id": "A246660", "text": "Run Length Transform of factorials.", "sequence": "1,1,1,2,1,1,2,6,1,1,1,2,2,2,6,24,1,1,1,2,1,1,2,6,2,2,2,4,6,6,24,120,1,1,1,2,1,1,2,6,1,1,1,2,2,2,6,24,2,2,2,4,2,2,4,12,6,6,6,12,24,24,120,720,1,1,1,2,1,1,2,6,1,1,1,2,2,2,6,24,1,1,1", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom re import split\nfrom math import factorial\ndef A246660(n):\n    return reduce(mul,(factorial(len(d)) for d in split('0+',bin(n)[2:]) if d)) if n > 0 else 1 \n"}
{"sequence_id": "A246666", "text": "Numbers n such that n^3 + (n+1)^3 + (n+3)^3 is prime.", "sequence": "1,3,5,9,31,43,45,51,71,89,135,141,145,149,159,163,169,183,185,225,233,241,255,261,271,281,283,285,299,309,311,313,355,395,401,411,415,423,429,435,449,453,485,491,541,551,561,579,583,589,603,621,625,635,681", "code": "\nfrom sympy import isprime\nA246666_list = [n for n in range(1,10**5) if isprime(3*n*(n*(n+4)+10)+28)]\n\n"}
{"sequence_id": "A246701", "text": "First differences of A246520.", "sequence": "3,7,10,16,9,27,32,32,17,17,38,64,64,64,64,64,33,33,33,33,33,107,128,128,128,128,128,128,128,128,128,128,65,65,65,65,65,65,65,65,65,65,150,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,129,129", "code": "\ndef A246701(n):\n....return(max(int(bin(n+1-k)[2:]+bin(n+1+k)[2:],2) for k in range(n+2)) -max(int(bin(n-k)[2:]+bin(n+k)[2:],2) for k in range(n+1)))\n\n"}
{"sequence_id": "A246714", "text": "Catalan(n) mod prime(n).", "sequence": "1,2,0,0,9,2,4,5,9,5,10,35,21,12,14,45,19,38,36,20,54,54,19,10,83,40,101,4,20,8,16,18,53,127,25,139,4,54,149,127,176,156,71,17,65,196,10,211,221,205,63,138,137,234,254,194,67,243,155,145,164,203,76,187,272", "code": "\nfrom sympy import prime\nfrom gmpy2 import divexact, t_mod\nA246714, c = [1], 1\nfor n in range(2,10**3):\n....c = divexact(c*(4*n-2),(n+1))\n....A246714.append(t_mod(c,prime(n))) \n"}
{"sequence_id": "A246757", "text": "Largest n-digit number divisible by the product of its decimal digits.", "sequence": "9,36,816,9612,93744,973728,9939915,99221112,997711344,9993393711,99934212672,999641938176,9999121936392,99996414731136,999994123418112,9999982411646976,99999318116613312,999991631331122112,9999944111773994112,99999911232931433472,999999832211912282112", "code": "\nfrom operator import mul\nfrom functools import reduce\ndef A246757(n):\n    for i in range(10**n-1,int('1'*n)-1,-1):\n        pd = reduce(mul,(int(d) for d in str(i)))\n        if pd and not i % pd:\n            return i \n"}
{"sequence_id": "A246763", "text": "Catalan(n)^2 mod prime(n).", "sequence": "1,1,0,0,4,4,16,6,12,25,7,4,31,15,8,11,7,41,23,45,69,72,29,11,2,85,4,16,73,64,2,62,69,5,29,144,16,145,157,40,9,82,75,96,88,9,100,144,36,118,8,163,212,38,9,27,185,242,203,231,11,189,250,137,116,34,91,289,10,272", "code": "\nfrom sympy import prime\nfrom gmpy2 import divexact, t_mod\nA246763, c = [1], 1\nfor n in range(2,10**2):\n....c = divexact(c*(4*n-2),(n+1))\n....A246763.append(t_mod(c**2,prime(n))) \n"}
{"sequence_id": "A246801", "text": "Primes of the form: concatenation n with n-th composite integer.", "sequence": "4057,4463,4969,5881,6691,86117,90121,129169,131171,136177,160207,162209,169217,193247,225287,252319,265333,272341,280351,288361,297371,327407,346429,355441,388481,410507,429529,451553,456559,474581", "code": "\nimport sympy\nfrom sympy import isprime\nc = 0\nfor n in range(2,10**5):\n..if not isprime(n):\n....c += 1\n....p = str(c)+str(n)\n....if isprime(p):\n......print(int(p),end=', ')\n\n"}
{"sequence_id": "A246806", "text": "Number of n-digit numbers whose base-10 representations can be written as the concatenations of 0 or more prime numbers (also expressed in base 10).", "sequence": "1,4,33,285,2643,24920,239543,2327458,22801065,224608236,2222034266,22053438268", "code": "\nfrom sympy import isprime, primerange\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef ok(n):\n  if n%10 not in {1, 2, 3, 5, 7, 9}: return False\n  if isprime(n): return True\n  d = str(n)\n  for i in range(1, len(d)):\n    if d[i] != '0' and isprime(int(d[:i])) and ok(int(d[i:])): return True\n  return False\ndef a(n): return 1 if n == 0 else sum(ok(m) for m in range(10**(n-1), 10**n))\nprint([a(n) for n in range(7)]) \n"}
{"sequence_id": "A246807", "text": "Number of n-bit numbers that can be written as the concatenation of 0 or more prime numbers (everything written in base 2).", "sequence": "1,0,2,2,5,8,15,33,59,126,246,494,978,1971,3930,7845,15749,31527,63349,126986,254880,511468,1026348,2060633,4135808,8303940,16669925,33472231,67201664,134930088,270895845,543915707,1091923726", "code": "\nfrom sympy import isprime, primerange\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef ok(n):\n  if n%4 == 0: return False\n  if isprime(n): return True\n  b = bin(n)[2:]\n  for i in range(2, len(b)-1):\n    if b[i] != '0' and isprime(int(b[:i], 2)) and ok(int(b[i:], 2)):\n      return True\n  return False\ndef a(n):\n  return 1 if n == 0 else sum(1 for m in range(2**(n-1), 2**n) if ok(m))\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A246817", "text": "Possible number of trailing zeros in hyperfactorials (A002109).", "sequence": "0,5,15,30,50,100,130,165,205,250,350,405,465,530,600,750,830,915,1005,1100,1300,1405,1515,1630,1750,2125,2255,2390,2530,2675,2975,3130,3290,3455,3625,3975,4155,4340,4530,4725,5125,5330,5540,5755,5975,6425,6655", "code": "\nfrom sympy import multiplicity\nA246817, p5 = [0], 0\nfor n in range(5,5*10**3,5):\n....p5 += multiplicity(5,n)*n\n....A246817.append(p5) \n"}
{"sequence_id": "A246824", "text": "Numbers k for which A242720(k) = (prime(k)+1)^2 + 2.", "sequence": "3,35,41,52,57,81,104,209,215,343,373,398,473,477,584,628,768,774,828,872,1117,1145,1189,1287,1324,1435,1615,1634,1653,1704,1886,1925,2070,2075,2123,2171,2193,2425,2449,2605,2633,2934,2948,3019,3194,3273,3533,3552,3685,3758", "code": "\nfrom sympy import prime, isprime, factorint\nA246824_list = [a for a, b in ((n, prime(n)+1) for n in range(3,10**3)) if (not (isprime(b**2-1) and isprime(b**2+1)) and (min(factorint(b**2+1)) > min(factorint(b**2-1)) >= b-1))] \n"}
{"sequence_id": "A246830", "text": "T(n,k) is the concatenation of n-k and n+k in binary; triangle T(n,k), n>=0, 0<=k<=n, read by rows.", "sequence": "0,3,2,10,7,4,15,20,13,6,36,29,22,15,8,45,38,31,40,25,10,54,47,72,57,42,27,12,63,104,89,74,59,44,29,14,136,121,106,91,76,61,46,31,16,153,138,123,108,93,78,63,80,49,18,170,155,140,125,110,95,144,113,82,51,20", "code": "\nA246830 = []\nfor n in range(10**2):\n....for k in range(n):\n........A246830.append(int(bin(n-k)[2:]+bin(n+k)[2:],2))\n....A246830.append(2*n) \n"}
{"sequence_id": "A246831", "text": "a(n) is the concatenation of n and 3n in binary.", "sequence": "0,7,22,57,76,95,210,245,280,315,350,737,804,871,938,1005,1072,1139,1206,1273,1340,1407,2882,3013,3144,3275,3406,3537,3668,3799,3930,4061,4192,4323,4454,4585,4716,4847,4978,5109,5240,5371,5502,11137,11396,11655", "code": "\ndef A246831(n):\n....return int(bin(n)[2:]+bin(3*n)[2:],2) \n"}
{"sequence_id": "A246839", "text": "Number of trailing zeros in A002109(n).", "sequence": "0,0,0,0,0,5,5,5,5,5,15,15,15,15,15,30,30,30,30,30,50,50,50,50,50,100,100,100,100,100,130,130,130,130,130,165,165,165,165,165,205,205,205,205,205,250,250,250,250,250,350,350,350,350,350,405,405,405,405", "code": "\ndef a(n):\n..s = 1\n..for k in range(n+1):\n....s *= k**k\n..i = 1\n..while not s % 10**i:\n....i += 1\n..return i-1\nn = 1\nwhile n < 100:\n..print(a(n),end=', ')\n..n += 1 \n"}
{"sequence_id": "A246839", "text": "Number of trailing zeros in A002109(n).", "sequence": "0,0,0,0,0,5,5,5,5,5,15,15,15,15,15,30,30,30,30,30,50,50,50,50,50,100,100,100,100,100,130,130,130,130,130,165,165,165,165,165,205,205,205,205,205,250,250,250,250,250,350,350,350,350,350,405,405,405,405", "code": "\nfrom sympy import multiplicity\nA246839, p5 = [0,0,0,0,0], 0\nfor n in range(5,10**3,5):\n....p5 += multiplicity(5,n)*n\n....A246839.extend([p5]*5)\n\n"}
{"sequence_id": "A246849", "text": "Decimal expansion of 1-delta_0, where delta_0 is the Hall-Montgomery constant (A143301).", "sequence": "8,2,8,4,9,9,5,0,6,8,5,8,4,6,3,9,3,4,1,3,9,5,6,0,0,2,8,4,4,4,7,8,7,8,9,0,3,7,7,7,3,7,0,9,5,7,7,0,4,4,9,1,5,8,2,8,5,7,8,8,9,0,8,1,7,6,3,0,1,3,9,4,4,0,5,6,9,1,4,2,2,0,1,2,0,2,8,8,0,1,9,1,3,1,9,9,1,8,2,6,9", "code": "\nfrom mpmath import mp, log, exp, polylog, pi\nmp.dps=102\nprint([int(n) for n in list(str(pi**2/6 + log(exp(1/2)+1) - log(exp(1/2)+1)**2 - 2*polylog(2, 1/(exp(1/2)+1)))[2:-1])]) \n"}
{"sequence_id": "A246850", "text": "Even numbers which cannot be represented by the surface area of an n1 X n2 X n3 block.", "sequence": "2,4,8,12,20,36,44,60,84,116,140,156,204,260,380,420,660,924", "code": "\nfrom sympy import integer_nthroot\ndef aupto(lim):\n  e, r, lim2 = set(range(2, lim+1, 2)), set(), integer_nthroot(lim//2, 2)[0]\n  for n1 in range(1, lim2):\n    for n2 in range(n1, lim2):\n      for n3 in range(n2, lim+1):\n        r.add(2*(n1*n2 + n1*n3 + n2*n3))\n  return sorted(e - r)\nprint(aupto(1000)) \n"}
{"sequence_id": "A246870", "text": "Lesser of the Gridgeman pairs in base 2 in increasing order: pairs of primes palindromic in base 2 which differ only in their middle digits.", "sequence": "5,22541,296201,360461,499151,514271,1071937,1096609,1298809,1347877,1458253,4404833,5497829,5694389,6824459,7010219,7168859,7267259,8102639,17629537,19525417,21884773,23330893,24364957,24440413,24538333,24735037,25445443,28493467", "code": "\nfrom sympy import isprime\nA246870 = []\nfor n in range(1,2**17):\n....s1 = bin(n)[2:]\n....s2 = s1[::-1]\n....p1, p2 = int(s1+'0'+s2,base), int(s1+'1'+s2,base)\n....if isprime(p1) and isprime(p2):\n........A246870.append(p1)\nA246870 = sorted(A246870)\n"}
{"sequence_id": "A246871", "text": "Lesser of Gridgeman pairs in base 8 in increasing order: pairs of primes palindromic in base 8 which differ only in their middle digits by a difference of 1.", "sequence": "2,89,479,12547,14563,15667,28807,30367,31663,32119,296969,311561,318281,328721,383321,409889,422369,452009,490481,511289,792131,936227,951851,1345037,1366349,1444901,1505261,1543229,1852679,1861511,1865159,1871951,1898447", "code": "\nfrom gmpy2 import digits\nfrom sympy import isprime\nA246871 = [2]\nfor n in range(1,8**5):\n....s1 = digits(n,8)\n....s2 = s1[::-1]\n....for m in range(7):\n........p1, p2 = int(s1+str(m)+s2,8), int(s1+str(m+1)+s2,8)\n........if isprime(p1) and isprime(p2):\n............A246871.append(p1)\nA246871 = sorted(A246871)\n"}
{"sequence_id": "A246872", "text": "Lesser of Gridgeman pairs in base 16 in increasing order: pairs of primes palindromic in base 16 which differ only in their middle digits by a difference of 1.", "sequence": "2,337,433,1831,2377,3373,3517,104593,209203,229507,236947,244147,253651,332053,337957,341557,350293,361093,376501,477511,486247,488311,489847,497047,592393,633001,639433,744283,745051,766651,885133,894637,906973,911341,914941", "code": "\nfrom gmpy2 import digits\nfrom sympy import isprime\nA246872 = [2]\nfor n in range(1,16**4):\n....s1 = digits(n,16)\n....s2 = s1[::-1]\n....for m in range(15):\n........p1, p2 = int(s1+digits(m,16)+s2,16), int(s1+digits(m+1,16)+s2,16)\n........if isprime(p1) and isprime(p2):\n............A246872.append(p1)\nA246872 = sorted(A246872)\n"}
{"sequence_id": "A246874", "text": "Primes p such that p - m^2, m = 2, 4, 6, 8, are all (positive) primes.", "sequence": "83,167,227,503,677,1217,1487,4973,5843,10337,12437,13163,15683,15923,21803,22067,23057,24107,24113,36587,40883,47717,53633,57287,65183,73013,95633,104123,107777,109583,113147,122267,128987,129533,132173,148403,148727", "code": "\nfrom sympy import prime, isprime\nA246874_list = [p for p in (prime(n) for n in range(1,3*10**6)) if all([isprime(p-m*m) for m in range(2,10,2)])]\n\n"}
{"sequence_id": "A246971", "text": "Triangular array read by rows, arising from enumeration of binary words containing n 0's and k 1's that avoid the pattern 0100010.", "sequence": "1,2,1,6,3,1,20,10,4,1,70,35,15,5,1,248,126,56,21,6,1,894,457,210,84,28,7,1,3264,1674,786,330,120,36,8,1,12036,6183,2947,1280,495,165,45,9,1,44722,22997,11080,4933,1994,715,220,55,10,1", "code": "\nfrom itertools import combinations\nA246971_list = []\nfor n in range(10):\n....for k in range(n,-1,-1):\n........c, d0 = 0, ['0']*(n+k)\n........for x in combinations(range(n+k),n):\n............d = list(d0)\n............for i in x:\n................d[i] = '1'\n............if not '0100010' in ''.join(d):\n................c += 1\n........A246971_list.append(c) \n"}
{"sequence_id": "A246972", "text": "(n+1)^2 concatenated with n^2.", "sequence": "10,41,94,169,2516,3625,4936,6449,8164,10081,121100,144121,169144,196169,225196,256225,289256,324289,361324,400361,441400,484441,529484,576529,625576,676625,729676,784729,841784,900841,961900,1024961,10891024,11561089,12251156,12961225,13691296", "code": "\ndef A246972(n):\n....return int(str((n+1)**2)+str(n**2)) \n"}
{"sequence_id": "A247000", "text": "Maximal number of palindromes in a circular binary word of length n.", "sequence": "1,2,4,6,7,9,10,12,13,15,16,18,19,21,23,24,26,28,29,31,33,34,36,38,39,41,43,44,46,48", "code": "\ndef A247000(n):\n....maxcount = 0\n....for i in range(2**(n-1),2**n):\n........s = format(i,'0'+str(n)+'b')\n........s, plist = s+s[:-1], []\n........for j in range(n):\n............for k in range(n):\n................t = s[j:j+k+1]\n................if t == t[::-1] and not t in plist:\n....................plist.append(t)\n........if len(plist) > maxcount:\n............maxcount = len(plist)\n....return maxcount \n"}
{"sequence_id": "A247012", "text": "Consider the aliquot parts, in ascending order, of a composite number. Take their sum and repeat the process deleting the minimum number and adding the previous sum. The sequence lists the numbers that after some iterations reach a sum equal to the reverse of themselves.", "sequence": "6,133,172,841,1005,1603,4258,5299,192901,498906,1633303,5307589,16333303,20671542,41673714,42999958,73687923", "code": "\nfrom sympy import isprime, divisors\nA247012_list = []\nfor n in range(2,10**9):\n....m = int(str(n)[::-1])\n....if not isprime(n):\n........x = divisors(n)\n........x.pop()\n........y = sum(x)\n........while y < m:\n............x, y = x[1:]+[y], 2*y-x[0]\n........if y == m:\n............A247012_list.append(n) \n"}
{"sequence_id": "A247013", "text": "Consider the prime factors, with multiplicity, in ascending order, of a composite number not ending in 0. Take their sum and repeat the process deleting the minimum number and adding the previous sum. The sequence lists the numbers that after some iterations reach a sum equal to the reverse of themselves.", "sequence": "4,9,14,94,194,371,1887,1994,11282,25656,61081,66691,112082,394407,582225,4284191,5681778,9317913,9361072,9493615,19120874,75519134,92688481", "code": "\nfrom itertools import chain\nfrom sympy import isprime, factorint\nA247013_list = []\nfor n in range(2,10**8):\n....m = int(str(n)[::-1])\n....if n % 10 and not isprime(n):\n........x = sorted(chain.from_iterable([p]*e for p,e in factorint(n).items()))\n........y = sum(x)\n........while y < m:\n............x, y = x[1:]+[y], 2*y-x[0]\n........if y == m:\n............A247013_list.append(n) \n"}
{"sequence_id": "A247016", "text": "Triangular numbers A000217 composed of only curved digits {0, 2, 3, 5, 6, 8, 9}.", "sequence": "0,3,6,28,36,55,66,253,300,325,528,595,630,666,820,903,990,2080,2556,2628,2850,2926,3003,3655,3828,5050,5253,5356,5565,5886,5995,6328,6555,6903,8256,8385,20503,22366,23005,23220,23653,25200,26335,26565,28203,28680,28920", "code": "\nfor n in range(2,10**3):\n..s = str(int(n*(n-1)/2))\n..if not (s.count('1') + s.count('4') + s.count('7')):\n....print(int(s),end=', ') \n"}
{"sequence_id": "A247021", "text": "Triangular numbers composed of only digits with line segments or both line segments and curves {1, 2, 4, 5, 7}.", "sequence": "1,15,21,45,55,171,741,1225,1275,1711,2145,2211,2415,2775,5151,11175,15225,21115,22155,25425,44551,45451,72771,77421,112575,121771,124251,125751,151525,211575,221445,222111,224115,227475,254541,255255,417241,451725,551775,577275", "code": "\nfor n in range(10**3):\n..s = str(int(n*(n+1)/2))\n..if not (s.count('0') + s.count('3') + s.count('6') + s.count('8') + s.count('9')):\n....print(int(s),end=', ') \n"}
{"sequence_id": "A247025", "text": "Lengths of prefixes of the infinite string of digits repeat(1379) which are prime; increasingly sorted.", "sequence": "2,3,7,81,223,250,255,537,543,1042,2103,4285", "code": "\nfrom sympy import isprime\nfrom itertools import cycle\nit=cycle([1,3,7,9])\nc=0\na=0\nfor i in it:\n....c+=1\n....a*=10\n....a+=i\n....if isprime(a):\n........print c\n"}
{"sequence_id": "A247038", "text": "Decimal expansion of Integral_{x=0..1} log(floor(1/x))/(1+x) dx.", "sequence": "6,8,4,7,2,4,7,8,8,5,6,3,1,5,7,1,2,3,2,9,9,1,4,6,1,4,8,7,5,5,7,7,7,6,2,0,4,6,0,6,7,5,4,1,6,3,3,7,4,4,8,8,3,6,6,0,6,2,8,9,8,6,7,8,1,5,9,5,6,8,8,2,1,7,6,2,6,9,3,6,1,0,4,3,7,0,7,6,8,1,4,3,4,9,5,8,5,8,1,0,0,9,9,7", "code": "\nfrom mpmath import mp, log, khinchin\nmp.dps=106\nprint([int(n) for n in list(str(log(2)*log(khinchin)))[2:-2]]) \n"}
{"sequence_id": "A247047", "text": "Numbers n such that n^2 contains 2 distinct digits and n^3 contains 3 distinct digits.", "sequence": "5,6,8,9,15,30,173,300,3000,30000,300000,3000000,30000000,300000000,3000000000", "code": "\nA247047_list = [n for n in range(1,10**6) if len(set(str(n**3))) == 3 and len(set(str(n**2))) == 2]\n\n"}
{"sequence_id": "A247048", "text": "Composite numbers n such that n+2 is also composite and such that (sopfr(n), sopfr(n+2)) is a twin prime pair. A001414 explains notation 'sopfr(n)'.", "sequence": "54,845,1083,37595,50367,50898,101673,103416,107909,112344,117390,160020,172176,266342,761926,839147,1183488,1190597,1629219,1711950,1742585,2247839,2312190,2345894,2372272,2756502,3092261,3679504,3710280,4832298,5267824,5305023,5350590,6720445", "code": "\nfrom sympy import isprime, factorint\nA247048_list = []\nfor n in range(1,10**6):\n....if not(isprime(n) or isprime(n+2)):\n........m = sum(p*e for p,e in factorint(n).items())\n........if isprime(m):\n............m2 = sum(p*e for p,e in factorint(n+2).items())\n............if ((m2 == m+2) or (m == m2+2)) and isprime(m2):\n................A247048_list.append(n)\n\n"}
{"sequence_id": "A247052", "text": "Primes composed of only digits with line segments or both line segments and curves {1, 2, 4, 5, 7}.", "sequence": "2,5,7,11,17,41,47,71,127,151,157,211,227,241,251,257,271,277,421,457,521,541,547,557,571,577,727,751,757,1117,1151,1171,1217,1277,1427,1447,1451,1471,1511,1571,1721,1741,1747,1777,2111,2141,2221,2251,2411,2417", "code": "\nfor n in range(1,10**3):\n..s = str(prime(n))\n..if not (s.count('0') + s.count('3') + s.count('6') + s.count('8') + s.count('9')):\n....print(int(s),end=', ') \n"}
{"sequence_id": "A247089", "text": "Initial members of prime quadruples (n, n+2, n+30, n+32).", "sequence": "11,29,41,71,107,149,197,239,281,431,569,827,1019,1031,1061,1289,1451,1667,1997,2081,2111,2237,2309,2657,2969,3299,3329,3359,3527,3821,4019,4127,4229,4241,4517,5849,6269,6659,6761,7457,7559,8597", "code": "\nfrom sympy import isprime\nfor n in range(1,10000001,2):\n..if isprime(n) and isprime(n+2) and isprime(n+30) and isprime(n+32): print(n,end=', ')\n"}
{"sequence_id": "A247105", "text": "Variation of Flavius Josephus's sieve: Start with the natural numbers; at the k-th sieving step, make k passes removing every k-th term of the sequence remaining after the previous sieving step; iterate.", "sequence": "1,5,25,109,385,1373,4645,16009,48817,159757,488377,1571425,4560901,14482393,43408013,130394125,380755429,1118740741,3326930413,9931863461,28466058257,84243573797,240453967777,706827067045,2009065808473,5913933615149,16711898903281", "code": "\nfor n in range(1, 101):\n..m = n\n..for i in range(n, 1, -1):\n....for j in range(i):\n......t = m * i // (i - 1)\n......while t - t // i >= m:\n........t -= 1\n......m = t + 1\n..print(\"%d %d\" % (n, m)) \n"}
{"sequence_id": "A247108", "text": "Complementary Aitken's array: triangle of numbers {a(n,k), n >= 0, 0<=k<=n} read by rows, defined by a(0,0)=1, a(n,0)=-a(n-1,n-1), a(n,k)=a(n,k-1)+a(n-1,k-1).", "sequence": "1,-1,0,0,-1,-1,1,1,0,-1,1,2,3,3,2,-2,-1,1,4,7,9,-9,-11,-12,-11,-7,0,9,-9,-18,-29,-41,-52,-59,-59,-50,50,41,23,-6,-47,-99,-158,-217,-267,267,317,358,381,375,328,229,71,-146,-413,413,680,997,1355,1736,2111,2439,2668,2739,2593,2180", "code": "\n\nfrom itertools import accumulate\nA247108_list = blist = [1]\nfor _ in range(10**2):\n....b = -blist[-1]\n....blist = list(accumulate([b]+blist))\n....A247108_list += blist\n"}
{"sequence_id": "A247128", "text": "Positive numbers that are congruent to {0,5,9,13,17} mod 22.", "sequence": "5,9,13,17,22,27,31,35,39,44,49,53,57,61,66,71,75,79,83,88,93,97,101,105,110,115,119,123,127,132,137,141,145,149,154,159,163,167,171,176,181,185,189,193,198,203,207,211", "code": "\nfrom math import *\nfor n in range(0,100001):\n..if (sqrt(4*n-ceil(n/3)+3+n%2))%1==0:print(int(sqrt(4*n-ceil(n/3)+3+n%2)),end=\",\")\n"}
{"sequence_id": "A247128", "text": "Positive numbers that are congruent to {0,5,9,13,17} mod 22.", "sequence": "5,9,13,17,22,27,31,35,39,44,49,53,57,61,66,71,75,79,83,88,93,97,101,105,110,115,119,123,127,132,137,141,145,149,154,159,163,167,171,176,181,185,189,193,198,203,207,211", "code": "\nA247128_list = [n for n in range(1,10**5) if (n % 22) in {0,5,9,13,17}]\n\n"}
{"sequence_id": "A247128", "text": "Positive numbers that are congruent to {0,5,9,13,17} mod 22.", "sequence": "5,9,13,17,22,27,31,35,39,44,49,53,57,61,66,71,75,79,83,88,93,97,101,105,110,115,119,123,127,132,137,141,145,149,154,159,163,167,171,176,181,185,189,193,198,203,207,211", "code": "\nA247128_list, l = [], [5,9,13,17,22]\nfor _ in range(10**5):\n....A247128_list.extend(l)\n....l = [x+22 for x in l] \n"}
{"sequence_id": "A247145", "text": "Composite numbers such that the product of the number's proper divisors is divisible by the sum of the number's proper divisors.", "sequence": "6,12,24,28,40,42,56,60,90,120,140,153,216,234,270,290,360,440,496,522,568,585,588,672,708,819,924,984,992,1001,1170,1316,1320,1365,1431,1780,2016,2184,2295,2296,2299,2464,2466,2655,2832,3100,3344,3420,3627,3724,3948,4320,4336,4416,4680", "code": "\nfrom operator import mul\ndef divs(n):\n....for i in range(1,n/2+1):\n........if n%i == 0: yield i\n....yield n\ng = []\nfor a in range(2,100):\n....q = list(divs(a))[0:-1]\n....if reduce(mul, q, 1) % sum(q) == 0 and len(q) != 1::\n........g.append(a)\nprint(g)\n"}
{"sequence_id": "A247165", "text": "Numbers n such that n^2 + 1 divides 2^n - 1.", "sequence": "0,16,256,8208,65536,649800,1382400,4294967296", "code": "\nA247165_list = [n for n in range(10**6) if n == 0 or pow(2,n,n*n+1) == 1]\n\n"}
{"sequence_id": "A247177", "text": "Primes p with property that the sum of the squares of the successive gaps between primes <= p is a prime number.", "sequence": "5,13,29,41,89,97,139,173,179,263,269,281,307,337,353,431,439,461,487,499,509,569,607,613,641,643,661,709,739,761,809,823,839,857,919,941,967,991,1031,1039,1061,1117,1129,1163,1171,1201,1229,1277,1381,1399", "code": "\nfrom sympy import nextprime, isprime\np = 2\ns = 0\nwhile s < 8000:\n    np = nextprime(p)\n    if isprime(s):\n        print(p)\n    d = np - p\n    s += d*d\n    p = np\n"}
{"sequence_id": "A247178", "text": "Primes p with property that the sum of the cubes of the successive gaps between primes <= p is a prime number.", "sequence": "7,13,31,103,157,211,229,277,283,337,349,367,373,379,433,463,499,523,547,577,613,619,643,673,751,907,937,1009,1021,1039,1123,1201,1231,1327,1399,1459,1489,1543,1579,1597,1669,1723,1777,1789,1831,1873,1933,1987,2011,2017", "code": "\nfrom sympy import nextprime, isprime\np=2\ns=0\nwhile 0 < p < 10000:\n    np=nextprime(p)\n    if isprime(s):\n        print(p)\n    d=np-p\n    s+=(d*d*d)\n    p=np\n"}
{"sequence_id": "A247190", "text": "Calculate the smallest positive residues of 2!,3!,...,(prime(n)-1)! modulo prime(n) and stop the calculation at the moment m when for the first time there appear two equal numbers. If m!==k!, then a(n)=k; but a(n)=0 if no such m exists.", "sequence": "0,3,2,4,3,3,4,4,2,6,5,8,4,2,2,8,5,7,4,9,3,8,15,2,14,2,9,2,7,10,3,4,10,13,13,11,2,10,17,12,3,27,3,7,31,19,10,2,21,14,8,2,14,11,7,15,17,14,8,17,3,14,4,10,20,7,2,24,2,2,10,5,18,44,21,36", "code": "\nfrom sympy import prime\ndef A247190(n):\n....p, f, fv = prime(n), 1, {}\n....for i in range(2,p):\n........f = (f*i) % p\n........if f in fv:\n............return fv[f]\n........else:\n............fv[f] = i\n....else:\n........return 0 \n"}
{"sequence_id": "A247213", "text": "Numbers n = Product_(p_i^e_i) such that nn = Product_((p_i + 2)^e_i) is divisible by n.", "sequence": "1,2,4,8,16,32,64,105,128,210,256,315,420,512,630,840,1024,1260,1575,1680,2048,2520,3150,3360,4096,5040,6300,6720,8192,10080,11025,12600,13440,16384,20160,22050,25200,26880,32768,33075,40320,44100,50400,53760,65536", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import factorint\nA247213_list = [n for n in range(1,10**4) if n <= 1 or not reduce(mul,[(p+2)**e for p,e in factorint(n).items()]) % n]\n\n"}
{"sequence_id": "A247219", "text": "Positive numbers n such that n^2 - 1 divides 2^n - 1.", "sequence": "2,4,16,36,256,456,1296,2556,4356,6480,8008,11952,26320,44100,47520,47880,49680,57240,65536,74448,84420,97812,141156,157080,165600,225456,278496,310590,333432,365940,403900,419710,476736,557040,560736,576720,647088,1011960,1033056,1204560,1206180", "code": "\nfrom gmpy2 import powmod\nA247219_list = [n for n in range(2,10**7) if powmod(2,n,n*n-1) == 1]\n\n"}
{"sequence_id": "A247220", "text": "Numbers k such that k^2 + 1 divides 2^k + 1.", "sequence": "0,2,4,386,20136,59140,373164544", "code": "\nfrom gmpy2 import powmod\nA247220_list = [i for i in range(10**7) if powmod(2,i,i*i+1) == i*i]\n\n"}
{"sequence_id": "A247221", "text": "Numbers n such that 2*n^2 + 1 divides 2^n + 1.", "sequence": "0,1,67653,2124804", "code": "\nA247221_list = [n for n in range(10**6) if pow(2,n,2*n*n+1) == 2*n*n]\n\n"}
{"sequence_id": "A247248", "text": "a(n) is the least k such that n divides 2^k + k.", "sequence": "1,2,1,4,4,2,6,8,7,4,3,8,12,6,7,16,16,14,18,4,19,8,22,8,33,12,7,40,11,26,23,32,8,16,6,32,5,18,37,24,40,38,42,8,7,22,10,32,61,84,38,12,35,32,46,40,32,28,24,44,17,30,61,64,66,8,66,16,67,6,11,32", "code": "\ndef A247248(n):\n....if n == 1:\n........return 1\n....else:\n........x, k, kr = 1,0,0\n........while (x+kr) % n:\n............x, kr = (2*x) % n, (kr+1) % n\n............k += 1\n........return k\n\n"}
{"sequence_id": "A247348", "text": "Primes p such that (p-k)/(k+1) is also prime for k = 1, 2, 3, 4.", "sequence": "174599,334319,535919,671039,907199,2129399,2298119,3103799,3369959,4351199,4598159,5697599,6184799,6446159,7224839,7943759,7957319,8148839,8346959,8656919,9096359,9339119,9463319,9511199,10514159,10780559,11816999,12424319,13781039", "code": "\nfrom __future__ import division\nfrom sympy import prime, isprime\nA247348_list = [p for p in (5*prime(n)+4 for n in range(1,10**6)) if not ((p-1) % 2 or (p-2) % 3 or (p-3) % 4) and isprime(p) and isprime((p-1)//2) and isprime((p-2)//3) and isprime((p-3)//4)] \n"}
{"sequence_id": "A247351", "text": "Nearest prime to Pi*10^(n-1).", "sequence": "3,31,313,3137,31397,314159,3141601,31415899,314159257,3141592661,31415926541,314159265359,3141592653581,31415926535879,314159265358951,3141592653589771,31415926535897921,314159265358979347,3141592653589793239,31415926535897932363", "code": "\nfrom sympy import isprime, nextprime, prevprime, S\ndef a(n):\n  target = int(S.Pi*10**(n-1))\n  if isprime(target): return target\n  before, after = prevprime(target), nextprime(target)\n  return before if target-before <= after-target else after\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A247358", "text": "Triangle read by rows: n-th row contains powers b^e with b + e = n + 1 in natural order.", "sequence": "1,1,2,1,3,4,1,4,8,9,1,5,16,16,27,1,6,25,32,64,81,1,7,36,64,125,243,256,1,8,49,128,216,625,729,1024,1,9,64,256,343,1296,2187,3125,4096,1,10,81,512,512,2401,6561,7776,15625,16384,1,11,100,729,1024,4096,16807,19683,46656,65536,78125", "code": "\nfrom itertools import chain\nA247358_list = list(chain.from_iterable(sorted((b+1)**(n-b) for b in range(n)) for n in range(1,8))) \n"}
{"sequence_id": "A247363", "text": "Central terms of triangle A247358.", "sequence": "1,3,16,64,343,4096,59049,1000000,14348907,129140163,1475789056,38443359375,1099511627776,34271896307633,1156831381426176,42052983462257059,1152921504606846976,18446744073709551616,295147905179352825856,12116574790945106558976", "code": "\ndef A247363(n):\n....return(sorted((b+1)**((2*n-1)-b) for b in range(2*n-1))[n-1])\n\n"}
{"sequence_id": "A247377", "text": "Decimal expansion of integral_{0..infinity} 1/Gamma(1+x) dx, a variation of the Frans\u00e9n-Robinson constant.", "sequence": "2,2,6,6,5,3,4,5,0,7,6,9,9,8,4,8,8,3,5,0,7,1,9,6,3,8,5,7,6,7,8,2,2,0,9,1,8,4,0,8,8,2,9,7,1,4,2,8,0,2,2,2,1,9,3,8,6,1,0,9,3,5,5,4,4,2,9,1,8,8,9,9,7,6,9,1,3,7,5,2,8,1,0,8,5,0,9,1,0,6,9,7,4,7,9,3,4,0,6,9,5,8,8,4", "code": "\nfrom sympy.mpmath import *\nmp.dps = 200\nA247377 = [d for d in nstr(quad(lambda x:1/gamma(1+x),[0,inf]),n=mp.dps)[:-1] if d != '.'] \n"}
{"sequence_id": "A247452", "text": "a(n)=3^n*Bell(n).", "sequence": "1,3,18,135,1215,12636,147987,1917999,27162540,416236401,6848207775,120206639790,2239278203277,44074161731151,913065539247018,19843943547060315,451135755042249987,10701182793462338052,264250529777677991751,6779171511882363638619,180350988089950776032172", "code": "\n\nfrom itertools import accumulate\nA247452_list, blist, b, n3 = [1,3], [1], 1, 9\nfor _ in range(2,201):\n....blist = list(accumulate([b]+blist))\n....b = blist[-1]\n....A247452_list.append(b*n3)\n....n3 *= 3 \n"}
{"sequence_id": "A247541", "text": "a(n) = 7*n^2 + 1.", "sequence": "1,8,29,64,113,176,253,344,449,568,701,848,1009,1184,1373,1576,1793,2024,2269,2528,2801,3088,3389,3704,4033,4376,4733,5104,5489,5888,6301,6728,7169,7624,8093,8576,9073,9584,10109,10648,11201,11768,12349,12944,13553", "code": "\nfor n in range (0,500) : print (7*n**2+1)\n"}
{"sequence_id": "A247586", "text": "Number of acute triangles with integer sides less than or equal to n.", "sequence": "1,3,6,11,17,25,36,49,64,81,102,127,154,185,219,258,301,349,401,457,520,587,660,740,824,914,1010,1114,1225,1342,1468,1600,1740,1887,2041,2206,2378,2561,2750,2948", "code": "\nimport itertools\ndef A247586(n):\n    I = itertools.combinations_with_replacement(range(1,n+1),3)\n    F = filter(lambda c: c[0]**2 + c[1]**2 > c[2]**2, I)\n    return len(list(F))\nprint([A247586(n) for n in range(41)]) \n"}
{"sequence_id": "A247592", "text": "Numbers n such that A002496(n) mod A002496(n-1) is a perfect square.", "sequence": "2,8,10,25,42,147,160,169,238,260,491,544,869,890,923,1140,1337,1386,1465,1643,1927,3371,4614,5038,5086,5225,5832,5909,5995,7118,7157,8540,9859,12543,13505,13795,13841,14211,15347,17079,17263,18643,20211,21184,21245", "code": "\nfrom gmpy2 import t_mod, is_square, is_prime\nA247592_list, A002496_list, m, c = [], [2], 2, 2\nfor n in range(1, 10**7):\n....m += 2*n+1\n....if is_prime(m):\n........if is_square(t_mod(m, A002496_list[-1])):\n............A247592_list.append(c)\n........A002496_list.append(m)\n........c += 1 \n"}
{"sequence_id": "A247647", "text": "Binary numbers that begin and end with 1 and do not contain two adjacent zeros.", "sequence": "1,11,101,111,1011,1101,1111,10101,10111,11011,11101,11111,101011,101101,101111,110101,110111,111011,111101,111111,1010101,1010111,1011011,1011101,1011111,1101011,1101101,1101111,1110101,1110111,1111011,1111101,1111111,10101011,10101101,10101111,10110101,10110111,10111011,10111101", "code": "\nA247647_list = [int(bin(n)[2:]) for n in range(1,10**5) if n % 2 and not '00' in bin(n)]\n\n"}
{"sequence_id": "A247648", "text": "Numbers whose binary expansion begins and ends with 1 and does not contain two adjacent zeros.", "sequence": "1,3,5,7,11,13,15,21,23,27,29,31,43,45,47,53,55,59,61,63,85,87,91,93,95,107,109,111,117,119,123,125,127,171,173,175,181,183,187,189,191,213,215,219,221,223,235,237,239,245,247,251,253", "code": "\nA247648_list = [n for n in range(1,10**5) if n % 2 and not '00' in bin(n)]\n\n"}
{"sequence_id": "A247649", "text": "Number of terms in expansion of f^n mod 2, where f = 1/x^2 + 1/x + 1 + x + x^2 mod 2.", "sequence": "1,5,5,7,5,17,7,19,5,25,17,19,7,31,19,25,5,25,25,35,17,61,19,71,7,35,31,41,19,71,25,77,5,25,25,35,25,85,35,95,17,85,61,71,19,91,71,77,7,35,35,49,31,107,41,121,19,95,71,85,25,113,77,103", "code": "\nimport sympy\nfrom functools import reduce\nfrom operator import mul\nx = sympy.symbols('x')\nf = 1/x**2+1/x+1+x+x**2\nA247649_list, g = [1], 1\nfor n in range(1,1001):\n    s = [int(d,2) for d in bin(n)[2:].split('00') if d != '']\n    g = (g*f).expand(modulus=2)\n    if len(s) == 1:\n        A247649_list.append(g.subs(x,1))\n    else:\n        A247649_list.append(reduce(mul,(A247649_list[d] for d in s)))\n\n"}
{"sequence_id": "A247650", "text": "Number of terms in expansion of f^n mod 2, where f = (1/x^2+1/x+1+x+x^2)*(1/y^2+1/y+1+y+y^2) mod 2.", "sequence": "1,25,25,49,25,289,49,361,25,625,289,361,49,961,361,625,25,625,625,1225,289,3721,361,5041,49,1225,961,1681,361,5041,625,5929,25,625,625,1225,625,7225,1225,9025,289,7225,3721,5041,361,8281,5041,5929,49,1225", "code": "\nimport sympy\nfrom operator import mul\nfrom functools import reduce\nx, y = sympy.symbols('x y')\nf = ((1/x**2+1/x+1+x+x**2)*(1/y**2+1/y+1+y+y**2)).expand(modulus=2)\nA247650_list, g = [1], 1\nfor n in range(1,101):\n....s = [int(d,2) for d in bin(n)[2:].split('00') if d != '']\n....g = (g*f).expand(modulus=2)\n....if len(s) == 1:\n........A247650_list.append(g.subs([(x,1),(y,1)]))\n....else:\n........A247650_list.append(reduce(mul,(A247650_list[d] for d in s)))\n\n"}
{"sequence_id": "A247698", "text": "Brady numbers: B(n) = B(n - 1) + B(n - 2) with B(1) = 2308 and  B(2) = 4261.", "sequence": "2308,4261,6569,10830,17399,28229,45628,73857,119485,193342,312827,506169,818996,1325165,2144161,3469326,5613487,9082813,14696300,23779113,38475413,62254526,100729939,162984465,263714404,426698869,690413273,1117112142,1807525415,2924637557,4732162972,7656800529", "code": "\ndef A247698_list(n):\n    list = [2308, 4261] + [0] * (n - 2)\n    for i in range(2, n):\n        list[i] = list[i - 1] + list[i - 2]\n    return list\nprint(A247698_list(32)) \n"}
{"sequence_id": "A247747", "text": "Whole number sieve of Pi.", "sequence": "1,5,9,8,4,7,9,9,5,2,16,20,62,8,3,9,28,9,44,95,58,3,2,5,8,8,7,28,0,10,59,9,7,4,78,6,6,60,6,54,66,9,0,60,9,2,7,0,1,88,0,96,9,0,6,6,0,0,305,6,4,9,9,94,270,7,9,2,6,93,1,3,5,7,6,9,35,57,9,8,0", "code": "\ndef arccot(x, unity):\n    sum = xpower = unity // x\n    n = 3\n    sign = -1\n    while 1:\n        xpower = xpower // (x*x)\n        term = xpower // n\n        if not term:\n            break\n        sum += sign * term\n        sign = -sign\n        n += 2\n    return sum\ndef pi(digits):\n    unity = 10**(digits + 10)\n    pi = 4 * (4*arccot(5, unity) - arccot(239, unity))\n    return pi // 10**10\ndef primes(n):\n    \"\"\" Returns  a list of primes < n \"\"\"\n    sieve = [True] * n\nfor i in range(3, int(n**0.5)+1, 2):\n        if sieve[i]:\n            sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1)\nreturn [2] + [i for i in range(3, n, 2) if sieve[i]]\na = pi(400)\nb = range(100000)\ny = str(a)\nfor x in b:\n    if str(x) in y:\n        y = y.replace(str(x), \" \", 1)\nwhile \"  \" in y:\n    y = y.replace(\"  \", \" \")\nz = y.split(\" \")\nz = filter(None, z)\nf = map(int, z)\nprint(f[0:-1])\n\n\n"}
{"sequence_id": "A247792", "text": "a(n) = 9*n^2 + 1.", "sequence": "1,10,37,82,145,226,325,442,577,730,901,1090,1297,1522,1765,2026,2305,2602,2917,3250,3601,3970,4357,4762,5185,5626,6085,6562,7057,7570,8101,8650,9217,9802,10405,11026,11665,12322,12997,13690,14401,15130,15877,16642,17425,18226,19045,19882", "code": " for n in range (0,100): print (9*n**2+1)\n"}
{"sequence_id": "A247843", "text": "Consecutive exclusionary squares: Numbers n such that n^2 does not contain digits of n and (n+1)^2 does not contain digits of n+1.", "sequence": "2,3,7,8,17,33,38,53,57,58,157,187,237,313,333,557,558,672,688,738,787,788,812,813,853,1557,2087,2107,2112,3112,3113,3157,3333,3357,3358,4453,4553,5598,5857,6672,6688,7017,7287,7772,7888,7908,8087,8337,15787,17157,18557,22112,32358", "code": "\nfor n in range(10**5):\n..s,t = str(n),str(n+1)\n..s2,t2 = str(n**2),str((n+1)**2)\n..c = 0\n..for i in s:\n....if s2.count(i):\n......c += 1\n......break\n..for j in t:\n....if t2.count(j):\n......c += 1\n......break\n..if not c:\n....print(n,end=', ')\n"}
{"sequence_id": "A247855", "text": "The 10th Hermite Polynomial evaluated at n: H_10(n) = 1024*n^10 - 23040*n^8 + 161280*n^6 - 403200*n^4 + 302400*n^2 - 30240.", "sequence": "-30240,8224,200416,-3093984,125984224,3275529760,30232000224,174454774816,753610971616,2661760648224,8093278209760,21900944840224,53969864949216,123139662877216,263393520320224,533257736009760,1029623343008224,1907515621443616", "code": "\nm = [3715891200, -16721510400, 30036787200, -27095040000, 12533391360, -2612736000, 139499520, 3640320, 153728, -38464, -30240]\nA247855_list = [m[-1]]\nfor _ in range(10**1):\n....for i in range(10):\n........m[i+1]+= m[i]\n....A247855_list.append(m[-1]) \n"}
{"sequence_id": "A247875", "text": "Numbers that are even or whose binary expansions contain one or more pairs of adjacent zeros when odd.", "sequence": "0,2,4,6,8,9,10,12,14,16,17,18,19,20,22,24,25,26,28,30,32,33,34,35,36,37,38,39,40,41,42,44,46,48,49,50,51,52,54,56,57,58,60,62,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,86", "code": "\nA247875_list = [n for n in range(10**3) if not n % 2 or '00' in bin(n)]\n\n"}
{"sequence_id": "A247883", "text": "Consecutive exclusionary cubes: Digits of n are not present in n^3 and digits of n+1 are not present in n+1.", "sequence": "2,7,47,52,187,222,477,587,5522,6777", "code": "\nfor n in range(10**6):\n..s,t = str(n),str(n+1)\n..s3,t3 = str(n**3),str((n+1)**3)\n..c = 0\n..for i in s:\n....if s3.count(i):\n......c += 1\n......break\n..for j in t:\n....if t3.count(j):\n......c += 1\n......break\n..if not c:\n....print(n,end=', ')\n"}
{"sequence_id": "A247884", "text": "Number of positive integers < 10^n divisible by their first digit.", "sequence": "9,41,327,3158,31450,314349,3143320,31433005,314329833,3143298089,31432980631,314329806030,3143298060001,31432980599686,314329805996514,3143298059964770,31432980599647312,314329805996472711,3143298059964726682,31432980599647266367", "code": "\ncount = 9\nprint(1,9)\nn = 2\nwhile n < 101:\n....for a in range(1,10):\n........count += 10**(n-1)/a\n........if 10**(n-1) % a != 0:\n............count += 1\n....print(n,count)\n....n += 1\n\n"}
{"sequence_id": "A247891", "text": "a(n) is Gray-coded in base 4 into n.", "sequence": "0,1,2,3,5,6,7,4,10,11,8,9,15,12,13,14,21,22,23,20,26,27,24,25,31,28,29,30,16,17,18,19,42,43,40,41,47,44,45,46,32,33,34,35,37,38,39,36,63,60,61,62,48,49,50,51,53,54,55,52,58,59,56,57,85,86,87,84,90", "code": "\ndef basexor(a, b, base):\n  result = 0\n  digit = 1\n  while a or b:\n    da = a % base\n    db = b % base\n    a //= base\n    b //= base\n    sum = (da+db) % base\n    result += sum * digit\n    digit *= base\n  return result\nbase = 4  \nfor n in range(129):\n  a = n\n  b = n//base\n  while b:\n    a = basexor(a,b, base)\n    b //= base\n  print str(a)+',',\n"}
{"sequence_id": "A248018", "text": "Least number k > 0 such that n^k contains n*R_n in its decimal representation, or 0 if no such k exists.", "sequence": "1,43,119,96,186,1740,6177,8421,104191,0,946417", "code": "\ndef a(n):\n..s = str(n)\n..p = len(s)\n..if s.count('1') == 1 and s.count('0') == p - 1:\n....return 0\n..k = 1\n..while not str(n**k).count(n*s):\n....k += 1\n..return k\nn = 1\nwhile n < 10:\n..print(a(n),end=', ')\n..n += 1\n\n"}
{"sequence_id": "A248080", "text": "Decimal expansion of P_0(xi), the maximum limiting probability that a random n-permutation has no cycle exceeding a given length.", "sequence": "0,9,8,7,1,1,7,5,4,4,8,0,7,1,4,6,9,2,4,9,3,7,2,1,3,0,8,2,3,7,0,2,0,6,7,9,9,3,3,3,3,3,3,5,4,7,8,0,8,4,4,0,0,0,2,5,6,6,9,7,9,0,8,3,6,2,2,5,2,5,3,6,4,2,7,4,0,6,3,0,1,5,8,6,2,6,3,0,0,2,1,5,7,5,9,2,4,5,4,6,1,6", "code": "\nfrom mpmath import *\nmp.dps=102\nxi=1/(1 + sqrt(e))\nC = log(xi)**2/2 + log(xi) + polylog(2, xi) - pi**2/12 + 1\nprint([int(n) for n in list(str(C)[2:-1])]) \n"}
{"sequence_id": "A248109", "text": "Integer part of square root of A010811(n) = n^23.", "sequence": "0,1,2896,306827,8388608,109183006,888667667,5231514822,24296003999,94143178827,316227766016,946271759726,2573856496961,6461726194556,15152085430295,33500360392119,70368744177664,141306648466586", "code": "\nfrom decimal import *\ngetcontext().prec = 100\nfor n in range(0,1001): print n, int(Decimal(n**23).sqrt())\n"}
{"sequence_id": "A248132", "text": "Integer part of square root of A010813(n) = n^25.", "sequence": "0,1,5792,920482,33554432,545915033,5332006004,36620603758,194368031998,847288609443,3162277660168,10408989356987,30886277963534,84002440529229,212129196024140,502505405881790,1125899906842624", "code": "\nfrom decimal import *\ngetcontext().prec = 100\nfor n in range(0, 1001): print int(Decimal(n**25).sqrt())\n"}
{"sequence_id": "A248135", "text": "Composite numbers c that divide the sum of remainders of c' mod k, for k from 1 to c', where c' is the arithmetic derivative of c.", "sequence": "1,12,52,840,988,1461,4926,21376,130484,210840,297158", "code": "\nfrom sympy import isprime, factorint\nA248135_list = []\nfor n in range(1,10**6):\n....if not isprime(n):\n........a = sum([int(n*e/p) for p, e in factorint(n).items()]) if n > 1 else 0\n........if not sum(a % i for i in range(1,a)) % n:\n............A248135_list.append(n)\n\n"}
{"sequence_id": "A248153", "text": "Start with a(0)=10, then a(n) = 7 times the n-th digit of the sequence.", "sequence": "10,7,0,49,0,28,63,0,14,56,42,21,0,7,28,35,42,28,14,14,7,0,49,14,56,21,35,28,14,14,56,7,28,7,28,49,0,28,63,7,28,35,42,14,7,21,35,14,56,7,28,7,28,35,42,49,14,56,49,14,56,28,63,0,14,56,42,21,49,14,56,21,35", "code": "\ndef aupton(nn):\n    alst, astr = [10], \"X10\"\n    for n in range(1, nn+1):\n        alst.append(7 * int(astr[n]))\n        astr += str(alst[-1])\n    return alst\nprint(aupton(72)) \n"}
{"sequence_id": "A248210", "text": "Zeroless numbers k (numbers in A052382) such that k - DigitProduct(k) contains the same distinct digits as k.", "sequence": "293,362,436,545,554,631,653,749,763,891,958,965,1293,1362,1436,1545,1554,1631,1653,1749,1763,1891,1958,1965,2193,2331,2491,2536,2556,2565,2693,2917,2954,2963,3162,3231,3325,3382,3529,3534,3635,3651,4291,4515,4533,4551,4634,4935,4952,4971", "code": "\nfrom math import prod\ndef ok(n):\n    s = str(n)\n    return '0' not in s and set(str(n-prod(int(d) for d in s))) == set(s)\nprint(list(filter(ok, range(5000)))) \n"}
{"sequence_id": "A248323", "text": "Numbers n which appear at least twice in A037278(n), concatenation of their divisors written in base 10.", "sequence": "11,12,42,84,124,135,248,325,366,510,550,555,624,650,714,1010,1111,1525,1734,2510,3913,4020,5100,5500,5610,5625,8040,11111,13515,16575,21175,24104,25500,28160,34170,35250,35610,36800,37444,44919,50100,51020,51102,51250,52000", "code": "\nfrom sympy import divisors\nimport re\nA248323_list = [n for n in range(1,10**7) if len(list(re.finditer('(?='+str(n)+')',''.join([str(d) for d in divisors(n)])))) > 1]\n\n"}
{"sequence_id": "A248339", "text": "a(n) = 22*n+19.", "sequence": "19,41,63,85,107,129,151,173,195,217,239,261,283,305,327,349,371,393,415,437,459,481,503,525,547,569,591,613,635,657,679,701,723,745,767,789,811,833,855,877,899,921,943,965,987,1009", "code": "\nfor n in range(101):\n..print(22*n+19,end=', ')\n"}
{"sequence_id": "A248365", "text": "4n concatenated with itself.", "sequence": "44,88,1212,1616,2020,2424,2828,3232,3636,4040,4444,4848,5252,5656,6060,6464,6868,7272,7676,8080,8484,8888,9292,9696,100100,104104,108108,112112,116116,120120,124124,128128,132132,136136,140140,144144,148148,152152,156156", "code": " {print(str(4*n)*2,end=', ') for n in range(1,50)} \n"}
{"sequence_id": "A248367", "text": "Initial members of prime quadruples (n, n+2, n+36, n+38).", "sequence": "5,71,101,191,311,821,1451,4091,4481,4931,5441,6791,12071,13721,14591,17921,18251,20441,20771,20981,21521,21611,35801,38711,41141,41981,43541,46271,47351,47741,48821,49331,53231,64151,70841", "code": "\nfrom sympy import isprime\nfor n in range(1,10000001,2):\n..if isprime(n) and isprime(n+2) and isprime(n+36) and isprime(n+38): print(n,end=', ')\n"}
{"sequence_id": "A248410", "text": "a(n) = number of polynomials a_k*x^k + ... + a_1*x + n with k > 0, integer coefficients and only distinct integer roots.", "sequence": "3,11,11,23,11,43,11,47,23,43,11,103,11,43,43,83,11,103,11,103,43,43,11,223,23,43,47,103,11,187,11,139,43,43,43,275,11,43,43,223,11,187,11,103,103,43,11,427,23,103,43,103,11,223,43,223,43,43,11,503,11,43,103,227,43,187,11,103,43,187,11,635,11,43,103,103,43,187,11", "code": "\nfrom itertools import chain, combinations\ndef powerset(iterable):\n...s = list(iterable)\n...return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\nprint(\"Start\")\na_n = 0\nfor num in range(1,1000):\n...div_set = set((-1,1))\n...a_n = 0\n...for divisor in range(1, num + 1):\n......if (num % divisor == 0):\n.........div_set.add(divisor)\n.........div_set.add(divisor*(-1))\n...pow_set = set(powerset(div_set))\n...num_set = len(pow_set)\n...for count_set in range(0, num_set):\n......subset = set(pow_set.pop())\n......num_subset = len(subset)\n......prod = 1\n......if num_subset < 1:\n.........prod = 0\n......for count_subset in range (0, num_subset):\n.........prod = prod * subset.pop()\n......if prod != 0:\n.........if (num % prod == 0):\n............a_n = a_n +1\n...print(num, a_n)\nprint(\"Ende\")\n"}
{"sequence_id": "A248474", "text": "Numbers congruent to 13 or 17 mod 30.", "sequence": "13,17,43,47,73,77,103,107,133,137,163,167,193,197,223,227,253,257,283,287,313,317,343,347,373,377,403,407,433,437,463,467,493,497,523,527,553,557,583,587,613,617", "code": "\nfor n in range(1,101):\n..print (n*30-17),\n..print (n*30-13),\n"}
{"sequence_id": "A248523", "text": "Initial members of prime quadruples (n, n+2, n+144, n+146).", "sequence": "5,137,1787,1997,2237,2657,3527,4127,4337,4787,8087,12107,13757,14447,17987,19697,21377,23057,23687,31247,32297,34157,34367,35447,37547,38567,39227,43397,48677,51197,51827,53087,58907,65027,65837", "code": "\nfrom sympy import isprime\nfor n in range(1,10000001,2):\n..if isprime(n) and isprime(n+2) and isprime(n+144) and isprime(n+146): print(n,end=', ')\n"}
{"sequence_id": "A248558", "text": "Squares of the digits of the decimal expansion of e.", "sequence": "4,49,1,64,4,64,1,64,4,64,16,25,81,0,16,25,4,9,25,9,36,0,4,64,49,16,49,1,9,25,4,36,36,4,16,81,49,49,25,49,4,16,49,0,81,9,36,81,81,81,25,81,25,49,16,81,36,36,81,36,49,36,4,49,49,4,16,0,49,36", "code": "s=\"4\".for c in str(math.e*10**15)[1:-2]:..s = s+\",\"+str( int(c)*int(c)).print(s)\n"}
{"sequence_id": "A248572", "text": "a(n) = 29*n + 1.", "sequence": "1,30,59,88,117,146,175,204,233,262,291,320,349,378,407,436,465,494,523,552,581,610,639,668,697,726,755,784,813,842,871,900,929,958,987,1016,1045,1074,1103,1132,1161,1190,1219,1248,1277,1306,1335,1364,1393,1422", "code": "\nfor n in range(61):\n    print(29*n+1, end=', ')\n"}
{"sequence_id": "A248587", "text": "The smallest of four consecutive primes whose sum is a perfect cube.", "sequence": "4812191,6353029,8039333,8821867,19876711,60742631,85017061,108879847,127042367,138853049,170367959,238190951,259108427,414949357,485941193,512095739,529218559,582868471,623331491,648485381,771656657,1001132351,1098706507,1172752457", "code": "\nfrom __future__ division\nfrom sympy import nextprime, prevprime\nA248587_list = []\nfor i in range(3,10**6):\n    n = i**3\n    p3 = prevprime(n//4)\n    p2, p4 = prevprime(p3), nextprime(p3)\n    p1 = prevprime(p2)\n    q = p1+p2+p3+p4\n    while q <= n:\n        if q == n:\n            A248587_list.append(p1)\n        p1, p2, p3, p4 = p2, p3, p4, nextprime(p4)\n        q = p1+p2+p3+p4 \n"}
{"sequence_id": "A248620", "text": "Lesser of twin primes of (29n + 1, 29n + 3).", "sequence": "59,1277,1451,3539,4931,5279,9281,9629,10499,11717,12239,16067,22157,23027,23201,24419,26681,31727,34511,35729,37991,40427,45821,47387,48779,55217,59219,60089,70181,70877,72269,75401,77489,79229,80447,83231,85667,88799", "code": "\nfrom math import *\nfrom sympy import isprime\nfor n in range(0,10001):\n..if isprime(58*n+1) and isprime(58*n+3): print (58*n+1,end=', ')\n"}
{"sequence_id": "A248646", "text": "Expansion of x*(5+x+x^2)/(1-2*x).", "sequence": "2,5,11,23,46,92,184,368,736,1472,2944,5888,11776,23552,47104,94208,188416,376832,753664,1507328,3014656,6029312,12058624,24117248,48234496,96468992,192937984,385875968,771751936,1543503872,3087007744,6174015488,12348030976", "code": " print([int(23*2**(n-4)) for n in range(1, 34)]) \n"}
{"sequence_id": "A248661", "text": "Initial members of prime quadruples (n, n+2, n+54, n+56).", "sequence": "5,17,137,227,827,1427,1667,1877,2027,2087,2657,3527,3767,4217,4967,10037,11117,11777,12107,13877,17987,19697,20717,21557,22037,23687,24977,27527,27737,34157,37307,41177,42017,42407,47657,48677", "code": "\nfrom sympy import isprime\nfor n in range(1,10000001,2):\n..if isprime(n) and isprime(n+2) and isprime(n+54) and isprime(n+56): print(n,end=', ')\n"}
{"sequence_id": "A248663", "text": "a(1) = 0; a(A000040(n)) = 2^(n-1), and a(n*m) = a(n) XOR a(m).", "sequence": "0,1,2,0,4,3,8,1,0,5,16,2,32,9,6,0,64,1,128,4,10,17,256,3,0,33,2,8,512,7,1024,1,18,65,12,0,2048,129,34,5,4096,11,8192,16,4,257,16384,2,0,1,66,32,32768,3,20,9,130,513,65536,6,131072,1025,8,0,36,19", "code": "\nfrom sympy import factorint, primepi\nfrom sympy.ntheory.factor_ import core\ndef a048675(n):\n    f=factorint(n)\n    return 0 if n==1 else sum([f[i]*2**(primepi(i) - 1) for i in f])\ndef a(n): return a048675(core(n)) print [a(n) for n in range(1, 101)] \n"}
{"sequence_id": "A248705", "text": "The cubes related to the strictly increasing subsequence of A053668(n), n >= 1.", "sequence": "1,8,27,64,343,729,2744,3375,6859,35937,46656,148877,287496,438976,778688,2985984,3869893,8489664,34645976,43986977,58863869,75686967,398688256,426957777,485587656,596947688,835896888,1693669888,2548895896,2954987875,4758586568", "code": "\nfrom operator import mul\nfrom functools import reduce\nA248705_list, x, m  = [], 0, [6, -6, 1, 0]\nfor _ in range(10**9):\n....for i in range(3):\n........m[i+1]+= m[i]\n....xn = reduce(mul,[int(d) for d in str(m[-1])],1)\n....if xn > x:\n........x = xn\n........A248705_list.append(m[-1]) \n"}
{"sequence_id": "A248717", "text": "Zeroless numbers k such that k - (sum of digits of k) and k - (product of digits of k) contain the same distinct digits as k.", "sequence": "12331,13231,13651,21331,23131,23552,25545,26553,31231,31651,32131,32552,34355,34531,34554,35354,35453,35631,36156,36231,43531,45353,46431,53631,54353,54885,55245,55296,59652,61599,63231,64431,87973,95274,122553,125918,126531,126535,126553", "code": "\nfrom math import prod\ndef ok(n):\n    s = str(n); d = list(map(int, s))\n    if '0' in s: return False\n    return set(s) == set(str(n-sum(d))) and set(s) == set(str(n-prod(d)))\nprint(list(filter(ok, range(127000)))) \n"}
{"sequence_id": "A248739", "text": "a(n) = 29*n + ceiling(n/29).", "sequence": "0,30,59,88,117,146,175,204,233,262,291,320,349,378,407,436,465,494,523,552,581,610,639,668,697,726,755,784,813,842,872,901,930,959,988,1017,1046,1075,1104,1133,1162,1191,1220,1249,1278,1307,1336,1365,1394,1423", "code": "\nfrom math import *\nfor n in range(0,101):\n..print n,(29*n+ceil(n/29.0))\n"}
{"sequence_id": "A248786", "text": "a(n) =  29*n + floor(n/29) + 0^n - 0^(n mod 29).", "sequence": "0,29,58,87,116,145,174,203,232,261,290,319,348,377,406,435,464,493,522,551,580,609,638,667,696,725,754,783,812,841,871,900,929,958,987,1016,1045,1074,1103,1132,1161,1190,1219,1248", "code": "\nfrom math import *\nfrom decimal import *\ngetcontext().prec = 100\nfor n in range(0,101):\n..print n,(29*n+floor(n/29.0))+ 0**n-0**(n%29)\n"}
{"sequence_id": "A248791", "text": "Decimal expansion of P_2(xi), the maximum limiting probability that a random n-permutation has exactly two cycles exceeding a given length.", "sequence": "0,7,2,7,8,8,7,3,8,6,6,0,8,2,1,3,7,3,3,6,6,7,1,8,6,6,3,3,1,8,1,9,1,4,2,9,6,8,8,9,2,9,5,4,9,4,4,8,7,0,6,8,4,1,4,5,7,5,1,3,1,8,3,4,6,1,4,4,6,0,6,9,1,6,6,9,0,2,2,7,6,4,0,1,7,0,8,1,9,5,9,2,9,2,0,8,3,6,2,6,9", "code": "\nfrom mpmath import *\nmp.dps=101\nxi=1/(1 + sqrt(e))\nC = -pi**2/12 + (1/2)*log(xi)**2 + polylog(2, xi)\nprint([int(n) for n in list(str(C)[2:-1])]) \n"}
{"sequence_id": "A248804", "text": "Prime sieve of e.", "sequence": "18,8284,90452,60287,526624,24,36999,669,6,24076630,5945,382,85,6,427,9,3,0,2,7,66,0,57,429526059,0,813,2862,4,763,5,9525,90,573,4,21540,934884,46066808,6847,85,4234544,53,77,9,551702,8386062,8,7520,38265,760,7", "code": "\nfrom decimal import *\ngetcontext().prec = 300\ndef primes(n):\n....\"\"\" Returns  a list of primes < n \"\"\"\n....sieve = [True] * n\n....for i in range(3,int(n**0.5)+1,2):\n........if sieve[i]:\n............sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1)\n....return [2] + [i for i in range(3,n,2) if sieve[i]]\nb = primes(429526060)\nx = (Decimal(1).exp())\ny = str(x)\ny = y.replace(\".\",\"\")\nfor x in b:\n....if str(x) in y:\n........y = y.replace(str(x),\" \",1)\nwhile \"  \" in y:\n....y = y.replace(\"  \",\" \")\nz = y.split(\" \")\nz = filter(None, z)\nf = map(int,z)\nprint(f[0:-1])\n\n"}
{"sequence_id": "A248831", "text": "Prime sieve of the square root of 2.", "sequence": "1,4,1,6,309,6,8078,1875,69480,66,7,32,8462,388,87,2764,27350,846,12,24,6055850,4,999358,41322266,27505,9995050,527820605,470,5,716059,453459686,285,86408,5,87,4508,627995,8968,396546,808,640620,5,50,502,599,2", "code": "\ndef sqroot(a, digits):\n....a = a * (10**(2*digits))\n....x_prev = 0\n....x_next = 1 * (10**digits)\n....while x_prev != x_next:\n........x_prev = x_next\n........x_next = (x_prev + (a // x_prev)) >> 1\n....return x_next\ndef primes(n):\n....sieve = [True] * n\n....for i in range(3,int(n**0.5)+1,2):\n........if sieve[i]:\n............sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1)\n....return [2] + [i for i in range(3,n,2) if sieve[i]]\na = sqroot(2,300)\nb = primes(10000000)\ny = str(a)\nfor x in b:\n....if str(x) in y:\n........y = y.replace(str(x),\" \",1)\nwhile \"  \" in y:\n....y = y.replace(\"  \",\" \")\nz = y.split(\" \")\nz = filter(None, z)\nf = map(int,z)\nprint(f)\n\n"}
{"sequence_id": "A248863", "text": "Table of bit patterns: The bits of A011545(n) -- approximations to Pi -- placed into row n in the order MSB to LSB.", "sequence": "1,1,1,1,1,1,1,1,0,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,1,1", "code": " mystr=''\nwith open('c:\\\\bA011545.txt') as myfile:\n...mess = [line.rstrip('\\n') for line in myfile]\nfor i5 in range(len(mess)):\n...tp=mess[i5].split(' ')\n...mystr=mystr+bin(int(tp[1]))\npre1=mystr.replace('0b','')\npre2=pre1.replace('1','1,')\nfinal=pre2.replace('0','0,')\nprint (final)\n"}
{"sequence_id": "A248889", "text": "Palindromic in base 10 and 18.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,171,323,343,505,595,686,848,1661,2112,3773,23332,46664,69996,262262,583385,782287,859958,981189,1254521,1403041,1832381,39388393,54411445,55499455,88844888,118919811,191010191", "code": "\ndef palgen10(l): \n....if l > 0:\n........yield 0\n........for x in range(1,l+1):\n............n = 10**(x-1)\n............n2 = n*10\n............for y in range(n,n2):\n................s = str(y)\n................yield int(s+s[-2::-1])\n............for y in range(n,n2):\n................s = str(y)\n................yield int(s+s[::-1])\ndef palcheck(n, b): \n....s = digits(n, b)\n....return s == s[::-1]\nA248889_list = [n for n in palgen10(9) if palcheck(n, 18)]\n\n"}
{"sequence_id": "A248909", "text": "Completely multiplicative with a(p) = p if p = 6k+1 and a(p) = 1 otherwise.", "sequence": "1,1,1,1,1,1,7,1,1,1,1,1,13,7,1,1,1,1,19,1,7,1,1,1,1,13,1,7,1,1,31,1,1,1,7,1,37,19,13,1,1,7,43,1,1,1,1,1,49,1,1,13,1,1,1,7,19,1,1,1,61,31,7,1,13,1,67,1,1,7,1,1,73,37,1,19,7,13,79,1,1", "code": "\nfrom sympy import factorint\ndef A248909(n):\n    y = 1\n    for p,e in factorint(n).items():\n        y *= (1 if (p-1) % 6 else p)**e\n    return y \n"}
{"sequence_id": "A248939", "text": "Table read by rows: row n lists the wrecker ball sequence starting with n, or contains -1 if 0 is never reached..", "sequence": "0,1,0,2,1,-1,-4,0,3,2,0,4,3,1,-2,2,-3,-9,-16,-8,-17,-7,-18,-6,7,21,6,-10,-27,-45,-26,-46,-25,-47,-24,0,5,4,2,-1,3,-2,-8,-15,-7,-16,-6,-17,-5,8,22,7,-9,-26,-44,-25,-45,-24,-46,-23,1,26,0,6,5,3", "code": " def A248939_row(n):\n    seen = {n}; orbit = [n]; c = 0\n    while n != 0:\n        ++c; s = c if n>0 else -c; n += s if n-s in seen else -s\n        seen.add(n); orbit.append(n)\n    return orbit \n(C++) \n  A248939_row(long n) { int c=0, s; for(std::map<long, bool> seen; n; n += seen[n-(s=n>0?c:-c)] ? s:-s) { std::cout<<n<<\", \"; seen[n]=true; ++c; } std::cout<<0; } // _M. F. Hasler_, Mar 18 2019\n"}
{"sequence_id": "A248952", "text": "Smallest term in wrecker ball sequence starting with n.", "sequence": "0,0,-4,0,-47,-46,0,-6362,-23,-22,0,-32,-471,-470,-29,0,-218,-4843985,-39,-38,-657367,0,-101,-57,-56,-7609937,-45,-44,0,-736,-56168428,-3113136,-3113135,-3113134,-3113133,-51,0,-190,-1213998,-1213997,-495,-62,-61,-60", "code": "\n\n\n\n\ndef trip(n):\n    stucklist = list()\n    spotsvisited = [n]\n    leavingspots = list()\n    turn = 0\n    forbidden = {n}\n    while n != 0:\n        turn += 1\n        sign = n // abs(n)\n        st = sign * turn\n        if n - st not in forbidden:\n            n = n - st\n        else:\n            leavingspots.append(n)\n            if n + st in forbidden:\n                stucklist.append(n)\n            n = n + st\n        spotsvisited.append(n)\n        forbidden.add(n)\n    return {'stuck':stucklist, 'spots':spotsvisited,\n                'turns':turn, 'flee':leavingspots}\n\ndef a(n):\n    d = trip(n)\n    return min(d['spots'])\n\n"}
{"sequence_id": "A248952", "text": "Smallest term in wrecker ball sequence starting with n.", "sequence": "0,0,-4,0,-47,-46,0,-6362,-23,-22,0,-32,-471,-470,-29,0,-218,-4843985,-39,-38,-657367,0,-101,-57,-56,-7609937,-45,-44,0,-736,-56168428,-3113136,-3113135,-3113134,-3113133,-51,0,-190,-1213998,-1213997,-495,-62,-61,-60", "code": " def A248952(n): return min(A248939_row(n)); // _M. F. Hasler_, Mar 18 2019\n(C++) \nlong A248952(long n) { long c=0, s, m=0; for(std::map<long, bool> seen; n; n += seen[n-(s=n>0?c:-c)] ? s:-s) { if(n<m) m=n; seen[n]=true; ++c; } return m; } // _M. F. Hasler_, Mar 18 2019\n"}
{"sequence_id": "A248953", "text": "Largest term in wrecker ball sequence starting with n.", "sequence": "0,1,2,3,21,26,6,6843,8,14,10,72,365,366,14,15,352,4674389,18,22,891114,21,102,23,31,7856204,26,27,28,1700,61960674,3702823,3702824,3702825,3702826,35,36,370,1047903,1047904,596,41,42,43,2976,45,341,260,261,123", "code": "\n\n\n\n\ndef trip(n):\n    stucklist = list()\n    spotsvisited = [n]\n    leavingspots = list()\n    turn = 0\n    forbidden = {n}\n    while n != 0:\n        turn += 1\n        sign = n // abs(n)\n        st = sign * turn\n        if n - st not in forbidden:\n            n = n - st\n        else:\n            leavingspots.append(n)\n            if n + st in forbidden:\n                stucklist.append(n)\n            n = n + st\n        spotsvisited.append(n)\n        forbidden.add(n)\n    return {'stuck':stucklist, 'spots':spotsvisited,\n            'turns':turn, 'flee':leavingspots}\n\ndef a(n):\n    d = trip(n)\n    return max(d['spots'])\n\n(C++) \nlong A248953(long n) { long c=0, s, m=n; for(std::map<long, bool> seen; n; n += seen[n-(s=n>0?c:-c)] ? s:-s) { if(n>m) m=n; seen[n]=true; ++c; } return m; } // _M. F. Hasler_, Mar 18 2019\n"}
{"sequence_id": "A248958", "text": "Maximum number of distinct nonempty squares in a binary string of length n.", "sequence": "0,1,1,2,2,3,3,4,5,6,7,7,8,9,10,11,12,12,13,13,14,15,16,17,18,19,20,20,21,22,23,23,24,25", "code": "\nfrom itertools import product\ndef a(n): \n  squares = set(\"\".join(u) + \"\".join(u)\n    for r in range(1, n//2 + 1) for u in product(\"01\", repeat = r))\n  words = (\"0\"+\"\".join(w) for w in product(\"01\", repeat=n-1))\n  return max(len(squares &\n    set(w[i:j] for i in range(n) for j in range(i+1, n+1))) for w in words)\nprint([a(n) for n in range(1, 18)]) \n"}
{"sequence_id": "A248961", "text": "Sums of wrecker ball sequences starting with n.", "sequence": "0,1,-2,5,-292,-241,14,-437861,-28,-1,30,313,-4472,-4223,-2,55,3252,-214246256269,-70,-27,5260887648,91,-538,-193,-132,-864538549823,-22,27,140,40053,53088613819206,86166834699,86167898716,86168962733,86170026754,49,204", "code": " def A248961(n):\n  A = {n}; c = 0; S = 0\n  while n != 0:\n    ++c; s = c if n>0 else -c; n += s if n-s in A else -s; A.add(n); S += n\n  return S \n"}
{"sequence_id": "A249067", "text": "Smallest k such that {first digit of j*n, 0<=j<=k} = {0,1,...,9}.", "sequence": "9,45,27,23,18,15,13,12,9,9,9,42,62,43,54,44,53,45,43,45,43,41,35,34,36,35,34,33,32,27,26,25,25,27,26,25,25,24,24,23,22,22,21,21,18,18,18,17,17,18,18,18,17,17,17,17,16,16,16,15,15,15,15,15,14,14,14,14,14,13,13,13,13,13,12,12,12,12,12,12,12,11,11,11,11,11,11,11", "code": "\ndef a(n):\n...got = [0]*10\n...i = 1\n...while sum(got)<9:\n......d=int(str(n*i)[0])\n......got[d] = 1\n......i += 1\n...return i-1\n"}
{"sequence_id": "A249079", "text": "a(n) = 29*n + floor( n/29 ) + 0^( 1-floor( (14+(n mod 29))/29 ) ).", "sequence": "0,29,58,87,116,145,174,203,232,261,290,319,348,377,406,436,465,494,523,552,581,610,639,668,697,726,755,784,813,842,871,900,929,958,987,1016,1045,1074,1103,1132,1161,1190,1219,1248,1278,1307,1336", "code": "\nfor n in range(101):\n    print(29*n+n//29+0**(1-(14+n%29)//29), end=', ')\n"}
{"sequence_id": "A249127", "text": "a(n) = n * floor(3*n/2).", "sequence": "0,1,6,12,24,35,54,70,96,117,150,176,216,247,294,330,384,425,486,532,600,651,726,782,864,925,1014,1080,1176,1247,1350,1426,1536,1617,1734,1820,1944,2035,2166,2262,2400,2501,2646,2752,2904,3015,3174,3290,3456,3577,3750,3876,4056,4187,4374,4510", "code": "\nfrom math import *\n{print(int(n*floor(3*n/2)),end=', ') for n in range(101)}\n"}
{"sequence_id": "A249129", "text": "Lexicographically earliest sequence of distinct nonnegative integers such that a(2n) = a(n) + a(n+1) for all n >= 0.", "sequence": "1,0,2,3,5,4,8,6,9,7,12,10,14,11,15,13,16,17,19,18,22,20,24,21,25,23,26,27,28,30,29,31,33,32,36,34,37,35,40,38,42,39,44,41,45,43,46,47,48,50,49,51,53,52,55,54,58,56,59,57,60,61,64,62,65,63,68", "code": "\ndef a249129():\n...seq = {0:1}\n...acc = 0\n...i = 0\n...while True:\n......if i in seq:\n.........if i+1 in seq:\n............if 2*i not in seq:\n...............seq[2*i] = seq[i]+seq[i+1]\n.........elif 2*i in seq:\n............seq[i+1] = seq[2*i]-seq[i]\n.........else:\n............while acc in seq.values():\n...............acc += 1\n............seq[i+1] = acc\n............seq[2*i] = seq[i] + seq[i+1]\n......else:\n.........while acc in seq.values():\n............acc += 1\n.........seq[i] = acc\n......yield seq[i]\n......i += 1\n\n"}
{"sequence_id": "A249153", "text": "Exponent of 2 in the hyperfactorial of 2n: a(n) = A007814(A002109(2n)).", "sequence": "0,2,10,16,40,50,74,88,152,170,210,232,304,330,386,416,576,610,682,720,840,882,970,1016,1208,1258,1362,1416,1584,1642,1762,1824,2208,2274,2410,2480,2696,2770,2922,3000,3320,3402,3570,3656,3920,4010,4194,4288,4768,4866,5066,5168,5480,5586,5802,5912", "code": "\nfrom sympy import multiplicity\nA249153_list, n = [0], 0\nfor i in range(2,20002,2):\n    n += multiplicity(2,i)*i\n    A249153_list.append(n) \n"}
{"sequence_id": "A249155", "text": "Palindromic in bases 6 and 15.", "sequence": "0,1,2,3,4,5,7,14,80,160,301,602,693,994,1295,1627,1777,2365,2666,5296,5776,6256,17360,34720,51301,52201,105092,155493,209284,587846,735644,7904800,11495701,80005507,80469907,83165017,89731777,90196177", "code": "\ndef palQ(n,b): \n....s = digits(n,b)\n....return s == s[::-1]\ndef palQgen(l,b): \n....if l > 0:\n........yield 0\n........for x in range(1,l+1):\n............for y in range(b**(x-1),b**x):\n................s = digits(y,b)\n................yield int(s+s[-2::-1],b)\n............for y in range(b**(x-1),b**x):\n................s = digits(y,b)\n................yield int(s+s[::-1],b)\nA249155_list = [n for n in palQgen(8,6) if palQ(n,15)] \n"}
{"sequence_id": "A249156", "text": "Palindromic in bases 5 and 7.", "sequence": "0,1,2,3,4,6,24,57,78,114,342,624,856,1432,10308,12654,27616,100056,537856,593836,769621,1434168,1473368,1636104,1823544,1862744,17968646,18108296,22412057,34713713,34853363,39280254,159690408,663706192", "code": "\nfrom gmpy2 import digits\ndef palQ(n,b): \n    s = digits(n,b)\n    return s == s[::-1]\ndef palQgen(l,b): \n    if l > 0:\n        yield 0\n        for x in range(1,b**l):\n            s = digits(x,b)\n            yield int(s+s[-2::-1],b)\n            yield int(s+s[::-1],b)\nA249156_list = sorted([n for n in palQgen(8,5) if palQ(n,7)]) \n"}
{"sequence_id": "A249157", "text": "Palindromic in bases 11 and 13.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,12,84,366,510,732,876,1020,1098,1242,1464,10248,30252,31110,62220,103704,146541,3382050,3698730,4391268,225622530,272466250,413186676,713998530,801837204,848770222,912265732", "code": "\nfrom gmpy2 import digits\ndef palQ(n,b): \n....s = digits(n,b)\n....return s == s[::-1]\ndef palQgen(l,b): \n....if l > 0:\n........yield 0\n........for x in range(1,b**l):\n............s = digits(x,b)\n............yield int(s+s[-2::-1],b)\n............yield int(s+s[::-1],b)\nA249157_list = sorted([n for n in palQgen(6,11) if palQ(n,13)]) \n"}
{"sequence_id": "A249158", "text": "Palindromic in bases 7 and 29.", "sequence": "0,1,2,3,4,5,6,8,16,24,150,300,5952,7752,7955,9755,9958,11904,13704,13907,14110,15707,15910,392850,751043,4585544,12737804,12828748,16380296,19289406,19380350,20228253,33115710,395849700,1339182534", "code": "\nfrom gmpy2 import digits\ndef palQ(n,b): \n....s = digits(n,b)\n....return s == s[::-1]\ndef palQgen(l,b): \n....if l > 0:\n........yield 0\n........for x in range(1,b**l):\n............s = digits(x,b)\n............yield int(s+s[-2::-1],b)\n............yield int(s+s[::-1],b)\nA249158_list = sorted([n for n in palQgen(8,7) if palQ(n,29)])\n\n"}
{"sequence_id": "A249275", "text": "a(n) is the smallest b > 1 such that p = prime(n) satisfies b^(p-1) == 1 (mod p^3).", "sequence": "9,26,57,18,124,239,158,333,42,1215,513,691,1172,3038,295,1468,2511,15458,3859,6372,923,1523,5436,1148,412,4943,4432,5573,476,68,21304,30422,6021,8881,33731,25667,3868,3170,17987,26626,43588,7296,14628,22076,138057", "code": "\nfrom sympy import prime\ndef a(n):\n    b, p = 2, prime(n)\n    p3 = p**3\n    while pow(b, p-1, p3) != 1: b += 1\n    return b\nprint([a(n) for n in range(1, 46)]) \n"}
{"sequence_id": "A249344", "text": "A(n,k) = exponent of the largest power of n-th prime which divides k, square array read by antidiagonals.", "sequence": "0,1,0,0,0,0,2,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom sympy import prime\ndef a(n, k):\n    p=prime(n)\n    i=z=0\n    while p**i<=k:\n        if k%(p**i)==0: z=i\n        i+=1\n    return z\nfor n in range(1, 10): print([a(k, n - k + 1) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A249357", "text": "Fibonacci-Zumkeller numbers: a(n)=n if n<=3, otherwise the smallest number >= a(n-2) + a(n-1) having at least one common factor with a(n-2), but none with a(n-1).", "sequence": "1,2,3,8,15,26,45,74,123,200,327,530,861,1396,2259,3656,5919,9578,15501,25082,40587,65672,106263,171938,278211,450151,728367,1178527,1906896,3085439,4992336,8077783,13070121,21147910,34218033,55365944,89583981,144949928,234533913,379483844,614017761,993501608", "code": "\nfrom fractions import gcd\nA249357_list, l1, l2 = [1,2,3], 3, 2\nfor _ in range(100):\n....i = l1+l2\n....while True:\n........if gcd(i,l1) == 1 and gcd(i,l2) > 1:\n............A249357_list.append(i)\n............l2, l1 = l1, i\n............break\n........i += 1 \n"}
{"sequence_id": "A249374", "text": "Prime numbers Q such that the concatenation Q,1,Q is prime.", "sequence": "3,17,29,41,47,59,71,89,113,131,137,239,263,359,389,443,461,467,509,653,659,821,887,911,947,971,977,1151,1193,1223,1499,1553,1559,1613,1637,1667,1787,1871,1997,2039,2063,2081,2141,2243,2267,2273,2297,2351,2393,2399", "code": "\nfrom sympy import isprime, primerange\ndef ok(p): s = str(p); return isprime(int(s+'1'+s))\nprint(list(filter(ok, primerange(1, 2400)))) \n"}
{"sequence_id": "A249375", "text": "Prime numbers Q such that the concatenation Q,2,Q is prime.", "sequence": "7,19,31,61,79,193,283,367,373,421,499,547,619,733,751,883,997,1021,1033,1039,1069,1153,1171,1279,1399,1483,1543,1567,1753,1831,1879,1951,1999,2083,2161,2179,2251,2281,2287,2503,2671,2707,2713,2767,2797,2953,3019", "code": "\nfrom sympy import isprime, primerange\ndef ok(p): s = str(p); return isprime(int(s+'2'+s))\nprint(list(filter(ok, primerange(1, 3020)))) \n"}
{"sequence_id": "A249381", "text": "Prime numbers Q such that the concatenation Q,9,Q is prime.", "sequence": "7,13,19,41,43,47,61,67,71,73,79,83,89,107,137,149,173,179,211,229,269,277,281,283,379,401,431,443,491,523,547,557,577,599,607,613,619,647,683,691,823,863,877,919,977,1031,1069,1091,1151,1171,1213,1249,1259", "code": "\nfrom sympy import isprime, primerange\ndef ok(p): swb = str(p); return isprime(int(swb + '9' + swb))\ndef aupto(lim): return [p for p in primerange(1, lim+1) if ok(p)]\nprint(aupto(1260)) \n"}
{"sequence_id": "A249515", "text": "Numbers n for which the digital sum of n contains the same distinct digits as n itself.", "sequence": "0,1,2,3,4,5,6,7,8,9,199,919,991,1188,1818,1881,2999,8118,8181,8811,9299,9929,9992,11177,11444,11717,11771,13333,14144,14414,14441,17117,17171,17711,22888,26666,28288,28828,28882,31333,33133,33313,33331,39999,41144", "code": "\nfrom itertools import product\nA249515_list = [0]\nfor g in range(1,12):\n....xp, ylist = [], []\n....for i in range(9*g,-1,-1):\n........x = set(str(i))\n........if not x in xp:\n............xv = [int(d) for d in x]\n............imin = int(''.join(sorted(str(i))))\n............if max(xv)*(g-len(x)) >= imin-sum(xv) and i-sum(xv) >=  min(xv)*(g-len(x)):\n................xp.append(x)\n................for y in product(x,repeat=g):\n....................if y[0] != '0' and set(y) == x and set(str(sum([int(d) for d in y]))) == x:\n........................ylist.append(int(''.join(y)))\n....A249515_list.extend(sorted(ylist)) \n"}
{"sequence_id": "A249517", "text": "Numbers n for which the digital sum A007953(n) and the digital product A007954(n) both contain the same distinct digits as the number n.", "sequence": "0,1,2,3,4,5,6,7,8,9,11111111111", "code": "\nfrom itertools import product\nfrom operator import mul\nfrom functools import reduce\nA249517_list = [0]\nfor g in range(1,15):\n....xp, ylist = [], []\n....for i in range(9*g,-1,-1):\n........x = set(str(i))\n........if not (('0' in x) or (x in xp)):\n............xv = [int(d) for d in x]\n............imin = int(''.join(sorted(str(i))))\n............if max(xv)*(g-len(x)) >= imin-sum(xv) and i-sum(xv) >=  min(xv)*(g-len(x)):\n................xp.append(x)\n................for y in product(x,repeat=g):\n....................if set(y) == x:\n........................yd = [int(d) for d in y]\n........................if set(str(sum(yd))) == x == set(str(reduce(mul, yd, 1))):\n............................ylist.append(int(''.join(y)))\n....A249517_list.extend(sorted(ylist)) \n"}
{"sequence_id": "A249542", "text": "Decimal expansion of the average product of a side and an adjacent angle of a random Gaussian triangle in two dimensions.", "sequence": "1,6,3,7,7,2,9,3,2,4,8,5,6,8,6,8,0,3,2,7,8,0,1,5,6,9,5,6,7,9,8,4,7,6,4,5,5,8,2,0,3,8,1,9,8,7,0,9,0,5,9,3,4,1,7,5,4,8,7,6,5,2,2,4,7,7,1,2,0,5,6,8,9,3,3,1,1,1,6,4,9,0,2,1,5,0,7,1,1,3,4,8,3,2,2,0,7,1,2,4,6,9,9,2,8", "code": "\nfrom mpmath import *\nmp.dps=106\nC = (-sqrt(3)*log(3) + pi**2 - 8*polylog(2, 2-sqrt(3)) + 2*polylog(2, 7 - 4*sqrt(3)))/(2*sqrt(pi))\nprint([int(n) for n in list(str(C).replace('.', '')[:-1])]) \n"}
{"sequence_id": "A249586", "text": "Sum of the first n^3 cubes.", "sequence": "0,1,1296,142884,4326400,62015625,549246096,3480528016,17247043584,70801227225,250500250000,785786510916,2231605748736,5829824737009,14183810499600,32455809000000,70403108110336,145714859280081,289307033504784,553490085376900", "code": "\nA249586_list, m = [0], [119750400, -658627200, 1546776000, -2020606560, 1602266400, -789354720, 237304980, -40965390, 3576156, -120849, 784, 0, 0]\nfor _ in range(10**3):\n....for i in range(12):\n........m[i+1]+= m[i]\n....A249586_list.append(m[-1]) \n"}
{"sequence_id": "A249610", "text": "Primes of the form (2k^3 - 2k^2 + k + 2) / 2.", "sequence": "585691,1248103,4713493,5799691,13766521,15939631,23805073,42023263,46526581,80435161,102284443,127770301,157172671,179088331,215640301,287060731,519072451,591998821,617744731,788035711,951796141,987056419,1433977333,1998789031", "code": "\nfrom sympy import isprime\nA249610_list, m = [], [48, -56, 13, 1]\nfor _ in range(10**5):\n....for i in range(3):\n........m[i+1]+= m[i]\n....if isprime(m[-1]):\n........A249610_list.append(m[-1]) \n"}
{"sequence_id": "A249627", "text": "Product of the lowest and highest prime factors of n-th repunit A002275(n).", "sequence": "121,111,1111,11111,111,1111111,1507,1001001,100001,11111111111,29703,14064697609,10000001,8718483,64705883,11111111111111111,1001001,1234567901234567900987654320987654321,307571,32516067,5645629,123456790123456790123454320987654320987654321", "code": "\nfrom sympy import factorint\nA249627_list = [min(fs)*max(fs) for fs in (factorint((10**n-1)//9) for n in range(2,31))] \n"}
{"sequence_id": "A249651", "text": "Decimal expansion of Integral_{0..1} Li_2(x)^2 dx, where Li_2 is the dilogarithm function.", "sequence": "6,0,7,7,1,2,3,3,7,9,4,3,0,1,5,4,6,4,2,4,6,2,2,6,2,6,2,0,1,5,0,6,9,4,1,5,4,3,9,0,3,2,4,0,8,0,2,1,2,2,4,8,6,6,5,6,7,2,3,7,8,5,8,5,0,2,9,3,3,7,7,6,5,1,5,7,6,8,0,0,7,9,7,9,1,9,2,7,9,4,1,7,7,3,9,1,3,4,9,8,8,9,6,7,1,7", "code": "\nfrom mpmath import *\nmp.dps=107\nf=lambda x: polylog(2, x)**2\nI=quad(f, [0, 1])\nprint([int(n) for n in list(str(I)[2:-1])]) \n"}
{"sequence_id": "A249652", "text": "Decimal expansion of integral_{0..1} Li_3(x)^2 dx, where Li_3 is the trilogarithm function.", "sequence": "4,2,7,7,1,4,7,8,4,2,9,0,8,2,4,0,8,8,1,1,2,8,3,8,9,7,1,6,1,2,7,9,4,5,3,2,4,2,8,6,0,2,4,7,8,7,7,4,6,9,5,7,4,4,5,5,4,9,2,9,8,3,5,2,4,1,6,1,6,5,8,8,1,5,1,6,7,4,1,4,3,2,0,4,6,5,6,6,8,1,9,8,6,3,4,5,4,2,1,2,6,9", "code": "\nfrom mpmath import mp, zeta\nmp.dps=103\nz2=zeta(2)\nz3=zeta(3)\nprint([int(z) for z in list(str(20 - 8*z2 - 10*z3 + 15*zeta(4)/2 - 2*z2*z3 + z3**2)[2:-1])]) \n"}
{"sequence_id": "A249667", "text": "Numbers n such that the sum of n and the largest prime<n is prime, and the sum of n and the least prime>n is also prime.", "sequence": "6,24,30,36,50,54,78,84,114,132,144,156,174,210,220,252,294,300,306,330,360,378,474,492,510,512,528,546,560,594,610,650,660,690,714,720,762,780,800,804,810,816,870,912,996,1002,1068,1074,1104,1120,1170,1176,1190,1210,1236,1262", "code": "\nfrom gmpy2 import is_prime, next_prime\nA249667_list, p = [], 2\nfor _ in range(10**4):\n....q = next_prime(p)\n....n1 = 2*p+1\n....n2 = p+q+1\n....while n1 < p+q:\n........if is_prime(n1) and is_prime(n2):\n............A249667_list.append(n1-p)\n........n1 += 2\n........n2 += 2\n....p = q \n"}
{"sequence_id": "A249689", "text": "Numbers n such that A084937(3n) > A084937(3n+1).", "sequence": "16,65,91,1514,1993,1994,2452,2722,3047,3214,3931,3957,4356,4366,5191,5581,5805,5806,7519,8871,9228,9752,10036,10037,10039,10040,10963,10964,11278,11279,12015,12281,12595,12665,13262,13618,13648,15102,15103,18529,18991", "code": "\nfrom __future__ import division\nfrom fractions import gcd\nA249689_list, l1, l2, s, b = [], 2, 1, 3, set()\nfor n in range(3,10**4):\n....i = s\n....while True:\n........if not i in b and gcd(i,l1) == 1 and gcd(i,l2) == 1:\n............l2, l1 = l1, i\n............b.add(i)\n............if l2 > l1 and n % 3 == 1:\n................A249689_list.append((n-1)//3)\n............while s in b:\n................b.remove(s)\n................s += 1\n............break\n........i += 1 \n"}
{"sequence_id": "A249751", "text": "Numbers n such that n - 2 divides n^n + 2.", "sequence": "3,4,7,8,67,260,379,1191,1471,5076,25807,58591,103780,134947,137347,170587,203236,272611,285391,420211,453748,538735,540856,592411,618451,680707,778807,1163067,1306936,1520443,1700947,1891336,2099203,2831011,3481960,4020031", "code": "\nA249751_list = [n for n in range(3,10**7) if n==3 or pow(n,n,n-2) == n-4]\n\n"}
{"sequence_id": "A249780", "text": "Product of lowest and highest prime factors of 2^n-1", "sequence": "9,49,15,961,21,16129,51,511,93,2047,39,67092481,381,1057,771,17179607041,219,274876858369,123,2359,2049,8388607,723,55831,24573,1838599,381,486737,993,4611686014132420609,196611,4196353,393213,3810551,327,137438953471,1572861,849583,185043", "code": "\nfrom sympy import primefactors\nA249780_list, x = [], 1\nfor n in range(2,10):\n....x = 2*x + 1\n....p = primefactors(x)\n....A249780_list.append(max(p)*min(p)) \n"}
{"sequence_id": "A249799", "text": "a(n+1) is the next smallest nontrivial cube beginning with a(n), initial term is 3.", "sequence": "3,343,34328125,343281258441879199985152,3432812584418791999851522633552283890505384030397984598615707004422070464", "code": "\ndef f(x):\n    n = x\n    s = 1\n    while s < 10**7:\n        if s % 10:\n            S = str(s**3)\n            if S.startswith(str(n)):\n                print(s**3,end=', ')\n                n = s**3\n        s += 1\nf(3)\n"}
{"sequence_id": "A249804", "text": "a(n+1) is the next smallest nontrivial cube beginning with a(n), initial term is 4.", "sequence": "4,4096,409675763483,4096757634832457594649749511342547903", "code": "\ndef f(x):\n..n = x\n..s = 1\n..while s < 10**7:\n....if s % 10:\n......S = str(s**3)\n......if S.startswith(str(n)):\n........print(s**3, end=', ')\n........n = s**3\n....s += 1\nf(4)\n"}
{"sequence_id": "A249805", "text": "a(n+1) is the next smallest nontrivial cube beginning with a(n), initial term is 5.", "sequence": "5,512,5124031424,5124031424891652800051720000001", "code": "\ndef f(x):\n..n = x\n..s = 1\n..while s < 10**7:\n....if s % 10:\n......S = str(s**3)\n......if S.startswith(str(n)):\n........print(s**3, end=', ')\n........n = s**3\n....s += 1\nf(5)\n"}
{"sequence_id": "A249828", "text": "a(n+1) is the next smallest nontrivial cube beginning with a(n), initial term is 6.", "sequence": "6,64,6434856,64348563687280925127256,6434856368728092512725673603219352207940941512476919680996778471241599", "code": "\ndef f(x):\n..n = x\n..s = 1\n..while s < 10**7:\n....if s % 10:\n......S = str(s**3)\n......if S.startswith(str(n)):\n........print(s**3, end=', ')\n........n = s**3\n....s += 1\nf(6)\n"}
{"sequence_id": "A249834", "text": "a(n+1) is the next smallest nontrivial cube beginning with a(n), initial term is 7.", "sequence": "7,729,7290099019,72900990191475181426079596544", "code": "\ndef f(x):\n..n = x\n..s = 1\n..while s < 10**7:\n....if s % 10:\n......S = str(s**3)\n......if S.startswith(str(n)):\n........print(s**3, end=', ')\n........n = s**3\n....s += 1\nf(7)\n"}
{"sequence_id": "A249837", "text": "a(n+1) is the next smallest nontrivial cube beginning with a(n), initial term is 9.", "sequence": "9,9261,92615351886784,9261535188678457128255779014690172977343833,926153518867845712825577901469017297734383369607525414854584903918819898290730346512973206455943454340951813592133138664220381927", "code": "\ndef f(x):\n..n = x\n..s = 1\n..while s < 10**7:\n....if s % 10:\n......S = str(s**3)\n......if S.startswith(str(n)):\n........print(s**3, end=', ')\n........n = s**3\n....s += 1\nf(9)\n"}
{"sequence_id": "A249875", "text": "Numbers that are exactly halfway between the nearest square and the nearest power of 2.", "sequence": "3,6,34,136,498,2082,8146,32946,131058,524232,2096928,8387712,33550848,134226562,536859906,2147439624,8589943858,34359775432,137439101728,549756406912,2199022661826,8796090647304,35184374452498,140737497809992,562949943786834,2251799775147336", "code": "\nfrom gmpy2 import isqrt\nA249875_list, x = [], 1\nfor _ in range(10**3):\n....A249875_list.append(2*sum(divmod(isqrt(2*x),2))**2+x)\n....x *= 4 \n"}
{"sequence_id": "A249893", "text": "a(n+1) is next smallest square not divisible by 10 beginning with a(n), initial term is 2.", "sequence": "2,25,256,256036,2560361612769,256036161276932002260000001,256036161276932002260000001607597862784080913990785121", "code": "\ndef f(x):\n..print(x,end=', ')\n..n = x\n..s = 1\n..while s < 10**7:\n....if s % 10:\n......S = str(s**2)\n......if S.startswith(str(n)):\n........print(s**2,end=', ')\n........n = s**2\n....s += 1\nf(2)\n"}
{"sequence_id": "A249893", "text": "a(n+1) is next smallest square not divisible by 10 beginning with a(n), initial term is 2.", "sequence": "2,25,256,256036,2560361612769,256036161276932002260000001,256036161276932002260000001607597862784080913990785121", "code": "\ndef anext(an):\n  lo, hi = an*10, an*10 + 9\n  while True:\n    found = False\n    if isqrt(hi)**2 > lo: return (isqrt(lo)+1)**2\n    lo, hi = lo*10, hi*10 + 9\nn, an = 1, 2\nfor n in range(2, 17):\n  an = anext(an)\n  print(n, an) \n"}
{"sequence_id": "A249894", "text": "a(n+1) is next smallest square not divisible by 10 beginning with a(n), initial term is 3.", "sequence": "3,36,361,361201,36120142809,3612014280924268428225,361201428092426842822525044572369542546150009", "code": "\ndef f(x):\n..print(x, end=', ')\n..n = x\n..s = 1\n..while s < 10**7:\n....if s % 10:\n......S = str(s**2)\n......if S.startswith(str(n)):\n........print(s**2, end=', ')\n........n = s**2\n....s += 1\nf(3)\n"}
{"sequence_id": "A249895", "text": "a(n+1) is next smallest square not divisible by 10 beginning with a(n), initial term is 5.", "sequence": "5,529,529984,52998485796,5299848579629072273476,529984857962907227347600150092608188876380736", "code": "\ndef f(x):\n..print(x, end=', ')\n..n = x\n..s = 1\n..while s < 10**7:\n....if s % 10:\n......S = str(s**2)\n......if S.startswith(str(n)):\n........print(s**2, end=', ')\n........n = s**2\n....s += 1\nf(5)\n"}
{"sequence_id": "A249896", "text": "a(n+1) is next smallest square not divisible by 10 beginning with a(n), initial term is 6.", "sequence": "6,64,64009,6400960036,640096003602877347904,640096003602877347904912233550482787380625,6400960036028773479049122335504827873806251020537411455326101704116338781035920283225", "code": "\ndef f(x):\n..print(x, end=', ')\n..n = x\n..s = 1\n..while s < 10**7:\n....if s % 10:\n......S = str(s**2)\n......if S.startswith(str(n)):\n........print(s**2, end=', ')\n........n = s**2\n....s += 1\nf(7)\n"}
{"sequence_id": "A249897", "text": "a(n+1) is next smallest square not divisible by 10 beginning with a(n), initial term is 7.", "sequence": "7,729,729316,7293164743396,72931647433968832639882896,72931647433968832639882896319584064899663299793041401", "code": "\ndef f(x):\n..print(x, end=', ')\n..n = x\n..s = 1\n..while s < 10**7:\n....if s % 10:\n......S = str(s**2)\n......if S.startswith(str(n)):\n........print(s**2, end=', ')\n........n = s**2\n....s += 1\nf(7)\n"}
{"sequence_id": "A249898", "text": "a(n+1) is next smallest square not divisible by 10 beginning with a(n), initial term is 8.", "sequence": "8,81,81225,8122515625,812251562541751472569,812251562541751472569881528811450814530084", "code": "\ndef f(x):\n..print(x, end=', ')\n..n = x\n..s = 1\n..while s < 10**7:\n....if s % 10:\n......S = str(s**2)\n......if S.startswith(str(n)):\n........print(s**2, end=', ')\n........n = s**2\n....s += 1\nf(8)\n"}
{"sequence_id": "A249902", "text": "Numbers n such that 2n-1 and sigma(n) are both primes.", "sequence": "2,4,9,16,64,289,1681,2401,3481,4096,15625,65536,85849,262144,491401,531441,552049,683929,703921,734449,1352569,1885129,3411409,3892729,5470921,7091569,7778521,9247681,10374841,12652249,18139081,19439281,22287841,23902321", "code": "\nfrom sympy import isprime, divisor_sigma\nA249902_list = [2]+[n for n in (d**2 for d in range(1,10**3)) if isprime(2*n-1) and isprime(divisor_sigma(n))] \n"}
{"sequence_id": "A249915", "text": "Numbers n such that the decimal expansions of both n and n^2 have 2 as smallest digit and 6 as largest digit.", "sequence": "255465,652244,665256,2534665,2536656,2554262,6523462,6524235,6652242,23352656,23354365,23523462,23546665,23565325,25346665,25425256,25624665,25625465,65226242,65234535,235442656,254234662,255465525,255645525,256246665,256254665", "code": "\nfrom itertools import product\nA249915_list = []\nfor l in range(10):\n....for a in product('23456',repeat = l):\n........for b in ('2','4','5','6'):\n............s = ''.join(a)+b\n............if '2' in s and '6' in s:\n................n = int(s)\n................if {'2','6'} <= set(str(n**2)) <= {'2','3','4','5','6'}:\n....................A249915_list.append(n) \n"}
{"sequence_id": "A249919", "text": "Number of LCD (liquid-crystal display) segments needed to display n in binary.", "sequence": "6,2,8,4,14,10,10,6,20,16,16,12,16,12,12,8,26,22,22,18,22,18,18,14,22,18,18,14,18,14,14,10,32,28,28,24,28,24,24,20,28,24,24,20,24,20,20,16,28,24,24,20,24,20,20,16,24,20,20,16,20,16,16,12,38,34,34,30,34,30,30,26,34,30,30,26,30,26,26", "code": "\ndef A249919(n):\n....x=bin(n)[2:]\n....s=0\n....for i in x:\n........s+=[6,2][int(i)]\n....return s \n"}
{"sequence_id": "A249951", "text": "Numbers n such that A113630(n) is prime.", "sequence": "3,5,8,23,42,62,63,75,90,98,177,192,207,213,222,228,233,263,288,297,317,320,402,453,455,528,570,602,620,650,672,752,780,797,810,863,867,870,875,912,932,935,978,1010,1043,1065,1067,1070,1110,1125,1133,1142,1190", "code": "\nfrom sympy import isprime\nA249951_list, m = [], [362880, -1229760, 1607760, -1011480, 309816, -40752, 1584, -4, 1]\nfor n in range(1,10**5+1):\n....for i in range(8):\n........m[i+1]+= m[i]\n....if isprime(m[-1]):\n........A249951_list.append(n)\n"}
{"sequence_id": "A249988", "text": "Integer part of sine of n degrees multiplied by 1000.", "sequence": "0,17,34,52,69,87,104,121,139,156,173,190,207,224,241,258,275,292,309,325,342,358,374,390,406,422,438,453,469,484,500,515,529,544,559,573,587,601,615,629,642,656,669,681,694,707,719,731,743,754,766,777,788,798,809,819,829,838,848,857,866", "code": "\nimport math\nfor n in range(381): print str(int(math.trunc(1000*math.sin(math.pi*n/180))))+',',\n"}
{"sequence_id": "A249990", "text": "Start with the natural numbers, reverse the order in each pair, skip one pair, reverse the order in each triple, skip one triple, and so on.", "sequence": "2,1,6,3,4,12,5,8,7,16,9,10,13,14,22,15,18,11,24,17,32,25,26,19,20,23,30,48,31,38,21,28,27,34,33,52,35,42,29,36,39,40,49,50,58,51,54,41,44,37,60,43,66,53,84,67,68,61,62,45,46,55,56,59,76,94,77,90", "code": "\nTOP = 100\na = list(range(TOP))\nfor step in range(2,TOP):\n    numBlocks = (len(a)-1) // step\n    if numBlocks==0:  break\n    a = a[:(1+numBlocks*step)]\n    for pos in range(1,len(a),step):\n        a[pos:pos+step] = a[pos+step-1:pos-1:-1]\n    for i in range(1, step+1):  print(str(a[i]), end=',')\n    a[1:] = a[step+1:]\n"}
{"sequence_id": "A249991", "text": "Start with the natural numbers, reverse the order in each pair, skip one number, reverse the order in each triple, skip one number, and so on.", "sequence": "2,3,5,10,12,13,21,26,28,39,41,46,54,65,67,82,84,85,109,114,122,137,139,160,178,179,181,222,230,235,269,274,276,313,331,336,370,381,383,424,426,437,471,476,536,541,549,554,618,629,647,704,706,707,761,818", "code": "\nTOP = 100000\na = range(TOP)\nfor step in range(2,TOP):\n..numBlocks = (len(a)-1) / step\n..if numBlocks==0:  break\n..a = a[:(1+numBlocks*step)]\n..for pos in range(1,len(a),step):\n....a[pos:pos+step] = a[pos+step-1:pos-1:-1]\n..print str(a[1])+',',\n..a[1:] = a[2:]\n"}
{"sequence_id": "A250024", "text": "40n - 21.", "sequence": "19,59,99,139,179,219,259,299,339,379,419,459,499,539,579,619,659,699,739,779,819,859,899,939,979,1019,1059,1099,1139,1179,1219,1259,1299,1339,1379,1419,1459,1499,1539,1579,1619,1659,1699,1739,1779,1819,1859,1899", "code": "  for n in range(1,101): print(40*n-21,end=\",\")\n"}
{"sequence_id": "A250025", "text": "Lesser of twin prime pairs of the form (40n - 21, 40n - 19).", "sequence": "59,179,419,659,1019,1619,2339,3299,3539,4019,4259,5099,6299,6659,6779,8219,8819,9419,10139,10499,10859,11699,11939,12539,16139,16979,17579,18059,18539,19139,19379,21059,22619,22739,22859,24179,24419,26699,27059,27539,28619,32939,33179,34259,34499,36779,36899,37019,38459", "code": "  from sympy import isprime\nfor n in range(1,1001):\n..if isprime(40*n-21) and isprime(40*n-19): print(40*n-21,end=\",\")\n"}
{"sequence_id": "A250127", "text": "Numbers n where A098550(n)/n reaches a new high-water mark.", "sequence": "1,5,7,11,13,103,177,206,684,1138,1368,1817,2046,2270,2485,4959,7411,19616,22061,24482,31776,220238,314155,345422,376714,532978,1592947,3707718,4235919,4763906,6874759,7929554,8984063,9511273", "code": "\nfrom fractions import gcd\nA250127_list, l1, l2, s, u, l, b = [1], 3, 2, 4, 1, 1, {}\nfor n in range(4,10**4):\n....i = s\n....while True:\n........if not i in b and gcd(i,l1) == 1 and gcd(i,l2) > 1:\n............l2, l1, b[i] = l1, i, 1\n............while s in b:\n................b.pop(s)\n................s += 1\n............if u*n < i*l:\n................A250127_list.append(n)\n................u, l = i, n\n............break\n........i += 1 \n"}
{"sequence_id": "A250130", "text": "Numerator of the harmonic mean of the first n primes.", "sequence": "2,12,90,840,11550,180180,3573570,77597520,2007835830,64696932300,2206165391430,89048857617720,3955253425853730,183158658643380420,9223346738827371150,521426535635040715680,32686925952621614864190,2111190864469325477698860", "code": "\nfrom sympy import prime\nfrom fractions import Fraction\ndef a(n):\n  return (n/sum(Fraction(1, prime(k)) for k in range(1, n+1))).numerator\nprint([a(n) for n in range(1, 19)]) \n"}
{"sequence_id": "A250408", "text": "Palindromic in bases 10 and 20.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,252,6556,6776,7117,10101,12621,20202,22722,30303,1784871,1786871,1788871,1913191,1915191,1917191,1919191,1444884441,334495594433,334843348433,355110011553,355746647553,10614366341601,14102600620141,28095922959082,38072044027083", "code": "\nfrom gmpy2 import digits\ndef palQ(n, b): \n    s = digits(n, b)\n    return s == s[::-1]\ndef palQgen10(l): \n    if l > 0:\n        yield 0\n        for x in range(1,10**l):\n            s = str(x)\n            yield int(s+s[-2::-1])\n            yield int(s+s[::-1])\nA250408_list = sorted([n for n in palQgen10(6) if palQ(n,20)])\n\n"}
{"sequence_id": "A250410", "text": "Numbers palindromic in bases 10 and 25.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,22,494,626,676,1001,6886,7887,8338,9339,622226,626626,2828282,2859582,3304033,3309033,3330333,3335333,3361633,3366633,3392933,3397933,6603066,6608066,6634366,6639366,8986898,9400049,9405049,9431349,9436349,9462649,9467649,9493949,9498949", "code": "\nfrom gmpy2 import digits\ndef palQ(n,b): \n    s = digits(n,b)\n    return s == s[::-1]\ndef palQgen10(l): \n    if l > 0:\n        yield 0\n        for x in range(1,10**l):\n            s = str(x)\n            yield int(s+s[-2::-1])\n            yield int(s+s[::-1])\nA250410_list = sorted([n for n in palQgen10(6) if palQ(n,25)])\n\n"}
{"sequence_id": "A250984", "text": "Record values in A247190.", "sequence": "0,3,4,6,8,9,15,17,27,31,44,68,84,86,139,153,163,185,202,234,255,273,279,376,398,415,441,491,503,525,674,713,785,972,1076,1098,1242,1423,1678,1685,1814,1882,2371,2437,2931,2956,3152,3170,3898,4877,4922,4967", "code": "\nfrom sympy import prime\ndef A247190(n):\n....p, f, fv = prime(n), 1, {}\n....for i in range(2,p):\n........f = (f*i) % p\n........if f in fv:\n............return fv[f]\n........else:\n............fv[f] = i\n....return 0\nA250984_list, m = [], -1\nfor i in range(3,10**6):\n....v = A247190(i)\n....if v > m:\n........A250984_list.append(v)\n........m = v\n"}
{"sequence_id": "A250985", "text": "Index of record values in A247190.", "sequence": "3,4,6,12,14,22,25,41,44,47,76,116,151,179,375,615,617,670,744,750,1118,1160,1358,1471,1541,2693,2906,3658,3878,4132,4281,5719,5907,7136,12346,12792,14816,14991,19215,23004,24892,26778,28483,41558,44031,48858,55934", "code": "\nfrom sympy import prime\ndef A247190(n):\n....p, f, fv = prime(n), 1, {}\n....for i in range(2,p):\n........f = (f*i) % p\n........if f in fv:\n............return fv[f]\n........else:\n............fv[f] = i\n....return 0\nA250985_list, m = [], -1\nfor i in range(3,10**6):\n....v = A247190(i)\n....if v > m:\n........A250985_list.append(i)\n........m = v\n"}
{"sequence_id": "A251240", "text": "Indices of squares of primes in A098550.", "sequence": "4,5,11,40,124,187,273,313,505,747,751,1280,1478,1563,1841,2386,3130,3134,4196,4493,4497,5455,6002,6877,8158,9047,9276,10190,10194,11157,14182,15086,16762,16766,19758,20051,21749,23435,24601,26398,28655,28659,32636", "code": "\nfrom gmpy2 import gcd, is_square, is_prime, isqrt\nA251240_list, l1, l2, s, b = [], 3, 2, 4, {}\nfor n in range(4,10**4):\n....i = s\n....while True:\n........if not i in b and gcd(i,l1) == 1 and gcd(i,l2) > 1:\n............l2, l1, b[i] = l1, i, 1\n............while s in b:\n................b.pop(s)\n................s += 1\n............if is_square(i) and is_prime(isqrt(i)):\n................A251240_list.append(n)\n............break\n........i += 1 \n"}
{"sequence_id": "A251360", "text": "Numbers n such that n is the concatenation of prime factors of pi(n), in increasing order.", "sequence": "1117,2163,2537,5137,222926801", "code": "\nfrom sympy import prime, factorint\nA251360_list, p = [], 3\nfor n in range(2,10**6):\n....q, fn = prime(n+1), factorint(n)\n....m = int(''.join(str(d)*fn[d] for d in sorted(fn)))\n....if p <= m < q:\n........A251360_list.append(m)\n....p = q \n"}
{"sequence_id": "A251393", "text": "Indices of powers of 2 in A098550.", "sequence": "1,2,4,6,14,29,65,137,277,546,1109,2208,4391,8746,17404,34662,69036,137604,274385,547278", "code": "\nfrom fractions import gcd\nA251393_list, l1, l2, s, p2, b = [1,2], 3, 2, 4, 4, {}\nfor n in range(4,10**4):\n....i = s\n....while True:\n........if not i in b and gcd(i,l1) == 1 and gcd(i,l2) > 1:\n............l2, l1, b[i] = l1, i, 1\n............while s in b:\n................b.pop(s)\n................s += 1\n............if i == p2:\n................A251393_list.append(n)\n................p2 *= 2\n............break\n........i += 1 \n"}
{"sequence_id": "A251411", "text": "Numbers n such that A098550(n) = n.", "sequence": "1,2,3,4,12,50,86", "code": "\nfrom fractions import gcd\nA251411_list, l1, l2, s, b = [1,2,3], 3, 2, 4, {}\nfor n in range(4,10**4):\n....i = s\n....while True:\n........if not i in b and gcd(i,l1) == 1 and gcd(i,l2) > 1:\n............l2, l1, b[i] = l1, i, 1\n............while s in b:\n................b.pop(s)\n................s += 1\n............if i == n:\n................A251411_list.append(n)\n............break\n........i += 1 \n"}
{"sequence_id": "A251413", "text": "a(n) = 2n-1 if n <= 3, otherwise the smallest odd number not occurring earlier having at least one common factor with a(n-2), but none with a(n-1).", "sequence": "1,3,5,9,25,21,55,7,11,35,33,49,15,77,27,91,45,13,51,65,17,39,85,57,115,19,23,95,69,125,63,145,81,29,75,203,93,119,31,105,341,87,121,111,143,37,99,185,117,155,123,175,41,133", "code": "\nfrom fractions import gcd\nA251413_list, l1, l2, s, b = [1,3,5], 5, 3, 7, {}\nfor _ in range(1,10**4):\n....i = s\n....while True:\n........if not i in b and gcd(i,l1) == 1 and gcd(i,l2) > 1:\n............A251413_list.append(i)\n............l2, l1, b[i] = l1, i, True\n............while s in b:\n................b.pop(s)\n................s += 2\n............break\n........i += 2 \n"}
{"sequence_id": "A251414", "text": "(A251413(n) + 1)/2.", "sequence": "1,2,3,5,13,11,28,4,6,18,17,25,8,39,14,46,23,7,26,33,9,20,43,29,58,10,12,48,35,63,32,73,41,15,38,102,47,60,16,53,171,44,61,56,72,19,50,93,59,78,62,88,21,67,103,74,108", "code": "\nfrom __future__ import division\nfrom fractions import gcd\nA251414_list, l1, l2, s, b = [1,2,3], 5, 3, 7, {}\nfor _ in range(1,10**2):\n....i = s\n....while True:\n........if not i in b and gcd(i,l1) == 1 and gcd(i,l2) > 1:\n............A251414_list.append((i+1)//2)\n............l2, l1, b[i] = l1, i, True\n............while s in b:\n................b.pop(s)\n................s += 2\n............break\n........i += 2 \n"}
{"sequence_id": "A251415", "text": "Values of A098550 where A098550(n)/n reaches a new high-water mark.", "sequence": "1,9,15,25,35,329,581,679,3443,5753,6941,9229,10417,11561,14963,30043,45071,120107,135187,150137,255221,1786819,2552567,2807737,3063077,4849921,14549573,33948953,38798741,43648643,63048061,72747599,82447327,87297191", "code": "\nfrom fractions import gcd\nA251415_list, l1, l2, s, u, l, b = [1], 3, 2, 4, 1, 1, {}\nfor n in range(4,10**4):\n....i = s\n....while True:\n........if not i in b and gcd(i,l1) == 1 and gcd(i,l2) > 1:\n............l2, l1, b[i] = l1, i, 1\n............while s in b:\n................b.pop(s)\n................s += 1\n............if u*n < i*l:\n................A251415_list.append(i)\n................u, l = i, n\n............break\n........i += 1 \n"}
{"sequence_id": "A251554", "text": "a(1)=1, a(2)=2, a(3)=5; thereafter a(n) is the smallest number not occurring earlier having at least one common factor with a(n-2), but none with a(n-1).", "sequence": "1,2,5,4,15,8,3,10,9,14,27,7,6,35,12,25,16,45,22,21,11,18,55,24,65,28,13,20,39,32,33,26,51,38,17,19,34,57,40,63,44,49,30,77,36,91,46,105,23,42,115,48,85,52,75,56,69,50,81,58,93,29,31,87,62,99,64,111", "code": "\nfrom fractions import gcd\nA251554_list, l1, l2, s, b = [1,2,5], 5, 2, 3, {5}\nfor _ in range(10**4):\n....i = s\n....while True:\n........if not i in b and gcd(i,l1) == 1 and gcd(i,l2) > 1:\n............A251554_list.append(i)\n............l2, l1 = l1, i\n............b.add(i)\n............while s in b:\n................b.remove(s)\n................s += 1\n............break\n........i += 1 \n"}
{"sequence_id": "A251555", "text": "a(1)=1, a(2)=3, a(3)=2; thereafter a(n) is the smallest number not occurring earlier having at least one common factor with a(n-2), but none with a(n-1).", "sequence": "1,3,2,9,4,15,8,5,6,25,12,35,16,7,10,21,20,27,14,33,26,11,13,22,39,28,45,32,51,38,17,18,85,24,55,34,65,36,91,30,49,40,63,44,57,46,19,23,76,69,50,81,52,75,56,87,62,29,31,58,93,64,99,68,77,48,119,54,133,60,161,66,115,42,95,72,125", "code": "\nfrom fractions import gcd\nA251555_list, l1, l2, s, b = [1,3,2], 2, 3, 4, set()\nfor _ in range(10**4):\n....i = s\n....while True:\n........if not i in b and gcd(i,l1) == 1 and gcd(i,l2) > 1:\n............A251555_list.append(i)\n............l2, l1 = l1, i\n............b.add(i)\n............while s in b:\n................b.remove(s)\n................s += 1\n............break\n........i += 1 \n"}
{"sequence_id": "A251561", "text": "A permutation of the natural numbers: interchange p and 2p for every prime p.", "sequence": "1,4,6,2,10,3,14,8,9,5,22,12,26,7,15,16,34,18,38,20,21,11,46,24,25,13,27,28,58,30,62,32,33,17,35,36,74,19,39,40,82,42,86,44,45,23,94,48,49,50,51,52,106,54,55,56,57,29,118,60,122,31,63,64,65,66", "code": "\nfrom sympy import isprime\ndef A251561(n):\n....if n == 2:\n........return 4\n....q,r = divmod(n,2)\n....if r :\n........if isprime(n):\n............return 2*n\n........return n\n....if isprime(q):\n........return q\n....return n \n"}
{"sequence_id": "A251603", "text": "Numbers n such that n + 2 divides n^n - 2.", "sequence": "3,4551,46775,82503,106976,1642796,4290771,4492203,4976427,21537831,21549347,21879936,51127259,56786087,60296571,80837771,87761787,94424463,96593696,138644871,168864999,221395539,255881451,297460451,305198247,360306363,562654203", "code": "\nA251603_list = [n for n in range(1,10**6) if pow(n, n, n+2) == 2] \n"}
{"sequence_id": "A251623", "text": "Primes p with property that the sum of the 4th powers of the successive gaps between primes <= p is a prime number.", "sequence": "5,19,29,41,61,67,83,89,103,113,167,179,229,263,281,283,307,317,359,461,467,509,563,571,613,739,743,761,1019,1031,1051,1093,1229,1291,1297,1319,1409,1447,1609,1621,1667,1747,1801,1877,1979,2113,2137,2161", "code": "\nimport sympy\np=2\ns=0\nwhile 10000>p>0:\n    np=sympy.nextprime(p)\n    if sympy.isprime(s):\n        print(p)\n    d=np-p\n    s+=(d**4)\n    p=np\n"}
{"sequence_id": "A251726", "text": "Numbers n > 1 for which gpf(n) < lpf(n)^2, where lpf and gpf (least and greatest prime factor of n) are given by A020639(n) and A006530(n).", "sequence": "2,3,4,5,6,7,8,9,11,12,13,15,16,17,18,19,21,23,24,25,27,29,31,32,35,36,37,41,43,45,47,48,49,53,54,55,59,61,63,64,65,67,71,72,73,75,77,79,81,83,85,89,91,95,96,97,101,103,105,107,108,109,113,115,119,121,125,127,128,131,133,135,137,139,143,144", "code": "\nfrom sympy import primefactors\nprint([n for n in range(2, 150) if max(primefactors(n))<min(primefactors(n))**2]) \n"}
{"sequence_id": "A251743", "text": "Pairs of nodes in a complete binary tree that are at an absolute height difference of less than 2 from each other.", "sequence": "3,13,49,185,713,2793,11049,43945,175273,700073,2798249,11188905,44747433,178973353,715860649,2863377065,11453377193,45813246633,183252462249,733008800425,2932033104553,11728128223913,46912504507049,187650001250985,750599971449513,3002399818689193,12009599140539049", "code": "\ndef nc2(n):\n    return n * (n-1) / 2\ndef numAdjacentNodes(levels):\n    ret = 0\n    for level in range(1, levels+1):\n        ret += ((1 << level) + nc2(1 << level))\n    return ret\nfor height in range(1, 33):\n    print numAdjacentNodes(height)\n"}
{"sequence_id": "A251756", "text": "a(0) = 0; for n>0, a(n) is the smallest integer not already in the list with a composite common factor with a(n-1).", "sequence": "0,4,8,12,6,18,9,27,36,16,20,10,30,15,45,54,24,28,14,42,21,63,72,32,40,44,22,66,33,99,81,90,48,52,26,78,39,117,108,56,60,50,25,75,100,64,68,34,102,51,153,126,70,35,105,84,76,38,114,57,171,135,120,80", "code": "\nfrom gmpy2 import gcd, is_prime\nA251756_list, l, s, b = [0], 0, 1, {}\nfor _ in range(10**3):\n....i = s\n....while True:\n........if not i in b:\n............m = gcd(i,l)\n............if not (m == 1 or is_prime(m)):\n................A251756_list.append(i)\n................l, b[i] = i, True\n................while s in b:\n....................b.pop(s)\n....................s += 1\n................break\n........i += 1 \n"}
{"sequence_id": "A251781", "text": "Numbers whose square is the sum of two distinct positive cubes.", "sequence": "3,24,81,98,168,192,228,312,375,525,588,648,671,784,847,1014,1029,1183,1225,1261,1323,1344,1536,1824,2187,2496,2646,2888,3000,3993,4200,4225,4536,4563,4644,4704,5184,5368,6156,6272,6292,6371,6591,6696,6776,6877,8112", "code": "\ndef aupto(limit):\n  c = [i**3 for i in range(1, int(limit**(2/3))+2) if i**3 <= limit**2]\n  cc = [c1 + c2 for i, c1 in enumerate(c) for c2 in c[i+1:]]\n  return sorted([i for i in range(1, limit+1) if i*i in cc])\nprint(aupto(8122)) \n"}
{"sequence_id": "A251853", "text": "Nonnegative numbers n with all even digits such that the digital sum of the digits' sum is even.", "sequence": "0,2,4,6,8,20,22,24,26,40,42,44,60,62,80,200,202,204,206,220,222,224,240,242,260,400,402,404,420,422,440,488,600,602,620,668,686,688,800,848,866,868,884,886,888,2000,2002,2004,2006,2020,2022,2024,2040,2042,2060,2200", "code": "\nA251853_list = [int(''.join(d)) for d in product('02468',repeat=4) if not sum(int(y) for y in str(sum(int(x) for x in d))) % 2] \n"}
{"sequence_id": "A251862", "text": "Numbers n such that n + 3 divides n^n - 3.", "sequence": "3,7,10,27,727,1587,9838,758206,789223,1018846,1588126,1595287,2387206,4263586,9494746,12697378,17379860,21480726,25439767,38541526,44219926,55561536,62072326,64335356,70032586,83142466,85409276", "code": "\nA251862_list = [n for n in range(10**6) if pow(-3, n, n+3) == 3] \n"}
{"sequence_id": "A251966", "text": "Numbers representable as both b^c - b + c and x^y + x - y, where b, c, x, y are integers greater than 1.", "sequence": "4,14,18,27,123,256,3125,6556,6566,46656,823543,16777216,387420489,10000000000,285311670611,8916100448256,95367431640610,95367431640640,302875106592253,11112006825558016,437893890380859375,18446744073709551616,827240261886336764177", "code": "\nTOP = 10000000\na = [0]*TOP\nfor y in range(2, TOP//2):\n  if 2**y+2-y>=TOP: break\n  for x in range(2, TOP//2):\n    k = x**y+x-y\n    if k>=TOP: break\n    if k>=0: a[k]=1\nfor y in range(2, TOP//2):\n  if 2**y-2+y>=TOP: break\n  for x in range(2, TOP//2):\n    k = x**y-x+y\n    if k>=TOP: break\n    if k>=0: a[k]|=2\nprint([n for n in range(TOP) if a[n]==3])\n"}
{"sequence_id": "A251984", "text": "Smallest number such that a carry occurs when adding it to n in decimal representation.", "sequence": "9,8,7,6,5,4,3,2,1,90,9,8,7,6,5,4,3,2,1,80,9,8,7,6,5,4,3,2,1,70,9,8,7,6,5,4,3,2,1,60,9,8,7,6,5,4,3,2,1,50,9,8,7,6,5,4,3,2,1,40,9,8,7,6,5,4,3,2,1,30,9,8,7,6,5,4,3,2,1,20,9,8,7,6", "code": "\ndef a(n):\n    s = str(n)\n    t = s.strip('0')\n    return (10 - int(t)%10) * 10**(len(s) - len(t))\nprint([a(n) for n in range(1, 85)]) \n"}
{"sequence_id": "A252022", "text": "Lexicographically earliest permutation of the positive integers, such that no carry occurs when adjacent terms are added in decimal representation.", "sequence": "1,2,3,4,5,10,6,11,7,12,13,14,15,20,8,21,16,22,17,30,9,40,18,31,23,24,25,32,26,33,34,35,41,27,42,36,43,44,45,50,19,60,28,51,37,52,46,53,100,29,70,101,38,61,102,47,110,39,120,48,111,54,103,55,104", "code": "\nA252022_list, l, s, b = [1], [1], 2, set()\nfor _ in range(10**3):\n....i = s\n....while True:\n........if i not in b:\n............li = [int(d) for d in str(i)[::-1]]\n............for x,y in zip(li,l):\n................if x+y > 9:\n....................break\n............else:\n................l = li\n................b.add(i)\n................A252022_list.append(i)\n................while s in b:\n....................b.remove(s)\n....................s += 1\n................break\n........i += 1 \n"}
{"sequence_id": "A252079", "text": "Fixed points of permutations A252022 and A252023.", "sequence": "1,2,3,4,5,36,72,125,136,900,4454,8021,27223,33905,73222,127536,146353,180177,234668,273241", "code": "\nA252079_list, l, s, b = [1], [1], 2, set()\nfor n in range(2,10**5):\n....i = s\n....while True:\n........if i not in b:\n............li = [int(d) for d in str(i)[::-1]]\n............for x,y in zip(li,l):\n................if x+y > 9:\n....................break\n............else:\n................l = li\n................b.add(i)\n................if i == n:\n....................A252079_list.append(i)\n................while s in b:\n....................b.remove(s)\n....................s += 1\n................break\n........i += 1 \n"}
{"sequence_id": "A252169", "text": "Beatty sequence for sqrt(Pi*phi) where phi is the golden ratio A001622.", "sequence": "2,4,6,9,11,13,15,18,20,22,24,27,29,31,33,36,38,40,42,45,47,49,51,54,56,58,60,63,65,67,69,72,74,76,78,81,83,85,87,90,92,94,96,99,101,103,105,108,110,112,114,117,119,121,124,126,128,130", "code": " from sympy import *\nfor n in range(1,3001): print(floor(n*sqrt(pi*(1+sqrt(5))/2)),end=', ')\n"}
{"sequence_id": "A252463", "text": "Hybrid shift: a(1) = 1, a(2n) = n, a(2n+1) = A064989(2n+1); shift the even numbers one bit right, shift the prime factorization of odd numbers one step towards smaller primes.", "sequence": "1,1,2,2,3,3,5,4,4,5,7,6,11,7,6,8,13,9,17,10,10,11,19,12,9,13,8,14,23,15,29,16,14,17,15,18,31,19,22,20,37,21,41,22,12,23,43,24,25,25,26,26,47,27,21,28,34,29,53,30,59,31,20,32,33,33,61,34,38,35,67,36,71,37,18,38,35,39,73,40,16", "code": "\nfrom sympy import factorint, prevprime\nfrom operator import mul\ndef a064989(n):\n    f = factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==2 else prevprime(i)**f[i] for i in f])\ndef a(n): return 1 if n==1 else n//2 if n%2==0 else a064989(n)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A252481", "text": "Numbers whose set of digits is simply connected to 1.", "sequence": "1,10,11,12,21,100,101,102,110,111,112,120,121,122,123,132,201,210,211,212,213,221,231,312,321,1000,1001,1002,1010,1011,1012,1020,1021,1022,1023,1032,1100,1101,1102,1110,1111,1112,1120,1121,1122,1123,1132,1200,1201,1202,1203,1210,1211,1212,1213,1220,1221,1222,1223", "code": "\ndef ok(n):\n  s = set(str(n)); return '1' in s and len(s) == ord(max(s))-ord(min(s))+1\ndef aupto(nn): return [m for m in range(1, nn+1) if ok(m)]\nprint(aupto(1223)) \n"}
{"sequence_id": "A252606", "text": "Numbers n such that n + 2 divides 2^n + 2.", "sequence": "3,4,16,196,2836,4551,5956,25936,46775,65536,82503,540736,598816,797476,1151536,3704416,4290771,4492203,4976427,8095984,11272276,13362420,21235696,21537831,21549347,29640832,31084096,42913396,49960912,51127259,55137316,56786087,60296571,70254724,70836676", "code": "\nA252606_list = [n for n in range(10**4) if pow(2, n, n+2) == n] \n"}
{"sequence_id": "A252648", "text": "Irregular table of perfect digital invariants for n > 1, i.e., numbers equal to the sum of n-th powers of their digits, read by rows.", "sequence": "1,0,1,2,3,4,5,6,7,8,9,0,1,0,1,153,370,371,407,0,1,1634,8208,9474,0,1,4150,4151,54748,92727,93084,194979,0,1,548834,0,1,1741725,4210818,9800817,9926315,14459929,0,1,24678050,24678051,88593477,0,1,146511208,472335975,534494836,912985153,0,1,4679307774", "code": "\nfrom itertools import combinations_with_replacement\nA252648_list = [1]\nfor m in range(1,21):\n    l, L, dm, xlist, q = 1, 1, [d**m for d in range(10)], [0], 9**m\n    while l*q >= L:\n        for c in combinations_with_replacement(range(1,10),l):\n            n = sum(dm[d] for d in c)\n            if sorted(int(d) for d in str(n)) == [0]*(len(str(n))-len(c))+list(c):\n                xlist.append(n)\n        l += 1\n        L *= 10\n    A252648_list.extend(sorted(xlist)) \n"}
{"sequence_id": "A252652", "text": "a(n) is the smallest nonnegative integer such that a(n)! contains a string of exactly n consecutive 0's, not including trailing 0's.", "sequence": "0,7,12,22,107,264,812,4919,12154,24612,75705,101805,236441,1946174", "code": "\nimport re\ndef A252652(n):\n    if n == 0:\n        return 0\n    f, i, s = 1, 0, re.compile('[0-9]*[1-9]0{'+str(n)+'}[1-9][0-9]*')\n    while s.match(str(f)) == None:\n        i += 1\n        f *= i\n    return i \n"}
{"sequence_id": "A252655", "text": "Smallest prime p with property that the sum of the n-th power of the successive gaps between primes <= p is also a prime number.", "sequence": "5,5,7,5,43,13,7,5,241,13,43,41,19,41,7,5,13,83,43,229,811,41,31,167,811,127,367,419,79,43,43,83,673,19,109,83,13,331,523,409,199", "code": "\nimport sympy\nc=1\nwhile c>0:\n....p=2\n....d=0\n....s=0\n....while p>0:\n........s=s+(d**c)\n........sp=sympy.isprime(s)\n........if sp ==True:\n............print(c,p)\n............p=-1\n............c=c+1\n........else:\n............np=sympy.nextprime(p)\n............d=np-p\n............p=np\n"}
{"sequence_id": "A252664", "text": "Minimal nontrivial undulant (A046075) divisible by n, or 0 if no undulant is divisible by n.", "sequence": "101,202,141,212,505,252,161,232,171,1010,121,252,494,252,525,272,272,252,171,2020,252,242,161,696,525,494,2727,252,232,3030,434,3232,363,272,525,252,3737,494,585,4040,656,252,989,484,585,414,141,4848,343,5050", "code": "\nfeld = []\nfor n in range(3, 500):\n...for a in range(1, 10):\n......for b in range(10):\n.........if a != b:\n............z_string = \"\"\n............for pos in range(n):\n...............if pos % 2 == 0:\n..................z_string = z_string + str(a)\n...............else:\n..................z_string = z_string + str(b)\n............z = int(z_string)\n............feld.append(z)\nfeld_length = len(feld)\nfor z in range (1, 150):\n...start = 0\n...while start < feld_length and feld[start] % z != 0:\n......start = start + 1\n...if start < feld_length:\n......print(z, feld[start])\n"}
{"sequence_id": "A252669", "text": "a(n) is the smallest integer k such that n*k mod (n+k) = 1, or -1 if no such k exists.", "sequence": "1,3,2,13,8,31,3,5,32,91,50,17,4,183,98,241,12,7,162,381,5,75,30,553,288,651,46,129,392,23,6,9,76,55,578,1261,100,47,722,1561,17,311,7,105,968,27,18,413,1152,11,1250,489,228,2863,34,3081,8,615,1682,217,1800,707", "code": "\nimport math\nfor n in range(1,333):\n    res=-1\nfor k in range(2**31-1):\n        if ((n*k) % (n+k) == 1):\n            res=k\n            break\n    print str(res)+',',\n"}
{"sequence_id": "A252862", "text": "Initial members of prime sextuples (n, n+2, n+6, n+8, n+18, n+20).", "sequence": "11,18041,97841,165701,392261,663581,1002341,1068701,1155611,1329701,1592861,1678751,1718861,1748471,2159231,2168651,2177501,2458661,2596661,3215741,3295541,3416051,3919241,4353311,5168921,5201291,5205461,6404771", "code": "\nfrom sympy import isprime\nfor n in range(1,10000001,2):\n..if isprime(n) and isprime(n+2) and isprime(n+6) and isprime(n+8) and isprime(n+18) and isprime(n+20): print(n,end=', ')\n"}
{"sequence_id": "A252865", "text": "a(n) = n if n <= 3, otherwise the smallest squarefree number not occurring earlier having at least one common factor with a(n-2), but none with a(n-1).", "sequence": "1,2,3,10,21,5,6,35,22,7,11,14,33,26,15,13,30,91,34,39,17,42,85,38,51,19,66,95,46,55,23,65,69,70,57,58,93,29,31,87,62,105,74,77,37,110,111,82,129,41,43,123,86,141,106,47,53,94,159,118,165,59,78,295", "code": "\nfrom fractions import gcd\nfrom sympy import factorint\nA252865_list, l1, l2, s, b = [1,2,3], 3, 2, 4, set()\nfor _ in range(10**2):\n....i = s\n....while True:\n........if max(factorint(i).values()) == 1:\n............if not i in b and gcd(i,l1) == 1 and gcd(i,l2) > 1:\n................A252865_list.append(i)\n................l2, l1 = l1, i\n................b.add(i)\n................while s in b:\n....................b.remove(s)\n....................s += 1\n................break\n........else:\n............b.add(i)\n........i += 1 \n"}
{"sequence_id": "A252867", "text": "a(n) = n if n <= 2, otherwise the smallest number not occurring earlier having in its binary representation at least one bit in common with a(n-2), but none with a(n-1).", "sequence": "0,1,2,5,10,4,3,12,17,6,9,18,8,7,24,33,14,32,11,36,19,40,16,13,48,15,80,34,20,35,28,65,22,41,66,21,42,68,25,38,72,23,64,26,69,50,73,52,67,44,81,46,129,30,97,130,29,98,132,27,100,131,56,70,49,74,37,82", "code": "\nA252867_list, l1, l2, s, b = [0,1,2], 2, 1, 3, set()\nfor _ in range(10**2):\n    i = s\n    while True:\n        if not (i in b or i & l1) and i & l2:\n            A252867_list.append(i)\n            l2, l1 = l1, i\n            b.add(i)\n            while s in b:\n                b.remove(s)\n                s += 1\n            break\n        i += 1 \n"}
{"sequence_id": "A252868", "text": "Squarefree version of A252867.", "sequence": "1,2,3,10,21,5,6,35,22,15,14,33,7,30,77,26,105,13,42,65,66,91,11,70,143,210,187,39,55,78,385,34,165,182,51,110,273,85,154,195,119,330,17,231,170,429,238,715,102,455,374,1365,38,1155,442,57,770,663,95,462,1105,114,1001,255", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import prime\ndef A019565(n):\n....return reduce(mul,(prime(i+1) for i,v in enumerate(bin(n)[:1:-1]) if v == '1')) if n > 0 else 1\nA252868_list, l1, l2, s, b = [1,2,3], 2, 1, 3, set()\nfor _ in range(10**4):\n....i = s\n....while True:\n........if not (i in b or i & l1) and i & l2:\n............A252868_list.append(A019565(i))\n............l2, l1 = l1, i\n............b.add(i)\n............while s in b:\n................b.remove(s)\n................s += 1\n............break\n........i += 1 \n"}
{"sequence_id": "A253046", "text": "An involution of the natural numbers: if n = 2*p_i then replace n with 3*p_{i+1}, and conversely if n = 3*p_i then replace n with 2*p_{i-1}, where p_i denotes the i-th prime.", "sequence": "1,2,3,9,5,15,7,8,4,21,11,12,13,33,6,16,17,18,19,20,10,39,23,24,25,51,27,28,29,30,31,32,14,57,35,36,37,69,22,40,41,42,43,44,45,87,47,48,49,50,26,52,53,54,55,56,34,93,59,60,61,111,63,64,65,66,67", "code": "\nfrom sympy import isprime, nextprime, prevprime\ndef A253046(n):\n....q2, r2 = divmod(n,2)\n....if not r2 and isprime(q2):\n........return 3*nextprime(q2)\n....else:\n........q3, r3 = divmod(n,3)\n........if not r3 and isprime(q3):\n............return 2*prevprime(q3)\n........return n \n"}
{"sequence_id": "A253047", "text": "Start with the natural numbers 1,2,3,...; interchange 2*prime(i) and 3*prime(i+1) for each i, and interchange prime(prime(i)) with prime(2*prime(i)) for each i.", "sequence": "1,2,7,9,13,15,3,8,4,21,29,12,5,33,6,16,43,18,19,20,10,39,23,24,25,51,27,28,11,30,79,32,14,57,35,36,37,69,22,40,101,42,17,44,45,87,47,48,49,50,26,52,53,54,55,56,34,93,139,60,61,111,63", "code": "\nfrom sympy import isprime, primepi, prevprime, nextprime, prime\ndef A253047(n):\n....if n <= 2:\n........return n\n....if n == 3:\n........return 7\n....q2, r2 = divmod(n,2)\n....if r2:\n........q3, r3 = divmod(n,3)\n........if r3:\n............if isprime(n):\n................m = primepi(n)\n................if isprime(m):\n....................return prime(2*m)\n................x, y = divmod(m,2)\n................if not y:\n....................if isprime(x):\n........................return prime(x)\n............return n\n........if isprime(q3):\n............return 2*prevprime(q3)\n........return n\n....if isprime(q2):\n........return 3*nextprime(q2)\n....return n \n"}
{"sequence_id": "A253050", "text": "A252867 read mod 2.", "sequence": "0,1,0,1,0,0,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,0,1,0,1,0,0,1,0", "code": "\nA253050_list, l1, l2, s, b = [0,1,0], 2, 1, 3, set()\nfor _ in range(10**4):\n....i = s\n....while True:\n........if not (i in b or i & l1) and i & l2:\n............A253050_list.append(i & 1)\n............l2, l1 = l1, i\n............b.add(i)\n............while s in b:\n................b.remove(s)\n................s += 1\n............break\n........i += 1 \n"}
{"sequence_id": "A253051", "text": "A compressed version of A253050 (A252867 mod 2): replace every substring 01 in A253050 with 1, every 001 with 2, every 0001 with 3, every 00001 with 4, etc.", "sequence": "1,1,2,1,1,2,1,2,1,2,1,3,1,1,1,2,2,2,1,1,1,1,1,1,2,1,2,1,1,1,1,2,1,1,1,1,1,1,1,3,1,1,1,2,1,2,2,2,1,1,2,1,2,1,1,2,1,1,1,2,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,3,1,1,2,2,1,1,2,1,1,1,2,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,2,1", "code": "\nA253051_list, c, l1, l2, s, b = [1], 1, 2, 1, 3, set()\nfor _ in range(10**6):\n....i = s\n....while True:\n........if not (i in b or i & l1) and i & l2:\n............if i & 1:\n................A253051_list.append(c)\n................c = 0\n............else:\n................c += 1\n............l2, l1 = l1, i\n............b.add(i)\n............while s in b:\n................b.remove(s)\n................s += 1\n............break\n........i += 1 \n"}
{"sequence_id": "A253084", "text": "Triangle read by rows: T(n,k) = {binomial(n+k,n-k)*binomial(n,k)} mod 2, 0 <= k <= n.", "sequence": "1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,1,0,1,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1", "code": "\ndef A253084_T(n,k):\n    return int(not (~(n+k) & (n-k)) | (~n & k)) \n"}
{"sequence_id": "A253147", "text": "Palindromes in base 10 >= 256 that remain palindromes when the digits are reversed in base 256.", "sequence": "8448,31613,32123,55255,63736,92929,96769,108801,450054,516615,995599,1413141,1432341,1539351,1558551,2019102,2491942,2513152,2712172,2731372,2750572,2807082,2838382,2857582,2876782,3097903,3740473,3866683,3885883,4201024,4220224,4327234", "code": "\nfrom __future__ import division\ndef palgen(l,b=10): \n....if l > 0:\n........yield 0\n........for x in range(1,l+1):\n............n = b**(x-1)\n............n2 = n*b\n............for y in range(n,n2):\n................k, m = y//b, 0\n................while k >= b:\n....................k, r = divmod(k,b)\n....................m = b*m + r\n................yield y*n + b*m + k\n............for y in range(n,n2):\n................k, m = y, 0\n................while k >= b:\n....................k, r = divmod(k,b)\n....................m = b*m + r\n................yield y*n2 + b*m + k\ndef reversedigits(n,b=10): \n....x, y = n, 0\n....while x >= b:\n........x, r = divmod(x,b)\n........y = b*y + r\n....return b*y + x\nA253147_list = []\nfor n in palgen(4):\n....x = reversedigits(n,256)\n....if n > 255 and x == reversedigits(x,10):\n........A253147_list.append(n)\n"}
{"sequence_id": "A253148", "text": "Nontrivial palindromes in base 10 and base 256.", "sequence": "55255,63736,92929,96769,108801,450054,516615,995599,1413141,1432341,1539351,1558551,2019102,2491942,2807082,3097903,3740473,3866683,3885883,4201024,4220224,4327234,4346434,4365634,4384834,5614165,5633365,5759575,6692966,7153517,7172717", "code": "\nfrom __future__ import division\ndef palgen(l, b=10): \n....if l > 0:\n........yield 0\n........for x in range(1, l+1):\n............n = b**(x-1)\n............n2 = n*b\n............for y in range(n, n2):\n................k, m = y//b, 0\n................while k >= b:\n....................k, r = divmod(k, b)\n....................m = b*m + r\n................yield y*n + b*m + k\n............for y in range(n, n2):\n................k, m = y, 0\n................while k >= b:\n....................k, r = divmod(k, b)\n....................m = b*m + r\n................yield y*n2 + b*m + k\ndef reversedigits(n, b=10): \n....x, y = n, 0\n....while x >= b:\n........x, r = divmod(x, b)\n........y = b*y + r\n....return b*y + x\nA253148_list = []\nfor n in palgen(5):\n....if n > 255 and n == reversedigits(n,256):\n........A253148_list.append(n)\n"}
{"sequence_id": "A253149", "text": "Primes >= 256 that remain primes when the digits are reversed in base 256.", "sequence": "257,269,293,311,313,347,379,397,419,449,479,491,773,809,823,827,829,857,883,887,947,953,971,977,1013,1283,1289,1297,1301,1307,1321,1327,1367,1373,1399,1409,1429,1439,1451,1453,1481,1483,1511,1523,1801,1811,1847,1867", "code": "\nfrom sympy import prime, isprime\ndef reversedigits(n, b=10): \n    x, y = n, 0\n    while x >= b:\n        x, r = divmod(x, b)\n        y = b*y + r\n    return b*y + x\nA253149_list = []\nfor n in range(1, 300):\n    p = prime(n)\n    if p > 255 and isprime(reversedigits(p,256)):\n        A253149_list.append(p)\nprint(A253149_list)\n"}
{"sequence_id": "A253181", "text": "Numbers n such that the distance between n^3 and the nearest square is less than n.", "sequence": "1,2,3,4,5,9,13,15,16,17,25,32,35,36,37,40,43,46,49,52,56,63,64,65,81,99,100,101,109,121,136,143,144,145,152,158,169,175,190,195,196,197,225,243,255,256,257,289,312,317,323,324,325,331,336,351,356,361,366,377", "code": "\ndef isqrt(a):\n    sr = 1 << (int.bit_length(int(a)) >> 1)\n    while a < sr*sr:  sr>>=1\n    b = sr>>1\n    while b:\n        s = sr + b\n        if a >= s*s:  sr = s\n        b>>=1\n    return sr\nfor n in range(1000):\n    cube = n*n*n\n    r = isqrt(cube)\n    sqr = r**2\n    if cube-sqr < n or sqr+2*r+1-cube < n:  print(str(n), end=',')\n"}
{"sequence_id": "A253264", "text": "Primes p such that q = p^2 - 2, r = q^2 - 2, s = r^2 - 2 and t = s^2 - 2 are all prime.", "sequence": "2,1644103,3892831,5178193,5497949,5657699,11078437,13379917,14471147,14890693,19861879,25219343,27671803,28012511,29878997,31848277,32550769,34190399,40630441,42081719,47187919,53964661,54795553,55912781,59327927,64749281,68818993", "code": "\nfrom gmpy2 import is_prime, next_prime\nA253264_list, p = [], 2\nfor _ in range(10**10):\n....q = p**2 - 2\n....if is_prime(q):\n........r = q**2 -2\n........if is_prime(r):\n............s = r**2-2\n............if is_prime(s) and is_prime(s**2-2):\n................A253264_list.append(p)\n....p = next_prime(p) \n"}
{"sequence_id": "A253285", "text": "a(n) = RF(n+1,3)*C(n+2,n-1), where RF(a,n) is the rising factorial.", "sequence": "0,24,240,1200,4200,11760,28224,60480,118800,217800,377520,624624,993720,1528800,2284800,3329280,4744224,6627960,9097200,12289200,16364040,21507024,27931200,35880000,45630000,57493800,71823024,89011440,109498200,133771200,162370560", "code": " [n*((n+1)*(n+2))**2*(n+3)/6 for n in range(40)] \n"}
{"sequence_id": "A253295", "text": "Prime factor look-and-say sequence starting with a(0) = 8.", "sequence": "8,32,52,22113,5317113,131167110613,1711111711229181533,1761140131560305063481,1313718313871371493773936301,125111501315199577167049112574051,33185242436199338915435977096119517,149731486009055371137303679066123116017", "code": "\nfrom sympy import factorint\nA253295_list = [8]\nfor _ in range(10):\n....A253295_list.append(int(''.join((str(e)+str(p) for p, e in sorted(factorint(A253295_list[-1]).items())))))\n\n"}
{"sequence_id": "A253315", "text": "a(n) = bitwise XOR of all the bit numbers for the bits that are set in n.", "sequence": "0,0,1,1,2,2,3,3,3,3,2,2,1,1,0,0,4,4,5,5,6,6,7,7,7,7,6,6,5,5,4,4,5,5,4,4,7,7,6,6,6,6,7,7,4,4,5,5,1,1,0,0,3,3,2,2,2,2,3,3,0,0,1,1,6,6,7,7,4,4,5,5,5,5,4,4,7,7,6,6,2,2,3,3,0,0,1,1,1,1,0,0,3,3,2,2,3,3,2,2,1,1,0,0,0", "code": "\ndef a(n):\n..r = 0\n..b = 0\n..while n > 0:\n....if (n & 1):\n......r = r ^ b\n....b = b + 1\n....n = n >> 1\n..return r\n"}
{"sequence_id": "A253412", "text": "Number of n-bit legal binary words with maximal set of 1s.", "sequence": "1,2,2,4,4,7,9,13,18,25,36,49,70,97,137,191,268,376,526,738,1033,1449,2029,2844,3985,5584,7825,10964,15365,21529,30169,42274,59238,83008,116316,162991,228393,320041,448462,628417,880580,1233929,1729066,2422885,3395113,4757463", "code": "\ndef A253412(n):\n    c, fs = 0, '0'+str(n)+'b'\n    for i in range(2**n):\n        s = '01'+format(i,fs)+'10'\n        for j in range(n):\n            if s[j:j+4] == '0100' or s[j+1:j+5] == '0010' or s[j+1:j+4] == '000' or s[j+1:j+4] == '111':\n                break\n        else:\n            c += 1\n    return c \n"}
{"sequence_id": "A253413", "text": "Number of n-bit legal circular binary words with maximal set of 1's.", "sequence": "1,2,3,6,5,5,14,14,21,27,44,57,78,114,158,222,306,437,608,851,1193,1674,2346,3281,4605,6450,9039,12662,17748,24870,34844,48830,68423,95882,134349,188265,263810,369666,518001,725859,1017128,1425261,1997178,2798582", "code": "\ndef A253413(n):\n....if n > 1:\n........c, fs = 0, '0'+str(n)+'b'\n........for i in range(2**n):\n............s = format(i,fs)\n............s = s[-2:]+s+s[:2]\n............for j in range(n):\n................if s[j:j+4] == '0100' or s[j+1:j+5] == '0010' or s[j+1:j+4] == '000' or s[j+1:j+4] == '111':\n....................break\n............else:\n................c += 1\n........return c\n....else:\n........return 1 \n"}
{"sequence_id": "A253472", "text": "Square Pairs: Numbers n such that 1, 2, ..., 2n can be partitioned into n pairs, where each pair adds up to a perfect square.", "sequence": "4,7,8,9,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80", "code": " \n"}
{"sequence_id": "A253549", "text": "Maximal prime written in decimal among the base-k representations of the n-th prime, read in base 16, for k=2,3,...,16.", "sequence": "2,17,257,19,19,19,65537,37,65809,53,307,257,53,547,563,293,101,277,4099,577,4129,8737,787,137,577,257,593,4643,4657,773,577,821,311,313,268501249,74017,74257,8707,359,8753,8963,613,9011,12289,285212929,577,135697", "code": "\nfrom sympy import prime, isprime\ndef A253549(n):\n....p = prime(n)\n....for b in range(2,17):\n........x, y, z = p, 0, 1\n........while x >= b:\n............x, r = divmod(x,b)\n............y += r*z\n............z *= 16\n........y += x*z\n........if isprime(y):\n............return y\n"}
{"sequence_id": "A253574", "text": "Primes p such that digits of p do not appear in p^4.", "sequence": "2,3,7,53,59,67,89,383,887,2027,3253,5669,7993,8009,9059,53633,54667,56533,88883,272777777,299222299,383833883,797769997", "code": "\nfrom sympy import isprime\nA253574_list = [n for n in range(1,10**6) if set(str(n)) & set(str(n**4)) == set() and isprime(n)]\n\n"}
{"sequence_id": "A253575", "text": "Primes p such that digits of p do not appear in p^6.", "sequence": "2,3,13,44449", "code": "\nfrom sympy import isprime\nA253575_list = [n for n in range(1,10**6) if set(str(n)) & set(str(n**6)) == set() and isprime(n)]\n\n"}
{"sequence_id": "A253576", "text": "Primes p such that digits of p do not appear in p^7.", "sequence": "3,7,43,7757,31333", "code": "\nfrom sympy import isprime\nA253576_list = [n for n in range(1,10**6) if set(str(n)) & set(str(n**7)) == set() and isprime(n)]\n\n"}
{"sequence_id": "A253577", "text": "Primes p such that digits of p do not appear in p^8.", "sequence": "3,43,59,73,233,353", "code": "\nfrom sympy import isprime\nA253577_list = [n for n in range(1,10**6) if set(str(n)) & set(str(n**8)) == set() and isprime(n)]\n\n"}
{"sequence_id": "A253578", "text": "Primes p such that digits of p do not appear in p^10.", "sequence": "3,877", "code": "\nfrom sympy import isprime\nA253578_list = [n for n in range(1,10**6) if set(str(n)) & set(str(n**10)) == set() and isprime(n)] \n"}
{"sequence_id": "A253594", "text": "Numbers n that have more than one palindromic representation in bases 2 <= b <= n-2.", "sequence": "10,15,16,17,18,20,21,24,26,27,28,30,31,32,33,34,36,38,40,42,44,45,46,48,50,51,52,54,55,56,57,60,62,63,64,65,66,67,68,70,72,73,74,75,76,78,80,81,82,84,85,86,88,90,91,92,93,96,98,99,100,102,104,105,107,108,109,110,111,112,114,116,117,118,119,120,121,122,123,124", "code": "\nfrom itertools import count\n.\ndef base(n,b):\n...while n:\n......m = n%b\n......yield m\n......n = (n-m)//b\n.\ndef is_palindrome(seq):\n...seq = list(seq)\n...l = len(seq)//2\n...return seq[:l] == seq[-1:-l-1:-1]\n.\ndef a():\n...for n in count(2):\n......base_representations = [(b,list(base(n,b))) for b in range(2,n-1)]\n......pals = [(b,s) for b,s in base_representations if is_palindrome(s)]\n......if len(pals)>1:\n.........yield n\n"}
{"sequence_id": "A253606", "text": "Numbers n such that digits of n are not present in n^8.", "sequence": "3,4,8,9,22,33,43,54,59,73,222,233,353,712,777,22224", "code": "\nA253606_list = [n for n in range(1,10**6) if set(str(n)) & set(str(n**8)) == set()]\n"}
{"sequence_id": "A253608", "text": "The binary representation of a(n) is the concatenation of n and the binary complement of n, A035327(n).", "sequence": "2,9,12,35,42,49,56,135,150,165,180,195,210,225,240,527,558,589,620,651,682,713,744,775,806,837,868,899,930,961,992,2079,2142,2205,2268,2331,2394,2457,2520,2583,2646,2709,2772,2835,2898,2961,3024,3087,3150,3213", "code": "\nfor n in range(1,333):\n  print(str((n+1)*(2 ** int.bit_length(int(n))-1)), end=',')\n"}
{"sequence_id": "A253624", "text": "Initial members of prime sextuples (p, p+2, p+12, p+14, p+24, p+26).", "sequence": "5,17,1277,4217,21587,91127,103967,113147,122027,236867,342047,422087,524957,560477,626597,754967,797567,909317,997097,1322147,1493717,1698857,1748027,1762907,2144477,2158577,2228507,2398157,2580647,2615957", "code": "\nfrom sympy import isprime\nfor n in range(1,10000001,2):\n  if isprime(n) and isprime(n+2) and isprime(n+12) and isprime(n+14) and isprime(n+24) and isprime(n+26): print(n,end=', ')\n"}
{"sequence_id": "A253624", "text": "Initial members of prime sextuples (p, p+2, p+12, p+14, p+24, p+26).", "sequence": "5,17,1277,4217,21587,91127,103967,113147,122027,236867,342047,422087,524957,560477,626597,754967,797567,909317,997097,1322147,1493717,1698857,1748027,1762907,2144477,2158577,2228507,2398157,2580647,2615957", "code": "\nfrom sympy import isprime, primerange\ndef aupto(limit):\n  alst = []\n  for p in primerange(2, limit+1):\n    if all(map(isprime, [p+2, p+12, p+14, p+24, p+26])): alst.append(p)\n  return alst\nprint(aupto(3*10**6)) \n"}
{"sequence_id": "A253627", "text": "Initial members of prime sextuples (n, n+2, n+12, n+14, n+18, n+20).", "sequence": "179,809,5639,9419,62969,88799,109829,284729,452519,626609,663569,855719,983429,1003349,1146779,1322159,2116559,2144489,2668229,3153569,3437699,4575269,4606559,4977419,5248079,5436269,5450099,5651729", "code": "\nfrom sympy import isprime\nfor n in range(1,10000001,2):\n..if isprime(n) and isprime(n+2) and isprime(n+12) and isprime(n+14) and isprime(n+18) and isprime(n+20): print(n,end=', ')\n"}
{"sequence_id": "A253631", "text": "Palindromic primes containing only the digits 0 and 1 such that their squares are palindromes.", "sequence": "11,101,100111001,110111011,111010111,1100011100011,1100101010011,1101010101011,100110101011001,101000010000101,101011000110101,101110000011101,10000010101000001,10011010001011001,10100110001100101,10110010001001101,10111000000011101,11010001010001011,1000010101010100001,1001010100010101001", "code": "\nfrom sympy import isprime\nA253631_list = [11]\nfor i in range(2,2**30):\n....s = format(i,'b')\n....x = int(s+s[-2::-1])\n....s2 = str(x*x)\n....if s2 == s2[::-1] and isprime(x):\n........A253631_list.append(x)\n"}
{"sequence_id": "A253643", "text": "Numbers n such that n^k is zeroless for k=0,...,3.", "sequence": "1,2,3,4,5,6,7,8,9,11,12,13,14,15,17,18,19,21,23,24,25,26,27,28,29,31,35,36,38,39,41,44,46,54,56,57,58,61,62,65,66,68,72,75,76,77,81,82,83,85,88,91,92,96,111,113,114,119,121,122,125,129,132,133,136,137,139,146,154,156,157,158,161", "code": "\nfor n in range(100):\n..s1,s2,s3 = str(n),str(n**2),str(n**3)\n..if s1.find('0') + s2.find('0') + s3.find('0') == -3:\n....print(n,end=', ') \n"}
{"sequence_id": "A253646", "text": "Primes p such that p^k is zeroless for k=1,...,6.", "sequence": "2,3,5,17,48989,5453971,61636943111479,128359315177123,884785266899689,1116777231836989", "code": "\nfrom sympy import isprime\nA253646_list = [2]\nfor i in range(1,10**6,2):\n....if not '0' in str(i):\n........m = i\n........for k in range(5):\n............m *= i\n............if '0' in str(m):\n................break\n........else:\n............if isprime(i):\n................A253646_list.append(i) \n"}
{"sequence_id": "A253671", "text": "a(n) = floor(A000111(n+1)/A000111(n)).", "sequence": "1,1,2,2,3,3,4,5,5,6,7,7,8,8,9,10,10,11,12,12,13,14,14,15,15,16,17,17,18,19,19,20,21,21,22,22,23,24,24,25,26,26,27,28,28,29,29,30,31,31,32,33,33,34,35,35,36,36,37,38,38,39,40,40", "code": "\n\nfrom itertools import accumulate\nA253671_list, blist, l1, l2 = [1], [1], 1, 1\nfor n in range(10**2):\n....blist = list(reversed(list(accumulate(reversed(blist))))) + [0] if n % 2 else [0]+list(accumulate(blist))\n....l2, l1 = l1, sum(blist)\n....A253671_list.append(l1//l2) \n"}
{"sequence_id": "A253769", "text": "Sum of number of divisors of all positive integers <= prime(n).", "sequence": "3,5,10,16,29,37,52,60,76,103,113,142,160,170,188,219,249,263,294,314,328,358,379,413,461,484,494,516,530,554,637,659,697,707,768,782,822,858,878,919,953,973,1033,1049,1072,1086,1168,1240,1267,1281,1307,1343,1365,1423,1468,1504,1544,1562,1604,1632,1642,1709", "code": "\nfrom math import isqrt\nfrom sympy import prime\ndef A253769(n): return (lambda m, p: 2*sum(p//k for k in range(1, m+1))-m*m)(isqrt(prime(n)),prime(n)) \n"}
{"sequence_id": "A253887", "text": "Row index of n in A191450: a(3n) = 2n, a(3n+1) = 2n+1, a(3n+2) = a(n+1).", "sequence": "1,1,2,3,1,4,5,2,6,7,3,8,9,1,10,11,4,12,13,5,14,15,2,16,17,6,18,19,7,20,21,3,22,23,8,24,25,9,26,27,1,28,29,10,30,31,11,32,33,4,34,35,12,36,37,13,38,39,5,40,41,14,42,43,15,44,45,2,46,47,16,48,49,17,50,51,6,52,53,18,54,55,19,56,57,7", "code": "\ndef a(n):\n    if n%3==0: return 2*n//3\n    elif n%3==1: return 2*(n - 1)//3 + 1\n    else: return a((n - 2)//3 + 1)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A253912", "text": "Fourth powers whose reversal is a prime.", "sequence": "16,38416,130321,160000,923521,1500625,13845841,14776336,16777216,38950081,163047361,181063936,312900721,322417936,384160000,937890625,1303210000,1600000000,3722098081,7992538801,9235210000,13841287201,15006250000,16610312161,17748900625,31414372081,37141383841", "code": "\nfrom sympy import isprime\nA253912_list = [n for n in (i**4 for i in range(10**6)) if isprime(int(str(n)[::-1]))] \n"}
{"sequence_id": "A253913", "text": "Numbers of the form m^k + m, with m >= 0 and k > 1.", "sequence": "0,2,6,10,12,18,20,30,34,42,56,66,68,72,84,90,110,130,132,156,182,210,222,240,246,258,260,272,306,342,350,380,420,462,506,514,520,552,600,630,650,702,732,738,756,812,870,930,992,1010,1026,1028,1056,1122,1190,1260,1302", "code": "\ndef aupto(lim):\n    xkx = set(x**k + x for k in range(2, lim.bit_length()) for x in range(int(lim**(1/k))+2))\n    return sorted(filter(lambda t: t<=lim, xkx))\nprint(aupto(1500)) \n"}
{"sequence_id": "A253941", "text": "Primes p such that (p^2 + 5)/6, (p^4 + 5)/6, (p^6 + 5)/6, (p^8 + 5)/6 and (p^10 + 5)/6 are all prime.", "sequence": "184279409,619338131,913749803,1057351301,1507289869,1600204213,2845213937,4725908767,4760956439,5374709801,5518707641,8724256757,9044067313,9387396269,10992352517,11937043567,13493126359,13593105793,17891702891,17897035213,17954907767,19690938161,20227580927,20922685813,21313027583,21717176851", "code": "\nfrom gmpy2 import is_prime, t_divmod\nA253941_list = []\nfor p in range(1,10**6,2):\n....if is_prime(p):\n........p2, x = p**2, 1\n........for i in range(5):\n............x *= p2\n............q, r = t_divmod(x+5,6)\n............if r or not is_prime(q):\n................break\n........else:\n............A253941_list.append(p) \n"}
{"sequence_id": "A254007", "text": "Cardinality of the set of equivalence classes of the set X_n of finite integer sequences {x_1 = 0, x_2, ..., x_n} satisfying |x_k - x_{k+1}| = 1, where two such sequences are deemed equivalent if they are permutations of each other.", "sequence": "1,1,2,4,7,13,22,40,66,118,192,338,546,948,1526,2618,4208,7146,11482,19332,31070,51938,83520,138786,223330,369284,594662,979306,1578064,2590138,4176394,6836164,11028942,18012562", "code": "\ndef generate_paths(n):\n    if n == 0:\n        yield (), 0\n    else:\n        results = set()\n        for p, last in generate_paths(n-1):\n            q = tuple(sorted(p + (last,)))\n            results.add((q, last+1))\n            results.add((q, last-1))\n        for p, last in results:\n            yield p, last\ndef count_paths(n):\n    results = set()\n    for p, last in generate_paths(n):\n        q = tuple(sorted(p + (last,)))\n        if not (q in results):\n            results.add(q)\n    return len(results)\nprint([count_paths(n) for n in range(15)])\n"}
{"sequence_id": "A254058", "text": "Smallest a(n) such that C(a(n),n) >= 2^n.", "sequence": "2,4,5,7,8,9,11,12,13,15,16,17,18,20,21,22,24,25,26,28,29,30,32,33,34,35,37,38,39,41,42,43,45,46,47,48,50,51,52,54,55,56,58,59,60,61,63,64,65,67,68,69,71,72,73,74,76,77,78,80,81,82,84,85,86,87,89", "code": "\n    a=n\n    while binomial(a,n)<2^n:\n        a=a+1\n"}
{"sequence_id": "A254058", "text": "Smallest a(n) such that C(a(n),n) >= 2^n.", "sequence": "2,4,5,7,8,9,11,12,13,15,16,17,18,20,21,22,24,25,26,28,29,30,32,33,34,35,37,38,39,41,42,43,45,46,47,48,50,51,52,54,55,56,58,59,60,61,63,64,65,67,68,69,71,72,73,74,76,77,78,80,81,82,84,85,86,87,89", "code": "\nfrom __future__ import division\ndef A254058(n):\n....b, a1, a2, t = 1, 0, n, 2**n\n....while b < t:\n........a2 += 1\n........a1 += 1\n........b = (b*a2)//a1\n....return a2 \n"}
{"sequence_id": "A254073", "text": "Number of solutions to x^3 + y^3 + z^3 == 1 (mod n) for 1 <= x, y, z <= n.", "sequence": "1,4,9,16,25,36,90,64,162,100,121,144,252,360,225,256,289,648,468,400,810,484,529,576,625,1008,1458,1440,841,900,1143,1024,1089,1156,2250,2592,1602,1872,2268,1600,1681,3240,2115,1936,4050,2116,2209,2304,4410", "code": "\ndef A254073(n):\n    ndict = {}\n    for i in range(n):\n        m = pow(i,3,n)\n        if m in ndict:\n            ndict[m] += 1\n        else:\n            ndict[m] = 1\n    count = 0\n    for i in ndict:\n        ni = ndict[i]\n        for j in ndict:\n            k = (1-i-j) % n\n            if k in ndict:\n                count += ni*ndict[j]*ndict[k]\n    return count \n"}
{"sequence_id": "A254078", "text": "a(n) is the number of steps after which n variables with increasing value ranges all have equal values when the values of all variables are decreased by 1 at each step and the value is set to the maximum value again when the resulting value would be 0.", "sequence": "4,10,58,58,418,838,2518,2518,27718,27718,360358,360358,360358,720718,12252238,12252238,232792558,232792558,232792558,232792558,5354228878,5354228878,26771144398,26771144398,80313433198,80313433198,2329089562798", "code": "\nfrom math import gcd\nlcm = 2\nfor n in range(3,53):\n..lcm *= n // gcd(lcm,n)\n..print(n-1,lcm-2) \n"}
{"sequence_id": "A254103", "text": "Permutation of natural numbers: a(0) = 0, a(2n) = (3*a(n))-1, a(2n+1) = floor((3*(1+a(n)))/2).", "sequence": "0,1,2,3,5,4,8,6,14,9,11,7,23,13,17,10,41,22,26,15,32,18,20,12,68,36,38,21,50,27,29,16,122,63,65,34,77,40,44,24,95,49,53,28,59,31,35,19,203,103,107,55,113,58,62,33,149,76,80,42,86,45,47,25,365,184,188,96,194,99,101,52,230,117,119,61,131,67,71,37,284,144,146,75,158,81,83,43", "code": "\ndef a(n):\n    if n==0: return 0\n    if n%2==0: return 3*a(n//2) - 1\n    else: return int((3*(1 + a((n - 1)//2)))/2)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A254104", "text": "Permutation of natural numbers: a(0) = 0, a(3n) = 1 + 2*a(2n - 1), a(3n+1) = 1 + 2*a(2n), a(3n+2) = 2*a(n+1).", "sequence": "0,1,2,3,5,4,7,11,6,9,15,10,23,13,8,19,31,14,21,47,22,27,17,12,39,63,18,29,43,30,95,45,20,55,35,46,25,79,26,127,37,16,59,87,38,61,191,62,91,41,28,111,71,42,93,51,94,159,53,44,255,75,54,33,119,34,175,77,24,123,383,78,125,183,126,83,57,36,223,143,58,85,187,86,103,189,60", "code": "\ndef a(n):\n    if n==0: return 0\n    if n%3==0: return 1 + 2*a(2*n//3 - 1)\n    elif n%3==1: return 1 + 2*a(2*(n - 1)//3)\n    else: return 2*a((n - 2)//3 + 1)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A254115", "text": "Permutation of natural numbers: a(n) = A254104(A048673(n)).", "sequence": "1,2,3,4,5,6,7,8,13,10,11,12,9,14,21,16,15,26,23,20,43,22,19,24,63,18,33,28,31,42,47,32,55,30,127,52,27,46,87,40,17,86,39,44,107,38,29,48,75,126,91,36,95,66,191,56,53,62,45,84,35,94,1023,64,255,110,25,60,183,254,79,104,37,54,171,92,125,174,59,80,4095,34,61,172,77,78", "code": "\nfrom sympy import factorint, nextprime\nfrom operator import mul\ndef a048673(n):\n    f = factorint(n)\n    return 1 if n==1 else (1 + reduce(mul, [nextprime(i)**f[i] for i in f]))/2\ndef a254104(n):\n    if n==0: return 0\n    if n%3==0: return 1 + 2*a254104(2*n/3 - 1)\n    elif n%3==1: return 1 + 2*a254104(2*(n - 1)/3)\n    else: return 2*a254104((n - 2)/3 + 1)\ndef a(n): return a254104(a048673(n)) \n"}
{"sequence_id": "A254116", "text": "Permutation of natural numbers: a(n) = A064216(A254103(n)).", "sequence": "1,2,3,4,5,6,7,8,13,10,11,12,9,14,17,16,41,26,23,20,15,22,19,24,67,18,37,28,47,34,29,32,27,82,61,52,73,46,43,40,89,30,21,44,59,38,31,48,111,134,107,36,57,74,33,56,149,94,79,68,83,58,25,64,359,54,181,164,193,122,101,104,229,146,49,92,85,86,71,80,185,178,139,60,95,42,39", "code": "\nfrom sympy import factorint, prevprime, floor\nfrom operator import mul\ndef a064216(n):\n    f=factorint(2*n - 1)\n    return 1 if n==1 else reduce(mul, [prevprime(i)**f[i] for i in f])\ndef a254103(n):\n    if n==0: return 0\n    if n%2==0: return 3*a254103(n/2) - 1\n    else: return floor((3*(1 + a254103((n - 1)/2)))/2)\ndef a(n): return a064216(a254103(n)) \n"}
{"sequence_id": "A254117", "text": "Permutation of natural numbers: a(n) = A254104(A249746(1+n)-1).", "sequence": "1,2,3,6,5,4,10,7,11,21,9,31,16,15,23,27,63,13,43,8,19,53,14,37,45,47,95,26,22,17,511,127,12,91,39,18,85,62,29,2047,30,38,111,20,54,75,42,55,157,35,46,174,25,79,24,59,77,303,123,94,78,167,87,223,61,103,699,191,41,107,183,125,431,28,71,84,60,93,110,767,51", "code": "\nfrom sympy import factorint, nextprime\nfrom operator import mul\ndef a048673(n):\n    f = factorint(n)\n    return 1 if n==1 else (1 + reduce(mul, [nextprime(i)**f[i] for i in f]))/2\ndef a254104(n):\n    if n==0: return 0\n    if n%3==0: return 1 + 2*a254104(2*n/3 - 1)\n    elif n%3==1: return 1 + 2*a254104(2*(n - 1)/3)\n    else: return 2*a254104((n - 2)/3 + 1)\ndef a254115(n): return a254104(a048673(n))\ndef a(n): return (a254115(2*n + 1) - 1)/2 \n"}
{"sequence_id": "A254118", "text": "Permutation of natural numbers: a(n) = A249745(1+A254103(n)) - 1.", "sequence": "1,2,3,6,5,4,8,20,11,7,9,33,18,23,14,13,30,36,21,44,10,29,15,55,53,28,16,74,39,41,12,179,90,96,50,114,24,42,35,92,69,47,19,86,25,51,26,236,153,110,81,101,22,45,48,221,113,119,56,77,65,38,17,546,182", "code": "\nfrom sympy import factorint, prevprime, floor\nfrom operator import mul\nfrom functools import reduce\ndef a064216(n):\n    f=factorint(2*n - 1)\n    return 1 if n==1 else reduce(mul, [prevprime(i)**f[i] for i in f])\ndef a254103(n):\n    if n==0: return 0\n    if n%2==0: return 3*a254103(n//2) - 1\n    else: return floor((3*(1 + a254103((n - 1)/2)))//2)\ndef a254116(n): return a064216(a254103(n))\ndef a(n): return (a254116(2*n + 1) - 1)//2\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A254149", "text": "Decimal expansion of the average reciprocal length of a line segment picked at random in a unit 4-cube.", "sequence": "1,4,8,1,4,3,2,6,3,6,5,2,1,0,6,4,7,4,9,7,4,8,7,6,9,1,4,0,7,2,7,6,5,8,3,0,2,5,7,0,9,5,2,6,3,4,1,5,4,8,6,1,0,4,8,8,7,7,5,3,7,8,9,6,7,1,6,8,2,3,9,9,1,0,3,5,0,7,1,2,8,8,9,1,6,3,6,9,5,7,7,9,8,6,9,0,5,5,2,9,1,8,5", "code": "\nfrom mpmath import *\nmp.dps=104\nx=3 - 2*sqrt(2)\nTi2x=(j/2)*(polylog(2, -j*x) - polylog(2, j*x))\nC=-152/315 - 8*pi/15 - 16/5*log(2) + 2/5*log(3) + 68/105*sqrt(2) - 16/35*sqrt(3) + 4/5*log(1 + sqrt(2)) + 32/5*log(1 + sqrt(3)) - 8/3*catalan + 8*Ti2x - 8/5*sqrt(2)*atan(sqrt(2)/4)\nprint([int(n) for n in list(str(C.real).replace('.','')[:-1])]) \n"}
{"sequence_id": "A254231", "text": "Product of tribonacci numbers A000073(2) * ... * A000073(n).", "sequence": "1,1,2,8,56,728,17472,768768,62270208,9278260992,2542243511808,1281290729951232,1187756506664792064,2025124843863470469120,6350791510355843391160320,36631365431732504680212725760,388622155865250142152376807587840", "code": "\nA254231_list, a, b, c, d = [1], 0, 0, 1, 1\nfor _ in range(100):\n....a, b, c = b, c, a+b+c\n....d *= c\n....A254231_list.append(d) \n"}
{"sequence_id": "A254232", "text": "Product of Perrin numbers A001608(2) * ... * A001608(n).", "sequence": "2,6,12,60,300,2100,21000,252000,4284000,94248000,2733192000,106594488000,5436318888000,369669684384000,33270271594560000,3959162319752640000,625547646520917120000,130739458122871678080000,36214829900035454828160000", "code": "\nA254232_list, a, b, c, d = [2], 3, 0, 2, 2\nfor _ in range(200):\n    a, b, c = b, c, a+b\n    d *= c\nA254232_list.append(d) \n"}
{"sequence_id": "A254315", "text": "Number of distinct digits in the prime factorization of n (counting terms of the form p^1 as p).", "sequence": "1,1,1,1,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,1,2,2,3,2,2,2,3,2,2,2,3,2,3,2,3,2,2,3,2,2,3,2,2,3,3,2,2,2,3,3,2,2,3,2,3,3,2,3,3,2,3,2,3,2,2,2,3,3,3,2,3,2,3,2,3,2,3,3,3,3,3", "code": "\nfrom sympy import factorint\ndef A254315(n):\n....return len(set([x for l in [[d for d in str(p)]+[d for d in str(e) if d != '1'] for p,e in factorint(n).items()] for x in l]))\n\n"}
{"sequence_id": "A254334", "text": "Powers of 3 in base 60, concatenating the decimal values of the sexagesimal digits.", "sequence": "1,3,9,27,121,403,1209,3627,14921,52803,162409,491227,2273721,7225203,22083609,106254827,319172521,957521603,2953364809,12940502427,42902311321,132707334003,402122410009,2010408030027,6031224090121,18093712270403,54285137211209", "code": "\ndef digits(n,b=10): \n....x, y = n, []\n....while x >= b:\n........x, r = divmod(x,b)\n........y.append(r)\n....y.append(x)\n....return list(reversed(y))\nA254334_list = [int(''.join([format(x,'02d') for x in digits(3**i, 60)])) for i in range(10**2)]\n\n"}
{"sequence_id": "A254449", "text": "a(n) is the smallest nonnegative integer such that a(n)! contains a string of exactly n consecutive 4's.", "sequence": "0,4,21,63,117,375,1325,1253,5741,30455,83393,68094,565882,2666148,1514639", "code": "\ndef A254449(n):\n    if n == 0:\n        return 0\n    i, m, s = 1, 1, '4'*n\n    s2 = s+'4'\n    while True:\n        m *= i\n        sn = str(m)\n        if s in sn and s2 not in sn:\n            return i\n        i += 1 \n"}
{"sequence_id": "A254625", "text": "Integers n such that core(n), core(n+1), core(n+2) are smaller than n^(1/3) where core(n) is A007913(n), the squarefree part of n.", "sequence": "48,629693,8388223,9841094,1728322595,19503452898,27558254932,2399283556900", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import factorint\ndef A007913(n):\n....return reduce(mul,[1]+[p for p,e in factorint(n).items() if e % 2])\nA254625_list, n, c0, c1, c2 = [], 1, 1, 8, 27\nfor _ in range(10**6):\n....if max(c0,c1,c2) < n:\n........A254625_list.append(n)\n....n += 1\n....c0, c1, c2 = c1, c2, A007913(n+2)**3 \n"}
{"sequence_id": "A254648", "text": "Numbers n whose square representation in base 10 can be split into three parts whose sum is n.", "sequence": "36,82,91,235,379,414,675,756,792,909,918,964,991,1296,1702,1782,3366,3646,3682,4132,4906,5149,6832,7543,8416,8767,8856,9208,9325,9586,9621,9765,9901,9945,9955,9991,12222,12727,17271,22231", "code": "\nfrom itertools import combinations\nA254648_list, n, n2 = [], 10, 100\nwhile n < 10**4:\n    m = str(n2)\n    for a in combinations(range(1,len(m)),2):\n        x, y, z = int(m[:a[0]]), int(m[a[0]:a[1]]), int(m[a[1]:])\n        if y != 0 and z != 0 and x+y+z == n:\n            A254648_list.append(n)\n            break\n    n += 1\n    n2 += 2*n-1 \n"}
{"sequence_id": "A254671", "text": "Numbers that can be represented as x * y + x + y, where x >= y > 1.", "sequence": "8,11,14,15,17,19,20,23,24,26,27,29,31,32,34,35,38,39,41,43,44,47,48,49,50,51,53,54,55,56,59,62,63,64,65,67,68,69,71,74,75,76,77,79,80,83,84,86,87,89,90,91,92,94,95,97,98,99,101,103,104,107,109,110,111,113", "code": "\ndef aupto(limit):\n    cands = range(2, limit//3+1)\n    nums = [x*y+x+y for i, y in enumerate(cands) for x in cands[i:]]\n    return sorted(set(k for k in nums if k <= limit))\nprint(aupto(113)) \n"}
{"sequence_id": "A254687", "text": "Number of decompositions of 2n into sums of two primes p1 < p2 such that p2-p1-1 is also a prime.", "sequence": "0,0,0,0,1,0,1,1,2,2,1,1,2,2,2,1,2,0,1,2,3,3,1,2,3,3,3,2,2,1,1,4,2,2,3,2,4,3,3,3,2,3,4,3,4,2,4,2,2,3,2,5,3,2,4,5,5,5,4,4,1,4,5,2,4,2,4,3,3,4,4,2,5,3,5,1,5,3,0,6,4,5,4,2,6,4,5", "code": "\nfrom sympy import isprime, nextprime\ndef A254687(n):\n....y, x, n2 = 0, 2, 2*n\n....while x < n:\n........if isprime(n2-x) and isprime(n2-2*x-1):\n............y += 1\n........x = nextprime(x)\n....return y \n"}
{"sequence_id": "A254688", "text": "Number of decompositions of 2n into sums of two primes p1 < p2 such that p2-p1+1 is also a prime.", "sequence": "0,0,0,1,1,1,0,2,1,1,2,2,1,2,2,1,2,3,0,2,2,2,3,1,2,3,2,2,1,3,0,4,3,1,2,2,2,5,3,3,2,4,2,3,4,2,2,4,2,5,2,3,5,1,2,5,4,4,3,5,2,4,4,2,4,3,3,4,1,4,3,6,4,3,3,3,5,3,2,5,5,4,2,4,3,4,5", "code": "\nfrom sympy import isprime, nextprime\ndef A254688(n):\n....y, x, n2 = 0, 2, 2*n\n....while x < n:\n........if isprime(n2-x) and isprime(n2-2*x+1):\n............y += 1\n........x = nextprime(x)\n....return y \n"}
{"sequence_id": "A254732", "text": "a(n) is the least k > n such that n divides k^2.", "sequence": "2,4,6,6,10,12,14,12,12,20,22,18,26,28,30,20,34,24,38,30,42,44,46,36,30,52,36,42,58,60,62,40,66,68,70,42,74,76,78,60,82,84,86,66,60,92,94,60,56,60,102,78,106,72,110,84,114,116,118,90,122,124,84,72", "code": "\ndef A254732(n):\n....k = n + 1\n....while pow(k,2,n):\n........k += 1\n....return k \n"}
{"sequence_id": "A254734", "text": "a(n) is the least k > n such that n divides k^4.", "sequence": "2,4,6,6,10,12,14,10,12,20,22,18,26,28,30,18,34,24,38,30,42,44,46,30,30,52,30,42,58,60,62,36,66,68,70,42,74,76,78,50,82,84,86,66,60,92,94,54,56,60,102,78,106,60,110,70,114,116,118,90,122,124,84", "code": "\ndef A254734(n):\n....k = n + 1\n....while pow(k,4,n):\n........k += 1\n....return k \n"}
{"sequence_id": "A254746", "text": "a(n) = Catalan(n^2) mod prime(n).", "sequence": "1,2,2,5,8,0,0,11,0,24,0,0,29,0,0,0,0,39,58,0,21,33,9,69,9,0,16,86,0,0,0,0,0,64,139,0,0,0,75,12,4,0,0,119,195,0,193,202,0,0,55,218,0,0,0,0,84,201,0,0,203,275,0,198,159,0,0,0,0,255,13,204,0", "code": "\nfrom sympy import factorint, prime\nA254746_list, c, s, s2 = [1], {}, 2, 4\nfor n in range(2,10**3+1):\n....for p,e in factorint(4*n-2).items():\n........if p in c:\n............c[p] += e\n........else:\n............c[p] = e\n....for p,e in factorint(n+1).items():\n........if c[p] == e:\n............del c[p]\n........else:\n............c[p] -= e\n....if n == s2:\n........d, ps = 1, prime(s)\n........for p,e in c.items():\n............d = (d*pow(p,e,ps)) % ps\n........A254746_list.append(d)\n........s2 += 2*s+1\n........s += 1 \n"}
{"sequence_id": "A254756", "text": "Numbers such that all their proper hexadecimal prefixes and suffixes represent primes.", "sequence": "34,35,37,39,43,45,50,51,53,55,59,61,82,83,85,87,91,93,114,115,117,119,123,125,178,179,181,183,187,189,210,211,213,215,219,221,595,661,663,669,691,693,763,851,947,949,979,1333,1339,1341,1429", "code": "\nfrom gmpy2 import is_prime\nA254756_list = []\nfor n in range(16,10**6):\n....s = format(n,'x')\n....for i in range(1,len(s)):\n........if not (is_prime(int(s[i:],16)) and is_prime(int(s[:-i],16))):\n............break\n....else:\n........A254756_list.append(n) \n"}
{"sequence_id": "A254868", "text": "Recam\u00e1n [-, +, *]-sequence with seed 6 and step 4.", "sequence": "6,2,8,4,16,12,48,44,40,36,32,28,24,20,80,76,72,68,64,60,56,52,208,204,200,196,192,188,184,180,176,172,168,164,160,156,152,148,144,140,136,132,128,124,120,116,112,108,104,100,96,92,88,84,336,332,328,324", "code": "\nfrom sympy import primerange, prime\ndef aupton(nn, seed=6, step=4):\n  alst, step = [seed], step\n  for n in range(1, nn+1, 1):\n    x, y, z = alst[-1] - step, alst[-1] + step, alst[-1] * step\n    if    x > 0 and x not in alst: alst.append(x)\n    elif  y > 0 and y not in alst: alst.append(y)\n    elif  z > 0 and z not in alst: alst.append(z)\n    else: break\n  return alst\nprint(aupton(57)) \n"}
{"sequence_id": "A254979", "text": "Decimal expansion of the mean Euclidean distance from a point in a unit 4D cube to the faces (named B_4(1) in Bailey's paper).", "sequence": "1,1,2,1,8,9,9,6,1,8,7,1,5,8,6,0,9,7,7,3,5,1,6,1,5,1,7,5,5,6,7,5,4,2,7,0,9,2,0,0,8,0,7,9,5,6,4,3,9,5,4,5,8,3,0,8,3,6,7,9,2,4,6,6,9,1,6,4,0,3,5,4,8,6,0,6,9,1,5,3,4,9,0,2,4,6,7,3,1,4,5,5,7,8,6,3,7,6,4,4,9,7,6,3,4", "code": "\nfrom mpmath import *\nmp.dps=106\nx=3 - 2*sqrt(2)\nTi2x=(j/2)*(polylog(2, -j*x) - polylog(2, j*x))\nC = 2/5 - catalan/10 + (3/10)*Ti2x + log(3) - (7*sqrt(2)/10)*atan(1/sqrt(8))\nprint([int(n) for n in str(C.real).replace('.', '')]) \n"}
{"sequence_id": "A254980", "text": "Decimal expansion of the mean reciprocal Euclidean distance from a point in a unit 4D cube to the faces (named B_4(-1) in Bailey's paper).", "sequence": "9,6,7,4,1,2,0,2,1,2,4,1,1,6,5,8,9,8,6,6,1,8,3,6,4,3,8,1,7,8,1,5,8,3,9,0,1,3,5,9,3,7,0,0,9,2,9,9,9,6,0,7,0,7,2,7,4,8,2,5,7,9,2,6,6,9,5,2,4,8,4,1,9,6,7,2,3,8,4,0,5,6,6,7,2,3,1,0,2,5,3,2,3,4,2,7,7,0,0,6,6,6,6,9", "code": "\nfrom mpmath import *\nmp.dps=105\nx=3 - 2*sqrt(2)\nTi2x=(j/2)*(polylog(2, -j*x) - polylog(2, j*x))\nC = 2*log(3) - (2/3)*catalan + 2*Ti2x - sqrt(8) * atan(1/sqrt(8))\nprint([int(n) for n in list(str(C.real)[2:-1])]) \n"}
{"sequence_id": "A254999", "text": "Numbers n of the form 4*k+2 such that (sigma(n) mod n) divides n, where sigma is given by A000203.", "sequence": "2,18,234,650,1890,8190,14850,61110,64890,92070,157950,162162,206910,258390,365310,383130,558558,702702,711450,743850,822510,916110,1140750,1561950,1862190,2357550,4977126,5782590", "code": "\nfrom sympy import factorint\ndef sigma_mod(n, m): \n    y = 1\n    for p, e in factorint(n).items():\n        y  = (y*(p**(e + 1) - 1)//(p - 1)) % m\n    return y\nA254999_list = [n for n,m in ((4*k+2, sigma_mod(4*k+2,4*k+2)) for k in range(10**6)) if m and not n % m]\n\n"}
{"sequence_id": "A255018", "text": "Smallest number that is the sum of 3 nonnegative cubes in exactly n ways.", "sequence": "4,0,216,5104,13896,161568,1259712,2016496,2562624,14926248,58995000,34012224,150547032,471960000,119095488,1259712000,952763904,5159780352,3974344704,2176782336,10077696000,2985984000,36330467328,30723115968,23887872000,17414258688,72825163776,75686967000", "code": "\nTOP = 6000000\na = [0]*TOP\nfor b in range(TOP):\n  b3 = b**3\n  if b3*3>=TOP: break\n  for c in range(b,TOP):\n    c3 = b3 + c**3\n    if c3>=TOP: break\n    for d in range(c,TOP):\n      res = c3 + d**3\n      if res>=TOP: break\n      a[res] += 1\nm = max(a)\nr = [-1] * (m+1)\nfor i in range(TOP):\n    if r[a[i]]==-1:  r[a[i]]=i\nprint(r)\n"}
{"sequence_id": "A255073", "text": "Primes that remain prime after each digit is replaced by the power of its position.", "sequence": "2,3,5,7,11,13,17,19,23,37,43,47,67,71,79,83,101,103,107,109,113,131,137,139,167,173,179,191,211,241,263,269,281,307,311,313,331,337,353,359,367,397,431,479,491,503,521,577,593,601,613,617,659,673", "code": "\nimport sympy\ndef powdig(m):\n....l=len(str(m))\n....return(int(''.join([str(int(list(i)[1])**(l-list(i)[0])) for i in enumerate(list(str(m)))])))\nn=2\nwhile n>0:\n....t=powdig(n)\n....if sympy.isprime(t)==True:\n........print(n)\n....n=sympy.nextprime(n)\n"}
{"sequence_id": "A255132", "text": "Number of divisors of odd Catalan numbers (A038003).", "sequence": "1,1,2,8,96,2048,3145728,206158430208,27670116110564327424,498460498419343452338927647605129216,24991100464315816765228594460089760794425300959309994174606999552,336610107623104398583024455855523763248864803845734108839073897168302318415095310965480469919661369165797247714066432", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import factorint\nA255132_list, c, s = [1, 1], {}, 3\nfor n in range(2,2**15):\n....for p,e in factorint(4*n-2).items():\n........if p in c:\n............c[p] += e\n........else:\n............c[p] = e\n....for p,e in factorint(n+1).items():\n........if c[p] == e:\n............del c[p]\n........else:\n............c[p] -= e\n....if n == s:\n........c2 = reduce(mul,[e+1 for e in c.values()])\n........A255132_list.append(c2)\n........s = 2*s+1\n"}
{"sequence_id": "A255133", "text": "Number of unitary divisors of odd Catalan numbers (A038003).", "sequence": "1,1,2,8,64,2048,1048576,68719476736,18446744073709551616,166153499473114484112975882535043072,822752278660603021077484591278675252491367932816789931674304512,4925250774549309901534880012517951725634967408808180833493536675530715221437151326426783281860614455100828498788352", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import factorint\nA255133_list, c, s = [1, 1], {}, 3\nfor n in range(2,2**17):\n....for p,e in factorint(4*n-2).items():\n........if p in c:\n............c[p] += e\n........else:\n............c[p] = e\n....for p,e in factorint(n+1).items():\n........if c[p] == e:\n............del c[p]\n........else:\n............c[p] -= e\n....if n == s:\n........c2 = 2**len(c)\n........A255133_list.append(c2)\n........s = 2*s+1\n"}
{"sequence_id": "A255192", "text": "Triangle of number of connected subgraphs of K(n,n) with m edges.", "sequence": "1,4,1,81,78,36,9,1,4096,8424,9552,7464,4272,1812,560,120,16,1,390625,1359640,2696200,3880300,4394600,4059000,3111140,1994150,1070150,478800,176900,53120,12650,2300,300,25,1,60466176,314452800,939988800,2075760000", "code": "\na(n,m) = f(1,n,n,m) where\ndef f(x,a,b,k):\n...if b == k == 0: return 1\n...if b == 0 or k == 0: return 0\n...if x == a:\n......return sum(binom(a,n)*f(x,x,b-1,k-n) for n in range(1,a+1))\n...return sum(binom(b,n)*f(x,x,n,k2)*f(n,b,a-x,k-k2) for n in range(1,b+1) for k2 in range(0,k+1))\n"}
{"sequence_id": "A255194", "text": "Numbers n such that prime(n) + {1,2,3,4,5,6} are all products of three primes.", "sequence": "369,8788,16456,20522,23335,53601,77047,97930,100123,120745,127847,139723,152996,217177,230179,250248,264618,304656,325478,418592,452277,495518,523028,574110,600888,609574,615102,619844,638584,716516,722010,749479,789769,810082,858158,901322,928090,940735,999329", "code": "\nfrom sympy import factorint, nextprime\nA255194_list, p, p2 = [], 2, 3\nfor n in range(1,10**6):\n....if p2 - p > 6:\n........for i in range(1,7):\n............fs = factorint(p+i)\n............if len(fs) > 3 or sum(list(fs.values())) != 3:\n................break\n........else:\n............A255194_list.append(n)\n....p, p2 = p2, nextprime(p2) \n"}
{"sequence_id": "A255244", "text": "Numbers that divide the average of the sum of the squares of their divisors.", "sequence": "1,65,175,1105,5425,20737,32045,70525,103685,171275,200725,207553,352529,372775,1037765,1198925,1264957,1347905,1762645,1824877,2609425,2698189,3628975,3928475,4966975,6324785,6337175,8646625,8813225,9124385,10223341,12774139,13490945", "code": "\nfrom __future__ import division\nfrom sympy import factorint\nA255244_list = []\nfor n in range(1,10**9):\n....s0 = s2 = 1\n....for p,e in factorint(n).items():\n........s0 *= e+1\n........s2 *= (p**(2*(e+1))-1)//(p**2-1)\n....q, r = divmod(s2,s0)\n....if not (r or q % n):\n........A255244_list.append(n) \n"}
{"sequence_id": "A255245", "text": "Numbers that divide the average of the squares of their aliquot parts.", "sequence": "10,65,140,420,2100,2210,20737,32045,200725,207370,1204350,1347905,1762645,16502850,31427800,37741340,107671200,130643100,200728169,239719720,357491225,417225900,430085380,766750575,1088692500,1132409168,1328204850,1788379460", "code": "\nfrom __future__ import division\nfrom sympy import factorint\nA255245_list = []\nfor n in range(2,10**9):\n....s0 = s2 = 1\n....for p,e in factorint(n).items():\n........s0 *= e+1\n........s2 *= (p**(2*(e+1))-1)//(p**2-1)\n....q, r = divmod(s2-n**2,s0-1)\n....if not (r or q % n):\n........A255245_list.append(n) \n"}
{"sequence_id": "A255265", "text": "Numbers representable as x*y*(x+y), where x>=y>1.", "sequence": "16,30,48,54,70,84,96,120,126,128,160,162,180,198,210,240,250,264,286,308,324,330,336,384,390,420,432,448,462,468,510,520,540,546,560,576,624,630,646,660,672,686,714,720,750,768,798,810,840,880,884,912,960,966,1008", "code": "\nTOP = 10000\na = [0]*TOP\nfor y in range(2,TOP//2):\nfor x in range(y,TOP//2):\n    k = x*y*(x+y)\n    if k>=TOP: break\n    a[k]+=1\n[n for n in range(TOP) if a[n]>0]\n"}
{"sequence_id": "A255266", "text": "Numbers representable in more than one way as x*y*(x+y), where x>=y>1.", "sequence": "240,390,810,880,1008,1020,1680,1920,2100,2310,2970,3120,3360,3696,3750,4320,4914,5460,5670,6090,6270,6480,6630,7040,7380,7440,7770,8064,8160,8190,8448,8580,8976,9240,9520,10290,10530,10640,11340,11856,12474,13440,13776,14040", "code": "\nTOP = 100000\na = [0]*TOP\nfor y in range(2, TOP//2):\n  for x in range(y, TOP//2):\n    k = x*y*(x+y)\n    if k>=TOP: break\n    a[k]+=1\nprint([n for n in range(TOP) if a[n]>1])\n"}
{"sequence_id": "A255267", "text": "Numbers representable as both x*y*(x+y) and b*c+b+c, where b>=c>1 and x>=y>1.", "sequence": "48,54,84,120,128,160,264,286,308,324,384,390,468,510,560,624,686,714,720,798,840,884,912,960,1024,1056,1134,1140,1190,1224,1254,1280,1330,1350,1386,1440,1456,1500,1512,1584,1650,1672,1680,1710,1748,1794,1798,1820,1890", "code": "\nTOP = 100000\na = [0]*TOP\nb = [0]*TOP\nfor y in range(2,TOP//2):\n  for x in range(y,TOP//2):\n    k = x*y*(x+y)\n    if k>=TOP: break\n    a[k]+=1\nfor y in range(2,TOP//2):\n  for x in range(y,TOP//2):\n    k = x*y+(x+y)\n    if k>=TOP: break\n    b[k]+=1\nprint([n for n in range(TOP) if a[n]>0 and b[n]>0])\n"}
{"sequence_id": "A255343", "text": "Numbers n such that there are exactly three 1's in their factorial base representation (A007623).", "sequence": "9,27,31,32,35,39,45,57,81,105,123,127,128,131,135,141,145,146,149,150,154,157,158,161,163,164,167,171,175,176,179,183,189,195,199,200,203,207,213,219,223,224,227,231,237,249,267,271,272,275,279,285,297,321,345,369,387,391,392,395,399,405,417,441", "code": "\ndef fbr(n, p=2): \n    return n if n<p else fbr(n//p, p+1)*10 + n%p\ndef ok(n): return str(fbr(n)).count('1') == 3\nprint(list(filter(ok, range(442)))) \n"}
{"sequence_id": "A255361", "text": "Number of ways n can be represented as x*y+x+y where x>=y>1.", "sequence": "0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,1,0,0,2,1,0,1,1,0,2,0,1,1,0,1,3,0,0,1,2,0,2,0,1,2,0,0,3,1,1,1,1,0,2,1,2,1,0,0,4,0,0,2,2,1,2,0,1,1,2,0,4,0,0,2,1,1,2,0,3,2,0,0,4,1,0,1,2,0,4,1,1,1,0,1,4,0,1,2,3,0,2,0,2,3,0", "code": "\nTOP = 1000\na = [0]*TOP\nfor y in range(2, TOP//2):\n    for x in range(y, TOP//2):\n        k = x*y + x + y\n        if k>=TOP: break\n        a[k]+=1\nprint(a)\n"}
{"sequence_id": "A255362", "text": "Numbers n such that neither n nor n+1 is representable as x*y+x+y, where x>=y>1.", "sequence": "0,1,2,3,4,5,6,9,12,21,36,45,57,60,72,81,105,156,165,177,192,225,261,276,312,345,357,381,396,420,456,465,477,501,540,561,585,612,660,672,717,732,756,837,861,876,885,981,996,1017,1092,1152,1185,1200,1212,1236,1281", "code": "\nTOP = 10000\na = [0]*TOP\nfor y in range(2, TOP//2):\n  for x in range(y, TOP//2):\n    k = x*y + x + y\n    if k>=TOP: break\n    a[k]+=1\nprint([n for n in range(TOP-1) if a[n]==0 and a[n+1]==0])\n"}
{"sequence_id": "A255400", "text": "a(n) is the smallest nonnegative integer such that a(n)! contains a string of exactly n consecutive 0's.", "sequence": "0,5,10,15,20,264,25,30,35,40,45,101805,50,55,60,65,70", "code": "\nimport re\ndef A255400(n):\n    f, i, s = 1, 0, re.compile('[0-9]*[1-9]0{'+str(n)+'}[1-9][0-9]*')\n    while s.match(str(f)+'1') is None:\n        i += 1\n        f *= i\n    return i \n"}
{"sequence_id": "A255411", "text": "Shift factorial base representation of n one digit left (with 0 added to right), increment all nonzero digits by one, then convert back to decimal; Numbers with no digit 1 in their factorial base representation.", "sequence": "0,4,12,16,18,22,48,52,60,64,66,70,72,76,84,88,90,94,96,100,108,112,114,118,240,244,252,256,258,262,288,292,300,304,306,310,312,316,324,328,330,334,336,340,348,352,354,358,360,364,372,376,378,382,408,412,420,424,426,430,432,436,444", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623((n//p), p+1)*10 + n%p\ndef a(n):\n    x=(str(a007623(n)) + '0')\n    y=\"\".join(str(int(i) + 1) if int(i)>0 else '0' for i in x)[::-1]\n    return 0 if n==0 else sum(int(y[i])*f(i + 1) for i in range(len(y)))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A255484", "text": "a(n) = Product_{k=0..n} (prime(k+1)*(binomial(n,k) mod 2).", "sequence": "2,6,0,210,0,0,0,9699690,0,0,0,0,0,0,0,32589158477190044730,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,525896479052627740771371797072411912900610967452630,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import prime\ndef A255484(n):\n    return reduce(mul,(0 if ~n & k else prime(k+1) for k in range(n+1))) \n"}
{"sequence_id": "A255500", "text": "a(n) = (p^9 + 5*p^8 + 4*p^7 - p^6 - 5*p^5 + 2*p^4)/6 where p is the n-th prime.", "sequence": "352,9909,698125,12045817,584190541,2487920149,25846158097,68520305701,367691205289,2846113596901,5135516500321,24650159312557,61346708983561,93685639700269,206700247118737,602622774810109,1567842813615901,2110866318916741,4876836410298997", "code": "\nfrom __future__ import division\nfrom sympy import prime\nA255500_list = []\nfor n in range(1,10**2):\n....p = prime(n)\n....A255500_list.append(p**4*(p*(p*(p*(p*(p + 5) + 4) - 1) - 5) + 2)//6)\n\n"}
{"sequence_id": "A255501", "text": "a(n) = (n^9 + 5*n^8 + 4*n^7 - n^6 - 5*n^5 + 2*n^4)/6.", "sequence": "0,1,352,9909,107776,698125,3252096,12045817,37679104,103495401,256420000,584190541,1241471232,2487920149,4741917376,8654360625,15207694336,25846158097,42644120544,68520305701,107506720000,165082149981,248581222912,367691205289", "code": "\n\nfrom itertools import accumulate\nA255501_list, m  = [0], [60480, -208320, 273840, -168120, 45420, -2712, -648, 62, -1, 0]\nfor _ in range(10**2):\n....m = list(accumulate(m))\nA255501_list.append(m[-1]) \n"}
{"sequence_id": "A255535", "text": "Numbers representable as both b^c + b + c and x^y + x - y, where b, c, x, y are integers greater than 1.", "sequence": "14,88,65548,33554459,387420510,1099511627800,35184372088855,3656158440063002,459986536544739960976836", "code": "\nTOP = 100000000\na = [0]*TOP\nfor y in range(2,TOP//2):\n  if 2**y+2+y>=TOP: break\n  for x in range(2,TOP//2):\n    k = x**y+x+y\n    if k>=TOP: break\n    a[k]=1\nfor y in range(2,TOP//2):\n  if 2**y+2-y>=TOP: break\n  for x in range(2,TOP//2):\n    k = x**y+x-y\n    if k>=TOP: break\n    if k>=0: a[k]|=2\nprint([n for n in range(TOP) if a[n]==3])\n"}
{"sequence_id": "A255562", "text": "A reversed prime Fibonacci sequence: a(n+2) is the smallest odd prime such that a(n) is the smallest odd prime divisor of a(n+1)+a(n+2).", "sequence": "3,5,7,3,11,7,37,19,277,331,223,439,7,406507,67,330515394367,967,10576492618777,116041,223724392248491824062507397,3691561,100105207373914057144918297314160710207525630111509317,423951181", "code": "\nimport math\ndef sieve(n):\n    r = int(math.floor(math.sqrt(n)))\n    composites = [j for i in range(2,r+1) for j in range(2*i, n, i)]\n    primes = set(range(2,n)).difference(set(composites))\n    return sorted(primes)\nPrimes = sieve(1000000)\nOdd_primes = Primes[1:]\ndef find_smallest_odd_div(n):\n    for p in Odd_primes:\n        if n % p == 0:\n            return p\ndef next_term(a,b):\n    for p in Odd_primes:\n        if (p + b) % a == 0:\n            if find_smallest_odd_div(p+b) == a:\n                return p\ndef compute_reversed_seq(a,b):\n    seq = [a,b]\n    while seq[-1] != None:\n        seq.append(next_term(seq[-2],seq[-1]))\n    return seq[:len(seq)-1]\nprint(compute_reversed_seq(3,5))\n"}
{"sequence_id": "A255589", "text": "Convert n to base 4, move the least significant digit to the most significant one and convert back to base 10.", "sequence": "0,1,2,3,1,5,9,13,2,6,10,14,3,7,11,15,4,20,36,52,5,21,37,53,6,22,38,54,7,23,39,55,8,24,40,56,9,25,41,57,10,26,42,58,11,27,43,59,12,28,44,60,13,29,45,61,14,30,46,62,15,31,47,63,16,80,144,208,17,81", "code": "\ndef A255589(n):\n....x=str(A007090(n))\n....return int(x[-1]+x[:-1],4) \n"}
{"sequence_id": "A255590", "text": "Convert n to base 5, move the least significant digit to the most significant one and convert back to base 10.", "sequence": "0,1,2,3,4,1,6,11,16,21,2,7,12,17,22,3,8,13,18,23,4,9,14,19,24,5,30,55,80,105,6,31,56,81,106,7,32,57,82,107,8,33,58,83,108,9,34,59,84,109,10,35,60,85,110,11,36,61,86,111,12,37,62,87,112,13,38,63,88", "code": "\ndef A255590(n):\n....x=str(A007091(n))\n....return int(x[-1]+x[:-1], 5) \n"}
{"sequence_id": "A255591", "text": "Convert n to base 6, move least significant digit to most significant digit and convert back to base 10.", "sequence": "0,1,2,3,4,5,1,7,13,19,25,31,2,8,14,20,26,32,3,9,15,21,27,33,4,10,16,22,28,34,5,11,17,23,29,35,6,42,78,114,150,186,7,43,79,115,151,187,8,44,80,116,152,188,9,45,81,117,153,189,10,46,82,118,154,190,11", "code": "\ndef A255591(n):\n....x=A007092(n)\n....return int(x[-1]+x[:-1],6) \n"}
{"sequence_id": "A255669", "text": "Primes p such that p divides the concatenation of the next two primes.", "sequence": "3,7,61,167", "code": "\nfrom sympy import nextprime\nA255669_list, p1, p2, l = [], 2, 3, 10\nfor n in range(10**8):\n....p3 = nextprime(p2)\n....if p3 >= l: \n........l *= 10\n....if not ((p2 % p1)*l + p3) % p1:\n........A255669_list.append(p1)\n....p1, p2 = p2, p3 \n"}
{"sequence_id": "A255689", "text": "Convert n to base 4, move the most significant digit to the least significant one and convert back to base 10.", "sequence": "0,1,2,3,1,5,9,13,2,6,10,14,3,7,11,15,1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,2,6,10,14,18,22,26,30,34,38,42,46,50,54,58,62,3,7,11,15,19,23,27,31,35,39,43,47,51,55,59,63,1,5,9,13,17,21,25", "code": "\ndef A255689(n):\n....x=A007090(n)\n....return int (x[1:]+x[0],4) \n"}
{"sequence_id": "A255911", "text": "a(n) is the smallest natural number such that A002182(n) = a(n) * A002182(n - i) for some i > 0, where A002182 is the sequence of highly composite numbers.", "sequence": "2,2,3,2,2,3,2,5,2,3,2,2,2,7,7,2,2,2,3,2,2,2,5,11,3,2,2,3,2,2,2,5,2,3,2,2,13,13,2,2,2,5,2,3,2,2,3,2,2,2,3,17,2,17,2,3,2,2,3,2,2,2,3,19,2,2,2,3,2,19,2,5,2,2,2,3,2,2,2,2,7,23,7", "code": "\nfrom sympy import divisor_count\nA002182_list, A255911_list, count, m = [], [], 0, 0\nfor i in range(1,10**6):\n....d = divisor_count(i)\n....if d > m:\n........m = d\n........A002182_list.append(i)\n........for j in range(count-1,-1,-1):\n............q, r = divmod(i,A002182_list[j])\n............if not r:\n................A255911_list.append(q)\n................break\n........count += 1 \n"}
{"sequence_id": "A255963", "text": "Number of empty sets in the n-th power set of the empty set.", "sequence": "1,1,2,5,41,1343489", "code": "\ndef empty_sets(n):\n.    if n==0:\n..        return 1\n.    if n==1:\n..        return 1\n.    else:\n..        t = 2\n..        for i in range(n-2):\n...            t = 2**t\n..        return ((empty_sets(n-1)*t)/2 + 1)\n\n"}
{"sequence_id": "A256048", "text": "Smallest palindromic prime by adding at least one digit to both the left and right of n", "sequence": "101,313,727,131,11411,151,10601,373,181,191,30103,1114111,1120211,11311,11411,31513,1160611,1117111,18181,71917,30203,1120211,72227,32323,12421,1250521,36263,12721,12821,39293,10301,11311,32323,13331,14341,33533,16361,77377", "code": "\nfrom __future__ import division\nfrom sympy import isprime\ndef palgenrange2(m,l): \n....if m == 1:\n........yield 0\n....for x in range(m//2+1,l+1):\n........n = 10**(x-1)\n........for y in range(n,n*10):\n............s = str(y)\n............yield int(s+s[-2::-1])\ndef A256048(n):\n....sn = str(n)\n....for p in palgenrange2(len(sn)+2,len(sn)+20):\n........if sn in str(p)[1:-1] and isprime(p):\n............break\n....else:\n........return 'search limit reached'\n....return p \n"}
{"sequence_id": "A256072", "text": "Primes that cannot be represented as x*y + x + y, where x >= y > 1.", "sequence": "2,3,5,7,13,37,61,73,157,193,277,313,397,421,457,541,613,661,673,733,757,877,997,1093,1153,1201,1213,1237,1321,1381,1453,1621,1657,1753,1873,1933,1993,2017,2137,2341,2473,2557,2593,2797,2857,2917,3061,3217,3253,3313", "code": "\nimport sympy\nfrom sympy import isprime\nTOP = 10000\na = [0]*TOP\nfor y in range(2, TOP//2):\n  for x in range(y, TOP//2):\n    k = x*y + x + y\n    if k>=TOP: break\n    a[k]+=1\nprint([n for n in range(TOP) if a[n]==0 and isprime(n)])\n"}
{"sequence_id": "A256073", "text": "Numbers n representable as x*y + x + y, where x >= y > 1, such that all x's and y's in all representation(s) of n are primes.", "sequence": "8,11,15,17,23,31", "code": "\nimport sympy\nfrom sympy import isprime\nTOP = 10000\na = [0]*TOP\nno= [0]*TOP\nfor y in range(2, TOP//2):\n    for x in range(y, TOP//2):\n        k = x*y + x + y\n        if k>=TOP: break\n        if no[k]==0:\n            a[k]=1\n            if not (isprime(x) and isprime(y)): no[k]=1\nprint([n for n in range(TOP) if a[n]>0 and no[n]==0])\n"}
{"sequence_id": "A256112", "text": "Pandigitals in some base b (A061845) with an extra property: each number formed by the first i digits is divisible by i (digits in the pandigital base b) for 1 <= i <= b-1.", "sequence": "2,19,75,99,108,135,228,2102,8525,10535,13685,13710,26075,31835,44790,203367,247215,477543,518703,576495,620343,743823,3850399,6996535,6996871,6996920,7375543,8947631,11128712,12306056,78473956,89789620,156414388,222029284,306600196", "code": "\ndef dgen(n,b):\n    if n == 1:\n        t = list(range(b))\n        for i in range(1,b):\n            u = list(t)\n            u.remove(i)\n            yield i, u\n    else:\n        for d, v in dgen(n-1,b):\n            for g in v:\n                k = d*b+g\n                if not k % n:\n                    u = list(v)\n                    u.remove(g)\n                    yield k, u\nA256112_list = lambda n: [a*k+b[0] for k in range(2, n) for a, b in dgen(k-1, k)]\nprint(A256112_list(10))\n"}
{"sequence_id": "A256114", "text": "Numbers n such that digit_product(n^2) = (digit_product(n))^2 and n mod 10 > 0.", "sequence": "1,2,3,101,102,103,104,105,201,202,203,205,301,302,303,305,401,402,403,405,501,502,503,504,505,506,507,508,509,601,602,603,605,609,661,701,702,703,705,708,709,801,802,803,805,901,902,903,905,906,983", "code": "\ndef product_digits(n):\n...results = 1\n...while n > 0:\n......remainder = n % 10\n......results *= remainder\n......n = (n-remainder)/10\n...return results\npos = 0\nfor a in range(1,1000000):\n...if product_digits(a*a) == (product_digits(a))*(product_digits(a)) and (a%10 > 0):\n......pos += 1\n......print(pos, a)\n"}
{"sequence_id": "A256115", "text": "Zeroless numbers n whose digit product squared is equal to the digit product of n^2.", "sequence": "1,2,3,661,983,2631,2893,9254,9628,9642,11892,12385,12893,13836,14642,14661,16472,18615,27519,29474,35383,36213,36914,38691,43386,46215,49231,49342,56176,72576,75384,76256,83631,87291,92843,94482,99146,99482,99842,113865", "code": "\ndef product_digits(n):\n    results = 1\n    while n > 0:\n        remainder = n % 10\n        results *= remainder\n        n = (n-remainder)/10\n    return results\nL = []\nfor a in range(1, 100000):\n    if product_digits(a*a) == (product_digits(a))*(product_digits(a)) and (product_digits(a) > 0):\n        L.append(a)\nprint(L)\n"}
{"sequence_id": "A256143", "text": "Fibonacci Mutant Bunnies. Start at 1,1,1 and, at each step, either add the last three elements or take the difference of the last two. a(n) is equal to the minimum number of steps to get to n.", "sequence": "1,0,2,1,4,2,3,6,5,3,4,4,5,7,6,6,6,4,5,5,6,8,6,7,7,8,7,7,7,6,8,5,8,7,6,8,6,8,7,10,8,10,9,9,8,9,9,10,8,9,8,8,9,7,9,9,7,6,8,7,9,8,7,11,9,8,7,9,8,10,10,11,8,10,10,9,9,10,10,11,10,10", "code": "\ndef aupto(limit):\n  start, goals = (1, 1, 1), set(range(limit+1)) - {1}\n  steps, paths = {b: 0 for b in start}, {(0,) + start}\n  iters = 1\n  while len(goals) > 0:\n    newpaths = []\n    while len(paths) > 0:\n      p = paths.pop() \n      sum3, diff2 = sum(p[-3:]), abs(p[-2]-p[-1])\n      for newb in [sum3, diff2]:\n        if newb in goals:\n          steps[newb] = iters\n          goals.discard(newb)\n        newpaths.append( p[1:] + (newb, ) )\n    paths = newpaths\n    iters += 1\n  return [steps[b] for b in range(limit+1)]\nprint(aupto(81)) \n"}
{"sequence_id": "A256175", "text": "Babylonian Wurm - The change of direction in successive segments is recorded as 1 (clockwise) or -1 (counterclockwise).", "sequence": "1,1,1,1,1,1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,1,1,1,1,-1,1,1,1,1,1,-1,1,1,1,1,-1,-1,1,-1,1,-1,1,1,1,1,1,1,1,1,1,1,-1,1,-1,1,-1,1,1,1,-1,1,-1,-1,-1,1,1,1", "code": " See Rayman link.\n"}
{"sequence_id": "A256184", "text": "First of two variations by Per N\u00f8rg\u00e5rd of his \"infinity sequence\", cf. A004718: u(0) = 0; u(3*n) = -u(n); u(3*n+1) = u(n) - 2; u(3*n+2) = u(n) - 1.", "sequence": "0,-2,-1,2,-4,-3,1,-3,-2,-2,0,1,4,-6,-5,3,-5,-4,-1,-1,0,3,-5,-4,2,-4,-3,2,-4,-3,0,-2,-1,-1,-1,0,-4,2,3,6,-8,-7,5,-7,-6,-3,1,2,5,-7,-6,4,-6,-5,1,-3,-2,1,-3,-2,0,-2,-1,-3,1,2,5,-7,-6,4,-6,-5", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef a(n): return 0 if n == 0 else (a(n//3) - (3-n%3)) if n%3 else -a(n//3)\nprint([a(n) for n in range(72)]) \n"}
{"sequence_id": "A256229", "text": "Powering the decimal digits of n (right-associative) with 0^0 = 1 by convention.", "sequence": "1,2,3,4,5,6,7,8,9,1,1,1,1,1,1,1,1,1,1,1,2,4,8,16,32,64,128,256,512,1,3,9,27,81,243,729,2187,6561,19683,1,4,16,64,256,1024,4096,16384,65536,262144,1,5,25,125,625,3125,15625,78125,390625,1953125,1,6,36,216,1296", "code": "\ndef A256229(n):\n....y = 1\n....for d in reversed(str(n)):\n........y = int(d)**y\n....return y \n"}
{"sequence_id": "A256230", "text": "Numbers n such that neither n nor 2*n is representable as x*y+x+y, where x>=y>1.", "sequence": "0,1,2,3,5,6,9,18,21,30,33,36,78,81,96,105,138,141,156,165,198,210,228,261,270,273,306,330,336,345,366,378,393,438,453,498,525,546,561,576,585,600,606,618,660,690,726,765,810,828,861,876,933,936,966,996,1005,1008", "code": "\nTOP = 2200\na = [0]*TOP\nfor y in range(2, TOP//2):\n  for x in range(y, TOP//2):\n    k = x*y + x + y\n    if k>=TOP: break\n    a[k]=1\nprint([n for n in range(TOP//2) if a[n]==0 and a[2*n]==0])\n"}
{"sequence_id": "A256241", "text": "Numbers n whose Euler's totient function phi(n), divided by two, plus one, p = (phi(n) / 2) + 1, is a divisor of n.", "sequence": "4,6,12,15,20,21,28,30,33,39,42,44,51,52,57,66,68,69,76,78,87,92,93,102,111,114,116,123,124,129,138,141,148,159,164,172,174,177,183,186,188,201,212,213,219,222,236,237,244,246,249,258,267,268,282,284,291,292,303,309,316,318,321,327,332,339,354,356,366", "code": "\nfrom sympy import totient\n[n for n in range(1, 10**5) if n%((totient(n)/2)+1)==0]\n"}
{"sequence_id": "A256278", "text": "a(0)=1, a(1)=2, a(n)=31a(n-1)-29a(n-2).", "sequence": "1,2,33,965,28958,869713,26121321,784539274,23563199185,707707535789,21255600833094,638400107288033,19173990901769297,575880114843495250,17296237823997043137,519482849213446974997,15602377428720941973934,468608697663159238917041", "code": "\nprint(1,2,end=', ')\nan = [1,2]\nfor n in range(2,26):\n..print(31*an[n-1]-29*an[n-2],end=', ')\n..an.append(31*an[n-1]-29*an[n-2])\n"}
{"sequence_id": "A256340", "text": "Numbers which have only digits 7 and 8 in base 10.", "sequence": "7,8,77,78,87,88,777,778,787,788,877,878,887,888,7777,7778,7787,7788,7877,7878,7887,7888,8777,8778,8787,8788,8877,8878,8887,8888,77777,77778,77787,77788,77877,77878,77887,77888,78777,78778,78787,78788,78877,78878", "code": "\ndef a(n): return int(bin(n+1)[3:].replace('0', '7').replace('1', '8'))\nprint([a(n) for n in range(1, 45)]) \n"}
{"sequence_id": "A256341", "text": "Numbers which have only digits 8 and 9 in base 10.", "sequence": "8,9,88,89,98,99,888,889,898,899,988,989,998,999,8888,8889,8898,8899,8988,8989,8998,8999,9888,9889,9898,9899,9988,9989,9998,9999,88888,88889,88898,88899,88988,88989,88998,88999,89888,89889", "code": "\ndef a(n): return int(bin(n+1)[3:].replace('0', '8').replace('1', '9'))\nprint([a(n) for n in range(1, 45)]) \n"}
{"sequence_id": "A256370", "text": "Positive integers n such that n^4 + (n+1)^4 + (n+2)^4 + (n+3)^4 + (n+4)^4 is prime.", "sequence": "7,25,97,115,145,169,223,247,343,379,385,421,541,577,601,607,673,691,751,847,895,961,997,1111,1129,1237,1267,1303,1327,1459,1489,1555,1615,1639,1657,1663,1741,1765,1771,1807,1819,1831,1873,1903,1927,1945,1951,1963", "code": "\nfrom gmpy2 import is_prime\nA256370_list = [n for n in range(1,10**6) if is_prime(5*n*(n*(n*(n + 8) + 36) + 80) + 354)] \n"}
{"sequence_id": "A256437", "text": "Nonnegative integers i such that i^2 + reverse(i)^2 is a palindrome.", "sequence": "0,1,2,10,11,12,20,21,30,100,101,102,110,111,120,200,201,210,220,300,310,1000,1001,1002,1010,1011,1012,1020,1021,1022,1100,1101,1102,1110,1111,1120,1200,1201,1210,1300,2000,2001,2010,2011,2100,2101,2110,2200,2201", "code": "\nA256437_list = [i for i in range(10**6) if str(i**2 + int(str(i)[::-1])**2) == str(i**2 + int(str(i)[::-1])**2)[::-1]] \n"}
{"sequence_id": "A256450", "text": "Numbers that have at least one 1-digit in their factorial base representation (A007623).", "sequence": "1,2,3,5,6,7,8,9,10,11,13,14,15,17,19,20,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,49,50,51,53,54,55,56,57,58,59,61,62,63,65,67,68,69,71,73,74,75,77,78,79,80,81,82,83,85,86,87,89,91,92,93,95,97,98,99,101", "code": "\ndef A(n, p=2): return n if n<p else A(n//p, p+1)*10 + n%p\nprint([n for n in range(1, 151) if str(A(n)).count(\"1\")>=1]) \n"}
{"sequence_id": "A256480", "text": "Smallest prime obtained by appending n to a nonzero number with identical digits or 0 if no such prime exists.", "sequence": "0,11,0,13,0,0,0,17,0,19,0,211,0,113,0,0,0,317,0,419,0,421,0,223,0,0,0,127,0,229,0,131,0,233,0,0,0,137,0,139,0,241,0,443,0,0,0,347,0,149,0,151,0,353,0,0,0,157,0,359,0,461,0,163,0,0,0,167,0,269", "code": "\nfrom gmpy2 import digits, mpz, is_prime\ndef A256480(n,limit=2000):\n....sn = str(n)\n....if not (n % 2 and n % 5):\n........return 0\n....for i in range(1,limit+1):\n........for j in range(1,10):\n............si = digits(j,10)*i\n............p = mpz(si+sn)\n............if is_prime(p):\n................return int(p)\n....else:\n........return 'search limit reached.'\n"}
{"sequence_id": "A256481", "text": "Smallest prime obtained by appending a number with identical digits to n or 0 if no such prime exists.", "sequence": "2,11,23,31,41,53,61,71,83,97,101,113,127,131,149,151,163,173,181,191,2011,211,223,233,241,251,263,271,281,293,307,311,3299,331,347,353,367,373,383,397,401,419,421,431,443,457,461,479,487,491,503,511111,521,5333", "code": "\nfrom gmpy2 import mpz, digits, is_prime\ndef A256481(n,limit=2000):\n....if n in (6930,50358,56574,72975):\n........return 0\n....if n == 0:\n........return 2\n....sn = str(n)\n....for i in range(1,limit+1):\n........for j in range(1,10,2):\n............si = digits(j,10)*i\n............p = mpz(sn+si)\n............if is_prime(p):\n................return int(p)\n....else:\n........return 'search limit reached.'\n"}
{"sequence_id": "A256516", "text": "Numbers obtained by removing the first a(n) > 0 decimal digits of Pi set new records for closeness to Pi.", "sequence": "1,2,102,249,294,1635,3647,5105,6954,357593,416507,497533,821581,1299504,1457054,39082410,45969853,47607985,86389357,121338042,183331620,191525092,198003319,388055713,427238910,570434345,678096433", "code": "\ndef a256516():\n....best = 1\n....yield 1\n....i = 2\n....while True:\n........if i>=len(pi):\n............return\n........a = pi[i]\n........valid = True\n........o = 1\n........while valid:\n............pi_approx = int(pi[:o])\n............a_approx = abs(int(pi[i:i+o])-pi_approx)\n............b_approx = abs(int(pi[best:best+o])-pi_approx)\n............if abs(b_approx-a_approx)>10:\n................valid = False\n............else:\n................o+=1\n........if a_approx<b_approx:\n............best = i\n............yield i\n........i+=1\n"}
{"sequence_id": "A256532", "text": "Product of n and the sum of remainders of n mod k, for k = 1, 2, 3, ..., n.", "sequence": "0,0,3,4,20,18,56,64,108,130,242,204,364,434,540,576,867,846,1216,1220,1470,1694,2254,2040,2575,2912,3375,3472,4379,4140,5177,5344,6072,6698,7630,7128,8621,9424,10491,10320,12177,11928,13975,14432,15255,16468,18941,17952,20286,21000,22899,23608,26765,26568,29095", "code": "\ndef A256532(n):\n....s=0\n....for k in range(1,n+1):\n........s+=n%k\n....return s*n \n"}
{"sequence_id": "A256533", "text": "Product of n and the sum of all divisors of all positive integers <= n.", "sequence": "1,8,24,60,105,198,287,448,621,870,1089,1524,1833,2310,2835,3520,4046,4986,5643,6780,7791,8954,9913,11784,13050,14664,16308,18480,20010,22860,24614,27424,29865,32606,35245,39528,42032,45448,48828,53680,56744,62160,65532,70752,75870,80868,84882,92640,97363,104000", "code": "\ndef A256533(n):\n    s=0\n    for k in range(1, n+1):\n        s+=n%k\n    return (n**3)-(s*n) \n"}
{"sequence_id": "A256594", "text": "Numbers k such that k!*2^k + 1 is prime.", "sequence": "0,1,259,16708,18655,26304,61999,110251", "code": "\nfrom sympy import factorial, isprime\nfor n in range(0,300):\n    if isprime(factorial(n)*(2**n)+1):\n        print(n, end=', ') \n"}
{"sequence_id": "A256617", "text": "Numbers having exactly two distinct prime factors, which are also adjacent prime numbers.", "sequence": "6,12,15,18,24,35,36,45,48,54,72,75,77,96,108,135,143,144,162,175,192,216,221,225,245,288,323,324,375,384,405,432,437,486,539,576,648,667,675,768,847,864,875,899,972,1125,1147,1152,1215,1225,1296,1458,1517,1536,1573,1715,1728,1763,1859,1875,1944", "code": "\nfrom sympy import primefactors, nextprime\nA256617_list = []\nfor n in range(1,10**5):\n    plist = primefactors(n)\n    if len(plist) == 2 and plist[1] == nextprime(plist[0]):\n        A256617_list.append(n) \n"}
{"sequence_id": "A256620", "text": "Numbers n such that n is both the average of some twin prime pair p, q (q = p+2) (i.e., n = p+1 = q-1) and is also the arithmetic mean of the four numbers consisting of the two primes before p and the two primes after q.", "sequence": "12,30,42,312,600,858,1032,1290,1698,2112,2688,3768,4218,4230,4260,5850,6132,6552,6702,7212,7308,8292,9420,9930,11970,12042,12378,15972,17190,17598,17922,19470,19890,21600,24180,26862,30012,30852,32118", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(5,200001,2):\n..if isprime(i) and isprime(i+2):\n....a = prevprime(i)\n....b = prevprime(a)\n....if a+b+nextprime(i,2)+nextprime(i,3) == 4*(i+1): print(i+1,end=', ')\n..else: continue\n"}
{"sequence_id": "A256630", "text": "Numbers n such that the decimal expansions of both n and n^2 have 0 as smallest digit and 4 as largest digit.", "sequence": "142201,1422010,11141110,11411110,11412021,14220100,20323421,21024111,101203421,110141011,110142201,111411100,114111100,114120210,120013421,141433102,142201000,203234210,210241110,1012034210,1101410011,1101410110,1101422010,1114111000", "code": "\nfrom itertools import product\nA256630_list = []\nfor l in range(11):\n    for a in ('1','2','3','4'):\n        for b in product('01234',repeat = l):\n            for c in ('0','1','2'):\n                s = a+''.join(b)+c\n                if '0' in s and '4' in s:\n                    n = int(s)\n                    s2 = set(str(n**2))\n                    if {'0','4'} <= s2 <= {'0','1','2','3','4'}:\n                        A256630_list.append(n)\nprint(A256630_list) \n"}
{"sequence_id": "A256635", "text": "a(n) = the smallest number k such that the base-10 digital sum of sigma(k) is n.", "sequence": "1,19,2,3,13,5,4,7,10,12,28,18,192,67,42,273,52,138,324,336,196,300,372,438,2716,997,1590,3468,2512,3260,5817,5692,4112,17472,10852,15840,18496,27252,22860,24300,31572,35172,61488,165652,138438,265252,285652,292860", "code": "\nfrom sympy.ntheory.factor_ import divisor_sigma\ndef A256635(n):\n....k = 1\n....while sum(int(d) for d in str(divisor_sigma(k))) != n:\n........k += 1\n....return k \n"}
{"sequence_id": "A256753", "text": "Numbers n such that n is both the average of some twin prime pair p, q (q = p+2) (i.e., n = p+1 = q-1) and is also the average of the prime before p and the prime after q.", "sequence": "12,18,30,42,60,102,108,228,270,312,420,462,570,600,858,882,1050,1092,1230,1290,1302,1428,1488,1620,1872,1998,2028,2340,2550,2688,2730,3390,3462,3540,3582,4020,4230,4242,4272,4338,4518,4650,4788", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(5,12001,2):\n..if isprime(i) and isprime(i+2):\n....if prevprime(i)+nextprime(i,2) == 2*(i+1): print(i+1,end=', ')\n"}
{"sequence_id": "A256958", "text": "The integers (shown from -50 on).", "sequence": "-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50", "code": " list(range(-50, 51)) \n"}
{"sequence_id": "A256961", "text": "Generated by a rearranging problem (see links for precise definition).", "sequence": "6,5,26,14,16,9,11,30,4,92,31,64,28,44,46,22,52,126,256,197,230,110,125,13,21,196,336,684,462,632,852,1208,780,1278,544,796,520,8,3864,98,1782,5316,6372,7714,7274,3818,4254,9046,6412,2168,2856,2148,1206,3246", "code": "\ndef flip(i,n):\n..m = i%n\n..m2 = n-m-1\n..return i-m+m2\n.\ndef revert(i,moves):\n..for move,leader in reversed(moves):\n....if i==leader-1:\n......i=0\n....else:\n......i+=1\n....\n....i = flip(i,move)\n..return i+3\n.\ndef a256961():\n..moves = []\n..while True:\n....move = revert(0,moves)\n....leader = revert(move-1,moves)\n....out = revert(flip(leader,move),moves)\n....yield out\n....moves.append((move,leader))\n\n"}
{"sequence_id": "A256964", "text": "Solution to Popular Computing Problem 196.", "sequence": "6,8,10,9,14,12,4,15,22,5,26,21,18,32,34,7,38,40,24,33,46,27,50,39,30,56,58,11,62,48,36,51,70,13,74,57,42,60,82,45,86,88,16,69,94,17,98,75,54,104,106,19,110,84,20,87,118,63,122,93,66,128,130,23,134", "code": "\nA256964_list, nlist = [], list(range(3,2*10**4+10))\nfor i in range(10**4):\n....x = nlist[i]\n....A256964_list.append(nlist[x+i])\n....nlist[x+i] = x \n"}
{"sequence_id": "A256967", "text": "a(n) = A256966(n) + 1.", "sequence": "1,2,4,7,10,14,18,22,27,32,37,42,47,53,59,65,71,77,83,89,95,102,109,116,123,130,137,144,151,158,165,172,179,186,194,202,210,218,226,234,242,250,258,266,274,282,290,298,306,314,322,330", "code": "\nA256967_list, x, d, f1, f2 = [], 1, 1, 1, 0\nfor _ in range(20):\n....for i in range(f1):\n........A256967_list.append(x)\n........x += d\n....d += 1\n....f1, f2 = f1 + f2, f1\n\n"}
{"sequence_id": "A256968", "text": "Let b(n) = Product_{i=1..n} p_i/(p_i - 1), p_i = i-th prime; a(n) = minimum k such that b(k) >= n.", "sequence": "1,1,1,2,4,6,9,14,22,35,55,89,142,230,373,609,996,1637,2698,4461,7398,12301,20503,34253,57348,96198,161659,272124,458789,774616,1309627,2216968,3757384,6375166", "code": "\nfrom sympy import prime\nA256968_list, count, bn, bd = [], 0, 1, 1\nfor k in range(1,10**4):\n....p = prime(k)\n....bn *= p\n....bd *= p-1\n....while bn >= count*bd:\n........A256968_list.append(k)\n........count += 1 \n"}
{"sequence_id": "A256969", "text": "Let b(n) = Product_{i=1..n} p_i/(p_i - 1), p_i = i-th prime; a(n) = minimum k such that b(k) > n.", "sequence": "1,1,2,3,4,6,9,14,22,35,55,89,142,230,373,609,996,1637,2698,4461,7398,12301,20503,34253,57348,96198,161659,272124,458789,774616,1309627,2216968,3757384,6375166", "code": "\nfrom sympy import prime\nA256969_list, count, bn, bd = [], 0, 1, 1\nfor k in range(1,10**4):\n....p = prime(k)\n....bn *= p\n....bd *= p-1\n....while bn > count*bd:\n........A256969_list.append(k)\n........count += 1 \n"}
{"sequence_id": "A256985", "text": "Define a sequence {b(i), i >= 0} by b(i) = 1 for 0 <= i <= n, thereafter b(i+1) = (b(i)+b(i-n)) mod 10; consider the sequence of n-tuples [b(i-n+1), b(i-n+2),...,b(i)]; this repeats with period a(n).", "sequence": "60,217,520,42,196812,2480437,2232,7128815,1736327236,124516392,203450520,40193528485,14417724597564,22856442972,324145501174,7946757,193726348876699204,206135768515040,581179046630097612,32289695739703771,275114595439871720", "code": "\nfrom itertools import accumulate \ndef A256985(n):\n....ilist, k = [1]*(n+1), 1\n....jlist = [d % 10 for d in accumulate(ilist)]\n....jlist = [jlist[-1]]+ jlist[:-1]\n....while ilist != jlist:\n........k += 1\n........jlist = [d % 10 for d in accumulate(jlist)]\n........jlist = [jlist[-1]]+ jlist[:-1]\n....return k \n"}
{"sequence_id": "A257002", "text": "Primes p such that p+2 divides p^p+2.", "sequence": "7,13,19,31,37,61,67,109,127,139,157,181,193,199,211,307,313,337,379,397,409,487,499,541,571,577,631,691,751,769,787,811,829,877,919,937,991,1009,1021,1039,1117,1201,1291,1297,1327,1381,1399,1459,1471,1531,1567", "code": "\nfrom sympy import prime\nA257002_list = [p for p in (prime(n) for n in range(1,10**4)) if pow(p, p, p+2) == p] \n"}
{"sequence_id": "A257054", "text": "Numbers k such that for each decimal digit d of k, \"sum of all occurrences of d in k\" is constant.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,111,112,121,211,222,224,242,333,336,363,422,444,448,484,555,633,666,777,844,888,999,1111,1113,1131,1311,2222,2226,2262,2622,3111,3333,3339,3393,3933,4444,5555,6222,6666,7777,8888,9333,9999,11111,11114,11141,11411", "code": "\ndef a():\n....digits = [1,2,3,4,5,6,7,8,9]\n.\n....combs = []\n....for n in range(1,10):\n........combs += list(combinations(digits,n))\n.\n....\n....templates = [''.join(str(d)*(lcm(comb)//d) for d in comb) for comb in combs]\n....templates.sort(key=len)\n.\n....\n....for i in count(1):\n........\n........ts = takewhile(lambda x:len(x)<=i,templates)\n........ts = [t for t in ts if i%len(t)==0]\n........\n........its = sum(([int(''.join(x)) for x in permutations_without_duplicates(sorted(t*(i//len(t))))] for t in ts),[])\n........its.sort()\n........for n in its:\n............yield n\n"}
{"sequence_id": "A257117", "text": "Smaller of two consecutive primes each of which is the sum of two squares.", "sequence": "37,109,193,229,277,313,349,389,397,401,449,457,509,613,661,673,701,757,761,769,797,853,929,937,997,1009,1093,1109,1193,1201,1213,1237,1373,1429,1489,1549,1597,1609,1637,1669", "code": "\nimport sympy\ndef sumpow(sn0,n,p):\n....af=0;bf=0;an=1\n....sn1=sn0+n\n....if n!=0:\n........sn1=sympy.nextprime(sn0,n)\n....while an**p<sn1:\n........bnsq=sn1-(an**p)\n........bn=sympy.ntheory.perfect_power(bnsq)\n........if bn!=False and list(bn)[1]==p:\n............af=an\n............bf=list(bn)[0]\n............an=sn1+100\n........an=an+1\n....return(af,bf)\ns0=1; pw=2\nwhile s0>0:\n....a0,b0=sumpow(s0,0,pw)\n....a1,b1=sumpow(s0,1,pw)\n....if a0!=0 and a1!=0:\n........print(s0)\n....s0=sympy.nextprime(s0)\n"}
{"sequence_id": "A257118", "text": "Smallest of three consecutive prime numbers each of which is the sum of two squares.", "sequence": "89,389,397,449,661,757,761,929,997,1193,1201,1669,2213,2269,2293,2593,2609,2617,2741,3037,3041,3209,3217,3413,3433,3449,3697,3877,4397,4801,5189,5233,5237,5569,5689,5717,6101,6217,6389,6469,6733,6829,6833,6997,7529", "code": "\nimport sympy\ndef sumpow(sn0,n,p):\n....af=0;bf=0;an=1\n....sn1=sn0+n\n....if n!=0:\n........sn1=sympy.nextprime(sn0,n)\n....while an**p<sn1:\n........bnsq=sn1-(an**p)\n........bn=sympy.ntheory.perfect_power(bnsq)\n........if bn!=False and list(bn)[1]==p:\n............af=an\n............bf=list(bn)[0]\n............an=sn1+100\n........an=an+1\n....return(af,bf)\ns0=1; pw=2\nwhile s0>0:\n....a0,b0=sumpow(s0,0,pw)\n....a1,b1=sumpow(s0,1,pw)\n....a2,b2=sumpow(s0,2,pw)\n....if a0!=0 and a1!=0 and a2!=0:\n........print(s0)\n....s0=sympy.nextprime(s0)\n"}
{"sequence_id": "A257119", "text": "Smallest member of four consecutive prime numbers each of which is the sum of two squares.", "sequence": "389,757,1193,2593,2609,3037,3209,3413,3433,5233,6829,7649,8669,8677,9157,9241,10169,10429,11173,11593,11597,11617,11621,11633,11657,12269,12277,12409,12413,12829,12841,15053,17389", "code": "\nimport sympy\ndef sumpow(sn0,n,p):\n....af=0;bf=0;an=1\n....sn1=sn0+n\n....if n!=0:\n........sn1=sympy.nextprime(sn0,n)\n....while an**p<sn1:\n........bnsq=sn1-(an**p)\n........bn=sympy.ntheory.perfect_power(bnsq)\n........if bn!=False and list(bn)[1]==p:\n............af=an\n............bf=list(bn)[0]\n............an=sn1+100\n........an=an+1\n....return(af,bf)\ns0=1; pw=2\nwhile s0>0:\n....a0,b0=sumpow(s0,0,pw)\n....a1,b1=sumpow(s0,1,pw)\n....a2,b2=sumpow(s0,2,pw)\n....a3,b3=sumpow(s0,3,pw)\n....if a0!=0 and a1!=0 and a2!=0 and a3!=0:\n........print(s0)\n....s0=sympy.nextprime(s0)\n"}
{"sequence_id": "A257175", "text": "The smallest m such that the m-th triangular number is greater than or equal to half the n-th triangular number.", "sequence": "0,1,2,2,3,4,5,5,6,7,7,8,9,10,10,11,12,12,13,14,14,15,16,17,17,18,19,19,20,21,22,22,23,24,24,25,26,27,27,28,29,29,30,31,31,32,33,34,34,35,36,36,37,38,39,39,40,41,41,42,43,43,44,45,46,46,47,48,48,49,50,51,51,52,53,53,54,55,56,56,57", "code": "\ndef tri(n):\n... return .5*n*(n+1)\n.\nfor n in range(1,10001):\n... k = 1\n... while 2*tri(k)<tri(n):\n....... k+=1\n... print k\n"}
{"sequence_id": "A257222", "text": "Numbers that have at least one divisor containing the digit 5 in base 10.", "sequence": "5,10,15,20,25,30,35,40,45,50,51,52,53,54,55,56,57,58,59,60,65,70,75,80,85,90,95,100,102,104,105,106,108,110,112,114,115,116,118,120,125,130,135,140,145,150,151,152,153,154,155,156,157,158,159,160,162,165", "code": "\nfrom sympy import divisors\nA257222_list = [n for n in range(1,10**3) if '5' in set().union(*(set(str(d)) for d in divisors(n,generator=True)))] \n"}
{"sequence_id": "A257297", "text": "a(n) = (initial digit of n) * (n with initial digit removed).", "sequence": "0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,0,2,4,6,8,10,12,14,16,18,0,3,6,9,12,15,18,21,24,27,0,4,8,12,16,20,24,28,32,36,0,5,10,15,20,25,30,35,40,45,0,6,12,18,24,30,36,42,48,54,0,7,14,21,28,35,42,49,56,63,0,8,16,24,32,40,48,56,64,72,0,9,18,27,36,45,54,63,72,81,0,1,2,3", "code": "\ndef a(n): s = str(n); return 0 if len(s) < 2 else int(s[0])*int(s[1:])\nprint([a(n) for n in range(104)]) \n"}
{"sequence_id": "A257299", "text": "Numbers n for which each of the digits 0-9 appears exactly once as first digit in the orbit of n under iterations of n -> (first digit of n)*(n with first digit removed) until a single digit is reached; no leading zeros allowed.", "sequence": "9848,51948,56648,68648,77712,84157,87207,98142,98642,249217,298242,325803,328957,381082,383003,423027,461992,516957,549492,721712,796523,812157,879707,925492,945992,948742,950742,960492,1248242,1957313,2211992,2259492,2282707", "code": "\nfrom itertools import permutations\nA257299_list = []\nfor n in permutations('123456789',9):\n....x = 0\n....for d in n:\n........q, r = divmod(x,int(d))\n........if r:\n............break\n........x = int(d + str(q))\n....else:\n........A257299_list.append(x)\nA257299_list = sorted(A257299_list) \n"}
{"sequence_id": "A257341", "text": "Solution to Popular Computing Problem 56 (binary).", "sequence": "1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0", "code": "\nfrom fractions import Fraction\nA257341_list, m = [], 2\nfor i in range(2,10):\n....for j in range(1,i):\n........x = Fraction(j,i)\n........if x.denominator == i:\n............A257341_list.append(int(m*x) % 2)\n............m *= 2 \n"}
{"sequence_id": "A257342", "text": "Solution to Popular Computing Problem 56 (decimal).", "sequence": "8,8,9,0,0,0,3,5,4,9,6,9,5,2,3,0,1,3,9,3,4,6,7,1,9,6,9,0,8,7,9,1,2,9,3,1,0,5,3,8,4,8,0,2,1,0,1,7,9,5,4,3,4,1,4,5,4,3,4,6,5,3,7,0,0,3,2,3,9,6,3,5,0,8,5,2,5,3,1,2,8,6,1,1,0,9,8", "code": "\nfrom fractions import Fraction\nfrom math import log10\nA257342_list, m, y = [], 2, Fraction(0,1)\nfor i in range(2,100):\n....for j in range(1,i):\n....x = Fraction(j,i)\n........if x.denominator == i:\n............y += Fraction(int(m*x) % 2,m)\n............m *= 2\nfor i in range(int(log10(m))-2):\n....y *= 10\n....A257342_list.append(int(y) % 10) \n"}
{"sequence_id": "A257345", "text": "Regard the terms of A004290 as binary numbers and convert to base 10.", "sequence": "0,1,2,7,4,2,14,9,8,511,2,3,28,9,18,14,16,29,1022,25,4,21,6,53,56,4,18,895,36,109,14,59,32,63,58,18,2044,7,50,21,8,31,42,109,12,1022,106,19,112,97,4,35,36,35,1790,6,72,25,218,223,28,37,118,991,64", "code": "\ndef A257345(n):\n....if n > 0:\n........for i in range(1,2**n):\n............x = int(format(i,'b'))\n............if not x % n:\n................return int(str(x),2)\n....return 0 \n"}
{"sequence_id": "A257349", "text": "a(1) = 16, a(n) = sigma(a(n-1)).", "sequence": "16,31,32,63,104,210,576,1651,1792,4088,8880,28272,79360,196416,633984,1827840,7074432,22032000,86640840,364989240,1651141800,7540142400,33541980160,90193969152,334471118520,1415960985600,6118878991680,29424972595200", "code": "\nfrom itertools import accumulate, repeat \nfrom sympy import divisor_sigma\nA257349_list = list(accumulate(repeat(16,100), lambda x, _: divisor_sigma(x)))\n\n"}
{"sequence_id": "A257486", "text": "Numbers n such that the decimal expansions of both n and n^2 have 3 as smallest digit and 7 as largest digit.", "sequence": "6734,67434,577734,667334,745356,6674334,6734744,6756734,7373376,7453574,7466434,7533576,66673334,67345644,67656734,74547734,74656376,75733576,666743334,667335356,746556344,5775434474,6666733334,6666733576,6676476434,7447533576", "code": "\nfrom itertools import product, repeat\nA257486_list = []\nfor l in range(12):\n....for a in product('34567',repeat = l):\n........for b in ('4','5','6'):\n............s = ''.join(a)+b\n............if '3' in s and '7' in s:\n................n = int(s)\n................if {'3','7'} <= set(str(n**2)) <= {'3','4','5','6','7'}:\n....................A257486_list.append(n) \n"}
{"sequence_id": "A257501", "text": "Triangle, read by rows, T(n,k) = 2*k*C(2*(n+k),n-k)/(n+k).", "sequence": "1,4,1,14,8,1,48,44,12,1,165,208,90,16,1,572,910,544,152,20,1,2002,3808,2907,1120,230,24,1,7072,15504,14364,7084,2000,324,28,1,25194,62016,67298,40480,14625,3248,434,32,1,90440,245157,303600", "code": "\nimport math\nf=math.factorial\ndef C(n,r): return f(n)/f(r)/f(n-r)\ni=1\nfor n in range(1,126):\n....for k in range(1,n+1):\n........print str(i)+\" \"+str(2*k*C(2*(n+k),n-k)/(n+k))\n........i+=1 \n"}
{"sequence_id": "A257552", "text": "Primes p such that q = p^2 - 2, r = q^2 - 2 and s = r^2 - 2 are also prime.", "sequence": "2,3,3299,6323,9127,9697,26357,27061,27809,77513,83299,83641,87701,99721,117307,152123,197969,202987,243461,248179,249397,262121,285721,285823,351217,379273,388009,397763,436477,502063,523777,531263,541661,583501,651881", "code": "\nfrom gmpy2 import is_prime, next_prime\nA257552_list, p = [], 2\nfor _ in range(10**9):\n....q = p**2 - 2\n....if is_prime(q):\n........r = q**2 -2\n........if is_prime(r):\n............s = r**2-2\n............if is_prime(s):\n................A257552_list.append(p)\n....p = next_prime(p) \n"}
{"sequence_id": "A257588", "text": "If n = abcd... in decimal, a(n) = |a^2-b^2+c^2-d^2+...|.", "sequence": "0,1,4,9,16,25,36,49,64,81,1,0,3,8,15,24,35,48,63,80,4,3,0,5,12,21,32,45,60,77,9,8,5,0,7,16,27,40,55,72,16,15,12,7,0,9,20,33,48,65,25,24,21,16,9,0,11,24,39,56,36,35,32,27,20,11,0,13,28,45,49", "code": "\ndef A257588(n):\n....return abs(sum((int(d)**2*(-1)**j for j,d in enumerate(str(n)))))\n\n"}
{"sequence_id": "A257630", "text": "Near-repdigit triangular numbers.", "sequence": "10,15,21,28,36,45,78,91,171,300,595,990,1711,5565,6555,66066,333336", "code": "\nfrom sympy import integer_nthroot\ndef istri(n): return integer_nthroot(8*n+1, 2)[1]\ndef near_repdigits(digits):\n    s = set()\n    for d1 in \"0123456789\":\n        for d2 in set(\"0123456789\") - {d1}:\n            for loc in range(1, digits+1):\n                nrd = d1*(digits-loc) + d2 + d1*(loc-1)\n                if nrd[0] != \"0\": s.add(int(nrd))\n    return sorted(s)\ndef afind(maxdigits):\n    for digits in range(2, maxdigits+1):\n        for t in near_repdigits(digits):\n            if istri(t): print(t, end=\", \")\nafind(100) \n"}
{"sequence_id": "A257631", "text": "Near-repunit triangular numbers.", "sequence": "10,15,21,91,171,1711", "code": "\nfrom sympy import integer_nthroot\ndef istri(n): return integer_nthroot(8*n+1, 2)[1]\ndef near_repunits(digits):\n    for loc in range(1, digits):\n        yield int(\"1\"*loc + \"0\" + \"1\"*(digits-loc-1))\n    for loc in range(1, digits+1):\n        for d in \"23456789\":\n            yield int(\"1\"*(digits-loc) + d + \"1\"*(loc-1))\ndef afind(maxdigits):\n    for digits in range(2, maxdigits+1):\n        for t in near_repunits(digits):\n            if istri(t): print(t, end=\", \")\nafind(200) \n"}
{"sequence_id": "A257638", "text": "Numbers n such that n-25, n-1, n+1 and n+25 are consecutive primes.", "sequence": "232962,311712,431832,435948,473352,501342,525492,596118,635388,665922,699792,754182,842448,1013502,1017648,1036002,1156848,1255452,1284738,1306692,1479912,1516128,1551732,1560708,1595928,1659348,1690572,1745112", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,1000001,6):\n..if isprime(i-1) and isprime(i+1) and prevprime(i-1) == i-25 and nextprime(i+1) == i+25: print (i,end=', ')\n"}
{"sequence_id": "A257679", "text": "The smallest nonzero digit present in the factorial base representation (A007623) of n, 0 if no nonzero digits present.", "sequence": "0,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,2,1,3,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,2,1,2,1,1,1,2,1,3,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,2,1,3,1,1,1,2,1,4,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,2,1,3,1,1,1,2,1,1", "code": "\ndef A(n, p=2):\n    return n if n<p else A(n//p, p+1)*10 + n%p\ndef a(n):\n    return 0 if n==0 else min(int(i) for i in str(A(n)) if i !='0')\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A257680", "text": "Characteristic function for A256450: 1 if there is at least one 1-digit present in the factorial representation of n (A007623), otherwise 0.", "sequence": "0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1", "code": "\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a(n): return 1 if '1' in str(a007623(n)) else 0\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A257684", "text": "Discard the rightmost digit from the factorial base representation of n and subtract one from all remaining nonzero digits, then convert back to decimal.", "sequence": "0,0,0,0,1,1,0,0,0,0,1,1,2,2,2,2,3,3,4,4,4,4,5,5,0,0,0,0,1,1,0,0,0,0,1,1,2,2,2,2,3,3,4,4,4,4,5,5,6,6,6,6,7,7,6,6,6,6,7,7,8,8,8,8,9,9,10,10,10,10,11,11,12,12,12,12,13,13,12,12,12,12,13,13,14,14,14,14,15,15,16,16,16,16,17,17", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2):\n    return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a(n):\n    x=str(a007623(n))[:-1]\n    y=\"\".join(str(int(i) - 1) if int(i)>0 else '0' for i in x)[::-1]\n    return 0 if n==1 else sum(int(y[i])*f(i + 1) for i in range(len(y)))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A257685", "text": "Left inverse for injection A255411: a(0) = 0, after which, if n = A255411(k) for some k, then a(n) = k, otherwise a(n) = 0.", "sequence": "0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,3,0,4,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,9,0,10,0,0,0,11,0,12,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,15,0,16,0,0,0,17,0,18,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,21,0,22,0,0,0,23,0,0", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2):\n    return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a257684(n):\n    x=str(a007623(n))[:-1]\n    y=\"\".join(str(int(i) - 1) if int(i)>0 else '0' for i in x)[::-1]\n    return 0 if n==1 else sum([int(y[i])*f(i + 1) for i in range(len(y))])\ndef a257680(n): return 1 if '1' in str(a007623(n)) else 0\ndef a(n): return (1 - a257680(n))*a257684(n)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A257686", "text": "a(0) = 0, for n >= 1: a(n) = A099563(n) * A048764(n).", "sequence": "0,1,2,2,4,4,6,6,6,6,6,6,12,12,12,12,12,12,18,18,18,18,18,18,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,72", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a(n):\n    x=str(a007623(n))\n    return int(x[0])*f(len(x))\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A257687", "text": "Discard the most significant digit from factorial base representation of n, then convert back to decimal: a(n) = n - A257686(n).", "sequence": "0,0,0,1,0,1,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,0", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a(n):\n    x=str(a007623(n))[1:][::-1]\n    return sum(int(x[i])*f(i + 1) for i in range(len(x)))\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A257692", "text": "Numbers such that the smallest nonzero digit present (A257679) in their factorial base representation is 2.", "sequence": "4,12,16,22,48,52,60,64,66,70,76,84,88,94,100,108,112,118,240,244,252,256,258,262,288,292,300,304,306,310,312,316,324,328,330,334,336,340,348,352,354,358,364,372,376,382,408,412,420,424,426,430,436,444,448,454,460,468,472,478,484,492,496,502", "code": "\ndef A(n, p=2): return n if n<p else A(n//p, p+1)*10 + n%p\ndef a(n): return 0 if n==0 else min([int(i) for i in str(A(n)) if i !='0'])\nprint([n for n in range(1, 503) if a(n)==2]) \n"}
{"sequence_id": "A257693", "text": "Numbers such that the smallest nonzero digit present (A257679) in their factorial base representation is 3.", "sequence": "18,72,90,114,360,378,432,450,456,474,498,552,570,594,618,672,690,714,2160,2178,2232,2250,2256,2274,2520,2538,2592,2610,2616,2634,2640,2658,2712,2730,2736,2754,2760,2778,2832,2850,2856,2874,2898,2952,2970,2994,3240,3258,3312,3330,3336,3354,3378,3432,3450,3474,3498,3552", "code": "\ndef A(n, p=2): return n if n<p else A(n//p, p+1)*10 + n%p\ndef a(n): return 0 if n==0 else min([int(i) for i in str(A(n)) if i !='0'])\nprint([n for n in range(1, 4001) if a(n)==3]) \n"}
{"sequence_id": "A257763", "text": "Zeroless numbers n such that n and n^2 have the same set of decimal digits.", "sequence": "1,4762,4832,12385,14829,26394,34196,36215,49827,68474,72576,74528,79286,79836,94583,94867,96123,98376,123385,123546,124235,124365,124579,124589,125476,125478,126969,129685,135438,139256,139261,139756,149382,152385,156242", "code": "\nA257763_list = [n for n in range(1,10**6) if not '0' in str(n) and set(str(n)) == set(str(n**2))] \n"}
{"sequence_id": "A257768", "text": "Numbers n such that for some power k, n is the sum of d + d^k as d runs through the digits of n.", "sequence": "12,18,30,90,666,870,960,1998,7816,42648,119394,302034,360522,1741752,12051036,909341082,931186956,1136424308,1145082306,8390370196,49388550660,52927388760,100552730520,41845367362266,51671446297908,245917854035004,607628544623816,858683110606660,4023730658941192", "code": "\n\ndef moda(n,a):\n    kk = 0\n    while n > 0:\n        kk= kk+(n%10)**a\n        n = n//10\n    return kk\ndef sod(n):\n    kk = 0\n    while n > 0:\n        kk += n % 10\n        n = n//10\n    return kk\nfor a in range (1, 10):\n    for c in range (10, 10**6):\n        if c == moda(c,a)+sod(c):\n            print(c, end=\",\")\n"}
{"sequence_id": "A257784", "text": "Numbers n such that the sum of the digits squared times the sum of the digits of n to some power equals n.", "sequence": "0,1,512,2511,4913,5832,17576,19683,24624,32144,37000,111616,382360,415000,420224,2219400,14041600,16328000,19300032,30681423,39203125,62025728,78535423,186836625,214292000,432265248,1120141312,3479669440,18529084125,25342447725", "code": "\n\ndef moda(n,a):\n    kk = 0\n    while n > 0:\n        kk= kk+(n%10)**a\n        n =int(n//10)\n    return kk\ndef sod(n):\n    kk = 0\n    while n > 0:\n        kk= kk+(n%10)\n        n =int(n//10)\n    return kk\nfor a in range (1, 10):\n    for c in range (1, 10**8):\n        if c==sod(c)**2*moda(c,a):\n            print(c, end=\",\")\n"}
{"sequence_id": "A257786", "text": "Numbers n such that the square root of the sum of the digits times the sum of the digits of n in some power equal n.", "sequence": "0,1,27,376,13131,234595324075,54377519037479592374299,8326623359858152426050700,1513868951125582592290131113769528", "code": "\ndef moda(n,a):\n....kk = 0\n....while n > 0:\n........kk= kk+(n%10)**a\n........n =int(n//10)\n....return kk\ndef sod(n):\n....kk = 0\n....while n > 0:\n........k= kk+(n%10)\n........n =int(n//10)\n....return kk\nfor a in range (1, 10):\n    for c in range (1, 10**8):\n        if c**2==sod(c)*moda(c,a)**2:\n            print (a,c, sod(c),moda(c,a))\n"}
{"sequence_id": "A257787", "text": "Numbers n such that the sum of the digits of n to some power divided by the sum of the digits equal n.", "sequence": "1,2,3,4,5,6,7,8,9,37,48,415,231591,3829377463694454,56407086228259246207394322684", "code": "\ndef moda(n,a):\n....kk = 0\n....while n > 0:\n........kk= kk+(n%10)**a\n........n =int(n//10)\n....return kk\ndef sod(n):\n....kk = 0\n....while n > 0:\n........kk= kk+(n%10)\n........n =int(n//10)\n....return kk\nfor a in range (1, 10):\n....for c in range (1, 10**6):\n........if c*sod(c)==moda(c, a):\n............print (a,c, moda(c,a),sod(c))\n"}
{"sequence_id": "A257806", "text": "a(n) = A257808(n) - A257807(n).", "sequence": "0,-1,0,1,0,1,2,1,2,1,2,3,2,3,4,5,6,5,4,5,6,5,6,5,4,3,4,3,4,5,4,5,6,7,6,5,6,7,6,7,8,7,6,7,8,9,10,11,12,11,12,13,12,11,10,9,10,9,10,11,10,11,12,13,12,11,12,13,12,13,12,13,14,13,12,11,10,9,10,11,12,11,10,9,10,11,12,13,14,15,14,15,16,15,16,15,14", "code": "\ndef A257806_print_upto(n):\n  a = 0\n  b = 0\n  for n in range(n):\n     print(b, end=\", \")\n     ta = a\n     c0 = 0\n     while ta>0:\n         c0 += 1-(ta&1)\n         ta >>= 1\n     a += 1 + c0\n     b += ((2*(1-(a&1))) - 1)\n\n(Scheme, two alternatives, the latter using memoizing definec-macro)\n(define (A257806 n) (- (A257808 n) (A257807 n)))\n(definec (A257806 n) (if (zero? n) n (+  (expt -1 (A233271 n)) (A257806 (- n 1)))))\n"}
{"sequence_id": "A257814", "text": "Numbers n such that k times the sum of the digits (d) to the power k equal n, so n=k*sum(d^k), for some positive integer k, where k is smaller than sum(d^k).", "sequence": "2,3,4,5,6,7,8,9,50,298,130004,484950,3242940,4264064,5560625,36550290,47746195,111971979,129833998,9865843497,46793077740,767609367921,4432743262896,42744572298532,77186414790914,99320211963544,99335229415136,456385296642870", "code": "\ndef mod(n,a):\n....kk = 0\n....while n > 0:\n........kk= kk+(n%10)**a\n........n =int(n//10)\n....return kk\nfor a in range (1, 10):\n....for c in range (1, 10**7):\n........if c==a*mod(c,a) and a<mod(c,a):\n............print (a,c, mod(c,a))\n"}
{"sequence_id": "A257831", "text": "In decimal representation of n: replace each digit with its binary representation.", "sequence": "0,1,10,11,100,101,110,111,1000,1001,10,11,110,111,1100,1101,1110,1111,11000,11001,100,101,1010,1011,10100,10101,10110,10111,101000,101001,110,111,1110,1111,11100,11101,11110,11111,111000,111001,1000,1001,10010,10011", "code": "\ndef A257831(n):\n....return int(''.join((format(int(d),'b') for d in str(n))))\n\n"}
{"sequence_id": "A257850", "text": "a(n) = floor(n/10) * (n mod 10).", "sequence": "0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,0,2,4,6,8,10,12,14,16,18,0,3,6,9,12,15,18,21,24,27,0,4,8,12,16,20,24,28,32,36,0,5,10,15,20,25,30,35,40,45,0,6,12,18,24,30,36,42,48,54,0,7,14,21,28,35,42,49,56,63,0,8", "code": " def A257850(n): return n//10*(n%10) \n"}
{"sequence_id": "A257860", "text": "Numbers n such that a digit of n to the power k plus the sum of the other digits of n equals n, where k is a positive integer.", "sequence": "1,89,132,264,518,739,2407,6579,8200,8201,8202,8203,8204,8205,8206,8207,8208,8209,32780,32781,32782,32783,32784,32785,32786,32787,32788,32789,59060,59061,59062,59063,59064,59065,59066,59067,59068,59069,78145,524300,524301,524302,524303,524304,524305,524306,524307,524308,524309,531459,823567,2097178", "code": "\ndef sod(n):\n....kk = 0\n....while n > 0:\n........kk= kk+(n%10)\n........n =int(n//10)\n....return kk\nfor i in range (1,10**7):\n....for j in range(1,len(str(i))+1):\n........k=(i//(10**(j-1)))%10\n........for m in range (2,30):\n............if i==sod(i)+k**m-k:\n................print (i)\n"}
{"sequence_id": "A257864", "text": "Numbers n such that n!! - 2^7 is prime.", "sequence": "11,13,21,47,59,77,109,129,155,163,245,337,511,1417,3013,3757,4989,8977,12479,12869", "code": "\nfrom gmpy2 import is_prime, mpz\nA257864_list, g, h = [], mpz(105), mpz(128)\nfor i in range(9,10**5,2):\n....g *= i\n....if is_prime(g-h):\n........A257864_list.append(i) \n"}
{"sequence_id": "A257867", "text": "Nonnegative integers n such that in balanced ternary representation the number of occurrences of each trit doubles when n is squared.", "sequence": "314,942,2824,2826,2854,3074,3130,3212,8066,8090,8096,8170,8224,8324,8426,8450,8472,8478,8480,8512,8534,8562,8578,8588,8656,9222,9224,9390,9404,9636,9638,24198,24206,24270,24288,24510,24670,24672,24674,24676,24802,24972", "code": "\ndef a(n):\n    s=[]\n    x=0\n    while n>0:\n        x=n%3\n        n//=3\n        if x==2:\n            x=-1\n            n+=1\n        s.append(x)\n    return s\nprint([n for n in range(1, 25001) if a(n**2).count(-1)==2*a(n).count(-1) and a(n**2).count(1)==2*a(n).count(1) and a(n**2).count(0)==2*a(n).count(0)]) \n"}
{"sequence_id": "A257868", "text": "Negative integers n such that in balanced ternary representation the number of occurrences of each trit doubles when n is squared.", "sequence": "-314,-898,-942,-2694,-2824,-2826,-2962,-3014,-3070,-3074,-8066,-8082,-8090,-8096,-8132,-8170,-8224,-8336,-8426,-8434,-8450,-8472,-8478,-8480,-8618,-8656,-8870,-8886,-8918,-9008,-9042,-9210,-9222,-9224,-24198,-24226,-24246", "code": "\ndef a(n):\n    s=[]\n    l=[]\n    x=0\n    while n>0:\n        x=n%3\n        n//=3\n        if x==2:\n            x=-1\n            n+=1\n        s.append(x)\n        l.append(-x)\n    return [s, l]\nprint([-n for n in range(1, 25001) if a(n**2)[0].count(-1)==2*a(n)[1].count(-1) and a(n**2)[0].count(1)==2*a(n)[1].count(1) and a(n**2)[0].count(0)==2*a(n)[1].count(0)]) \n"}
{"sequence_id": "A257869", "text": "Nonnegative integers with an equal number of occurrences of all trits in balanced ternary representation.", "sequence": "6,8,136,138,144,154,156,160,164,168,170,180,186,188,208,210,214,218,222,224,232,236,248,258,260,266,288,294,296,312,314,320,3406,3412,3414,3430,3432,3438,3484,3486,3492,3510,3568,3574,3576,3592,3594,3600,3622", "code": "\ndef a(n):\n    s=[]\n    x=0\n    while n>0:\n        x=n%3\n        n//=3\n        if x==2:\n            x=-1\n            n+=1\n        s.append(x)\n    return s\nprint([n for n in range(1, 5001) if a(n).count(1)==a(n).count(-1) and a(n).count(-1)==a(n).count(0)]) \n"}
{"sequence_id": "A257886", "text": "Least positive m such that floor(n! / (2*(floor(n/2)!))) + m is prime.", "sequence": "2,1,2,1,1,1,1,13,1,1,29,1,1,37,29,17,31,71,71,37,23,1,37,1,41,41,31,31,59,31,41,41,41,41,41,37,41,193,83,41,53,67,149,97,59,73,113,107,137,59,137,67,101,83,73,101,241,71,73,79,83,227,199,223,127,83,83,181,227,149,103,1,587,179,229,167,127,163,109,83", "code": "\nfrom sympy import factorial, nextprime\n[(nextprime(int(factorial(n)/(2*factorial(n//2)))))-int(factorial(n)/(2*factorial(n//2))) for n in range(1,10**5)]\n"}
{"sequence_id": "A257893", "text": "Pandigital numbers reordered so that the numbers A050278(n)/2^k, where 2^k||A050278(n), appear in nondecreasing order.", "sequence": "3076521984,3718250496,6398410752,1384906752,2769813504,2845310976,1578369024,1074659328,4761059328,9805234176,2507931648,1294073856,5619843072,6591873024,9073852416,9574023168,1208549376,1249837056,6103498752,1542389760,1683947520", "code": "\nfrom itertools import permutations\nl = []\nfor d in permutations('0123456789', 10):\n....if d[0] != '0':\n........d2 = int(''.join(d))\n........d = d2\n........r = d2 % 2\n........while not r:\n............d2, r = divmod(d2, 2)\n........l.append((d2,d))\nl.sort()\nA257893_list = [b for a,b in l] \n"}
{"sequence_id": "A257899", "text": "Pandigital numbers reordered so that the numbers A050278(n)/3^k, where 3^k||A050278(n), are in nondecreasing order.", "sequence": "7246198035,3410256897,5361708249,5902183746,6820513794,8145396207,8269753401,9145036728,9537240186,1257389406,1359426078,4379605281,1742063598,6185973240,2081654397,2095471863,6472951380,2170936485,2304859617,2415930786,2419650873", "code": "\nfrom itertools import permutations\nl = []\nfor d in permutations('0123456789', 10):\n....if d[0] != '0':\n........d2 = int(''.join(d))\n........d = d2\n........r = d2 % 3\n........while not r:\n............d2, r = divmod(d2, 3)\n........l.append((d2,d))\nl.sort()\nA257899_list = [b for a,b in l] \n"}
{"sequence_id": "A257901", "text": "Pandigital numbers reordered so that the numbers A050278(n)/5^k, where 5^k||A050278(n), are in nondecreasing order.", "sequence": "1304296875,1342968750,1437890625,1824609375,9123046875,1923046875,3104296875,3142968750,3649218750,4137890625,4862109375,1034296875,1269843750,6349218750,1284609375,1293046875,1347890625,1432968750,8124609375,1629843750,8462109375", "code": "\nfrom itertools import permutations\nl = []\nfor d in permutations('0123456789', 10):\n....if d[0] != '0':\n........d2 = int(''.join(d))\n........d = d2\n........r = d2 % 5\n........while not r:\n............d2, r = divmod(d2,5)\n........l.append((d2,d))\nl.sort()\nA257901_list = [b for a,b in l] \n"}
{"sequence_id": "A257968", "text": "Zeroless numbers n such that the product of digits of n, the product of digits of n^2 and the product of digits of n^3 form a geometric progression.", "sequence": "1,2,38296,151373,398293,422558,733381,971973,2797318,3833215,6988327,7271256,8174876,8732657,9872323,9981181,11617988,11798921,14791421,15376465,15487926,15625186,16549885,18543639,21316582,21492828,22346329,22867986,23373644", "code": "\ndef pod(n):\n....kk = 1\n....while n > 0:\n........kk= kk*(n%10)\n........n =int(n//10)\n....return kk\nfor i in range (1,10**7):\n....if pod(i**3)*pod(i)==pod(i**2)**2 and pod(i**2)!=0:\n........print (i, pod(i),pod(i**2),pod(i**3),pod(i**2)//pod(i))\n"}
{"sequence_id": "A257993", "text": "Least gap in the partition having Heinz number n; index of the least prime not dividing n.", "sequence": "1,2,1,2,1,3,1,2,1,2,1,3,1,2,1,2,1,3,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,3,1,2,1,2,1,3,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,3,1,2,1,2,1,3,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3", "code": "\nfrom sympy import nextprime, primepi\ndef a053669(n):\n    p = 2\n    while True:\n        if n%p!=0: return p\n        else: p=nextprime(p)\ndef a(n): return primepi(a053669(n)) \n"}
{"sequence_id": "A258044", "text": "Fibonacci numbers that can be expressed as sum of 2 consecutive prime numbers.", "sequence": "5,8,144,1548008755920", "code": "\nfrom sympy import nextprime as np\nfrom sympy import prevprime as pp\nf1=1\nf2=1\nf3=f1+f2\nwhile f3>0:\n    if f3%2==0 and f3>3:\n        i=f3/2\n        p=pp(i); q=np(p)\n        if p+q==f3:\n            print(f3)\n    f1=f2; f2=f3\n    f3=f1+f2\n"}
{"sequence_id": "A258060", "text": "Squares, without multiplicity, that are the concatenation of two integers (without leading zeros) the product of which is also a square.", "sequence": "49,169,361,1225,1444,1681,3249,4225,4900,15625,16900,36100,42025,49729,64009,81225,93025,122500,142129,144400,168100,225625,237169,324900,414736,422500,490000,519841,819025,950625,970225,1024144,1442401,1562500,1600225,1690000,1692601,2079364,2304324", "code": "\nimport math\nlist =[]\nfor i in range(1,100000):\n...a = i*i\n...b = str(a)\n...l = len(b)\n...for j in range(1, l):\n......a_1 = b[:j]\n......a_2 = b[j:]\n......c = int(a_1)* int(a_2)\n......sqrt_c = int(math.sqrt(int(c)))\n......if (sqrt_c * sqrt_c == c) and (int(a_2[:1]) > 0):\n.........if not a in list:\n............list.append(a)\n.........list.append(a)\nprint(list)\n"}
{"sequence_id": "A258088", "text": "Numbers n such that n is the average of four consecutive primes n-5, n-1, n+1 and n+5.", "sequence": "12,18,42,102,108,228,312,462,858,882,1092,1302,1428,1488,1872,1998,2688,3462,4518,4788,5232,5652,6828,7878,8292,10458,13692,13878,15732,16062,16068,16188,17388,19422,19428,20748,21018,21318,22278,23058", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,50001,2):\n..if isprime(i-1) and isprime(i+1):\n....if prevprime(i-1) == i-5 and nextprime(i+1) == i+5: print (i,end=', ')\n"}
{"sequence_id": "A258097", "text": "Number of nonnegative integers that can be computed using exactly n n's and the four basic arithmetic operations {+, -, *, /}.", "sequence": "1,3,9,26,68,198,536,1660,4769,15945,46240,165732,488268,1848866,5852344", "code": "\nfrom fractions import Fraction\nfrom functools import lru_cache\ndef a(n):\n    @lru_cache()\n    def f(m):\n        if m == 1: return {Fraction(n, 1)}\n        out = set()\n        for j in range(1, m):\n            for x in f(j):\n                for y in f(m-j):\n                    out.update([x + y, x - y, x * y])\n                    if y: out.add(Fraction(x, y))\n        return list(out)\n    return sum(num >= 0 and num.denominator == 1 for num in f(n))\nprint([a(n) for n in range(1, 10)]) \n"}
{"sequence_id": "A258103", "text": "Number of pandigital squares (containing each digit exactly once) in base n.", "sequence": "0,0,1,0,1,3,4,26,87,47,87,0,547,1303,3402,0,24192,187562", "code": "\nfrom gmpy2 import isqrt, mpz, digits\ndef A258103(n): \n....c, sm, sq = 0, mpz(''.join([digits(i,n) for i in range(n-1,-1,-1)]),n), mpz(''.join(['1','0']+[digits(i,n) for i in range(2,n)]),n)\n....m = isqrt(sq)\n....sq = m*m\n....m = 2*m+1\n....while sq <= sm:\n........if len(set(digits(sq,n))) == n:\n............c += 1\n........sq += m\n........m += 2\n....return c \n"}
{"sequence_id": "A258165", "text": "Odd non-Brazilian numbers > 1.", "sequence": "3,5,9,11,17,19,23,25,29,37,41,47,49,53,59,61,67,71,79,83,89,97,101,103,107,109,113,131,137,139,149,151,163,167,169,173,179,181,191,193,197,199,223,227,229,233,239,251,257,263,269,271,277,281,283,289,293,311,313,317,331,337", "code": "\nfrom sympy.ntheory.factor_ import digits\nl=[]\nfor n in range(3, 301, 2):\n    c=1\n    for b in range(2, n - 1):\n        d=digits(n, b)[1:]\n        if max(d)==min(d):\n            c=0\n            break\n    if c: l.append(n)\nprint(l) \n"}
{"sequence_id": "A258190", "text": "Smallest prime not appearing earlier that ends with A045572(n).", "sequence": "11,3,7,19,211,13,17,419,421,23,127,29,31,233,37,139,41,43,47,149,151,53,157,59,61,163,67,269,71,73,277,79,181,83,487,89,191,193,97,199,101,103,107,109,2111,113,1117,3119,3121,1123,4127,1129,131,4133,137,4139,2141,2143,5147,11149,1151,1153,4157,4159,2161,1163,167,3169", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n    alst, aset = [], set()\n    for n in range(1, terms+1):\n        ending = 2*n - 1 + (n+1)//4 * 2 \n        i, pow10 = ending, 10**len(str(ending))\n        while i in aset or not isprime(i): i += pow10\n        alst.append(i); aset.add(i)\n    return alst\nprint(aupton(68)) \n"}
{"sequence_id": "A258231", "text": "Numbers n such that both n and n squared contain exactly the same digits, and n is not divisible by 10.", "sequence": "1,4762,4832,10376,10493,11205,12385,14829,23506,24605,26394,34196,36215,48302,49827,68474,71205,72576,74528,79286,79603,79836,94583,94867,96123,98376,100469,100496,100498,100499,100946,102245,102953,103265,103479,103756", "code": "\nA258231_list = [n for n in range(10**6) if n % 10 and set(str(n)) == set(str(n**2))] \n"}
{"sequence_id": "A258272", "text": "The smallest amount which cannot be made with fewer than n British coins.", "sequence": "1,3,8,18,38,88,188,388,588,788,988,1188,1388,1588,1788,1988,2188,2388,2588,2788,2988,3188,3388,3588,3788,3988,4188,4388,4588,4788", "code": " \ncoins = [1,2,5,10,20,50,100,200]\nneed = [0]\nwhile True:\n....next = len(need)\n....n_need = next\n....for coin in coins:\n........if coin>next:\n............break\n........n_need = min(n_need,1+need[next-coin])\n....need.append(n_need)\n....if n_need == len(seq):\n........print(next)\n"}
{"sequence_id": "A258274", "text": "The smallest number of cents which cannot be made with fewer than n American coins.", "sequence": "1,2,3,4,9,19,44,94,194,294,394,494,594,694,794,894,994,1094,1194,1294,1394,1494,1594,1694,1794,1894,1994,2094,2194,2294,2394,2494,2594,2694,2794,2894,2994", "code": " \ncoins = [1,5,10,25,50,100]\nneed = [0]\nwhile True:\n....next = len(need)\n....n_need = next\n....for coin in coins:\n........if coin>next:\n............break\n........n_need = min(n_need,1+need[next-coin])\n....need.append(n_need)\n....if n_need == len(seq):\n........print(next)\n"}
{"sequence_id": "A258366", "text": "Numbers n representable as x*y + x + y, where x >= y > 1, such that all x's and y's in all representation(s) of n are perfect squares.", "sequence": "24,49,84,184,288,504,628,984,1284,1368,1716,2004,2884,3348,3384,3736,4368,6484,6816,7288,8004,9508,9808,10200,11508,14584,14836,15684,19896,21348,21784,22048,25048,25956,27216,27384,35284,38808,40500,40504,44184,47988,49588,50628", "code": "\ndef isqrt(a):\n    sr = 1 << (int.bit_length(int(a)) >> 1)\n    while a < sr*sr:  sr>>=1\n    b = sr>>1\n    while b:\n      s = sr+b\n      if a >= s*s:  sr = s\n      b>>=1\n    return sr\ndef isSquare(a):\n    sr = isqrt(a)\n    return a==sr*sr\nTOP = 100000\na = [0]*TOP\nno= [0]*TOP\nfor y in range(2, TOP//2):\n  for x in range(y, TOP//2):\n    k = x*y + x + y\n    if k>=TOP: break\n    if no[k]==0:\n        a[k]=1\n        if not (isSquare(x) and isSquare(y)):\n            no[k]=1\nprint([n for n in range(TOP) if a[n]>0 and no[n]==0])\n"}
{"sequence_id": "A258382", "text": "Non-palindromic numbers n such that the square root of n multiplied by the reversal of n is a palindrome.", "sequence": "144,441,1584,4851,10404,12544,14544,14884,15984,27648,40401,44521,44541,48841,48951,84672,114444,137984,144144,159984,409739,441441,444411,489731,489951,937904,1004004,1022121,1024144,1042441,1044484,1050804", "code": "\nfor n in range (1, 10**9):\n....y=int(str(n)[::-1])\n....ya=int(pow(n*y,1/2))\n....if ya==int(str(ya)[::-1]) and n*y==ya**2 and n!=y:\n........print (n)\n"}
{"sequence_id": "A258456", "text": "Product of divisors of n is not a square.", "sequence": "2,3,4,5,7,9,11,12,13,17,18,19,20,23,25,28,29,31,32,36,37,41,43,44,45,47,48,49,50,52,53,59,61,63,64,67,68,71,73,75,76,79,80,83,89,92,97,98,99,100,101,103,107,109,112,113,116,117,121,124,127,131,137", "code": "\nfrom gmpy2 import iroot\nfrom sympy import divisor_count\nA258456_list = [i for i in range(1,10**3) if not iroot(i,4)[1] and divisor_count(i) % 4] \n"}
{"sequence_id": "A258482", "text": "Positive numbers n with concatenations n=x//y such that n=x^2-y^2.", "sequence": "100,147,10000,13467,1000000,1010100,1016127,1034187,1140399,1190475,1216512,1300624,1334667,1416767,1484847,1530900,100000000,102341547,102661652,116604399,133346667,159809775,10000000000,10101010100,13333466667,14848484847", "code": "\nfor p in range(1, 7):\n    for i in range(10**p, 10**(p + 1)):\n        c = 10**(int((p - 1) / 2) + 1)\n        a, b = i // c, i % c\n        if i == a**2 - b**2:\n            print(i, end=\",\")\n"}
{"sequence_id": "A258484", "text": "Numbers m such that m equals a fixed number raised to the powers of the digits.", "sequence": "1,10,12,100,101,111,1000,1010,1033,1100,2112,4624,10000,10001,11101,20102,31301,100000,100010,100011,100100,100101,100110,101000,101001,101010,101100,101110,101111,101121,110000,110001,110010,110100,110110,110111,111000", "code": "\ndef moda(n,a,m):\n....kk = 0\n....while n > 0:\n........na=int(n%m)\n........kk= kk+a**na\n........n =int(n//m)\n....return kk\nfor c in range (1, 10**8):\n....for a in range (1,20):\n........if  c==moda(c,a,10):\n............print (a,c)\n"}
{"sequence_id": "A258574", "text": "Numbers n such that Fibonacci(n)+Lucas(n) is squarefree.", "sequence": "0,1,3,4,6,7,9,10,12,13,15,16,18,19,21,22,25,27,28,30,31,33,34,36,37,39,40,42,43,45,46,48,51,52,54,57,58,60,61,63,64,66,67,69,70,72,73,75,76,78,79,81,82,84,85,87,88,91,93,94,96,97,100", "code": "\nfrom sympy import factorint\nA258574_list = []\na, b = 0, 2\nfor n in range(10**2):\n....if max(factorint(b).values()) <= 1:\n........A258574_list.append(n)\n....a, b = b, a + b \n"}
{"sequence_id": "A258584", "text": "Numbers n such that n = Sum_{j>=1} c(j) where c(0) = n, c(j) = floor((c(j-1)/10^k)*(c(j-1) mod 10^k) for j>0, and k is half the number of digits of n, rounded up if the number of digits of n is odd.", "sequence": "86,860,1975,2160,3575,19750,21600,35750,43614,51884,65625,479900,868688,967750,1435575,1548384,1696875,4799000,8686880,9677500,28874200,34095100,38748800,39214560,47613625,53415625,148385715,156293216,288742000,340951000,387488000", "code": "\ndef pod(n,m):\n....kk = 1\n....while n > 0:\n........kk= kk*(n%m)\n........n =int(n//m)\n....return kk\nfor b in range(0,6):\n....dd,bb=0,(b-1)//2+2\n....j=10**bb\n....for c in range (10*j,100*j):\n........d,a,ca=0,0,pod(c,j)\n........while ca>0:\n............d,a=d+ca,a+1\n............if ca<j:\n................ca=j\n............ca=pod(ca,j)\n............if c==d and ca==0:\n................print (a,c)\n"}
{"sequence_id": "A258660", "text": "Numbers n such that the number of digits d in n is not prime and for each factor f of d the sum of the d/f digit groupings of size f is a square.", "sequence": "1,4,9,1521,3600,7396,8100,103041,120409,160801,11471769,11655396,12802084,15210000,22724289,36000000,42889401,42928704,45481536,45968400,46009089,54567769,61811044,62236321,70006689,73925604,73960000,76965529,79174404,81000000,85008400,97693456,97713225,100000000", "code": "\nfrom sympy import divisors\nfrom gmpy2 import is_prime, isqrt, isqrt_rem, is_square\nA258660_list = []\nfor l in range(1,17):\n....if not is_prime(l):\n........fs = divisors(l)\n........a, b = isqrt_rem(10**(l-1))\n........if b > 0:\n............a += 1\n........for n in range(a,isqrt(10**l-1)+1):\n............n2 = n**2\n............ns = str(n2)\n............for g in fs:\n................y = 0\n................for h in range(0,l,g):\n....................y += int(ns[h:h+g])\n................if not is_square(y):\n....................break\n............else:\n................A258660_list.append(n2) \n"}
{"sequence_id": "A258756", "text": "a(n) = common difference giving the highest score in the game \"Sequences\" for a sequence with largest element n and as many elements as possible.", "sequence": "1,1,2,2,3,3,4,3,5,5,4,4,7,3,4,4,3,3,4,3,3,3,3,3,3,3,4,4,3,3,4,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3", "code": "\ndef score(n,step):\n...return n*(step**(n//step+(1 if n%step!=0 else 0)))\n.\ndef best(n):\n...return max(range(1,(n-1)//2+1),key=lambda step:score(n,step))\n"}
{"sequence_id": "A258757", "text": "For 1 < k <= n, let m be the largest number such that k^1, k^2, ... k^m are palindromes in base n. a(n) gives the smallest k which has the largest value of m.", "sequence": "2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,2,3,2,2,2,2,2,2,2,2,6,2,2,2,2,2,2,2,2,2,2,2,2,7,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,10,2,2,2,2,2,2,2,6,2,2,2,2,2,2,2,2,2,2,2,2,11,2,2,2,5,2,2,2,2,2,2", "code": "\ndef to_base(n,b):\n...s = []\n...while n:\n......m = n%b\n......s = [m]+s\n......n = (n-m)//b\n...return s\n.\ndef is_palindrome(n):\n...return n==n[::-1]\n.\ndef num_palindromes(n,b):\n...if n<2:\n......return 0\n...t = 1\n...while is_palindrome(to_base(n**t,b)):\n......t+=1\n...return t-1\n.\ndef most_palindromes(b):\n...return max(range(2,b+1),key=lambda n:num_palindromes(n,b))\n"}
{"sequence_id": "A258774", "text": "a(n) = 1 + sigma(n) + sigma(n)^2.", "sequence": "3,13,21,57,43,157,73,241,183,343,157,813,211,601,601,993,343,1561,421,1807,1057,1333,601,3661,993,1807,1641,3193,931,5257,1057,4033,2353,2971,2353,8373,1483,3661,3193,8191,1807,9313,1981,7141,6163,5257,2353", "code": "\nfrom sympy import divisor_sigma\ndef A258774(n):\n....return (lambda x: x*(x+1)+1)(divisor_sigma(n)) \n"}
{"sequence_id": "A258786", "text": "Numbers n whose sum of anti-divisors is a permutation of their digits.", "sequence": "5,8,41,56,64,358,614,946,1092,1382,1683,2430,2683,2734,2834,2945,3045,3067,3602,4056,4286,5186,5784,6874,7251,8104,8546,9264,12881,14028,14384,15258,17386,21103,22044,23331,24434,24603,25346,26420,26822,26845,27024,27232", "code": "\nfrom sympy.ntheory.factor_ import antidivisors\nA258786_list = [n for n in range(1,10**5) if sorted(str(n)) == sorted(str(sum(antidivisors(n))))] \n"}
{"sequence_id": "A258807", "text": "a(n) = n^5 - 1.", "sequence": "0,31,242,1023,3124,7775,16806,32767,59048,99999,161050,248831,371292,537823,759374,1048575,1419856,1889567,2476098,3199999,4084100,5153631,6436342,7962623,9765624,11881375,14348906,17210367,20511148,24299999,28629150,33554431", "code": " for n in range(1, 50): print(n**5 - 1, end=', ') \n"}
{"sequence_id": "A258879", "text": "Numbers n such that n is the average of four consecutive primes n-7, n-1, n+1 and n+7.", "sequence": "30,60,270,570,600,1230,1290,1620,2340,2550,3540,4020,4650,5850,6270,6360,6570,10860,11490,14550,15270,17490,19080,19380,19470,23670,26730,29130,32370,34260,41610,48480,49200,49530,51420,51480", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,10001,2):\n..if isprime(i-1) and isprime(i+1):\n....if prevprime(i-1) == i-7 and nextprime(i+1) == i+7 :  print (i,end=', ')\n"}
{"sequence_id": "A258881", "text": "a(n) = n + the sum of the squared digits of n.", "sequence": "0,2,6,12,20,30,42,56,72,90,11,13,17,23,31,41,53,67,83,101,24,26,30,36,44,54,66,80,96,114,39,41,45,51,59,69,81,95,111,129,56,58,62,68,76,86,98,112,128,146,75,77,81,87,95,105,117,131,147,165,96,98,102", "code": "\ndef ssd(n): return sum(int(d)**2 for d in str(n))\ndef a(n): return n + ssd(n)\nprint([a(n) for n in range(63)]) \n"}
{"sequence_id": "A258945", "text": "Decimal expansion of Dickman's constant C_4.", "sequence": "0,6,7,6,4,5,2,0,2,1,0,6,9,4,6,1,3,6,9,6,9,7,5,0,2,3,1,0,3,3,8,2,2,9,9,3,9,2,3,4,2,1,9,3,4,4,9,4,9,2,0,4,3,1,7,3,0,1,8,6,0,1,3,4,6,5,2,5,7,5,3,8,5,1,1,6,8,5,5,5,2,9,0,9,8,0,6,8,5,2,2,4,6,3,5,6,2,4,4,8,2,7,0,6", "code": "\nfrom mpmath import mp, log, polylog, zeta, pi, quad\nmp.dps=104\nf=lambda x: (log(x/(2*x+1))*polylog(2, x) + (1/2)*log(x)**2*polylog(1, -2*x))/(x*(x+1))\nI=quad(f, [0, 1/2]) + 3*polylog(4, 1/2) - 3/8*polylog(4, 1/4) - 3/4*log(2) * polylog(3, 1/4) +(pi**2 - 9*log(2)**2)/12*polylog(2, 1/4) + 21*log(2)*zeta(3)/8 + pi**2*(log(2)**2/24) - pi**2*log(2)*(log(3)/6) + log(2)**3*log(3)/2 - 5*log(2)**4/8\nprint([int(z) for z in list(str(I)[2:-1])]) \n"}
{"sequence_id": "A258981", "text": "Numbers containing only 1's and 0's in their base-2, base-3, and base-4 representations.", "sequence": "0,1,4,81,84,85,256,273,324,325,336,337,1089,1092,1093,20496,20497,20736,20737,20740,65620,65856,65857,81921,81984,81985,82000,86032,86277,86292,86293,86356,262468,262480,263169", "code": "\ndef digits(n, b=10): \n    x, y = n, ''\n    while x >= b:\n        x, r = divmod(x,b)\n        y += str(r) if r < 10 else (chr(r+87) if r < 36 else chr(r+29))\n    y += str(x) if x < 10 else (chr(x+87) if x < 36 else chr(x+29))\n    return y[::-1]\nA255927_list = [n for n in (int(format(d,'b'),4) for d in range(10**4)) if max(digits(n,3)) <= '1'] \n"}
{"sequence_id": "A259025", "text": "Numbers n such that n is the average of four consecutive primes n-11, n-1, n+1 and n+11.", "sequence": "420,1050,2028,2730,3582,4230,4242,4272,4338,6090,6132,6690,6792,8220,11058,11160,11970,12252,15288,19542,19698,21588,21600,26892,27540,28098,28308,29400,30840,30870,31080,32412,42072,45318,47808,48120", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,50001,2):\n..if isprime(i-1) and isprime(i+1):\n....if prevprime(i-1) == i-11 and nextprime(i+1) == i+11 :  print (i,end=', ')\n"}
{"sequence_id": "A259089", "text": "Least k such that 2^k has at least n consecutive 2's in its decimal representation.", "sequence": "0,1,43,43,314,314,2354,8555,13326,81784,279272,865356,1727602,1727602", "code": "\ndef A259089(n):\n....s, k, k2 = '2'*n, 0, 1\n....while True:\n........if s in str(k2):\n............return k\n........k += 1\n........k2 *= 2 \n"}
{"sequence_id": "A259091", "text": "Smallest k such that 2^k contains two adjacent copies of n in its decimal expansion.", "sequence": "53,40,43,25,18,16,46,24,19,33,378,313,170,374,361,359,64,34,507,151,348,246,314,284,349,314,261,151,385,166,156,364,65,219,371,359,503,148,155,352,349,308,247,255,192,387,165,149,171,150,210,155,209,101,505", "code": "\ndef A259091(n):\n....s, k, k2 = str(n)*2, 0, 1\n....while True:\n........if s in str(k2):\n............return k\n........k += 1\n........k2 *= 2 \n"}
{"sequence_id": "A259092", "text": "Smallest k such that 2^k contains three adjacent copies of n in its decimal expansion.", "sequence": "242,42,43,83,44,41,157,24,39,50,949,1841,3661,1798,1701,1161,1806,391,1890,2053,950,1164,2354,1807,3816,1800,1799,818,1702,2115,904,1798,1807,2270,392,1699,3022,394,2054,1758,1804,2300,2720,2403,3396,1133,1808,3820", "code": "\ndef A259092(n):\n....s, k, k2 = str(n)*3, 0, 1\n....while True:\n........if s in str(k2):\n............return k\n........k += 1\n........k2 *= 2 \n"}
{"sequence_id": "A259124", "text": "If n is representable as x*y+x+y, with x>=y>1, then a(n) is the sum of all x's and y's in all such representations. Otherwise a(n)=0.", "sequence": "0,0,0,0,0,0,0,4,0,0,5,0,0,6,6,0,7,0,7,8,0,0,17,8,0,10,9,0,20,0,10,12,0,10,34,0,0,14,23,0,26,0,13,28,0,0,43,12,13,18,15,0,32,14,29,20,0,0,67,0,0,36,32,16,38,0,19,24,32,0,76,0,0,44,21,16,44,0,57,44", "code": "\nTOP = 100\na = [0]*TOP\nfor y in range(2, TOP//2):\n  for x in range(y, TOP//2):\n    n = x*y + x + y\n    if n>=TOP: break\n    a[n] += x+y\nprint(a[1:])\n"}
{"sequence_id": "A259146", "text": "Smallest prime with first n digits distinct.", "sequence": "2,13,103,1039,10243,102359,1023467,10234589,102345689,10234567897", "code": "\nfrom sympy import nextprime\ndef a(n):\n  p = nextprime(10**(n-1))\n  while len(set(str(p)[:n])) < n: p = nextprime(p)\n  return p\nfor n in range(1, 11):\n  print(a(n), end=\", \") \n"}
{"sequence_id": "A259176", "text": "Triangle read by rows T(n,k) in which row n lists the odd-indexed terms of n-th row of triangle A237593.", "sequence": "1,2,2,1,3,1,3,2,4,1,1,4,1,2,5,1,2,5,2,2,6,1,1,2,6,1,1,3,7,2,1,2,7,2,1,3,8,1,2,3,8,2,1,1,3,9,2,1,1,3,9,2,1,1,4,10,2,1,2,3,10,2,1,2,4,11,2,2,1,4,11,3,1,1,1,4,12,2,1,1,2,4,12,2,1,1,2,5,13,3,1,1,2,4,13,3,2,1,1,5,14,2,2,1,2,5", "code": "\nfrom sympy import sqrt\nimport math\ndef row(n): return int(math.floor((sqrt(8*n + 1) - 1)/2))\ndef s(n, k): return int(math.ceil((n + 1)/k - (k + 1)/2)) - int(math.ceil((n + 1)/(k + 1) - (k + 2)/2))\ndef T(n, k): return s(n, k) if k<=row(n) else s(n, 2*row(n) + 1 - k)\ndef a259177(n, k): return T(n, 2*k - 1)\nfor n in range(1, 11): print([a259177(n, k) for k in range(1, row(n) + 1)]) \n"}
{"sequence_id": "A259177", "text": "Triangle read by rows T(n,k) in which row n lists the even-indexed terms of n-th row of triangle A237593.", "sequence": "1,2,1,2,1,3,2,3,1,1,4,2,1,4,2,1,5,2,2,5,2,1,1,6,3,1,1,6,2,1,2,7,3,1,2,7,3,2,1,8,3,1,1,2,8,3,1,1,2,9,4,1,1,2,9,3,2,1,2,10,4,2,1,2,10,4,1,2,2,11,4,1,1,1,3,11,4,2,1,1,2,12,5,2,1,1,2,12,4,2,1,1,3,13,5,1,1,2,3,13,5,2,1,2,2,14", "code": "\nfrom sympy import sqrt\nimport math\ndef row(n): return int(math.floor((sqrt(8*n + 1) - 1)/2))\ndef s(n, k): return int(math.ceil((n + 1)/k - (k + 1)/2)) - int(math.ceil((n + 1)/(k + 1) - (k + 2)/2))\ndef T(n, k): return s(n, k) if k<=row(n) else s(n, 2*row(n) + 1 - k)\ndef a259177(n, k): return T(n, 2*k)\nfor n in range(1, 27): print([a259177(n, k) for k in range(1, row(n) + 1)]) \n"}
{"sequence_id": "A259313", "text": "Numbers n for which there exists a k>=2 such that n equals the average of digitsum(n^p) for p from 1 to k.", "sequence": "1,9,12,13,16,19,21,49,61,67,84,106,160,191,207,250,268,373,436,783,2321,3133,3786,3805,4842,5128,8167,13599,29431,35308", "code": "\ndef sod(n):\n....kk = 0\n....while n > 0:\n........kk= kk+(n%10)\n........n =int(n//10)\n....return kk\nfor c in range (2, 10**4):\n....bb=0\n....for a in range(1,200):\n........bb=bb+sod(c**a,10)\n........if bb==c*a:\n............print (c,a)\n"}
{"sequence_id": "A259316", "text": "Numbers n such that the result of n multiplied by the reversal of n can be split into two numbers a and b of equal length (if the length is odd a leading zero is allowed), where a + b equals n (b can also have a leading zero).", "sequence": "1,9,54,55,99,999,2727,3222,7777,8272,9999,12466,22222,25912,39114,75880,87777,87804,93357,99999,124660,142857,181818,185185,189189,230769,231868,324675,390313,412587,428274,443926,503866,513513,533169,568468", "code": "\ndef sod(n,m):\n....kk = 0\n....while n > 0:\n........kk= kk+(n%m)\n........n =int(n//m)\n....return kk\nuu=1\nfor a in range (1,9):\n....for n in range (10**(a-1)+1, 10**a):\n........y=int(str(n)[::-1])\n........ll=int(len(str(n*y))/2+0.5)\n........u=sod(n*y,10**ll)\n........if n==u:\n............print (n)\n(python for rep2-digit)\nfor f in range (12,98):\n....aa=1\n....for i in range(1,200):\n........aa=10**(2*i)+aa\n........c=f*aa\n........cc=str(c*int(str(c)[::-1]))\n........l=int(len(cc)/2)\n........cc1,cc2=int(cc[0:l]),int(cc[l:2*l+1])\n........if c==cc1+cc2:\n............print (c)\n"}
{"sequence_id": "A259374", "text": "Palindromic numbers in bases 3 and 5 written in base 10.", "sequence": "0,1,2,4,26,52,1066,1667,2188,32152,67834,423176,437576,14752936,26513692,27711772,33274388,320785556,1065805109,9012701786,9256436186,12814126552,18814619428,201241053056,478999841578,670919564984,18432110906024,158312796835916,278737550525722", "code": "\ndef nextpal(n,b): \n....m, pl = n+1, 0\n....while m > 0:\n........m, pl = m//b, pl+1\n....if n+1 == b**pl:\n........pl = pl+1\n....n = (n//(b**(pl//2))+1)//(b**(pl%2))\n....m = n\n....while n > 0:\n........m, n = m*b+n%b, n//b\n....return m\nn, a3, a5 = 0, 0, 0\nwhile n <= 20000:\n....if a3 < a5:\n........a3 = nextpal(a3,3)\n....elif a5 < a3:\n........a5 = nextpal(a5,5)\n....else: \n........print(n,a3)\n........a3, a5, n = nextpal(a3,3), nextpal(a5,5), n+1\n\n"}
{"sequence_id": "A259379", "text": "Numbers n of the form a - b + c, such that n^3 equals the decimal concatenation a//b//c and numbers n, b, and c have the same number of digits.", "sequence": "155,209,274,286,287,351,364,428,573,637,715,727,846,923,1095,1096,2191,8905,18182,18183,81818,81819,326734,336634,663367,673267,2727273,2727274,4545454,5454547,7272727,23529411,23529412,76470589", "code": "\ndef modb(n,m):\n...kk = 0\n....l=1\n....while n > 0:\n........na=int(n%m)\n........l=l+1\n........kk= kk+((-1)**l)*na\n........n =int(n//m)\n....return kk\nfor n in range (100,10**9):\n....ll= len(str(n))\n....if modb(n**3,10**ll)==n:\n.........print (n)\n"}
{"sequence_id": "A259385", "text": "Palindromic numbers in bases 2 and 9 written in base 10.", "sequence": "0,1,3,5,7,127,255,273,455,6643,17057,19433,19929,42405,1245161,1405397,1786971,2122113,3519339,4210945,67472641,90352181,133638015,134978817,271114881,6080408749,11022828069,24523959661,25636651261,25726334461,28829406059,1030890430479,1032991588623,1085079274815,1616662113341", "code": "\ndef nextpal(n, base): \n    m, pl = n+1, 0\n    while m > 0:\n        m, pl = m//base, pl+1\n    if n+1 == base**pl:\n        pl = pl+1\n    n = n//(base**(pl//2))+1\n    m, n = n, n//(base**(pl%2))\n    while n > 0:\n        m, n = m*base+n%base, n//base\n    return m\nn, a2, a9 = 0, 0, 0\nwhile n <= 30:\n    if a2 < a9:\n        a2 = nextpal(a2,2)\n    elif a9 < a2:\n        a9 = nextpal(a9, 9)\n    else: \n        print(a2, end=\",\")\n        a2, a9, n = nextpal(a2,2), nextpal(a9,9), n+1 \n"}
{"sequence_id": "A259407", "text": "Fibonacci numbers corresponding to the indices mentioned in A214852.", "sequence": "2,14930352,267914296,956722026041,781774079430987230203437,178890334785183168257455287891792,57602132235424755886206198685365216,55835073295300465536628086585786672357234389,15156039800290547036315704478931467953361427680642", "code": "\nf1=1; f2=1\nwhile f1>0:\n....f3=f1+f2\n....c = bin(f3).split('b')[1]\n....if c.count(\"1\")==c.count(\"0\"):\n........print(f3)\n....f1=f2; f2=f3\n"}
{"sequence_id": "A259621", "text": "Positive integers k with record-setting smallest values of abs(cos(k) - cos(k*Pi/180)).", "sequence": "1,6,32,179,243,352,2705,3063,8601,25560,144770,516060,2605860,31786380,66178620,1024465680,1090644300,6477687180,7568331480", "code": "\nfrom math import pi,cos\ndef record_smallest():\n...n = 0\n...record = None\n...while True:\n......n+=1\n......v = abs(cos(n)-cos(n*pi/180.0))\n......if record is None or v<record:\n.........yield n\n.........record = v\n"}
{"sequence_id": "A259629", "text": "\"Near Primorial\" numbers.", "sequence": "10,15,42,70,105,330,462,770,1155,2730,4290,6006,10010,15015,39270,46410,72930,102102,170170,255255,570570,746130,881790,1385670,1939938,3233230,4849845,11741730,13123110,17160990,20281170,31870410,44618574,74364290,111546435,281291010", "code": "\nfrom __future__ import division\nfrom sympy import nextprime\nA259629_list, plist, p = [10, 15], [10, 15], 5\nfor _ in range(50):\n    r = nextprime(p)\n    plist = [plist[-1]*2*r//p]+[d*r for d in plist]\n    A259629_list.extend(plist)\n    p = r \n"}
{"sequence_id": "A259630", "text": "a(n) is the smallest integer not occurring earlier such that 2^a(1) + 2^a(2) + ... + 2^a(n) is a prime.", "sequence": "1,0,2,4,3,12,5,14,27,8,25,30,31,36,13,18,131,60,133,458,247,1040,21,618,283,300,209,6282,19107,11792,3401,30214,1211,3044,15989,30194", "code": "\nfrom sympy import isprime\nA259630_list, A259630_set, k = [], set(), 0\nwhile len(A259630_list) < 50:\n    n, m = 0,1\n    k += m\n    while n in A259630_set or not isprime(k):\n        n += 1\n        k += m\n        m *= 2\n    A259630_list.append(n)\n    A259630_set.add(n) \n"}
{"sequence_id": "A259661", "text": "Binary representation of the middle column of the \"Rule 54\" elementary cellular automaton starting with a single ON cell.", "sequence": "1,11,110,1100,11001,110011,1100110,11001100,110011001,1100110011,11001100110,110011001100,1100110011001,11001100110011,110011001100110,1100110011001100,11001100110011001,110011001100110011,1100110011001100110,11001100110011001100", "code": " print([10**(n+3)//909 for n in range(50)]) \n"}
{"sequence_id": "A259673", "text": "a(n) = sigma_(prime(n))(n).", "sequence": "1,9,244,16513,48828126,13062296532,232630513987208,144115462954287105,8862938119746644274757,100000000186264514923632574038,191943424957750480504146841291812,8505622499882988712256991112913772434548,4695452425098908797088971409337422035076128814", "code": "\nfrom sympy import divisor_sigma, prime\ndef A259673(n):\n....return divisor_sigma(n,prime(n)) \n"}
{"sequence_id": "A259697", "text": "Triangle read by rows: T(n,k) = number of rook patterns on n X n board where bottom rook is in column k.", "sequence": "1,1,1,1,2,2,1,4,5,5,1,9,12,15,15,1,24,32,42,52,52,1,76,99,129,166,203,203,1,279,354,451,575,726,877,877,1,1156,1434,1786,2232,2792,3466,4140,4140,1,5296,6451,7883,9664,11881,14621,17884,21147,21147", "code": "\nfrom sympy import bell, binomial\ndef a011971(n, k): return sum([binomial(k, i)*bell(n - k + i) for i in range(k + 1)])\ndef T(n, k): return 1 if k==0 else sum([a011971(i - 1, k - 1) for i in range(k, n + 1)])\nfor n in range(10): print [T(n, k) for k in range(n + 1)] \n"}
{"sequence_id": "A259831", "text": "Numbers n with the property that it is possible to write the base 2 expansion of n as concat(a_2,b_2), with a_2>0 and b_2>0 such that, converting a_2 and b_2 to base 10 as a and b, we have (sigma(a)-a)*(sigma(b)-b) = n.", "sequence": "216,13296,13464,14416,51480,235200,575484,578592,585000,1032656,1121400,1599552,4190364,4786110,8365968,11268688,13010634,13253436,21835624,22108784,23896320,136311840,152820243,160380496,170073324,295999900,421686580,445421664", "code": "\nfrom sympy import divisor_sigma\nA259831_list= []\nfor n in range(2,10**6):\n....s = format(n,'0b')\n....for l in range(1,len(s)):\n........n1, n2 = int(s[:l],2), int(s[l:],2)\n........if n2 > 0 and n == (divisor_sigma(n1)-n1)*(divisor_sigma(n2)-n2):\n............A259831_list.append(n)\n............break \n"}
{"sequence_id": "A259832", "text": "Numbers n with the property that it is possible to write the base 2 expansion of n as concat(a_2,b_2), with a_2>0 and b_2>0 such that, converting a_2 and b_2 to base 10 as a and b, we have (sigma(a)-a)*(sigma(b)-b) = sigma(n).", "sequence": "7708,9020,86934,92128,120228,325180,372000,491630,565724,739032,862780,1120024,1344090,1419304,1440858,1678232,2752626,2980515,3684344,4154418,4860476,7539610,7565257,9527064,11025372,12277728,17002336,20256672,22528536,24597984", "code": "\nfrom sympy import divisor_sigma\nA259832_list= []\nfor n in range(2,10**6):\n....s, k = format(n,'0b'), divisor_sigma(n)\n....for l in range(1,len(s)):\n........n1, n2 = int(s[:l],2), int(s[l:],2)\n........if n2 > 0 and k == (divisor_sigma(n1)-n1)*(divisor_sigma(n2)-n2):\n............A259832_list.append(n)\n............break \n"}
{"sequence_id": "A259834", "text": "Number of permutations of [n] with no fixed points where the maximal displacement of an element equals n-1.", "sequence": "0,0,1,2,5,20,97,574,3973,31520,281825,2803418,30704101,367114252,4757800705,66432995030,994204132517,15875195019224,269397248811073,4841453414347570,91856764780324165,1834779993945449348,38485629141294791201,845788826477292504302", "code": "\ndef A259834_list(len):\n    L, u, x, y = [0], 1, 0, 0\n    for n in range(len):\n        y, x, u = x, x*n + u, -u\n        L.append(y + 2*x)\n    L[1] = 0\n    return L\nprint(A259834_list(23)) \n"}
{"sequence_id": "A259836", "text": "Integers n where n^3 + (n+1)^3 is a Taxicab number A001235.", "sequence": "9,121,235,301,1090,1293,1524,3152,8010,15556,15934,19247,20244,21498,24015,25363,25556,45462,57872,63758,80016,93349,94701,101929,113098,119942,132414,143653,167147,186540,192629,229508,246122,247318,292154,307534,322870", "code": "\nfrom __future__ import division\nfrom gmpy2 import is_square\nfrom sympy import divisors\nA259836_list = []\nfor n in range(10000):\n    m = n**3+(n+1)**3\n    for x in divisors(m):\n        x2 = x**2\n        if x2 > m:\n            break\n        if x != (2*n+1) and m < x*x2 and is_square(12*m//x-3*x2):\n            A259836_list.append(n)\n            break \n"}
{"sequence_id": "A259877", "text": "If n is even then a(n) = n!/( 2^(n/2)*(n/2)! ), otherwise a(n) = n!/( 3*2^((n-1)/2)*((n-3)/2)! ).", "sequence": "1,1,3,10,15,105,105,1260,945,17325,10395,270270,135135,4729725,2027025,91891800,34459425,1964187225,654729075,45831035250,13749310575,1159525191825,316234143225,31623414322500,7905853580625,924984868933125,213458046676875,28887988983603750,6190283353629375", "code": "\nfrom __future__ import division\nA259877_list, a = [1], 1\nfor n in range(2,10**2):\n....a = 6*a//(n-1) if n % 2 else a*n*(n+1)//6\n....A259877_list.append(a) \n"}
{"sequence_id": "A259942", "text": "Numbers that are larger than or equal to the sum of the cubes of their prime factors (with multiplicity).", "sequence": "1,64,96,108,128,144,162,192,216,240,243,256,270,288,300,320,324,360,384,400,405,432,448,450,480,486,500,504,512,540,560,567,576,600,625,630,640,648,672,675,700,720,729,750,756,768,784,800,810,840,864,875,882,896,900,945,960,972,980,1000", "code": "\nfrom sympy import factorint\nfor j in range(1, 1001):\n    k =  factorint(j)\n    it = k.keys()\n    va = k.values()\n    alfa = 0\n    for l in range(0,len(k)):\n        alfa = alfa + va[l]*(it[l]**3)\n    if alfa <=j:\n        print j\n"}
{"sequence_id": "A259981", "text": "Let b be the n-th composite number, A002808(n); a(n) is number of base-b digits x,y,z such that (xb+y)/(zb+x)=y/z.", "sequence": "1,2,2,2,4,4,2,6,7,4,4,10,6,6,6,4,6,10,6,4,8,6,6,21,2,6,18,6,4,18,10,8,10,10,12,12,6,16,22,14,6,10,2,12,21,12,20,4,10,22,10,2,12,20,14,24,8,24,8,10,28,6,6,18,10,28,16,10,6,6,30,4,24,37,6,6,46,14,10,6,18,24,6,18", "code": "\nfrom sympy import primepi\ndef A002808(n):\n....m = n\n....while m != primepi(m) + 1 + n:\n........m += 1\n....return m\ndef A259981(n):\n....b, c = A002808(n), 0\n....for x in range(1,b):\n........for y in range(1,b):\n............if x != y:\n................w = b*(x-y)\n................for z in range(1,b):\n....................if x != z:\n........................if z*w == y*(x-z):\n............................c += 1\n....return c \n"}
{"sequence_id": "A260031", "text": "Final nonzero digit of n^n in base 12.", "sequence": "1,4,3,4,5,3,7,4,9,4,11,1,1,4,3,4,5,3,7,4,9,4,11,4,1,4,3,4,5,3,7,4,9,4,11,9,1,4,3,4,5,3,7,4,9,4,11,4,1,4,3,4,5,3,7,4,9,4,11,1,1,4,3,4,5,3,7,4,9,4,11,9,1,4,3,4,5,3,7,4,9,4,11,1", "code": "\nfrom gmpy2 import mpz, digits\ndef A260031(n):\n    s = digits(mpz(n)**mpz(n),12)\n    t = s[-1]\n    while t == '0':\n        s = s[:-1]\n        t = s[-1]\n    return int(t,12) \n"}
{"sequence_id": "A260093", "text": "Numbers n for which A259124(n) = A259124(n-1) + 1.", "sequence": "20,49,2096,5684,14847,440876,18770091,40882585915,5598199195808,35959924244180", "code": "\nTOP = 5000*5000\na = [0]*TOP\nfor y in range(2, 5000):\n  z = TOP//y + 1\nfor x in range(y, z):\n    n = x*y + x + y\n    if n>=TOP: break\n    a[n] += x+y\nfor n in range(1,TOP):\n    if a[n]==a[n-1]+1 and a[n]>0: print str(n)+',',\n"}
{"sequence_id": "A260096", "text": "Numbers whose decimal and hexadecimal representations both have strictly decreasing digits.", "sequence": "0,1,2,3,4,5,6,7,8,9,10,32,50,64,65,80,81,82,83,84,96,97,98,210,54320,54321,64320,64321,65210,764210", "code": "\ndef decreasing(top):\n    if top==0:\n        yield []\n        return\n    for d in range(top):\n        if d>0:\n            yield [d]\n        for s in decreasing(d):\n            yield [d]+s\ndef to_int(s):\n    t = 0\n    for d in s:\n        t = t*10+d\n    return t\ndef to_hex(n):\n    out = []\n    if n==0:\n        return [0]\n    while n:\n        m = n%16\n        n = (n-m)//16\n        out.insert(0,m)\n    return out\ndef is_decreasing(h):\n    m = h[0]\n    for d in h[1:]:\n        if d>=m:\n            return False\n        m = d\n    return True\nns = sorted(to_int(s) for s in list(decreasing(10)))\na = [n for n in ns if is_decreasing(to_hex(n))]\n"}
{"sequence_id": "A260097", "text": "Numbers n = concat(s,t) such that n = sigma(s*t), where sigma(x) is the sum of the divisors of x.", "sequence": "124,2352,2604,6804,15240,63180,225302,632400,1531152,2537040,4592588,7160400,7603680,26100144,26378352,31492032,33747840,49447728,88385040,104941200,162496048,175600040,197499456,403242624,483741216,797091840,2077442640,2942021520,4045874976,4828299840", "code": "\nfrom sympy import divisor_sigma\nA260097_list= []\nfor n in range(11,10**6):\n....s = str(n)\n....for l in range(1,len(s)):\n........m = int(s[:l])*int(s[l:])\n........if m > 0 and n == divisor_sigma(m):\n............A260097_list.append(n)\n............break \n"}
{"sequence_id": "A260143", "text": "Runs of consecutive integers with same prime signature.", "sequence": "2,3,14,15,21,22,33,34,35,38,39,44,45,57,58,75,76,85,86,87,93,94,95,98,99,116,117,118,119,122,123,133,134,135,136,141,142,143,145,146,147,148,158,159,171,172,177,178,201,202,203,205,206,213,214,215,217,218,219,230,231,244,245", "code": "\nfrom sympy import factorint\ndef aupto(limit):\n    aset, prevsig = {2}, [1]\n    for k in range(3, limit+2):\n        sig = sorted(factorint(k).values())\n        if sig == prevsig: aset.update([k - 1, k])\n        prevsig = sig\n    return sorted(aset)\nprint(aupto(250)) \n"}
{"sequence_id": "A260185", "text": "a(n) is the number of ways to select an ordered pair of subsets of {2,...,n} such that each pair of elements from different subsets are relatively prime.", "sequence": "1,3,9,21,63,111,333,693,1521,2577,7731,13491,40473,67833,119241,239481,718443,1340523,4021569,7494849,13356657,22271409,66814227,130266387,268286823,447212583,896472063,1684872063,5054616189,9566769789,28700309367,57402497367", "code": " \n"}
{"sequence_id": "A260193", "text": "Numbers n of the form n = abs(a - b + c - d) such that n^4 equals the concatenation of a//b//c//d and numbers n,b,c,d have the same number of digits.", "sequence": "198,220,221,287,352,364,484,562,627,638,672,715,716,780,793,858,901,1095,1233,2328,8905,18183,39753,60248,85207,336734,2727274,5893504,8620777,17769557,52818678,70710735,76470590,82230444,101318734,101636206,104263158,105262158,109891110,109942690,117883117,119722383,120826541", "code": "\ndef modb(n, m):\n...kk = 0\n....l=1\n....while n > 0:\n........na=int(n%m)\n........l=l+1\n........kk= kk+((-1)**l)*na\n........n =int(n//m)\n....return abs(kk)\nfor n in range (100, 10**9):\n....ll= len(str(n))\n....if modb(n**4, 10**ll)==n:\n.........print (n)\n"}
{"sequence_id": "A260213", "text": "Numbers j such that j = (c_1 + k)*(c_2 + k)*...*(c_m + k) for some k > 0 where c_1, c_2, ..., c_m is the centesimal expansion of j.", "sequence": "114,120,147,198,264,420,500,506,513,525,533,550,558,568,581,648,1102,1116,1168,1302,1320,1377,1680,1692,1710,1720,1734,1755,1771,1872,2106,2132,2310,2332,2380,2664,2714,2736,2790,2914,2940,3312", "code": "\ndef pod(n,m,a):\n    kk = 1\n    while n > 0:\n        kk= kk*(n%m+a)\n        n =int(n//m)\n    return kk\nfor c in range (1,10000):\n    for a in range (1,100):\n        if c==pod(c,100,a):\n            print (c)\n"}
{"sequence_id": "A260224", "text": "Primes that contain only the digits (1, 3, 5).", "sequence": "3,5,11,13,31,53,113,131,151,311,313,331,353,1151,1153,1511,1531,1553,3313,3331,3511,3533,5113,5153,5333,5351,5531,11113,11131,11311,11351,11353,11551,13151,13313,13331,13513,13553,15131,15313,15331,15511,15551", "code": "\nfrom gmpy2 import is_prime, mpz\nfrom itertools import product\nA260224_list = [int(''.join(x)) for n in range(1,10) for x in product('135',repeat=n) if is_prime(mpz(''.join(x)))] \n"}
{"sequence_id": "A260273", "text": "Successively add the smallest nonzero binary number that is not a substring.", "sequence": "1,3,5,8,11,15,17,20,23,27,31,33,36,39,44,51,56,61,65,68,71,76,81,84,87,91,95,99,104,111,115,120,125,129,132,135,140,145,148,151,157,165,168,171,175,179,186,190,194,199,204,209,216,223,227,232,241,246", "code": "\nA260273_list, a = [1], 1\nfor i in range(10**3):\n    b, s = 1, format(a,'b')\n    while format(b,'b') in s:\n        b += 1\n    a += b\n    s = format(a,'b')\n    A260273_list.append(a) \n"}
{"sequence_id": "A260343", "text": "Numbers n such that the base-n number formed by concatenating the base-n numbers 1 2 ... n-1 n n-1 ... 2 1 is prime.", "sequence": "2,3,4,6,9,10,16,40,104,8840", "code": "\nfrom gmpy2 import is_prime\ndef intbase(dlist,b=10): \n    y = 0\n    for d in dlist:\n        y = y*b + d\n    return y\nA260343_list = [n for n in range(2,500) if is_prime(intbase(list(range(1,n))+[1,0]+list(range(n-1,0,-1)), n))] \n"}
{"sequence_id": "A260348", "text": "Numbers n such that n is divisible by (10^k - digitsum(n)), where k equals the number of digits of digitsum(n).", "sequence": "5,8,9,18,21,24,26,27,36,44,45,50,54,60,62,63,72,80,81,86,90,108,116,117,126,132,134,135,140,144,152,153,162,170,171,180,200,204,206,207,210,216,224,225,230,234,240,242,243,252,260,261,264,270,306,312,314", "code": "\ndef sod(n,m):\n....kk = 0\n....while n > 0:\n........kk= kk+(n%m)\n........n =int(n//m)\n....return kk\nfor c in range (1, 10**6):\n....k=len(str(sod(c,10)))\n....kl=10**k-sod(c,10)\n....if c%kl==0:\n........print (c)\n"}
{"sequence_id": "A260351", "text": "In base n, a(n) is the largest (decimal equivalent) number reached when one sequentially adds to a sum, starting with zero, the largest digit not in that sum.", "sequence": "1,5,30,214,1865,22881,342447,6053444,123456798,2853116815,73686782411,2103299351346,65751519678065,2234152501943369,81985529216487165,3231407272993503256,136146740744970718253,6106233505124424781971,290464265927977839351196", "code": "\nfrom gmpy2 import digits\ndef A260351(n):\n....r, c = set([digits(d,n) for d in range(n)]), 0\n....dc = set(digits(c,n))\n....while len(dc) < n-1 or '0' in dc:\n........c += max([int(d,n) for d in r - dc])\n........dc = set(digits(c,n))\n....return c \n"}
{"sequence_id": "A260355", "text": "Table T(n,k) read by antidiagonals. T(n,k) is the minimum value of Sum_{i=1..n} Product_{j=1..k} r_j[i] where each r_j is a permutation of {1..n}.", "sequence": "1,1,3,1,4,6,1,6,10,10,1,8,18,20,15,1,12,33,44,35,21,1,16,60,96,89,56,28,1,24,108,214,231,162,84,36,1,32,198,472,600,484,271,120,45,1,48,360,1043,1564,1443,915,428,165,55,1,64,648,2304,4074,4320,3089,1608,642,220,66,1,96,1188,5136,10618", "code": "\nfrom itertools import permutations, combinations_with_replacement\ndef A260355(n,k): \n    if k == 1:\n        return n*(n+1)//2\n    ntuple, count = tuple(range(1,n+1)), n**(k+1)\n    for s in combinations_with_replacement(permutations(ntuple,n),k-2):\n        t = list(ntuple)\n        for d in s:\n            for i in range(n):\n                t[i] *= d[i]\n        t.sort()\n        v = 0\n        for i in range(n):\n            v += (n-i)*t[i]\n        if v < count:\n            count = v\n    return count\n"}
{"sequence_id": "A260373", "text": "The nearest perfect square to n!", "sequence": "1,1,1,4,25,121,729,5041,40401,362404,3629025,39917124,478996996,6226945921,87178467600,1307674583296,20922793332736,355687416544329,6402373660047556,121645100663836929,2432902009335560361,51090942169052381124,1124000727752683686724", "code": "\nfrom gmpy2 import isqrt\nA260373_list, g = [1], 1\nfor i in range(1, 101):\n....g *= i\n....s = isqrt(g)\n....t = s**2\n....A260373_list.append(int(t if g-t-s <= 0 else t+2*s+1)) \n"}
{"sequence_id": "A260374", "text": "The distance between n! and the nearest perfect square.", "sequence": "0,0,1,2,1,1,9,1,81,476,225,324,4604,74879,176400,215296,3444736,11551671,45680444,255004929,1158920361,2657058876,24923993276,130518272975,97216010329,2430400258225,1553580508516,4666092737476,538347188396016,2137864362693921", "code": "\nfrom gmpy2 import isqrt\nA260374_list, g = [0], 1\nfor i in range(1, 1001):\n....g *= i\n....s = isqrt(g)\n....t = g-s**2\n....A260374_list.append(int(t if t-s <= 0 else 2*s+1-t)) \n"}
{"sequence_id": "A260375", "text": "Numbers k such that A260374(k) is a perfect square.", "sequence": "0,1,2,4,5,6,7,8,10,11,14,15,16", "code": "\nfrom gmpy2 import isqrt, is_square\nA260375_list, g = [0], 1\nfor i in range(1, 1001):\n    g *= i\n    s = isqrt(g)\n    t = g-s**2\n    if is_square(t if t-s <= 0 else 2*s+1-t):\n        A260375_list.append(i) \n"}
{"sequence_id": "A260442", "text": "Sequence A260443 sorted into ascending order.", "sequence": "1,2,3,5,6,7,11,13,15,17,18,19,23,29,30,31,35,37,41,43,47,53,59,61,67,71,73,75,77,79,83,89,90,97,101,103,105,107,109,113,127,131,137,139,143,149,151,157,163,167,173,179,181,191,193,197,199,210,211,221,223,227,229,233,239,241,245,251,257,263,269,270,271,277,281,283,293,307,311", "code": "\nfrom sympy import factorint, prime, primepi\nfrom operator import mul\nfrom functools import reduce\ndef a048675(n):\n    F=factorint(n)\n    return 0 if n==1 else sum([F[i]*2**(primepi(i) - 1) for i in F])\ndef a003961(n):\n    F=factorint(n)\n    return 1 if n==1 else reduce(mul, [prime(primepi(i) + 1)**F[i] for i in F])\ndef a(n): return n + 1 if n<2 else a003961(a(n//2)) if n%2==0 else a((n - 1)//2)*a((n + 1)//2)\nprint([n for n in range(301) if a(a048675(n))==n]) \n"}
{"sequence_id": "A260443", "text": "Prime factorization representation of Stern polynomials: a(0) = 1, a(1) = 2, a(2n) = A003961(a(n)), a(2n+1) = a(n)*a(n+1).", "sequence": "1,2,3,6,5,18,15,30,7,90,75,270,35,450,105,210,11,630,525,6750,245,20250,2625,9450,77,15750,3675,47250,385,22050,1155,2310,13,6930,5775,330750,2695,3543750,128625,1653750,847,4961250,643125,53156250,18865,24806250,202125,727650,143,1212750,282975,57881250,29645,173643750,1414875,18191250,1001", "code": "\nfrom sympy import factorint, prime, primepi\nfrom functools import reduce\nfrom operator import mul\ndef a003961(n):\n    F = factorint(n)\n    return 1 if n==1 else reduce(mul, (prime(primepi(i) + 1)**F[i] for i in F))\ndef a(n): return n + 1 if n<2 else a003961(a(n//2)) if n%2==0 else a((n - 1)//2)*a((n + 1)//2)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A260483", "text": "Beatty sequence for e^(1/Pi) = A179706.", "sequence": "1,2,4,5,6,8,9,10,12,13,15,16,17,19,20,21,23,24,26,27,28,30,31,32,34,35,37,38,39,41,42,43,45,46,48,49,50,52,53,54,56,57,59,60,61,63,64,65,67,68,70,71,72,74,75,76,78,79,81,82,83,85", "code": "\nfrom sympy import  E, pi, floor\nfor n in range(1,101): print(floor(n*E**(1/pi)), end=', ')\n"}
{"sequence_id": "A260484", "text": "Complement of the Beatty sequence for e^(1/Pi) = A179706.", "sequence": "3,7,11,14,18,22,25,29,33,36,40,44,47,51,55,58,62,66,69,73,77,80,84,88,91,95,99,102,106,110,113,117,121,124,128,132,135,139,143,146,150,154,157,161,165,168,172,176,179,183,187,190,194,198", "code": "\nfrom sympy import E, pi, floor\nfor n in range(1,101): print(floor(n*E**(1/pi)/(E**(1/pi)-1)), end=', ')\n"}
{"sequence_id": "A260534", "text": "Square array read by ascending antidiagonals, T(n,k) = Sum_{j=0..k} n^j*(C(k-j,j) mod 2).", "sequence": "1,1,1,1,1,1,1,1,2,1,1,1,3,1,1,1,1,4,1,3,1,1,1,5,1,7,2,1,1,1,6,1,13,5,3,1,1,1,7,1,21,10,11,1,1,1,1,8,1,31,17,31,1,4,1,1,1,9,1,43,26,69,1,23,3,1,1,1,10,1,57,37,131,1,94,21,5,1,1,1,11", "code": "\ndef A260534_T(n,k):\n    return sum(0 if ~(k-j) & j else n**j for j in range(k+1)) \n"}
{"sequence_id": "A260550", "text": "a(n) is the number of 2 X 2 matrices with entries in {1, ..., n} that are not the product of two 2 X 2 positive integer matrices.", "sequence": "1,15,75,237,559,1157,2055,3471,5449,8131,11633,16361,22041,29349,38329,48839,61325,76479,93957,114717,138041,164153,194505,229625,268259,311031,359719,413245,472145,537835,608837,688121,774877,867549,971403,1080637,1198233,1326059,1467029,1617451,1777881,1948219,2132381,2329081,2539351", "code": " see link\n"}
{"sequence_id": "A260553", "text": "Primes p such that p = q^2 + 2*r^2 where q and r are also primes.", "sequence": "17,43,59,67,107,139,251,307,347,379,547,587,859,1699,1867,1931,3371,3499,3739,4507,5059,5347,6907,6971,7451,10091,10627,10667,11467,12491,18787,20411,21227,22907,29947,32059,32779,37547,38651,39619,49307,49747,53147", "code": "\nfrom sympy import prime, isprime\nn = 5000\nA260553_list, plimit = [], prime(n)**2+8\nfor i in range(1,n):\n....q = 2*prime(i)**2\n....for j in range(1,n):\n........p = q + prime(j)**2\n........if p < plimit and isprime(p):\n............A260553_list.append(p)\nA260553_list = sorted(A260553_list) \n"}
{"sequence_id": "A260556", "text": "Primes p such that p = q^2 + 8*r^2 where q and r are also primes.", "sequence": "41,97,193,241,401,433,601,977,1033,1361,1753,2281,2897,3793,4241,4561,5113,6737,6961,7993,10273,11953,12841,13457,17681,22273,22481,26641,27961,32833,37321,42641,49801,49937,54361,57193,58153,63073,63377,76801,94321", "code": "\nfrom sympy import prime, isprime\nn = 5000\nA260556_list, plimit = [], prime(n)**2+32\nfor i in range(1,n):\n....q = 8*prime(i)**2\n....for j in range(1,n):\n........p = q + prime(j)**2\n........if p < plimit and isprime(p):\n............A260556_list.append(p)\nA260556_list = sorted(A260556_list) \n"}
{"sequence_id": "A260597", "text": "Primes as they occur for the first time as factors of terms of A173426 = concatenation(1,2,...,n,n-1,...,1).", "sequence": "11,3,37,101,41,271,7,13,239,4649,73,137,333667,12345678910987654321,17636684157301569664903,2799473675762179389994681,1109,4729,2354041513534224607850261,571,3167,10723,439781,2068140300159522133,75401,687437,759077450603", "code": "\nfrom sympy import primefactors\nA260597_list = []\nfor n in range(1,10):\n    m = primefactors(int(''.join([str(d) for d in range(1,n+1)]+[str(d) for d in range(n-1,0,-1)])))\n    for p in m:\n        if not p in A260597_list:\nA260597_list.append(p) \n"}
{"sequence_id": "A260617", "text": "Three-dimensional array read by shells: S(i, j, k) = i + j + k; i >= 0, j >= 0, k >= 0.", "sequence": "0,1,1,2,1,2,2,3,2,3,2,3,4,3,4,3,4,5,2,3,4,3,4,5,4,5,6,3,4,5,3,4,5,6,4,5,6,4,5,6,7,5,6,7,5,6,7,8,3,4,5,6,4,5,6,7,5,6,7,8,6,7,8,9,4,5,6,7,4,5,6,7,8,5,6,7,8,5,6,7,8,9,6,7,8,9,6,7,8,9,10", "code": "\ns = lambda x,y,z : x+y+z \ni = 1\nfor n in range(0,10):\n..for x in range(0,n+1):\n....for y in range(0,n+1):\n......if (x!=n and y!=n):\n........print(i, s(x,y,n))\n........i += 1\n......else:\n........for z in range(0,n+1):\n..........print(i, s(x,y,z))\n..........i += 1\n\n"}
{"sequence_id": "A260627", "text": "Largest n-digit number missing in first 10^n digits after the decimal point in expansion of Pi.", "sequence": "8,96,997,9997,99997,999997,9999997,99999992,999999998", "code": "\nwith open(\"pi-billion.txt\", \"r\") as f:\n    for a in range(1,10):\n        g = f.read(10**a)\n        for x in reversed(range((10**a)-50,(10**a)-1)):\n            if g.find(str(x)) == -1:\n                print(a,x)\n                break\n\n\n"}
{"sequence_id": "A260628", "text": "Union of missing numbers in first 10, 100, 1000, 10000, ... digits after the decimal point in expansion of Pi.", "sequence": "0,7,8,12,13,18,22,24,29,31,36,47,52,54,55,56,57,60,61,63,66,68,72,73,76,77,85,87,90,91,96,103,106,107,108,114,123,124,125,126,131,135,140,143,144,149,150,154,156,157,158,161,162,163,166,167,168,175,180", "code": "\nwith open(\"newseq.txt\",\"w\") as keep:\n....for a in range(1, 8):\n........start = 0\n........best = 0\n........with open(\"pi-billion.txt\", \"r\") as f:\n............g = f.read(10**a)\n............while start < 10**a:\n................if g.find(str(start)) == -1:\n....................keep.write(str(start)+\"\\n\")\n....................best = start\n................start += 1\n\n\n"}
{"sequence_id": "A260636", "text": "a(n) = binomial(3n, n) mod n.", "sequence": "0,1,0,3,3,0,3,7,3,5,3,0,3,8,9,15,3,15,3,15,0,4,3,12,3,2,3,12,3,24,3,15,18,15,0,9,3,34,6,31,3,21,3,0,15,38,3,36,3,40,33,40,3,42,0,16,27,44,3,0,3,46,45,47,39,51,3,53,15,0,3,45,3,15,9,20,76,0,3,7,3", "code": "\nfrom __future__ import division\nA260636_list, b = [], 3\nfor n in range(1,10001):\n    A260636_list.append(b % n)\n    b = b*3*(3*n+2)*(3*n+1)//((2*n+2)*(2*n+1)) \n"}
{"sequence_id": "A260640", "text": "Numbers n such that binomial(3*n,n) == 0 (mod n).", "sequence": "1,3,6,12,21,35,44,55,60,70,78,88,90,99,102,110,117,119,120,133,156,171,176,180,184,204,207,220,225,230,231,234,238,240,247,252,255,285,286,300,312,341,342,348,360,368,372,391,403,408,414,425,434,460,462,465,468,481,483,494,495,504,506,510,550,555,561,572,574,585,600", "code": "\nfrom __future__ import division\nA260640_list, b = [], 3\nfor n in range(1,10**3):\n    if not b % n:\n        A260640_list.append(n)\n    b = b*3*(3*n+2)*(3*n+1)//((2*n+2)*(2*n+1)) \n"}
{"sequence_id": "A260674", "text": "Primes p for which the greatest common divisor of 2^p+1 and 3^p+1 is greater than 1.", "sequence": "2,83,107,367,569,887,1327,1451,1621,1987,2027,3307,3547,3631,3691,4421,4547,4967,5669,5843,5927,6011,6911,6991,7207,7949,8167,8431,10771,10889,11287,11621,12007,12227,12487,12763,12983,15391,15767,16127,17107,17183,17231", "code": "\nfrom sympy import prime\nfrom fractions import gcd\nA260674_list = [p for p in (prime(n) for n in range(1,10**3)) if gcd(2**p+1,3**p+1) > 1] \n"}
{"sequence_id": "A260688", "text": "a(n) = the least number of pieces of currency of denominations .01, .05, .10, .25, 1, 5, 10, 20, 50, 100 that the greedy algorithm uses to make n times .01 (n \"cents\") in change.", "sequence": "0,1,2,3,4,1,2,3,4,5,1,2,3,4,5,2,3,4,5,6,2,3,4,5,6,1,2,3,4,5,2,3,4,5,6,2,3,4,5,6,3,4,5,6,7,3,4,5,6,7,2,3,4,5,6,3,4,5,6,7,3,4,5,6,7,4,5,6,7,8,4,5,6,7,8,3,4,5,6,7,4,5,6,7,8,4,5,6,7,8,5,6,7,8,9,5,6,7,8,9", "code": "\ndef how_many(cents):\n    \n    d = ['$0.01', '$0.05', '$0.10', '$0.25',\n         '$1', '$5', '$10', '$20', '$50', '$100']\n    coins = {coin: 100*float(str(coin)[1:]) for coin in d}\n    how_many = {d[i]: 0 for i in range(10)}\n    while len(d) != 0:\n        how_many[d[-1]] = cents // coins[d[-1]]\n        cents %= coins[d[-1]]\n        d.pop()\n    return int(sum(how_many.values()))\n"}
{"sequence_id": "A260692", "text": "Binary representation of the n-th iteration of the \"Rule 17\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,1,1000,1001111,1000000,11001111111,1000000000,111001111111111,1000000000000,1111001111111111111,1000000000000000,11111001111111111111111,1000000000000000000,111111001111111111111111111,1000000000000000000000,1111111001111111111111111111111", "code": " print([(10*100**n - 990*1000**((n-1)//2) - 1)//9 if n%2 else 1000**(n//2) for n in range(50)]) \n"}
{"sequence_id": "A260726", "text": "a(n) = smallest palindrome k > n such that k/n is a square; a(n) = 0 if no solution exists.", "sequence": "4,8,363,484,5445,46464,252,2138312,12321,0,44,23232,31213,686,53187678135,44944,272,24642,171,0,525,88,575,46464,5221225,62426,36963,252,464,0,1783799973871,291080192,2112,4114,53235,69696,333,20102,93639,0,656,858858", "code": "\nfor k in range(1,150):\n....c=2\n....while c < 10**8:\n........kk=k*c**2\n........if kk==int(str(kk)[::-1])\n............print (k,kk)\n............c=10**9\n........c=c+1\n"}
{"sequence_id": "A260736", "text": "a(0) = 0; for n >= 1, a(n) = A000035(n) + a(A257684(n)); in the factorial representation of n the number of digits with maximal possible value allowed in its location.", "sequence": "0,1,0,1,1,2,0,1,0,1,1,2,0,1,0,1,1,2,1,2,1,2,2,3,0,1,0,1,1,2,0,1,0,1,1,2,0,1,0,1,1,2,1,2,1,2,2,3,0,1,0,1,1,2,0,1,0,1,1,2,0,1,0,1,1,2,1,2,1,2,2,3,0,1,0,1,1,2,0,1,0,1,1,2,0,1,0,1,1,2,1,2,1,2,2,3,1,2,1,2,2,3,1,2,1,2,2,3,1,2,1,2,2,3,2,3,2,3,3,4,0", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a257684(n):\n    x=str(a007623(n))[:-1]\n    y=\"\".join(str(int(i) - 1) if int(i)>0 else '0' for i in x)[::-1]\n    return 0 if n==1 else sum(int(y[i])*f(i + 1) for i in range(len(y)))\ndef a(n): return 0 if n==0 else n%2 + a(a257684(n))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A260796", "text": "Numbers n such that digit sum of prime(n) plus digit sum of prime(n+1) is prime.", "sequence": "1,15,37,46,47,73,91,102,107,111,118,121,123,129,161,165,187,195,197,199,203,219,239,240,242,263,275,290,292,300,326,329,357,363,388,412,416,423,426,465,470,472,504,506,539,553,565,606,611,630,641,647,660,667", "code": "\nfrom sympy import isprime, prime\nA260796_list = [n for n in range(1,10**5) if isprime(sum(int(d) for d in str(prime(n))+str(prime(n+1))))] \n"}
{"sequence_id": "A260802", "text": "Odd numbers x = 2n - 1 such that the concatenation of A019519(n) and A038395(n-1) is prime.", "sequence": "3,13,19,21,67", "code": "\nimport sympy\nn=1\nwhile n>0:\n....s=str(n)\n....for m in range(n-2,0,-2):\n........s=str(m)+s+str(m)\n....p=int(s)\n....if sympy.isprime(p)==True:\n........print(n)\n....n=n+2\n"}
{"sequence_id": "A260824", "text": "Least positive integer b such that b^(2^n)+1 is not squarefree.", "sequence": "3,7,110,40,392,894,315,48", "code": "\nfrom sympy.ntheory.factor_ import core\ndef a(n):\n  b, pow2, t = 1, 2**n, 2\n  while core(t, 2) == t:\n    b += 1\n    t = b**(pow2) + 1\n  return b\nprint([a(n) for n in range(4)]) \n"}
{"sequence_id": "A260827", "text": "Primes that contain only the digits (0, 5, 7).", "sequence": "5,7,557,577,757,5077,5507,5557,7057,7507,7577,7757,50077,50707,50777,55057,57077,57557,70507,75557,75577,75707,77557,500057,500777,505777,507077,507557,507757,550007,550577,550757,555077,555557,555707,557057,570077,575077", "code": "\nfrom sympy import isprime\nfrom sympy.utilities.iterables import multiset_permutations\ndef aupton(terms):\n  n, digits, alst = 0, 1, []\n  while len(alst) < terms:\n    mpstr = \"\".join(d*digits for d in \"057\")\n    for mp in multiset_permutations(mpstr, digits):\n      if mp[0] == \"0\": continue\n      t = int(\"\".join(mp))\n      if isprime(t): alst.append(t)\n      if len(alst) == terms: break\n    else: digits += 1\n  return alst\nprint(aupton(38)) \n"}
{"sequence_id": "A260828", "text": "Primes that contain only the digits (1, 5, 7).", "sequence": "5,7,11,17,71,151,157,557,571,577,751,757,1117,1151,1171,1511,1571,1777,5171,5557,5711,5717,7151,7177,7517,7577,7717,7757,11117,11171,11177,11551,11717,11777,15511,15551,17117,17551,51151,51157,51511,51517,51551,51577", "code": "\nfrom sympy import isprime\nfrom sympy.utilities.iterables import multiset_permutations\ndef aupton(terms):\n  n, digits, alst = 0, 1, []\n  while len(alst) < terms:\n    mpstr = \"\".join(d*digits for d in \"157\")\n    for mp in multiset_permutations(mpstr, digits):\n      t = int(\"\".join(mp))\n      if isprime(t): alst.append(t)\n      if len(alst) == terms: break\n    else: digits += 1\n  return alst\nprint(aupton(44)) \n"}
{"sequence_id": "A260873", "text": "Lexicographically first sequence of positive integers, every nonempty subset of which has a distinct mean.", "sequence": "1,2,4,8,16,32,104,321,1010,3056,9477,29437,91060,286574,919633", "code": "\nfrom copy import copy\nfrom fractions import Fraction\nfrom itertools import chain, combinations\ndef powerset(s):\n  return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\ndef distinct_means(means, lst, t):\n  newmeans = copy(means)\n  for subset in powerset(lst):\n    sm = Fraction(t+sum(subset), len(subset)+1)\n    if sm in newmeans: return False, means\n    else: newmeans.add(sm)\n  return True, newmeans\ndef aupto(n):\n  largest = 0\n  alst = []\n  prevmeans = set()\n  for k in range(n):\n    t = largest + 1\n    passes, means = distinct_means(prevmeans, alst, t)\n    while not passes:\n      t += 1\n      passes, means = distinct_means(prevmeans, alst, t)\n    alst.append(t)\n    largest = t\n    prevmeans = means\n  return alst\nprint(aupto(10)) \n"}
{"sequence_id": "A260915", "text": "Prime number days: prime numbers that can be interpreted as an ISO date.", "sequence": "10000103,10000121,10000223,10000303,10000511,10000609,10000721,10000723,10000813,10000819,10000831,10001009,10001107,10001119,10001203,10001207,10001209,10001213,10001221,10001227,10001231,10010101,10010113,10010213,10010227,10010311,10010317,10010323,10010401", "code": "\nimport datetime\n.\ndef prime_number_days():\n...j = 0\n...date = datetime.date(1000,1,1)\n...while date.year<2100:\n......x = int(date.strftime(\"%Y%m%d\"))\n......while primes[j]<x:\n.........j += 1\n......if primes[j]==x:\n.........yield x\n......date += datetime.timedelta(days=1)\n"}
{"sequence_id": "A260933", "text": "Lexicographically smallest permutation of the natural numbers, such that a(n)+n and a(n)+n+1 are both composite numbers.", "sequence": "7,6,5,4,3,2,1,12,11,10,9,8,13,18,17,16,15,14,19,24,23,22,21,20,25,28,27,26,33,32,31,30,29,34,39,38,37,36,35,40,43,42,41,46,45,44,47,50,49,48,53,52,51,56,55,54,57,58,59,60,61,62,65,64,63,66,67", "code": "\nfrom sympy import isprime\ndef composite(n): return n > 1 and not isprime(n)\ndef aupton(terms):\n    alst, aset = [], set()\n    for n in range(1, terms+1):\n        an = 1\n        while True:\n            while an in aset: an += 1\n            if composite(an+n) and composite(an+n+1): break\n            an += 1\n        alst, aset = alst + [an], aset | {an}\n    return alst\nprint(aupton(67)) \n"}
{"sequence_id": "A260959", "text": "Numbers n such that n is the average of four consecutive primes n-13, n-1, n+1 and n+13.", "sequence": "7950,10500,32970,33330,34470,36900,43050,66360,71550,74610,87120,89070,92400,94560,95190,102000,104310,121950,125790,133980,148470,156900,160710,168630,174930,182640,194070,204600,206250,230340,244380,246510", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,300001,2):\n.. if isprime(i-1) and isprime(i+1):\n....if prevprime(i-1) == i-13 and nextprime(i+1) == i+13 :  print (i,end=', ')\n"}
{"sequence_id": "A260985", "text": "Numbers n such that A001222(n) - A001221(n) is an odd prime.", "sequence": "16,48,64,72,80,81,108,112,162,176,192,200,208,240,256,272,288,304,320,336,360,368,392,405,432,448,464,496,500,504,528,540,560,567,592,600,624,625,648,656,675,688,704,729,752,756,768,792,800,810,816,832,848", "code": "\nfrom sympy import isprime, primefactors\ndef omega(n): return 0 if n==1 else len(primefactors(n))\ndef bigomega(n): return 0 if n==1 else bigomega(n//min(primefactors(n))) + 1\ndef ok(n):\n    d = bigomega(n) - omega(n)\n    return d%2 and isprime(d)\nprint([n for n in range(1, 1001) if ok(n)]) \n"}
{"sequence_id": "A261010", "text": "Write 5^n in base 3, add up the \"digits\".", "sequence": "1,3,5,7,7,9,9,13,15,13,13,17,19,21,21,27,25,25,25,23,27,33,31,39,35,45,37,57,45,47,45,45,53,47,55,51,57,59,67,67,69,65,67,65,71,79,71,65,67,75,65,71,73,83,69,79,81,85,79,89,87,95,89,85,97,99,93,101,107", "code": "\ndef digits(n, b=10): \n    x, y = n, ''\n    while x >= b:\n        x, r = divmod(x,b)\n        y += str(r) if r < 10 else (chr(r+87) if r < 36 else chr(r+29))\n    y += str(x) if x < 10 else (chr(x+87) if x < 36 else chr(x+29))\n    return y[::-1]\ndef A261010(n):\n    return sum([int(d) for d in digits(5**n,3)]) \n"}
{"sequence_id": "A261011", "text": "Positive integers n such that ceiling(n^(1/3)) divides n.", "sequence": "1,2,4,6,8,9,12,15,18,21,24,27,28,32,36,40,44,48,52,56,60,64,65,70,75,80,85,90,95,100,105,110,115,120,125,126,132,138,144,150,156,162,168,174,180,186,192,198,204,210,216,217,224,231,238,245,252,259", "code": "\nfrom gmpy2 import iroot\nA261011_list = [n for n in range(1,10**5) if not n % (lambda x:x[0] + (0 if x[1] else 1))(iroot(n,3))] \n"}
{"sequence_id": "A261018", "text": "First differences of A260273.", "sequence": "2,2,3,3,4,2,3,3,4,4,2,3,3,5,7,5,5,4,3,3,5,5,3,3,4,4,4,5,7,4,5,5,4,3,3,5,5,3,3,6,8,3,3,4,4,7,4,4,5,5,5,7,7,4,5,9,5,4,4,4,3,3,3,6,3,3,6,9,5,6,5,7,8,3,3,6,3,3,4,4,4,7,4,4,8,4,4,5,5", "code": "\nA261018_list, a = [], 1\nfor i in range(10**3):\n    b, s = 1, format(a,'b')\n    while format(b,'b') in s:\n        b += 1\n    a += b\n    s = format(a,'b')\n    A261018_list.append(b) \n"}
{"sequence_id": "A261175", "text": "Number of digits of Hyperfactorial(n).", "sequence": "1,1,1,3,5,8,13,19,26,35,45,56,69,84,100,117,137,158,180,204,231,258,288,319,352,387,424,463,503,546,590,636,684,734,786,840,897,955,1015,1077,1141,1207,1275,1345,1418,1492,1568,1647,1728,1811,1896,1983,2072,2163,2257,2352", "code": "\nA261175_list, n = [], 1\nfor i in range(100):\n    n *= i**i\nA261175_list.append(len(str(n)))  \n"}
{"sequence_id": "A261182", "text": "Primes that contain only the digits (2, 7, 9).", "sequence": "2,7,29,79,97,227,229,277,727,797,929,977,997,2297,2729,2777,2797,2927,2999,7229,7297,7727,7927,9227,9277,9929,22229,22277,22279,22727,22777,27277,27299,27779,27799,27997,29297,29927,72227,72229,72277,72727,72797", "code": "\nfrom gmpy2 import is_prime\nfrom itertools import product\nA261182_list = [int(''.join(d)) for l in range(1,10) for d in product('279',repeat=l) if is_prime(int(''.join(d)))] \n"}
{"sequence_id": "A261194", "text": "Encoded square binary matrices representing an idempotent relation.", "sequence": "0,1,3,5,9,11,16,17,18,19,20,21,23,25,27,33,37,49,53,65,67,73,75,81,83,89,91,141,144,145,148,149,153,154,155,157,159,181,209,217,219,272,273,274,275,283,291,305,307,308,309,311,337,339,347,513,517,529", "code": "\ndef getBitIndex(i, j):\n..return (i+j)*(i+j+1)/2 + j\ndef getBit(mat, i, j):\n..return (mat >> getBitIndex(i,j)) & 1\ndef setBit(mat, i, j):\n..return mat | (1 << getBitIndex(i,j))\ndef noBitLeft(mat, i, j):\n..return mat >> getBitIndex(i,j) == 0\ndef squarematrix(mat):\n..result = 0;\n..i = 0\n..while True:\n....if noBitLeft(mat, i, 0):\n......return result\n....j = 0;\n....while True:\n......if noBitLeft(mat, 0, j):\n........break\n......k = 0\n......while True:\n........if noBitLeft(mat, i, k):\n..........break\n........if getBit(mat, i, k) & getBit(mat, k, j):\n..........result = setBit(result, i, j)\n..........break\n........k += 1\n......j += 1\n....i += 1\n..return result\nindex = 0\nmat = 0\nwhile True:\n..if mat == squarematrix(mat):\n....print index, mat\n....index += 1\n..mat += 1\n"}
{"sequence_id": "A261231", "text": "a(n) = number of steps to reach 0 when starting from k = n and repeatedly applying the map that replaces k with k - (sum of digits in base-3 representation of k).", "sequence": "0,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,8,8,8,8,8,8,9,9,9,10,10,10,11,11,11,12,12,12,13,13,13,13,13,13,14,14,14,14,14,14,15,15,15,16,16,16,17,17,17,17,17,17,18,18,18,18,18,18,19,19,19,19,19,19,20,20,20,20,20,20,21,21,21,22,22,22,23,23,23,24,24,24", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a054861(n): return (n - sum(digits(n, 3)[1:]))/2\ndef a(n): return 0 if n==0 else 1 + a(2*a054861(n)) \n"}
{"sequence_id": "A261280", "text": "Number of ways to start with set {1,2,...,n} and then repeat n times: partition each set into subsets.", "sequence": "1,1,3,22,315,7556,274778,14140722,979687005,87998832685,9951699489061,1384060090903535,232230523534594676,46265730933522733556,10797461309089628151462,2918087323005280354349508,904185772556792011572372117,318432010852077710049833537040", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef A(n, k): return 1 if n==0 or k==0 else sum(binomial(n - 1, j - 1)*A(j, k - 1)*A(n - j, k) for j in range(1, n + 1))\ndef a(n): return A(n, n)\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A261296", "text": "Smaller of pairs (m, n), such that the difference of their squares is a cube and the difference of their cubes is a square.", "sequence": "6,384,4374,5687,24576,17576,27783,64350,93750,354375,279936,113750,363968,166972,370656,705894,263736,1572864,1124864,1778112,3187744,4225760,4118400,3795000,3188646,4145823,4697550,1111158,730575,6000000,8171316,2413071,8573750", "code": "\ndef cube(z,p):\n....iscube=False\n....y=int(pow(z,1/p)+0.01)\n....if y**p==z:\n........iscube=True\n....return iscube\nfor n in range (1,10**5):\n....for m in range(n+1,10**5):\n........a=(m-n)*(m**2+m*n+n**2)\n........b=(m-n)*(m+n)\n........if cube(a,2)==True and cube(b,3)==True:\n............print (n,m)\n"}
{"sequence_id": "A261328", "text": "Larger of pairs (m, n), such that the difference of their squares is a cube and the difference of their cubes is a square.", "sequence": "10,640,7290,8954,40960,52728,55566,70434,156250,405000,466560,536250,573056,960089,997920,1176490,2037960,2621440,3374592,3556224,3748745,4379424,4507776,5005000,5314410,6527466,6742450,7778106,8938800,10000000,10214145,12065355", "code": "\n\nfrom __future__ import division\nfrom sympy import divisors\nfrom gmpy2 import is_square\nalist = []\nfor i in range(1,10000):\n    c = i**3\n    for d in divisors(c, generator=True):\n        d2 = c//d\n        if d >= d2:\n            m, r = divmod(d+d2,2)\n            if not r:\n                n = m-d2\n                if n > 0 and (m,n) not in alist and is_square(c*m+d2*n**2):\n                    alist.append((m,n))\nA261328_list, A261296_list = zip(*sorted(alist)) \n"}
{"sequence_id": "A261393", "text": "Additive terms of the rational Collatz tree.", "sequence": "0,1,2,4,4,5,8,13,8,7,10,14,16,17,26,40,16,11,14,16,20,19,28,41,32,25,34,44,52,53,80,121,32,19,22,20,28,23,32,43,40,29,38,46,56,55,82,122,64,41,50,52,68,61,88,125,104,79,106,134", "code": "\ndef h(n):\n  if(n == 0):     return 0\n  elif(n%2 == 0): return h(n/2)\n  else:           return h((n-1)/2) + 1\ndef a(n):\n  if(n == 0):     return 0\n  elif(n%2 == 0): return 2*a(n/2)\n  else:           return a((n-1)/2) + 3**h((n-1)/2)\n"}
{"sequence_id": "A261423", "text": "Largest palindrome <= n.", "sequence": "0,1,2,3,4,5,6,7,8,9,9,11,11,11,11,11,11,11,11,11,11,11,22,22,22,22,22,22,22,22,22,22,22,33,33,33,33,33,33,33,33,33,33,33,44,44,44,44,44,44,44,44,44,44,44,55,55,55,55,55,55,55,55,55,55,55,66,66,66,66,66,66,66,66,66,66,66,77,77", "code": "\ndef P(n):\n    s = str(n); h = s[:(len(s)+1)//2]; return int(h + h[-1-len(s)%2::-1])\ndef a(n):\n    s = str(n)\n    if s == '1'+'0'*(len(s)-1) and n > 1: return n - 1\n    Pn = P(n)\n    return Pn if Pn <= n else P(n - 10**(len(s)//2))\nprint([a(n) for n in range(79)]) \n"}
{"sequence_id": "A261433", "text": "k-digit integers equal to the sum of the k-th powers of the tens' complements of their digits.", "sequence": "5,378,91882,3762938,46478818,564426414", "code": "\nfrom itertools import combinations_with_replacement\nA261433_list = []\nfor k in range(1,10):\n    a, k10 = tuple([i**k for i in range(10,0,-1)]), 10**k\n    for b in combinations_with_replacement(range(1,10),k):\n        x = sum(list(map(lambda y:a[y],b)))\n        if x < k10 and tuple(int(d) for d in sorted(str(x))) == b:\n            A261433_list.append(x)\nA261433_list = sorted(A261433_list) \n"}
{"sequence_id": "A261459", "text": "Numbers n such that the concatenation of n 1's, the digits of n^2 + n + 1, and n 1's is prime.", "sequence": "1,3,4,5,6,10,254,410,751,1101,2488,3476", "code": "\nfrom gmpy2 import is_prime\nA261459_list = [k for k in range(10**3) if is_prime(int('1'*k+str(k*(k+1)+1)+'1'*k))]\n"}
{"sequence_id": "A261521", "text": "a(n) =  n^2 + 2*n + 29.", "sequence": "29,32,37,44,53,64,77,92,109,128,149,172,197,224,253,284,317,352,389,428,469,512,557,604,653,704,757,812,869,928,989,1052,1117,1184,1253,1324,1397,1472,1549,1628,1709,1792,1877,1964,2053,2144,2237,2332,2429,2528", "code": " def a(x):return x*x+2*x+27\n"}
{"sequence_id": "A261534", "text": "Nonprime palindromes n with only the digits 0, 1, 2 such that the product of divisors of n is also a palindrome.", "sequence": "1,22,111,121,202,1001,1111,10001,10201,11111,100001,1000001,1001001,1012101,1100011,1101011,1111111,10000001,100000001,101000101,110000011,200010002,10000000001,10011111001,11000100011,11001010011,11100100111,11101010111,20000100002", "code": "\nfrom __future__ import division\nfrom sympy import divisor_count\nfrom gmpy2 import isqrt, t_divmod, digits\ndef palgen(l,b=10): \n    if l > 0:\n        yield 0\n        for x in range(1,l+1):\n            n = b**(x-1)\n            n2 = n*b\n            for y in range(n,n2):\n                k, m = y//b, 0\n                while k >= b:\n                    k, r = t_divmod(k,b)\n                    m = b*m + r\n                yield y*n + b*m + k\n            for y in range(n,n2):\n                k, m = y, 0\n                while k >= b:\n                    k, r = t_divmod(k,b)\n                    m = b*m + r\n                yield y*n2 + b*m + k\nA261534_list = [1]\nfor m in palgen(17,3):\n    n = int(digits(m,3))\n    d = int(divisor_count(n))\n    if d > 2:\n        q, r = t_divmod(d,2)\n        s = digits(n**q*(isqrt(n) if r else 1))\n        if s == s[::-1]:\n            A261534_list.append(n)\n"}
{"sequence_id": "A261573", "text": "A variation of Recam\u00e1n's sequence A005132: Define a(0) = 0, and for n > 0, a(n) = a(n-1) - (n+2) if positive and not already in the sequence, otherwise a(n) = a(n-1) + (n+2).", "sequence": "0,3,7,2,8,1,9,18,28,17,5,18,4,19,35,52,34,15,35,14,36,13,37,12,38,11,39,10,40,71,103,70,104,69,33,70,32,71,31,72,30,73,29,74,120,167,119,168,118,67,119,66,120,65,121,64,6,65,125,186,124,61,125,60,126,59,127,58,128,57", "code": "\ndef sequence(n, k):\n    \"\"\"For n > 0 and k >= 0, generates the first n terms of the sequence\"\"\"\n    A, a = {0}, 0\n    yield a\n    for n in range(1, n + 1):\n        a = a - (n + k)\n        if a > 0 and a not in A:\n            A.add(a)\n            yield a\n        else:\n            a = a + 2 * (n + k)\n            A.add(a)\n            yield a\n\nlist(sequence(1000, 2))\n"}
{"sequence_id": "A261593", "text": "Odd numbers n such that the sum of the binary digits of n and n^2 both equal 12.", "sequence": "4095,10239,11263,12159,12223,12255,12271,12279,12283,14333,15351,15355,15743,15807,18431,19455,19967,20351,20477,22015,22495,22511,24031,24303,24431,24445,25599,26615,26621,27519,27631,27639,28095,28411,28413,28511,28541,28575", "code": "\nfrom itertools import combinations\nA261593_list = []\nfor c in combinations((2**x for x in range(15)),11):\n    n = sum(c)\n    if sum(int(d) for d in format(n*(n+1),'b')) == 11:\n        A261593_list.append(2*n+1)\nA261593_list = sorted(A261593_list) \n"}
{"sequence_id": "A261694", "text": "a(n) = Fibonacci(n) mod 21.", "sequence": "0,1,1,2,3,5,8,13,0,13,13,5,18,2,20,1,0,1,1,2,3,5,8,13,0,13,13,5,18,2,20,1,0,1,1,2,3,5,8,13,0,13,13,5,18,2,20,1,0,1,1,2,3,5,8,13,0,13,13,5,18,2,20,1,0,1,1,2,3,5,8,13,0,13,13,5,18,2,20,1,0,1,1,2,3,5,8,13,0,13", "code": "\nA261694_list, a, b, = [], 0, 1\nfor _ in range(10**3):\n    A261694_list.append(a)\n    a, b = b, (a+b) % 21 \n"}
{"sequence_id": "A261749", "text": "Numbers k where k^2 is an anagram of (k+2)^2.", "sequence": "206,224,314,1799,2006,11087,13364,15839,17153,17324,20006,22184,22706,24524,24542,40031,40247,45314,47069,48824,55556,61694,64691,70559,71351,89774,90224,102374,108251,112292,129824,132506,137987,151757,154295,157706,162089,167273,170324,171557,175031", "code": "\nA261749_list = [n for n in range(1,10**6) if sorted(str(n**2)) == sorted(str((n+2)**2))] \n"}
{"sequence_id": "A261807", "text": "a(n) = n XOR n^3.", "sequence": "0,0,10,24,68,120,222,336,520,720,994,1336,1740,2200,2742,3360,4112,4896,5850,6872,8020,9272,10638,12176,13848,15632,17586,19704,21980,24408,26982,29760,32800,35904,39338,42840,46692,50680,54910,59280,64040,68880,74050,79544", "code": "\nfor n in range(55): print(str(n ^ n*n*n), end=\",\")\n"}
{"sequence_id": "A261812", "text": "First differences of A098842.", "sequence": "-2,0,-1,1,0,0,-1,1,0,0,0,-1,1,0,0,0,-1,1,0,0,-1,1,0,0,0,-1,1,0,0,0,-1,1,0,0,-1,1,0,0,0,-1,1,0,0,-1,1,0,0,0,-1,1,0,0,0,-1,1,0,0,-1,1,0,0,0,-1,1,0,0,0,-1,1,0,0,-1,1,0,0,0,-1,1,0,0,0,-1,1,0,0,-1,1,0,0,0,-1,1,0,0,0,-1,1,0,0,-1,1,0,0,0,-1,1,0,0,0,-1,1,0,0,-1,1,0,0,0,-1,1,0,0,0,-1,1,0,0,-1,1,0,0,0,-1,1,0,0", "code": "\nimport sys\nimport math\nF = [F0,F1] = [0,1]\nc = 2\nc0 = 0\nll0 = 1\nwhile True:\n        T = F[0] + F[1]\n        F[0] = F[1]\n        F[1] = T\n        dfn = 1 + math.log10(T)\n        ll = math.floor(dfn)\n        if ll0 != ll:\n                if c0 != 0:\n                        sys.stdout.write(\"%d,\" % (c-c0))\n                ll0 = ll\n                c0 = c\n                c = 1\n                continue\n        c += 1\n"}
{"sequence_id": "A262068", "text": "Number of binary strings of length 2n that can be written as the concatenation of one or more squares.", "sequence": "1,2,6,22,76,268,926,3250,11328,39658,138534,484364,1693078,5918780,20690230,72328158,252841374,883869956,3089791576,10801141656", "code": " \nfrom numba import njit\n@njit()  \ndef a(n):\n  if n == 0: return 1  \n  s = 0\n  for b in range(int(2**(2*n-1))):\n    s += MS(b, n) >= 1\n  return 2*s\nprint([a(n) for n in range(10)]) \n"}
{"sequence_id": "A262069", "text": "Palindromes in base 10 that are also palindromes in base 60.", "sequence": "0,1,2,3,4,5,6,7,8,9,11,22,33,44,55,55155,55455,55755,57075,57375,113311,148841,2796972,8372738,11166111,14033041,26233262,28933982,150050051,151141151,152070251,152232251,153161351,153323351,154252451,154414451,155343551,155505551", "code": "\ndef palgen(l,b=10): \n    if l > 0:\n        yield 0\n        for x in range(1,l+1):\n            n = b**(x-1)\n            n2 = n*b\n            for y in range(n,n2):\n                k, m = y//b, 0\n                while k >= b:\n                    k, r = divmod(k,b)\n                    m = b*m + r\n                yield y*n + b*m + k\n            for y in range(n,n2):\n                k, m = y, 0\n                while k >= b:\n                    k, r = divmod(k,b)\n                    m = b*m + r\n                yield y*n2 + b*m + k\nA262069_list = [n for n in palgen(5,60) if str(n) == str(n)[::-1]] \n"}
{"sequence_id": "A262091", "text": "Amicable digital pairs: The smaller number of a pair (x,y) with x <> y such that, in decimal notation and with an appropriate number of leading zeros prepended, x=(x_m...x_1x_0)_{10}, y=(y_m...y_1y_0)_{10}, x = y_m^m + ... + y_1^m + y_0^m, and y = x_m^m + ... + x_1^m + x_0^m.", "sequence": "136,919,2178,58618,89883,63804,2755907,8139850,144839908,277668893,304162700,4370652168,21914086555935085,187864919457180831,13397885590701080090,19095442247273220984552,108493282045082839040458,1553298727699254868304830", "code": "\n\nfrom __future__ import print_function\nfrom itertools import combinations_with_replacement\nfor m in range(2,11):\n    fs = '0'+str(m+1)+'d'\n    for c in combinations_with_replacement(range(10),m+1):\n        n = sum(d**m for d in c)\n        r = sum(int(q)**m for q in str(n))\n        rlist = sorted(int(d) for d in str(r))\n        rlist = [0]*(m+1-len(rlist))+rlist\n        if n < r and rlist == list(c):\n            print(format(n,fs),format(r,fs)) \n"}
{"sequence_id": "A262123", "text": "a(1) + a(2) + ... + a(n) is the representation as a sum of n squares of the smallest integer needing n squares (using the greedy algorithm).", "sequence": "1,1,1,4,16,144,7056,13046544,42600214749456,453694852221644777216198544", "code": "\ndef list_a(n):\n....list=[1,1,1,4];root=2;length=4\n....while length<n:\n........root=root**2//2+root\n........list.append(root**2)\n........length+=1\n....return list\nlist_a(12)\n"}
{"sequence_id": "A262176", "text": "Numbers n where n-17, n-1, n+1 and n+17 are consecutive primes.", "sequence": "3390,66570,70140,84810,132330,136710,222840,225750,242730,271770,288930,320010,330330,377370,390390,414330,463890,489960,505710,644670,758340,819390,830310,857010,895650,906540,908910,924810,952380,968520,974820", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,3000001,6):\n..if isprime(i-1) and isprime(i+1) and prevprime(i-1)==i-17 and nextprime(i+1)==i+17 : print (i,end=', ')\n"}
{"sequence_id": "A262182", "text": "Prime numbers of the form (n*(n+1)/2)^2 + 1.", "sequence": "2,37,101,1297,4357,14401,44101,90001,164837,246017,608401,894917,1382977,4326401,8122501,8561477,9985601,10497601,38638657,46049797,52707601,84272401,121572677,146168101,165894401,201526417,259532101,289680401,404010001,428738437", "code": "\ndef prime(n):\n    if n == 1: return True\n    d = n + 1\n    c = n - 1\n    while c > 0 and d % c:\n        d += n\n        c -= 1\n    return bool(c == 1)\nn = 1\ni = 1\nwhile i <= 500:\n    target = (i * (i + 1)) // 2\n    if prime(target):\n        print(n, target*target+1)\n        n += 1\n    i += 1\n\n"}
{"sequence_id": "A262222", "text": "Decimal representations of hexadecimal numbers that can be misinterpreted as decimal numbers in scientific E notation.", "sequence": "480,481,482,483,484,485,486,487,488,489,736,737,738,739,740,741,742,743,744,745,992,993,994,995,996,997,998,999,1000,1001,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1504,1505,1506,1507,1508,1509,1510,1511", "code": "\nfrom itertools import count,product\n\ndef mids(d):\n    if d<1:\n        raise Exception(\"d<1\")\n    if d==1:\n        yield 'e'\n        return\n    for i in range(0,10):\n        for m in mids(d-1):\n            yield str(i)+m\n    for i in range(10**(d-1)):\n        yield 'e'+str(i).zfill(d-1)\ndef a_generator():\n    for d in count(1):\n        for start in range(1,10): \n            for mid in mids(d): \n                for end in range(10): \n                    s = '{}{}{}'.format(start,''.join(mid),end)\n                    i = int(s,16)\n                    yield i\na262222 = a_generator()\n[next(a262222) for _ in range(48)] \n"}
{"sequence_id": "A262242", "text": "Triangular numbers representable as 2^x + 2^y.", "sequence": "3,6,10,36,66,136,528,2080,8256,32896,131328,524800,2098176,8390656,33558528,134225920,536887296,2147516416,8590000128,34359869440,137439215616,549756338176,2199024304128,8796095119360,35184376283136,140737496743936,562949970198528", "code": "\ndef isTriangular(a):\n    sr = 1 << (int.bit_length(a) >> 1)\n    a += a\n    while a < sr*(sr+1):  sr>>=1\n    b = sr>>1\n    while b:\n      s = sr+b\n      if a >= s*(s+1):  sr = s\n      b>>=1\n    return (a==sr*(sr+1))\nfor a in range(1,200):\n    for b in range(a):\n        c = (1<<a) + (1<<b)\n        if isTriangular(c): print(str(c), end=',')\n"}
{"sequence_id": "A262249", "text": "Maximum possible number of distinct abelian squares occurring in a binary word of length n.", "sequence": "0,1,1,2,3,4,5,7,9,11,13,15,17,21,23,26,30,34,38,43,47,52,57,62,65,71,76,83,89,95,100,108,114,122", "code": "\nfrom itertools import product, permutations\ndef a(n): \n  ar = (\"\".join(u) for r in range(1, n//2+1) for u in product(\"01\", repeat=r))\n  abel_squares = set(w+\"\".join(wp) for w in ar for wp in permutations(w))\n  words = (\"0\"+\"\".join(w) for w in product(\"10\", repeat=n-1))\n  return max(sum(s in w for s in abel_squares) for w in words)\nprint([a(n) for n in range(1, 14)]) \n"}
{"sequence_id": "A262251", "text": "Triangular numbers representable as 2^x + 3^y.", "sequence": "3,10,28,91", "code": "\nfrom sympy import integer_nthroot\ndef auptoexponent(maxexp):\n  sums = set(2**x + 3**y for x in range(maxexp) for y in range(maxexp))\n  iroots = set(integer_nthroot(2*s, 2)[0] for s in sums)\n  return sorted(set(r*(r+1)//2 for r in iroots if r*(r+1)//2 in sums))\nprint(auptoexponent(500)) \n"}
{"sequence_id": "A262265", "text": "Maximum possible number of inequivalent abelian squares occurring in a binary word of length n", "sequence": "0,1,1,2,3,4,4,6,6,7,8,10,10,11,12,15,16,17,17,19,21,22,23,25,26,28,29,31,32,34,36,37,39,41", "code": "\nfrom itertools import product, permutations\ndef a(n): \n  ar = (\"\".join(u) for r in range(1, n//2+1) for u in product(\"01\", repeat=r))\n  abel_squares = set(w+\"\".join(wp) for w in ar for wp in permutations(w))\n  words = (\"0\"+\"\".join(w) for w in product(\"10\", repeat=n-1))\n  maxn = -1\n  for w in words:\n    seen = set()\n    for s in abel_squares:\n      if s in w: seen.add(tuple(sorted(s)))\n    maxn = max(maxn, len(seen))\n  return maxn\nprint([a(n) for n in range(1, 14)]) \n"}
{"sequence_id": "A262278", "text": "Number of binary strings of length 2n that are squares, but are not expressible as the concatenation of two or more squares.", "sequence": "0,2,2,6,10,24,40,92,164,408,704,1674,3036,7002,12688,29040,53034,119502,219152,487924,900686,1984664,3683632,8039958,15012858,32477788,60988590,130889590,247193588,526601802,999873640,2115798292", "code": "\nfrom numba import njit\n@njit() \ndef MS(b, k):\n  if b == 0: return k\n  r = -1\n  for i in range(1, k+1):\n    if ((b^(b>>i)) & ((1<<i)-1)) == 0:\n      r = max(r, MS(b>>(2*i), k-i))\n  return r+1 if r >= 0 else r\n@njit() \ndef a(n):\n  s = 0\n  for i in range(int(2**(n-1))):\n    s += MS((i<<n)|i, n)==1\n  return 2*s\nprint([a(n) for n in range(18)]) \n"}
{"sequence_id": "A262323", "text": "Lexicographically earliest sequence of distinct terms such that the decimal representations of two consecutive terms overlap.", "sequence": "1,10,11,12,2,20,22,21,13,3,23,30,33,31,14,4,24,32,25,5,15,41,16,6,26,42,27,7,17,51,18,8,28,52,29,9,19,61,36,43,34,40,44,45,50,35,53,37,63,38,73,39,83,48,54,46,60,56,55,57,65,58,75,47,64,49,74", "code": "\ndef overlaps(a, b):\n  s, t = sorted([str(a), str(b)], key = lambda x: len(x))\n  if any(t.startswith(s[i:]) for i in range(len(s))): return True\n  return any(t.endswith(s[:i]) for i in range(1, len(s)+1))\ndef aupto(nn):\n  alst, aset = [1], {1}\n  for n in range(2, nn+1):\n    an = 1\n    while True:\n      while an in aset: an += 1\n      if overlaps(an, alst[-1]): alst.append(an); aset.add(an); break\n      an += 1\n  return alst\nprint(aupto(67)) \n"}
{"sequence_id": "A262361", "text": "a(n) = L(L(L(n))), where L(n) are Lucas numbers A000032.", "sequence": "4,1,7,29,1149851,387739824812222466915538827541705412334749", "code": "\nfrom sympy import lucas as L\ndef a(n):  return L(L(L(n)))\nprint([a(n) for n in range(6)]) \n"}
{"sequence_id": "A262571", "text": "Concatenation of the numbers from 2 to n.", "sequence": "2,23,234,2345,23456,234567,2345678,23456789,2345678910,234567891011,23456789101112,2345678910111213,234567891011121314,23456789101112131415,2345678910111213141516,234567891011121314151617,23456789101112131415161718,2345678910111213141516171819", "code": "\ndef a(n): return int(\"\".join(map(str, range(2, n+1))))\nprint([a(n) for n in range(2, 20)]) \n"}
{"sequence_id": "A262668", "text": "Numbers n such that n-19, n-1, n+1 and n+19 are consecutive primes.", "sequence": "20982,28182,51768,57222,76422,87720,90678,104850,108108,110730,141180,199602,227112,248118,264600,268842,304392,304458,320082,322920,330018,382728,401670,414432,429972,450258,467082,489408,520548,535608,540120", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,1000001,6):\n..if isprime(i-1) and isprime(i+1):\n....if prevprime(i-1) == i-19 and nextprime(i+1) == i+19 : print(i,end=', ')\n"}
{"sequence_id": "A262713", "text": "Numbers k such that the sum of digits of k^2 is 10.", "sequence": "8,19,35,46,55,71,80,145,152,179,190,251,332,350,361,449,451,460,548,550,649,710,800,1450,1520,1790,1900,2510,3320,3500,3610,4490,4499,4510,4600,5480,5500,6490,7100,8000,14500,15200,17900,19000,20249,20251,24499", "code": " \ndef ok(n): return sum(map(int, str(n*n))) == 10\nprint(list(filter(ok, range(25000)))) \n"}
{"sequence_id": "A262719", "text": "a(n) is the smallest nonnegative k such that there is no 3 X 3 matrix with entries in {1,...,n} whose determinant is k.", "sequence": "1,6,21,55,110,203,357,544,808,1177,1670,2215,2865,3599,4558,5621,6637,8041,9769,11413,13394,15593,17683,20317,23249,26063,29506,33287,37461,41692,46306,50707,55667,61723,67547,73939,80767,87941,94913,101613,111422", "code": "\nfrom itertools import product,groupby,count\n.\ndef det(m):\n...a,b,c,d,e,f,g,h,i = m\n...return abs(a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g))\n.\ndef a262719(n):\n...s = list(product(range(1,n+1),repeat=9))\n...i = 0\n...for k,ms in groupby(sorted(s,key=det),key=det):\n......if k!=i:\n.........return i\n......i += 1\n...return i\n"}
{"sequence_id": "A262769", "text": "Integers k such that the concatenation of 2^k and k is prime.", "sequence": "3,23,63,261,281,291,4689,11231,12519", "code": "\nfrom sympy import isprime\ndef afind(limit):\n  k, twok = 0, 1\n  while k <= limit:\n    if isprime(int(str(twok) + str(k))): print(k, end = \", \")\n    k, twok = k+1, twok*2\nafind(2000) \n"}
{"sequence_id": "A262776", "text": "a(n) = Fibonacci(n!) mod Fibonacci(n)!.", "sequence": "0,0,0,0,0,0,20160,1098377280,10712200669548618240,157910199555786679826546221836620444160,12162675222629942931022379230724715707339402614012620710827200735689241600", "code": "\nfrom gmpy2 import fac, fib\ndef A262776(n):\n    if n < 2:\n        return 0\n    a, b, m = 0, 1, fac(fib(n))\n    for i in range(fac(n)-1):\n        b, a = (b+a) % m, b\n    return int(b) \n"}
{"sequence_id": "A262814", "text": "Numbers k dividing every cyclic permutation of k^k.", "sequence": "1,2,3,7,9,11,27,63,99,111,129,159,231,271,273,303,333,351,357,403,457,711,991,999,1111,1147,1241,2121,2479,4227,4653,5151,5547,5837,6191,6237,6643,6993,7133,8229,8547,8683,8811,8987,9009,9633,9999,11009,13449,13531", "code": "\nA262814_list = []\nfor k in range(1,10**3):\n    n = k**k\n    if not n % k:\n        s = str(n)\n        for i in range(len(s)-1):\n            s = s[1:]+s[0]\n            if int(s) % k:\n                break\n        else:\n            A262814_list.append(k) \n"}
{"sequence_id": "A262861", "text": "Binary representation of the n-th iteration of the \"Rule 147\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,101,10001,1011101,100010001,10111011101,1000100010001,101110111011101,10001000100010001,1011101110111011101,100010001000100010001,10111011101110111011101,1000100010001000100010001,101110111011101110111011101,10001000100010001000100010001", "code": " print([(10000 + 110*(n%2))*100**n//9999 for n in range(30)]) \n"}
{"sequence_id": "A262862", "text": "Decimal representation of the n-th iteration of the \"Rule 147\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,5,17,93,273,1501,4369,24029,69905,384477,1118481,6151645,17895697,98426333,286331153,1574821341,4581298449,25197141469,73300775185,403154263517,1172812402961,6450468216285,18764998447377,103207491460573,300239975158033", "code": " print([(16 + 6*(n%2))*4**n//15 for n in range(50)]) \n"}
{"sequence_id": "A262863", "text": "Binary representation of the middle column of the \"Rule 147\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,10,100,1001,10011,100110,1001100,10011001,100110011,1001100110,10011001100,100110011001,1001100110011,10011001100110,100110011001100,1001100110011001,10011001100110011,100110011001100110,1001100110011001100,10011001100110011001", "code": " print([100100*10**n//99990 for n in range(50)]) \n"}
{"sequence_id": "A262864", "text": "Decimal representation of the middle column of the \"Rule 147\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,2,4,9,19,38,76,153,307,614,1228,2457,4915,9830,19660,39321,78643,157286,314572,629145,1258291,2516582,5033164,10066329,20132659,40265318,80530636,161061273,322122547,644245094,1288490188,2576980377,5153960755,10307921510", "code": " print([6*2**n//5 for n in range(50)]) \n"}
{"sequence_id": "A262958", "text": "Numbers whose base-b expansions, for both b=3 and b=4, include no digits other than 1 and b-1.", "sequence": "1,5,7,13,23,53,125,215,373,1367,1373,1375,3551,4093,5471,5495,5503,30581,30589,32765,32767,56821,56831,89557,96119,96215,96223,97655,98135,98141,98143,98167,98293,98303,351743,352093,521599,521693,521717,521719,524119,524149,875893,875903,884725,884735", "code": "\nfrom gmpy2 import digits\ndef f1(n):\n    s = digits(n,3)\n    m = len(s)\n    for i in range(m):\n        if s[i] == '0':\n            return(int(s[:i]+'1'*(m-i),3))\n    return n\ndef f2(n):\n    s = digits(n,4)\n    m = len(s)\n    for i in range(m):\n        if s[i] == '0':\n            return(int(s[:i]+'1'*(m-i),4))\n        if s[i] == '2':\n            return(int(s[:i]+'3'+'1'*(m-i-1),4))\n    return n\nA262958_list = []\nn = 1\nfor i in range(10**4):\n    m = f2(f1(n))\n    while m != n:\n        n, m = m, f2(f1(m))\n    A262958_list.append(m)\n    n += 1 \n"}
{"sequence_id": "A262963", "text": "List of numbers n whose base-3 expansion contains only the digits 1 and 2 and whose base-4 expansion contains only the digits 2 and 3.", "sequence": "2,14,43,238,239,698,4010,4090,4091,4094,10922,12031,12271,12283,174842,174847,176062,176063,977578,977579,981679,981691,981931,981934,981935,981950,1043114,1043194,1043195,1043198,3129259,3129262,3129263,3129322,3129323,3129326,3129343", "code": "\nfrom gmpy2 import digits\ndef f1(n):\n    s = digits(n,3)\n    m = len(s)\n    for i in range(m):\n        if s[i] == '0':\n            return(int(s[:i]+'1'*(m-i),3))\n    return n\ndef f2(n):\n    s = digits(n,4)\n    m = len(s)\n    for i in range(m):\n        if s[i] in ['0','1']:\n            return(int(s[:i]+'2'*(m-i),4))\n    return n\nA262963_list = []\nn = 1\nfor i in range(10**4):\n    m = f2(f1(n))\n    while m != n:\n        n, m = m, f2(f1(m))\n    A262963_list.append(m)\n    n += 1 \n"}
{"sequence_id": "A263017", "text": "n is the a(n)-th positive integer having its binary weight.", "sequence": "1,2,1,3,2,3,1,4,4,5,2,6,3,4,1,5,7,8,5,9,6,7,2,10,8,9,3,10,4,5,1,6,11,12,11,13,12,13,6,14,14,15,7,16,8,9,2,15,17,18,10,19,11,12,3,20,13,14,4,15,5,6,1,7,16,17,21,18,22,23,16,19,24,25,17", "code": "\ndef a(n):\n    x=bin(n)[2:].count(\"1\")\nreturn sum([1 for i in range(n) if bin(i)[2:].count(\"1\")==x]) \n"}
{"sequence_id": "A263102", "text": "Number of distinct cycles without repeated edges on the multigraph with 2 vertices connected by n edges.", "sequence": "0,0,1,3,12,40,225,1071,8848,56232,616185,4880755,66475596,629398848,10238194057,112690225935,2130537219840,26719024870576,575573407212753,8099650628337987,195807849389362540,3054957193416951480,81892400673047263761,1402819397613793354063,41294565798306731368272,770446268109598573215000", "code": "\ndef trfact(n, k):\n    return reduce(lambda x, y: x*y, range(k+1,n+1),1)\ndef a(n):\n    return sum(trfact(n,n-k)/k for k in range(2, n+1, 2))\n"}
{"sequence_id": "A263103", "text": "Minimum possible number of cycles without repeated edges on a multigraph with 3 vertices and n edges (when each vertex pair must have at least one edge).", "sequence": "1,3,8,28,103,415,2176,12888,77787,585411,4616376,37165472,359048127,3547499455,35666828200,418731250432,4974631473123,59967609426243,827065614194184,11481419054280168,161364022042775615,2553658998728779999", "code": " See links.\n"}
{"sequence_id": "A263104", "text": "a(3k), a(3k+1), a(3k+2) are the numbers of edges between each vertex-pair in a multigraph with 3 vertices and k edges (with at least one edge between each vertex-pair) which has the minimum number of distinct cycles, if that arrangement of edges is unique.", "sequence": "1,1,1,1,1,2,1,2,2,1,2,3,2,2,3,2,3,3,1,4,4,3,3,4,3,4,4,2,5,5,4,4,5,4,5,5,3,6,6,5,5,6,5,6,6,4,7,7,6,6,7,6,7,7,5,8,8,7,7,8,7,8,8,7,8,9,8,8,9,8,9,9,8,9,10", "code": " See links.\n"}
{"sequence_id": "A263105", "text": "Number of distinct cycles without repeated edges in the multigraph on 3 vertices, with n edges between each pair of vertices.", "sequence": "1,33,2916,808300,509131545,605707523361,1214620662420928,3795417851074101456,17444500147778706611145,112823815631393432721650905,991377088026896964421518306036,11502248569873461404933124399742188", "code": " See links.\n"}
{"sequence_id": "A263129", "text": "Numbers n whose binary representation is the concatenation of all the words in one of its possible Huffman encodings.", "sequence": "1024538,1024675,1024789,1024837,1024936,1025347,1025378,1025384,1026593,10234987,10236597,10236758,10258346,10259347,10267845,10278534,10283546,10293486,10293675,10294837", "code": "\nimport itertools\ndecimal = []\nhuf = ['000','001','010','011','100','101','110','111']\n  \n  \n  \n  \nndec = list(map(\"\".join, itertools.permutations('0123456789',len(huf))))\nnbin = list(map(\"\".join, itertools.permutations(huf)))\nfor item in nbin:\n  decimal.append(str(int(item, 2)))\nn = set(decimal).intersection(set(ndec))\nprint(sorted(n), len(n))\n\n"}
{"sequence_id": "A263132", "text": "Positive values of m, arranged in order, such that binomial(4*m - 1, m) is odd.", "sequence": "1,2,3,4,6,8,11,12,16,22,24,32,43,44,48,64,86,88,96,128,171,172,176,192,256,342,344,352,384,512,683,684,688,704,768,1024,1366,1368,1376,1408,1536,2048,2731,2732,2736,2752,2816,3072,4096,5462,5464,5472,5504", "code": "\nA263132_list = [m for m in range(1,10**6) if not ~(4*m-1) & m] \n"}
{"sequence_id": "A263133", "text": "Numbers m such that binomial(4*m + 3, m) is odd.", "sequence": "0,1,2,3,5,7,10,11,15,21,23,31,42,43,47,63,85,87,95,127,170,171,175,191,255,341,343,351,383,511,682,683,687,703,767,1023,1365,1367,1375,1407,1535,2047,2730,2731,2735,2751,2815,3071,4095,5461,5463,5471,5503", "code": "\nA263133_list = [m for m in range(10**6) if not ~(4*m+3) & m] \n"}
{"sequence_id": "A263194", "text": "4-digit numbers (with leading zeros supplied where necessary) in which the sum of the number consisting of the first two digits and the number consisting of the last two digits equals the number consisting of the middle two digits.", "sequence": "0,109,110,219,220,329,330,439,440,549,550,659,660,769,770,879,880,989,990,1208,1318,1428,1538,1648,1758,1868,1978,2307,2417,2527,2637,2747,2857,2967,3406,3516,3626,3736,3846,3956,4505,4615,4725,4835,4945,5604,5714,5824,5934,6703,6813,6923,7802,7912,8901", "code": "\ndef ok(n): return (n//100) + (n%100) == (n//10)%100\nprint([m for m in range(10000) if ok(m)]) \n"}
{"sequence_id": "A263272", "text": "Self-inverse permutation of nonnegative integers: a(n) = A263273(2*n) / 2.", "sequence": "0,1,2,3,4,5,6,11,8,9,10,7,12,13,14,15,32,23,18,29,20,33,38,17,24,35,26,27,28,19,30,37,16,21,34,25,36,31,22,39,40,41,42,95,68,45,86,59,96,113,50,69,104,77,54,83,56,87,110,47,60,101,74,99,92,65,114,119,44,51,98,71,72,89,62,105,116,53,78,107,80,81", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a(n): return a263273(2*n)/2 \n"}
{"sequence_id": "A263273", "text": "Bijective base-3 reverse: a(0) = 0; for n >= 1, a(n) = A030102(A038502(n)) * A038500(n).", "sequence": "0,1,2,3,4,7,6,5,8,9,10,19,12,13,22,21,16,25,18,11,20,15,14,23,24,17,26,27,28,55,30,37,64,57,46,73,36,31,58,39,40,67,66,49,76,63,34,61,48,43,70,75,52,79,54,29,56,33,38,65,60,47,74,45,32,59,42,41,68,69,50,77,72,35,62,51,44,71,78,53,80,81", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a(n): return 0 if n==0 else a030102(a038502(n))*a038500(n) \n"}
{"sequence_id": "A263298", "text": "Numbers n such that n-23, n-1, n+1 and n+23 are consecutive primes.", "sequence": "19890,43890,157770,400680,436650,609780,681090,797310,924360,978180,1093200,1116570,1179150,1185930,1313700,1573110,1663350,2001510,2110290,2163570,2336310,2372370,2408280,2415630,2562690,2877840,2896740,2961900", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,5000001,6):\n..if  isprime(i-1) and isprime(i+1) and prevprime(i-1) == i-23 and nextprime(i+1) == i+23: print (i,end=', ')\n"}
{"sequence_id": "A263299", "text": "Primes that are the concatenation of k 1's, the digits of k^2 + k + 1, and k 1's.", "sequence": "131,11113111,1111211111,111113111111,11111143111111,11111111111111111111111", "code": "\nfrom gmpy2 import is_prime\nA263299_list = [n for n in (int('1'*k+str(k*(k+1)+1)+'1'*k) for k in range(10**2)) if is_prime(n)] \n"}
{"sequence_id": "A263308", "text": "Smallest prime modulus p such that there exists a multiplicative-coset Ramsey algebra in n colors over Z/pZ, or 0 if no such prime exists.", "sequence": "2,5,13,41,71,97,491,0,523,1181,947,769,0,1709,1291,1217,4013,2521,1901,2801,1933,3257,3221,4129,3701,4889,5563,8849,6323,5521,6263,5441,8779,7481,7841,10009,13469,12161,8971,14561,13367,19993,14621,12497,14401,14537,20117,18913,22541,22901,19687,29537", "code": "\nimport numpy as np\nimport itertools\nfrom copy import copy\nfrom sympy.ntheory.residue_ntheory import primitive_root\ndef psieve():\n    for n in [2, 3, 5, 7]:\n        yield n\n    D = {}\n    ps = psieve()\n    next(ps)\n    p = next(ps)\n    assert p == 3\n    psq = p*p\n    for i in itertools.count(9, 2):\n        if i in D:\n            step = D.pop(i)\n        elif i < psq:\n            yield i\n            continue\n        else:\n            assert i == psq\n            step = 2*p\n            p = next(ps)\n            psq = p*p\n        i += step\n        while i in D:\n            i += step\n        D[i] = step\ndef check_p_m_v6(p,m,g):\n    ''' checks a prime p with primitive root g for m colors '''\nX0 = np.array( [pow(g, i, p) for i in range(0, p-m, m) ] )\ncertificates = np.array([ pow(g, i, p) for i in range(m) ])\n    C_minus_X0 = ( ( certificates[:, np.newaxis] - X0 ) % p )\n    C_minus_X0_sets = [ set(L) for L in C_minus_X0 ]\nfor i in range(m):\nXi = {pow(g, x+i, p) for x in range(0, p-m, m)}\nfor j in range(i,m):\n            if bool(Xi.intersection(C_minus_X0_sets[j])) == bool(j == 0):\n                return False\n    return True\ndef main(mikelist):\n    ''' Accepts a list of m's, checks all candidate primes until it finds one that works.\n        Will NOT terminate for m=8 or m=13 '''\n    lget = primitive_root     \n    lcheck = check_p_m_v6\n    with open(\"401output.csv\", 'a') as file:\n        for mike in mikelist:\n            primes = psieve()\n            prime = next(primes)\n            while prime < 2*mike**2 - 4*mike:\n                prime = next(primes)\n            while True:\n                if (prime-1)/2 % mike == 0:\n                    gen = lget(prime)\n                    p_out = lcheck(prime, mike, gen)\n                    if p_out == True:\n                        print mike, prime, gen\n                        file.write(str(mike) + ', ' + str(prime) + ', ' + str(gen) + '\\n')\n                        break\n                prime = next(primes)\nmrange = range(2,8) + range(9,13) + range(14,101)  \nmain(mrange)\n"}
{"sequence_id": "A263314", "text": "Numbers m whose decimal representation includes at least one digit that divides every digit of m.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,24,26,28,30,31,33,36,39,40,41,42,44,48,50,51,55,60,61,62,63,66,70,71,77,80,81,82,84,88,90,91,93,99,100,101,102,103,104,105,106,107,108,109,110,111,112", "code": "\nA263314_list = []\nfor i in range(10**4):\n    s = str(i)\n    for d in s:\n        j = int(d)\n        if j :\n            for e in s:\n                if int(e) % j:\n                    break\n            else:\n                A263314_list.append(i)\n                break\n\n"}
{"sequence_id": "A263318", "text": "Number of aperiodic necklaces (Lyndon words) with 9 black beads and n white beads.", "sequence": "0,1,5,18,55,143,333,715,1430,2700,4862,8398,13995,22610,35530,54477,81719,120175,173583,246675,345345,476901,650325,876525,1168695,1542684,2017356,2615085,3362260,4289780,5433714,6835972,8544965,10616463,13114465,16112057", "code": "\nfrom sympy import mobius, binomial, gcd, divisors\nprint([sum(mobius(d) * binomial((n + 9)//d, 9//d) for d in divisors(gcd(n + 9, 9))) // (n + 9) for n in range(51)]) \n"}
{"sequence_id": "A263400", "text": "Smallest index k such that Fibonacci(k) contains Fibonacci(n) as a proper substring in decimal notation.", "sequence": "15,7,7,8,7,10,11,26,26,31,40,66,79,40,132,64,58,339,433,387,254,1158,691,74,623,1450,3136,3867,1066,1801,953,10392,6051,4677,6092,7445,17382,19526,27332,28226,102495,84345,36245,44281,102373,238850,163880,308518", "code": "\nfrom gmpy2 import fib2, digits\ndef A263400(n):\n    b, a = fib2(n)\n    s, m = digits(b), n\n    while True:\n        a, b, m = b, a+b, m+1\n        t = digits(b)\n        if b > a and s in t:\n            return m \n"}
{"sequence_id": "A263457", "text": "Integers m such that A006218(m) is triangular.", "sequence": "1,2,5,15,20,26,55,68,92,108,150,156,336,346,364,423,563,586,682,798,866,951,1194,1734,1888,2790,3102,3150,3506,4210,4611,5820,6766,6943,7665,7701,7888,8734,8772,9410,10114,10839,10969,11014,11453,11630,11947,12357", "code": "\nfrom sympy import integer_nthroot, divisor_count\nA263457_list, s = [], 0\nfor n in range(1,10**4):\n    s += divisor_count(n)\n    if integer_nthroot(8*s+1,2)[1]:\n        A263457_list.append(n) \n"}
{"sequence_id": "A263535", "text": "a(1) = 1; thereafter a(n) = a(n-1) + d_1^1 + d_2^2 + d_3^3 + ..., where d_1 d_2 d_3 ... is the decimal expansion of a(n-1).", "sequence": "1,2,4,8,16,53,67,122,135,270,321,329,1065,1907,4390,5132,5181,5700,5754,6189,13269,73632,73977,93930,94758,128519,661103,661876,729478,1009425,1095200,1096587,2187425,2269554,2311471,2430158,4542981,4864284,5143384,5422306", "code": "\ndef moda(n):\n    return sum(int(d)**(i + 1) for i, d in enumerate(str(n)))\nb = 1\nresu = [1]\nfor a in range(1, 100):\n    b += moda(b)\n    resu.append(b)\nresu\n"}
{"sequence_id": "A263574", "text": "Beatty sequence for 1/sqrt(3) - log(phi)/3575 where phi is the golden ratio, A001622.", "sequence": "0,0,1,1,2,2,3,4,4,5,5,6,6,7,8,8,9,9,10,10,11,12,12,13,13,14,15,15,16,16,17,17,18,19,19,20,20,21,21,22,23,23,24,24,25,25,26,27,27,28,28,29,30,30,31,31,32,32,33,34,34,35,35,36,36,37,38,38,39,39,40,40,41,42,42,43", "code": "\nfrom sympy import floor, log, sqrt\nfor n in range(0,101):print(floor(n*(1/sqrt(3)-log(1/2+sqrt(5)/2)/3575)),end=', ')\n"}
{"sequence_id": "A263609", "text": "Base-4 numbers whose square is a palindrome in base 4.", "sequence": "0,1,11,101,111,1001,1013,1103,10001,10101,10121,10331,100001,100133,1000001,1001001,1001201,1010301,1100211,1100323,1101211,10000001,10001333,10013201,10031113,100000001,100010001,100012001,100103001,100301113,100332101,101002101,103231203,110002011", "code": "\ndef decimal_to_quaternary(n):\n    if n == 0:\n        return '0'\n    b = ''\n    while n > 0:\n        b = str(n % 4) + b\n        n = n // 4\n    return b\nx = 0\ncounter = 0\nwhile True:\n    y = decimal_to_quaternary(x ** 2)\n    if y == y[::-1]:\n        print(int(decimal_to_quaternary(x)))\n        counter += 1\n    x += 1  \n"}
{"sequence_id": "A263616", "text": "Number of n-digit numbers whose square is a palindrome.", "sequence": "4,3,8,5,11,6,19,14,25,18,49,31,71,46,105,71,154,101,209,132,292,182", "code": "\nfrom itertools import product\ndef pal(n): s = str(n); return s == s[::-1]\ndef a(n): return int(n==1) + sum(pal(i**2) for i in range(10**(n-1), 10**n))\nprint([a(n) for n in range(1, 8)]) \n"}
{"sequence_id": "A263620", "text": "Number of nonzero palindromic squares with at most 2n digits.", "sequence": "3,6,14,19,30,36,55,69,94,112", "code": "\ndef ispal(n): s = str(n); return s == s[::-1]\ndef a(n):\n  c, k, kk = 0, 1, 1\n  while kk < 10**(2*n): c, k, kk = c + (ispal(kk)), k+1, kk + 2*k + 1\n  return c\nprint([a(n) for n in range(1, 8)]) \n"}
{"sequence_id": "A263856", "text": "Let S_n be the list of the first n primes written in binary, with least significant bits on the left, and sorted into lexicographic order; a(n) = position of n-th prime in S_n.", "sequence": "1,2,2,4,4,3,2,6,9,5,11,4,3,11,14,6,13,9,11,17,3,20,14,5,2,9,23,20,12,4,31,17,5,23,12,32,17,22,32,15,26,14,42,2,11,37,29,46,27,14,9,48,6,40,2,43,22,51,18,12,43,17,39,56,14,32,45,6,50", "code": "\nfrom sympy import prime\ndef A263856(n):\n    return 1+sorted(format(prime(i),'b')[::-1] for i in range(1,n+1)).index(format(prime(n),'b')[::-1]) \n"}
{"sequence_id": "A263897", "text": "Number of anagram compositions of 2n that can be formed from the compositions of n.", "sequence": "1,1,2,6,16,44,134,414,1290,4102,13306,43718,145176,487384,1651154,5636702,19381392,67074420,233483430,817106622,2873589060,10151255976,36009769278,128231072994,458268615966,1643227382022,5910606009330,21322486928518,77132729929864", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import factorial as f\n@cacheit\ndef b(n, i, p): return f(p)**2 if n==0 else 0 if i<1 else sum(b(n - i*j, i - 1, p + j)//f(j)**2 for j in range(n//i + 1))\ndef a(n): return b(n, n, 0)\nprint([a(n) for n in range(36)]) \n"}
{"sequence_id": "A263987", "text": "Number of ways of ordering integers 1 to n such that each number is either a factor of or larger than its predecessor.", "sequence": "1,2,4,14,28,164,328,2240,9970,63410,126820,1810514,3621028,31417838,294911038,3344414606,6688829212,121919523980,243839047960,5307482547686,56885719183654", "code": "\ndef p(n):\n....count = 0\n....for i in permutations(range(1,n+1),r=n):\n........for j in range(len(i)-1):\n............if i[j]%i[j+1]!=0 and i[j]>i[j+1]:\n................break\n........else:\n............count+=1\n....return count\nfor i in range(1,100):\n....print(p(i))\n"}
{"sequence_id": "A263991", "text": "a(n) is the number of uniform consecutive subintervals of the unit interval each of size 2^(-ceiling(log_2(n))) that are completely covered by one of the n uniform consecutive subintervals (of size 1/n each) of the unit interval.", "sequence": "1,2,2,4,4,4,2,8,8,8,6,8,4,4,2,16,16,16,14,16,12,12,10,16,8,8,6,8,4,4,2,32,32,32,30,32,28,28,26,32,24,24,22,24,20,20,18,32,16,16,14,16,12,12,10,16,8,8,6,8,4,4,2,64,64,64,62,64,60,60,58,64,56,56,54,56,52,52,50,64,48,48,46,48,44,44,42,48,40,40,38,40,36,36,34,64,32,32,30", "code": "\ndef getNumber(n):\n    y = int(math.ceil(math.log(n, 2)))\n    smallIncrement = 0.5 ** y\n    marker = 0\n    nMarker = 0\n    toReturn = 0\n    while marker < 1:\n        newMarker = marker + smallIncrement\n        if (nMarker + 1) / n < newMarker:\n            nMarker += 1\n        if nMarker / n <= marker and (nMarker + 1) / n >= newMarker:\n            toReturn += 1\n        marker = newMarker\n    return toReturn\n"}
{"sequence_id": "A264432", "text": "Third-order Bell numbers.", "sequence": "1,1,2,6,24,119,700,4748,36403,310851,2922606,29977587,332929492,3978258079,50872884285,692985674373,10015172966221,153021613683924,2464031776132958,41698912656882644,739771703127828419,13727160292457369098,265876635231121617716", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, h): return 1 if min(n, h)==0 else sum(binomial(n - 1, j - 1)*b(j - 1, h - 1)*b(n - j, h) for j in range(1, n + 1))\ndef a(n): return b(n, 3)\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A264596", "text": "Let S_n be the list of the first n nonnegative numbers written in binary, with least significant bits on the left, and sorted into lexicographic order; a(n) = position of n in S_n, starting indexing at 0.", "sequence": "0,1,1,3,1,4,3,7,1,6,4,10,3,10,7,15,1,10,6,16,4,15,10,22,3,16,10,24,7,22,15,31,1,18,10,28,6,25,16,36,4,25,15,37,10,33,22,46,3,28,16,42,10,37,24,52,7,36,22,52,15,46,31,63,1,34,18,52,10,45,28", "code": "\ndef A264596(n):\n    return sorted(format(i,'b')[::-1] for i in range(n+1)).index(format(n,'b')[::-1]) \n"}
{"sequence_id": "A264600", "text": "Let S_n denote the list of decimal numbers 0 to n, written backwards (allowing leading zeros) and arranged in lexicographic order; a(n) = position where backwards-n appears, starting indexing at 0.", "sequence": "0,1,2,3,4,5,6,7,8,9,1,3,5,7,9,11,13,15,17,19,2,5,8,11,14,17,20,23,26,29,3,7,11,15,19,23,27,31,35,39,4,9,14,19,24,29,34,39,44,49,5,11,17,23,29,35,41,47,53,59,6,13,20,27,34,41,48,55,62,69,7,15,23,31,39,47,55,63,71,79,8,17,26,35,44,53,62,71,80,89,9,19,29,39,49,59,69,79,89,99,1,12", "code": "\ndef A264600(n):\n    return sorted(str(i)[::-1] for i in range(n+1)).index(str(n)[::-1]) \n"}
{"sequence_id": "A264688", "text": "The decimal digits of n appear n times in the decimal representation of n!.", "sequence": "0,1,1170,1528,9877,9886,9897,11535", "code": "\nfrom math import factorial\ndef in_a(n):\n....f = str(factorial(n))\n....s = set(str(n))\n....return sum(f.count(d) for d in s)==n\n"}
{"sequence_id": "A264695", "text": "Number of equidistributed binary strings of length n.", "sequence": "2,2,6,4,4,12,34,20,16,8,68,100,144,314,668,360,288,128,192,400,608,2320,8816,9408,9912,6912,38204,37864,52464,108608,209664,106368,79360,32768,49152,16384", "code": " \nfrom itertools import product\nfrom collections import Counter\ndef e(b):\n    if len(b) == 1: return True\n    for k in range(1, len(b)):\n        c = Counter(b[i:i+k] for i in range(len(b)-k+1))\n        if len(c) < 2**k and max(c.values()) > 1: return False\n        elif max(c.values()) - min(c.values()) > 1: return False\n    return True\ndef a(n): return 2*sum(e(\"0\"+\"\".join(b)) for b in product(\"01\", repeat=n-1))\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A264725", "text": "Numbers n such that the concatenation of the first n digits of the digital expansion of 1/137 is prime.", "sequence": "3,11,371,1123,8203,11899,16019", "code": "\nfrom sympy import isprime\nA264725_list,c,n,m,k = [],3,7,29927007,10**8\nfor i in range(1,50):\n    if isprime(n):\n         A264725_list.append(c)\n    c += 8\n    n = n*k+m \n"}
{"sequence_id": "A264749", "text": "a(n) = floor(n/BL(n)) where BL(n) = A070939(n) is the binary length of n.", "sequence": "0,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6,6,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,8,8,8,8,8,8,9,9,9,9,9,9,10,10,10,10,9,9,9,9,9,9,10,10,10,10,10,10,10,11,11,11,11,11,11,11,12", "code": "\nfor n in range(88):  print str(n // (len(bin(n))-2))+',',\n"}
{"sequence_id": "A264814", "text": "Numbers k such that concatenate(k,k+1,k) is prime.", "sequence": "7,9,11,13,33,37,39,41,47,57,59,61,69,71,77,79,81,83,101,103,129,149,181,187,189,191,193,207,217,229,231,241,289,291,299,301,303,307,317,333,347,359,373,377,383,387,409,439,451,467,473,487,489,509,517,527", "code": "\nfrom sympy import isprime\ndef aupto(N):\n  return [k for k in range(1, N+1, 2) if isprime(int(str(k)+str(k+1)+str(k)))]\nprint(aupto(530)) \n"}
{"sequence_id": "A264847", "text": "Pluritriangular numbers: a(0) = 0; a(n+1) = a(n) + the number of digits in terms a(0)..a(n).", "sequence": "0,1,3,6,10,16,24,34,46,60,76,94,114,137,163,192,224,259,297,338,382,429,479,532,588,647,709,774,842,913,987,1064,1145,1230,1319,1412,1509,1610,1715,1824,1937,2054,2175,2300,2429,2562,2699,2840,2985,3134,3287,3444,3605,3770,3939", "code": "\na, b = 0, 0\nprint(a, end=',')\nfor k in range(1, 101):\n   b += len(str(a))\n   a += b\n   print(a, end=',')\n"}
{"sequence_id": "A264868", "text": "Number of rooted tandem duplication trees on n gene segments.", "sequence": "1,1,2,6,22,92,420,2042,10404,54954,298648,1660714,9410772,54174212,316038060,1864781388,11111804604,66782160002,404392312896,2465100947836,15116060536540,93184874448186,577198134479356,3590697904513792,22425154536754776", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef a(n):\n    return 1 if n<3 else sum([(-1)**(k + 1)*binomial(n + 1 - 2*k, k)*a(n - k) for k in range(1, (n + 1)//3 + 1)])\nprint([a(n) for n in range(1, 26)]) \n"}
{"sequence_id": "A264961", "text": "Numbers that are products of two triangular numbers in more than one way.", "sequence": "36,45,210,315,360,630,780,990,1260,1386,1540,1800,2850,2970,3510,3570,3780,4095,4788,4851,6300,7920,8415,8550,8778,9450,11700,11781,14850,15400,15561,16380,17640,17955,18018,18648,19110,20790,21420,21450,21528,25116,25200,26565,26775,26796,27720,28980", "code": "\nfrom __future__ import division\nmmax = 10**3\ntmax, A264961_dict = mmax*(mmax+1)//2, {}\nti = 0\nfor i in range(1,mmax+1):\n    ti += i\n    p = ti*i*(i-1)//2\n    for j in range(i,mmax+1):\n        p += ti*j\n        if p <= tmax:\n            A264961_dict[p] = 2 if p in A264961_dict else 1\n        else:\n            break\nA264961_list = sorted([i for i in A264961_dict if A264961_dict[i] > 1]) \n"}
{"sequence_id": "A264974", "text": "Self-inverse permutation of natural numbers: a(n) = A263273(4*n) / 4.", "sequence": "0,1,2,3,4,5,6,7,16,9,10,19,12,13,14,15,8,17,18,11,20,21,34,43,48,25,52,27,28,55,30,37,46,57,22,49,36,31,58,39,40,41,42,23,50,45,32,59,24,35,44,51,26,53,54,29,56,33,38,47,60,61,142,63,88,169,102,115,124,129,70,151,144,97,178,75,106,133,156,79,160,81", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a(n): return a263273(4*n)/4 \n"}
{"sequence_id": "A264977", "text": "a(0) = 0, a(1) = 1, a(2*n) = 2*a(n), a(2*n+1) = a(n) XOR a(n+1).", "sequence": "0,1,2,3,4,1,6,7,8,5,2,7,12,1,14,15,16,13,10,7,4,5,14,11,24,13,2,15,28,1,30,31,32,29,26,7,20,13,14,3,8,1,10,11,28,5,22,19,48,21,26,15,4,13,30,19,56,29,2,31,60,1,62,63,64,61,58,7,52,29,14,19,40,25,26,3,28,13,6,11,16,9,2,11,20,1,22", "code": "\nclass Memoize:\n    def __init__(self, func):\n        self.func=func\n        self.cache={}\n    def __call__(self, arg):\n        if arg not in self.cache:\n            self.cache[arg] = self.func(arg)\n        return self.cache[arg]\n@Memoize\ndef a(n): return n if n<2 else 2*a(n//2) if n%2==0 else a((n - 1)//2)^a((n + 1)//2)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A264983", "text": "Odd bisection of A263273.", "sequence": "1,3,7,5,9,19,13,21,25,11,15,23,17,27,55,37,57,73,31,39,67,49,63,61,43,75,79,29,33,65,47,45,59,41,69,77,35,51,71,53,81,163,109,165,217,91,111,199,145,171,181,127,219,235,85,93,193,139,117,175,121,201,229,103,147,211", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a(n): return a263273(2*n + 1) \n"}
{"sequence_id": "A264984", "text": "Even bisection of A263273; terms of A263262 doubled.", "sequence": "0,2,4,6,8,10,12,22,16,18,20,14,24,26,28,30,64,46,36,58,40,66,76,34,48,70,52,54,56,38,60,74,32,42,68,50,72,62,44,78,80,82,84,190,136,90,172,118,192,226,100,138,208,154,108,166,112,174,220,94,120,202,148,198,184,130", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a(n): return a263273(2*n) \n"}
{"sequence_id": "A264985", "text": "Self-inverse permutation of nonnegative integers: a(n) = (A264983(n)-1) / 2.", "sequence": "0,1,3,2,4,9,6,10,12,5,7,11,8,13,27,18,28,36,15,19,33,24,31,30,21,37,39,14,16,32,23,22,29,20,34,38,17,25,35,26,40,81,54,82,108,45,55,99,72,85,90,63,109,117,42,46,96,69,58,87,60,100,114,51,73,105,78,94,84,57,91,111,48,64,102,75,112,93,66,118,120,41", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a(n): return (a263273(2*n + 1) - 1)/2 \n"}
{"sequence_id": "A264986", "text": "Even bisection of A263272; terms of A264974 doubled.", "sequence": "0,2,4,6,8,10,12,14,32,18,20,38,24,26,28,30,16,34,36,22,40,42,68,86,96,50,104,54,56,110,60,74,92,114,44,98,72,62,116,78,80,82,84,46,100,90,64,118,48,70,88,102,52,106,108,58,112,66,76,94,120,122,284,126,176,338,204,230,248,258,140,302,288", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a(n): return a263273(4*n)/2 \n"}
{"sequence_id": "A264987", "text": "Odd bisection of A263272.", "sequence": "1,3,5,11,9,7,13,15,23,29,33,17,35,27,19,37,21,25,31,39,41,95,45,59,113,69,77,83,87,47,101,99,65,119,51,71,89,105,53,107,81,55,109,57,73,91,111,43,97,63,61,115,75,79,85,93,49,103,117,67,121,123,203,257,285,149,311,135,167,329,177,221,275", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a(n): return a263273(2*(2*n + 1))/2 \n"}
{"sequence_id": "A264990", "text": "a(n) = number of occurrences of a most frequent nonzero digit in factorial base representation (A007623) of n.", "sequence": "0,1,1,2,1,1,1,2,2,3,1,2,1,1,1,2,2,2,1,1,1,2,1,1,1,2,2,3,1,2,2,3,3,4,2,3,1,2,2,3,2,2,1,2,2,3,1,2,1,1,1,2,2,2,1,2,2,3,2,2,2,2,2,2,3,3,1,1,1,2,2,2,1,1,1,2,1,1,1,2,2,3,1,2,1,1,1,2,2,2,2,2,2,2,2,2,1,1,1,2,1,1,1,2,2,3,1,2,1,1,1,2,2,2,1,1,1,2,1,1,1,2", "code": "\nfrom sympy import prime, factorint\nfrom operator import mul\nimport collections\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a051903(n): return 0 if n==1 else max(factorint(n).values())\ndef a275735(n):\n    y=collections.Counter(map(int, list(str(a007623(n)).replace(\"0\", \"\")))).most_common()\n    return 1 if n==0 else reduce(mul, [prime(y[i][0])**y[i][1] for i in range(len(y))])\ndef a(n): return 0 if n==0 else a051903(a275735(n))\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A265108", "text": "The number of n-digit numbers in A264847 (pluritriangular numbers).", "sequence": "0,4,8,19,50,142,408,1186,3498,10401,31139,93728,283377,859939,2617798,7990517,24447214,74950315,230198869,708160711,2181656006,6729833482,20784165689,64257670873,198857204708,615951476925", "code": "\na, b, d = 0, 0, 0\nfor g in range(1,18):\n    h = 10**g\n    while a < h:\n        b = b + g\n        a = a + b\n        d = d + 1\n    print d\n    d = 0\n"}
{"sequence_id": "A265312", "text": "Square array read by ascending antidiagonals, Bell numbers iterated by the Bell transform.", "sequence": "1,1,1,1,1,1,1,1,2,1,1,1,2,5,1,1,1,2,6,15,1,1,1,2,6,23,52,1,1,1,2,6,24,106,203,1,1,1,2,6,24,119,568,877,1,1,1,2,6,24,120,700,3459,4140,1,1,1,2,6,24,120,719,4748,23544,21147,1,1,1,2,6,24,120,720,5013,36403,176850,115975,1", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef A(n, h): return 1 if min(n, h)==0 else sum([binomial(n - 1, j - 1)*A(j - 1, h - 1)*A(n - j, h) for j in range(1, n + 1)])\nfor d in range(13): print([A(n, d - n) for n in range(d + 1)]) \n"}
{"sequence_id": "A265342", "text": "Permutation of even numbers: a(n) = 2 * A265351(n).", "sequence": "0,2,4,6,8,22,12,10,16,18,20,58,24,26,76,66,64,70,36,14,40,30,28,34,48,46,52,54,56,166,60,62,184,174,172,178,72,74,220,78,80,238,228,226,232,198,68,202,192,190,196,210,208,214,108,38,112,42,44,130,120,118,124,90,32,94,84,82,88,102,100,106,144", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a263272(n): return a263273(2*n)/2\ndef a(n): return 2*a263272(a263273(n)) \n"}
{"sequence_id": "A265351", "text": "Permutation of nonnegative integers: a(n) = A263272(A263273(n)).", "sequence": "0,1,2,3,4,11,6,5,8,9,10,29,12,13,38,33,32,35,18,7,20,15,14,17,24,23,26,27,28,83,30,31,92,87,86,89,36,37,110,39,40,119,114,113,116,99,34,101,96,95,98,105,104,107,54,19,56,21,22,65,60,59,62,45,16,47,42,41,44,51,50,53,72,25,74,69,68,71,78,77,80,81", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a263272(n): return a263273(2*n)/2\ndef a(n): return a263272(a263273(n)) \n"}
{"sequence_id": "A265352", "text": "Permutation of nonnegative integers: a(n) = A263273(A263272(n)).", "sequence": "0,1,2,3,4,7,6,19,8,9,10,5,12,13,22,21,64,23,18,55,20,57,58,25,24,73,26,27,28,11,30,31,16,15,46,17,36,37,14,39,40,67,66,199,68,63,190,65,192,193,70,69,208,71,54,163,56,165,166,61,60,181,62,171,172,59,174,175,76,75,226,77,72,217,74,219,220,79,78,235,80,81", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a(n): return a263273(a263273(2*n)/2) \n"}
{"sequence_id": "A265353", "text": "Permutation of nonnegative integers: a(n) = A264985(A263273(n)).", "sequence": "0,1,3,2,4,10,6,9,12,5,7,19,8,13,31,24,28,37,15,11,33,18,27,30,21,36,39,14,16,46,23,25,73,69,55,64,17,22,58,26,40,94,78,85,112,51,34,100,72,82,91,75,109,118,42,32,96,20,35,105,60,99,102,45,29,87,54,81,84,57,90,93,48,38,114,63,108,111,66,117,120,41", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a264985(n): return (a263273(2*n + 1) - 1)/2\ndef a(n): return a264985(a263273(n)) \n"}
{"sequence_id": "A265354", "text": "Permutation of nonnegative integers: a(n) = A263273(A264985(n)).", "sequence": "0,1,3,2,4,9,6,10,12,7,5,19,8,13,27,18,28,36,21,11,57,24,37,30,15,31,39,22,16,64,23,14,55,20,46,58,25,17,73,26,40,81,54,82,108,63,29,171,72,109,90,45,85,117,66,34,192,69,38,165,60,100,174,75,35,219,78,118,84,33,91,93,48,32,138,51,112,111,42,94,120,67", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a264985(n): return (a263273(2*n + 1) - 1)/2\ndef a(n): return a263273(a264985(n)) \n"}
{"sequence_id": "A265360", "text": "Second smallest number of complexity n: second smallest number requiring n 1's to build using + and *.", "sequence": "6,8,12,13,19,25,29,43,53,67,94,131,173,214,269,359,479,713,863,1277,1499,2099,3019,3833,5639,7103,10463,12527,18899,22643,33647,45989,60443,88379,103319,166319,206639,280223,384479,543659,755663,1020599,1316699,1856159,2556839,3346559,4895963,6649199,8666783", "code": "\ndef aupton(nn):\n  alst, R = [], {0: {1}} \n  for n in range(1, nn):\n    R[n]  = set(a+b for i in range(n//2+1) for a in R[i] for b in R[n-1-i])\n    R[n] |= set(a*b for i in range(n//2+1) for a in R[i] for b in R[n-1-i])\n    new = R[n] - R[n-1]\n    if n >= 4: alst.append(min(new - {min(new)}))\n  return alst\nprint(aupton(35)) \n"}
{"sequence_id": "A265379", "text": "Binary representation of the n-th iteration of the \"Rule 158\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,111,11101,1110011,111011101,11100110011,1110111011101,111001100110011,11101110111011101,1110011001100110011,111011101110111011101,11100110011001100110011,1110111011101110111011101,111001100110011001100110011,11101110111011101110111011101", "code": " print([(11100 - (n%2))*100**n//9999 for n in range(30)]) \n"}
{"sequence_id": "A265381", "text": "Decimal representation of the middle column of the \"Rule 158\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,3,7,14,29,59,119,238,477,955,1911,3822,7645,15291,30583,61166,122333,244667,489335,978670,1957341,3914683,7829367,15658734,31317469,62634939,125269879,250539758,501079517,1002159035,2004318071,4008636142,8017272285", "code": " print([7*2**(n+2)//15 for n in range(34)]) \n"}
{"sequence_id": "A265433", "text": "Number of primes with digit sum n whose digit product is maximal among all numbers with digit sum n.", "sequence": "0,1,1,0,1,0,2,1,0,1,2,0,5,1,0,4,3,0,8,2,0,2,2,0,10,1,0,5,4,0,8,1,0,4,2,0,17,0,0,7,4,0,13,3,0,0,3,0,17,4,0,12,1,0,13,1,0,6,2,0,18,1,0,11,0,0,24,2,0,5,1,0,25,1,0,10,2,0,23,2,0,9,1", "code": "\nfrom __future__ import division\nfrom sympy.utilities.iterables import multiset_permutations\nfrom sympy import isprime\ndef A265433(n):\n    if n == 1:\n        return 0\n    if n == 3:\n        return 1\n    if (n % 3) == 0:\n        return 0\n    else:\n        pmaxlist = ['3'*(n//3) + '2'] if (n % 3 == 2) else ['3'*(n//3 -1) + '22','3'*(n//3 -1) + '4']\n        return sum(1 for p in pmaxlist for k in multiset_permutations(p) if isprime(int(''.join(k)))) \n"}
{"sequence_id": "A265436", "text": "a(n) is the least m (1 <= m <= n) such that the set of pairs (x, y) of distinct terms from [m, n] can be ordered in such a way that the corresponding sums (x+y) and products (x*y) are monotonic.", "sequence": "1,1,1,1,2,2,3,3,4,5,6,6,7,8,8,9,10,11,12,12,13,14,15,15,16,17,18,19,20,20,21,22,23,24,24,25,26,27,28,29,30,30,31,32,33,34,35,35,36,37,38,39,40,41,42,42,43,44,45,46,47,48,48,49,50,51,52,53,54,55", "code": "\nprint(\"1, 1, \")\nx=[1, 2]\nmaxx=50\nfinal=[1, 2]\nn=3\nx.append(n)\noldLen=len(x)\nwhile n<maxx:\n   myLen=len(x)\n   if myLen>oldLen:\n      print (x[0], \", \", end=\"\")\n   s=[]\n   p=[]\n   z=[]\n   for i in range(myLen-1):\n      for j in range(i+1, myLen):\n         s.append( x[i]+x[j] )\n         p.append( x[i]*x[j] )\n   z=list(zip( s, p ))\n   y=[]\n   y=sorted(z)\n   sumsort=[]\n   prodsort=[]\n   for h5 in range(len(y)):\n      vals, valp=y[h5]\n      sumsort.append(vals)\n      prodsort.append(valp)\n   errer=0\n   for j5 in range(len(sumsort)-1):\n      for k5 in range(j5+1, len(sumsort)):\n         if sumsort[k5]<sumsort[j5]:\n            errer=1\n            break\n         if prodsort[k5]<prodsort[j5]:\n            errer=1\n            break\n      if errer>0:\n         break\n   if errer<1:\n      for ptr in range (len(y)-1):\n         if y[ptr]==y[ptr+1]:\n            errer=1\n            break\n   if errer>0:\n      final.append(-x[0])\n      x.pop(0)\n   else:\n      final.append(n)\n      n+=1\n      x.append(n)\n   oldLen=myLen\n\n"}
{"sequence_id": "A265449", "text": "Palindromes that are the sums of consecutive fourth powers.", "sequence": "0,1,353,979,14641,16561,998899,2138312,104060401,1004006004001,10004000600040001,85045192129154058,100004000060000400001,1000004000006000004000001,10000004000000600000040000001", "code": "\nimport heapq\ndef ispal(n): s = str(n); return s == s[::-1]\ndef afind():\n  print(\"0, \") \n  N, T = 4, 1  \n  sigma = sum(i**N for i in range(1, T+1))\n  h = [(sigma, 1, T)]\n  nextcount = T + 1\n  while True:\n    (v, s, l) = heapq.heappop(h)\n    if ispal(v): print(f\"{v}, [= Sum_{{i = {s}..{l}}} i^{N}]\")\n    if v >= sigma:\n      sigma += nextcount**N\n      heapq.heappush(h, (sigma, 1, nextcount))\n      nextcount += 1\n    v -= s**N; s += 1; l += 1; v += l**N\n    heapq.heappush(h, (v, s, l))\nafind() \n"}
{"sequence_id": "A265648", "text": "Number of binary strings of length n that are powers of shorter strings, but cannot be written as the concatenation of two or more such strings.", "sequence": "0,2,2,2,0,8,0,10,6,20,0,48,0,74,26,146,0,372,0,630,94,1350,0,2864,0,5598,368,11140,0,23892,0,46194,1524,95552,0,193026,0,390774,6098,778684,0,1606572,0,3180700,24554,6488240,0,13003236,0,26349278,99384", "code": " \nfrom sympy import divisors\nfrom itertools import product\ndef is_pow(s):\n    return any(s == s[:d]*(len(s)//d) for d in divisors(len(s))[:-1])\ndef is_concat_pows(s, c):\n    if len(s) < 2: return False\n    if c > 0 and is_pow(s): return True\n    for i in range(2, len(s)-1):\n        if is_pow(s[:i]) and is_concat_pows(s[i:], c+1): return True\n    return False\ndef ok(s):\n    return is_pow(s) and not is_concat_pows(s, 0)\ndef pows_len(n): \n    for d in divisors(n)[:-1]:\n        for b in product(\"01\", repeat=d-1):\n            yield \"\".join(('0'+''.join(b))*(n//d))\ndef a(n):\n    return 2*sum(ok(s) for s in pows_len(n) if s[0] == '0')\nprint([a(n) for n in range(1, 26)]) \n"}
{"sequence_id": "A265651", "text": "Numbers n such that n-29, n-1, n+1 and n+29 are consecutive primes.", "sequence": "14592,84348,151938,208962,241392,254490,397182,420192,494442,527700,549978,581982,637200,641550,712602,729330,791628,850302,975552,995052,1086558,1107852,1157670,1245450,1260798,1286148,1494510,1555290,1608912", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,1000001,6):\n.. if isprime(i-1) and isprime(i+1) and prevprime(i-1) == i-29 and nextprime(i+1) == i+29 :  print (i,end=', ')\n"}
{"sequence_id": "A265688", "text": "Binary representation of the n-th iteration of the \"Rule 190\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,111,11101,1110111,111011101,11101110111,1110111011101,111011101110111,11101110111011101,1110111011101110111,111011101110111011101,11101110111011101110111,1110111011101110111011101,111011101110111011101110111,11101110111011101110111011101", "code": " print([11100*100**n//9999 for n in range(30)]) \n"}
{"sequence_id": "A265720", "text": "Binary representation of the n-th iteration of the \"Rule 1\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,0,100,1100011,10000,11110001111,1000000,111111000111111,100000000,1111111100011111111,10000000000,11111111110001111111111,1000000000000,111111111111000111111111111,100000000000000,1111111111111100011111111111111,10000000000000000", "code": " print([(10*100**n - 999*10**(n-1) - 1)//9 if n%2 else 10**n for n in range(50)]) \n"}
{"sequence_id": "A265721", "text": "Decimal representation of the n-th iteration of the \"Rule 1\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,0,4,99,16,1935,64,32319,256,522495,1024,8381439,4096,134189055,16384,2147368959,65536,34359279615,262144,549753978879,1048576,8796085682175,4194304,140737458995199,16777216,2251799696244735,67108864,36028796549201919,268435456", "code": " print([2*4**n  - 7*2**(n-1) - 1 if n%2 else 2**n for n in range(50)]) \n"}
{"sequence_id": "A265745", "text": "a(n) is the number of Jacobsthal numbers (A001045) needed to sum to n using the greedy algorithm.", "sequence": "0,1,2,1,2,1,2,3,2,3,2,1,2,3,2,3,2,3,4,3,4,1,2,3,2,3,2,3,4,3,4,3,2,3,4,3,4,3,4,5,4,5,2,1,2,3,2,3,2,3,4,3,4,3,2,3,4,3,4,3,4,5,4,5,2,3,4,3,4,3,4,5,4,5,4,3,4,5,4,5,4,5,6,5,6,1,2,3,2,3,2,3,4,3,4,3,2,3,4,3,4,3,4,5,4,5,2", "code": "\ndef greedyJ(n): n1 = (3*n+1).bit_length() - 1; return (2**n1 - (-1)**n1)//3\ndef a(n): return 0 if n == 0 else 1 + a(n - greedyJ(n))\nprint([a(n) for n in range(107)]) \n"}
{"sequence_id": "A265747", "text": "Numbers written in Jacobsthal greedy base.", "sequence": "0,1,2,10,11,100,101,102,110,111,200,1000,1001,1002,1010,1011,1100,1101,1102,1110,1111,10000,10001,10002,10010,10011,10100,10101,10102,10110,10111,10200,11000,11001,11002,11010,11011,11100,11101,11102,11110,11111,20000,100000,100001,100002,100010,100011,100100", "code": "\ndef greedyJ(n): m = (3*n+1).bit_length() - 1; return (m, (2**m-(-1)**m)//3)\ndef a(n):\n    if n == 0: return 0\n    place, value = greedyJ(n)\n    return 10**(place-2) + a(n - value)\nprint([a(n) for n in range(49)]) \n"}
{"sequence_id": "A265904", "text": "Self-inverse permutation of nonnegative integers: a(n) = A263272(A263273(A263272(n))).", "sequence": "0,1,2,3,4,11,6,29,8,9,10,5,12,13,38,33,92,17,18,83,20,87,110,35,24,89,26,27,28,7,30,37,32,15,86,23,36,31,14,39,40,119,114,281,44,99,254,65,276,335,98,51,260,71,54,245,56,249,326,101,60,263,74,261,272,47,330,353,116,105,278,53,72,251,62,267,332,107,78,269,80,81,82,19", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a263272(n): return a263273(2*n)/2\ndef a(n): return a263272(a263273(a263272(n))) \n"}
{"sequence_id": "A265917", "text": "a(n) = floor(A070939(n)/A000120(n)) where A070939(n) is the binary length of n and A000120(n) is the binary weight of n.", "sequence": "1,2,1,3,1,1,1,4,2,2,1,2,1,1,1,5,2,2,1,2,1,1,1,2,1,1,1,1,1,1,1,6,3,3,2,3,2,2,1,3,2,2,1,2,1,1,1,3,2,2,1,2,1,1,1,2,1,1,1,1,1,1,1,7,3,3,2,3,2,2,1,3,2,2,1,2,1,1,1,3,2,2,1,2,1,1", "code": "\nfor n in range(1, 88):\n    print(str((len(bin(n))-2) // bin(n).count('1')), end=',')\n"}
{"sequence_id": "A265918", "text": "a(n) = A070939(n) mod A000120(n), where A070939(n) is the binary length of n and A000120(n) is the binary weight of n.", "sequence": "0,0,0,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,2,1,2,2,1,1,2,2,1,2,1,1,0,0,0,0,0,0,0,0,2,0,0,0,2,0,2,2,1,0,0,0,2,0,2,2,1,0,2,2,1,2,1,1,0,0,1,1,1,1,1,1,3,1,1,1,3,1,3,3,2,1,1,1,3,1,3,3", "code": "\nfor n in range(1, 88): print str((len(bin(n))-2) % bin(n).count('1'))+',',\n"}
{"sequence_id": "A266001", "text": "Numbers with no 0's in their base 3 and base 4 expansions.", "sequence": "1,2,5,7,13,14,22,23,25,26,41,43,53,121,122,125,149,151,157,158,214,215,229,230,233,238,239,365,367,373,374,377,445,446,473,475,485,607,617,619,634,635,637,638,697,698,701,725,727,1366,1367,1373,1375,1429,1430,1445,1447,1453,1454", "code": "\nfrom __future__ import division\nfrom gmpy2 import digits\nA266001_list = [j for j in (int(format(i,'b'),3)+(3**n-1)//2 for n in range(1,10) for i in range(2**n)) if '0' not in digits(j,4)] \n"}
{"sequence_id": "A266068", "text": "Binary representation of the n-th iteration of the \"Rule 3\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,100,10,1111001,100,11111110011,1000,111111111100111,10000,1111111111111001111,100000,11111111111111110011111,1000000,111111111111111111100111111,10000000,1111111111111111111111001111111,100000000,11111111111111111111111110011111111", "code": " print([(10*100**n - 99*10**((n-1)//2) - 1)//9 if n%2 else 10**(n//2) for n in range(30)]) \n"}
{"sequence_id": "A266069", "text": "Decimal representation of the n-th iteration of the \"Rule 3\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,4,2,121,4,2035,8,32743,16,524239,32,8388511,64,134217535,128,2147483263,256,34359737599,512,549755812351,1024,8796093019135,2048,140737488349183,4096,2251799813672959,8192,36028797018939391,16384,576460752303374335,32768", "code": " print([2*4**n - 3*2**((n-1)//2) - 1 if n%2 else 2**(n//2) for n in range(30)]) \n"}
{"sequence_id": "A266071", "text": "Binary representation of the middle column of the \"Rule 3\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,10,100,1001,10010,100101,1001010,10010101,100101010,1001010101,10010101010,100101010101,1001010101010,10010101010101,100101010101010,1001010101010101,10010101010101010,100101010101010101,1001010101010101010,10010101010101010101", "code": " print([991*10**n//990 for n in range(50)]) \n"}
{"sequence_id": "A266090", "text": "Decimal representation of the n-th iteration of the \"Rule 17\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,1,8,79,64,1663,512,29695,4096,499711,32768,8191999,262144,132644863,2097152,2134900735,16777216,34259075071,134217728,548950507519,1073741824,8789650571263,8589934592,140685948747775,68719476736,2251387496824831,549755813888", "code": " print([2*4**n - 6*8**((n-1)//2) - 1 if n%2 else 8**(n//2) for n in range(50)]) \n"}
{"sequence_id": "A266139", "text": "Volcano palindromes: palindromes not in A110784 such that removing one digit will result in a term in A110784.", "sequence": "0,1,2,3,4,5,6,7,8,9,101,202,212,303,313,323,404,414,424,434,505,515,525,535,545,606,616,626,636,646,656,707,717,727,737,747,757,767,808,818,828,838,848,858,868,878,909,919,929,939,949,959,969,979,989,11011", "code": "\nfrom itertools import combinations_with_replacement as mc\ndef agentod(digits):\n    yield from range(10)\n    for d in range(3, digits+1, 2):\n        for left in mc(\"123456789\", d//2):\n            for center in range(int(left[-1])):\n                yield int(\"\".join(left + (str(center), ) + left[::-1]))\nprint([an for an in agentod(5)]) \n"}
{"sequence_id": "A266141", "text": "Number of n-digit primes in which n-1 of the digits are 2's.", "sequence": "4,2,3,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0", "code": "\nfrom sympy import isprime\ndef A266141(n):\n    return 4 if n==1 else sum(1 for d in '1379' if isprime(int('2'*(n-1)+d))) \n"}
{"sequence_id": "A266142", "text": "Number of n-digit primes in which n-1 of the digits are 3's.", "sequence": "4,8,9,12,7,14,13,11,8,7,9,8,3,10,11,14,9,12,6,11,11,11,9,10,9,10,22,10,10,12,7,14,14,15,7,16,11,7,14,10,13,13,8,10,11,12,6,12,10,10,10,11,5,14,8,8,5,14,6,18,13,9,13,10,4,14,12,6,11,13,12,20,11,9,13,6,12,22,13,10,10,12,5,20,11,10,11,10,11,12,11,13,12,18,7,20,15,6,8,8,8,15,12,10,14", "code": "\nfrom __future__ import division\nfrom sympy import isprime\ndef A266142(n):\n    return 4*n if (n==1 or n==2) else sum(1 for d in range(-3,7) for i in range(n) if isprime((10**n-1)//3+d*10**i)) \n"}
{"sequence_id": "A266144", "text": "Number of n-digit primes in which n-1 of the digits are 5's.", "sequence": "4,2,1,1,0,1,0,2,0,1,0,2,1,0,1,0,0,1,0,0,0,1,0,0,0,2,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom __future__ import division\nfrom sympy import isprime\ndef A266144(n):\n    return 4 if n==1 else sum(1 for d in [-4,-2,2,4] if isprime(5*(10**n-1)//9+d)) \n"}
{"sequence_id": "A266145", "text": "Number of n-digit primes in which n-1 of the digits are 6's.", "sequence": "4,2,1,1,0,1,0,1,1,1,1,0,0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom __future__ import division\nfrom sympy import isprime\ndef A266145(n):\n    return 4 if n==1 else sum(1 for d in [-5,-3,1,3] if isprime(2*(10**n-1)//3+d)) \n"}
{"sequence_id": "A266146", "text": "Number of n-digit primes in which n-1 of the digits are 7's.", "sequence": "4,8,10,9,12,11,8,4,9,9,10,14,14,11,16,7,10,17,7,10,9,12,9,13,11,10,14,5,3,22,6,13,13,10,8,16,8,6,16,8,13,14,8,7,8,13,9,11,13,9,14,8,4,23,13,11,8,8,8,12,13,13,11,11,10,23,11,8,8,3,6,16,12,13,12,12,8,11,8,11,14,13,7,15,12,17,11,7,9,21,6,6,11,12,6,14,14,12,13,12,11,17,10,17,18", "code": "\nfrom __future__ import division\nfrom sympy import isprime\ndef A266146(n):\n     return 4*n if (n==1 or n==2) else sum(1 for d in range(-7,3) for i in range(n) if isprime(7*(10**n-1)//9+d*10**i)) \n"}
{"sequence_id": "A266147", "text": "Number of n-digit primes in which n-1 of the digits are 8's.", "sequence": "4,2,3,1,1,1,0,1,2,0,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom __future__ import division\nfrom sympy import isprime\ndef A266147(n):\n    return 4 if n==1 else sum(1 for d in [-7,-5,-1,1] if isprime(8*(10**n-1)//9+d)) \n"}
{"sequence_id": "A266148", "text": "Number of n-digit primes in which n-1 of the digits are 9's.", "sequence": "4,6,7,7,8,10,7,13,8,8,11,13,8,11,13,14,10,9,7,11,9,13,10,19,5,10,14,7,10,9,9,15,13,8,7,9,10,11,10,13,5,12,15,7,12,7,12,11,13,11,8,13,13,13,12,12,9,9,15,14,9,8,13,11,15,17,10,8,11,10,6,16,8,8,8,15,9,11,14,7,10,11,16,17,11,10,12,16,8,15,7,11,11,10,7,12,6,10,8,9", "code": "\nfrom sympy import isprime\ndef A266148(n):\n    return sum(1 for d in range(-9,1) for i in range(n) if isprime(10**n-1+d*10**i)) \n"}
{"sequence_id": "A266149", "text": "Number of n-digit primes that consist of at least n-1 copies of some decimal digit.", "sequence": "4,21,46,43,40,53,35,49,40,38,44,52,35,45,49,42,38,57,28,45,38,47,38,52,33,45,56,38,36,65,29,56,48,40,38,58,37,33,57,40,37,61,41,39,37,44,36,55,47,43,47,43,35,62,43,46,29,35,37,56,39,41,46,48,39,74,45,34,34,35,34,67,39,45,43", "code": "\nfrom sympy import isprime\ndef a(n):\n  if n == 1: return 4\n  okset = set()\n  for digit1 in \"24568\":\n    for digit2 in \"1379\":\n      t = int(digit1*(n-1) + digit2)\n      if isprime(t): okset.add(t)\n  for digit1 in \"1379\":\n    for digit2 in \"0123456789\":\n      if ((n-1)*int(digit1) + int(digit2))%3 == 0: continue\n      for j in range(n):\n        mc = digit1*j + digit2 + digit1*(n-1-j)\n        if mc[0] == '0': continue\n        t = int(mc)\n        if isprime(t): okset.add(t)\n  return len(okset)\nprint([a(n) for n in range(1, 76)]) \n"}
{"sequence_id": "A266175", "text": "Binary representation of the n-th iteration of the \"Rule 5\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,10,100,1101011,10000,11110101111,1000000,111111010111111,100000000,1111111101011111111,10000000000,11111111110101111111111,1000000000000,111111111111010111111111111,100000000000000,1111111111111101011111111111111,10000000000000000", "code": " print([10*100**n//9 - 101*10**(n-1) if n%2 else 10**n for n in range(30)]) \n"}
{"sequence_id": "A266176", "text": "Decimal representation of the n-th iteration of the \"Rule 5\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,2,4,107,16,1967,64,32447,256,523007,1024,8383487,4096,134197247,16384,2147401727,65536,34359410687,262144,549754503167,1048576,8796087779327,4194304,140737467383807,16777216,2251799729799167,67108864,36028796683419647,268435456", "code": " print([2*4**n -5*2**(n-1) -1 if n%2 else 2**n for n in range(30)]) \n"}
{"sequence_id": "A266179", "text": "Binary representation of the n-th iteration of the \"Rule 6\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,110,10000,1100000,100000000,11000000000,1000000000000,110000000000000,10000000000000000,1100000000000000000,100000000000000000000,11000000000000000000000,1000000000000000000000000,110000000000000000000000000,10000000000000000000000000000", "code": " print([110*100**(n-1) if n%2 else 100**n for n in range(30)]) \n"}
{"sequence_id": "A266180", "text": "Decimal representation of the n-th iteration of the \"Rule 6\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,6,16,96,256,1536,4096,24576,65536,393216,1048576,6291456,16777216,100663296,268435456,1610612736,4294967296,25769803776,68719476736,412316860416,1099511627776,6597069766656,17592186044416,105553116266496,281474976710656", "code": " print([int(4**(n-1)*(5-(-1)**n)) for n in range(30)]) \n"}
{"sequence_id": "A266181", "text": "Numbers n such that n == d_1 (mod 2), n == d_2 (mod 3), n == d_3 (mod 4) etc., where d_1 d_2 d_3 ... is the decimal expansion of n.", "sequence": "1,11311,1032327,1210565,11121217,101033565,111214177,113411719,121254557,123254387,10333633323,12105652565,11121314781937", "code": "\nfor b in range (3,11):\n....for i in range (10**(b-2), 13*10**(b-3)):\n........si,k,kk=str(i),0,i\n........for j in range(1,b):\n............if int(si[len(str(i))-j])==kk%(b+1-j):\n................k=k+1\n........if k==len(str(i)):\n............print (i)\n"}
{"sequence_id": "A266189", "text": "Self-inverse permutation of nonnegative integers: a(n) = A263273(A264985(A263273(n))).", "sequence": "0,1,3,2,4,10,6,9,12,7,5,11,8,13,37,24,28,31,21,19,57,18,27,30,15,36,39,22,16,34,23,17,35,69,29,32,25,14,38,26,40,118,78,109,112,75,46,100,72,82,91,51,85,94,66,64,192,20,73,219,60,171,138,63,55,165,54,81,84,33,90,111,48,58,174,45,108,93,42,117,120,67,49", "code": "\nfrom sympy import factorint\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a030102(n): return 0 if n==0 else int(''.join(map(str, digits(n, 3)[1:][::-1])), 3)\ndef a038502(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==3 else i**f[i] for i in f])\ndef a038500(n): return n/a038502(n)\ndef a263273(n): return 0 if n==0 else a030102(a038502(n))*a038500(n)\ndef a264985(n): return (a263273(2*n + 1) - 1)/2\ndef a(n): return a263273(a264985(a263273(n))) \n"}
{"sequence_id": "A266193", "text": "Decrement by 1 all maximal digits in factorial base representation of n and then shift it one digit right.", "sequence": "0,0,1,1,1,1,2,2,3,3,3,3,4,4,5,5,5,5,4,4,5,5,5,5,6,6,7,7,7,7,8,8,9,9,9,9,10,10,11,11,11,11,10,10,11,11,11,11,12,12,13,13,13,13,14,14,15,15,15,15,16,16,17,17,17,17,16,16,17,17,17,17,18,18,19,19,19,19,20,20,21,21,21,21,22,22,23,23,23,23,22", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a(n):\n    x=str(a007623(n))[::-1]\n    y=\"\".join(str(i) if i + 1==int(x[i]) else x[i] for i in range(len(x)))[1:]\n    return 0 if n==0 else sum(int(y[i])*f(i + 1) for i in range(len(y)))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A266213", "text": "Square array A(n,r), the number of neighbors at a sharp Manhattan distance r in a finite n-hypercube lattice, read by upwards antidiagonals; A(n,r) = Sum_{k=0..min(n,r)} binomial(r-1,k-1)*binomial(n,k)* 2^k.", "sequence": "1,1,0,1,2,0,1,4,2,0,1,6,8,2,0,1,8,18,12,2,0,1,10,32,38,16,2,0,1,12,50,88,66,20,2,0,1,14,72,170,192,102,24,2,0,1,16,98,292,450,360,146,28,2,0,1,18,128,462,912,1002,608,198,32,2,0", "code": "\nfrom sympy import binomial\ndef T(n, r):\n    if r==0: return 1\n    return sum(binomial(r - 1, k - 1) * binomial(n - r, k) * 2**k for k in range(min(n - r, r) + 1))\nfor n in range(11): print([T(n, r) for r in range(n + 1)]) \n"}
{"sequence_id": "A266217", "text": "Binary representation of the n-th iteration of the \"Rule 7\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,110,0,1111111,0,11111111111,0,111111111111111,0,1111111111111111111,0,11111111111111111111111,0,111111111111111111111111111,0,1111111111111111111111111111111,0,11111111111111111111111111111111111,0,111111111111111111111111111111111111111", "code": " print([(10*100**n - 1)//9*(n%2) + 0**n - 0**abs(n-1) for n in range(50)]) \n"}
{"sequence_id": "A266218", "text": "Decimal representation of the n-th iteration of the \"Rule 7\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,6,0,127,0,2047,0,32767,0,524287,0,8388607,0,134217727,0,2147483647,0,34359738367,0,549755813887,0,8796093022207,0,140737488355327,0,2251799813685247,0,36028797018963967,0,576460752303423487,0,9223372036854775807,0", "code": " print([(2*4**n-1)*(n%2) + 0**n - 0**abs(n-1) for n in range(33)]) \n"}
{"sequence_id": "A266219", "text": "Binary representation of the middle column of the \"Rule 7\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,11,110,1101,11010,110101,1101010,11010101,110101010,1101010101,11010101010,110101010101,1101010101010,11010101010101,110101010101010,1101010101010101,11010101010101010,110101010101010101,1101010101010101010,11010101010101010101", "code": " print([(110 - 1)*10**n//99 for n in range(50)]) \n"}
{"sequence_id": "A266224", "text": "Least x such that prime(n)*x+x+1 is a prime, or -1 if no such x exists.", "sequence": "2,1,1,2,1,2,1,2,3,1,3,5,1,2,2,2,1,5,2,1,2,3,4,2,2,1,3,1,3,2,2,3,1,2,1,3,2,5,2,2,1,3,1,2,1,2,5,2,1,2,4,1,3,3,4,5,1,5,2,1,2,3,2,1,5,10,3,2,1,2,2,5,9,3,2,2,3,2,4,2,1,5,1,3,2,4,4", "code": "\nfrom sympy import isprime\nTOP=1000000\nfor p in range(2,777):\n    if isprime(p):\n        failed = True\n        for x in range(1,TOP):\n            if isprime(p*x+x+1):\n                print str(x)+',',\n                failed = False\n                break\n        if failed: print '-1,',\n"}
{"sequence_id": "A266225", "text": "Least x>1 such that prime(n)*x+x-1 is a prime, or -1 if no such x exists.", "sequence": "2,2,2,3,2,3,3,3,2,2,4,3,2,3,4,2,3,7,4,5,6,3,2,2,3,5,3,4,4,2,3,2,6,3,3,4,4,3,3,2,2,4,2,6,3,3,7,7,3,4,2,2,4,2,3,5,3,4,6,2,7,2,4,5,3,3,4,3,6,3,3,2,3,6,7,3,4,3,4,3,2,6,2,3,3,2,6", "code": "\nfrom sympy import isprime\nTOP=1000000\nfor p in range(2,777):\n    if isprime(p):\n        failed = True\n        for x in range(2,TOP):\n            if isprime(p*x+x-1):\n                print str(x)+',',\n                failed = False\n                break\n        if failed: print '-1,',\n"}
{"sequence_id": "A266233", "text": "Primes representable as f(f(f(...f(p)...))) where p is a prime and f(x) = x*2 + 1.", "sequence": "5,7,11,23,31,47,59,71,79,83,107,127,151,167,179,191,223,227,239,263,271,347,359,383,431,439,467,479,503,563,587,599,607,631,719,727,839,863,887,911,919,967,983,991,1019,1031,1087,1103,1151,1187,1231,1279,1283", "code": "\nfrom sympy import isprime\na=[]\nTOP=10000\nfor p in range(TOP):\n    if isprime(p):\n         while p<TOP:\n            p = p*2+1\n            if isprime(p): a.append(p)\nprint(sorted(set(a)))\n"}
{"sequence_id": "A266235", "text": "Primes representable as f(f(f(...f(p)...))) where p is a prime and f(x) = x^2 + 1.", "sequence": "5,101,677,28901,3422501,4884101,260176901,4784488901,5887492901,7370222501,12898144901,14498568101,24840912101,38514062501,47563248101,56249608901,64014060101,110842384901,123657722501,135755402501,205145584901,279343960901,288680544101", "code": "\nfrom sympy import isprime\na=[]\nTOP=1000000\nfor p in range(TOP):\n    if isprime(p):\n        q=p\n        while q<TOP:\n            q = q*q+1\n            if isprime(q):\n                a.append(q)\nprint(sorted(set(a)))\n"}
{"sequence_id": "A266239", "text": "a(n) is the smallest k such that the following are four primes: prime(n)*k-1, prime(n)*k+1, prime(n)*k^2-1, prime(n)*k^2+1. Or -1 if no such k exists.", "sequence": "3,2,6,66,300,24,3744,27000,6,1080,960,90,30,366,9204,8154,1170,840,330,6090,84,27720,324,90,186,4740,2856,6,24270,936,5220,1560,6,1500,510,120,930,3270,30,8520,29700,1200,23310,1056,3540,90,3420,2370,9654,83040,2610,9270,2610", "code": "\nfrom sympy import isprime\nTOP=10**9\nfor p in range(2,333):\n    if isprime(p):\n        failed = True\nfor x in range(1, TOP):\n            if isprime(p*x+1) and isprime(p*x-1) and isprime(p*x*x-1) and isprime(p*x*x+1):\n                print str(x)+',',\n                failed = False\n                break\n        if failed: print '-1, ',\n"}
{"sequence_id": "A266244", "text": "Binary representation of the n-th iteration of the \"Rule 9\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,0,101,1100000,11101,11110100000,11101,111111110100000,11101,1111111111110100000,11101,11111111111111110100000,11101,111111111111111111110100000,11101,1111111111111111111111110100000,11101,11111111111111111111111111110100000,11101", "code": " print([1, 0, 101, 1100000]+[100**n//10 + 1011010*100**n//999900 - 1011010 if n%2 else 11101 for n in range(4,30)]) \n"}
{"sequence_id": "A266245", "text": "Decimal representation of the n-th iteration of the \"Rule 9\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,0,5,96,29,1952,29,32672,29,524192,29,8388512,29,134217632,29,2147483552,29,34359738272,29,549755813792,29,8796093022112,29,140737488355232,29,2251799813685152,29,36028797018963872,29,576460752303423392,29,9223372036854775712", "code": " print([1, 0, 5, 96]+[4**n//2 + 90*(4**n//60) - 90 if n%2 else 29 for n in range(4,50)]) \n"}
{"sequence_id": "A266247", "text": "Binary representation of the middle column of the \"Rule 9\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,10,101,1010,10101,101011,1010110,10101101,101011010,1010110101,10101101010,101011010101,1010110101010,10101101010101,101011010101010,1010110101010101,10101101010101010,101011010101010101,1010110101010101010,10101101010101010101", "code": " print([1, 10, 101, 1010] + [(100000*10**n//9 + 100001*10**n)//110000 for n in range(4, 50)]) \n"}
{"sequence_id": "A266248", "text": "Decimal representation of the middle column of the \"Rule 9\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,2,5,10,21,43,86,173,346,693,1386,2773,5546,11093,22186,44373,88746,177493,354986,709973,1419946,2839893,5679786,11359573,22719146,45438293,90876586,181753173,363506346,727012693,1454025386,2908050773,5816101546,11632203093", "code": " print([1, 2, 5, 10] + [65*2**n//48 for n in range(4, 50)]) \n"}
{"sequence_id": "A266254", "text": "Binary representation of the n-th iteration of the \"Rule 11\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,100,11,1111100,11,11111111100,11,111111111111100,11,1111111111111111100,11,11111111111111111111100,11,111111111111111111111111100,11,1111111111111111111111111111100,11,11111111111111111111111111111111100,11", "code": " print([(10*100**n - 100)//9 if n%2 else 11 - 10*0**n for n in range(50)]) \n"}
{"sequence_id": "A266255", "text": "Decimal representation of the n-th iteration of the \"Rule 11\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,4,3,124,3,2044,3,32764,3,524284,3,8388604,3,134217724,3,2147483644,3,34359738364,3,549755813884,3,8796093022204,3,140737488355324,3,2251799813685244,3,36028797018963964,3,576460752303423484,3,9223372036854775804,3", "code": " print([2*4**n - 4 if n%2 else 3 - 2*0**n for n in range(33)]) \n"}
{"sequence_id": "A266281", "text": "a(1)=1; a(n) is the first integer > a(n-1) with which, in the a(n-1)/a(n) decimal expansion, n is present.", "sequence": "1,4,11,13,14,17,19,22,23,29,34,47,58,61,65,87,89,93,94,97,102,103,105,109,113,115,116,118,121,130,131,136,139,141,149,152,157,159,161,166,167,169,174,177,179,181,184,188,191,193,194,197,199,203,218,223,224", "code": "\nalfa = 1\nfor n in range(2,101):\n    beta = alfa\n    aflag = 0\n    while aflag == 0:\n        beta = beta + 1\n        restlist = []\n        result = \"\"\n        dividend = alfa\n        lenn = len(str(n))\n        bflag = 0\n        while bflag < lenn:\n            dividend = dividend * 10\n            q = dividend/beta\n            resto = dividend - (q * beta)\n            if resto == 0:\n                bflag = lenn\n            if resto in restlist:\n                bflag = bflag + 1\n            restlist.append(resto)\n            dividend = resto\n            result = result + str(q)\n            if str(n) in result:\n                bflag = lenn\n                aflag = 1\n    print alfa\n    alfa = beta\n"}
{"sequence_id": "A266283", "text": "Binary representation of the n-th iteration of the \"Rule 13\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,10,101,1101010,10101,11110101010,1010101,111111010101010,101010101,1111111101010101010,10101010101,11111111110101010101010,1010101010101,111111111111010101010101010,101010101010101,1111111111111101010101010101010,10101010101010101", "code": " print([(10*100**n - (1000*10**n-1)//11 - 1)//9 if n%2 else (100*10**n-1)//99 for n in range(50)]) \n"}
{"sequence_id": "A266284", "text": "Decimal representation of the n-th iteration of the \"Rule 13\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,2,5,106,21,1962,85,32426,341,522922,1365,8383146,5461,134195882,21845,2147396266,87381,34359388842,349525,549754415786,1398101,8796087429802,5592405,140737465985706,22369621,2251799724206762,89478485,36028796661050026,357913941", "code": " print([2*4**n - (8*2**n-1)//3 - 1 if n%2 else (4*2**n-1)//3 for n in range(50)]) \n"}
{"sequence_id": "A266295", "text": "2-free tetranacci sequence beginning 1,3,5,7.", "sequence": "1,3,5,7,1,1,7,1,5,7,5,9,13,17,11,25,33,43,7,27,55,33,61,11,5,55,33,13,53,77,11,77,109,137,167,245,329,439,295,327,695,439,439,475,1,677,199,169,523,49,235,61,217,281,397,239,567,371,787", "code": "\n\ndef main():\n    name = \"b266295.txt\"\n    file = open(name, 'w')\n    file.write('1' + ' ' + '1\\n')\n    file.write('2' + ' ' + '3\\n')\n    file.write('3' + ' ' + '5\\n')\n    file.write('4' + ' ' + '7\\n')\n    a, b, c, d = 1, 3, 5, 7\nfor i in range(5,10001):\n        x=a+b+c+d\n        while x%2==0:\n            x /= 2\n        a, b, c, d = b, c, d, x\n        file.write(str(i) + ' ' + str(d) + '\\n')\n    file.close()\nmain()\n"}
{"sequence_id": "A266299", "text": "Binary representation of the n-th iteration of the \"Rule 14\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,110,11000,1100000,110000000,11000000000,1100000000000,110000000000000,11000000000000000,1100000000000000000,110000000000000000000,11000000000000000000000,1100000000000000000000000,110000000000000000000000000,11000000000000000000000000000", "code": " print([int(110*100**(n-1)) for n in range(50)]) \n"}
{"sequence_id": "A266301", "text": "Binary representation of the n-th iteration of the \"Rule 15\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,110,1,1111110,1,11111111110,1,111111111111110,1,1111111111111111110,1,11111111111111111111110,1,111111111111111111111111110,1,1111111111111111111111111111110,1,11111111111111111111111111111111110,1,111111111111111111111111111111111111110", "code": " print([(10*100**n - 10)//9 if n%2 else 1 for n in range(50)]) \n"}
{"sequence_id": "A266302", "text": "Decimal representation of the n-th iteration of the \"Rule 15\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,6,1,126,1,2046,1,32766,1,524286,1,8388606,1,134217726,1,2147483646,1,34359738366,1,549755813886,1,8796093022206,1,140737488355326,1,2251799813685246,1,36028797018963966,1,576460752303423486,1,9223372036854775806,1", "code": " print([2*4**n - 2 if n%2 else 1 for n in range(50)]) \n"}
{"sequence_id": "A266323", "text": "Binary representation of the n-th iteration of the \"Rule 19\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,101,0,1111111,0,11111111111,0,111111111111111,0,1111111111111111111,0,11111111111111111111111,0,111111111111111111111111111,0,1111111111111111111111111111111,0,11111111111111111111111111111111111,0,111111111111111111111111111111111111111", "code": " print([(10*100**n - 1)//9*(n%2) + 0**n - 10*0**abs(n-1) for n in range(50)]) \n"}
{"sequence_id": "A266324", "text": "Decimal representation of the n-th iteration of the \"Rule 19\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,5,0,127,0,2047,0,32767,0,524287,0,8388607,0,134217727,0,2147483647,0,34359738367,0,549755813887,0,8796093022207,0,140737488355327,0,2251799813685247,0,36028797018963967,0,576460752303423487,0,9223372036854775807,0", "code": " print([(2*4**n - 1)*(n%2) + 0**n - 2*0**abs(n-1) for n in range(50)]) \n"}
{"sequence_id": "A266341", "text": "If A036987(n) = 1, a(n) = n - A053644(n), otherwise a(n) = n - A053644(n) + 2^(A063250(n)-1).", "sequence": "0,0,1,1,2,3,3,3,4,5,6,7,6,7,7,7,8,9,10,11,12,13,14,15,12,13,14,15,14,15,15,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,24,25,26,27,28,29,30,31,28,29,30,31,30,31,31,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50", "code": "\nfrom sympy import catalan\ndef a063250(n):\n    if n<2: return 0\n    b=bin(n)[2:]\n    s=0\n    while b.count(\"0\")!=0:\n        N=int(b[-1] + b[:-1], 2)\n        s+=1\n        b=bin(N)[2:]\n    return s\ndef a053644(n): return 0 if n==0 else 2**(len(bin(n)[2:]) - 1)\ndef a036987(n): return catalan(n)%2\ndef a(n): return n - a053644(n) if a036987(n)==1 else n - a053644(n) + 2**(a063250(n) - 1) \n"}
{"sequence_id": "A266379", "text": "Binary representation of the n-th iteration of the \"Rule 21\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,11,0,1111111,0,11111111111,0,111111111111111,0,1111111111111111111,0,11111111111111111111111,0,111111111111111111111111111,0,1111111111111111111111111111111,0,11111111111111111111111111111111111,0,111111111111111111111111111111111111111", "code": " print([(10*100**n - 1)//9*(n%2) + 0**n - 100*0**abs(n-1) for n in range(50)]) \n"}
{"sequence_id": "A266380", "text": "Decimal representation of the n-th iteration of the \"Rule 21\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,3,0,127,0,2047,0,32767,0,524287,0,8388607,0,134217727,0,2147483647,0,34359738367,0,549755813887,0,8796093022207,0,140737488355327,0,2251799813685247,0,36028797018963967,0,576460752303423487,0,9223372036854775807,0", "code": " print([(2*4**n - 1)*(n%2) + 0**n - 4*0**abs(n-1) for n in range(50)]) \n"}
{"sequence_id": "A266388", "text": "Integers k such that the concatenation of 2^k and 2^k - 1 is prime.", "sequence": "2,14,18,58,570,3198,4462,7266", "code": "\nfrom sympy import isprime\ndef afind(limit, startk=0):\n    pow2 = 2**startk\n    for k in range(startk, limit+1):\n        if isprime(int(str(pow2) + str(pow2 - 1))): print(k, end=\", \")\n        pow2 *= 2\nafind(600) \n"}
{"sequence_id": "A266435", "text": "Binary representation of the n-th iteration of the \"Rule 23\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,111,0,1111111,0,11111111111,0,111111111111111,0,1111111111111111111,0,11111111111111111111111,0,111111111111111111111111111,0,1111111111111111111111111111111,0,11111111111111111111111111111111111,0,111111111111111111111111111111111111111", "code": " print([(10*100**n-1)//9*(n%2) + 0**n for n in range(33)]) \n"}
{"sequence_id": "A266436", "text": "Decimal representation of the n-th iteration of the \"Rule 23\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,7,0,127,0,2047,0,32767,0,524287,0,8388607,0,134217727,0,2147483647,0,34359738367,0,549755813887,0,8796093022207,0,140737488355327,0,2251799813685247,0,36028797018963967,0,576460752303423487,0,9223372036854775807,0", "code": " print([(2*4**n-1)*(n%2) + 0**n for n in range(33)]) \n"}
{"sequence_id": "A266442", "text": "Binary representation of the n-th iteration of the \"Rule 25\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,1,1010,1000011,1110100,11010000111,11101000,111110100001111,111010000,1111111101000011111,1110100000,11111111111010000111111,11101000000,111111111111110100001111111,111010000000,1111111111111111101000011111111,1110100000000", "code": " print([1, 1, 10, 1000011] + [(10*100**n - 909999*10**((n+1)//2) - 1)//9 if n%2 else 11101*10**(n//2) for n in range(4,50)]) \n"}
{"sequence_id": "A266443", "text": "Decimal representation of the n-th iteration of the \"Rule 25\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,1,10,67,116,1671,232,32015,464,522783,928,8385599,1856,134211711,3712,2147471615,7424,34359714303,14848,549755765759,29696,8796092925951,59392,140737488162815,118784,2251799813300223,237568,36028797018193919,475136", "code": " print([1, 1, 10, 67] + [2*4**n-47*2**((n+1)//2)-1 if n%2 else 29*2**(n//2) for n in range(4,30)]) \n"}
{"sequence_id": "A266460", "text": "Binary representation of the n-th iteration of the \"Rule 27\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,101,10,1111011,100,11111110111,1000,111111111101111,10000,1111111111111011111,100000,11111111111111110111111,1000000,111111111111111111101111111,10000000,1111111111111111111111011111111,100000000,11111111111111111111111110111111111", "code": " print([(10*(100**n - 9*10**(n//2)) - 1)//9 if n%2 else 10**(n//2) for n in range(50)]) \n"}
{"sequence_id": "A266461", "text": "Decimal representation of the n-th iteration of the \"Rule 27\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,5,2,123,4,2039,8,32751,16,524255,32,8388543,64,134217599,128,2147483391,256,34359737855,512,549755812863,1024,8796093020159,2048,140737488351231,4096,2251799813677055,8192,36028797018947583,16384,576460752303390719,32768", "code": " print([2*(4**n - 2**(n//2)) - 1 if n%2 else 2**(n//2) for n in range(50)]) \n"}
{"sequence_id": "A266508", "text": "Binary representation of the n-th iteration of the \"Rule 28\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,11,101,1011,10101,101011,1010101,10101011,101010101,1010101011,10101010101,101010101011,1010101010101,10101010101011,101010101010101,1010101010101011,10101010101010101,101010101010101011,1010101010101010101,10101010101010101011", "code": " print([(100*10**n + 89)//99 for n in range(50)]) \n"}
{"sequence_id": "A266513", "text": "Number of undirected cycles in a triangular grid graph, n vertices on each side.", "sequence": "0,1,11,110,2402,128967,16767653,5436906668,4406952731948,8819634719356421,43329348004927734247,522235268182347360718818,15436131339319739257518081878,1117847654274955574635482276231683,198163274851163063009517020867737770265", "code": "\n\nfrom graphillion import GraphSet\ndef make_n_triangular_grid_graph(n):\n    s = 1\n    grids = []\n    for i in range(n + 1, 1, -1):\n        for j in range(i - 1):\n            a, b, c = s + j, s + j + 1, s + i + j\n            grids.extend([(a, b), (a, c), (b, c)])\n        s += i\n    return grids\ndef A266513(n):\n    if n == 1: return 0\n    universe = make_n_triangular_grid_graph(n - 1)\n    GraphSet.set_universe(universe)\n    cycles = GraphSet.cycles()\n    return cycles.len()\nprint([A266513(n) for n in range(1, 12)])  \n"}
{"sequence_id": "A266515", "text": "Binary representation of the n-th iteration of the \"Rule 29\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,11,100,1101111,10000,11110111111,1000000,111111011111111,100000000,1111111101111111111,10000000000,11111111110111111111111,1000000000000,111111111111011111111111111,100000000000000,1111111111111101111111111111111,10000000000000000", "code": " print([(10*(100**n - 9*10**n) - 1)//9 if n%2 else 10**n for n in range(50)]) \n"}
{"sequence_id": "A266516", "text": "Decimal representation of the n-th iteration of the \"Rule 29\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,3,4,111,16,1983,64,32511,256,523263,1024,8384511,4096,134201343,16384,2147418111,65536,34359476223,262144,549754765311,1048576,8796088827903,4194304,140737471578111,16777216,2251799746576383,67108864,36028796750528511,268435456", "code": " print([2*(4**n - 2**n) - 1 if n%2 else 2**n for n in range(50)]) \n"}
{"sequence_id": "A266551", "text": "Image of n under the 3p+1 map, which is a variation of the 3x+1 (Collatz) map.", "sequence": "7,10,2,16,3,22,4,3,5,34,6,40,7,5,8,52,9,58,10,7,11,70,12,5,13,9,14,88,15,94,16,11,17,7,18,112,19,13,20,124,21,130,22,15,23,142,24,7,25,17,26,160,27,11,28,19,29,178,30,184,31,21,32,13,33,202,34,23,35,214,36,220,37,25", "code": "\nfrom sympy import isprime, primefactors\ndef a(n): return 3*n + 1 if isprime(n) else n//min(primefactors(n))\nprint([a(n) for n in range(2, 101)]) \n"}
{"sequence_id": "A266552", "text": "Irregular triangle read by rows giving the 3p+1 sequence of n.", "sequence": "2,3,10,5,16,8,4,2,4,2,5,16,8,4,2,6,3,10,5,16,8,4,2,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,8,4,2,9,3,10,5,16,8,4,2,10,5,16,8,4,2,11,34,17,52,26,13,40,20,10,5,16,8,4,2", "code": "\nfrom sympy import isprime, primefactors\ndef a(n):\n    if n==2: return [2]\n    l=[n, ]\n    while True:\n        if isprime(n): n = 3*n + 1\n        else: n/=min(primefactors(n))\n        l+=[n, ]\n        if n==2: break\n    return l\nfor n in range(2, 21): print a(n) \n"}
{"sequence_id": "A266589", "text": "Binary representation of the n-th iteration of the \"Rule 37\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,10,1110,1000001,111000,11100000111,11100000,111110000011111,1110000000,1111111000001111111,111000000000,11111111100000111111111,11100000000000,111111111110000011111111111,1110000000000000,1111111111111000001111111111111,111000000000000000", "code": " print([1, 10] + [(10*100**n - 99999*10**(n-2) - 1)//9 if n%2 else 111*10**(n-1) for n in range(2, 50)]) \n"}
{"sequence_id": "A266590", "text": "Decimal representation of the n-th iteration of the \"Rule 37\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,2,14,65,56,1799,224,31775,896,520319,3584,8372735,14336,134154239,57344,2147229695,229376,34358722559,917504,549751750655,3670016,8796076769279,14680064,140737423343615,58720256,2251799553638399,234881024,36028795978776575", "code": " print([1, 2] + [2*4**n - 31*2**(n-2) - 1 if n%2 else 7*2**(n-1) for n in range(2, 50)]) \n"}
{"sequence_id": "A266606", "text": "Binary representation of the n-th iteration of the \"Rule 39\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,110,10,1111101,100,11111111011,1000,111111111110111,10000,1111111111111101111,100000,11111111111111111011111,1000000,111111111111111111110111111,10000000,1111111111111111111111101111111,100000000,11111111111111111111111111011111111", "code": " print([(10*100**n - 1)//9*(n%2) + (-1)**n*10**(n//2)  for n in range(50)]) \n"}
{"sequence_id": "A266607", "text": "Decimal representation of the n-th iteration of the \"Rule 39\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,6,2,125,4,2043,8,32759,16,524271,32,8388575,64,134217663,128,2147483519,256,34359738111,512,549755813375,1024,8796093021183,2048,140737488353279,4096,2251799813681151,8192,36028797018955775,16384,576460752303407103,32768", "code": " print([(2*4**n - 1)*(n%2) + (-1)**n*2**(n//2)  for n in range(50)]) \n"}
{"sequence_id": "A266609", "text": "Binary representation of the n-th iteration of the \"Rule 41\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,0,101,1100100,1,11111111000,101,111111111100100,1,1111111111111111000,101,11111111111111111100100,1,111111111111111111111111000,101,1111111111111111111111111100100,1,11111111111111111111111111111111000,101", "code": " print([(10*100**n + 10 - 1010*(n%4))//9 - 10675*0**((n+1)%4) if n%2 else  101**((n%4)//2) for n in range(50)]) \n"}
{"sequence_id": "A266610", "text": "Decimal representation of the n-th iteration of the \"Rule 41\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,0,5,100,1,2040,5,32740,1,524280,5,8388580,1,134217720,5,2147483620,1,34359738360,5,549755813860,1,8796093022200,5,140737488355300,1,2251799813685240,5,36028797018963940,1,576460752303423480,5,9223372036854775780,1", "code": " print([2*4**n + 2 - 10*(n%4) if n%2 else  5**((n%4)//2) for n in range(50)]) \n"}
{"sequence_id": "A266612", "text": "Binary representation of the middle column of the \"Rule 41\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,10,101,1010,10100,101001,1010010,10100101,101001010,1010010101,10100101010,101001010101,1010010101010,10100101010101,101001010101010,1010010101010101,10100101010101010,101001010101010101,1010010101010101010,10100101010101010101", "code": " print([99991*10**n//99000 for n in range(50)]) \n"}
{"sequence_id": "A266613", "text": "Decimal representation of the middle column of the \"Rule 41\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,2,5,10,20,41,82,165,330,661,1322,2645,5290,10581,21162,42325,84650,169301,338602,677205,1354410,2708821,5417642,10835285,21670570,43341141,86682282,173364565,346729130,693458261,1386916522,2773833045,5547666090,11095332181", "code": " print([31*2**n//24 for n in range(50)]) \n"}
{"sequence_id": "A266660", "text": "Binary representation of the n-th iteration of the \"Rule 47\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,110,11,1111100,11,11111111100,11,111111111111100,11,1111111111111111100,11,11111111111111111111100,11,111111111111111111111111100,11,1111111111111111111111111111100,11,11111111111111111111111111111111100,11", "code": " print([1, 110] + [(10*100**n - 100)//9 if n%2 else 11  for n in range(2, 50)]) \n"}
{"sequence_id": "A266661", "text": "Decimal representation of the n-th iteration of the \"Rule 47\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,6,3,124,3,2044,3,32764,3,524284,3,8388604,3,134217724,3,2147483644,3,34359738364,3,549755813884,3,8796093022204,3,140737488355324,3,2251799813685244,3,36028797018963964,3,576460752303423484,3,9223372036854775804,3", "code": " print([1, 6] + [2*4**n - 4 if n%2 else 3  for n in range(2, 50)]) \n"}
{"sequence_id": "A266667", "text": "Binary representation of the n-th iteration of the \"Rule 51\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,101,100,1110111,10000,11111011111,1000000,111111101111111,100000000,1111111110111111111,10000000000,11111111111011111111111,1000000000000,111111111111101111111111111,100000000000000,1111111111111110111111111111111,10000000000000000", "code": " print([(10*100**n - 9*10**n - 1)//9  if n%2 else 10**n for n in range(50)]) \n"}
{"sequence_id": "A266668", "text": "Decimal representation of the n-th iteration of the \"Rule 51\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,5,4,119,16,2015,64,32639,256,523775,1024,8386559,4096,134209535,16384,2147450879,65536,34359607295,262144,549755289599,1048576,8796090925055,4194304,140737479966719,16777216,2251799780130815,67108864,36028796884746239,268435456", "code": " print([2*4**n - 2**n - 1  if n%2 else 2**n for n in range(50)]) \n"}
{"sequence_id": "A266670", "text": "Binary representation of the n-th iteration of the \"Rule 53\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,11,1000,1011111,1000000,11011111111,1000000000,111011111111111,1000000000000,1111011111111111111,1000000000000000,11111011111111111111111,1000000000000000000,111111011111111111111111111,1000000000000000000000,1111111011111111111111111111111", "code": " print([(1000*10000**(n//2) - 900*1000**(n//2) - 1)//9 if n%2 else 1000**(n//2) for n in range(50)]) \n"}
{"sequence_id": "A266671", "text": "Decimal representation of the n-th iteration of the \"Rule 53\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,3,8,95,64,1791,512,30719,4096,507903,32768,8257535,262144,133169151,2097152,2139095039,16777216,34292629503,134217728,549218942975,1073741824,8791798054911,8589934592,140703128616959,68719476736,2251524935778303,549755813888", "code": " print([8*16**(n//2) - 4*8**(n//2) - 1 if n%2 else 8**(n//2) for n in range(50)]) \n"}
{"sequence_id": "A266717", "text": "Binary representation of the n-th iteration of the \"Rule 59\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,101,110,1111011,1100,11111110111,11000,111111111101111,110000,1111111111111011111,1100000,11111111111111110111111,11000000,111111111111111111101111111,110000000,1111111111111111111111011111111,1100000000,11111111111111111111111110111111111", "code": " print([(10*100**n - 9*10**((n+1)//2) - 1)//9 if n%2 else 11*10**(n//2) - 10*0**n for n in range(50)]) \n"}
{"sequence_id": "A266718", "text": "Decimal representation of the n-th iteration of the \"Rule 59\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,5,6,123,12,2039,24,32751,48,524255,96,8388543,192,134217599,384,2147483391,768,34359737855,1536,549755812863,3072,8796093020159,6144,140737488351231,12288,2251799813677055,24576,36028797018947583,49152,576460752303390719,98304", "code": " print([2*4**n - 2**((n+1)//2) - 1 if n%2 else 3*2**(n//2) - 2*0**n for n in range(50)]) \n"}
{"sequence_id": "A266720", "text": "Binary representation of the middle column of the \"Rule 59\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,10,101,1011,10110,101101,1011010,10110101,101101010,1011010101,10110101010,101101010101,1011010101010,10110101010101,101101010101010,1011010101010101,10110101010101010,101101010101010101,1011010101010101010,10110101010101010101", "code": " print([10009*10**n//9900 for n in range(50)]) \n"}
{"sequence_id": "A266721", "text": "Decimal representation of the middle column of the \"Rule 59\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,2,5,11,22,45,90,181,362,725,1450,2901,5802,11605,23210,46421,92842,185685,371370,742741,1485482,2970965,5941930,11883861,23767722,47535445,95070890,190141781,380283562,760567125,1521134250,3042268501,6084537002,12169074005", "code": " print([17*2**n//12  for n in range(50)]) \n"}
{"sequence_id": "A266727", "text": "Stanley sequence S(0,1,7).", "sequence": "0,1,7,8,10,11,17,18,30,31,37,38,40,41,47,48,90,91,97,98,100,101,107,108,120,121,127,128,130,131,137,138,270,271,277,278,280,281,287,288,300,301,307,308,310,311,317,318,360,361,367,368,370,371,377,378,390", "code": "\nA266727_list = [0,1,7]\nfor i in range(1000):\n    n, flag = A266727_list[-1]+1, False\n    while True:\n        for j in range(i+2,0,-1):\n            m = 2*A266727_list[j]-n\n            if m in A266727_list:\n                break\n            if m < A266727_list[0]:\n                flag = True\n                break\n        else:\n            A266727_list.append(n)\n            break\n        if flag:\n            A266727_list.append(n)\n            break\n        n += 1 \n"}
{"sequence_id": "A266787", "text": "Binary representation of the n-th iteration of the \"Rule 61\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,11,1100,1010111,1111000,11010001111,1111010000,111010001111111,1111010000000,1111010001111111111,1111010000000000,11111010001111111111111,1111010000000000000,111111010001111111111111111,1111010000000000000000,1111111010001111111111111111111", "code": " print([1, 11, 1100, 1010111, 1111000] + [10*100**n - 90999*1000**(n//2)//100 - 1)//9 if n%2 else 111101*1000**(n//2)//100000 for n in range(5,50)]) \n"}
{"sequence_id": "A266788", "text": "Decimal representation of the n-th iteration of the \"Rule 61\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,3,12,87,120,1679,976,29823,7808,500735,62464,8200191,499712,132710399,3997696,2135425023,31981568,34263269375,255852544,548984061951,2046820352,8789919006719,16374562816,140688096231423,130996502528,2251404676694015,1047972020224", "code": " print([1, 3, 12, 87, 120] + [2*4**n - 23*8**(n//2)//4 - 1 if n%2 else 61*8**(n//2)//32 for n in range(5,50)]) \n"}
{"sequence_id": "A266882", "text": "Primes p(n) such that p(n) + p(n+3) = p(n+1) + p(n+2) and p(n) + p(n+4) = p(n+2) + p(n+3).", "sequence": "13,37,223,1087,1423,1483,2683,4783,6079,7331,7547,11057,12269,12401,12641,17333,19471,20743,21799,23027,27733,28097,29017,29389,30631,30859,33191,33343,33587,33613,35527,36551,42457,44263,45817,48857,49459,54499,55813,57329,58151,59207", "code": "\nfrom sympy import primerange\nb, c, d, e = 2, 3, 5, 7\nfor p in primerange(11, 10**9):\n... a, b, c, d, e = b, c, d, e, p\n... if a + d == b + c and a + e == c + d:\n....... print a\n"}
{"sequence_id": "A266883", "text": "Numbers of the form m*(4*m+1)+1, where m = 0,-1,1,-2,2,-3,3,...", "sequence": "1,4,6,15,19,34,40,61,69,96,106,139,151,190,204,249,265,316,334,391,411,474,496,565,589,664,690,771,799,886,916,1009,1041,1140,1174,1279,1315,1426,1464,1581,1621,1744,1786,1915,1959,2094,2140,2281,2329,2476,2526", "code": " [n*(n+1)+1-((2*n+1)*(-1)**n-1)/4 for n in range(60)]\n"}
{"sequence_id": "A266956", "text": "Numbers m such that 9*m+7 is a square.", "sequence": "1,2,18,21,53,58,106,113,177,186,266,277,373,386,498,513,641,658,802,821,981,1002,1178,1201,1393,1418,1626,1653,1877,1906,2146,2177,2433,2466,2738,2773,3061,3098,3402,3441,3761,3802,4138,4181,4533,4578,4946,4993,5377,5426", "code": " from gmpy2 import is_square\n[n for n in range(6000) if is_square(9*n+7)]\n"}
{"sequence_id": "A266956", "text": "Numbers m such that 9*m+7 is a square.", "sequence": "1,2,18,21,53,58,106,113,177,186,266,277,373,386,498,513,641,658,802,821,981,1002,1178,1201,1393,1418,1626,1653,1877,1906,2146,2177,2433,2466,2738,2773,3061,3098,3402,3441,3761,3802,4138,4181,4533,4578,4946,4993,5377,5426", "code": " [(18*(n-1)*n-7*(2*n-1)*(-1)**n+1)/8 for n in range(1, 60)]\n"}
{"sequence_id": "A266957", "text": "Numbers m such that 9*m+10 is a square.", "sequence": "-1,6,10,31,39,74,86,135,151,214,234,311,335,426,454,559,591,710,746,879,919,1066,1110,1271,1319,1494,1546,1735,1791,1994,2054,2271,2335,2566,2634,2879,2951,3210,3286,3559,3639,3926,4010,4311,4399,4714,4806,5135,5231,5574", "code": " from gmpy2 import is_square\n[n for n in range(-1,6000) if is_square(9*n+10)]\n"}
{"sequence_id": "A266957", "text": "Numbers m such that 9*m+10 is a square.", "sequence": "-1,6,10,31,39,74,86,135,151,214,234,311,335,426,454,559,591,710,746,879,919,1066,1110,1271,1319,1494,1546,1735,1791,1994,2054,2271,2335,2566,2634,2879,2951,3210,3286,3559,3639,3926,4010,4311,4399,4714,4806,5135,5231,5574", "code": " [(18*(n-1)*n+5*(2*n-1)*(-1)**n-3)/8 for n in range(1, 60)]\n"}
{"sequence_id": "A266958", "text": "Numbers m such that 9*m+13 is a square.", "sequence": "-1,4,12,27,43,68,92,127,159,204,244,299,347,412,468,543,607,692,764,859,939,1044,1132,1247,1343,1468,1572,1707,1819,1964,2084,2239,2367,2532,2668,2843,2987,3172,3324,3519,3679,3884,4052,4267,4443,4668,4852,5087,5279,5524", "code": " from gmpy2 import is_square\n[n for n in range(-1,6000) if is_square(9*n+13)]\n"}
{"sequence_id": "A266958", "text": "Numbers m such that 9*m+13 is a square.", "sequence": "-1,4,12,27,43,68,92,127,159,204,244,299,347,412,468,543,607,692,764,859,939,1044,1132,1247,1343,1468,1572,1707,1819,1964,2084,2239,2367,2532,2668,2843,2987,3172,3324,3519,3679,3884,4052,4267,4443,4668,4852,5087,5279,5524", "code": " [(18*(n-1)*n+(2*n-1)*(-1)**n-7)/8 for n in range(1,60)]\n"}
{"sequence_id": "A267077", "text": "Least m>0 for which m*n^2 + 1 is a square and m*triangular(n) + 1 is a triangular number (A000217). Or -1 if no such m exists.", "sequence": "1,35,30,18135,189,27,321300,23760,1188585957,1656083,26,244894427400,82093908624206325,1858717755529547,86478,21491811639746039592", "code": "\nfrom math import sqrt\ndef A267077(n):\n    if n == 0:\n        return 1\n    u,v,t,w = max(8,2*n),max(4,n)**2-9,4*n*(n+1),n**2\n    while True:\n        m,r = divmod(v,t)\n        if not r and int(sqrt(m*w+1))**2 == m*w+1:\n            return m\n        v += u+1\n        u += 2 \n"}
{"sequence_id": "A267140", "text": "Least m>0 for which m + n^2 is a square and m + triangular(n) is a triangular number (A000217).", "sequence": "1,35,12,72,180,336,45,792,1092,208,1836,2280,112,315,3900,4536,644,5952,6732,7560,225,715,10332,627,12420,13536,924,1575,17172,840,396,21240,22692,3267,2565,27336,28980,3392,32412,34200,1881,3795,637,1400,1785,45936,2240", "code": "\nfrom math import sqrt\ndef A267140(n):\n    u,r,k,m = 2*n+1,4*n*(n+1)+1,0,2*n+1\n    while True:\n        if int(sqrt(8*m+r))**2 == 8*m+r:\n            return m\n        k += 2\n        m += u + k \n"}
{"sequence_id": "A267144", "text": "Octagonal numbers with prime indices.", "sequence": "8,21,65,133,341,481,833,1045,1541,2465,2821,4033,4961,5461,6533,8321,10325,11041,13333,14981,15841,18565,20501,23585,28033,30401,31621,34133,35425,38081,48133,51221,56033,57685,66305,68101,73633,79381,83333,89441,95765", "code": "\nfrom sympy import prime\ndef a(n): p = prime(n); return p*(3*p-2)\nprint([a(n) for n in range(1, 42)]) \n"}
{"sequence_id": "A267254", "text": "Binary representation of the n-th iteration of the \"Rule 111\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,110,111,1111010,11111,11111100010,1011111,111111111100010,1011111,1111111111111100010,1011111,11111111111111111100010,1011111,111111111111111111111100010,1011111,1111111111111111111111111100010,1011111,11111111111111111111111111111100010", "code": " print([1, 110, 111, 1111010, 11111] + [10*100**n//9 - 11101 if n%2 else 1011111 for n in range(5,50)]) \n"}
{"sequence_id": "A267255", "text": "Decimal representation of the n-th iteration of the \"Rule 111\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,6,7,122,31,2018,95,32738,95,524258,95,8388578,95,134217698,95,2147483618,95,34359738338,95,549755813858,95,8796093022178,95,140737488355298,95,2251799813685218,95,36028797018963938,95,576460752303423458,95,9223372036854775778", "code": " print([1, 6, 7, 122, 31] + [2*4**n - 30 if n%2 else 95  for n in range(5,50)]) \n"}
{"sequence_id": "A267310", "text": "a(n) is the numerator of Sum_{d|n} sigma(n/d)^d/d, where sigma is A000203.", "sequence": "1,7,13,47,31,175,57,479,310,847,133,4799,183,737,4513,25023,307,32123,381,195887,17803,356671,553,1892351,39656,3192287,807286,12898415,871,6727787,993,109575039,12603505,258287671,1630737,502527043,1407,2324532815", "code": "\nfrom __future__ import division\nfrom sympy import divisors, divisor_sigma, gcd\ndef A267310(n):\n    m = sum(d*divisor_sigma(d)**(n//d)  for d in divisors(n, generator=True))\n    return m//gcd(m,n) \n"}
{"sequence_id": "A267367", "text": "Decimal representation of the middle column of the \"Rule 126\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,3,6,13,26,52,104,209,418,836,1672,3344,6688,13376,26752,53505,107010,214020,428040,856080,1712160,3424320,6848640,13697280,27394560,54789120,109578240,219156480,438312960,876625920,1753251840,3506503681,7013007362", "code": "\ndef A267367(n):\n    i, s, z = n, 0, 1\n    while 0 <= i: s += 1<<i; i -= z; z += z\n    return s\nprint([A267367(n) for n in range(33)]) \n"}
{"sequence_id": "A267413", "text": "Dropping any binary digit gives a prime number.", "sequence": "6,7,11,15,35,39,63,135,255,999,2175,8223,16383,57735,131075,131079,262143,524295,1048575,536870919,1073735679,2147483655,4294967295,17179770879", "code": "\nfrom sympy import isprime\ndef ok(n):\n    if n < 7 or n%4 != 3: return n == 6\n    b = bin(n)[2:]\n    return all(isprime(int(b[:i]+b[i+1:], 2)) for i in range(len(b)))\nprint(list(filter(ok, range(2, 2**20)))) \n"}
{"sequence_id": "A267490", "text": "Primes whose base-8 representation is a perfect square in base 10.", "sequence": "149,241,661,1409,2593,3733,6257,7793,15313,23189,25601,26113,30497,34337,44053,49057,78577,92821,95009,108529,115861,132757,162257,178417,183377,223381,235541,242197,266261,327317,345749,426389,525461,693397,719893,729713,805397,814081,903841", "code": "\nfrom sympy import isprime\nA267490_list = [int(s,8) for s in (str(i**2) for i in range(10**6)) if max(s) < '8' and isprime(int(s,8))] \n"}
{"sequence_id": "A267523", "text": "Binary representation of the n-th iteration of the \"Rule 139\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,100,10011,1001111,100111111,10011111111,1001111111111,100111111111111,10011111111111111,1001111111111111111,100111111111111111111,10011111111111111111111,1001111111111111111111111,100111111111111111111111111,10011111111111111111111111111", "code": " print([100**n + int(100**(n-1))//9  for n in range(50)]) \n"}
{"sequence_id": "A267526", "text": "Binary representation of the n-th iteration of the \"Rule 141\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,10,101,1011,1010111,10101111,10101011111,101010111111,101010101111111,1010101011111111,1010101010111111111,10101010101111111111,10101010101011111111111,101010101010111111111111,101010101010101111111111111,1010101010101011111111111111", "code": " print([1, 10] + [10**n*(100**(n//2) - 1)//99 + (10**(n-1) - 1)//9 for n in range(2,50)]) \n"}
{"sequence_id": "A267527", "text": "Decimal representation of the n-th iteration of the \"Rule 141\" elementary cellular automaton starting with a single ON (black) cell.", "sequence": "1,2,5,11,87,175,1375,2751,21887,43775,349695,699391,5593087,11186175,89481215,178962431,1431666687,2863333375,22906535935,45813071871,366504050687,733008101375,5864062713855,11728125427711,93824995033087,187649990066175", "code": " print([1, 2] + [2**n*(4**(n//2) - 1)//3 + 2**(n-1) - 1 for n in range(2,50)]) \n"}
{"sequence_id": "A267682", "text": "a(n) = 2*a(n-1) - 2*a(n-3) + a(n-4) for n > 3, with initial terms 1, 1, 4, 8.", "sequence": "1,1,4,8,15,23,34,46,61,77,96,116,139,163,190,218,249,281,316,352,391,431,474,518,565,613,664,716,771,827,886,946,1009,1073,1140,1208,1279,1351,1426,1502,1581,1661,1744,1828,1915,2003,2094,2186,2281,2377,2476", "code": " print([n*(n-1)+n//2+1 for n in range(51)]) \n"}
{"sequence_id": "A267709", "text": "Number of partitions of pentagonal numbers.", "sequence": "1,1,7,77,1002,14883,239943,4087968,72533807,1327710076,24908858009,476715857290,9275102575355,182973889854026,3652430836071053,73653287861850339,1498478743590581081,30724985147095051099,634350763653787028583,13177726323474524612308", "code": "\nfrom sympy.ntheory import npartitions\nprint([npartitions(n*(3*n - 1)//2) for n in range(51)]) \n"}
{"sequence_id": "A267763", "text": "Numbers whose base-3 representation is a square when read in base 10.", "sequence": "0,1,9,16,81,100,144,235,729,784,900,961,1296,1369,2115,6561,6724,7056,7225,8100,8649,11664,11881,12321,15985,19035,59049,59536,60516,61009,63504,64009,65025,72900,73441,77841,104976,105625,106929,110889,143865,171315,182428,531441,532900,535824,537289,544644,546121", "code": "\nA267763_list = [int(d,3) for d in (str(i**2) for i in range(10**6)) if max(d) < '3'] \n"}
{"sequence_id": "A267764", "text": "Numbers whose base-4 representation is a square when read in base 10.", "sequence": "0,1,16,25,256,289,400,441,673,1761,1849,4096,4225,4624,4761,6400,6561,7056,7713,10768,13401,28176,29584,65536,66049,67600,68121,73984,74529,76176,76729,77985,102400,103041,104976,112896,113569,123408,150081,172288,214416,450816,473344,501433,519873", "code": "\nA267764_list = [int(d,4) for d in (str(i**2) for i in range(10**6)) if max(d) < '4'] \n"}
{"sequence_id": "A267765", "text": "Numbers whose base-5 representation is a square when read in base 10.", "sequence": "0,1,4,25,36,49,89,100,121,139,249,329,351,625,676,729,900,961,1225,1551,1654,2146,2225,2289,2500,2601,3025,3289,3475,3521,3814,4324,4529,4801,5086,5149,6225,6726,6829,7374,8225,8464,8775,9454,9601,13926,15625,15876,16129,16900,17161", "code": "\nA267765_list = [int(d,5) for d in (str(i**2) for i in range(10**6)) if max(d) < '5'] \n"}
{"sequence_id": "A267766", "text": "Numbers whose base-6 representation is a square when read in base 10.", "sequence": "0,1,4,17,36,49,64,89,124,144,169,232,305,388,409,449,544,577,612,665,953,1105,1296,1369,1444,1529,1764,1849,1936,2033,2304,2825,3097,3204,3280,3473,4345,4464,4588,4841,5104,5184,5329,5633,6084,6241,7081,7649,8044,8352,8449,9160,9593", "code": "\nA267766_list = [int(d,6) for d in (str(i**2) for i in range(10**6)) if max(d) < '6'] \n"}
{"sequence_id": "A267767", "text": "Numbers whose base-7 representation is a square when read in base 10.", "sequence": "0,1,4,13,19,27,46,49,64,81,117,139,165,190,196,225,313,361,433,460,571,603,637,705,748,837,883,931,981,1048,1105,1222,1323,1489,1560,1684,1744,2028,2185,2254,2346,2401,2500,2601,2763,2869,3084,3136,3249,3364,3547,3667,3865,3969,4096", "code": "\nA267767_list = [int(s, 7) for s in (str(i**2) for i in range(10**6)) if max(s) < '7'] \n"}
{"sequence_id": "A267768", "text": "Numbers whose base-8 representation is a square when read in base 10.", "sequence": "0,1,4,14,21,30,52,64,81,100,149,174,212,241,256,289,382,405,446,532,622,661,804,849,896,1012,1045,1102,1220,1281,1344,1409,1476,1557,1630,1780,1920,2001,2197,2286,2452,2545,2593,2878,2965,3070,3233,3328,3441,3540,3630,3733,4068,4096", "code": "\nA267768_list = [int(s, 8) for s in (str(i**2) for i in range(10**6)) if max(s) < '8'] \n"}
{"sequence_id": "A267769", "text": "Numbers whose base-9 representation is a square when read in base 10.", "sequence": "0,1,4,15,23,33,58,73,81,100,121,185,213,265,298,324,361,400,474,509,555,643,685,751,861,914,1093,1153,1215,1288,1354,1481,1554,1705,1783,1863,1945,2029,2210,2301,2488,2584,2673,2773,2875,3101,3210,3424,3538,3682,3802,4038,4154,4281,4450", "code": "\nA267769_list = [int(s, 9) for s in (str(i**2) for i in range(10**6)) if max(s) < '9'] \n"}
{"sequence_id": "A267794", "text": "a(n) = n-2-i, where i (0 <= i < n-2) is the largest number such that [a(n-2)-a(i); a(n-1)-a(i+1)] = [0; 0], or a(n) = 0 if no such i exists.", "sequence": "0,0,0,1,0,0,3,0,0,3,3,0,4,0,0,6,0,0,3,9,0,0,4,10,0,0,4,4,0,15,0,0,6,17,0,0,4,10,14,0,0,5,0,0,3,26,0,0,4,12,0,0,4,4,26,0,9,0,37,0,0,9,5,0,21,0,0,6,35,0,0,4,19,0,0,4,4,23,0,0,5,39", "code": "\na=[0, 0]\nfor i in range(1000):\n    for j in range(i-1, -1, -1):\n        if a[j:j+2] == a[-2:]:\n            a.append(i-j)\n            break\n    else:\n        a.append(0)\nprint(a)\n\n"}
{"sequence_id": "A267795", "text": "Integers n such that n, 2n, 3n ... 10n contain almost equally many copies of each base 10 digit.", "sequence": "1,9,109,909,10909,90909,1090909,9090909,13431958,25834963,32973507,38296415,45096237,51546969,94845303,96237045,109090909,113431958,126084879,132868745,132875488,133595248,134319558,134755956,134758658,137584878,143865844,153584878", "code": "\ndef f(n):\n    \"\"\" This returns True iff n is in the sequence \"\"\"\n    l = [ n * i for i in range(1, 11) ]\n  s = \"\".join(str(i) for i in l)\n  c = [ s.count(str(j)) for j in range(10) ]\n  return min(c) >= max(c) - 1\n"}
{"sequence_id": "A267818", "text": "Primes whose base-4 representation is a square when read in base 10.", "sequence": "673,1165921,6228961,53378329,128818873,805379161,926711449,1542173569,2459671993,8365652929,14232980953,26484614209,30755887321,31937961241,37968797689,78180076129,80974979329,97835803129,168394504129,314911422913,410879716321,529074406681", "code": "\nfrom sympy import isprime\nA267818_list = [int(d,4) for d in (str(i**2) for i in range(1,10**6)) if max(d) < '4' and isprime(int(d,4))] \n"}
{"sequence_id": "A267819", "text": "Primes whose base-5 representation is a square when read in base 10.", "sequence": "89,139,4801,6829,9601,48661,305551,539849,867001,3503449,3527071,6063839,13912039,15933439,18100351,18319321,20366399,22849121,26239321,46724801,63565049,78057911,95802799,100294871,102369439,107474911,139769449,141118079,144829879,159468079,161483801", "code": "\nfrom sympy import isprime\nA267819_list = [int(d,5) for d in (str(i**2) for i in range(1,10**6)) if max(d) < '5' and isprime(int(d,5))] \n"}
{"sequence_id": "A267820", "text": "Primes whose base-6 representation is a square when read in base 10.", "sequence": "17,89,409,449,577,953,7649,12401,14593,23689,28393,29033,30689,36809,40153,46457,47969,54577,56393,59273,65033,72649,78713,92033,98953,106033,141353,146249,150209,169657,176489,199889,205433,221849,235273,238481,245033,258569,381841,394633,441193,529273", "code": "\nfrom sympy import isprime\nA267820_list = [int(d,6) for d in (str(i**2) for i in range(1,10**6)) if max(d) < '6' and isprime(int(d,6))] \n"}
{"sequence_id": "A267821", "text": "Primes whose base-9 representation is a square in base 10.", "sequence": "23,73,509,643,751,1093,1153,1481,1783,2029,6067,8011,8933,9613,16061,24763,30803,44203,64633,74521,82723,88003,94033,103171,106619,118669,126541,133321,154571,158293,163561,165883,179821,197339,202393,207643,225523,234733,264083,268003,284593,288661,324931", "code": "\nfrom sympy import isprime\nA267821_list = [int(d,9) for d in (str(i**2) for i in range(1,10**6)) if max(d) < '9' and isprime(int(d,9))] \n"}
{"sequence_id": "A267875", "text": "Decimal expansion of Mersenne prime 2^74207281 - 1.", "sequence": "3,0,0,3,7,6,4,1,8,0,8,4,6,0,6,1,8,2,0,5,2,9,8,6,0,9,8,3,5,9,1,6,6,0,5,0,0,5,6,8,7,5,8,6,3,0,3,0,3,0,1,4,8,4,8,4,3,9,4,1,6,9,3,3,4,5,5,4,7,7,2,3,2,1,9,0,6,7,9,9,4,2,9,6,8,9,3", "code": "\nfrom gmpy2 import mpz\ndef A267875(n): return int((mpz(2)**74207281-1)//mpz(10)**(44677235-n) % 10) \n"}
{"sequence_id": "A267958", "text": "4 times A042965.", "sequence": "0,4,12,16,20,28,32,36,44,48,52,60,64,68,76,80,84,92,96,100,108,112,116,124,128,132,140,144,148,156,160,164,172,176,180,188,192,196,204,208,212,220,224,228,236,240,244,252,256,260,268,272,276,284,288,292,300,304", "code": "\ndef DifferenceOfEvenSquares(maximumBound):\n    sequence = set([0])\n    for x in range(0, maximumBound+1, 4):\n        if x % 16 != 8:\n            sequence.add(x)\n    print(sorted(sequence))\n"}
{"sequence_id": "A267982", "text": "a(n) = 4*n*Catalan(n)^2.", "sequence": "0,4,32,300,3136,35280,418176,5153148,65436800,851005584,11284224640,152054927024,2076911622912,28698821320000,400547241561600,5639401174441500,80010548981049600,1142928467041798800,16425988397113680000,237364657887402183600", "code": "\nfrom __future__ import division\nA267982_list, b = [0], 4\nfor n in range(1,10**2):\n    A267982_list.append(b)\n    b = b*4*(n+1)*(2*n+1)**2//(n*(n+2)**2) \n"}
{"sequence_id": "A268037", "text": "Numbers k such that the number of divisors of k+2 divides k and the number of divisors of k divides k+2.", "sequence": "4,30,48,110,208,270,320,368,510,590,688,750,1070,1216,1328,1566,1808,2030,2190,2510,2670,2768,3008,3088,3728,4110,4208,4430,4528,4688,4698,4910,5008,5696,5870,5886,5968,6128,6592,6846,7088,7310,7790,8384,9008,9230,9390,9488,9534,9710", "code": "\nfrom sympy import divisors\ndef ok(n): return n%len(divisors(n+2)) == 0 and (n+2)%len(divisors(n)) == 0\nprint(list(filter(ok, range(1, 9711)))) \n"}
{"sequence_id": "A268045", "text": "Least number k > 1 such that C(n+k,n) is squarefree.", "sequence": "2,2,2,2,2,2,4,4,3,2,2,2,2,2,9,8,3,6,2,2,2,2,36,36,20,18,36,2,2,2,16,16,2,2,3,12,2,2,4,4,2,2,2,4,3,2,16,896,175,10,2,2,9,9,4,4,2,2,2,2,2,256,417,32,2,2,2,2,2,2,4,36,2,5,5,2,2,2,81,136,135,2", "code": "\nfrom __future__ import division\nfrom collections import Counter\nfrom sympy import factorint\ndef A268045(n):\n    if n == 0:\n        return 2\n    flist, k = Counter(factorint((n+2)*(n+1)//2)), 2\n    while max(flist.values()) >= 2:\n        k += 1\n        flist += Counter(factorint(n+k))\n        flist -= Counter(factorint(k))\n    return k \n"}
{"sequence_id": "A268083", "text": "Numbers n that are not prime powers and such that gcd(binomial(2*n-1,n), n) = 1.", "sequence": "39,55,93,111,119,155,161,185,253,275,279,305,327,333,351,363,377,403,407,413,497,511,517,533,559,629,635,649,655,685,689,697,707,741,749,755,779,785,791,813,817,849,871,893,901,905,923,981,1003,1011,1027,1043", "code": "\nfrom __future__ import division\nfrom fractions import gcd\nfrom sympy import factorint\nA268083_list, b = [], 1\nfor n in range(1,10**4):\n    if len(factorint(n)) > 1 and gcd(b,n) == 1:\n        A268083_list.append(n)\n    b = b*2*(2*n+1)//(n+1) \n"}
{"sequence_id": "A268084", "text": "Minimum number of occurrences of abelian squares in a binary word of length n.", "sequence": "0,0,0,1,2,3,4,4,5,6,7,8,10,11,12,14,15,17,18,20,21,23,24,26,28,29,30,32,34,35,37,39,41,43,44", "code": "\nfrom itertools import product, permutations\ndef count_overlaps(subs, s):\n  c = i = 0\n  while i != -1:\n    i = s.find(subs, i)\n    if i != -1: c += 1; i += 1\n  return c\ndef a(n): \n  ar = (\"\".join(u) for r in range(1, n//2+1) for u in product(\"01\",\nrepeat=r))\n  abel_squares = set(w+\"\".join(wp) for w in ar for wp in permutations(w))\n  words = (\"0\"+\"\".join(w) for w in product(\"10\", repeat=n-1))\n  themin = n*n\n  for w in words:\n    numw = 0\n    for s in abel_squares:\n      numw += count_overlaps(s, w)\n      if numw >= themin: break\n    else: themin = min(themin, numw)\n  return themin\nprint([a(n) for n in range(1, 14)]) \n"}
{"sequence_id": "A268111", "text": "Integers k such that the concatenation of 2^k and 3^k is prime.", "sequence": "0,1,3,7,8,21,23,33,51,88,96,227,287,1231,1924,3035,3614,4598,6112", "code": "\nfrom sympy import isprime\ndef afind(limit, startk=0):\n    pow2, pow3 = 2**startk, 3**startk\n    for k in range(startk, limit+1):\n        if isprime(int(str(pow2) + str(pow3))): print(k, end=\", \")\n        pow2 *= 2; pow3 *= 3\nafind(300) \n"}
{"sequence_id": "A268140", "text": "Smallest prime followed by at least 2^n nonprimes.", "sequence": "3,7,23,113,523,1327,31397,1357201,436273009,304599508537,1693182318746371", "code": "\nfrom sympy import isprime\ndef A268140(n):\n    p, n2 = 2, 2**n+1\n    while True:\n        for i in range(1,n2):\n            if isprime(p+i):\n                p += i\n                break\n        else:\n            return p \n"}
{"sequence_id": "A268176", "text": "a(0) = a(1) = 1, and a(n) = a(n-1) + a( (a(n-1)-1) mod n ) for n>=2.", "sequence": "1,1,2,3,5,10,13,23,36,72,73,86,87,123,196,197,202,398,399,798,1196,1994,2117,2118,2128,2130,4248,4284,8568,8655,8851,9048,11166,11252,20300,40600,44884,44886,44909,45707,49955,50157,50193,50279,59130,118260,163967", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n): return 1 if n<2 else a(n - 1) + a((a(n - 1) - 1)%n)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A268289", "text": "a(0)=0; thereafter a(n) = a(n-1) - A037861(n).", "sequence": "0,1,1,3,2,3,4,7,5,5,5,7,7,9,11,15,12,11,10,11,10,11,12,15,14,15,16,19,20,23,26,31,27,25,23,23,21,21,21,23,21,21,21,23,23,25,27,31,29,29,29,31,31,33,35,39,39,41,43,47,49", "code": "\ndef sequence(x):\nx = str(bin(x))\ny = []\nfor z in list(x):\n  if z == '0':\n   y.append(-1)\n  else:\n   y.append(1)\ny.pop(0)\ny.pop(0)\nreturn(y)\n\ndef pattern(upto):\np = []\nseed = 0\nadds = []\nwhile upto != 0:\n  adds.append(sequence(upto))\n  upto -= 1\nwhile len(adds) != 0:\n  x = adds.pop()\n  for y in x:\n   seed += y\n  p.append(seed)\nreturn(p)\n\ndef notin(upto, inn):\nx = pattern(int(upto) ** 2)\ny = []\nwhile upto != 0:\n  if inn == False:\n   if upto not in x:\n    y.append(upto)\n  else:\n   if upto in x:\n    y.append(upto)\n  upto -= 1\ny.reverse()\nreturn(y)\n"}
{"sequence_id": "A268304", "text": "Odd numbers n such that binomial(6*n, 2*n) == -1 (mod 8).", "sequence": "1,5,21,73,85,273,293,297,329,341,529,545,1041,1057,1089,1093,1105,1173,1189,1193,1297,1317,1321,1353,1365,2065,2081,2113,2117,2129,2177,2181,2209,2577,2593,4113,4129,4161,4165,4177,4225,4229,4257,4353,4357,4373,4417,4421,4433", "code": "\nfrom __future__ import division\nA268304_list, b, m1, m2 = [], 15, [21941965946880, -54854914867200, 49244258396160, -19011472727040, 2933960577120, -126898662960, 771887070, 385943535, 385945560],  [10569646080, -25763512320, 22419210240, -8309145600, 1209116160, -46992960, 415800, 311850, 311850]\nfor n in range(10**3):\n    if b % 8 == 7:\n        A268304_list.append(2*n+1)\n    b = b*m1[-1]//m2[-1]\n    for i in range(8):\n        m1[i+1] += m1[i]\n        m2[i+1] += m2[i] \n"}
{"sequence_id": "A268305", "text": "Numbers n such that  n - 37, n - 1, n + 1, n + 37 are consecutive primes.", "sequence": "1524180,3264930,3970530,5438310,5642910,6764940,8176410,10040880,10413900,10894320,11639520,12352980,13556340,15900720,16897590,17283360,18168150,18209100,18686910,19340220,20099940,20359020,20483340,21028290,21846360", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,30000001,6):\n..if isprime(i-1) and isprime(i+1) and prevprime(i-1) == i-37 and nextprime(i+1) == i+37 : print (i,end=', ')\n"}
{"sequence_id": "A268338", "text": "Numbers that cycle under the following transformation: if m is even, divide by 2, if m is congruent to 1 mod 4, multiply by 3 and add 1; if m is congruent to 3 mod 4, multiply by 7 and add 1.", "sequence": "1,2,4,19,23,31,38,41,46", "code": "\na = 1\nb = 1\nprev = []\nkeep = []\ncount = 0\nwhile b < 51:\n....keep.append(a)\n....flag1 = False\n....flag2 = False\n....if a % 2 == 0:\n........a /= 2\n....elif a % 4 == 1:\n........a = a*3+1\n....else:\n........a = a*7+1\n....if count > 50:\n........b += 1\n........a = b\n........count = 0\n........keep = []\n....if keep.count(a) == 2 and a not in prev and a <= 50:\n........prev.append(a)\n........count = 0\n........keep = []\n........b += 1\n........a = b\n....count += 1\nprint(sorted(prev))\n\n"}
{"sequence_id": "A268383", "text": "Least monotonic left inverse of A268412.", "sequence": "0,0,0,0,0,1,1,1,1,2,3,4,4,5,5,5,5,6,7,8,9,9,10,11,11,12,13,14,14,15,15,15,15,16,17,18,19,19,20,21,22,22,22,22,23,23,24,25,25,26,27,28,29,29,30,31,31,32,33,34,34,35,35,35,35,36,37,38,39,39,40,41,42,42,42,42,43,43,44,45,46", "code": "\nA268383_list = [0]\nfor i in range(1,10**6):\n    A268383_list.append(A268383_list[-1]+1-len(list(filter(bool,format(i,'b').split('0')))) % 2) \n"}
{"sequence_id": "A268411", "text": "Parity of number of runs of 1's in binary representation of n.", "sequence": "0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1", "code": "\nfrom sympy import prime, primefactors, log, floor\ndef a092248(n): return 0 if n==1 else 1*(len(primefactors(n))%2==1)\ndef A(n): return n - 2**int(floor(log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a(n): return a092248(b(n)) \n"}
{"sequence_id": "A268411", "text": "Parity of number of runs of 1's in binary representation of n.", "sequence": "0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1", "code": "\ndef a(n): return sum(1 for d in bin(n)[2:].split('0') if len(d))%2 \n"}
{"sequence_id": "A268412", "text": "Balanced evil numbers: numbers with an even number of runs of 1's in their binary expansion.", "sequence": "0,5,9,10,11,13,17,18,19,20,22,23,25,26,27,29,33,34,35,36,38,39,40,44,46,47,49,50,51,52,54,55,57,58,59,61,65,66,67,68,70,71,72,76,78,79,80,85,88,92,94,95,97,98,99,100,102,103,104,108,110,111,113,114", "code": "\nA268412_list = [i for i in range(10**6) if not len(list(filter(bool,format(i,'b').split('0')))) % 2] \n"}
{"sequence_id": "A268415", "text": "Balanced odious numbers: numbers with an odd number of runs of 1's in their binary expansion.", "sequence": "1,2,3,4,6,7,8,12,14,15,16,21,24,28,30,31,32,37,41,42,43,45,48,53,56,60,62,63,64,69,73,74,75,77,81,82,83,84,86,87,89,90,91,93,96,101,105,106,107,109,112,117,120,124,126,127,128,133,137,138,139,141", "code": "\nA268415_list = [i for i in range(10**6) if len(list(filter(bool,format(i,'b').split('0')))) % 2] \n"}
{"sequence_id": "A268476", "text": "Balanced evil primes: primes with an even number of runs of 1's in their binary expansion.", "sequence": "5,11,13,17,19,23,29,47,59,61,67,71,79,97,103,113,131,149,173,181,191,193,199,223,227,239,241,251,257,263,271,277,293,331,337,347,349,373,383,421,449,463,479,487,499,503,509,557,587,593,599,601,613,617,619", "code": "\nfrom sympy import prime\nA268476_list = [p for p in (prime(i) for i in range(1,10**6)) if not len(list(filter(bool,format(p,'b').split('0')))) % 2] \n"}
{"sequence_id": "A268477", "text": "Balanced odious primes: primes with an odd number of runs of 1's in their binary expansion.", "sequence": "2,3,7,31,37,41,43,53,73,83,89,101,107,109,127,137,139,151,157,163,167,179,197,211,229,233,269,281,283,307,311,313,317,353,359,367,379,389,397,401,409,419,431,433,439,443,457,461,467,491,521,523,541,547,563", "code": "\nfrom sympy import prime\nA268477_list = [p for p in (prime(i) for i in range(1,10**6)) if len(list(filter(bool,format(p,'b').split('0')))) % 2] \n"}
{"sequence_id": "A268511", "text": "Odd integers n such that 3^n + 5^n = x^2 + y^2 (x and y integers) is solvable.", "sequence": "1,5,13,17,29,89,109,149,157,193,373", "code": "\nfrom sympy import factorint\nA268511_list = []\nfor n in range(1,50,2):\n    m = factorint(3**n+5**n)\n    for d in m:\n        if d % 4 == 3 and m[d] % 2:\n            break\n    else:\n        A268511_list.append(n) \n"}
{"sequence_id": "A268517", "text": "Three-digit numbers, starting with 321, such that when written in a table with three columns, there are arithmetic progressions modulo 10 down the diagonals, with steps of 1, 2 and 3 respectively.", "sequence": "321,444,675,680,370,268,949,206,851,208,132,444,567,68,37,826,994,620,185,820,213,444,756,806,703,682,499,62,518,82,321,444,675,680,370,268,949,206,851,208,132,444,567,68,37,826,994,620,185,820,213,444,756,806", "code": "\nfrom __future__ import division\nA268517_list = [321]\nfor i in range(10**4):\n    a = A268517_list[-1]\n    A268517_list.append(((a+1+(2-i)%3) % 10)*100 + ((a//100+1+(-i)%3) % 10)*10 + ((a//10+1+(1-i)%3) % 10)) \n"}
{"sequence_id": "A268539", "text": "Numbers k such that 48*k+25 is a perfect square.", "sequence": "0,2,3,7,17,25,28,38,58,72,77,93,123,143,150,172,212,238,247,275,325,357,368,402,462,500,513,553,623,667,682,728,808,858,875,927,1017,1073,1092,1150,1250,1312,1333,1397,1507,1575,1598,1668,1788,1862,1887,1963,2093,2173", "code": " from gmpy2 import is_square\n[k for k in range(2200) if is_square(48*k+25)] \n"}
{"sequence_id": "A268605", "text": "a(1) = 0; a(n+1) is the smallest integer in which the difference between its digits sum and the a(n) digits sum is equal to the n-th prime.", "sequence": "0,2,5,19,89,1999,59999,4999999,599999999,199999999999,399999999999999,799999999999999999,8999999999999999999999,499999999999999999999999999,29999999999999999999999999999999,4999999999999999999999999999999999999", "code": "\nsumprime = 0\nisPrime=lambda x: all(x % i != 0 for i in range(int(x**0.5)+1)[2:])\nfor i in range(2,100):\n..if isPrime(i):\n....alfa = \"\"\n....k = i + sumprime\n....sumprime = k\n....while k > 9:\n......alfa = alfa + \"9\"\n......k = k - 9\n....alfa = str(k)+alfa\n....print alfa\n"}
{"sequence_id": "A268714", "text": "Square array A(i,j) = A006068(i) + A006068(j), read by antidiagonals.", "sequence": "0,1,1,3,2,3,2,4,4,2,7,3,6,3,7,6,8,5,5,8,6,4,7,10,4,10,7,4,5,5,9,9,9,9,5,5,15,6,7,8,14,8,7,6,15,14,16,8,6,13,13,6,8,16,14,12,15,18,7,11,12,11,7,18,15,12,13,13,17,17,12,10,10,12,17,17,13,13,8,14,15,16,22,11,8,11,22,16,15,14,8,9,9,16,14,21,21,9,9,21,21,14,16,9,9", "code": "\n\ndef A006068(n):\n    return n if n<2 else 2*A006068(n//2) + (n%2 + A006068(n//2)%2)%2\ndef T(i,j): return A006068(i) + A006068(j)\nfor i in range(14):\n    print([T(i - j, j) for j in range(i + 1)]) \n"}
{"sequence_id": "A268715", "text": "Square array A(i,j) = A003188(A006068(i) + A006068(j)), read by antidiagonals as A(0,0), A(0,1), A(1,0), A(0,2), A(1,1), A(2,0), ...", "sequence": "0,1,1,2,3,2,3,6,6,3,4,2,5,2,4,5,12,7,7,12,5,6,4,15,6,15,4,6,7,7,13,13,13,13,7,7,8,5,4,12,9,12,4,5,8,9,24,12,5,11,11,5,12,24,9,10,8,27,4,14,10,14,4,27,8,10,11,11,25,25,10,15,15,10,25,25,11,11,12,9,8,24,29,14,12,14,29,24,8,9,12,13,13,24,9,31,31,13,13,31,31,9,24,13,13", "code": "\ndef a003188(n): return n^(n>>1)\ndef a006068(n):\n    s=1\n    while True:\n        ns=n>>s\n        if ns==0: break\n        n=n^ns\n        s<<=1\n    return n\ndef T(n, k): return a003188(a006068(n) + a006068(k))\nfor n in range(21): print([T(n - k, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A268717", "text": "Permutation of natural numbers: a(0) = 0, a(n) = A003188(1+A006068(n-1)), where A003188 is binary Gray code and A006068 is its inverse.", "sequence": "0,1,3,6,2,12,4,7,5,24,8,11,9,13,15,10,14,48,16,19,17,21,23,18,22,25,27,30,26,20,28,31,29,96,32,35,33,37,39,34,38,41,43,46,42,36,44,47,45,49,51,54,50,60,52,55,53,40,56,59,57,61,63,58,62,192,64,67,65,69,71,66,70,73,75,78,74,68,76,79,77,81", "code": "\ndef A003188(n): return n^(n//2)\ndef A006068(n):\n    if n<2: return n\n    m = A006068(n//2)\n    return 2*m + (n%2 + m%2)%2\ndef a(n): return 0 if n<1 else A003188(1 + A006068(n - 1))\nprint([a(n) for n in range(0, 101)]) \n"}
{"sequence_id": "A268718", "text": "Permutation of natural numbers: a(0) = 0, a(n) = 1 + A003188(A006068(n)-1), where A003188 is binary Gray code and A006068 is its inverse.", "sequence": "0,1,4,2,6,8,3,7,10,12,15,11,5,13,16,14,18,20,23,19,29,21,24,22,9,25,28,26,30,32,27,31,34,36,39,35,45,37,40,38,57,41,44,42,46,48,43,47,17,49,52,50,54,56,51,55,58,60,63,59,53,61,64,62,66,68,71,67,77,69,72,70,89,73,76,74,78,80,75,79,113,81", "code": "\ndef a003188(n): return n^(n>>1)\ndef a006068(n):\n    s=1\n    while True:\n        ns=n>>s\n        if ns==0: break\n        n=n^ns\n        s<<=1\n    return n\ndef a(n): return 0 if n==0 else 1 + a003188(a006068(n) - 1) \n"}
{"sequence_id": "A268719", "text": "Triangular table T(n>=0,k=0..n) = A003188(A006068(n) + A006068(k)), read by rows as A(0,0), A(1,0), A(1,1), A(2,0), A(2,1), A(2,2), ...", "sequence": "0,1,3,2,6,5,3,2,7,6,4,12,15,13,9,5,4,13,12,11,10,6,7,4,5,14,15,12,7,5,12,4,10,14,13,15,8,24,27,25,29,31,26,30,17,9,8,25,24,31,30,27,26,19,18,10,11,8,9,26,27,24,25,22,23,20,11,9,24,8,30,26,25,27,18,22,21,23,12,13,14,15,8,9,10,11,28,29,30,31,24", "code": "\ndef a003188(n): return n^(n>>1)\ndef a006068(n):\n    s=1\n    while True:\n        ns=n>>s\n        if ns==0: break\n        n=n^ns\n        s<<=1\n    return n\ndef T(n, k): a003188(a006068(n) + a006068(k))\nfor n in range(21): print [T(n, k) for k in range(n + 1)] \n"}
{"sequence_id": "A268726", "text": "Index of the toggled bit between n and A268717(n+1): a(n) = A000523(A003987(n, A268717(1+n))).", "sequence": "0,1,2,0,3,0,0,1,4,0,0,1,0,1,2,0,5,0,0,1,0,1,2,0,0,1,2,0,3,0,0,1,6,0,0,1,0,1,2,0,0,1,2,0,3,0,0,1,0,1,2,0,3,0,0,1,4,0,0,1,0,1,2,0,7,0,0,1,0,1,2,0,0,1,2,0,3,0,0,1,0,1,2,0,3,0,0,1,4,0,0,1,0,1,2,0,0,1,2,0,3,0,0,1,4,0,0,1,0,1,2,0,5,0,0,1,0,1,2,0,0", "code": "\ndef A003188(n): return n^(n//2)\ndef A006068(n):\n    if n<2: return n\n    else:\n        m=A006068(n//2)\n        return 2*m + (n%2 + m%2)%2\ndef A268717(n): return 0 if n<1 else A003188(1 + A006068(n - 1))\nprint([int(math.floor(math.log(n^A268717(n + 1), 2))) for n in range(201)]) \n"}
{"sequence_id": "A268754", "text": "The period of an n X 1 rectangular oscillator in the B1/S Life-like cellular automaton.", "sequence": "1,2,1,6,4,14,1,14,12,62,8,126,28,30,1,30,28,1022,24,126,124,4094,16,2046,252,1022,56,32766,60,62,1,62,60,8190,56,174762,2044,8190,48,2046,252,254,248,8190,8188,16777214,32,4194302,4092,510,504,134217726,2044,2097150", "code": "\ndef electron_period(n):\n  wire_mask = (1 << n) - 1\n  power = lam = 1\n  tortoise, hare = 1, 2\n  while tortoise != hare:\n    if power == lam:\n      tortoise = hare\n      power *= 2\n      lam = 0\n    hare = ((hare << 1) ^ (hare >> 1)) & wire_mask\n    lam += 1\n  return lam\n"}
{"sequence_id": "A268811", "text": "Sequence of positive integers where each is chosen to be as small as possible subject to the condition that no three terms a(j), a(j+k), a(j+2k) (for any j and k) form a geometric progression.", "sequence": "1,1,2,1,1,2,2,3,3,1,1,2,1,1,2,2,3,3,2,3,3,5,5,6,5,5,6,1,1,2,1,1,2,2,3,3,1,1,2,1,1,2,2,3,3,2,3,3,5,5,6,5,5,6,2,3,3,5,5,6,5,5,6,6,7,7,6,7,7,8,8,10,6,7,7,6,7,7,8,8,10,1,1,2,1,1,2,2,3,3,1,1,2,1,1,2,2,3,3,2,3,3,5,5,6,5,5,6,1,1,2,1,1,2,2,3,3,1,1,2,1,1,2,2,3,3,2", "code": "\nA268811_list = []\nfor n in range(1000):\n....i, j, b = 1, 1, set()\n....while n-2*i >= 0:\n........b.add(A268811_list[n-i]**2/A268811_list[n-2*i])\n........i += 1\n........while j in b:\n............b.remove(j)\n............j += 1\n....A268811_list.append(j)\n"}
{"sequence_id": "A268818", "text": "Permutation of nonnegative integers: a(n) = A268718(A268718(n)).", "sequence": "0,1,6,4,3,10,2,7,15,5,14,11,8,13,18,16,23,29,22,19,32,21,9,24,12,25,30,28,27,34,26,31,39,45,38,35,48,37,57,40,60,41,46,44,43,17,42,47,20,49,54,52,51,58,50,55,63,53,62,59,56,61,66,64,71,77,70,67,80,69,89,72,92,73,78,76,75,113,74,79,116,81", "code": "\ndef a003188(n): return n^(n>>1)\ndef a006068(n):\n    s=1\n    while True:\n        ns=n>>s\n        if ns==0: break\n        n=n^ns\n        s<<=1\n    return n\ndef a278618(n): return 0 if n==0 else 1 + a003188(a006068(n) - 1)\ndef a(n): return a278618(a278618(n)) \n"}
{"sequence_id": "A268820", "text": "Square array A(r,c): A(0,c) = c, A(r,0) = 0, A(r>=1,c>=1) = A003188(1+A006068(A(r-1,c-1))) = A268717(1+A(r-1,c-1)), read by descending antidiagonals as A(0,0), A(0,1), A(1,0), A(0,2), A(1,1), A(2,0), ...", "sequence": "0,1,0,2,1,0,3,3,1,0,4,6,3,1,0,5,2,2,3,1,0,6,12,7,2,3,1,0,7,4,6,6,2,3,1,0,8,7,13,5,6,2,3,1,0,9,5,12,7,7,6,2,3,1,0,10,24,5,15,4,7,6,2,3,1,0,11,8,4,13,5,5,7,6,2,3,1,0,12,11,25,4,14,12,5,7,6,2,3,1,0,13,9,24,12,15,4,4,5,7,6,2,3,1,0,14,13,9,27,12,10,13,4,5,7,6,2,3,1,0", "code": "\ndef A003188(n): return n^(n//2)\ndef A006068(n):\n    if n<2: return n\n    else:\n        m=A006068(n//2)\n        return 2*m + (n%2 + m%2)%2\ndef a(r, c): return c if r<1 else 0 if c<1 else A003188(1 + A006068(a(r - 1, c - 1)))\nfor r in range(16):\n    print([a(c, r - c) for c in range(r + 1)]) \n"}
{"sequence_id": "A268821", "text": "Permutation of nonnegative integers: a(0) = 0, a(n) = A268717(1 + A268717(n-1)).", "sequence": "0,1,3,2,7,6,13,12,5,4,25,24,9,8,15,14,11,10,49,48,17,16,23,22,19,18,27,26,31,30,21,20,29,28,97,96,33,32,39,38,35,34,43,42,47,46,37,36,45,44,51,50,55,54,61,60,53,52,41,40,57,56,63,62,59,58,193,192,65,64,71,70,67,66,75,74,79,78,69,68,77,76,83,82", "code": "\ndef A003188(n): return n^(n//2)\ndef A006068(n):\n    if n<2: return n\n    else:\n        m=A006068(n//2)\n        return 2*m + (n%2 + m%2)%2\ndef A268717(n): return 0 if n<1 else A003188(1 + A006068(n - 1))\ndef a(n): return A268717(1 + A268717(n-1)) if n>0 else 0\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A268823", "text": "Permutation of nonnegative integers: a(0) = 0, a(n) = A268717(1 + A268821(n-1)).", "sequence": "0,1,3,2,6,5,7,15,13,4,12,27,25,8,24,14,10,9,11,51,49,16,48,22,18,17,19,26,30,29,31,23,21,28,20,99,97,32,96,38,34,33,35,42,46,45,47,39,37,44,36,50,54,53,55,63,61,52,60,43,41,56,40,62,58,57,59,195,193,64,192,70,66,65,67,74,78,77,79,71,69,76,68,82,86,85", "code": "\ndef A003188(n): return n^(n//2)\ndef A006068(n):\n    if n<2: return n\n    else:\n        m=A006068(n//2)\n        return 2*m + (n%2 + m%2)%2\ndef A268717(n): return 0 if n<1 else A003188(1 + A006068(n - 1))\ndef a(n): return A268717(1 + A268717(1 + A268717(n - 2))) if n>1 else n\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A268825", "text": "Permutation of nonnegative integers: a(0) = 0, a(n) = A268717(1+A268823(n-1)).", "sequence": "0,1,3,2,6,7,4,5,14,15,12,13,26,27,24,25,10,11,8,9,50,51,48,49,18,19,16,17,30,31,28,29,22,23,20,21,98,99,96,97,34,35,32,33,46,47,44,45,38,39,36,37,54,55,52,53,62,63,60,61,42,43,40,41,58,59,56,57,194,195,192,193,66,67,64,65,78,79,76,77,70,71,68,69,86,87", "code": "\ndef A003188(n): return n^(n//2)\ndef A006068(n):\n    if n<2: return n\n    else:\n        m=A006068(n//2)\n        return 2*m + (n%2 + m%2)%2\ndef A268717(n): return 0 if n<1 else A003188(1 + A006068(n - 1))\ndef A268823(n): return A268717(1 + A268717(1 + A268717(n - 2))) if n>1 else n\ndef a(n): return A268717(1 + A268823(n - 1)) if n>0 else 0\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A268827", "text": "Permutation of nonnegative integers: a(0) = 0, a(n) = A268717(1+A268825(n-1)).", "sequence": "0,1,3,2,6,7,5,12,4,10,14,13,15,30,26,25,27,11,9,24,8,54,50,49,51,19,17,48,16,31,29,20,28,18,22,21,23,102,98,97,99,35,33,96,32,47,45,36,44,34,38,37,39,55,53,60,52,58,62,61,63,46,42,41,43,59,57,40,56,198,194,193,195,67,65,192,64,79,77,68,76,66,70,69,71,87", "code": "\ndef A003188(n): return n^(n//2)\ndef A006068(n):\n    if n<2: return n\n    else:\n        m=A006068(n//2)\n        return 2*m + (n%2 + m%2)%2\ndef A268717(n): return 0 if n<1 else A003188(1 + A006068(n - 1))\ndef A268823(n): return A268717(1 + A268717(1 + A268717(n - 2))) if n>1 else n\ndef A268825(n): return A268717(1 + A268823(n - 1)) if n>0 else 0\ndef a(n): return A268717(1 + A268825(n - 1)) if n>0 else 0\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A268830", "text": "Square array A(r,c): A(0,c) = c, A(r,0) = 0, A(r>=1,c>=1) = 1+A(r-1,A268718(c)-1) = 1 + A(r-1, A003188(A006068(c)-1)), read by descending antidiagonals.", "sequence": "0,1,0,2,1,0,3,4,1,0,4,2,3,1,0,5,6,2,3,1,0,6,8,9,2,3,1,0,7,3,8,9,2,3,1,0,8,7,5,5,6,2,3,1,0,9,10,4,4,7,8,2,3,1,0,10,12,13,6,4,6,7,2,3,1,0,11,15,12,13,5,4,6,7,2,3,1,0,12,11,17,17,18,5,4,6,7,2,3,1,0,13,5,16,16,19,20,5,4,6,7,2,3,1,0,14,13,7,18,16,18,19,5,4,6,7,2,3,1,0", "code": "\ndef a003188(n): return n^(n>>1)\ndef a006068(n):\n    s=1\n    while True:\n        ns=n>>s\n        if ns==0: break\n        n=n^ns\n        s<<=1\n    return n\ndef a278618(n): return 0 if n==0 else 1 + a003188(a006068(n) - 1)\ndef A(r, c): return c if r==0 else 0 if c==0 else 1 + A(r - 1, a278618(c) - 1)\nfor r in range(21): print([A(c, r - c) for c in range(r + 1)]) \n"}
{"sequence_id": "A268831", "text": "Permutation of nonnegative integers: a(0) = 0, a(n) = A268717(1+A268827(n-1)).", "sequence": "0,1,3,2,6,7,5,4,13,12,11,10,15,14,31,30,27,26,9,8,25,24,55,54,51,50,17,16,49,48,29,28,21,20,19,18,23,22,103,102,99,98,33,32,97,96,45,44,37,36,35,34,39,38,53,52,61,60,59,58,63,62,47,46,43,42,57,56,41,40,199,198,195,194,65,64,193,192,77", "code": "\ndef A003188(n): return n^(n//2)\ndef A006068(n):\n    if n<2: return n\n    else:\n        m=A006068(n//2)\n        return 2*m + (n%2 + m%2)%2\ndef A268717(n): return 0 if n<1 else A003188(1 + A006068(n - 1))\ndef A268823(n): return A268717(1 + A268717(1 + A268717(n - 2))) if n>1 else n\ndef A268825(n): return A268717(1 + A268823(n - 1)) if n>0 else 0\ndef A268827(n): return A268717(1 + A268825(n - 1)) if n>0 else 0\ndef a(n): return A268717(1 + A268827(n - 1)) if n>0 else 0\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A268833", "text": "Square array A(row,col) = A101080(col,A268820(row,row+col)), read by descending antidiagonals.", "sequence": "0,0,1,0,1,2,0,1,2,1,0,1,2,3,2,0,1,2,3,2,3,0,1,2,1,2,1,2,0,1,2,3,2,3,2,1,0,1,2,1,2,3,4,3,2,0,1,2,1,2,3,4,3,2,3,0,1,2,3,2,3,4,3,2,3,4,0,1,2,3,2,3,4,3,2,1,4,3,0,1,2,1,2,1,2,3,2,3,2,3,2,0,1,2,1,2,3,2,1,2,3,2,3,2,3,0,1,2,3,2,3,4,3,2,3,4,1,2,1,2", "code": "\ndef A101080(n, k): return bin(n^k)[2:].count(\"1\")\ndef A003188(n): return n^(n//2)\ndef A006068(n):\n    if n<2: return n\n    else:\n        m=A006068(n//2)\n        return 2*m + (n%2 + m%2)%2\ndef A268820(r, c): return c if r<1 else 0 if c<1 else A003188(1 + A006068(A268820(r - 1, c - 1)))\ndef a(r, c): return A101080(c, A268820(r, r + c))\nfor r in range(21):\n    print([a(c, r - c) for c in range(r + 1)]) \n"}
{"sequence_id": "A268834", "text": "Transpose of array A268833.", "sequence": "0,1,0,2,1,0,1,2,1,0,2,3,2,1,0,3,2,3,2,1,0,2,1,2,1,2,1,0,1,2,3,2,3,2,1,0,2,3,4,3,2,1,2,1,0,3,2,3,4,3,2,1,2,1,0,4,3,2,3,4,3,2,3,2,1,0,3,4,1,2,3,4,3,2,3,2,1,0,2,3,2,3,2,3,2,1,2,1,2,1,0,3,2,3,2,3,2,1,2,3,2,1,2,1,0,2,1,2,1,4,3,2,3,4,3,2,3,2,1,0", "code": "\ndef A101080(n, k): return bin(n^k)[2:].count(\"1\")\ndef A003188(n): return n^(n/2)\ndef A006068(n):\n....if n<2: return n\n....else:\n........m=A006068(n/2)\n........return 2*m + (n%2 + m%2)%2\ndef A268820(r, c): return c if r<1 else 0 if c<1 else A003188(1 + A006068(A268820(r - 1, c - 1)))\ndef a(r, c): return A101080(c, A268820(r, r + c))\nfor r in range(0, 21):\n....print [a(r - c, c) for c in range(0, r + 1)] \n"}
{"sequence_id": "A268835", "text": "Main diagonal of arrays A268833 & A268834: a(n) = A101080(n, A268820(n, 2*n)).", "sequence": "0,1,2,1,2,3,2,3,2,3,4,5,2,1,4,3,2,3,4,5,4,3,6,5,2,3,2,1,4,5,4,3,2,3,4,5,4,3,6,5,4,5,4,3,6,7,6,5,2,3,4,3,2,3,2,3,4,5,6,5,4,3,4,3,2,3,4,5,4,3,6,5,4,5,4,3,6,7,6,5,4,5,6,5,4,5,4,5,6,7,8,7,6,5,6,5,2,3,4,3,4,5,4,5,2,3,4,5,2,1,4,3,4,5,6,5,6,5,6,5,4", "code": "\ndef A101080(n, k): return bin(n^k)[2:].count(\"1\")\ndef A003188(n): return n^(n//2)\ndef A006068(n):\n    if n<2: return n\n    else:\n        m=A006068(n//2)\n        return 2*m + (n%2 + m%2)%2\ndef A268717(n): return 0 if n<1 else A003188(1 + A006068(n - 1))\ndef A268820(r, c): return c if r<1 else 0 if c<1 else A003188(1 + A006068(A268820(r - 1, c - 1)))\nprint([A101080(n, A268820(n, 2*n)) for n in range(301)]) \n"}
{"sequence_id": "A268858", "text": "Prime numbers ending in 39.", "sequence": "139,239,439,739,839,1039,1439,2039,2239,2339,2539,2939,3539,3739,4139,4339,4639,5039,5639,5839,5939,7039,7639,8039,8539,8839,9239,9439,9539,9739,9839,10039,10139,10639,10739,10939,11239,11839,11939,12239,12539,12739", "code": "\nfrom sympy import isprime\nfor n in range(139,15000,100):\n    if(isprime(n)):print(n)\n\n"}
{"sequence_id": "A268859", "text": "Prime numbers ending in 21.", "sequence": "421,521,821,1021,1321,1621,1721,2221,2521,2621,3121,3221,3821,4021,4421,4621,4721,5021,5521,5821,6121,6221,6421,6521,7121,7321,7621,8221,8521,8821,9221,9421,9521,9721,10321,11321,11621,11821,12421,12721,12821,13121", "code": "\nfrom sympy import isprime\nfor n in range(421,15000,100):\n    if(isprime(n)):print(n)\n\n"}
{"sequence_id": "A268860", "text": "Prime numbers ending in 27.", "sequence": "127,227,727,827,1327,1427,1627,2027,2927,3527,3727,4027,4127,4327,5227,5527,5827,5927,6427,6827,7027,7127,7727,7927,8527,8627,9127,9227,10427,10627,11027,11527,11827,11927,12227,12527,13127,13327,13627,14327,14627", "code": "\nfrom sympy import isprime\nfor n in range(127,10000,100):\n    if(isprime(n)):print(n)\n\n"}
{"sequence_id": "A268878", "text": "Breadth-first traversal of a binary tree in which the value at the n-th node is equal to ParentNode()*prime(n-1).", "sequence": "1,2,3,10,14,33,39,170,190,322,406,1023,1221,1599,1677,7990,9010,11210,11590,21574,22862,29638,32074,84909,91047,118437,123321,164697,171093,182793,189501,1014730,1046690,1234370,1252390,1670290,1692710,1819630,1889170", "code": "\ndef a(n):\n  \n  \n  if n == 0:\n  return 1\n  else:\n    return prime(n-1)*a(math.floor((n-1)/2))\n"}
{"sequence_id": "A268924", "text": "One of the two successive approximations up to 3^n for the 3-adic integer sqrt(-2). These are the numbers congruent to 1 mod 3 (except for n = 0).", "sequence": "0,1,4,22,22,22,508,508,2695,2695,2695,2695,356989,888430,4077076,4077076,18425983,18425983,147566146,534986635,534986635,7508555437,28429261843,28429261843,122572440670,405001977151", "code": "\ndef a268924(n):\n    ary=[0]\n    a, mod = 1, 3\n    for i in range(n):\n          b=a%mod\n          ary.append(b)\n          a=b**2 + b + 2\n          mod*=3\n    return ary\nprint(a268924(100)) \n"}
{"sequence_id": "A268982", "text": "a(n) is the denominator of Sum_{d|n} sigma(n/d)^d/d, where sigma is A000203.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,13,2,15,16,17,9,19,20,7,22,23,24,25,26,27,28,29,6,31,32,33,34,35,18,37,38,1,40,41,6,43,44,9,46,47,16,49,25,51,52,53,27,55,56,19,58,59,60,61,62,21,64,65,66,67,68,69", "code": "\nfrom __future__ import division\nfrom sympy import divisors, divisor_sigma, gcd\ndef A268982(n):\n    return n//gcd(n,sum(d*divisor_sigma(d)**(n//d)  for d in divisors(n, generator=True))) \n"}
{"sequence_id": "A268983", "text": "Numbers n such that Sum_{d|n} sigma(n/d)^d/d is an integer, where sigma is A000203.", "sequence": "1,39,793,25930965,76147347", "code": "\nfrom __future__ import division\nfrom sympy import divisors, divisor_sigma\nA268983_list = [n for n in range(1,10000) if not sum(d*pow(int(divisor_sigma(d)),n//d,n) % n for d in divisors(n, generator=True)) % n] \n"}
{"sequence_id": "A269100", "text": "a(n) = 13*n + 11.", "sequence": "11,24,37,50,63,76,89,102,115,128,141,154,167,180,193,206,219,232,245,258,271,284,297,310,323,336,349,362,375,388,401,414,427,440,453,466,479,492,505,518,531,544,557,570,583,596,609,622,635,648,661,674,687,700,713,726,739", "code": " [13*n+11 for n in range(60)]\n"}
{"sequence_id": "A269131", "text": "Composite numbers whose largest prime factor is less than its second-largest prime factor's square, counting with multiplicity so that the factors of 18 are 2, 3, 3.", "sequence": "4,6,8,9,12,15,16,18,21,24,25,27,30,32,35,36,42,45,48,49,50,54,55,60,63,64,65,70,72,75,77,81,84,85,90,91,95,96,98,100,105,108,110,115,119,120,121,125,126,128,130,133,135,140,143,144,147,150,154,161,162,165", "code": "\nseq = []\nfor n in range(2, 1000):\n    temp = n\n    factor = 2\n    while temp > 1:\n        if temp % factor == 0:\n            temp //= factor\n            if temp == 1:\n                continue\n            if temp < factor * factor:\n                seq.append(n)\n        else:\n            factor += 1\nprint(seq)\n"}
{"sequence_id": "A269173", "text": "Formula for Wolfram's Rule 126 cellular automaton: a(n) = (n XOR 2n) OR (n XOR 4n).", "sequence": "0,7,14,15,28,31,30,27,56,63,62,63,60,63,54,51,112,119,126,127,124,127,126,123,120,127,126,127,108,111,102,99,224,231,238,239,252,255,254,251,248,255,254,255,252,255,246,243,240,247,254,255,252,255,254,251,216,223,222,223,204,207,198,195,448,455,462", "code": " print([(n^(2*n))|(n^(4*n)) for n in range(101)]) \n"}
{"sequence_id": "A269174", "text": "Formula for Wolfram's Rule 124 cellular automaton: a(n) = (n OR 2n) AND ((n XOR 2n) OR (n XOR 4n)).", "sequence": "0,3,6,7,12,15,14,11,24,27,30,31,28,31,22,19,48,51,54,55,60,63,62,59,56,59,62,63,44,47,38,35,96,99,102,103,108,111,110,107,120,123,126,127,124,127,118,115,112,115,118,119,124,127,126,123,88,91,94,95,76,79,70,67,192,195,198,199,204,207,206,203,216", "code": " def a(n): return (n|2*n)&((n^(2*n))|(n^(4*n))) \n"}
{"sequence_id": "A269225", "text": "Smallest k such that k! > 2^n.", "sequence": "2,3,3,4,4,5,5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,11,11,11,11,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,23,24,24,24,24,24,25,25,25,25,26,26,26,26,26,27,27,27,27", "code": "\ndef a269225():\n...k = 1\n...f = 1\n...p = 1\n...n = 0\n...while True:\n......while f<=p:\n.........k += 1\n.........f *= k\n......yield k\n......p *= 2\n......n += 1\n"}
{"sequence_id": "A269266", "text": "a(n) = 2^n mod 31.", "sequence": "1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1,2,4,8,16,1", "code": " for n in range(0,100):print(2**n%31) \n"}
{"sequence_id": "A269306", "text": "a(n+1) is the smallest integer such that the difference between its digital sum and the digital sum of a(n) is n.", "sequence": "0,1,3,6,19,69,399,1999,9999,99999,1999999,39999999,699999999,19999999999,699999999999,39999999999999,1999999999999999,99999999999999999,9999999999999999999,1999999999999999999999", "code": "\ns = 0\nfor i in range(1,100):\n..alfa = \"\"\n..k = i + s\n..s = k\n..while k > 9:\n....alfa = alfa + \"9\"\n....k = k - 9\n..alfa = str(k)+alfa\n..print alfa\n"}
{"sequence_id": "A269455", "text": "Number of Type I (singly-even) self-dual binary codes of length 2n.", "sequence": "1,3,15,105,2295,75735,4922775,625192425,163204759575,83724041661975,85817142703524375,175667691114114395625,720413716161839357604375,5902349576513949856852644375,96709997811181068404530578084375,3168896498278970068411253452090715625,207692645973961964120828372930661061284375,27222898185745116523209337325140537285726884375,7136346644902153570976711733098966146766874104484375,3741493773415815389266667264411257664189964123617799515625", "code": "\nfor n in range(1,10):\n    product1 = 1\n    for i in range(1,n-1 + 1):\n        product1 *= (2**i+1)\n    if (2*n)%8 == 0:\n        product2 = 1\n        for i in range(n-2 + 1):\n            product2 *= (2**i+1)\n        print(product1 - product2)\n    else:\n        print(product1)\n"}
{"sequence_id": "A269483", "text": "a(n) = n^12 - n^11 + n^9 - n^8 + n^6 - n^4 + n^3 - n + 1.", "sequence": "1,1,2359,368089,12783421,196890121,1822428931,11898664849,60247241209,251393376241,900900990991,2855262053161,8177824843189,21515718297529,52663539957211,121132473843361,263947231891441,548461977100129", "code": "\nA269483_list, m = [], [479001600, -2674425600, 6386688000, -8501915520, 6889478400, -3482100720, 1080164160, -194177280, 17948256, -666714, 5418, 0, 1]\nfor _ in range(10**2):\n    A269483_list.append(m[-1])\n    for i in range(12):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A269631", "text": "a(1) = 0; a(n+1) is the smallest integer not yet used that contains the number of decimal digits of a(n) as a substring.", "sequence": "0,1,10,2,11,12,20,21,22,23,24,25,26,27,28,29,32,42,52,62,72,82,92,102,3,13,112,30,120,31,121,33,122,34,123,35,124,36,125,37,126,38,127,39,128,43,129,53,132,63,142,73,152,83,162,93,172,103,113,130,131,133,134,135", "code": "\n\n\n\nprint(\"0\", end=',')\nlista = [-1,0,0,0,0,0,0,0,0,0]\na = 1\nfor g in range (1,100):\n    b = len(str(a))\n    val = lista[b] + 1\n    flag = 0\n    while flag == 0:\n        sval = str(val)\n        while str(b) not in sval:\n            val += 1\n            sval = str(val)\n        k = len(sval)\n        comp = k\n        for s in range(k):\n            if lista[int(sval[s])] < val:\n                comp -= 1\n        if comp == 0:\n            flag = 1\n        else:\n            val +=1\n    print(val, end=',')\n    lista[b] = val\n    a = val\n\n"}
{"sequence_id": "A269723", "text": "Start with A_0 = 0, then extend by setting B_k = complement of A_k and A_{k+1} = A_k A_k B_k B_k; sequence is limit of A_k as k -> infinity.", "sequence": "0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1", "code": "\nA269723_list = [0]\nfor _ in range(7):\n    A269723_list += A269723_list + [1-d for d in A269723_list]*2 \n"}
{"sequence_id": "A269723", "text": "Start with A_0 = 0, then extend by setting B_k = complement of A_k and A_{k+1} = A_k A_k B_k B_k; sequence is limit of A_k as k -> infinity.", "sequence": "0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1", "code": "\nA269723_list = [bin(_&0xaaaaa).count('1')%2 for _ in range(16384)] \n"}
{"sequence_id": "A269784", "text": "Primes p such that 2*p + 11 is a square.", "sequence": "7,19,79,107,139,307,359,607,919,1399,1619,1979,2239,2659,3607,3779,4507,5507,6379,6607,7559,8059,8839,10799,11699,12007,15307,17107,20599,21419,22679,23539,24859,25307,25759,32507,35107,40039,41179,46507,47119", "code": "\nfrom sympy import isprime\nA269784_list, j = [], -5\nfor i in range(10**5):\n    A269784_list.extend([j] if isprime(j) else [])\n    j += 4*(i+1) \n"}
{"sequence_id": "A269784", "text": "Primes p such that 2*p + 11 is a square.", "sequence": "7,19,79,107,139,307,359,607,919,1399,1619,1979,2239,2659,3607,3779,4507,5507,6379,6607,7559,8059,8839,10799,11699,12007,15307,17107,20599,21419,22679,23539,24859,25307,25759,32507,35107,40039,41179,46507,47119", "code": "\nfrom gmpy2 import is_prime,is_square\nfor p in range(3,10**6,2):\n    if(not is_square(2*p+11)):continue\n    elif(is_prime(p)):print(p)\n\n"}
{"sequence_id": "A269785", "text": "Primes p such that 2*p + 23 is a square.", "sequence": "13,29,73,101,353,409,601,673,829,1093,1289,1613,1973,2801,2953,3109,3433,4129,4889,5501,6373,6833,7069,7309,8053,9649,9929,10501,13933,16369,18229,19001,20593,21001,25301,26209,26669,28549,30493,31489,33013,33529,36709", "code": "\nfrom gmpy2 import is_prime,is_square\nfor p in range(3,10**6,2):\n    if(not is_square(2*p+23)):continue\n    elif(is_prime(p)):print(p)\n\n"}
{"sequence_id": "A269786", "text": "Primes p such that 2*p + 31 is a square.", "sequence": "97,349,997,1609,2797,3769,6829,7549,10789,11689,13597,15649,16729,22669,28069,32497,40597,44089,49597,59497,63709,70297,74869,86929,89449,94597,113749,122497,128509,144169,147409,153997,164149,181789,196549,200329,207997", "code": "\nfrom gmpy2 import is_prime,is_square\nfor p in range(3,10**6,2):\n    if(not is_square(2*p+31)):continue\n    elif(is_prime(p)):print(p)\n\n"}
{"sequence_id": "A269787", "text": "Primes p such that 2*p + 43 is a square.", "sequence": "3,19,199,523,739,991,1279,2791,3259,6823,9091,12619,13591,15643,17839,32491,34039,37243,40591,63703,68059,72559,79579,86923,89443,105319,110899,137791,144163,153991,160723,171091,178183,192799,196543,200323,211879,219763", "code": "\nfrom gmpy2 import is_prime,is_square\nfor p in range(3,10**6,2):\n    if(not is_square(2*p+43)):continue\n    elif(is_prime(p)):print(p)\n\n"}
{"sequence_id": "A269790", "text": "Primes p such that 2*p + 79 is a square.", "sequence": "73,181,2341,4861,6121,9901,12601,18973,20161,26641,47701,51481,59473,61561,68041,79561,81973,84421,94573,110881,157321,185401,192781,207973,231841,244261,248473,270073,292573,335341,365473,440821,446473,452161,475273", "code": "\nfrom sympy import isprime\nfrom gmpy2 import is_square\nfor p in range(0,1000000):\n    if(is_square(2*p+79) and isprime(p)):print(p)\n\n"}
{"sequence_id": "A269903", "text": "Integers n such that A002110(n) / 2 is the sum of 4 but no fewer nonzero squares.", "sequence": "3,6,7,10,14,17,20,21,26,29,30,37,40,43,44,47,50,51,58,63,67,68,72,75,82,85,90,94,97,98,102,105,106,117,120,123,125,127,129,132,139,140,143,146,150,154,164,165,167,170,173,174,178,186,190,191,193,201,205,208,209,213,220", "code": "\nfrom sympy import prime\nA269903_list, p = [], 1\nfor i in range(2,10**6):\n    p = (p*prime(i)) % 8\n    if p == 7:\n        A269903_list.append(i) \n"}
{"sequence_id": "A269927", "text": "Start with A_0 = 0, then extend by setting B_k = complement of A_k and A_{k+1} = A_k C_1 C_2 ... C_m, where m is the length of A_k and C_i = A_k if the i-th element of A_k is 1 and C_i = B_k otherwise; sequence is limit of A_k as k -> infinity.", "sequence": "0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,1,1,0,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,1,0,0,1,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1", "code": "\nA269927_list = [0]\nfor _ in range(5):\n    ylist = [1-d for d in A269927_list]\n    zlist = list(A269927_list)\n    for i in A269927_list:\n        if i:\n            zlist += A269927_list\n        else:\n            zlist += ylist\n    A269927_list = zlist\n"}
{"sequence_id": "A270048", "text": "a(1) = 0; a(n+1) = a(n) + n * the number of digits of a(n).", "sequence": "0,1,3,6,10,20,32,46,62,80,100,133,169,208,250,295,343,394,448,505,565,628,694,763,835,910,988,1069,1181,1297,1417,1541,1669,1801,1937,2077,2221,2369,2521,2677,2837,3001,3169,3341,3517,3697,3881,4069,4261,4457,4657,4861,5069,5281,5497,5717,5941", "code": "\nb = 0\nprint(b, end=',')\nfor g in range(1, 100):\n   b += g*len(str(b))\n   print(b, end=',')\n"}
{"sequence_id": "A270102", "text": "Numbers n such that 3^n - n*2^n is prime.", "sequence": "3,4,5,7,8,10,11,23,34,62,95,128,173,251,260,464,628,1267,1895,2057,2743,5102,7790,49163", "code": "\nfrom gmpy2 import is_prime\nfor n in range(5000):\n   if(is_prime(3**n-n*2**n)):print(n,end=\", \")\n\n"}
{"sequence_id": "A270225", "text": "Lesser of twin primes where both primes are the sum of three squares.", "sequence": "3,11,17,41,59,107,137,179,227,281,347,419,521,569,617,641,659,809,827,857,881,1019,1049,1091,1289,1427,1451,1481,1619,1667,1697,1721,1787,1931,2027,2081,2129,2267,2339,2657,2729,2801,2969,3251,3257,3299,3329,3371,3467,3539", "code": "\nfrom sympy import prime, isprime\nA270225_list = [p for p in (prime(i) for i in range(2,10**3)) if p % 8 not in {5,7} and isprime(p+2)] \n"}
{"sequence_id": "A270270", "text": "The number of n-digit numbers in A270048.", "sequence": "4,6,17,45,131,381,1123,3334,9973,29991,90601,274746,835844,2549874,7797469,23894630,73358721,225589420,694745922,2142444490,6614766985,20445300258,63256499281,195890524486,607136782567,1883199766658,5845450449249,18156369461770,56429925440218", "code": "\n\nseq = [4]   \nsomme = [4] \nlast = [10] \n\nfor n in range (1,30):\n  k = (len(somme)+1)     \n  limit = 10**k          \n  base = (somme[-1]+1)*k \n  hypo = seq[-1]*3       \n  rid = 10**(len(str(hypo))-1) \n  \n  s, p, m = 0, 0, 0\n  while s < 1:\n    diff_1 = (base + (base + (k*(hypo-1))))*float(hypo)/2\n    tot = last[-1] + diff_1\n    if tot < limit:\n      p = 1\n      if m == 1 and rid > 1:\n        m = 0; rid = rid/10\n      hypo = hypo + rid\n    else:\n      diff_2 = (base + (base + (k*(hypo-2))))*float(hypo-1)/2\n      tot = last[-1] + diff_2\n      if tot > limit:\n        m = 1\n        if p == 1 and rid > 1:\n          p = 0; rid = rid/10\n        hypo = hypo - rid\n      else:\n        s = 1    \n  \n  seq.append(hypo)\n  somme.append(somme[-1]+ hypo)\n  last.append(last[-1]+ diff_1)\n\n\nprint(seq)\n"}
{"sequence_id": "A270343", "text": "Numbers n that end with ( sum of digits of n )^2.", "sequence": "0,1,81,3144,3256,6225,6484,6576,7121,7529,7676,9100,9324,9361,9729,9784,12144,12256,15225,15484,15576,16121,16529,16676,18100,18324,18361,18729,18784,21144,21256,24225,24484,24576,25121", "code": "\nfor i in range(0,200000):\n    res = pow((sum(map(int,str(i)))),2)\n    if(i%pow(10,len(str(res)))==res):print(i)\n\n"}
{"sequence_id": "A270361", "text": "Odd primes p for which there exists an odd prime q < p such that p*q - 1 is a square.", "sequence": "13,29,53,61,73,89,97,109,137,149,157,173,233,241,277,317,349,353,373,389,397,409,433,461,521,541,569,593,617,641,653,661,673,701,709,733,757,769,773,821,829,853,877,881,929,937", "code": "\nfrom gmpy2 import is_prime,is_square\nfor p in range(3,10**4,2):\n    flag=0\n    if(is_prime(p)):\nfor q in range(3,p,2):\n            if(is_square(p*q-1) and is_prime(q)):flag=1;break\n    if(flag):print(p)\n\n"}
{"sequence_id": "A270440", "text": "Least k such that binomial(k, 2) >= binomial(2*n, n).", "sequence": "2,3,4,7,13,23,44,84,161,313,609,1189,2327,4562,8958,17614,34673,68318,134724,265878,525066,1037554,2051390,4057939,8030892,15900354,31493446,62400953,123682583,245223436,486342641,964809156,1914483817,3799849586,7543612064,14979070587,29749371096,59095356237,117410567231", "code": "\nfrom __future__ import division\nfrom gmpy2 import iroot\nA270440_list, b = [], 8\nfor n in range(1001):\n    q, r = iroot(b+1,2)\n    A270440_list.append(int((q+1)//2 + (0 if r else 1)))\n    b = b*2*(2*n+1)//(n+1) \n"}
{"sequence_id": "A270441", "text": "Numbers n such that n^3+1 divides n!.", "sequence": "17,31,50,68,69,75,80,101,103,122,147,155,159,160,164,170,173,179,182,212,230,231,236,257,263,264,274,278,293,302,325,327,335,353,362,373,374,381,394,407,411,424,431,437,440,451,459,467,471,472,485,491,495,500", "code": "\nfrom math import factorial\nfor n in range(2,1000):\n    if(factorial(n)%(n**3+1)==0):print(n)\n\n"}
{"sequence_id": "A270538", "text": "Numbers n > 0 such that n = (d_1^1 + d_2^2 + d_3^3 + ...)^2, where d_k represents the k-th decimal digit of n.", "sequence": "0,1,81,441,3721", "code": "\nA270538_list = [n**2 for n in range(10**6) if n == sum(int(a)**(b+1) for b, a in enumerate(str(n**2)))] \n"}
{"sequence_id": "A270754", "text": "Numbers n such that n - 31, n - 1, n + 1 and n + 31 are consecutive primes.", "sequence": "90438,258918,293862,385740,426162,532950,1073952,1317192,1318410,1401318,1565382,1894338,1986168,2174772,2612790,2764788,3390900,3450048,3618960,3797250,3961722,3973062,4074870,4306230,4648068,4917360,5351010,5460492", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,1000001,6):\n.. if isprime(i-1) and isprime(i+1) and prevprime(i-1) == i-31 and nextprime(i+1) == i+31 :  print (i,end=', ')\n"}
{"sequence_id": "A270807", "text": "Trajectory of 1 under the map n -> n + n/gpf(n) + 1 (see A269304).", "sequence": "1,3,5,7,9,13,15,19,21,25,31,33,37,39,43,45,55,61,63,73,75,91,99,109,111,115,121,133,141,145,151,153,163,165,181,183,187,199,201,205,211,213,217,225,271,273,295,301,309,313,315,361,381,385,421,423,433,435,451,463,465", "code": "\nfrom __future__ import division\nfrom sympy import primefactors\nA270807_list, b = [], 1\nfor i in range(10000):\n    A270807_list.append(b)\n    b += b//(max(primefactors(b)+[1])) + 1 \n"}
{"sequence_id": "A270808", "text": "First differences of A270807, divided by 2.", "sequence": "1,1,1,1,2,1,2,1,2,3,1,2,1,2,1,5,3,1,5,1,8,4,5,1,2,3,6,4,2,3,1,5,1,8,1,2,6,1,2,3,1,2,4,23,1,11,3,4,2,1,23,10,2,18,1,5,1,8,6,1,8,7,23,1,2,1,5,7,2,1,2,6,18,1,2,25,2,1,32,1,17,7,2,1,2,10,14,3,7,8", "code": "\nfrom __future__ import division\nfrom sympy import primefactors\nA270808_list, a = [], 1\nfor i in range(10001):\n    b = a//(max(primefactors(a)+[1])) + 1\n    A270808_list.append(b//2)\n    a += b \n"}
{"sequence_id": "A270817", "text": "Integers n such that (2^n - 1) + (3^n - 1) + (5^n - 1) is a prime number.", "sequence": "1,3,4,9,11,69,117,449,675,1119,1959,2687,2859,8001,8175", "code": "\nfrom sympy import isprime\ndef afind(limit, startk=1):\n    pow2, pow3, pow5 = 2**startk, 3**startk, 5**startk\n    for k in range(startk, limit+1):\n        if isprime(pow2 + pow3 + pow5 - 3): print(k, end=\", \")\n        pow2 *= 2; pow3 *= 3; pow5 *= 5\nafind(1200) \n"}
{"sequence_id": "A270867", "text": "a(n) = n^3 + 2*n^2 + 4*n + 1.", "sequence": "1,8,25,58,113,196,313,470,673,928,1241,1618,2065,2588,3193,3886,4673,5560,6553,7658,8881,10228,11705,13318,15073,16976,19033,21250,23633,26188,28921,31838,34945,38248,41753,45466,49393,53540,57913,62518,67361,72448", "code": " for i in range(0,100):print(i**3+2*i**2+4*i+1) \n"}
{"sequence_id": "A270994", "text": "a(n) = 9454129 + 11184810*n.", "sequence": "9454129,20638939,31823749,43008559,54193369,65378179,76562989,87747799,98932609,110117419,121302229,132487039,143671849,154856659,166041469,177226279,188411089,199595899,210780709,221965519,233150329,244335139,255519949,266704759,277889569,289074379,300259189", "code": " for n in range(0,100):print(9454129+11184810*n) \n"}
{"sequence_id": "A271027", "text": "a(n) = 3661529 + 11184810*n.", "sequence": "3661529,14846339,26031149,37215959,48400769,59585579,70770389,81955199,93140009,104324819,115509629,126694439,137879249,149064059,160248869,171433679,182618489,193803299,204988109,216172919,227357729,238542539,249727349,260912159,272096969,283281779,294466589", "code": " for n in range(0,100):print(3661529+11184810*n) \n"}
{"sequence_id": "A271043", "text": "Primes p such that p and prime(p) end with the same digit.", "sequence": "7,11,23,29,37,103,107,109,149,239,271,277,293,307,331,367,379,431,449,499,503,541,557,577,601,701,751,761,787,821,823,839,881,883,907,953,967,983,991,1031,1033,1097,1163,1171,1213,1223,1249,1289,1321,1433", "code": "\nfrom sympy import isprime,prime\nfor p in range(2,10**4):\n    if(prime(p)%10==p%10 and isprime(p)):print(p)\n\n"}
{"sequence_id": "A271044", "text": "Primes p such that p and prime(p) end with the same two digits.", "sequence": "823,1033,1223,1723,1811,2027,2833,3079,3389,3461,3659,4691,5021,5231,5501,5581,5711,5851,6143,6151,6581,7043,7151,7253,7411,7759,7817,8429,8599,9551,10613,10733,10789,11069,11161,11701,12011,12637,12941,13381,13619", "code": "\nfrom sympy import isprime,prime\nfor p in range(2,20000):\n    if(prime(p)%100==p%100 and isprime(p)):print(p)\n\n"}
{"sequence_id": "A271045", "text": "Primes p such that p and prime(p) end with the same three digits.", "sequence": "1723,7817,9551,12637,23071,29201,29287,30059,38653,43067,53617,56671,57727,57809,60811,73351,74201,78307,79423,87403,89413,91771,107647,108301,113039,115259,116579,118543,133271,133649,138283,140317,154111,155569,160681", "code": "\nfrom sympy import isprime,prime\nfor p in range(2,100000):\n    if(prime(p)%1000==p%1000 and isprime(p)):print(p)\n\n"}
{"sequence_id": "A271046", "text": "Primes p such that p and prime(p) end with the same four digits.", "sequence": "9551,23071,107647,115259,160681,229499,259379,270701,279919,301649,321221,352543,375341,402049,411683,422621,526963,654413,667559,692647,745981,755143,761731,805523,816691,875107,968819,1069561,1117603,1143091,1182487,1199683", "code": "\nfrom sympy import isprime,prime\nfor p in range(2,10**6):\n    if(prime(p)%10000==p%10000 and isprime(p)):print(p)\n\n"}
{"sequence_id": "A271222", "text": "One of the two successive approximations up to 3^n for the 3-adic integer sqrt(-2). These are the numbers congruent to 2 mod 3 (except for the initial 0).", "sequence": "0,2,5,5,59,221,221,1679,3866,16988,56354,174452,174452,705893,705893,10271831,24620738,110714180,239854343,627274832,2951797766,2951797766,2951797766,65713916984,159857095811,442286632292", "code": "\ndef a271222(n):\n      ary=[0]\n      a, mod = 2, 3\n      for i in range(n):\n          b=a%mod\n          ary.append(b)\n          a=2*b**2 + b + 4\n          mod*=3\n      return ary\nprint(a271222(100)) \n"}
{"sequence_id": "A271267", "text": "Even numbers k such that k + 2 divides k^k + 2.", "sequence": "4,16,196,2836,5956,25936,65536,540736,598816,797476,1151536,3704416,8095984,11272276,13362420,21235696,29640832,31084096,42913396,49960912,55137316,70254724,70836676,81158416,94618996,111849956,129275056,150026176,168267856,169242676,189796420,192226516,198464176,208232116,244553296,246605776,300018016,318143296", "code": "\ndef afind(limit):\n  k = 2\n  while k < limit:\n    if (pow(k, k, k+2) + 2)%(k+2) == 0: print(k, end=\", \")\n    k += 2\nafind(10**7) \n"}
{"sequence_id": "A271268", "text": "Concatenate sum of digits of previous term and product of digits of previous term, starting with 8.", "sequence": "8,88,1664,17144,17112,1214,88,1664,17144,17112,1214,88,1664,17144,17112,1214,88,1664,17144,17112,1214,88,1664,17144,17112,1214,88,1664,17144,17112,1214,88,1664,17144,17112,1214,88,1664,17144,17112,1214,88,1664,17144", "code": "\nfrom functools import reduce\nfrom operator import mul\ndef product(seq):\n    return reduce(mul, seq, 1)\ndef conversion(n):\n    n = str(n)\n    return str(sum(int(i) for i in n)) + \\\n           str(product(int(i) for i in n))\ndef a271268(n):\n    if n == 1:\n        return 8\n    else:\n        r = 8\n        while n > 1:\n            r = conversion(r)\n            n -= 1\n        return int(r)\n"}
{"sequence_id": "A271323", "text": "Numbers n such that  n - 41, n - 1, n + 1, n + 41 are consecutive primes.", "sequence": "383220,1269642,1528938,2590770,3014700,3158298,3697362,3946338,4017312,4045050,4545642,4711740,4851618,4871568,5141178,5194602,5925042,5972958,5990820,6075030,6179862,6212202,6350760,6442938,6549312,6910638,6912132", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,12000001,6):\n..if isprime(i-1) and isprime(i+1) and prevprime(i-1) == i-41 and nextprime(i+1) == i+41: print (i,end=', ')\n"}
{"sequence_id": "A271327", "text": "Integers k such that the k-th prime divides the product of the first k nonzero Fibonacci numbers.", "sequence": "18,24,29,30,46,47,51,60,63,71,82,89,98,100,102,121,123,127,135,136,139,145,149,152,156,157,162,163,165,169,180,181,184,185,221,225,235,251,252,313,316,326,327,329,331,337,359,362,369,399,401,405,428,431,434,436,440,445,448,463", "code": "\nfrom sympy import prime\nA271327_list = []\nfor n in range(1,10**3):\n    p, a, b = prime(n), 1, 1\n    for i in range(n):\n        if not a:\n            A271327_list.append(n)\n            break\n        a, b = b, (a + b) % p \n"}
{"sequence_id": "A271347", "text": "Primes p such that p + 38 is also prime.", "sequence": "3,5,23,29,41,59,71,89,101,113,173,191,233,239,269,293,311,359,383,401,419,449,461,503,509,563,569,593,653,701,719,773,821,839,881,929,953,971,983,1013,1031,1049,1091,1163,1193,1259,1283,1289", "code": "\nfrom sympy import isprime\nfor i in range(3, 2001,2):\n..if isprime(i) and isprime(i+38): print (i,end=', ')\n"}
{"sequence_id": "A271349", "text": "Numbers n such that n - 35, n - 1, n + 1 and n + 35 are consecutive primes.", "sequence": "276672,558828,1050852,1278288,1486908,1625418,2536308,2538918,2690958,2731242,3015162,3252678,3268338,3508278,3711612,4233708,4575912,4717962,5004402,5108352,5404032,5482782,5519082,5525328,5640918,5654358,5995818", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,1000001,6):\n..if isprime(i-1) and isprime(i+1) and prevprime(i-1) == i-35 and nextprime(i+1) == i+35 :  print (i,end=', ')\n"}
{"sequence_id": "A271390", "text": "a(n) = (2*n + 1)^(2*floor((n-1)/2) + 1).", "sequence": "1,3,5,343,729,161051,371293,170859375,410338673,322687697779,794280046581,952809757913927,2384185791015625,4052555153018976267,10260628712958602189,23465261991844685929951,59938945498865420543457,177482997121587371826171875,456487940826035155404146917", "code": "\nfor n in range(0,10**3):print((int)((2*n+1)**(2*floor((n-1)/2)+1)))\n\n"}
{"sequence_id": "A271427", "text": "a(n) = 7^n - a(n-1) for n>0, a(0)=0.", "sequence": "0,7,42,301,2100,14707,102942,720601,5044200,35309407,247165842,1730160901,12111126300,84777884107,593445188742,4154116321201,29078814248400,203551699738807,1424861898171642,9974033287201501,69818233010410500,488727631072873507,3421093417510114542", "code": " for n in range(0,10**2):print((int)((7*(7**n-(-1)**n))/8))\n\n"}
{"sequence_id": "A271438", "text": "Numbers n such that the number formed by concatenating in ascending order the first n multidigit palindromic primes is prime.", "sequence": "1,17,451", "code": "\nfrom sympy import isprime, nextprime\ndef ispal(n): strn = str(n); return strn == strn[::-1]\ndef agen():\n  np, p, pstr = 1, 11, \"11\"\n  while True:\n    if isprime(int(pstr)): yield np\n    p = nextprime(p)\n    while not ispal(p): p = nextprime(p)\n    np += 1\n    pstr += str(p)\nfor an in agen(): print(an, end=\", \") \n"}
{"sequence_id": "A271472", "text": "Binary representation of n in base i-1.", "sequence": "0,1,1100,1101,111010000,111010001,111011100,111011101,111000000,111000001,111001100,111001101,100010000,100010001,100011100,100011101,100000000,100000001,100001100,100001101,110011010000,110011010001,110011011100,110011011101,110011000000,110011000001", "code": "\nfrom gmpy2 import c_divmod\nu = ('0000','1000','0011','1011')\ndef A271472(n):\n    if n == 0:\n        return 0\n    else:\n        s, q = '', n\n        while q:\n            q, r = c_divmod(q, -4)\n            s += u[r]\n        return int(s[::-1]) \n"}
{"sequence_id": "A271478", "text": "If n is even, a(n)=n/2, otherwise 2*n+2.", "sequence": "0,4,1,8,2,12,3,16,4,20,5,24,6,28,7,32,8,36,9,40,10,44,11,48,12,52,13,56,14,60,15,64,16,68,17,72,18,76,19,80,20,84,21,88,22,92,23,96,24,100,25,104,26,108,27,112,28,116,29,120,30,124,31,128,32,132,33,136,34,140,35", "code": "\nfor n in range(0,10**3):\n    if(not n%2):print((int)(n/2))\n    else:print(2*n+2)\n\n"}
{"sequence_id": "A271497", "text": "If n is a multiple of 3 then a(n) = n/3, otherwise a(n) = n'+n'', where n' (resp. n'') is obtained by sorting the bits of the binary expansion of n into increasing (resp. decreasing) order.", "sequence": "0,2,3,1,5,9,2,14,9,3,15,21,4,21,21,5,17,27,6,35,27,7,35,45,8,35,35,9,35,45,10,62,33,11,51,63,12,63,63,13,51,63,14,75,63,15,75,93,16,63,63,17,63,75,18,93,63,19,75,93,20,93,93,21,65,99,22,119,99,23,119,135,24,119,119,25,119,135", "code": "\nfrom __future__ import division\ndef A271497(n):\n    return int(''.join(sorted(bin(n)[2:])),2) + int(''.join(sorted(bin(n)[2:],reverse=True)),2) if n % 3 else n//3 \n"}
{"sequence_id": "A271499", "text": "Positive numbers n such that the number of 1's in the binary expansion of n is not a power of 2.", "sequence": "7,11,13,14,19,21,22,25,26,28,31,35,37,38,41,42,44,47,49,50,52,55,56,59,61,62,63,67,69,70,73,74,76,79,81,82,84,87,88,91,93,94,95,97,98,100,103,104,107,109,110,111,112,115,117,118,119,121,122,123,124,125,126,127,131,133,134,137,138,140", "code": "\nA271499_list = [n for n in range(1,10**6) if bin(bin(n).count('1')).count('1') != 1] \n"}
{"sequence_id": "A271507", "text": "Number of self-avoiding walks of any length from NW to SW corners on an n X n grid or lattice.", "sequence": "1,2,11,178,8590,1246850,550254085,741333619848,3046540983075504,38141694646516492843,1453908228148524205711098,168707605740228097581729005751,59588304533380500951726150179910606,64061403305026776755367065417308840021540", "code": "\n\nfrom graphillion import GraphSet\nimport graphillion.tutorial as tl\ndef A271507(n):\n    if n == 1: return 1\n    universe = tl.grid(n - 1, n - 1)\n    GraphSet.set_universe(universe)\n    start, goal = 1, n\n    paths = GraphSet.paths(start, goal)\n    return paths.len()\nprint([A271507(n) for n in range(1, 10)])  \n"}
{"sequence_id": "A271512", "text": "a(n) = (p+1)*(p+2)*(p+3)/6 where p is the n-th prime.", "sequence": "10,20,56,120,364,560,1140,1540,2600,4960,5984,9880,13244,15180,19600,27720,37820,41664,54740,64824,70300,88560,102340,125580,161700,182104,192920,215820,227920,253460,357760,392084,447580,467180,573800,596904,669920,748660", "code": "\nfrom sympy import prime\nfor n in range(1,1000):\n    p=prime(n)\n    print((int)(((p+1)*(p+2)*(p+3))/6))\n\n"}
{"sequence_id": "A271527", "text": "a(n) = 1000^n + 1.", "sequence": "2,1001,1000001,1000000001,1000000000001,1000000000000001,1000000000000000001,1000000000000000000001,1000000000000000000000001,1000000000000000000000000001,1000000000000000000000000000001,1000000000000000000000000000000001", "code": "\nfor n in range(0,10**4):print(1000**n+1)\n\n"}
{"sequence_id": "A271528", "text": "a(n) = 2*(10^n - 1)^2/27.", "sequence": "0,6,726,73926,7405926,740725926,74073925926,7407405925926,740740725925926,74074073925925926,7407407405925925926,740740740725925925926,74074074073925925925926,7407407407405925925925926,740740740740725925925925926,74074074074073925925925925926", "code": "\nfor n in range(0,10**1):print((int)((2*(10**n-1)**2)/27))\n\n"}
{"sequence_id": "A271532", "text": "a(n) = (-1)^n*(n + 1)*(5*n^2 + 10*n + 1).", "sequence": "1,-32,123,-304,605,-1056,1687,-2528,3609,-4960,6611,-8592,10933,-13664,16815,-20416,24497,-29088,34219,-39920,46221,-53152,60743,-69024,78025,-87776,98307,-109648,121829,-134880,148831,-163712,179553,-196384,214235,-233136,253117,-274208,296439", "code": " for n in range(0,10**3):print((-1)**n*(n+1)*(5*n**2+10*n+1)) \n"}
{"sequence_id": "A271572", "text": "a(n) = n^7 mod 32.", "sequence": "0,1,0,11,0,13,0,23,0,25,0,3,0,5,0,15,0,17,0,27,0,29,0,7,0,9,0,19,0,21,0,31,0,1,0,11,0,13,0,23,0,25,0,3,0,5,0,15,0,17,0,27,0,29,0,7,0,9,0,19,0,21,0,31,0,1,0,11,0,13,0,23,0,25,0,3,0,5", "code": " for n in range(0,50):print((n**7)%32) \n"}
{"sequence_id": "A271591", "text": "Second most significant bit of the tribonacci number A000073(n).", "sequence": "0,0,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1", "code": "\nA271591_list, a, b, c = [], 0, 1 ,1\nfor n in range(4,10001):\n    a, b, c = b, c, a+b+c\n    A271591_list.append(int(bin(c)[3])) \n"}
{"sequence_id": "A271592", "text": "Array read by antidiagonals: T(n,m) = number of directed Hamiltonian walks from NW to SW corners on a grid with n rows and m columns.", "sequence": "1,0,1,0,1,1,0,1,0,1,0,1,2,1,1,0,1,0,4,0,1,0,1,4,8,8,1,1,0,1,0,23,0,16,0,1,0,1,8,55,86,47,32,1,1,0,1,0,144,0,397,0,64,0,1,0,1,16,360,948,1770,1584,264,128,1,1,0,1,0,921,0,11658,0,6820,0,256,0,1", "code": "\n\nfrom graphillion import GraphSet\nimport graphillion.tutorial as tl\ndef A271592(n, k):\n    if k == 1: return 1\n    universe = tl.grid(k - 1, n - 1)\n    GraphSet.set_universe(universe)\n    start, goal = 1, n\n    paths = GraphSet.paths(start, goal, is_hamilton=True)\n    return paths.len()\nprint([A271592(j + 1, i - j + 1) for i in range(12) for j in range(i + 1)])  \n"}
{"sequence_id": "A271636", "text": "a(n) = 4*n*(4*n^2 + 3).", "sequence": "0,28,152,468,1072,2060,3528,5572,8288,11772,16120,21428,27792,35308,44072,54180,65728,78812,93528,109972,128240,148428,170632,194948,221472,250300,281528,315252,351568,390572,432360,477028,524672,575388,629272,686420", "code": " for n in range(0,1000):print(4*n*(4*n**2+3)) \n"}
{"sequence_id": "A271638", "text": "The total sum of the cubes of all parts of all compositions of n.", "sequence": "1,10,48,170,512,1398,3580,8770,20808,48206,109652,245850,544864,1196134,2605164,5636210,12124280,25952382,55312516,117440650,248512656,524288150,1103102108,2315255970,4848615592,10133438638,21139292340,44023414970,91536490688", "code": " for n in range(1,50):print((13*n-36)*2**(n-1)+6*n+18) \n"}
{"sequence_id": "A271666", "text": "Primes p such that 4*p^2+4*p-1 is prime.", "sequence": "2,3,7,13,17,23,31,37,53,59,67,139,149,151,157,167,179,193,199,223,233,293,307,331,359,373,389,431,479,571,587,619,643,653,683,809,839,857,863,919,937,947,1021,1091,1123,1151,1187,1277,1301,1367,1427,1511", "code": "\nfrom gmpy2 import is_prime\nfor p in range(3,10**5,2):\n    if(not is_prime(p)):continue\n    elif(is_prime(6*p**2+6*p-1)):print(p)\n\n"}
{"sequence_id": "A271667", "text": "Primes p such that 6*p^2+6*p-1 is prime.", "sequence": "3,5,13,41,43,61,71,73,103,113,181,223,241,269,271,283,379,433,479,491,521,523,593,619,631,659,719,839,929,941,1009,1039,1069,1193,1249,1289,1319,1429,1433,1471,1489,1511,1553,1601,1613,1693,1699,1723,1753,1861", "code": "\nfrom gmpy2 import is_prime\nfor p in range(3,10**5,2):\n    if(not is_prime(p)):continue\n    elif(is_prime(6*p**2+6*p-1)):print(p)\n\n"}
{"sequence_id": "A271675", "text": "Numbers m such that 3*m + 4 is a square.", "sequence": "0,4,7,15,20,32,39,55,64,84,95,119,132,160,175,207,224,260,279,319,340,384,407,455,480,532,559,615,644,704,735,799,832,900,935,1007,1044,1120,1159,1239,1280,1364,1407,1495,1540,1632,1679,1775,1824,1924,1975,2079,2132,2240,2295,2407", "code": "\nfrom gmpy2 import is_square\nfor n in range(0,10**5):\n    if(is_square(3*n+4)):print(n)\n\n"}
{"sequence_id": "A271713", "text": "Numbers n such that 3*n - 5 is a square.", "sequence": "2,3,7,10,18,23,35,42,58,67,87,98,122,135,163,178,210,227,263,282,322,343,387,410,458,483,535,562,618,647,707,738,802,835,903,938,1010,1047,1123,1162,1242,1283,1367,1410,1498,1543,1635,1682,1778,1827,1927,1978,2082,2135,2243,2298", "code": "\nfrom __future__ import division\nA271713_list = [(n**2+5)//3 for n in range(10**6) if not (n**2+5) % 3] \n"}
{"sequence_id": "A271723", "text": "Numbers k such that 3*k - 8 is a square.", "sequence": "3,4,8,11,19,24,36,43,59,68,88,99,123,136,164,179,211,228,264,283,323,344,388,411,459,484,536,563,619,648,708,739,803,836,904,939,1011,1048,1124,1163,1243,1284,1368,1411,1499,1544,1636,1683,1779,1828,1928,1979,2083,2136,2244,2299", "code": " from gmpy2 import is_square\n[n for n in range(3000) if is_square(3*n-8)] \n"}
{"sequence_id": "A271723", "text": "Numbers k such that 3*k - 8 is a square.", "sequence": "3,4,8,11,19,24,36,43,59,68,88,99,123,136,164,179,211,228,264,283,323,344,388,411,459,484,536,563,619,648,708,739,803,836,904,939,1011,1048,1124,1163,1243,1284,1368,1411,1499,1544,1636,1683,1779,1828,1928,1979,2083,2136,2244,2299", "code": " [(6*(n-1)*n-(2*n-1)*(-1)**n+23)/8 for n in range(1, 60)] \n"}
{"sequence_id": "A271899", "text": "a(n) = 1 + 471*n/140 + 1594*n^2/315 + 73*n^3/16 + 161*n^4/60 + 83*n^5/80 + 61*n^6/240 + n^7/28 + 11*n^8/5040.", "sequence": "1,18,162,927,3906,13248,38256,97614,225819,482482,965250,1827189,3299556,5720976,9574128,15531132,24508917,37735938,56831698,83900619,121641894,173477040,243696960,337630410,461835855,624318786,834776658,1104873697,1448547912,1882352736,2425835808", "code": "\nA271899_list, m = [], [88, -128, 61, -8]+[1]*5\nfor _ in range(100):\n    A271899_list.append(m[-1])\n    for i in range(8):\n        m[i+1] += m[i] \n"}
{"sequence_id": "A271901", "text": "Length of period of Narayana sequence A000930 modulo n-th prime.", "sequence": "7,8,31,57,60,168,288,381,528,840,930,342,1723,1848,46,468,3541,1240,33,5113,2664,6240,3444,7920,3169,10303,10713,11557,11991,991,2016,130,6256,1610,148,22800,24807,26733,4648,172,10680,32760,36673,37443,2156,3960,481,12432,226,26220,54523,8160,9680,63000", "code": "\nfrom sympy import prime\ndef A271901(n):\n    p = prime(n)\n    i, a, b, c =  1, 1, 1, 2 % p\n    while a != 1 or b != 1 or c != 1:\n        i += 1\n        a, b, c = b, c, (a+c) % p\n    return i \n"}
{"sequence_id": "A271977", "text": "G_6(n), where G is the Goodstein function defined in A266201.", "sequence": "0,139,1751,187243,16777215,33554571,50333399,84073323,134217727,134217867,134219479,134404971,150994943", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef bump(n,b):\n  s=digits(n,b)[1:]\n  l=len(s)\n  return sum(s[i]*(b+1)**bump(l-i-1,b) for i in range(l) if s[i])\ndef A271977(n):\n  if n==3: return 0\n  for i in range(2,8):\n    n=bump(n,i)-1\n  return n \n"}
{"sequence_id": "A271978", "text": "G_7(n), where G is the Goodstein function defined in A266201.", "sequence": "0,173,2454,332147,37665879,774841151,1162263921,1937434592,2749609302,3486784574,3486786855,3487116548,3524450280", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef bump(n,b):\n  s=digits(n,b)[1:]\n  l=len(s)\n  return sum(s[i]*(b+1)**bump(l-i-1,b) for i in range(l) if s[i])\ndef A271978(n):\n  if n==3: return 0\n  for i in range(2,9):\n    n=bump(n,i)-1\n  return n \n"}
{"sequence_id": "A271979", "text": "G_8(n), where G is the Goodstein function defined in A266201.", "sequence": "0,211,3325,555551,77777775,20000000211,30000003325,50000555551,70077777775,100000000211,100000003325,100000555551,100077777775", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef bump(n,b):\n  s=digits(n,b)[1:]\n  l=len(s)\n  return sum(s[i]*(b+1)**bump(l-i-1,b) for i in range(l) if s[i])\ndef A271979(n):\n  if n==3: return 0\n  for i in range(2,10):\n    n=bump(n,i)-1\n  return n \n"}
{"sequence_id": "A271981", "text": "Primes p such that p + 40 is also prime.", "sequence": "3,7,13,19,31,43,61,67,73,97,109,127,139,151,157,193,199,211,223,229,241,271,277,307,313,349,379,409,421,439,463,523,547,577,601,607,613,619,643,661,733,757,769,787,823,907,937,991,1009,1021,1051", "code": "\nfrom sympy import isprime\nfor i in range(3, 2001,2):\n..if isprime(i) and isprime(i+40): print (i,end=', ')\n"}
{"sequence_id": "A271982", "text": "Primes p such that p + 42 is also prime.", "sequence": "5,11,17,19,29,31,37,41,47,59,61,67,71,89,97,107,109,131,137,139,149,151,157,181,191,197,199,227,229,239,241,251,269,271,307,311,317,331,337,347,359,367,379,389,397,401,419,421,449,457,461", "code": "\nfrom sympy import isprime\nfor i in range(3,2001,2):\n..if isprime(i) and isprime(i+42): print (i,end=', ')\n"}
{"sequence_id": "A271985", "text": "G_9(n), where G is the Goodstein function defined in A266201.", "sequence": "0,253,4382,885775,150051213,570623341475,855935016215,1426559238830,1997331745490,3138428376974,3138428381103,3138429262496,3138578427934", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef bump(n,b):\n  s=digits(n,b)[1:]\n  l=len(s)\n  return sum(s[i]*(b+1)**bump(l-i-1,b) for i in range(l) if s[i])\ndef A271985(n):\n  if n==3: return 0\n  for i in range(2,11):\n    n=bump(n,i)-1\n  return n \n"}
{"sequence_id": "A271986", "text": "G_10(n), where G is the Goodstein function defined in A266201.", "sequence": "0,299,5643,1357259,273624711,17832200896811,26748301350411,44580503598539,62412976762503,106993205379371,106993205384715,106993206736331,106993479003783", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef bump(n,b):\n  s=digits(n,b)[1:]\n  l=len(s)\n  return sum(s[i]*(b+1)**bump(l-i-1,b) for i in range(l) if s[i])\ndef A271986(n):\n  if n==3: return 0\n  for i in range(2,12):\n    n=bump(n,i)-1\n  return n \n"}
{"sequence_id": "A272134", "text": "a(n) = n*(15*n^2 - 15*n + 4).", "sequence": "0,4,68,282,736,1520,2724,4438,6752,9756,13540,18194,23808,30472,38276,47310,57664,69428,82692,97546,114080,132384,152548,174662,198816,225100,253604,284418,317632,353336,391620,432574,476288,522852,572356,624890,680544", "code": " for n in range(0,10**3):print(n*(15*n**2-15*n+4),end=\", \") \n"}
{"sequence_id": "A272170", "text": "Second most significant bit of Fibonacci numbers > 1 written in base 2.", "sequence": "0,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,1,1,0,0,1,0", "code": "\nA272170_list, a, b = [], 1 ,1\nfor n in range(3,10001):\n    a, b = b, a+b\n    A272170_list.append(int(bin(b)[3])) \n"}
{"sequence_id": "A272176", "text": "Primes p such that p + 44 is also prime.", "sequence": "3,17,23,29,53,59,83,107,113,137,149,167,179,197,227,233,239,263,269,293,353,389,419,443,479,503,557,563,569,587,599,617,647,683,743,809,839,863,947,953,977,1019,1049,1109,1187,1193,1259,1277,1283", "code": "\nfrom sympy import isprime\nfor i in range(3, 3001, 2):\n    if isprime(i) and isprime(i + 44): print(i, end=', ')\n"}
{"sequence_id": "A272213", "text": "Number of distinct subsemigroups of the multiplicative semigroup of integers modulo n.", "sequence": "1,3,5,8,7,26,9,29,20,42,9,168,13,58,106,141,11,220,13,504,141,58,9,1997,66,99,279,1420,13,2764,17,2171,141,83,248,12412,19,99,258,19549,17,4135,17,15508,8310,58,9,91508,228,1758,226,60303,13,26691,248,228792,245,99,9,890397,25,140,109296,389930", "code": "\nfrom itertools import chain, combinations, combinations_with_replacement\nfor i in range(1, 100):\n    t = 0\n    for s in chain.from_iterable(combinations((list(range(0, i))), r) for r in range(1, i+1)):\n        c = 1\n        for k in combinations_with_replacement(s, 2):\n            if (k[0]*k[1])%i not in s:\n                c = 0\n                break\n        if c == 1:\n            t += 1\n    print(t,end=', ') \n"}
{"sequence_id": "A272265", "text": "Number of n-step tri-directional self-avoiding walks on the hexagonal lattice.", "sequence": "1,3,9,21,51,123,285,669,1569,3603,8343,19335,44193,101577,233697,532569,1218345,2789475,6343161,14464101,33004269,74923059,170440203,387945747,879473277,1997066751,4536975315,10273846185", "code": "\ndef add(L,x):\n... M=[y for y in L];M.append(x)\n... return(M)\nplus=lambda L,M : [x+y for x,y in zip(L,M)]\nmo=[[2,0],[-1,1],[-1, -1]]\ndef a(n,P=[[0, 0]]):\n... if n==0: return(1)\n... mv1 = [plus(P[-1],x) for x in mo]\n... mv2=[x for x in mv1 if x not in P]\n... if n==1: return(len(mv2))\n... else: return(sum(a(n-1,add(P,x)) for x in mv2))\n[a(n) for n in range(11)]\n\n"}
{"sequence_id": "A272297", "text": "a(n) = n^4 + 64.", "sequence": "64,65,80,145,320,689,1360,2465,4160,6625,10064,14705,20800,28625,38480,50689,65600,83585,105040,130385,160064,194545,234320,279905,331840,390689,457040,531505,614720,707345,810064,923585,1048640,1185985,1336400,1500689,1679680,1874225,2085200", "code": " [n**4+64 for n in range(40)]\n"}
{"sequence_id": "A272297", "text": "a(n) = n^4 + 64.", "sequence": "64,65,80,145,320,689,1360,2465,4160,6625,10064,14705,20800,28625,38480,50689,65600,83585,105040,130385,160064,194545,234320,279905,331840,390689,457040,531505,614720,707345,810064,923585,1048640,1185985,1336400,1500689,1679680,1874225,2085200", "code": " for n in range(0,10**5):print(n**4+64) \n"}
{"sequence_id": "A272298", "text": "a(n) = n^4 + 324.", "sequence": "324,325,340,405,580,949,1620,2725,4420,6885,10324,14965,21060,28885,38740,50949,65860,83845,105300,130645,160324,194805,234580,280165,332100,390949,457300,531765,614980,707605,810324,923845,1048900,1186245,1336660,1500949,1679940,1874485,2085460", "code": " [n**4+324 for n in range(40)]\n"}
{"sequence_id": "A272298", "text": "a(n) = n^4 + 324.", "sequence": "324,325,340,405,580,949,1620,2725,4420,6885,10324,14965,21060,28885,38740,50949,65860,83845,105300,130645,160324,194805,234580,280165,332100,390949,457300,531765,614980,707605,810324,923845,1048900,1186245,1336660,1500949,1679940,1874485,2085460", "code": " for n in range(0, 10**5):print(n**4+324,end=\", \") \n"}
{"sequence_id": "A272328", "text": "Number of integers 1<=k<=n such that phi(n)=phi(n+k) where phi is Euler's totient function A000010.", "sequence": "1,0,2,1,2,0,2,2,2,1,1,0,2,1,4,3,2,0,2,2,4,0,1,1,3,3,2,2,1,0,1,4,3,3,5,1,3,1,6,2,3,0,2,2,7,0,1,1,2,1,5,6,1,0,5,5,5,0,1,0,4,0,5,5,4,0,1,4,2,4,1,3,6,4,6,3,5,2,1,3,1,5,1,1,4,1,2", "code": "\nfrom sympy import totient\nnmax = 10**4\nphilist = [totient(i) for i in range(1,2*nmax+1)]\nA272328_list = [philist[i+1:2*(i+1)].count(philist[i]) for i in range(nmax)] \n"}
{"sequence_id": "A272363", "text": "Number of ways to group the first 2*n natural numbers into n pairs (xi,yi) with yi>xi, and such that the 2*n numbers xi+yi and xi-yi are all different.", "sequence": "1,1,0,2,12,64,220,1886,16346,142420,1302106,14467384,177079358", "code": "\nfrom sympy.utilities.iterables import multiset_partitions\ndef A272363(n):\n    return 1 if n == 0 else sum(1 for p in multiset_partitions(list(range(1,2*n+1)),n) if max(len(d) for d in p) == 2 and len(set([sum(d) for d in p]))+len(set([abs(d[0]-d[1]) for d in p])) == 2*n) \n"}
{"sequence_id": "A272369", "text": "Numbers n such that Bernoulli number B_{n} has denominator 1410.", "sequence": "92,184,1564,1748,2116,3496,4232,4324,5428,5612,6532,8648,9476,9844,10028,10856,11224,12604,14444,15364,16652,18124,18952,19412,20056,20884,21068,23644,24932,26036,26588,28612,28796,28888,29164,30728,31004,31924,32108,32476,33304,34868,35236,35788,36248,36524", "code": "\nfrom sympy import divisors, isprime\nA272369_list = []\nfor i in range(92, 10**6, 92):\n    for d in divisors(i):\n        if d not in (1,2,4,46) and isprime(d+1):\n            break\n    else:\n        A272369_list.append(i) \n"}
{"sequence_id": "A272378", "text": "a(n) = n*(6*n^2 - 8*n + 3).", "sequence": "0,1,22,99,268,565,1026,1687,2584,3753,5230,7051,9252,11869,14938,18495,22576,27217,32454,38323,44860,52101,60082,68839,78408,88825,100126,112347,125524,139693,154890,171151,188512,207009,226678,247555,269676,293077", "code": " for n in range(0,10**3):print(n*(6*n**2-8*n+3),end=\", \") \n"}
{"sequence_id": "A272383", "text": "Numbers n such that Bernoulli number B_{n} has denominator 3318.", "sequence": "78,1014,2418,3354,7566,8502,10842,11622,12246,12714,13026,15054,15366,15522,16458,17394,23946,26286,27222,27534,29562,29874,30342,31434,31902,33774,34242,35646,36114,40794,42198,43602,44538,47814,48126,48282,49218,50154,52494,55302,57174,57642,59046,59982", "code": "\nfrom sympy import divisors, isprime\nA272383_list = []\nfor i in range(78, 10**6, 78):\n    for d in divisors(i):\n        if d not in (1,2,6,78) and isprime(d+1):\n            break\n    else:\n        A272383_list.append(i) \n"}
{"sequence_id": "A272470", "text": "7 times the primes.", "sequence": "14,21,35,49,77,91,119,133,161,203,217,259,287,301,329,371,413,427,469,497,511,553,581,623,679,707,721,749,763,791,889,917,959,973,1043,1057,1099,1141,1169,1211,1253,1267,1337,1351,1379,1393,1477,1561,1589,1603,1631,1673,1687,1757,1799,1841,1883,1897", "code": "\nfrom sympy import prime\nfor n in range(1,1000):print(7*prime(n),end=\", \") \n"}
{"sequence_id": "A272552", "text": "Numbers n such that n*prime(n) is a pandigital number containing digits 0-9 exactly once.", "sequence": "11376,14562,15057,15723,16659,20421,21330,24867,28494,28746", "code": "\nfrom sympy import prime\nfrom numpy import sort\nfor n in range(10000,30000):\n   num=sort(list(str(n*prime(n))))\n   res=''.join(num)\n   if(res=='0123456789'):print(n)\n\n"}
{"sequence_id": "A272582", "text": "The number of strongly connected digraphs with n vertices and n+1 edges.", "sequence": "0,9,84,720,6480,63000,665280,7620480,94348800,1257379200,17962560000,273988915200,4446092851200,76498950528000,1391365527552000,26676557107200000,537799391281152000,11373816888225792000,251805357846282240000,5824367407574876160000", "code": "\nfrom __future__ import print_function\nfrom sympy import factorial\nfor n in range(2,500):\n   print((int)((n-2)*(n+3)*factorial(n)/4),end=\", \")\n\n"}
{"sequence_id": "A272610", "text": "a(1)=5, a(2)=9, a(3)=4, a(4)=6; thereafter a(n) = a(n-a(n-1)) + a(n-a(n-2)).", "sequence": "5,9,4,6,5,5,18,4,5,10,10,18,4,10,15,10,27,4,15,15,10,36,4,15,20,15,36,4,20,25,15,45,4,25,25,20,45,4,25,35,15,54,4,35,25,20,72,4,25,40,25,54,4,40,40,20,72,4,40,35,25,81,4,35,50,25,81,4,50,40,25,117", "code": "\nfrom functools import cache\n@cache\ndef a(n):\n    if n < 0: return 0\n    if n < 5: return [0, 5, 9, 4, 6][n]\n    return a(n - a(n-1)) + a(n - a(n-2))\nprint([a(n) for n in range(1, 73)]) \n"}
{"sequence_id": "A272636", "text": "a(0)=0, a(1)=1; thereafter a(n) = squarefree part of a(n-1)+a(n-2).", "sequence": "0,1,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7,1,2,3,5,2,7", "code": "\nfrom sympy.ntheory.factor_ import core\nl=[0, 1]\nfor n in range(2, 101):\n    l.append(core(l[n - 1] + l[n - 2]))\nprint(l) \n"}
{"sequence_id": "A272653", "text": "Numbers whose binary expansion is an abelian square.", "sequence": "3,9,10,15,33,34,36,43,45,46,51,53,54,63,129,130,132,136,147,149,150,153,154,156,163,165,166,169,170,172,183,187,189,190,195,197,198,201,202,204,215,219,221,222,231,235,237,238,255,513,514,516,520,528,547", "code": "\nfrom sympy.utilities.iterables import multiset_permutations\nA272653_list = [int(b+''.join(s),2) for b in (bin(n)[2:] for n in range(1,100)) for s in multiset_permutations(sorted(b))] \n"}
{"sequence_id": "A272654", "text": "Binary words beginning with 1 which are abelian squares.", "sequence": "11,1001,1010,1111,100001,100010,100100,101011,101101,101110,110011,110101,110110,111111,10000001,10000010,10000100,10001000,10010011,10010101,10010110,10011001,10011010,10011100,10100011,10100101,10100110,10101001,10101010,10101100", "code": "\nfrom sympy.utilities.iterables import multiset_permutations\nA272654_list = [int(b+''.join(s)) for b in (bin(n)[2:] for n in range(1,100)) for s in multiset_permutations(sorted(b))] \n"}
{"sequence_id": "A272655", "text": "Numbers whose decimal expansion is an abelian square.", "sequence": "11,22,33,44,55,66,77,88,99,1001,1010,1111,1212,1221,1313,1331,1414,1441,1515,1551,1616,1661,1717,1771,1818,1881,1919,1991,2002,2020,2112,2121,2222,2323,2332,2424,2442,2525,2552,2626,2662,2727,2772,2828,2882,2929,2992", "code": "\nfrom sympy.utilities.iterables import multiset_permutations\nA272655_list = [int(str(n)+''.join(s)) for n in range(1,100) for s in multiset_permutations(sorted(str(n)))] \n"}
{"sequence_id": "A272670", "text": "Numbers whose binary expansion is not palindromic but which when reversed and leading zeros omitted, does form a palindrome.", "sequence": "2,4,6,8,10,12,14,16,18,20,24,28,30,32,34,36,40,42,48,54,56,60,62,64,66,68,72,80,84,90,96,102,108,112,120,124,126,128,130,132,136,144,146,160,168,170,180,186,192,198,204,214,216,224,238,240,248,252,254", "code": "\nA272670_list = [n for n in range(1,10**4) if bin(n)[2:] != bin(n)[:1:-1] and bin(n)[2:].rstrip('0') == bin(n)[:1:-1].lstrip('0')] \n"}
{"sequence_id": "A272671", "text": "Numbers k such that the decimal number 1k is a square.", "sequence": "6,21,44,69,96,156,225,296,369,444,521,600,681,764,849,936,1025,1236,1449,1664,1881,2100,2321,2544,2769,2996,3225,3456,3689,3924,4161,4400,4641,4884,5129,5376,5625,5876,6129,6384,6641,6900,7161,7424,7689,7956,8225,8496,8769,9044,9321,9600", "code": "\nfrom sympy.ntheory.primetest import is_square\ndef ok(n): return is_square(int('1'+str(n)))\nprint(list(filter(ok, range(9601)))) \n"}
{"sequence_id": "A272673", "text": "Take list of squares that start with 1 (A045784) and omit the leading 1 and any leading zeros from what is left; if the number was a power of 10, replace it with 0.", "sequence": "0,6,0,21,44,69,96,24,89,156,225,296,369,444,521,600,681,764,849,936,0,201,404,609,816,1025,1236,1449,1664,1881,2100,2321,2544,2769,2996,3225,3456,3689,3924,4161,4400,4641,4884,5129,5376,5625,5876", "code": "\nA272673_list = [0] + [int(str(m**2)[1:]) if sum(int(d) for d in str(m**2)[1:]) != 1 else 0 for m in range(4,10**3) if str(m**2)[0] == '1'] \n"}
{"sequence_id": "A272679", "text": "a(n)^2 is the smallest square whose binary expansion begins with the binary expansion of n.", "sequence": "0,1,2,5,2,9,5,11,4,3,9,19,5,21,15,11,4,33,6,25,9,13,19,39,7,5,29,21,15,61,11,45,8,23,33,67,6,49,35,25,9,73,13,53,107,19,77,39,79,7,10,81,29,83,59,21,15,43,61,87,11,89,63,45,8,129,23,93,33,47", "code": "\nfrom gmpy2 import isqrt\ndef A272679(n):\n    if n == 0:\n        return 0\n    else:\n        d, nd = 1, n\n        while True:\n            x = isqrt(nd-1)+1\n            if x**2 < nd+d:\n                return int(x)\n            d *= 2\n            nd *= 2 \n"}
{"sequence_id": "A272680", "text": "Smallest square that begins with n (in binary).", "sequence": "0,1,4,25,4,81,25,121,16,9,81,361,25,441,225,121,16,1089,36,625,81,169,361,1521,49,25,841,441,225,3721,121,2025,64,529,1089,4489,36,2401,1225,625,81,5329,169,2809,11449,361,5929,1521,6241,49,100,6561,841,6889", "code": "\nfrom gmpy2 import isqrt\ndef A272680(n):\n    if n == 0:\n        return 0\n    else:\n        d, nd = 1, n\n        while True:\n            x = (isqrt(nd-1)+1)**2\n            if x < nd+d:\n                return int(x)\n            d *= 2\n            nd *= 2 \n"}
{"sequence_id": "A272681", "text": "Smallest binary square that begins with the binary expansion of n.", "sequence": "0,1,100,11001,100,1010001,11001,1111001,10000,1001,1010001,101101001,11001,110111001,11100001,1111001,10000,10001000001,100100,1001110001,1010001,10101001,101101001,10111110001,110001,11001,1101001001,110111001,11100001,111010001001", "code": "\nfrom gmpy2 import isqrt\ndef A272681(n):\n    if n == 0:\n        return 0\n    else:\n        d, nd = 1, n\n        while True:\n            x = (isqrt(nd-1)+1)**2\n            if x < nd+d:\n                return int(bin(x)[2:])\n            d *= 2\n            nd *= 2 \n"}
{"sequence_id": "A272695", "text": "Nearest integer to n*sin(n).", "sequence": "0,1,2,0,-3,-5,-2,5,8,4,-5,-11,-6,5,14,10,-5,-16,-14,3,18,18,0,-19,-22,-3,20,26,8,-19,-30,-13,18,33,18,-15,-36,-24,11,38,30,-7,-38,-36,1,38,41,6,-37,-47,-13,34,51,21,-30,-55,-29,25,58,38,-18,-59,-46,11,59,54,-2,-57,-61,-8,54,68,18", "code": "\nfrom sympy import sin\ndef A272695(n):\n    return int((n*sin(n)).round()) \n"}
{"sequence_id": "A272816", "text": "Prime pairs of the form (p, p+20).", "sequence": "3,23,11,31,17,37,23,43,41,61,47,67,53,73,59,79,83,103,89,109,107,127,131,151,137,157,173,193,179,199,191,211,251,271,257,277,263,283,293,313,311,331,317,337,347,367,353,373,359,379,389,409,401,421", "code": "\nfrom gmpy2 import is_prime\nfor n in range(1000):\n   if(is_prime(n) and is_prime(n+20)):\n      print('{}, {}'.format(n,n+20),end=', ')\n\n"}
{"sequence_id": "A272890", "text": "Numbers n such that the product of n and the sum of the reciprocal of their anti-divisors is an integer.", "sequence": "9,36,441,576,1296,1764,2025,7569,10404,17424,23409,34596,41616,51984,56169,74529,88209,90000,103041,140625,181476,194481,219024,236196,239121,269361,324900,367236,404496,480249,540225,571536,576081,627264,783225,842724,904401", "code": "\nfrom fractions import Fraction\nfrom sympy.ntheory.factor_ import antidivisors\nA272890_list = [n for n in range(3,10**5) if sum(Fraction(n,a) for a in antidivisors(n)).denominator == 1] \n"}
{"sequence_id": "A272896", "text": "Difference between the number of odd and even digits in the decimal expansion of 2^n.", "sequence": "1,-1,-1,-1,0,0,-2,-1,-1,1,-2,-4,-2,0,-1,-1,1,2,-4,-4,-1,1,-1,-5,2,2,-4,1,-3,1,0,-4,-2,2,3,3,1,4,-2,2,5,3,-1,-5,-2,-2,-2,1,-1,3,-4,0,2,2,-1,-1,5,2,2,-4,-3,1,-5,-1,0,0,-6,3,5,5,2,-10,-8,2,-3,7,9,0,0", "code": "\ndef A272896(n):\n....x=y=0\n....for i in str(2**n):\n........if int(i)%2: x+=1\n........else: y+=1\n....return x - y \n"}
{"sequence_id": "A272899", "text": "Product of next n prime numbers greater than n.", "sequence": "2,15,385,5005,323323,7436429,955049953,35336848261,1448810778701,62298863484143,14107860812636383,832363787945546597,261682369333342226303,18579448222667298067513,1356299720254712758928449,107147677900122307955347471", "code": "\nfrom math import prod\nfrom sympy import prime, primepi\ndef a(n): r = primepi(n); return prod(prime(i) for i in range(r+1, r+n+1))\nprint([a(n) for n in range(1, 17)]) \n"}
{"sequence_id": "A272915", "text": "a(n) = n + floor(5*n/6).", "sequence": "0,1,3,5,7,9,11,12,14,16,18,20,22,23,25,27,29,31,33,34,36,38,40,42,44,45,47,49,51,53,55,56,58,60,62,64,66,67,69,71,73,75,77,78,80,82,84,86,88,89,91,93,95,97,99,100,102,104,106,108,110,111,113,115,117,119", "code": " [n+int(5*n/6) for n in range(70)]\n"}
{"sequence_id": "A272918", "text": "Fibonacci numbers with the base 10 digits sorted into increasing order.", "sequence": "0,1,1,2,3,5,8,13,12,34,55,89,144,233,377,16,789,1579,2458,1148,5667,1469,11177,25678,34668,2557,112339,114689,111378,122459,2348,1234669,123789,2345578,257788,2245679,1233459,11245778,1368899,23456689,11233455,11145568", "code": "\nfrom gmpy2 import fib\nfor n in range(500):\n   print(''.join(sorted(list(str(fib(n))))),end=', ')\n\n"}
{"sequence_id": "A273004", "text": "Sum of coefficients in the hereditary representation of n in base 2.", "sequence": "0,1,2,3,3,4,5,6,4,5,6,7,7,8,9,10,4,5,6,7,7,8,9,10,8,9,10,11,11,12,13,14,5,6,7,8,8,9,10,11,9,10,11,12,12,13,14,15,9,10,11,12,12,13,14,15,13,14,15,16,16,17,18,19,6,7,8,9,9,10,11,12,10,11,12,13,13,14,15,16,10,11,12,13,13,14,15,16,14,15,16,17,17,18,19,20,11,12,13,14,14", "code": "\ndef A273004(n):\n  s=format(n,'b')[::-1]\n  return sum(1+A273004(i) for i in range(len(s)) if s[i]=='1') \n"}
{"sequence_id": "A273005", "text": "Sum of coefficients in the hereditary representation of n in base 10.", "sequence": "0,1,2,3,4,5,6,7,8,9,2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7,8,9,10,11,12,13,14,6,7,8,9,10,11,12,13,14,15,7,8,9,10,11,12,13,14,15,16,8,9,10,11,12,13,14,15,16,17,9,10,11,12,13,14,15,16,17,18,10,11,12,13,14,15,16,17,18,19,3", "code": "\ndef A273005(n):\n  s=str(n)[::-1]\n  return sum(int(s[i])+A273005(i) for i in range(len(s)) if s[i]!='0') \n"}
{"sequence_id": "A273039", "text": "Numbers n such that the following process converges to zero: x(0)=n, x(i+1) = x(i) XOR ror(x(i)) XOR rol(x(i)), see the Comments section for details.", "sequence": "0,5,6,9,24,29,34,40,43,45,48,51,54,57,65,66,68,71,75,77,80,83,86,89,90,92,101,102,111,129,130,135,139,141,153,154,159,180,189,198,204,209,216,219,226,231,232,238,257,260,263,267,272,275,277,278,282,284,297", "code": "\ndef ROR(n):                \n    BL = len(bin(n))-2\n    return (n>>1) + ((n&1) << (BL-1))\ndef ROL(n):                \n    BL = len(bin(n))-2\n    return (n*2) - (1<<BL) + 1\nfor n in range(1000):\n    X = n\n    Xs = []\n    while not (X in Xs):\n        Xs.append(X)\n        if X==0:\n            print str(n)+',',\n            break\n        X = X ^ ROR(X) ^ ROL(X)\n"}
{"sequence_id": "A273050", "text": "Numbers k such that ror(k) XOR rol(k) = k, where ror(x)=A038572(x) is x rotated one binary place to the right, rol(x)=A006257(x) is x rotated one binary place to the left, and XOR is the binary exclusive-or operator.", "sequence": "0,5,6,45,54,365,438,2925,3510,23405,28086,187245,224694,1497965,1797558,11983725,14380470,95869805,115043766,766958445,920350134,6135667565,7362801078,49085340525,58902408630,392682724205,471219269046", "code": "\ndef ROR(n):                \n    BL = len(bin(n))-2\n    return (n>>1) + ((n&1) << (BL-1))\ndef ROL(n):                \n    BL = len(bin(n))-2\n    return (n*2) - (1<<BL) + 1\nprint('0', end=',')\nfor n in range(1,100000):\n    if  ROR(n) ^ ROL(n) == n: print(n, end=',')\n"}
{"sequence_id": "A273101", "text": "Numbers n such that n - 43, n - 1, n + 1, n + 43 are consecutive primes.", "sequence": "7714800,8126820,8341260,8646060,9200880,9422970,13224270,13597920,14012460,14124630,15305700,17008680,17563920,18830940,22603740,22812150,24576240,25197300,26147040,26196900,26932950,27225240,30305580,31214640", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,60000001,6):\n..if isprime(i-1) and isprime(i+1) and prevprime(i-1) == i-43 and nextprime(i+1) == i+43: print (i,end=', ')\n"}
{"sequence_id": "A273105", "text": "a(n) = A038572(n) + A006257(n), sum of the two numbers obtained by rotating the binary representation of n by one place to the right and to the left.", "sequence": "0,2,2,6,3,9,8,14,5,15,10,20,15,25,20,30,9,27,14,32,19,37,24,42,29,47,34,52,39,57,44,62,17,51,22,56,27,61,32,66,37,71,42,76,47,81,52,86,57,91,62,96,67,101,72,106,77,111,82,116,87,121,92,126,33,99", "code": "\nprint('0', end=',')\nfor n in range(1,1000):\n    BL = len(bin(n))-2\n    x = (n>>1) + ((n&1) << (BL-1))   \n    x+= (n*2) - (1<<BL) + 1   \n    print(str(x), end=',')\n"}
{"sequence_id": "A273106", "text": "Numbers representable as ror(k)+rol(k), where ror(k)=A038572(k) is k rotated one binary place to the right, rol(k)=A006257(k) is k rotated one binary place to the left.", "sequence": "0,2,3,5,6,8,9,10,14,15,17,19,20,22,24,25,27,29,30,32,33,34,37,38,39,42,43,44,47,48,51,52,53,56,57,58,61,62,63,65,66,67,68,70,71,72,73,75,76,77,78,80,81,82,83,85,86,87,88,90,91,92,93,95,96,98", "code": "\ndef ROR(n):                \n    BL = len(bin(n))-2\n    return (n>>1) + ((n&1) << (BL-1))\ndef ROL(n):                \n    BL = len(bin(n))-2\n    return (n*2) - (1<<BL) + 1\na = [0]\nfor n in range(1, 1000):  a.append(ROR(n) + ROL(n))\nprint(sorted(set(a)))\n"}
{"sequence_id": "A273158", "text": "Number of concatenations nm consisting of n followed by a positive integer m (not a multiple of 10) that are divisible by m.", "sequence": "5,6,12,8,8,14,14,9,21,9,14,17,16,17,19,11,16,25,16,11,32,17,16,20,11,18,33,20,17,21,17,12,33,18,20,29,17,18,35,12,17,37,17,20,31,18,17,23,26,12", "code": "\n\nimport math\nfor N in range (1, 100):\n   ANZ = 0\n   for M in range(1, 195312500):\n      Z = int(str(int(N)) + str(int(M)))\n      if ((Z % M == 0) and (M % 10 > 0)):\n         ANZ = ANZ + 1\n   print(N, ANZ)\n"}
{"sequence_id": "A273190", "text": "a(n) is the number of nonnegative m < n for which m + n is a perfect square.", "sequence": "0,1,0,1,1,1,1,1,1,2,1,1,1,2,2,2,2,1,1,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,3,3,3,2,2,2,2,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,4,4,4,4,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4", "code": "\nfrom gmpy2 import isqrt\ndef A273190(n):\n    return isqrt(2*n-1)-isqrt(n-1) if n > 0 else 0 \n"}
{"sequence_id": "A273245", "text": "Non-palindromic binary numbers whose reversal is a palindrome.", "sequence": "10,100,110,1000,1010,1100,1110,10000,10010,10100,11000,11100,11110,100000,100010,100100,101000,101010,110000,110110,111000,111100,111110,1000000,1000010,1000100,1001000,1010000,1010100,1011010,1100000,1100110,1101100,1110000,1111000,1111100", "code": "\nA273245_list = [int(m) for m in (bin(n)[2:] for n in range(1,10**4)) if m != m[::-1] and m.rstrip('0') == m[::-1].lstrip('0')] \n"}
{"sequence_id": "A273355", "text": "Numbers n such that n - 47, n - 1, n + 1, n + 47 are consecutive primes.", "sequence": "15370470,15462870,18216510,23726160,30637050,31054740,38907060,39220080,44499900,44678190,60563100,66248550,86219910,87095190,87948780,93773970,96802860,103011990,105953760,105978330,106960410,111219990,116281770", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,160000001,6):\n..if isprime(i-1) and isprime(i+1) and prevprime(i-1) == i-47 and nextprime(i+1) == i+47: print (i,end=', ')\n"}
{"sequence_id": "A273356", "text": "Numbers n such that n - 49, n - 1, n + 1, n + 49 are consecutive primes.", "sequence": "913638,2763882,4500492,6220518,6473148,13884468,15131982,15729942,19671930,20494602,21372888,23791350,25541028,29535348,30787788,30906768,32085372,34128168,34139802,34550430,35989980,37473180,37784310,38106372", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,60000001,6):\n..if isprime(i-1) and isprime(i+1) and prevprime(i-1) == i-49 and nextprime(i+1) == i+49: print (i,end=', ')\n"}
{"sequence_id": "A273372", "text": "Squares ending in digit 1.", "sequence": "1,81,121,361,441,841,961,1521,1681,2401,2601,3481,3721,4761,5041,6241,6561,7921,8281,9801,10201,11881,12321,14161,14641,16641,17161,19321,19881,22201,22801,25281,25921,28561,29241,32041,32761,35721,36481,39601,40401", "code": "\nA273372_list = [(10*n+m)**2 for n in range(10**3) for m in (1,9)] \n"}
{"sequence_id": "A273526", "text": "Number of 123-avoiding indecomposable permutations.", "sequence": "1,1,3,11,38,127,423,1423,4854,16787,58776,208001,742888,2674427,9694831,35357655,129644774,477638683,1767263172,6564120401,24466267000,91482563619,343059613628,1289904147301,4861946401428,18367353072127,69533550915978,263747951750333,1002242216651340,3814986502092275", "code": "\nimport math\nf=math.factorial\ndef C(n,r): return f(n)/f(r)/f(n-r)\ndef Catalan(n): return C(2*n,n)/(n+1)\ndef A273526(n): return Catalan(n)-n+1 \n"}
{"sequence_id": "A273662", "text": "Least monotonic left inverse for A256450: a(1) = 0; for n > 1, a(n) = A257680(n) + a(n-1).", "sequence": "0,1,2,2,3,4,5,6,7,8,9,9,10,11,12,12,13,13,14,15,16,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,41,42,43,44,44,45,46,47,48,49,50,51,51,52,53,54,54,55,55,56,57,58,58,59,59,60,61,62,62,63,64,65,66,67,68,69,69,70", "code": "\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a257680(n): return 1 if '1' in str(a007623(n)) else 0\nl=[0, 0]\nfor n in range(2, 101):\n    l.append(a257680(n) + l[n - 1])\nprint(l[1:]) \n"}
{"sequence_id": "A273663", "text": "Least monotonic left inverse for A273670: a(1) = 0; for n > 1, a(n) = A257680(A225901(n)) + a(n-1).", "sequence": "0,0,1,2,3,3,4,4,5,6,7,7,8,8,9,10,11,12,13,14,15,16,17,17,18,18,19,20,21,21,22,22,23,24,25,25,26,26,27,28,29,30,31,32,33,34,35,35,36,36,37,38,39,39,40,40,41,42,43,43,44,44,45,46,47,48,49,50,51,52,53,53,54,54,55,56,57,57,58,58,59,60,61,61", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a225901(n):\n    s=0\n    k=2\n    while n:\n        d=n%k\n        n=n//k\n        if d: s=s+(k - d)*f(k - 1)\n        k+=1\n    return s\ndef a257680(n): return 1 if '1' in str(a007623(n)) else 0\ndef a(n): return 0 if n==1 else a257680(a225901(n)) + a(n - 1)\nl=[0, 0]\nfor n in range(2, 101): l.append(a257680(a225901(n)) + l[n - 1])\nprint(l[1:]) \n"}
{"sequence_id": "A273670", "text": "Numbers with at least one maximal digit in their factorial base representation.", "sequence": "1,3,4,5,7,9,10,11,13,15,16,17,18,19,20,21,22,23,25,27,28,29,31,33,34,35,37,39,40,41,42,43,44,45,46,47,49,51,52,53,55,57,58,59,61,63,64,65,66,67,68,69,70,71,73,75,76,77,79,81,82,83,85,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623(int(n/p), p+1)*10 + n%p\ndef a257684(n):\n    x=str(a007623(n))[:-1]\n    y=\"\".join([str(int(i) - 1) if int(i)>0 else '0' for i in x])[::-1]\n    return 0 if n==1 else sum([int(y[i])*f(i + 1) for i in range(len(y))])\ndef a260736(n): return 0 if n==0 else n%2 + a260736(a257684(n))\nprint([n for n in range(106) if a260736(n)>0]) \n"}
{"sequence_id": "A273889", "text": "a(n) = ((4n-3)!! + (4n-2)!!) / (4n-1).", "sequence": "1,9,435,52017,11592315,4152126825,2182133628675,1581940549814625,1512952069890336075,1845586177840605209625,2796710279417971723681875,5153962250373844341910100625,11351091844757135191108560046875,29444207228221006416048397134215625,88848552445321896564985597922269171875", "code": "\nfor n in range(1,101):\n    if n == 1:\n        a = 1\n        b = 2\n    else:\n        a = a*(4*n-5)*(4*n-3)\n        b = b*(4*n-4)*(4*n-2)\n    c = (a+b)/(4*n-1)\n    print(str(n)+\" \"+str(c))\n"}
{"sequence_id": "A273983", "text": "a(n) = ((4*n)!! - (4*n-1)!!)/(4*n+1).", "sequence": "1,31,2745,487935,145769625,65830256415,41892106080825,35736278004165375,39370290736153001625,54420772423242699849375,92234193751998833171261625,188098544080793843475953349375,454418941572893462364414856265625,1283429428883663190972186961851609375", "code": "\ndoublefac=lambda x:1 if x<2 else x*doublefac(x-2)\nfor i in range(200):\n    print(i,(doublefac(4*i)-doublefac(4*i-1))//(4*i+1))\n\n"}
{"sequence_id": "A274016", "text": "Choose the lexically first tuple of six nonincreasing positive integers (a, b, c, d, e, f) such that a*b*c + d*e*f = n. Then a(n) = a*b*c.", "sequence": "1,2,3,4,5,6,7,8,8,10,8,12,12,14,8,16,16,18,12,20,18,22,16,24,18,26,27,27,27,27,24,27,32,27,27,36,36,27,36,40,36,42,36,27,45,45,36,48,48,48,48,45,27,54,48,48,50,58,48,60,60,36,60,64,48,64,64,60,64,63,64", "code": "\n\nlimit = 10000\nres = [0 for i in range(limit-1)]\na = 1\nwhile not all(i > 0 for i in res):\n..for b in range(1,a+1):\n....for c in range(1,b+1):\n......for d in range(1,c+1):\n........for e in range(1,d+1):\n..........for f in range(1,e+1):\n............if a*b*c + d*e*f in range(2,limit+1):\n..............if not res[a*b*c + d*e*f - 2]:\n................res[a*b*c + d*e*f - 2] = a*b*c\n..a += 1\nfor i in range(limit-1):\n..print(i+2, res[i])\n"}
{"sequence_id": "A274042", "text": "Numbers n such that n - 53, n - 1, n + 1, n + 53 are consecutive primes.", "sequence": "9401700,64312710,78563130,83494350,92978310,101520540,111105090,121631580,136765860,138330780,139027950,145673850,157008390,163050090,166418280,169288530,170473410,177920850,198963210,200765250,213504870,220428600", "code": "\nfrom sympy import isprime,prevprime,nextprime\nfor i in range(0,250000001,6):\n..if isprime(i-1) and isprime(i+1) and prevprime(i-1) == i-53 and nextprime(i+1) == i+53: print (i,end=', ')\n"}
{"sequence_id": "A274045", "text": "Primes p such that p + 72 is the next prime.", "sequence": "31397,360091,507217,517639,633667,650107,705317,749471,753859,770669,809629,818021,828277,1001839,1025957,1087159,1133387,1145899,1152421,1164101,1206869,1207769,1210639,1241087,1278911,1290719,1351997", "code": "\nfrom sympy import isprime,nextprime\nfor i in range(3,1500001,2):\n..if isprime(i) and nextprime(i) == i+72: print(i,end=', ')\n"}
{"sequence_id": "A274086", "text": "Nearest integer to n*tan(n).", "sequence": "0,2,-4,0,5,-17,-2,6,-54,-4,6,-2485,-8,6,101,-13,5,59,-20,3,45,-32,0,37,-51,-3,31,-88,-8,26,-192,-14,21,-2485,-21,17,279,-31,12,141,-45,7,96,-64,1,73,-96,-6,58,-155,-14,46,-315,-23,36,-2485,-34,28,483,-49,19,228,-68,11,150,-96,2,111,-139", "code": "\nfrom sympy import tan\ndef A274086(n):\n    return int((n*tan(n)).round()) \n"}
{"sequence_id": "A274087", "text": "Nearest integer to n^2*sin(n).", "sequence": "0,1,4,1,-12,-24,-10,32,63,33,-54,-121,-77,71,194,146,-74,-278,-243,54,365,369,-4,-448,-522,-83,515,697,212,-558,-889,-388,565,1089,612,-525,-1285,-881,428,1466,1192,-267,-1617,-1538,34,1723,1908,273,-1770,-2290,-656,1743,2668,1112,-1629,-3024,-1636", "code": "\nfrom sympy import sin\ndef A274087(n):\n    return int((n**2*sin(n)).round()) \n"}
{"sequence_id": "A274088", "text": "a(n) = nearest integer to n^2 * sin(sqrt(n)).", "sequence": "0,1,4,9,15,20,23,23,20,11,-2,-21,-46,-76,-111,-150,-194,-240,-289,-339,-389,-437,-484,-527,-566,-599,-626,-645,-656,-658,-649,-630,-600,-559,-505,-440,-362,-273,-171,-58,66,201,346,501,664,835,1013,1197,1385,1577,1772,1968,2164,2359,2551,2740", "code": "\nfrom sympy import sin, sqrt\ndef A274088(n):\n    return int((n**2*sin(sqrt(n))).round()) \n"}
{"sequence_id": "A274090", "text": "a(n) = nearest integer to n^2 * cos(sqrt(n)).", "sequence": "0,1,1,-1,-7,-15,-28,-43,-61,-80,-100,-119,-137,-151,-162,-167,-167,-161,-147,-125,-95,-57,-11,44,107,177,255,339,429,524,623,725,830,935,1040,1143,1244,1342,1434,1520,1599,1669,1730,1780,1819,1845,1858,1857,1841,1810,1763,1700,1621,1525", "code": "\nfrom sympy import cos, sqrt\ndef A274090(n):\n    return int((n**2*cos(sqrt(n))).round()) \n"}
{"sequence_id": "A274091", "text": "Take alternate terms of A274088 and A274090.", "sequence": "0,0,1,1,4,1,9,-1,15,-7,20,-15,23,-28,23,-43,20,-61,11,-80,-2,-100,-21,-119,-46,-137,-76,-151,-111,-162,-150,-167,-194,-167,-240,-161,-289,-147,-339,-125,-389,-95,-437,-57,-484,-11,-527,44,-566,107,-599,177,-626,255,-645,339,-656,429,-658,524", "code": "\nfrom sympy import sin, sqrt, pi\ndef f(n, t = 1):\n    k, j = divmod(n,t)\n    return int((k**2*sin(sqrt(k)+j*pi/2)).round())\nA274091_list = [f(n,2) for n in range(10001)] \n"}
{"sequence_id": "A274092", "text": "a(n) = nearest integer to k^2*sin(sqrt(k)+j*Pi/2) where n = 3*k+j, 0<=j<3.", "sequence": "0,0,0,1,1,-1,4,1,-4,9,-1,-9,15,-7,-15,20,-15,-20,23,-28,-23,23,-43,-23,20,-61,-20,11,-80,-11,-2,-100,2,-21,-119,21,-46,-137,46,-76,-151,76,-111,-162,111,-150,-167,150,-194,-167,194,-240,-161,240,-289,-147,289,-339,-125,339,-389,-95,389", "code": "\nfrom sympy import sin, sqrt, pi\ndef A274092(n):\n    k, j = divmod(n,3)\n    return int((k**2*sin(sqrt(k)+j*pi/2)).round()) \n"}
{"sequence_id": "A274093", "text": "a(0)=0; thereafter (-1)^n*n appears n times.", "sequence": "0,-1,2,2,-3,-3,-3,4,4,4,4,-5,-5,-5,-5,-5,6,6,6,6,6,6,-7,-7,-7,-7,-7,-7,-7,8,8,8,8,8,8,8,8,-9,-9,-9,-9,-9,-9,-9,-9,-9,10,10,10,10,10,10,10,10,10,10,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,12,12,12,12,12,12,12,12,12,12,12", "code": "\nA274093_list = [0]+ [i for n in range(1,142) for i in [-n if n % 2 else n]*n] \n"}
{"sequence_id": "A274094", "text": "a(0)=0; thereafter (-1)^(n+1)*n appears n times.", "sequence": "0,1,-2,-2,3,3,3,-4,-4,-4,-4,5,5,5,5,5,-6,-6,-6,-6,-6,-6,7,7,7,7,7,7,7,-8,-8,-8,-8,-8,-8,-8,-8,9,9,9,9,9,9,9,9,9,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,11,11,11,11,11,11,11,11,11,11,11,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12", "code": "\nA274094_list = [0]+ [i for n in range(1,142) for i in [n if n % 2 else -n]*n] \n"}
{"sequence_id": "A274095", "text": "Nearest integer to n*sin(sqrt(n)).", "sequence": "0,1,2,3,4,4,4,3,2,1,0,-2,-4,-6,-8,-10,-12,-14,-16,-18,-19,-21,-22,-23,-24,-24,-24,-24,-23,-23,-22,-20,-19,-17,-15,-13,-10,-7,-5,-1,2,5,8,12,15,19,22,25,29,32,35,39,42,45,47,50,52,54,56,58,60,61,62,63,63,64,64,63,63,62,61,60,58,56", "code": "\nfrom sympy import sin, sqrt, pi\ndef A274095(n, t = 1):\n    k, j = divmod(n,t)\n    return int((k*sin(sqrt(k)+j*pi/2)).round())\nA274095_list = [A274095(n,1) for n in range(10001)] \n"}
{"sequence_id": "A274097", "text": "a(n) = nearest integer to k*sin(sqrt(k)+j*Pi/2) where n = 3*k+j, 0<=j<3.", "sequence": "0,0,0,1,1,-1,2,0,-2,3,0,-3,4,-2,-4,4,-3,-4,4,-5,-4,3,-6,-3,2,-8,-2,1,-9,-1,0,-10,0,-2,-11,2,-4,-11,4,-6,-12,6,-8,-12,8,-10,-11,10,-12,-10,12,-14,-9,14,-16,-8,16,-18,-7,18,-19,-5,19,-21,-3,21,-22,0,22,-23,2,23,-24,4,24,-24,7", "code": "\nfrom sympy import sin, sqrt, pi\ndef f(n, t = 1):\n    k, j = divmod(n,t)\n    return int((k*sin(sqrt(k)+j*pi/2)).round())\nA274097_list = [f(n,3) for n in range(10001)] \n"}
{"sequence_id": "A274117", "text": "a(n) = ((6n-5)!!!+(6n-4)!!!)/(6n-3).", "sequence": "1,12,1064,252160,115315200,86449126400,96313245952000,149342026677043200,307513455044956160000,811744577542368870400000,2672529840751688498380800000,10735527449319396895332761600000,51677469466519591978527317032960000,293652804750537765304678163152896000000", "code": "\ntriplefac=lambda x:1 if x<2 else x*triplefac(x-3)\nfor i in range(1,101):\n    print(i,(triplefac(6*i-5)+triplefac(6*i-4))//(6*i-3))\n"}
{"sequence_id": "A274119", "text": "a(n) = (Product_{i=0..4}(i*n+2) - Product_{i=0..4}(-i*n-1))/(4*n+3).", "sequence": "11,120,435,1064,2115,3696,5915,8880,12699,17480,23331,30360,38675,48384,59595,72416,86955,103320,121619,141960,164451,189200,216315,245904,278075,312936,350595,391160,434739,481440,531371,584640", "code": "\n\ndef B (n,k,a,b):\n    pa = pb = 1\n    for i in range(n+1):\n        pa *= (i*k+a)\n        pb *= (-i*k-b)\n    m = n*k+a+b\n    p = pa-pb\n    if m == 0:\n        return \"NaN\"\n    else:\n        return p/m\n\nfor j in range(101):\n    print(str(j)+\" \"+str(B(4,j,2,1)))  \n"}
{"sequence_id": "A274134", "text": "Primes p such that both ror(p) and rol(p) are also primes, where ror(x)=A038572(x) is x rotated one binary place to the right, rol(x)=A006257(x) is x rotated one binary place to the left.", "sequence": "3,7,11,31,43,67,79,127,131,139,167,191,211,223,227,307,331,367,487,523,631,691,743,751,883,971,1039,1087,1399,2063,2083,2143,2179,2239,2267,2287,2347,2411,2423,2503,2531,2543,2591,2687,2731,2803,2819,2927,2939,2963", "code": "\nfrom sympy import isprime\nfor n in range(3, 10000, 2):\n    if not isprime(n): continue\n    BL = len(bin(n))-2\n    x = (n>>1) + ((n&1) << (BL-1))   \n    if not isprime(x): continue\n    y = (n*2) - (1<<BL) + 1   \n    if not isprime(y): continue\n    print str(n)+',',\n"}
{"sequence_id": "A274136", "text": "a(n) = (n+1)*(2*n+2)!/(n+2).", "sequence": "1,16,540,32256,3024000,410572800,76281004800,18598035456000,5762136335155200,2211729098342400000,1030334000462807040000,572721601599913328640000,374484928188990947328000000,284562454970932936468070400000", "code": "\n\ndef B (n, k, a, b):\n    pa = pb = 1\n    for i in range(n+1):\n        pa *= (i*k+a)\n        pb *= (-i*k-b)\n    m = n*k+a+b\n    p = pa-pb\n    if m == 0:\n        return \"NaN\"\n    else:\n        return p/m\n\nfor j in range(101):\n    print(str(j)+\" \"+str(B(2*j+1, 1, 2, 1)))  \n"}
{"sequence_id": "A274181", "text": "Decimal expansion of Phi(1/2, 2, 2), where Phi is the Lerch transcendent.", "sequence": "3,2,8,9,6,2,1,0,5,8,6,0,0,5,0,0,2,3,6,1,0,6,2,5,2,8,0,6,3,8,7,2,0,4,3,4,9,7,6,7,9,3,8,9,9,2,2,4,5,0,5,7,0,1,7,3,7,3,8,8,1,9,1,4,9,2,6,8,4,1,7,6,2,8,6,7,3,2,8,0,3,2,6,7,3,6,1,2,7,4,3,5,1,6,6,3,4,2,8,7,4", "code": "\nfrom mpmath import mp, lerchphi\nmp.dps=102\nprint([int(d) for d in list(str(lerchphi(1/2, 2, 2))[2:-1])]) \n"}
{"sequence_id": "A274213", "text": "Meta recurrence: a(0) = 1, a(1) = 2, a(2) = 3, a(n) = a(n - a(n-3)) + 3 for n > 2.", "sequence": "1,2,3,6,6,6,4,5,6,9,9,9,9,9,9,7,8,9,12,12,12,12,12,12,12,12,12,10,11,12,15,15,15,15,15,15,15,15,15,15,15,15,13,14,15,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,16,17,18,21,21,21,21,21,21,21", "code": "\nA274213_list = [1,2,3]\nfor n in range(3,10001):\n    A274213_list.append(A274213_list[-A274213_list[-3]]+3)\n"}
{"sequence_id": "A274368", "text": "Numbers n such that if n is decreased by the sum of its digits and n is decreased by the product of its digits both differences are squares > 0.", "sequence": "45,48,231,121116,159229,11985489,17514256,51624256,88172137,228523729,467597425,11112111412,4329279198937,3716589421762641,23228676113127556,138417183479417732388", "code": "\ndef pod(n):\n    p = 1\n    for x in str(n):\n        p *= int(x)\n    return p\ndef sod(n):\n    return (sum(int(d) for d in str(n))\ndef cube(z,p):\n    iscube=False\n    y=int(pow(z,1/p)+0.01)\n    if y**p==z:\n        iscube=True\n    return iscube\nfor c in range (1, 10**8):\n    aa,ab=c-pod(c,10),c-sod(c,10)\n    if cube(aa,2)==True and cube(ab,2)==True and aa>0:\n       print (c,aa,ab)\n"}
{"sequence_id": "A274369", "text": "Let the starting square of Langton's ant have coordinates (0, 0), with the ant looking in negative x-direction. a(n) is the x-coordinate of the ant after n moves.", "sequence": "0,0,1,1,0,0,-1,-1,0,0,1,1,0,0,1,1,0,0,1,1,2,2,1,1,2,2,3,3,2,2,1,1,2,2,3,3,4,4,3,3,2,2,3,3,2,2,3,3,2,2,1,1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,-2,-2,-1,-1,-2,-2,-3,-3,-2,-2,-1,-1,-2,-2,-3", "code": "\n\ndef ant(n):\n    steps = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    black = set()\n    x = y = 0\n    position = [(x, y)]\n    direction = 2\n    for _ in range(n):\n        if (x, y) in black:\n            black.remove((x, y))\n            direction += 1\n        else:\n            black.add((x, y))\n            direction -= 1\n        (dx, dy) = steps[direction%4]\n        x += dx\n        y += dy\n        position.append((x, y))\n    return position\nprint([p[0] for p in ant(100)])\n\n"}
{"sequence_id": "A274383", "text": "a(n) is the least m such that A008284(m,n+1) > A008284(m,n).", "sequence": "4,7,10,15,18,23,29,35,40,47,54,60,68,75,83,90,99,107,116,125,134,143,152,162,172,182,193,203,214,225,236,248,259,271,283,295,307,320,332,345,358,372,385,398,412,426,440,454,469,483,498,513,528,543,559,574,590,606,622,638,654,671,688,704", "code": "\nelement = 1\ngoal = 64\nn = 1\np = [[]]\nwhile element <= goal:\n    \n    p.append([0]*(goal+2))\nfor k in range(1, min(n,goal+1)+1):\n        if (k == 1) or (k == n):\n            p[n][k] = 1\n        else:\n            p[n][k] = p[n-1][k-1] + p[n-k][k]\n      \n    if p[n][element+1] > p[n][element]:\n        print \"p[{}][{}]={} and p[{}][{}]={} so a[{}] = {}\".format(\n            n,element,p[n][element],n,element+1,p[n][element+1],element,n)\n        element = element+1\n    n = n+1\n"}
{"sequence_id": "A274519", "text": "Numbers k for which 4^k - 27 is prime.", "sequence": "3,4,5,10,11,13,25,28,29,65,70,115,305,515,2029,2393,2605,3530,4036,4750,10288,11048,11596", "code": "\nfrom sympy import isprime\ndef afind(limit, startk=3):\n    alst, pow4 = [], 4**startk\n    for k in range(startk, limit+1):\n        if isprime(pow4 - 27): print(k, end=\", \")\n        pow4 *= 4\nafind(600) \n"}
{"sequence_id": "A274601", "text": "a(n) = 2*3^(s-1) - n, where s is the number of trits of n in balanced ternary form.", "sequence": "1,4,3,2,13,12,11,10,9,8,7,6,5,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,121,120,119,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101,100", "code": "\nfrom sympy import log, floor\ndef a(n): return 2*3**(floor(log(2*n - 1, 3))) - n\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A274647", "text": "A variation on Recam\u00e1n's sequence (A005132): to get a(n), we first try to subtract n from a(n-1): a(n) = a(n-1)-n if positive and not already in the sequence; if not then we try to add n: a(n) = a(n-1)+n if not already in the sequence; if this fails we try to subtract 2n from a(n-1), or to add 2n to a(n-1), or to subtract 3n, or to add 3n, etc., until one of these produces a positive number not already in the sequence.", "sequence": "0,1,3,6,2,7,13,20,12,21,11,22,10,23,9,24,8,25,43,62,42,63,41,18,66,91,65,38,94,123,93,124,92,59,127,162,126,89,51,90,50,132,174,131,87,177,223,176,128,79,29,80,28,81,27,82,26,83,141,200,140,201,139", "code": "\nl=[0]\nfor n in range(1, 101):\n    i=1\n    while True:\n        a=l[n - 1]\n        x=a - i*n\n        if x>0 and x not in l:\n            l.append(x)\n            break\n        y=a + i*n\n        if y>0 and not y in l:\n            l.append(y)\n            break\n        else : i+=1\nprint(l) \n"}
{"sequence_id": "A274649", "text": "a(n) is the smallest odd prime that divides n + the sum of all smaller primes, or 0 if no such prime exists.", "sequence": "5,3,30915397,11339869,3,5,859,3,41,233,3,7,4175194313,3,307,5,3,1459,7,3,5,9907,3,647,13,3,31,11,3,193,5,3,7,2939,3,5,3167,3,11,7,3,1321,86629,3,17,5,3", "code": " \nfrom sympy import nextprime\ndef a(n):\n  psum, p = 2, 3\n  while (n + psum)%p: psum, p = psum + p, nextprime(p)\n  return p\nfor n in range(12):\n  print(a(n), end=\", \") \n"}
{"sequence_id": "A274765", "text": "Cyclops numbers with circular digits {0,6,8,9}.", "sequence": "0,606,608,609,806,808,809,906,908,909,66066,66068,66069,66086,66088,66089,66096,66098,66099,68066,68068,68069,68086,68088,68089,68096,68098,68099,69066,69068,69069,69086,69088,69089,69096,69098,69099,86066,86068,86069,86086,86088,86089,86096,86098,86099", "code": "\nimport sys\nf = open('b274765.txt', 'w')\ni = 1\nn = 0\na = [\"\"]\nwhile True:\n....for x in a:\n........for y in a:\n............f.write(str(i)+\" \"+x+\"0\"+y+\"\\n\")\n............i += 1\n............if i>20000:\n................f.close()\n................sys.exit()\n....a = sum([[x+\"6\",x+\"8\",x+\"9\"] for x in a],[])\n\n"}
{"sequence_id": "A274944", "text": "Numbers with at least three digits and with the property that the sum of the squares of the first and last digits equals the number obtained when the first and last digits are deleted.", "sequence": "110,121,152,240,251,282,390,1103,1174,1265,1376,1507,1658,1829,2133,2204,2295,2406,2537,2688,2859,3101,3132,3183,3254,3345,3456,3587,3738,3909,4160,4171,4202,4253,4324,4415,4526,4657,4808,4979,5250,5261,5292,5343,5414,5505,5616", "code": "\nA274944_list = [j*10**(i+1)+10*(j**2+k**2)+k for i in range(1,4) for j in range(1,10) for k in range(10) if 10**(i-1) <= j**2+k**2 < 10**i] \n"}
{"sequence_id": "A274944", "text": "Numbers with at least three digits and with the property that the sum of the squares of the first and last digits equals the number obtained when the first and last digits are deleted.", "sequence": "110,121,152,240,251,282,390,1103,1174,1265,1376,1507,1658,1829,2133,2204,2295,2406,2537,2688,2859,3101,3132,3183,3254,3345,3456,3587,3738,3909,4160,4171,4202,4253,4324,4415,4526,4657,4808,4979,5250,5261,5292,5343,5414,5505,5616", "code": "\nA274944_list = sorted([int(str(i)+str(i**2+j**2)+str(j)) for i in range(1,10) for j in range(10)]) \n"}
{"sequence_id": "A274945", "text": "The Staircase Sequence: numbers with at least three digits and with the property that the sum of the squares of the first and last digits equals the number obtained when the first and last digits are deleted.", "sequence": "110,121,152,240,251,282,390,1010,1021,1052,1103,1174,1265,1376,1507,1658,1829,2040,2051,2082,2133,2204,2295,2406,2537,2688,2859,3090,3101,3132,3183,3254,3345,3456,3587,3738,3909,4160,4171,4202,4253,4324,4415,4526,4657,4808,4979,5250,5261,5292,5343,5414,5505,5616", "code": "\nA274945_list = [j*10**(i+1)+10*(j**2+k**2)+k for i in range(1,10) for j in range(1,10) for k in range(10) if j**2+k**2 < 10**i] \n"}
{"sequence_id": "A274951", "text": "Pisot sequence E(8,12), a(n) = floor( a(n-1)^2/a(n-2) + 1/2 ).", "sequence": "8,12,18,27,41,62,94,143,218,332,506,771,1175,1791,2730,4161,6342,9666,14732,22453,34221,52157,79494,121159,184662,281449,428965,653799,996476,1518761,2314792,3528048,5377210,8195577,12491140,19038144,29016641,44225186,67405013,102734125,156580349", "code": "\na, b = 8, 12\nA274951_list = [a, b]\nfor i in range(1000):\n    c, d = divmod(b**2, a)\n    a, b = b, c + (0 if 2*d < a else 1)\n    A274951_list.append(b) \n"}
{"sequence_id": "A274962", "text": "Numbers n such that sigma(n) and sigma(n) + 2 are both primes.", "sequence": "2,2401,19356878641,46904541018721,119601542190001,360371335935601,16472757578830081,26835157974988801,59879777952495601,147669280778756881,170589096345900241,219660193449998401,1103765757989399761,1515946818108402241,2044393722679974961,2608728003079029841,2805689752523610241,3071293995460971361,4537323492222149281,9583348094642219041,9982134924573725761", "code": "\nfrom sympy import isprime, divisor_sigma\nA274962_list = [2]+[n for n, s in ((d**2, divisor_sigma(d**2)) for d in range(1,10**3)) if isprime(s) and isprime(s+2)] \n"}
{"sequence_id": "A274963", "text": "Numbers n such that both sigma(n) and sigma(n) - 2 are primes.", "sequence": "4,9,16,25,729,1681,3481,7921,10201,17161,552049,579121,1423249,5812921,7091569,7447441,9066121,9765625,10374841,10569001,11895601,22572001,38105929,43546801,46689889,52258441,75151561,82065481,86918329,90649441,94458961,94926049", "code": "\nfrom sympy import isprime, divisor_sigma\nA274963_list = [n for n, s in ((d**2, divisor_sigma(d**2)) for d in range(1,10**3)) if isprime(s) and isprime(s-2)] \n"}
{"sequence_id": "A274967", "text": "Odd composite numbers n which are not m-gonal number for 3 <= m < n.", "sequence": "77,119,143,161,187,203,209,221,299,319,323,329,371,377,391,407,413,437,473,493,497,517,527,533,539,551,581,583,589,611,623,629,649,667,689,707,713,731,737,749,767,779,791,799,803,817,851,869,893,899,901,913", "code": "\nfrom sympy import isprime\nA274967_list = []\nfor n in range(3,10**6,2):\n    if not isprime(n):\n        k = 3\n        while k*(k+1) <= 2*n:\n            if not (2*(k*(k-2)+n)) % (k*(k - 1)):\n                break\n            k += 1\n        else:\n            A274967_list.append(n) \n"}
{"sequence_id": "A274968", "text": "Even numbers n >= 4 which are not m-gonal number for 3 <= m < n.", "sequence": "4,8,14,20,26,32,38,44,50,56,62,68,74,80,86,98,104,110,116,122,128,134,140,146,152,158,164,170,182,188,194,200,206,212,218,224,230,236,242,248,254,266,272,278,284,290,296,302", "code": "\nA274968_list = []\nfor n in range(4,10**6,2):\n    k = 3\n    while k*(k+1) <= 2*n:\n        if not (2*(k*(k-2)+n)) % (k*(k - 1)):\n            break\n        k += 1\n    else:\n        A274968_list.append(n) \n"}
{"sequence_id": "A274998", "text": "Expansion of Product_{k>=1} 1/(1 - x^k)^(k*(3*k-2)).", "sequence": "1,1,9,30,106,339,1106,3355,10102,29358,83908,234394,644286,1739933,4631675,12153197,31485413,80576160,203902261,510490213,1265353568,3106771717,7559844833,18239351931,43650061720,103657177941,244346681972,571930478187,1329655624297,3071230379625,7049750442386,16085170634548,36489192684910", "code": "\nfrom sympy import divisors\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n): return 1 if n==0 else sum(sum(d**2*(3*d - 2) for d in divisors(j))*a(n - j) for j in range(1, n + 1))//n\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A275018", "text": "a(n) = A278846(n)/8.", "sequence": "0,0,0,0,0,1,1,5,6,10,11,19,20,29,33,38,43,56,60,76,81,90,98,118,121,138,147,163,172,197,202,230,243,260,273,294,303,336,352,373,384,421,430,470,487,508,528,572,583,623,640", "code": "\ndef t(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            for c in range(0,n+1):\n                for d in range(0,n+1):\n                    if (a!=b  and a!=d and b!=d and c!=a and c!=b and c!=d):\n                        if abs(a*d-b*c)==1:\n                            s+=1\n    return s\nfor i in range(0,201):\n    print str(i)+\" \"+str(t(i)/8) \\\\ _Indranil Ghosh_, Nov 30, 2016.\n"}
{"sequence_id": "A275078", "text": "Triangle read by rows in which row n lists the lexicographic composition of the elements of symmetric group S_n.", "sequence": "1,2,1,2,1,3,3,4,1,2,2,4,1,5,3,5,4,2,6,1,3,4,7,5,1,3,2,6,8,1,2,3,4,7,6,5,6,9,2,1,7,8,5,4,3,2,8,9,4,6,7,10,5,1,3,5,1,6,10,8,11,9,2,7,3,4,7,1,9,5,6,2,12,4,8,11,10,3", "code": "\nfrom itertools import count, permutations\nfor size in count(1):\n    row = tuple(range(1, size + 1))\n    for p in permutations(range(size)):\n        row = tuple(row[i] for i in p)\n    print(row)\n"}
{"sequence_id": "A275111", "text": "a(n) = prime(n)! mod prime(n+1).", "sequence": "2,1,1,2,1,3,1,4,22,1,33,7,1,8,19,30,1,43,12,1,27,14,23,24,17,1,18,1,19,19,22,8,1,94,1,140,72,28,62,91,1,105,1,33,1,177,97,38,1,39,2,1,19,15,160,204,1,247,47,1,291,299,52,1,53,198,132,55,1,59,3,176", "code": "\nfrom sympy import prime\nfrom sympy.core.numbers import igcdex\ndef A275111(n):\n    p, q = prime(n), prime(n+1)\n    a = q-1\n    for i in range(p+1,q):\n        a = (a*igcdex(i,q)[0]) % q\n    return a \n"}
{"sequence_id": "A275122", "text": "Pascal's hexagonal pyramid, read by slices, with each slice read by rows.", "sequence": "1,1,1,1,1,1,1,1,1,2,1,2,4,4,2,1,4,7,4,1,2,4,4,2,1,2,1,1,3,3,1,3,9,12,9,3,3,12,24,24,12,3,1,9,24,31,24,9,1,3,12,24,24,12,3,3,9,12,9,3,1,3,3,1", "code": "\nimport numpy as np\n\nnumLayers = 22\n\n\nwidth = numLayers*2\n\nneighbors = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2], [2, 1], [2, 2]]\n\nterms = np.zeros((numLayers, width, width))\n\nterms[0][0][0] = 1\n\nfor l in range(1, numLayers):\n  for x in range(width):\n    for y in range(width):\n      for n in neighbors:\n        terms[l][x][y] += terms[l-1][x-n[0]][y-n[1]]\n\nseq = terms.flatten().tolist()\n\nwhile 0 in seq:\n  seq.remove(0)\n\nfor s in range(len(seq)):\n  seq[s] = int(seq[s])\n\nfinal = \"\"\nfor s in range(len(seq)):\n  final += str(s+1)+\" \"+str(seq[s])+\"\\n\"\n\nbfile = open(\"b275122.txt\", \"w\")\nbfile.write(final)\nbfile.close()\n\n"}
{"sequence_id": "A275256", "text": "Numbers with a minimum of 6 polygonal roots, excluding itself.", "sequence": "1225,1540,2926,4005,5985,8856,9045,9801,11781,11935,12376,12496,12720,13041,14400,16401,17200,17226,17290,17865,18096,21528,21736,23001,23751,24220,24976,25425,26796,27000,27405,27951,29241,29316,29601,29646,30976,31465,31536", "code": "\nA275256_list = []\nfor m in range(2,10**5):\n    n, c = 3, 0\n    while (n*(n+1)) <= 2*m:\n        if not 2*(n*(n-2) + m) % (n*(n - 1)):\n            c += 1\n            if c >= 6:\n                break\n        n += 1\n    if c >= 6:\n        A275256_list.append(m) \n"}
{"sequence_id": "A275388", "text": "Convolution of Fibonacci numbers (A000045) and partition numbers (A000041).", "sequence": "0,1,2,5,10,20,37,68,120,210,360,612,1028,1717,2846,4698,7720,12649,20666,33700,54856,89183,144831,235016,381102,617693,1000753,1620882,2624645,4249245,6878455,11133304,18018601,29160254,47188998,76361562,123565443,199944982", "code": "\nfrom sympy import fibonacci, npartitions\ndef a(n): return sum([fibonacci(k)*npartitions(n - k) for k in range(1, n + 1)])\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A275392", "text": "Smallest term in the tribonacci Zeckendorf representation of n.", "sequence": "1,2,1,4,1,2,7,1,2,1,4,1,13,1,2,1,4,1,2,7,1,2,1,24,1,2,1,4,1,2,7,1,2,1,4,1,13,1,2,1,4,1,2,44,1,2,1,4,1,2,7,1,2,1,4,1,13,1,2,1,4,1,2,7,1,2,1,24,1,2,1,4,1,2,7,1,2,1,4,1,81,1,2,1,4,1,2,7,1,2,1,4,1,13,1,2,1,4,1,2,7,1,2,1", "code": "\ntribonacci = [0, 0, 1]\nseq = []\nnumTerms = 100\nwhile tribonacci[-1] < numTerms:\n  tribonacci.append(tribonacci[-1]+tribonacci[-2]+tribonacci[-3])\ntribonacci = tribonacci[3:]\ntribonacci.reverse()\nfor n in range(1, numTerms):\n  tmp = n\n  smallestTerm = 0\n  for place in tribonacci:\n    if tmp >= place:\n      tmp -= place\n      smallestTerm = place\n  seq.append(str(n)+\" \"+str(smallestTerm))\nprint('\\n'.join(seq))\n"}
{"sequence_id": "A275465", "text": "a(n) = f^(n/f), where f is the smallest prime factor of n.", "sequence": "2,3,4,5,8,7,16,27,32,11,64,13,128,243,256,17,512,19,1024,2187,2048,23,4096,3125,8192,19683,16384,29,32768,31,65536,177147,131072,78125,262144,37,524288,1594323,1048576,41,2097152,43,4194304,14348907,8388608,47,16777216", "code": "\nfrom __future__ import division\nfrom sympy import primefactors\ndef A275465(n):\n    p = min(primefactors(n))\n    return p**(n//p) \n"}
{"sequence_id": "A275481", "text": "n appears once in c_{m,k} for integers m >= k >= 1 where c_{m,k} = ((n+k)!(n-k+1))/((k)!(n+1)!).", "sequence": "3,4,6,7,8,10,11,12,13,15,16,17,18,19,21,22,23,24,25,26,29,30,31,32,33,34,36,37,38,39,40,41,43,45,46,47,49,50,51,52,53,55,56,57,58,59,60,61,62,63,64,66,67,68,69,70,71,72,73,74,76,78,79,80,81,82,83,84,85", "code": "\n\ndef Unique_Catalan_Triangle(k):\n    t = []\n    t.append([])\n    t[0].append(1)\n    for h in range(1, k):\n        t.append([])\n        t[0].append(1)\n    for i in range(1, k):\n        for j in range(0, k):\n            if i>j:\n                t[i].append(0)\n            else:\n                t[i].append(t[i-1][j] + t[i][j-1])\n    l = []\n    for r in range(0, k):\n        for s in range(0, k):\n            l.append(t[r][s])\n    unique = []\n    for n in l:\n        if n <= k and l.count(n) == 1 :\n            unique.append(n)\n    print sorted(unique)\n"}
{"sequence_id": "A275530", "text": "Smallest positive integer m such that (m^(2^n) + 1)/2 is prime.", "sequence": "3,3,3,9,3,3,3,113,331,513,827,799,3291,5041,71,220221,23891,11559", "code": "\nfrom sympy import isprime\ndef a(n):\n  m, pow2 = 1, 2**n\n  while True:\n    if isprime((m**pow2 + 1)//2): return m\n    m += 2\nprint([a(n) for n in range(9)]) \n"}
{"sequence_id": "A275544", "text": "Number of distinct terms at a given iteration of the Collatz (or 3x+1) map starting with 0.", "sequence": "1,2,4,8,15,29,56,108,208,400,766,1465,2793,5314,10088,19115,36156,68290,128817,242720,456884,859269,1614809,3032673,5692145,10678326,20023239,37531218,70323203,131725663,246674211", "code": "\nx = [0]\nfor i in range(n):\n    x_tmp = []\n    for s in x:\n        x_tmp.append(3*s+1)\n        x_tmp.append(s*0.5)\n    x = x_tmp\n    x = list(set(x))\n    print len(x)\n"}
{"sequence_id": "A275544", "text": "Number of distinct terms at a given iteration of the Collatz (or 3x+1) map starting with 0.", "sequence": "1,2,4,8,15,29,56,108,208,400,766,1465,2793,5314,10088,19115,36156,68290,128817,242720,456884,859269,1614809,3032673,5692145,10678326,20023239,37531218,70323203,131725663,246674211", "code": "\nfrom fractions import Fraction\nA275544_list, c = [1], [Fraction(0,1)]\nfor _ in range(20):\n    c = set(e for d in c for e in (3*d+1,d/2))\n    A275544_list.append(len(c)) \n"}
{"sequence_id": "A275545", "text": "Number of new duplicate terms at a given iteration of the Collatz (or 3x+1) map starting with 0.", "sequence": "0,0,0,0,1,1,2,4,8,16,34,67,137,272,540,1061,2074,4022,7763,14914,28556,54499,103729,196945,373201,705964,1333413,2515298,4739834,8926089", "code": "\nx = [0]\nfor i in range(n):\n    x_tmp = []\n    for s in x:\n        x_tmp.append(3*s+1)\n        x_tmp.append(s*0.5)\n    x = x_tmp\n    length_tmp = len(x)\n    x = list(set(x))\n    print length_tmp-len(x)\n"}
{"sequence_id": "A275573", "text": "Consider the function G(n) that adds to n a decimal part equal to the reverse of n. Sequence lists integers that are equal to Sum_{i=1..k}{G(i)} for some k.", "sequence": "11,1386327162,1644167162,98457031244,138632716794,164416716794,215332031244,3164184570305,9845703124994,13863271679994,16441671679994,21533203124994,35992309570305,984570312499994,1386327167999994,1644167167999994,2153320312499994,80783157348632805,98457031249999994,138632716799999994,164416716799999994,215332031249999994,243634719848632805", "code": "\nfrom __future__ import division\nfrom fractions import Fraction\nA275573_list, q = [], 0\nfor i in range(1,10**6):\n    q += Fraction(int(str(i)[::-1]),10**len(str(i)))\n    if q.denominator == 1:\n        A275573_list.append(q + i*(i+1)//2) \n"}
{"sequence_id": "A275586", "text": "Numbers k that appear more than once in c_{m,n} for integers m >= n >= 1 where c_{m,n} = ((m+n)!(m-n+1))/((n)!(m+1)!).", "sequence": "1,2,5,9,14,20,27,28,35,42,44,48,54,65,75,77,90,104,110,119,132,135,152,154,165,170,189,208,209,230,252,273,275,297,299,324,350,377,405,429,434,440,464,495,527,544,560,572,594,629,637,663,665,702,740,779,798,819,860,902,910,945,950,989", "code": "\ndef remove_duplicates(values):\n    output = []\n    seen = set()\n    for value in values:\n        if value not in seen:\n            output.append(value)\n            seen.add(value)\n    return output\ndef Non_Unique_Catalan_Triangle(k):\n    t = []\n    t.append([])\n    t[0].append(1)\n    for h in range(1, k):\n        t.append([])\n        t[0].append(1)\n    for i in range(1, k):\n        for j in range(0, k):\n            if i>j:\n                t[i].append(0)\n            else:\n                t[i].append(t[i-1][j] + t[i][j-1])\n    l = []\n    for r in range(0, k):\n        for s in range(0, k):\n            l.append(t[r][s])\n    non_unique = []\n    for n in l:\n        if  n <= k and n>1 and l.count(n) > 1:\n            non_unique.append(n)\n    non_unique = remove_duplicates(non_unique)\n    print (non_unique)\n"}
{"sequence_id": "A275600", "text": "Numbers that can be written in all bases from base 2 to base 6 using only the digits 0, 1 and 2.", "sequence": "0,1,2,6,36,37,260,1302,1376,1380,1381,1382,1556,1560,1561,1562,16932,562500,562501,562502,562506,562512,562536,562537,562752,562760,23610752,23610756,23610757,23610786,23615750,23615760,23615761,23615762,23615785,23615786,23626310", "code": " from gmpy2 import digits\nA275600_list = [n for n in (int(digits(m,3),6) for m in range(10**6)) if max(digits(n,5)) <= '2' and max(digits(n,4)) <= '2'] \n"}
{"sequence_id": "A275628", "text": "Pisot sequence E(31,51), a(n)=[a(n-1)^2/a(n-2)+1/2].", "sequence": "31,51,84,138,227,373,613,1007,1654,2717,4463,7331,12042,19780,32490,53367,87659,143986,236507,388479,638103,1048127,1721619,2827875,4644975,7629684,12532269,20585095,33812403,55539146,91226783,149846127,246132342,404288926,664071752,1090782516", "code": "\na, b = 31, 51\nA275628_list = [a, b]\nfor i in range(1000):\n    c, d = divmod(b**2, a)\n    a, b = b, c + (0 if 2*d < a else 1)\n    A275628_list.append(b) \n"}
{"sequence_id": "A275709", "text": "a(n) = 2*n^3 + 3*n^2.", "sequence": "0,5,28,81,176,325,540,833,1216,1701,2300,3025,3888,4901,6076,7425,8960,10693,12636,14801,17200,19845,22748,25921,29376,33125,37180,41553,46256,51301,56700,62465,68608,75141,82076,89425,97200,105413,114076,123201,132800,142885", "code": " for n in range(0,50): print(n**2*(2*n+3), end=' ') \n"}
{"sequence_id": "A275732", "text": "One-based positions of 1-digits in the factorial base representation of n are converted to primes with those indices, then multiplied together.", "sequence": "1,2,3,6,1,2,5,10,15,30,5,10,1,2,3,6,1,2,1,2,3,6,1,2,7,14,21,42,7,14,35,70,105,210,35,70,7,14,21,42,7,14,7,14,21,42,7,14,1,2,3,6,1,2,5,10,15,30,5,10,1,2,3,6,1,2,1,2,3,6,1,2,1,2,3,6,1,2,5,10,15,30,5,10,1,2,3,6,1,2,1,2,3,6,1,2,1,2,3,6,1,2,5,10,15,30", "code": "\nfrom operator import mul\nfrom sympy import prime\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a(n):\n    x=str(a007623(n))[::-1]\n    return 1 if n==0 or \"1\" not in x else reduce(mul, [prime(i + 1) for i in range(len(x)) if x[i]=='1'])\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A275734", "text": "Prime-factorization representations of \"factorial base slope polynomials\": a(0) = 1; for n >= 1, a(n) = A275732(n) * a(A257684(n)).", "sequence": "1,2,3,6,2,4,5,10,15,30,10,20,3,6,9,18,6,12,2,4,6,12,4,8,7,14,21,42,14,28,35,70,105,210,70,140,21,42,63,126,42,84,14,28,42,84,28,56,5,10,15,30,10,20,25,50,75,150,50,100,15,30,45,90,30,60,10,20,30,60,20,40,3,6,9,18,6,12,15,30,45,90,30,60,9,18,27", "code": "\nfrom operator import mul\nfrom sympy import prime, factorial as f\ndef a007623(n, p=2): return n if n<p else a007623(int(n/p), p+1)*10 + n%p\ndef a275732(n):\n    x=str(a007623(n))[::-1]\n    return 1 if n==0 or x.count(\"1\")==0 else reduce(mul, [prime(i + 1) for i in range(len(x)) if x[i]=='1'])\ndef a257684(n):\n    x=str(a007623(n))[:-1]\n    y=\"\".join(str(int(i) - 1) if int(i)>0 else '0' for i in x)[::-1]\n    return 0 if n==1 else sum(int(y[i])*f(i + 1) for i in range(len(y)))\ndef a(n): return 1 if n==0 else a275732(n)*a(a257684(n))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A275735", "text": "Prime-factorization representations of \"factorial base level polynomials\": a(0) = 1; for n >= 1, a(n) = 2^A257511(n) * A003961(a(A257684(n))).", "sequence": "1,2,2,4,3,6,2,4,4,8,6,12,3,6,6,12,9,18,5,10,10,20,15,30,2,4,4,8,6,12,4,8,8,16,12,24,6,12,12,24,18,36,10,20,20,40,30,60,3,6,6,12,9,18,6,12,12,24,18,36,9,18,18,36,27,54,15,30,30,60,45,90,5,10,10,20,15,30,10,20,20,40,30,60,15,30,30,60,45,90,25,50,50,100,75", "code": "\nfrom sympy import prime\nfrom operator import mul\nimport collections\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a(n):\n    y=collections.Counter(map(int, list(str(a007623(n)).replace(\"0\", \"\")))).most_common()\n    return 1 if n==0 else reduce(mul, [prime(y[i][0])**y[i][1] for i in range(len(y))])\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A275767", "text": "Numbers k for which 2*4^k - 27 is prime.", "sequence": "2,3,9,11,291,1263,2661,3165,8973,8999", "code": "\nfrom sympy import isprime\ndef afind(limit, startk=2):\n    alst, pow4 = [], 4**startk\n    for k in range(startk, limit+1):\n        if isprime(2*pow4 - 27): print(k, end=\", \")\n        pow4 *= 4\nafind(1300) \n"}
{"sequence_id": "A275804", "text": "Numbers with at most one nonzero digit on each digit slope of the factorial base representation of n.", "sequence": "0,1,2,3,4,6,7,8,9,10,12,13,16,18,20,24,25,26,27,28,30,31,32,33,34,36,37,40,42,44,48,49,50,51,52,60,61,64,66,68,72,73,76,78,79,82,90,96,98,102,104,108,120,121,122,123,124,126,127,128,129,130,132,133,136,138,140,144,145,146,147,148,150,151,152,153,154,156,157,160", "code": "\nfrom operator import mul\nfrom sympy import prime, factorial as f\nfrom sympy.ntheory.factor_ import core\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a275732(n):\n    x=str(a007623(n))[::-1]\n    return 1 if n==0 or x.count(\"1\")==0 else reduce(mul, [prime(i + 1) for i in range(len(x)) if x[i]=='1'])\ndef a257684(n):\n    x=str(a007623(n))[:-1]\n    y=\"\".join(str(int(i) - 1) if int(i)>0 else '0' for i in x)[::-1]\n    return 0 if n==1 else sum([int(y[i])*f(i + 1) for i in range(len(y))])\ndef a(n): return 1 if n==0 else a275732(n)*a(a257684(n))\ndef ok(n): return 1 if n==0 else core(a(n))==a(n)\nprint([n for n in range(201) if ok(n)]) \n"}
{"sequence_id": "A275805", "text": "Indices of nonsquarefree terms in A275734; numbers with at least one digit slope (in their factorial base representation) with multiple nonzero digits. (See comments for the exact definition).", "sequence": "5,11,14,15,17,19,21,22,23,29,35,38,39,41,43,45,46,47,53,54,55,56,57,58,59,62,63,65,67,69,70,71,74,75,77,80,81,83,84,85,86,87,88,89,91,92,93,94,95,97,99,100,101,103,105,106,107,109,110,111,112,113,114,115,116,117,118,119,125,131,134,135,137,139,141,142,143,149,155", "code": "\nfrom operator import mul\nfrom sympy import prime, factorial as f, mobius\nfrom functools import reduce\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a275732(n):\n    x=str(a007623(n))[::-1]\n    return 1 if n==0 or \"1\" not in x else reduce(mul, [prime(i + 1) for i in range(len(x)) if x[i]=='1'])\ndef a257684(n):\n    x=str(a007623(n))[:-1]\n    y=\"\".join(str(int(i) - 1) if int(i)>0 else '0' for i in x)[::-1]\n    return 0 if n==1 else sum([int(y[i])*f(i + 1) for i in range(len(y))])\ndef a(n): return 1 if n==0 else a275732(n)*a(a257684(n))\nprint([n for n in range(201) if mobius(a(n))==0]) \n"}
{"sequence_id": "A275806", "text": "a(n) = number of distinct nonzero digits in factorial base representation of n.", "sequence": "0,1,1,1,1,2,1,1,1,1,2,2,1,2,2,2,1,2,1,2,2,2,2,3,1,1,1,1,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,3,3,1,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,1,2,2,3,3,3,2,3,1,2,2,2,2,3,2,2,2,2,3,3,2,3,3,3,2,3,1,2,2,2,2,3,1,2,2,2,2,3,2,2,2,2,3,3,2,3,3,3,2,3,2,3,3,3,3,4,1", "code": "\nfrom sympy import prime, primefactors\nfrom operator import mul\nimport collections\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a275735(n):\n    y=collections.Counter(map(int, list(str(a007623(n)).replace(\"0\", \"\")))).most_common()\n    return 1 if n==0 else reduce(mul, [prime(y[i][0])**y[i][1] for i in range(len(y))])\ndef a(n): return len(primefactors(a275735(n)))\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A275811", "text": "Number of nonzero digits on a maximally occupied slope of factorial base representation of n: a(n) = A051903(A275734(n)). See comments for the definition.", "sequence": "0,1,1,1,1,2,1,1,1,1,1,2,1,1,2,2,1,2,1,2,1,2,2,3,1,1,1,1,1,2,1,1,1,1,1,2,1,1,2,2,1,2,1,2,1,2,2,3,1,1,1,1,1,2,2,2,2,2,2,2,1,1,2,2,1,2,1,2,1,2,2,3,1,1,2,2,1,2,1,1,2,2,1,2,2,2,3,3,2,2,1,2,2,2,2,3,1,2,1,2,2,3,1,2,1,2,2,3,1,2,2,2,2,3,2,3,2,3,3,4,1", "code": "\nfrom sympy import prime, factorint\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import factorial as f\ndef a051903(n): return 0 if n==1 else max(factorint(n).values())\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a275732(n):\n    x=str(a007623(n))[::-1]\n    return 1 if n==0 or x.count(\"1\")==0 else reduce(mul, [prime(i + 1) for i in range(len(x)) if x[i]=='1'])\ndef a257684(n):\n    x=str(a007623(n))[:-1]\n    y=\"\".join([str(int(i) - 1) if int(i)>0 else '0' for i in x])[::-1]\n    return 0 if n==1 else sum([int(y[i])*f(i + 1) for i in range(len(y))])\ndef a275734(n): return 1 if n==0 else a275732(n)*a275734(a257684(n))\ndef a(n): return 0 if n==0 else a051903(a275734(n))\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A275812", "text": "Sum of exponents larger than one in the prime factorization of n: A001222(n) - A056169(n).", "sequence": "0,0,0,2,0,0,0,3,2,0,0,2,0,0,0,4,0,2,0,2,0,0,0,3,2,0,3,2,0,0,0,5,0,0,0,4,0,0,0,3,0,0,0,2,2,0,0,4,2,2,0,2,0,3,0,3,0,0,0,2,0,0,2,6,0,0,0,2,0,0,0,5,0,0,2,2,0,0,0,4,4,0,0,2,0,0,0,3,0,2,0,2,0,0,0,5,0,2,2,4,0,0,0,3,0,0,0,5,0,0,0,4,0,0,0,2,2,0,0,3", "code": "\nfrom sympy import factorint, primefactors\ndef a001222(n):\n    return 0 if n==1 else a001222(n//primefactors(n)[0]) + 1\ndef a056169(n):\n    f=factorint(n)\n    return 0 if n==1 else sum(1 for i in f if f[i]==1)\ndef a(n):\n    return a001222(n) - a056169(n)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A275815", "text": "Maximum total number of possible moves that any number of queens of the same color can make on an n X n chessboard.", "sequence": "0,4,17,40,76,128,200,288,392,512,648,800,968,1152,1352,1568,1800,2048,2312,2592,2888,3200,3528,3872,4232,4608,5000,5408,5832,6272,6728,7200", "code": " \n"}
{"sequence_id": "A275948", "text": "Number of nonzero digits that occur only once in factorial base representation of n: a(n) = A056169(A275735(n)).", "sequence": "0,1,1,0,1,2,1,0,0,0,2,1,1,2,2,1,0,1,1,2,2,1,2,3,1,0,0,0,2,1,0,0,0,0,1,1,2,1,1,1,1,0,2,1,1,1,3,2,1,2,2,1,0,1,2,1,1,1,1,0,0,1,1,0,0,1,2,3,3,2,1,2,1,2,2,1,2,3,2,1,1,1,3,2,2,3,3,2,1,2,0,1,1,0,1,2,1,2,2,1,2,3,2,1,1,1,3,2,2,3,3,2,1,2,2,3,3,2,3,4,1", "code": "\nfrom sympy import prime, factorint\nfrom operator import mul\nfrom functools import reduce\nimport collections\ndef a056169(n):\n    f=factorint(n)\n    return 0 if n==1 else sum([1 for i in f if f[i]==1])\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a275735(n):\n    y=collections.Counter(map(int, list(str(a007623(n)).replace(\"0\", \"\")))).most_common()\n    return 1 if n==0 else reduce(mul, [prime(y[i][0])**y[i][1] for i in range(len(y))])\ndef a(n): return a056169(a275735(n))\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A275949", "text": "Number of distinct nonzero digits that occur multiple times in factorial base representation of n: a(n) = A056170(A275735(n)).", "sequence": "0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,2,0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,1,1,2,1,1,1,2,1,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,1,2,1,1,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0", "code": "\nfrom sympy import prime, factorint\nfrom operator import mul\nfrom functools import reduce\nimport collections\ndef a056170(n):\n    f = factorint(n)\n    return sum([1 for i in f if f[i]!=1])\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a275735(n):\n    y=collections.Counter(map(int, list(str(a007623(n)).replace(\"0\", \"\")))).most_common()\n    return 1 if n==0 else reduce(mul, [prime(y[i][0])**y[i][1] for i in range(len(y))])\ndef a(n): return a056170(a275735(n))\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A275959", "text": "Sum of distinct terms of A002674: a(0) = 0, a(2n) = A255411(A153880(a(n))), a(2n+1) = 1+A255411(A153880(a(n))).", "sequence": "0,1,12,13,360,361,372,373,20160,20161,20172,20173,20520,20521,20532,20533,1814400,1814401,1814412,1814413,1814760,1814761,1814772,1814773,1834560,1834561,1834572,1834573,1834920,1834921,1834932,1834933,239500800,239500801,239500812,239500813,239501160,239501161,239501172,239501173,239520960,239520961", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a255411(n):\n    x=(str(a007623(n)) + '0')\n    y=\"\".join(str(int(i) + 1) if int(i)>0 else '0' for i in x)[::-1]\n    return 0 if n==0 else sum([int(y[i])*f(i + 1) for i in range(len(y))])\ndef a153880(n):\n    x=(str(a007623(n)) + '0')[::-1]\n    return 0 if n==0 else sum([int(x[i])*f(i + 1) for i in range(len(x))])\ndef a(n): return 0 if n==0 else a255411(a153880(a(n//2))) if n%2==0 else 1 + a255411(a153880(a((n - 1)//2)))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A275968", "text": "Smaller of two consecutive primes p and q such that c(p) = c(q), where c(n) = A008908(n) is the length of x, f(x), f(f(x)), ... , 1 in the Collatz conjecture.", "sequence": "173,409,419,421,439,487,521,557,571,617,761,887,919,1009,1039,1117,1153,1171,1217,1327,1373,1549,1559,1571,1657,1693,1709,1721,1733,1783,1831,1861,1901,1993,1997,2053,2089,2339,2393,2521,2539,2647,2657,2677,2693,2777", "code": "\nimport sympy\ndef lcs(n):\n....a=1\n....while n>1:\n........if n%2==0:\n............n=n//2\n........else:\n............n=(3*n)+1\n........a=a+1\n....return(a)\nm=2\nwhile m>0:\n....n=sympy.nextprime(m)\n....if lcs(m)==lcs(n):\n........print(m,)\n....m=n\n\n"}
{"sequence_id": "A275971", "text": "Numbers n such that the decimal digits of n^2 are all prime.", "sequence": "5,15,85,165,235,485,1665,1885,4835,5765,7585,15085,15885,16665,18365,18915,22885,27115,27885,50235,57665,58115,72335,85635,87885,150915,166665,182415,194235,194365,229635,240365,268835,503515,507665,524915,568835,570415,577515,581165", "code": "\ndef aupto(limit):\n  alst = []\n  for k in range(1, limit+1):\n    if set(str(k*k)) <= set(\"2357\"): alst.append(k)\n  return alst\nprint(aupto(10**6)) \n"}
{"sequence_id": "A276008", "text": "Substitute ones for all nonzero digits in factorial base representation of n: a(n) = A059590(A275727(n)).", "sequence": "0,1,2,3,2,3,6,7,8,9,8,9,6,7,8,9,8,9,6,7,8,9,8,9,24,25,26,27,26,27,30,31,32,33,32,33,30,31,32,33,32,33,30,31,32,33,32,33,24,25,26,27,26,27,30,31,32,33,32,33,30,31,32,33,32,33,30,31,32,33,32,33,24,25,26,27,26,27,30,31,32,33,32,33,30,31,32,33,32,33,30,31,32,33,32,33,24", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a(n):\n    x=str(a007623(n))\n    y=\"\".join('1' if int(i)>0 else '0' for i in x)[::-1]\n    return sum([int(y[i])*f(i + 1) for i in range(len(y))])\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A276009", "text": "Decrement each nonzero digit by one in factorial base representation of n: a(n) = n - A276008(n).", "sequence": "0,0,0,0,2,2,0,0,0,0,2,2,6,6,6,6,8,8,12,12,12,12,14,14,0,0,0,0,2,2,0,0,0,0,2,2,6,6,6,6,8,8,12,12,12,12,14,14,24,24,24,24,26,26,24,24,24,24,26,26,30,30,30,30,32,32,36,36,36,36,38,38,48,48,48,48,50,50,48,48,48,48,50,50,54,54,54,54,56,56,60,60,60,60,62,62,72,72,72,72", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a(n):\n    x=str(a007623(n))\n    y=\"\".join(str(int(i) - 1) if int(i)>0 else '0' for i in x)[::-1]\n    return sum([int(y[i])*f(i + 1) for i in range(len(y))])\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A276027", "text": "Number of ways to transform a sequence of n ones to a single number by continually removing two numbers and replacing them with their sum modulo 3.", "sequence": "1,1,1,2,4,7,18,43,93,266,702,1687,5136,14405,36898,117016,341842,914064,2983027,8972121,24743851,82478973,253555061,715745648,2424954125,7582390623,21796481477,74805170349,237095926682,691568408221,2398418942361,7686495623620", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(x, y, z): return 1 if x + y + z==1 else (b(x + 1, y - 1, z - 1) if y>0 and z>0 else 0) + (b(x - 1, y, z) if x>1 or x>0 and y>0 or x>0 and z>0 else 0) + (b(x, y - 2, z + 1) if y>1 else 0) + (b(x, y + 1, z - 2) if z>1 else 0)\ndef a(n): return b(0, n, 0)\nprint([a(n) for n in range(1, 36)]) \n"}
{"sequence_id": "A276037", "text": "Numbers using only digits 1 and 5.", "sequence": "1,5,11,15,51,55,111,115,151,155,511,515,551,555,1111,1115,1151,1155,1511,1515,1551,1555,5111,5115,5151,5155,5511,5515,5551,5555,11111,11115,11151,11155,11511,11515,11551,11555,15111,15115,15151,15155,15511,15515", "code": "\nfrom itertools import product\nA276037_list = [int(''.join(d)) for l in range(1,10) for d in product('15',repeat=l)] \n"}
{"sequence_id": "A276039", "text": "Numbers using only digits 1 and 7.", "sequence": "1,7,11,17,71,77,111,117,171,177,711,717,771,777,1111,1117,1171,1177,1711,1717,1771,1777,7111,7117,7171,7177,7711,7717,7771,7777,11111,11117,11171,11177,11711,11717,11771,11777,17111,17117,17171,17177,17711,17717,17771,17777", "code": "\ndef a(n):\n  b = bin(n+1)[3:]\n  return int(\"\".join(b.replace(\"1\", \"7\").replace(\"0\", \"1\")))\nprint([a(n) for n in range(1, 47)]) \n"}
{"sequence_id": "A276075", "text": "a(1) = 0, a(n) = (e1*i1! + e2*i2! + ... + ez*iz!) for n = prime(i1)^e1 * prime(i2)^e2 * ... * prime(iz)^ez, where prime(k) is the k-th prime, A000040(k).", "sequence": "0,1,2,2,6,3,24,3,4,7,120,4,720,25,8,4,5040,5,40320,8,26,121,362880,5,12,721,6,26,3628800,9,39916800,5,122,5041,30,6,479001600,40321,722,9,6227020800,27,87178291200,122,10,362881,1307674368000,6,48,13,5042,722,20922789888000,7,126,27,40322,3628801,355687428096000,10,6402373705728000,39916801,28,6,726,123", "code": "\nfrom sympy import factorint, factorial as f, primepi\ndef a(n):\n    F=factorint(n)\n    return 0 if n==1 else sum(F[i]*f(primepi(i)) for i in F)\nprint([a(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A276077", "text": "Number of distinct prime factors p of n such that p^(1+A000720(p)) is a divisor of n, where A000720(p) gives the index of prime p, 1 for 2, 2 for 3, 3 for 5, and so on.", "sequence": "0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1,0,0,0,1", "code": "\nfrom sympy import primepi, isprime, primefactors, factorint\ndef a028234(n):\n    f=factorint(n)\n    return 1 if n==1 else n//(min(f)**f[min(f)])\ndef a067029(n):\n    f=factorint(n)\n    return 0 if n==1 else f[min(f)]\ndef a049084(n): return primepi(n)*(isprime(n))\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef a(n):\n    if n==1: return 0\n    val = a(a028234(n))\n    if a067029(n) > a055396(n):\n        val += 1\n    return val\nprint([a(n) for n in range(1, 201)]) \n"}
{"sequence_id": "A276078", "text": "Numbers n in whose prime factorization no exponent of any prime(k) exceeds k.", "sequence": "1,2,3,5,6,7,9,10,11,13,14,15,17,18,19,21,22,23,25,26,29,30,31,33,34,35,37,38,39,41,42,43,45,46,47,49,50,51,53,55,57,58,59,61,62,63,65,66,67,69,70,71,73,74,75,77,78,79,82,83,85,86,87,89,90,91,93,94,95,97,98,99,101,102,103,105,106,107,109,110,111,113,114,115,117,118,119,121", "code": "\nfrom sympy import factorint, primepi\ndef ok(n):\n    f = factorint(n)\n    return all(f[i] <= primepi(i) for i in f)\nprint([n for n in range(1, 151) if ok(n)]) \n"}
{"sequence_id": "A276079", "text": "Numbers n such that prime(k)^(k+1) divides n for some k.", "sequence": "4,8,12,16,20,24,27,28,32,36,40,44,48,52,54,56,60,64,68,72,76,80,81,84,88,92,96,100,104,108,112,116,120,124,128,132,135,136,140,144,148,152,156,160,162,164,168,172,176,180,184,188,189,192,196,200,204,208,212,216,220,224,228,232,236,240,243,244,248,252,256,260,264,268,270,272", "code": "\nfrom sympy import primepi, isprime, primefactors, factorint\ndef a028234(n):\n    f=factorint(n)\n    minf = min(f)\n    return 1 if n==1 else n//(minf**f[minf])\ndef a067029(n):\n    f=factorint(n)\n    return 0 if n==1 else f[min(f)]\ndef a049084(n): return primepi(n) if isprime(n) else 0\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef a(n): return 0 if n==1 else a(a028234(n)) + (1 if a067029(n) > a055396(n) else 0)\nprint([n for n in range(1, 301) if a(n)!=0]) \n"}
{"sequence_id": "A276080", "text": "a(n) = A276075(A206296(n)).", "sequence": "0,1,2,7,28,139,822,5677,44888,400021,3966970,43328131,516782292,6682867087,93130824878,1391321096089,22181459914672,375880800693097,6746469047955378,127851581333528191,2551039715319388940,53457519928692619411,1173770856436282074982,26948387795024752862917,645694707721735535710728,16117771962578155161812989", "code": "\nfrom sympy import factorint, factorial as f, prime, primepi\nfrom operator import mul\nfrom functools import reduce\ndef a003961(n):\n    F=factorint(n)\n    return 1 if n==1 else reduce(mul, [prime(primepi(i) + 1)**F[i] for i in F])\ndef a276075(n):\n    F=factorint(n)\n    return 0 if n==1 else sum([F[i]*f(primepi(i)) for i in F])\nl=[1, 2]\nL=[0, 1]\nfor n in range(2, 11):\n    l.append(a003961(l[n - 1])*l[n - 2])\n    L.append(a276075(l[n]))\nprint(L) \n"}
{"sequence_id": "A276081", "text": "a(n) = A276075(A260443(n)).", "sequence": "0,1,2,3,6,5,8,9,24,11,14,13,30,17,32,33,120,35,38,25,54,27,44,43,144,47,62,49,150,65,152,153,720,155,158,73,174,63,92,79,264,81,98,71,198,87,188,187,840,191,206,109,294,111,212,199,864,215,302,217,870,305,872,873,5040,875,878,313,894,231,332,247,984,237,266,155,438,171", "code": "\nfrom sympy import factorint, factorial as f, prime, primepi\nfrom operator import mul\nfrom functools import reduce\ndef a003961(n):\n    F=factorint(n)\n    return 1 if n==1 else reduce(mul, [prime(primepi(i) + 1)**F[i] for i in F])\ndef a260443(n): return n + 1 if n<2 else a003961(a260443(n//2)) if n%2==0 else a260443((n - 1)//2)*a260443((n + 1)//2)\ndef a276075(n):\n    F=factorint(n)\n    return 0 if n==1 else sum([F[i]*f(primepi(i)) for i in F])\ndef a(n): return a276075(a260443(n))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A276082", "text": "a(0) = 0, a(2n) = A153880(a(n)), a(2n+1) = 1+A255411(a(n)).", "sequence": "0,1,2,5,6,13,14,23,24,49,50,77,54,85,86,119,120,241,242,365,246,373,374,503,264,409,410,557,414,565,566,719,720,1441,1442,2165,1446,2173,2174,2903,1464,2209,2210,2957,2214,2965,2966,3719,1560,2401,2402,3245,2406,3253,3254,4103,2424,3289,3290,4157,3294,4165,4166,5039,5040,10081", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a255411(n):\n    x=str(a007623(n)) + '0'\n    y=\"\".join(str(int(i) + 1) if int(i)>0 else '0' for i in x)[::-1]\n    return 0 if n==0 else sum([int(y[i])*f(i + 1) for i in range(len(y))])\ndef a153880(n):\n    x=(str(a007623(n)) + '0')[::-1]\n    return 0 if n==0 else sum([int(x[i])*f(i + 1) for i in range(len(x))])\ndef a(n): return 0 if n==0 else a153880(a(n//2)) if n%2==0 else 1 + a255411(a((n - 1)//2))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A276083", "text": "a(0) = 0, a(2n) = A255411(a(n)), a(2n+1) = 1+A153880(a(n)).", "sequence": "0,1,4,3,18,13,16,9,96,73,76,51,90,61,64,33,600,481,484,363,498,373,376,249,576,433,436,291,450,301,304,153,4320,3601,3604,2883,3618,2893,2896,2169,3696,2953,2956,2211,2970,2221,2224,1473,4200,3361,3364,2523,3378,2533,2536,1689,3456,2593,2596,1731,2610,1741,1744,873,35280,30241", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a255411(n):\n    x=(str(a007623(n)) + '0')\n    y=\"\".join(str(int(i) + 1) if int(i)>0 else '0' for i in x)[::-1]\n    return 0 if n==0 else sum([int(y[i])*f(i + 1) for i in range(len(y))])\ndef a153880(n):\n    x=(str(a007623(n)) + '0')[::-1]\n    return 0 if n==0 else sum([int(x[i])*f(i + 1) for i in range(len(x))])\ndef a(n): return 0 if n==0 else a255411(a(n//2)) if n%2==0 else 1 + a153880(a((n - 1)//2))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A276084", "text": "a(n) = Number of trailing zeros in primorial base representation of n (A049345); largest k such that A002110(k) divides n.", "sequence": "0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,3,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,3,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,3,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,3", "code": "\nfrom sympy import nextprime, primepi\ndef a053669(n):\n    p = 2\n    while True:\n        if n%p!=0: return p\n        else: p=nextprime(p)\ndef a(n): return primepi(a053669(n)) - 1 \n"}
{"sequence_id": "A276085", "text": "a(1) = 0, a(n) = (e1*A002110(i1-1) + ... + ez*A002110(iz-1)) for n = prime(i1)^e1 * ... * prime(iz)^ez, where prime(k) is the k-th prime, A000040(k) and A002110(k) (the k-th primorial) is the product of first k primes.", "sequence": "0,1,2,2,6,3,30,3,4,7,210,4,2310,31,8,4,30030,5,510510,8,32,211,9699690,5,12,2311,6,32,223092870,9,6469693230,5,212,30031,36,6,200560490130,510511,2312,9,7420738134810,33,304250263527210,212,10,9699691,13082761331670030,6,60,13,30032,2312,614889782588491410,7,216,33,510512,223092871,32589158477190044730,10", "code": "\nfrom sympy import primorial, primepi, factorint\ndef a002110(n):\n    return 1 if n<1 else primorial(n)\ndef a(n):\n    f=factorint(n)\n    return sum(f[i]*a002110(primepi(i) - 1) for i in f)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A276086", "text": "Prime product form of primorial base expansion of n: digits in primorial base representation of n become the exponents of successive prime factors whose product a(n) is.", "sequence": "1,2,3,6,9,18,5,10,15,30,45,90,25,50,75,150,225,450,125,250,375,750,1125,2250,625,1250,1875,3750,5625,11250,7,14,21,42,63,126,35,70,105,210,315,630,175,350,525,1050,1575,3150,875,1750,2625,5250,7875,15750,4375,8750,13125,26250,39375,78750,49,98,147,294,441,882,245,490,735,1470,2205,4410,1225,2450", "code": "\nfrom sympy import prime\ndef a(n):\n    i=0\n    m=pr=1\n    while n>0:\n        i+=1\n        N=prime(i)*pr\n        if n%N!=0:\n            m*=(prime(i)**((n%N)/pr))\n            n-=n%N\n        pr=N\n    return m \n"}
{"sequence_id": "A276088", "text": "The least significant nonzero digit in primorial base representation of n: a(n) = A276094(n) / A002110(A276084(n)) (with a(0) = 0).", "sequence": "0,1,1,1,2,1,1,1,1,1,2,1,2,1,1,1,2,1,3,1,1,1,2,1,4,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,2,1,2,1,1,1,2,1,3,1,1,1,2,1,4,1,1,1,2,1,2,1,1,1,2,1,1,1,1,1,2,1,2,1,1,1,2,1,3,1,1,1,2,1,4,1,1,1,2,1,3,1,1,1,2,1,1,1,1,1,2,1,2,1,1,1,2,1,3,1,1,1,2,1,4,1,1,1,2,1,4", "code": "\nfrom sympy import nextprime, primepi, primorial\ndef a053669(n):\n    p = 2\n    while True:\n        if n%p!=0: return p\n        else: p=nextprime(p)\ndef a257993(n): return primepi(a053669(n))\ndef a002110(n): return 1 if n<1 else primorial(n)\ndef a276094(n): return 0 if n==0 else n%a002110(a257993(n))\ndef a(n): return 0 if n==0 else a276094(n)//a002110(a257993(n) - 1)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A276091", "text": "Numbers obtained by reinterpreting base-2 representation of n in A001563-base (A276326): a(n) = Sum_{k>=0} A030308(n,k)*A001563(k+1).", "sequence": "0,1,4,5,18,19,22,23,96,97,100,101,114,115,118,119,600,601,604,605,618,619,622,623,696,697,700,701,714,715,718,719,4320,4321,4324,4325,4338,4339,4342,4343,4416,4417,4420,4421,4434,4435,4438,4439,4920,4921,4924,4925,4938,4939,4942,4943,5016,5017,5020,5021,5034,5035,5038,5039,35280,35281", "code": "\nfrom sympy import factorial as f\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a255411(n):\n    x=(str(a007623(n)) + '0')\n    y=\"\".join(str(int(i) + 1) if int(i)>0 else '0' for i in x)[::-1]\n    return 0 if n==0 else sum(int(y[i])*f(i + 1) for i in range(len(y)))\ndef a(n): return 0 if n==0 else a255411(a(n//2)) if n%2==0 else 1 + a255411(a((n - 1)//2))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A276094", "text": "a(n) = n modulo A002110(A257993(n)), a(0) = 0.", "sequence": "0,1,2,1,4,1,6,1,2,1,4,1,12,1,2,1,4,1,18,1,2,1,4,1,24,1,2,1,4,1,30,1,2,1,4,1,6,1,2,1,4,1,12,1,2,1,4,1,18,1,2,1,4,1,24,1,2,1,4,1,60,1,2,1,4,1,6,1,2,1,4,1,12,1,2,1,4,1,18,1,2,1,4,1,24,1,2,1,4,1,90,1,2,1,4,1,6,1,2,1,4,1,12,1,2,1,4,1,18,1", "code": "\nfrom sympy import nextprime, primepi, primorial\ndef a053669(n):\n    p = 2\n    while True:\n        if n%p: return p\n        else: p=nextprime(p)\ndef a257993(n): return primepi(a053669(n))\ndef a002110(n): return 1 if n<1 else primorial(n)\ndef a(n): return 0 if n==0 else n%a002110(a257993(n))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A276113", "text": "Number of 2 X 2 matrices with entries in {0,1,...,n} and permanent = (trace)^2 with no entry repeated.", "sequence": "0,0,0,0,4,4,4,8,12,24,24,24,32,52,56,56,76,76,88,120,124,152,152,152,160,192,212,236,288,288,288,352,372,372,372,376,420,496,528,600,604,604,632,724,728,740,740,740,788,932,964", "code": "\ndef t(n):\n    s=0\n    for a in range(n+1):\n        for b in range(n+1):\n            for c in range(n+1):\n                for d in range(n+1):\n                   if (a!=b  and a!=d and b!=d and c!=a and c!=b and c!=d):\n                        if a*d+b*c==(a+d)**2:\n                            s+=1\n    return s\nfor i in range(201):\n    print(str(i)+\" \"+str(t(i)))\n"}
{"sequence_id": "A276150", "text": "Sum of digits when n is written in primorial base (A049345); minimal number of primorials (A002110) that add to n.", "sequence": "0,1,1,2,2,3,1,2,2,3,3,4,2,3,3,4,4,5,3,4,4,5,5,6,4,5,5,6,6,7,1,2,2,3,3,4,2,3,3,4,4,5,3,4,4,5,5,6,4,5,5,6,6,7,5,6,6,7,7,8,2,3,3,4,4,5,3,4,4,5,5,6,4,5,5,6,6,7,5,6,6,7,7,8,6,7,7,8,8,9,3,4,4,5,5,6,4,5,5,6,6,7,5,6,6,7,7,8,6,7,7,8,8,9,7,8,8,9,9,10,4", "code": "\nfrom sympy import prime, primefactors\ndef Omega(n): return 0 if n==1 else Omega(n//primefactors(n)[0]) + 1\ndef a276086(n):\n    i=0\n    m=pr=1\n    while n>0:\n        i+=1\n        N=prime(i)*pr\n        if n%N!=0:\n            m*=(prime(i)**((n%N)/pr))\n            n-=n%N\n        pr=N\n    return m\ndef a(n): return Omega(a276086(n))\nprint([a(n) for n in range(201)]) \n"}
{"sequence_id": "A276151", "text": "n minus the greatest primorial number (A002110) which divides n: a(n) = n - A053589(n).", "sequence": "0,0,2,2,4,0,6,6,8,8,10,6,12,12,14,14,16,12,18,18,20,20,22,18,24,24,26,26,28,0,30,30,32,32,34,30,36,36,38,38,40,36,42,42,44,44,46,42,48,48,50,50,52,48,54,54,56,56,58,30,60,60,62,62,64,60,66,66,68,68,70,66,72,72,74,74,76,72,78,78,80,80,82,78,84,84,86,86,88,60,90,90,92", "code": "\nfrom sympy import nextprime, primepi, primorial\ndef a002110(n): return 1 if n<1 else primorial(n)\ndef a053669(n):\n    p = 2\n    while True:\n        if n%p!=0: return p\n        else: p=nextprime(p)\ndef a276084(n): return primepi(a053669(n)) - 1\ndef a(n): return n - a002110(a276084(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A276156", "text": "Numbers obtained by reinterpreting base-2 representation of n in primorial base: a(0) = 0, a(2n) = A276154(a(n)), a(2n+1) = 1 + A276154(a(n)).", "sequence": "0,1,2,3,6,7,8,9,30,31,32,33,36,37,38,39,210,211,212,213,216,217,218,219,240,241,242,243,246,247,248,249,2310,2311,2312,2313,2316,2317,2318,2319,2340,2341,2342,2343,2346,2347,2348,2349,2520,2521,2522,2523,2526,2527,2528,2529,2550,2551,2552,2553,2556,2557,2558,2559,30030,30031", "code": "\nfrom sympy import prime, primorial, primepi, factorint\nfrom operator import mul\ndef a002110(n): return 1 if n<1 else primorial(n)\ndef a276085(n):\n    f=factorint(n)\n    return sum([f[i]*a002110(primepi(i) - 1) for i in f])\ndef a019565(n): return reduce(mul, (prime(i+1) for i, v in enumerate(bin(n)[:1:-1]) if v == '1')) \ndef a(n): return 0 if n==0 else a276085(a019565(n))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A276389", "text": "Numbers n such that n! ends in the same number of 0's in both base 10 and base 16.", "sequence": "0,1,2,3,4,6,7,8,9,10,11,12,13,14,16,17,20,21,22,23,28,29,32,33,35,36,37,38,39,40,41,42,43,45,46,47,52,53,54,56,57,58,59,60,61,62,63,65,70,71,76,77,78,79,80,81,82,83,85,86,87,90,91,95,100,101", "code": "\nA276389_list, m = [0], 1\nfor n in range(1,10**3):\n    m *= n\n    s, h = str(m), hex(m)\n    if not len(s)-len(s.rstrip('0'))+len(h.rstrip('0'))-len(h):\n        A276389_list.append(n) \n"}
{"sequence_id": "A276399", "text": "Numerator of n!/(n^n-n).", "sequence": "1,1,2,1,24,5,720,126,4480,6048,3628800,95040,479001600,55598400,5806080,1816214400,20922789888000,40327372800,6402373705728000,2501955993600,8911728967680000,193526296104960000,1124000727777607680000,696294353018880000,2256176006302688870400", "code": "\nfrom __future__ import division\nfrom math import factorial\nfrom fractions import gcd\ndef A276399(n):\n    a = factorial(n-1)\n    return a//gcd(n**(n-1)-1,a) \n"}
{"sequence_id": "A276400", "text": "Denominator of n!/(n^n-n).", "sequence": "1,4,21,26,1555,817,299593,134521,12345679,43229041,67546215517,4622635937,61054982558011,18617937516193,5118976599431,4224061794762749,128583032925805678351,655879001624535409,275941052631578947368421,286115209221463953761,2707038020425761202263187", "code": "\nfrom __future__ import division\nfrom math import factorial\nfrom fractions import gcd\ndef A276400(n):\n    a = n**(n-1) - 1\n    return a//gcd(factorial(n-1),a) \n"}
{"sequence_id": "A276449", "text": "Number of 1-orbits of the cyclic group C_4 for a bi-colored square n X n grid with n squares of one color.", "sequence": "1,0,0,4,6,0,0,120,190,0,0,7140,11480,0,0,635376,1028790,0,0,75287520,122391522,0,0,11143364232,18161699556,0,0,1978369382080,3230129794320,0,0,409663695276000,669741609663270,0,0,96930293990660064,158625578809472060", "code": "\nimport math\ndef nCr(n,r):\n    f = math.factorial\n    return f(n) / f(r) / f(n-r)\n\nfor j in range(101):\n    if j%4 == 0:\n        a = nCr((j*j/4),(j/4))\n    elif j%4 == 1:\n        a = nCr(((j-1)/2)*((j-1)/2+1),((j-1)/4))\n    else:\n        a = 0\n    print(str(j)+\" \"+str(a))\n"}
{"sequence_id": "A276451", "text": "Number of 2-orbits of the cyclic group C_4 for a bi-colored square n X n grid with n squares of one color.", "sequence": "0,1,2,12,30,408,1012,17920,45600,1059380,2730756,78115884,203235032,6917206576,18113945256,714851008512,1881039165696,84449819514060,223049005408900,11225502116862880,29736777118603962,1658138369930988088,4403069737450280832", "code": "\nimport math\ndef nCr(n,r):\n    f = math.factorial\n    return f(n) / f(r) / f(n-r)\n\nfor j in range(101):\n    i = j/2\n    if j%2==0:\n        b = nCr(2*i*i,i)\n    else:\n        b = nCr(2*i*(i+1),i)\n    if j%4==0:\n        c = nCr((j*j/4),(j/4))\n    elif j%4==1:\n        c = nCr(((j-1)/2)*((j-1)/2+1),((j-1)/4))\n    else:\n        c = 0\n    print(str(j)+\" \"+str((b-c)/2))\n"}
{"sequence_id": "A276452", "text": "Number of 4-orbits of the cyclic group C_4 for a bi-colored square n X n grid with n squares of one color.", "sequence": "0,1,20,448,13266,486744,21474640,1106532352,65221935740,4327576834420,319187489891256,25904823417117120,2294089575084464472,220132629092378694832,22751391952785312551232,2519687900505221042995200,297684761086121821704009432,37370623083548749203599933004", "code": "\nimport math\ndef nCr(n,r):\n    f = math.factorial\n    return f(n) / f(r) / f(n-r)\n\nfor j in range(101):\n    a = nCr(j*j,j)\n    i = j/2\n    if j%2==0:\n        b = nCr(2*i*i,i)\n    else:\n        b = nCr(2*i*(i+1),i)\n    print(str(j)+\" \"+str((a-b)/4))\n"}
{"sequence_id": "A276454", "text": "a(n) = A276452(n) + A276451(n) + A276449(n).", "sequence": "1,2,22,464,13302,487152,21475652,1106550392,65221981530,4327577893800,319187492622012,25904823495240144,2294089575287710984,220132629099295901408,22751391952803426496488,2519687900505935894639088,297684761086123702744203918", "code": "\nimport math\ndef nCr(n,r):\n    f = math.factorial\n    return f(n) / f(r) / f(n-r)\n\nfor j in range(101):\n   t = nCr(j*j,j)\n    i = j/2\n    if j%2==0:\n        d = nCr(2*i*i,i)\n    else:\n        d = nCr(2*i*(i+1),i)\n    a = (t-d)/4\n    if j%4==0:\n        c = nCr((j*j/4),(j/4))\n    elif j%4==1:\n        c = nCr(((j-1)/2)*((j-1)/2+1),((j-1)/4))\n    else:\n        c = 0\n    b = (d-c)/2\n    print(str(j)+\" \"+str(a+b+c))\n"}
{"sequence_id": "A276460", "text": "Numbers k such that for any positive integers a < b, if a * b = k then b - a is a square.", "sequence": "0,1,2,5,17,37,101,197,257,401,577,677,901,1297,1601,2917,3137,4357,5477,7057,8101,8837,10001,12101,13457,14401,15377,15877,16901,17957,20737,21317,22501,24337,25601,28901,30977,32401,33857,41617,42437,44101,50177,52901", "code": "\nfrom __future__ import division\nfrom sympy import divisors\nfrom gmpy2 import is_square\nA276460_list = [0]\nfor m in range(10**3):\n    k = m**2+1\n    for d in divisors(k):\n        if d > m:\n            A276460_list.append(k)\n            break\n        if not is_square(k//d - d):\n            break \n"}
{"sequence_id": "A276466", "text": "a(n) = numerator of Sum_{d|n} 0.d.", "sequence": "1,3,2,7,3,6,4,3,13,9,21,43,23,57,21,83,27,57,29,3,131,63,33,69,17,69,157,91,39,9,41,99,21,81,33,79,47,87,23,27,51,267,53,147,12,99,57,17,129,33,27,161,63,309,63,159,29,117,69,357,71,123,71,131,69", "code": "\nfrom fractions import Fraction\nfrom sympy import divisors\ndef A276466(n):\n    return sum(Fraction(d,10**len(str(d))) for d in divisors(n)).numerator \n"}
{"sequence_id": "A276542", "text": "Numbers k such that the k-th and (k+1)st triangular numbers have the same number of divisors.", "sequence": "3,4,5,11,17,28,29,33,41,42,52,55,59,66,68,71,76,85,88,91,93,101,107,114,123,137,141,143,149,150,159,170,172,179,183,185,186,188,191,196,197,201,203,208,213,215,217,219,227,232,235,236,239,243,244,247,265", "code": "\nfrom sympy import divisor_count\nfor n in range(1,20):\n    if divisor_count(n*(n+1)/2)==divisor_count((n+1)*(n+2)/2):\n        print(n, end=', ') \n"}
{"sequence_id": "A276553", "text": "Numbers n such that n^2 and (n + 1)^2 have the same number of divisors.", "sequence": "2,14,15,21,33,34,38,44,57,75,81,85,86,93,94,98,116,118,122,133,135,141,142,145,147,158,171,177,201,202,205,213,214,217,218,230,244,253,272,285,296,298,301,302,326,332,334,375,381,387,393,394,405,429,434,445", "code": "\nfrom sympy.ntheory import divisor_count\nprint([n for n in range(1, 501) if divisor_count(n**2) == divisor_count((n + 1)**2)]) \n(Scheme, with Antti Karttunen's IntSeq-library) (define A276553 (ZERO-POS 1 1 A284570)) ;; _Antti Karttunen_, Apr 15 2017\n"}
{"sequence_id": "A276588", "text": "Square array A(row,col) = Sum_{k=0..row} binomial(row,k)*(1+col+k)!, read by descending antidiagonals as A(0,0), A(0,1), A(1,0), A(0,2), A(1,1), A(2,0), ...", "sequence": "1,2,3,6,8,11,24,30,38,49,120,144,174,212,261,720,840,984,1158,1370,1631,5040,5760,6600,7584,8742,10112,11743,40320,45360,51120,57720,65304,74046,84158,95901,362880,403200,448560,499680,557400,622704,696750,780908,876809,3628800,3991680,4394880,4843440,5343120,5900520,6523224,7219974,8000882,8877691", "code": "\nfrom sympy import binomial, factorial\ndef T(r, c): return sum([binomial(r, k) * factorial(1 + c + k) for k in range(r + 1)])\nfor r in range(11): print([T(c, r - c) for c in range(r + 1)]) \n"}
{"sequence_id": "A276589", "text": "Transpose of A276588.", "sequence": "1,3,2,11,8,6,49,38,30,24,261,212,174,144,120,1631,1370,1158,984,840,720,11743,10112,8742,7584,6600,5760,5040,95901,84158,74046,65304,57720,51120,45360,40320,876809,780908,696750,622704,557400,499680,448560,403200,362880,8877691,8000882,7219974,6523224,5900520,5343120,4843440,4394880,3991680,3628800", "code": "\nfrom sympy import binomial, factorial\ndef T(r, c): return sum([binomial(r, k) * factorial(1 + c + k) for k in range(r + 1)])\nfor r in range(11): print [T(c, r - c) for c in range(r + 1)] \n"}
{"sequence_id": "A276638", "text": "a(0)=0; thereafter a(n) is the number of matches between the first n terms circularly shifted by s and the reverse of the first n terms, maximized over s.", "sequence": "0,1,2,1,4,3,4,3,6,3,6,3,8,5,8,5,6,5,6,7,8,7,10,7,8,7,12,7,12,7,12,7,12,7,14,9,14,9,14,9,14,9,14,9,14,11,16,11,14,11,16,11,18,11,16,11,16,11,16,11,20,13,16,13,18,13,16,13,18,13,18,13,18", "code": "\na = [0]\nfor n in range(1, 100):\n    a.append(max(sum(a[(i+s)%n]==a[-i-1] for i in range(n)) for s in range(n)))\n"}
{"sequence_id": "A276689", "text": "Least term in the periodic part of the continued fraction expansion of sqrt(n) or 0 if n is square.", "sequence": "0,0,2,1,0,4,2,1,1,0,6,3,2,1,1,1,0,8,4,1,2,1,1,1,1,0,10,5,2,1,2,1,1,1,1,1,0,12,6,4,3,2,2,1,1,1,1,1,1,0,14,7,1,1,1,2,2,1,1,1,1,1,1,1,0,16,8,1,4,1,1,1,2,1,1,1,1,1,1,1,1,0,18,9,6,1", "code": "\nfrom sympy import continued_fraction_periodic\ndef A276689(n):\n    x = continued_fraction_periodic(0,1,n)\n    return min(x[1]) if len(x) > 1 else 0\n"}
{"sequence_id": "A276690", "text": "Binary Barker codes written in base 10.", "sequence": "2,3,6,13,14,29,114,1810,7989", "code": "\ndef ok(n):\n    t = [(-1)**int(x) for x in bin(n)[2:]]\n    return all(abs(sum(t[i]*t[i+k] for i in range(len(t)-k))) <= 1 for k in range(1, len(t)))\ndef not_dup(n):\n    b = bin(n)[2:]\n    i = ''.join('0' if c=='1' else '1' for c in b)\n    return b >= b[::-1] and b >= i[::-1]\na = [n for n in range(2, 2**13) if not_dup(n) and ok(n)]\nprint(a)\n\n"}
{"sequence_id": "A276707", "text": "Number of terms of A069090 with exactly n digits.", "sequence": "4,12,60,381,2522,19094,151286,1237792,10354144,88407746,766869330", "code": "\nfrom sympy import primerange, isprime\ndef ok(p):\n    s = str(p)\n    if len(s) == 1: return True\n    return all(not isprime(int(s[:i])) for i in range(1, len(s)))\ndef a(n): return sum(ok(p) for p in primerange(10**(n-1), 10**n))\nprint([a(n) for n in range(1, 7)]) \n"}
{"sequence_id": "A276707", "text": "Number of terms of A069090 with exactly n digits.", "sequence": "4,12,60,381,2522,19094,151286,1237792,10354144,88407746,766869330", "code": " \nfrom sympy import isprime, nextprime\ndef a(n):\n    if n == 1: return 4\n    p, c = nextprime(10**(n-1)), 0\n    while p < 10**n:\n        s, fail = str(p), False\n        for i in range(1, n):\n            ti = int(s[:i])\n            if isprime(ti): fail = i; break\n        if fail: p = nextprime((ti+1)*10**(n-i))\n        else: p, c = nextprime(p), c+1\n    return c\nprint([a(n) for n in range(1, 8)]) \n"}
{"sequence_id": "A276718", "text": "Numbers n such that Sum_{k=1..n} d(r(k)) is an integer where d(r(k)) is the decimal fraction 0.r(k), where r(k) is the reverse of k (e.g. d(r(123))=0.321).", "sequence": "4,52655,57343,443749,526559,573439,656249,2515624,4437499,5265599,5734399,6562499,8484374,44374999,52655999,57343999,65624999,401953124,443749999,526559999,573439999,656249999,698046874,4437499999,5265599999,5734399999,6562499999,44374999999,52655999999,57343999999,65624999999", "code": "\nfrom fractions import Fraction\nA276718_list, q = [], 0\nfor i in range(1, 10**6):\n    s = str(i)\n    q += Fraction(int(s[::-1]), 10**len(s))\n    if q.denominator == 1:\n        A276718_list.append(i) \n"}
{"sequence_id": "A276740", "text": "Numbers n such that 3^n == 5 (mod n).", "sequence": "1,2,4,76,418,1102,4687,7637,139183,2543923,1614895738,9083990938,23149317409,497240757797,4447730232523,16000967516764,65262766108619,141644055557882", "code": "\nA276740_list = [1,2,4]+[n for n in range(5,10**6) if pow(3,n,n) == 5] \n"}
{"sequence_id": "A276756", "text": "Squarefree terms of A276655.", "sequence": "1,21,30,979,1411,1463,1547,1742,1947,2059,2090,2210,2318,2405,2419,2491,2703,2886,2945,3182,3243,3534,3567,16102,17654,20559,21243,25543,25705,27145,27307,27805,28045,29323,29370,29631,30485,30846,32574,33366,33465,33654", "code": "\nfrom fractions import Fraction\nfrom sympy import factorint, primefactors\nA276756_list = [1] + [n for n in range(2,10**6) if max(factorint(n).values()) <= 1 and sum(Fraction(p,10**len(str(p))) for p in primefactors(n)).denominator == 1]\n"}
{"sequence_id": "A276854", "text": "Beatty sequence for 1 + sqrt(5).", "sequence": "0,3,6,9,12,16,19,22,25,29,32,35,38,42,45,48,51,55,58,61,64,67,71,74,77,80,84,87,90,93,97,100,103,106,110,113,116,119,122,126,129,132,135,139,142,145,148,152,155,158,161,165,168,171,174,177,181,184,187", "code": "\nfrom sympy import integer_nthroot\ndef A276854(n): return n+integer_nthroot(5*n**2,2)[0] \n"}
{"sequence_id": "A276863", "text": "First differences of the Beatty sequence A276854 for 1 + sqrt(5).", "sequence": "3,3,3,3,4,3,3,3,4,3,3,3,4,3,3,3,4,3,3,3,3,4,3,3,3,4,3,3,3,4,3,3,3,4,3,3,3,3,4,3,3,3,4,3,3,3,4,3,3,3,4,3,3,3,3,4,3,3,3,4,3,3,3,4,3,3,3,4,3,3,3,3,4,3,3,3,4,3,3,3,4,3,3,3,4,3", "code": "\nfrom sympy import integer_nthroot\ndef A276863(n): return 1+integer_nthroot(5*n**2,2)[0]-integer_nthroot(5*(n-1)**2,2)[0] \n"}
{"sequence_id": "A276919", "text": "Number of solutions to x^3 + y^3 + z^3 + t^3 == 1 (mod n) for 1 <= x, y, z, t <= n.", "sequence": "1,8,27,64,125,216,336,512,1296,1000,1331,1728,1794,2688,3375,4096,4913,10368,7410,8000,9072,10648,12167,13824,15625,14352,34992,21504,24389,27000,30225,32768,35937,39304,42000,82944,48396,59280,48438,64000,68921,72576,77529,85184,162000,97336", "code": "\ndef A276919(n):\n    ndict = {}\n    for i in range(n):\n        i3 = pow(i,3,n)\n        for j in range(i+1):\n            j3 = pow(j,3,n)\n            m = (i3+j3) % n\n            if m in ndict:\n                if i == j:\n                    ndict[m] += 1\n                else:\n                    ndict[m] += 2\n            else:\n                if i == j:\n                    ndict[m] = 1\n                else:\n                    ndict[m] = 2\n    count = 0\n    for i in ndict:\n        j = (1-i) % n\n        if j in ndict:\n            count += ndict[i]*ndict[j]\n    return count \n"}
{"sequence_id": "A276920", "text": "Number of solutions to x^3 + y^3 + z^3 + t^3 == 0 (mod n) for 1 <= x, y, z, t <= n.", "sequence": "1,8,27,72,125,216,595,704,1539,1000,1331,1944,3133,4760,3375,5632,4913,12312,8911,9000,16065,10648,12167,19008,16125,25064,45927,42840,24389,27000,35371,47104,35937,39304,74375,110808,58645,71288,84591,88000", "code": "\ndef A276920(n):\n    ndict = {}\n    for i in range(n):\n        i3 = pow(i,3,n)\n        for j in range(i+1):\n            j3 = pow(j,3,n)\n            m = (i3+j3) % n\n            if m in ndict:\n                if i == j:\n                    ndict[m] += 1\n                else:\n                    ndict[m] += 2\n            else:\n                if i == j:\n                    ndict[m] = 1\n                else:\n                    ndict[m] = 2\n    count = 0\n    for i in ndict:\n        j = (-i) % n\n        if j in ndict:\n            count += ndict[i]*ndict[j]\n    return count \n"}
{"sequence_id": "A277021", "text": "Left inverse of A277022.", "sequence": "0,1,2,2,6,3,4,3,30,7,8,4,12,5,6,4,210,31,32,8,36,9,10,5,60,13,14,6,18,7,8,5,2310,211,212,32,216,33,34,9,240,37,38,10,42,11,12,6,420,61,62,14,66,15,16,7,90,19,20,8,24,9,10,6,30030,2311,2312,212,2316,213,214,33,2340,217,218,34,222,35,36,10,2520,241,242", "code": "\nfrom sympy import primorial, primepi, prime, factorint, floor, log\ndef a002110(n): return 1 if n<1 else primorial(n)\ndef a276085(n):\n    f=factorint(n)\n    return sum([f[i]*a002110(primepi(i) - 1) for i in f])\ndef A(n): return n - 2**int(floor(log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a(n): return a276085(b(n - 1))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A277030", "text": "Smallest m such that b^phi(n) == b^m (mod n) for every integer b, where phi(n) = A000010(n).", "sequence": "0,1,2,2,4,2,6,4,6,4,10,2,12,6,4,4,16,6,18,4,6,10,22,4,20,12,18,6,28,4,30,8,10,16,12,6,36,18,12,4,40,6,42,10,12,22,46,4,42,20,16,12,52,18,20,6,18,28,58,4,60,30,6,16,12,10,66,16,22,12,70,6,72,36,20,18,30", "code": "\nfrom sympy import totient\ndef a(n):\n    m=0\n    if n==1: return 0\n    else:\n        while True:\n            m+=1\n            b=1\n            while (b**totient(n))%n==(b**m)%n:\n                b+=1\n                if b>n: return m\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A277044", "text": "Number of 2 X 2 matrices with entries in {0,1,...,n} and even determinant with no entry repeated.", "sequence": "0,0,0,16,96,216,600,1008,2064,3040,5280,7200,11280,14616,21336,26656,36960,44928,59904,71280,92160,107800,135960,156816,193776,220896,268320,302848,362544,405720,479640,532800,623040,687616,796416,873936,1003680,1095768,1248984,1357360,1536720,1663200", "code": "\ndef t(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            for c in range(0,n+1):\n                for d in range(0,n+1):\n                   if (a!=b  and a!=d and b!=d and c!=a and c!=b and c!=d):\n                        if (a*d-b*c)%2==0:\n                            s+=1\n    return s\nfor i in range(0,201):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A277116", "text": "Number of segments used to represent the number n on a 7-segment display: variant where digits 6, 7 and 9 use 6, 3 and 5 segments, respectively.", "sequence": "6,2,5,5,4,5,6,3,7,5,8,4,7,7,6,7,8,5,9,7,11,7,10,10,9,10,11,8,12,10,11,7,10,10,9,10,11,8,12,10,10,6,9,9,8,9,10,7,11,9,11,7,10,10,9,10,11,8,12,10,12,8,11,11,10,11,12,9,13,11,9,5,8,8,7,8,9", "code": "\ndef A277116(n):\n    s=0\n    for i in str(n):\n        s+=[6,2,5,5,4,5,6,3,7,5][int(i)]\n    return s \n"}
{"sequence_id": "A277123", "text": "Numbers k such that 1 + Sum_{j=1..k} prime(j)^2 is prime.", "sequence": "1,11,19,29,37,73,97,155,163,175,191,257,295,313,325,341,365,389,391,409,415,461,491,497,515,599,697,715,757,761,767,775,785,793,857,875,895,899,905,919,1099,1109,1117,1139,1151,1163,1225,1271,1279,1295,1309", "code": "\nimport sympy\nsum = p = 1\nfor n in range(1,3001):\n  while not sympy.isprime(p):  p+=1    \n  sum += p*p\n  p+=1\n  if sympy.isprime(sum):  print str(n)+',',\n"}
{"sequence_id": "A277280", "text": "Maximal coefficient in Hermite polynomial of order n.", "sequence": "1,2,4,8,16,120,720,3360,13440,48384,302400,2217600,13305600,69189120,322882560,2421619200,19372953600,131736084480,790416506880,4290832465920,40226554368000,337903056691200,2477955749068800,16283709208166400,113985964457164800", "code": "\nfrom sympy import hermite, Poly\ndef a(n): return max(Poly(hermite(n, x), x).coeffs()) \n"}
{"sequence_id": "A277281", "text": "Maximal coefficient (ignoring signs) in Hermite polynomial of order n.", "sequence": "1,2,4,12,48,160,720,3360,13440,80640,403200,2217600,13305600,69189120,484323840,2905943040,19372953600,131736084480,846874828800,6436248698880,42908324659200,337903056691200,2477955749068800,18997660742860800,151981285942886400", "code": "\nfrom sympy import hermite, Poly\ndef a(n): return max(map(abs, Poly(hermite(n, x), x).coeffs())) \n"}
{"sequence_id": "A277285", "text": "Numbers n such that d(n) divides 2^n-1.", "sequence": "1,4,16,36,144,324,400,576,729,784,900,1764,1936,2304,2500,2704,2916,3600,4356,4624,5184,5776,6084,7056,8100,8464,9604,10000,10404,11664,12996,13456,14400,15376,15876,16384,17424,19044,20736,21904,22500,24336,25600,26244,26896,28224,29584,30276", "code": "\nfrom sympy import divisor_count\nA277285_list = [1] + [j for j in (i**2 for i in range(1,10**4)) if pow(2,j,int(divisor_count(j))) == 1] \n"}
{"sequence_id": "A277288", "text": "Positive integers n such that n | (3^n + 5).", "sequence": "1,2,14,1978,38209,4782974,9581014,244330711,365496202,1661392258,116084432414,288504187458218,490179448388654,802245996685561", "code": "\nA277288_list = [1,2]+[n for n in range(3,10**6) if pow(3,n,n)==n-5] \n"}
{"sequence_id": "A277289", "text": "Positive integers n such that n | (3^n + 7).", "sequence": "1,2,4,5,8,25,44,4664,6568,1353025,2919526,5709589,7827725,64661225,85132756,153872408,743947534,34304296003,38832409867,40263727492,1946603375348,2469908330348,64471909888247,274267749806485,888906849689897,896501949422459", "code": " A277289_list = [1,2,4,5]+[n for n in range(6,10**6) if pow(3,n,n)==n-7] \n"}
{"sequence_id": "A277319", "text": "Numbers n such that A048675(n) is a prime.", "sequence": "3,4,6,8,10,18,22,24,30,32,40,42,46,54,56,66,70,72,88,96,98,102,114,118,126,128,130,136,150,152,168,182,200,224,234,238,246,250,266,270,294,312,318,328,330,350,354,360,370,392,402,406,416,424,434,440,442,450,472,480,486,510,536,546,594,600,630,640,646,648,650,654,666,680,690,722", "code": "\nfrom sympy import factorint, primepi, isprime\ndef a048675(n):\n    if n==1: return 0\n    f=factorint(n)\n    return sum([f[i]*2**(primepi(i) - 1) for i in f])\nprint([n for n in range(1, 1001) if isprime(a048675(n))]) \n"}
{"sequence_id": "A277324", "text": "Odd bisection of A260443 (the even terms): a(n) = A260443((2*n)+1).", "sequence": "2,6,18,30,90,270,450,210,630,6750,20250,9450,15750,47250,22050,2310,6930,330750,3543750,1653750,4961250,53156250,24806250,727650,1212750,57881250,173643750,18191250,8489250,25467750,2668050,30030,90090,40020750,1910081250,891371250,9550406250,455814843750,212713593750", "code": "\nfrom sympy import factorint, prime, primepi\nfrom operator import mul\ndef a003961(n):\n    F=factorint(n)\n    return 1 if n==1 else reduce(mul, [prime(primepi(i) + 1)**F[i] for i in F])\ndef a260443(n): return n + 1 if n<2 else a003961(a260443(n//2)) if n%2==0 else a260443((n - 1)//2)*a260443((n + 1)//2)\ndef a(n): return a260443(2*n + 1)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A277340", "text": "Positive integers n such that n | (3^n + 11).", "sequence": "1,2,4,7,10,92,1099,29530,281473,657892,3313964,9816013,18669155396,94849225930,358676424226,957439868543,1586504109310,41431374800470,241469610359708,256165266592379", "code": "\nA277340_list = [1,2,4,7,10]+[n for n in range(11,10**6) if pow(3,n,n)==n-11] \n"}
{"sequence_id": "A277351", "text": "Value of (n+1,n) concatenated in binary representation.", "sequence": "5,14,19,44,53,62,71,152,169,186,203,220,237,254,271,560,593,626,659,692,725,758,791,824,857,890,923,956,989,1022,1055,2144,2209,2274,2339,2404,2469,2534,2599,2664,2729,2794,2859,2924,2989,3054,3119,3184,3249,3314", "code": "\ndef a(n): return int(bin(n+1)[2:] + bin(n)[2:], 2)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A277451", "text": "Number of edges in geodesic dome generated from icosahedron by recursively dividing each triangle in 4.", "sequence": "1,30,120,480,1920,7680,30720,122880,491520,1966080,7864320,31457280,125829120,503316480,2013265920,8053063680,32212254720,128849018880,515396075520,2061584302080,8246337208320,32985348833280,131941395333120,527765581332480", "code": " a = [1] + [30 * 4 ** (n-1) for n in range(1,24)]\n"}
{"sequence_id": "A277561", "text": "a(n) = Sum_{k=0..n} ({binomial(n+2k,2k)*binomial(n,k)} mod 2).", "sequence": "1,2,2,2,2,4,2,2,2,4,4,4,2,4,2,2,2,4,4,4,4,8,4,4,2,4,4,4,2,4,2,2,2,4,4,4,4,8,4,4,4,8,8,8,4,8,4,4,2,4,4,4,4,8,4,4,2,4,4,4,2,4,2,2,2,4,4,4,4,8,4,4,4,8,8,8,4,8,4,4,4,8,8,8,8,16,8", "code": "\ndef A277561(n):\n    return sum(int(not (~(n+2*k) & 2*k) | (~n & k)) for k in range(n+1))\n"}
{"sequence_id": "A277624", "text": "Composite numbers which have a dominant prime factor. A prime factor p of n is dominant if floor(sqrt(p)) > (n/p).", "sequence": "22,26,34,38,46,51,57,58,62,69,74,82,86,87,93,94,106,111,116,118,122,123,124,129,134,141,142,146,148,158,159,164,166,172,177,178,183,185,188,194,201,202,205,206,212,213,214,215,218,219,226,235,236,237,244", "code": "\nfrom sympy import primefactors\nfrom gmpy2 import is_prime, isqrt\nA277624_list = []\nfor n in range(2,10**3):\n    if not is_prime(n):\n        for p in primefactors(n):\n            if isqrt(p)*p > n:\n                A277624_list.append(n)\n                break \n"}
{"sequence_id": "A277636", "text": "Number of 3 X 3 matrices having all elements in {0,...,n} with determinant = permanent.", "sequence": "1,343,6859,50653,226981,753571,2048383,4826809,10218313,19902511,36264691,62570773,103161709,163667323,251239591,374805361,545338513,776151559,1083206683,1485446221,2005142581,2668267603,3504881359,4549540393,5841725401,7426288351", "code": "\ndef a(n):\n    return 27*n**6-81*n**5+108*n**4-81*n**3+36*n**2-9*n+1\n"}
{"sequence_id": "A277685", "text": "Position of first letter of n (in Portuguese) in alphabet.", "sequence": "26,21,4,20,17,3,19,19,15,14,4,15,4,20,17,17,4,4,4,4,22,22,22,22,22,22,22,22,22,22,20,20,20,20,20,20,20,20,20,20,17,17,17,17,17,17,17,17,17,17,3,3,3,3,3,3,3,3,3,3,19,19,19,19,19,19", "code": "\nfrom num2words import num2words\nimport unidecode\ndef A277685(n): \n    return ord(unidecode.unidecode(num2words(n, lang='pt')).lower()[0]) - 96 \n"}
{"sequence_id": "A277692", "text": "Mendelsohn-Rodney sequence: number of court balanced tournament designs that are available for a given set of teams n.", "sequence": "0,1,1,1,2,1,2,1,3,2,2,1,4,1,2,3,4,1,3,1,4,3,2,1,6,2,2,3,4,1,4,1,5,3,2,3,6,1,2,3,6,1,4,1,4,5,2,1,8,2,3,3,4,1,4,3,6,3,2,1,8,1,2,5,6,3,4,1,4,3,4,1,9,1,2,5,4,3,4,1,8,4,2,1,8,3,2,3,6,1,6,3,4,3,2,3,10,1,3,5,6,1,4,1,6,7,2,1", "code": "\nfrom __future__ import division\nfrom sympy import divisors\ndef A277692(n):\n    return sum(1 for c in divisors(n-1) if c < n-1 and not (n*(n-1)//2) % c) if n != 2 else 1 \n"}
{"sequence_id": "A277697", "text": "a(n) = Index of the least unitary prime divisor of n or 0 if no such prime-divisor exists.", "sequence": "0,1,2,0,3,1,4,0,0,1,5,2,6,1,2,0,7,1,8,3,2,1,9,2,0,1,0,4,10,1,11,0,2,1,3,0,12,1,2,3,13,1,14,5,3,1,15,2,0,1,2,6,16,1,3,4,2,1,17,2,18,1,4,0,3,1,19,7,2,1,20,0,21,1,2,8,4,1,22,3,0,1,23,2,3,1,2,5,24,1,4,9,2,1,3,2,25,1,5,0,26,1,27,6,2", "code": "\nfrom sympy import factorint, primepi, isprime, primefactors\ndef a049084(n): return primepi(n)*(1*isprime(n))\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef a028234(n):\n    f = factorint(n)\n    return 1 if n==1 else n/(min(f)**f[min(f)])\ndef a067029(n):\n    f=factorint(n)\n    return 0 if n==1 else f[min(f)]\ndef a(n): return 0 if n==1 else a055396(n) if a067029(n)==1 else a(a028234(n)) \n"}
{"sequence_id": "A277698", "text": "a(n) = Least unitary prime divisor of n or 1 if no such prime-divisor exists.", "sequence": "1,2,3,1,5,2,7,1,1,2,11,3,13,2,3,1,17,2,19,5,3,2,23,3,1,2,1,7,29,2,31,1,3,2,5,1,37,2,3,5,41,2,43,11,5,2,47,3,1,2,3,13,53,2,5,7,3,2,59,3,61,2,7,1,5,2,67,17,3,2,71,1,73,2,3,19,7,2,79,5,1,2,83,3,5,2,3,11,89,2,7,23,3,2,5,3,97,2,11,1,101,2,103,13,3", "code": "\nfrom sympy import factorint, prime, primepi, isprime, primefactors\ndef a049084(n): return primepi(n)*(1*isprime(n))\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef a028234(n):\n    f = factorint(n)\n    return 1 if n==1 else n/(min(f)**f[min(f)])\ndef a067029(n):\n    f=factorint(n)\n    return 0 if n==1 else f[min(f)]\ndef a277697(n): return 0 if n==1 else a055396(n) if a067029(n)==1 else a277697(a028234(n))\ndef a008578(n): return 1 if n==1 else prime(n - 1)\ndef a(n): return a008578(1 + a277697(n)) \n"}
{"sequence_id": "A277707", "text": "a(n) = index of the least prime divisor of n which has an odd exponent, or 0 if n is a perfect square.", "sequence": "0,1,2,0,3,1,4,1,0,1,5,2,6,1,2,0,7,1,8,3,2,1,9,1,0,1,2,4,10,1,11,1,2,1,3,0,12,1,2,1,13,1,14,5,3,1,15,2,0,1,2,6,16,1,3,1,2,1,17,2,18,1,4,0,3,1,19,7,2,1,20,1,21,1,2,8,4,1,22,3,0,1,23,2,3,1,2,1,24,1,4,9,2,1,3,1,25,1,5,0,26,1,27,1,2", "code": "\nfrom sympy import primepi, isprime, primefactors\nfrom sympy.ntheory.factor_ import core\ndef a049084(n): return primepi(n)*(1*isprime(n))\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef a(n): return a055396(core(n)) \n"}
{"sequence_id": "A277708", "text": "a(n) = Least prime divisor of n with an odd exponent, or 1 if n is a perfect square.", "sequence": "1,2,3,1,5,2,7,2,1,2,11,3,13,2,3,1,17,2,19,5,3,2,23,2,1,2,3,7,29,2,31,2,3,2,5,1,37,2,3,2,41,2,43,11,5,2,47,3,1,2,3,13,53,2,5,2,3,2,59,3,61,2,7,1,5,2,67,17,3,2,71,2,73,2,3,19,7,2,79,5,1,2,83,3,5,2,3,2,89,2,7,23,3,2,5,2,97,2,11,1,101,2,103,2,3", "code": "\nfrom sympy import primefactors\nfrom sympy.ntheory.factor_ import core\ndef lpf(n): return 1 if n==1 else primefactors(n)[0]\ndef a(n): return lpf(core(n)) \n"}
{"sequence_id": "A277828", "text": "Least number of tosses of a fair coin needed to have an even chance or better of getting a run of at least m consecutive heads or consecutive tails.", "sequence": "1,2,5,11,23,45,90,179,357,712,1422,2842,5681,11360,22716,45430,90856,181709,363413,726822,1453640,2907276,5814546,11629086,23258166,46516327,93032647", "code": "\ndef a(m):\n    if m == 1:\n        return 1\n    g = [2**i for i in range(1, m)]\n    sg, lim, n = sum(g), 2**(m-1), m\n    while True:\n        g.append(sg)\n        sg <<= 1\n        sg -= g.pop(0)\n        if g[-1] <= lim:\n            return n\n        lim <<= 1\n        n += 1\nprint([a(i) for i in range(1, 15)])\n\n"}
{"sequence_id": "A277885", "text": "a(n) = index of the least non-unitary prime divisor of n or 0 if no such prime-divisor exists.", "sequence": "0,0,0,1,0,0,0,1,2,0,0,1,0,0,0,1,0,2,0,1,0,0,0,1,3,0,2,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,2,0,0,1,4,3,0,1,0,2,0,1,0,0,0,1,0,0,2,1,0,0,0,1,0,0,0,1,0,0,3,1,0,0,0,1,2,0,0,1,0,0,0,1,0,2,0,1,0,0,0,1,0,4,2,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,2,0,0,1", "code": "\nfrom sympy import factorint, primepi, isprime, primefactors\ndef a049084(n): return primepi(n)*(1*isprime(n))\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef a028234(n):\n    f = factorint(n)\n    return 1 if n==1 else n/(min(f)**f[min(f)])\ndef a067029(n):\n    f=factorint(n)\n    return 0 if n==1 else f[min(f)]\ndef a(n): return 0 if n==1 else a055396(n) if a067029(n)>1 else a(a028234(n)) \n"}
{"sequence_id": "A277892", "text": "a(n) = A001222(A048675(n)).", "sequence": "0,1,1,2,1,3,1,2,1,4,2,5,2,2,2,6,1,7,2,2,1,8,1,3,2,2,2,9,1,10,1,3,2,3,2,11,2,2,1,12,1,13,3,3,1,14,2,4,2,3,2,15,1,3,1,3,4,16,3,17,3,3,2,4,1,18,3,3,1,19,1,20,2,2,3,4,2,21,3,3,2,22,3,3,2,2,1,23,2,4,3,5,3,4,1,24,1,3,2,25,1,26,2,2", "code": "\nfrom sympy import factorint, primepi, primefactors\ndef a001222(n): return 0 if n==1 else a001222(n//primefactors(n)[0]) + 1\ndef a048675(n):\n    if n==1: return 0\n    f=factorint(n)\n    return sum(f[i]*2**(primepi(i) - 1) for i in f)\ndef a(n): return a001222(a048675(n))\nprint([a(n) for n in range(2, 101)]) \n"}
{"sequence_id": "A277930", "text": "Array of coefficients a(k,n) of the formal power series A(k,x) read by upwards antidiagonals, where A(k,x) = ((2*k+1)*x+sqrt(1+4*k*(k+1)*x^2))/(1-x^2), k>=0.", "sequence": "1,1,1,1,3,1,1,5,5,1,1,7,13,3,1,1,9,25,5,-3,1,1,11,41,7,-59,3,1,1,13,61,9,-263,5,29,1,1,15,85,11,-759,7,805,3,1,1,17,113,13,-1739,9,6649,5,-131,1,1,19,145,15,-3443,11,31241,7,-12155,3,1,1,21,181,17,-6159,13,106261,9,-200711,5,765,1", "code": "\nfrom sympy import catalan\ndef A(k, n): return 1 if n==0 else 1 - 2*sum([catalan(i)*(-k*(k + 1))**(i + 1) for i in range(n/2)]) if n%2==0 else 2*k + 1\nfor n in range(13): print [A(n - k, k) for k in range(n + 1)] \n"}
{"sequence_id": "A277937", "text": "Number of runs of 1's of length 1 in the binary expansion of n.", "sequence": "0,1,1,0,1,2,0,0,1,2,2,1,0,1,0,0,1,2,2,1,2,3,1,1,0,1,1,0,0,1,0,0,1,2,2,1,2,3,1,1,2,3,3,2,1,2,1,1,0,1,1,0,1,2,0,0,0,1,1,0,0,1,0,0,1,2,2,1,2,3,1,1,2,3,3,2,1,2,1,1,2,3,3,2,3,4,2", "code": "\ndef A277937(n):\n    return sum(1 for d in bin(n)[2:].split('0') if len(d) == 1)\n"}
{"sequence_id": "A278049", "text": "a(n) = 3*(Sum_{k=1..n} phi(k)) - 1, where phi = A000010.", "sequence": "2,5,11,17,29,35,53,65,83,95,125,137,173,191,215,239,287,305,359,383,419,449,515,539,599,635,689,725,809,833,923,971,1031,1079,1151,1187,1295,1349,1421,1469,1589,1625,1751,1811,1883,1949,2087,2135,2261,2321,2417,2489,2645,2699,2819,2891,2999", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A278049(n): \n    if n == 0:\n        return -1\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*(2*A278049(k1)-1)//3\n        j, k1 = j2, n//j2\n    return 3*(n*(n-1)-c+j)//2 - 1 \n"}
{"sequence_id": "A278116", "text": "a(n) is the largest j such that A278115(n,k) strictly decreases for k=1..j.", "sequence": "1,2,3,3,4,3,2,2,5,4,4,2,2,3,3,5,3,2,2,4,3,3,2,2,3,4,6,6,2,3,4,3,3,2,2,3,5,4,4,2,4,3,4,3,2,2,3,4,3,2,2,4,3,4,3,2,2,3,4,3,2,2,3,3,5,3,2,2,4,5,4,2,2,3,3,4,3,2,3,4,7,5,2,2,3,4,2,2,2,3,5,5,5,2,2,3,4,3,2,2,4,5,3,3,2", "code": "\ndef isqrt(n):\n    if n < 0:\n        raise ValueError('imaginary')\n    if n == 0:\n        return 0\n    a, b = divmod(n.bit_length(),2)\n    x = 2**(a+b)\n    while True:\n        y = (x + n//x)//2\n        if y >= x:\n            return x\n        x = y;\ndef next_prime(n):\n    for p in range(n+1,2*n+1):\n        for i in range(2,isqrt(n)+1):\n            if p % i == 0:\n                break\n        else:\n            return p\n    return None\ndef A278116(n):\n    k = 0\n    p = 2\n    s2= (n**2)*p\n    s = s2\n    while True:\n        s_= s\n        k+= 1\n        p = next_prime(p)\n        s = (isqrt(s2//p)**2)*p\n        if s > s_:\n            break\n    return k\n"}
{"sequence_id": "A278161", "text": "Run length transform of A008619 (floor(n/2)+1).", "sequence": "1,1,1,2,1,1,2,2,1,1,1,2,2,2,2,3,1,1,1,2,1,1,2,2,2,2,2,4,2,2,3,3,1,1,1,2,1,1,2,2,1,1,1,2,2,2,2,3,2,2,2,4,2,2,4,4,2,2,2,4,3,3,3,4,1,1,1,2,1,1,2,2,1,1,1,2,2,2,2,3,1,1,1,2,1,1,2,2,2,2,2,4,2,2,3,3,2,2,2,4,2,2,4,4,2,2,2,4,4,4,4,6,2,2,2,4,2,2,4,4,3", "code": "\ndef A278161(n): return sum(int(not (~(n+3*k) & 6*k) | (~n & k)) for k in range(n+1)) \n"}
{"sequence_id": "A278211", "text": "Maximum total number of possible moves that any number of rooks of the same color can make on an n X n chessboard.", "sequence": "0,4,12,28,48,76", "code": " \n"}
{"sequence_id": "A278212", "text": "Maximum total number of possible moves that any number of bishops of the same color can make on an n X n chessboard.", "sequence": "0,2,8,20,38,64", "code": " \n"}
{"sequence_id": "A278219", "text": "Filter-sequence related to base-2 run length encoding: a(n) = A046523(A243353(n)).", "sequence": "1,2,4,2,4,8,6,2,4,12,16,8,6,12,6,2,4,12,36,12,16,32,24,8,6,30,24,12,6,12,6,2,4,12,36,12,36,72,60,12,16,48,64,32,24,72,24,8,6,30,60,30,24,48,60,12,6,30,24,12,6,12,6,2,4,12,36,12,36,72,60,12,36,180,144,72,60,180,60,12,16,48,144,48,64,128,96,32,24,120,216,72,24,72", "code": "\nfrom sympy import prime, factorint\nimport math\ndef A(n): return n - 2**int(math.floor(math.log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a005940(n): return b(n - 1)\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a003188(n): return n^int(n/2)\ndef a243353(n): return a005940(1 + a003188(n))\ndef a(n): return a046523(a243353(n)) \n"}
{"sequence_id": "A278222", "text": "Filter-sequence for unary-binary encoding of prime factorization: least number with the same prime signature as A005940(n+1).", "sequence": "1,2,2,4,2,6,4,8,2,6,6,12,4,12,8,16,2,6,6,12,6,30,12,24,4,12,12,36,8,24,16,32,2,6,6,12,6,30,12,24,6,30,30,60,12,60,24,48,4,12,12,36,12,60,36,72,8,24,24,72,16,48,32,64,2,6,6,12,6,30,12,24,6,30,30,60,12,60,24,48,6,30,30,60,30,210,60,120,12,60,60,180,24,120,48,96,4,12,12", "code": "\nfrom sympy import prime, factorint\nimport math\ndef A(n): return n - 2**int(math.floor(math.log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a005940(n): return b(n - 1)\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return a046523(a005940(n + 1)) \n"}
{"sequence_id": "A278223", "text": "Least number with the same prime signature as the n-th odd number: a(n) = A046523(2n-1).", "sequence": "1,2,2,2,4,2,2,6,2,2,6,2,4,8,2,2,6,6,2,6,2,2,12,2,4,6,2,6,6,2,2,12,6,2,6,2,2,12,6,2,16,2,6,6,2,6,6,6,2,12,2,2,30,2,2,6,2,6,12,6,4,6,8,2,6,2,6,24,2,2,6,6,6,12,2,2,12,6,2,6,6,2,30,2,4,12,2,12,6,2,2,6,6,6,24,2,2,30,2,2,6,6,6,12,6,2,6,6,6,6,6,2,36,2,2", "code": "\nfrom sympy import factorint\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return a046523(2*n - 1) \n"}
{"sequence_id": "A278224", "text": "a(n) = A046523(A048673(n)).", "sequence": "1,2,2,2,4,8,6,6,2,2,2,2,4,2,12,2,6,6,12,32,12,12,6,12,4,6,12,12,16,2,2,6,6,2,6,2,6,6,2,6,6,2,24,2,24,12,8,6,2,6,48,6,30,12,6,2,6,2,2,6,6,24,30,6,60,12,36,6,2,12,2,12,24,6,6,24,72,128,30,12,2,6,12,24,2,2,30,48,4,2,6,2,6,48,16,96,6,30,2,6,12,6,24,30,2,2,6", "code": "\nfrom sympy import factorint, nextprime\nfrom operator import mul\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a048673(n):\n    f = factorint(n)\n    return 1 if n==1 else (1 + reduce(mul, [nextprime(i)**f[i] for i in f]))//2\ndef a(n): return a046523(a048673(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A278348", "text": "Number of 2 X 2 singular integer matrices with elements from {0,...,n} with no elements repeated.", "sequence": "0,0,0,0,0,0,16,16,32,40,72,72,136,136,184,248,304,304,408,408,536,632,712,712,920,968,1064,1168,1360,1360,1664,1664,1848,2008,2136,2328,2696,2696,2840,3032,3432,3432,3880,3880,4200,4592,4768,4768,5336,5456,5824", "code": "\ndef p(n):\n    s=0\n    for a in range(n+1):\n        for b in range(n+1):\n            for c in range(n+1):\n                for d in range(n+1):\n                    if (a!=b  and a!=d and b!=d and c!=a and c!=b and c!=d):\n                        if a*d==b*c:\n                            s+=1\n    return s\nfor i in range(101):\n    print(str(i)+\" \"+str(p(i)))\n"}
{"sequence_id": "A278377", "text": "Number of 2 X 2 matrices with all elements in {0,1,...,n} and determinant n with no elements repeated.", "sequence": "0,0,0,4,8,16,40,36,72,60,128,92,232,144,260,284,332,252,564,324,680,568,696,492,1184,628,984,964,1392,796,1920,924,1820,1512,1752,1568,2820,1380,2244,2104,3340,1660,3864,1900,3544,3388,3300,2264,5652,2632,4616", "code": "\ndef p(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            for c in range(0,n+1):\n                for d in range(0,n+1):\n                    if (a!=b  and a!=d and b!=d and c!=a and c!=b and c!=d):\n                        if a*d-b*c==n:\n                            s+=1\n    return s\nfor i in range(0,101):\n    print str(i)+\" \"+str(p(i)) \\\\ _Indranil Ghosh_, Nov 20, 2016\n"}
{"sequence_id": "A278417", "text": "a(n) = n*((2+sqrt(3))^n + (2-sqrt(3))^n)/2.", "sequence": "0,2,14,78,388,1810,8106,35294,150536,632034,2620870,10759342,43804812,177105266,711809378,2846259390,11330543632,44929049794,177540878718,699402223118,2747583822740,10766828545746,42095796462874,164244726238366,639620518118424,2486558615814050,9651161613824822,37403957244654702", "code": "\nimport math\ndef p(n):\n    m=math.sqrt(3)\n    n=float(n)\n    x=2+m\n    y=2-m\n    return round((n/2)*(x**n+y**n),0)\nfor i in range(3,531):\n    print str(i)+\"  \"+str(int(p(i))) \\\\_Indranil Ghosh_, Nov 21 2016\n"}
{"sequence_id": "A278585", "text": "Numbers k such that k+1 is a prime, k+2 is twice a prime, k+3 is three times a prime, and k+4 is four times a prime.", "sequence": "12720,16920,19440,24480,49680,61560,104160,229320,255360,259680,266400,291720,298200,311040,331920,419400,423480,436800,446880,471240,525240,532800,539400,581520,600600,663600,704160,709920,783720,867000,904800,908040,918360", "code": "\nfrom sympy import prime, isprime\nA278585_list = [4*q-4 for q in (prime(i) for i in range(1,10000)) if isprime(4*q-3) and isprime(2*q-1) and (not (4*q-1) % 3) and isprime((4*q-1)//3)] \n"}
{"sequence_id": "A278677", "text": "Popularity of left children in treeshelves avoiding pattern T231.", "sequence": "1,5,23,109,544,2876,16113,95495,597155,3929243,27132324,196122796,1480531285,11647194573,95297546695,809490850313,7126717111964,64930685865768,611337506786061,5940420217001199,59502456129204083,613689271227219015,6510381400140132872", "code": "\n\nfrom sympy import bell\nHOW_MANY = 30\nprint([(n + 1) * bell(n) - bell(n + 1) for n in range(HOW_MANY)])\n"}
{"sequence_id": "A278677", "text": "Popularity of left children in treeshelves avoiding pattern T231.", "sequence": "1,5,23,109,544,2876,16113,95495,597155,3929243,27132324,196122796,1480531285,11647194573,95297546695,809490850313,7126717111964,64930685865768,611337506786061,5940420217001199,59502456129204083,613689271227219015,6510381400140132872", "code": "\n\nfrom sympy import *\nfrom sympy.abc import z\nbell = exp( exp (z) - 1)\nh = (z * exp (z) - exp (z) + 1) * bell\nNUMBER_OF_COEFFS = 8\ncoeffs = Poly(series(h,n = NUMBER_OF_COEFFS)).coeffs()\ncoeffs.reverse()\n\ncoeffs.pop(0)\nprint([coeffs[n]*factorial(n+2) for n in range(len(coeffs))])\n"}
{"sequence_id": "A278678", "text": "Popularity of left children in treeshelves avoiding pattern T321.", "sequence": "1,4,19,94,519,3144,20903,151418,1188947,10064924,91426347,887296422,9164847535,100398851344,1162831155151,14198949045106,182317628906283,2455925711626404,34632584722468115,510251350142181470,7840215226100517191,125427339735162102104", "code": "\n\nfrom sympy import *\nfrom sympy.abc import z\nh = (-sin(z) + 1 + (z-1)*cos(z))/ (1-sin(z))**2\nNUMBER_OF_COEFFS = 20\ncoeffs = Poly(series(h,n = NUMBER_OF_COEFFS)).coeffs()\ncoeffs.reverse()\n\ncoeffs.pop(0)\nprint([coeffs[n]*factorial(n+2) for n in range(len(coeffs))])\n"}
{"sequence_id": "A278679", "text": "Popularity of left children in treeshelves avoiding pattern T213.", "sequence": "1,5,24,128,770,5190,38864,320704,2894544,28382800,300575968,3419882304,41612735632,539295974000,7417120846080,107904105986048,1655634186628352,26721851169634560,452587550053179392,8026445538106839040,148751109541600495104", "code": "\n\nfrom sympy import *\nfrom sympy.abc import z\nh = (exp(sqrt(2)*z) * (4*z-4) - (sqrt(2)-2)*exp(2*sqrt(2)*z) + sqrt(2) + 2) / ((sqrt(2)-2)*exp(sqrt(2)*z) + 2 + sqrt(2))**2\nNUMBER_OF_COEFFS = 20\ncoeffs = Poly(series(h,n = NUMBER_OF_COEFFS)).coeffs()\ncoeffs.reverse()\n\ncoeffs.pop(0)\nprint([coeffs[n]*factorial(n+2) for n in range(len(coeffs))])\n"}
{"sequence_id": "A278736", "text": "Number of size-4 cliques in all simple labeled graphs on n nodes.", "sequence": "1,80,7680,1146880,293601280,135291469824,115448720916480,185773484629032960,570696144780389253120,3376492035251796327792640,38724311853895801724188229632,865171534655766566521499937669120", "code": "\nimport math\nf=math.factorial\ndef C(n,r): return f(n)/f(r)/f(n-r)\ndef A278736(n): return C(n,4)*2**(C(n,2)-6) \n"}
{"sequence_id": "A278761", "text": "a(n) is the number of parallelepipeds with vertices with integer coordinates between 0 and n and diagonals from one corner to the opposite corner with an integer length.", "sequence": "0,0,1,1,1,1,2,4,5,6,6,7,10,10,11,12,15,16,19,20,23,25,28,30,33,35,38,40,44,47,52,54,57,59,63,65,71,73,79,81,86,89,98,101,106,108,114,117,126,130,137,142,147,150,159,162,173,178,182", "code": "\ndef coprime(k,m,n):\n    while m:\n        k,m=m,k%m\n    if k==1:return 1\n    while k:\n        n,k=k,n%k\n    return n\noeis=[0]\nfor n in range(n):\n    kv=[i**2 for i in range(2*n)]\n    pyt=[]\n    for a in range(1,n):\n        for b in range(a,n+1):\n            for c in range(b,n+1):\n                if a**2+b**2+c**2 in kv and coprime(a,b,c)==1:\n                    pyt.append([a,b,c,int((a**2+b**2+c**2)**0.5+0.1)])\n    oeis.append(len(pyt))\nprint(pyt)\n"}
{"sequence_id": "A278846", "text": "Number of unimodular 2 X 2 matrices having entries in {0,1,...,n} with no entry repeated.", "sequence": "0,0,0,0,0,8,8,40,48,80,88,152,160,232,264,304,344,448,480,608,648,720,784,944,968,1104,1176,1304,1376,1576,1616,1840,1944,2080,2184,2352,2424,2688,2816,2984,3072,3368,3440,3760,3896,4064,4224,4576,4664,4984,5120", "code": "\ndef t(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            for c in range(0,n+1):\n                for d in range(0,n+1):\n                    if (a!=b  and a!=d and b!=d and c!=a and c!=b and c!=d):\n                        if abs(a*d-b*c)==1:\n                            s+=1\n    return s\nfor i in range(0,242):\n    print str(i)+\" \"+str(t(i)) \\\\ _Indranil Ghosh_ , Nov 29 2016\n"}
{"sequence_id": "A278902", "text": "Number of 2 X 2 matrices with entries in {0,1,...,n} with determinant = trace and no entry repeated.", "sequence": "0,0,0,0,0,8,12,24,28,40,48,68,72,100,120,132,144,188,208,252,280,304,336,396,416,464,512,556,592,668,704,776,844,900,960,1020,1056,1148,1240,1308,1348,1456,1524,1628,1728,1792,1872,2004,2080,2188,2292", "code": "\ndef t(n):\n    s=0\n    for a in range(n+1):\n        for b in range(n+1):\n            for c in range(n+1):\n                for d in range(n+1):\n                    if (a!=b and a!=d and b!=d and c!=a and c!=b and c!=d):\n                        if (a*d-b*c)==a+d:\n                            s+=1\n    return s\nfor i in range(241):\n    print(str(i)+\" \"+str(t(i)))\n"}
{"sequence_id": "A278909", "text": "Binary Smith numbers: composite numbers n such that sum of bits of n = sum of bits of prime factors of n (counted with multiplicity).", "sequence": "15,51,55,85,125,159,185,190,205,215,222,238,246,249,253,287,303,319,374,407,438,442,469,471,475,489,494,501,507,591,623,639,670,679,687,699,730,745,755,763,765,771,799,807,822,830,843,867,890,893,917,923,925,935,939,951,970,973,979,986,989,995,1010,1015,1017,1020,1023,1135,1167,1203,1243", "code": "\nfrom sympy import factorint\ndef sbd(n): return bin(n).count('1')\ndef ok(n):\n  f = factorint(n)\n  return sum(f[p] for p in f) > 1 and sbd(n) == sum(sbd(p)*f[p] for p in f)\nprint(list(filter(ok, range(1244)))) \n"}
{"sequence_id": "A278933", "text": "Number of 2 X 2 matrices with entries in {0,1,...,n} and permanent = trace with no entry repeated.", "sequence": "0,0,0,0,0,0,4,4,8,8,12,12,20,20,24,28,32,32,40,40,48,52,56,56,68,68,72,76,84,84,96,96,104,108,112,116,128,128,132,136,148,148,160,160,168,176,180,180,196,196,204", "code": "\ndef t(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            for c in range(0,n+1):\n                for d in range(0,n+1):\n                    if (a!=b  and a!=d and b!=d and c!=a and c!=b and c!=d):\n                        if (a*d+b*c)==a+d:\n                            s+=1\n    return s\nfor i in range(0,286):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A278959", "text": "Length of the string that is generated by the concatenation of all the prime numbers < n (where n >= 0).", "sequence": "0,0,0,1,2,2,3,3,4,4,4,4,6,6,8,8,8,8,10,10,12,12,12,12,14,14,14,14,14,14,16,16,18,18,18,18,18,18,20,20,20,20,22,22,24,24,24,24,26,26,26,26,26,26,28,28,28,28,28,28,30", "code": "\ndef p(n):\n    if n<=2:\n        return 0\n    s=1\n    l = [True] * n\nfor i in range(3,int(n**0.5)+1,2):\n        if l[i]:\n            l[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1)\nfor i in range(3,n,2):\n            if l[i]:\n                s+=len(str(i))\n    return s\nfor i in range(0,100001):\n    print str(i)+\" \"+str(p(i))\n"}
{"sequence_id": "A279014", "text": "a(n) = Sum_{k=0..n} fibonacci(k+1)*binomial(2*n-1,n-k).", "sequence": "1,2,8,33,138,581,2455,10395,44068,186953,793453,3368279,14300161,60713627,257763847,1094294875,4645306802,19717723173,83687094899,355155267179,1507078468075,6394577650959,27129846069301,115091608301743", "code": "\nfrom sympy import binomial, fibonacci\ndef a(n): return sum([fibonacci(k + 1)*binomial(2*n - 1, n - k) for k in range(n + 1)])\nprint([a(n) for n in range(24)]) \n"}
{"sequence_id": "A279018", "text": "Number of 2 X 2 matrices having entries in {-n,...,0,..,n} and permanent=trace with no entry repeated.", "sequence": "0,0,8,24,56,100,156,236,320,408,540,692,844,1044,1228,1368,1592,1884,2180,2500,2764,2996,3356,3756,4080,4456,4884,5276,5740,6252,6740,7316,7868,8340,8860,9352,9896,10628,11324", "code": "\ndef t(n):\n    s=0\n    for a in range(-n,n+1):\n        for b in range(-n,n+1):\n            for c in range(-n,n+1):\n                for d in range(-n,n+1):\n                   if (a!=b  and a!=d and b!=d and c!=a and c!=b and c!=d):\n                        if (a*d+b*c)==a+d:\n                            s+=1\n    return s\nfor i in range(0,151):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A279063", "text": "Number of 2 X 2 matrices having entries in {0,1,...,n} and determinant in the closed interval [-n,n] with no entry repeated.", "sequence": "0,0,0,16,56,136,296,512,864,1280,1912,2616,3680,4760,6200,7848,9792,11832,14632,17280,20784,24352,28480,32584,38200,43168,49160,55472,62936,69784,79008,86944,96952,106816,117672,128592,142352,154088,167968", "code": "\ndef t(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            for c in range(0,n+1):\n                for d in range(0,n+1):\n                   if (a!=b  and a!=d and b!=d and c!=a and c!=b and c!=d):\n                        if (a*d-b*c) in range(-n,n+1):\n                            s+=1\n    return s\nfor i in range(0,151):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A279169", "text": "a(n) = floor( 4*n^2/5 ).", "sequence": "0,0,3,7,12,20,28,39,51,64,80,96,115,135,156,180,204,231,259,288,320,352,387,423,460,500,540,583,627,672,720,768,819,871,924,980,1036,1095,1155,1216,1280,1344,1411,1479,1548,1620,1692,1767,1843,1920,2000,2080,2163,2247", "code": " [int(4*n**2/5) for n in range(60)]\n"}
{"sequence_id": "A279204", "text": "Numbers whose decimal expansion is a concatenation of 4 consecutive increasing nonnegative numbers.", "sequence": "1234,2345,3456,4567,5678,6789,78910,891011,9101112,10111213,11121314,12131415,13141516,14151617,15161718,16171819,17181920,18192021,19202122,20212223,21222324,22232425,23242526,24252627,25262728,26272829,27282930,28293031,29303132,30313233,31323334", "code": "\ndef A279204(n):\n    return int(str(n)+str(n+1)+str(n+2)+str(n+3)) \n"}
{"sequence_id": "A279213", "text": "Primes formed by concatenating n with n-3.", "sequence": "41,107,1613,2017,3229,4441,4643,5653,7673,9491,106103,116113,124121,130127,136133,170167,172169,182179,184181,196193,206203,212209,214211,220217,224221,230227,272269,274271,280277,302299,304301,320317,322319,326323,334331", "code": "\nfrom sympy import isprime\ni=4\nj=1\nwhile j<=10000:\n....if isprime(int(str(i)+str(i-3)))==True:\n........print str(j)+\" \"+str(i)+str(i-3)\n........j+=1\n....i+=1 \n"}
{"sequence_id": "A279260", "text": "Numbers which are cyclops palindromic in their binary reflected Gray code representation.", "sequence": "0,6,18,90,330,1386,5418,21930,87210,349866,1397418,5593770,22366890,89483946,357903018,1431677610,5726579370,22906579626,91625794218,366504225450,1466014804650,5864063412906,23456245263018,93824997829290,375299957762730,1501199898159786,6004799458421418", "code": "\ndef a(n):\n....return (-2*(1+((-2)**n)-(2**(2*n+1))))/3\n"}
{"sequence_id": "A279273", "text": "Number of 2 X 2 matrices having entries in {0,1,...,n} and determinant in the open interval (-n,n) with no entry repeated.", "sequence": "0,0,0,8,40,104,216,440,720,1160,1656,2432,3216,4472,5680,7280,9128,11328,13504,16632,19424,23216,27088,31600,35832,41912,47192,53544,60152,68192,75168", "code": "\ndef t(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            for c in range(0,n+1):\n                for d in range(0,n+1):\n                   if (a!=b  and a!=d and b!=d and c!=a and c!=b and c!=d):\n                        if (a*d-b*c) in range(-n+1,n):\n                            s+=1\n    return s\nfor i in range(0,122):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A279363", "text": "Sum of 4th powers of proper divisors of n.", "sequence": "0,1,1,17,1,98,1,273,82,642,1,1650,1,2418,707,4369,1,7955,1,10898,2483,14658,1,26482,626,28578,6643,41090,1,62644,1,69905,14723,83538,3027,133923,1,130338,28643,174994,1,236692,1,249170,57893,279858,1,423794,2402,401267,83603,485810,1,644372,15267,659842,130403,707298,1,1053636", "code": "\nfrom sympy.ntheory import divisor_sigma\nprint([divisor_sigma(n,4) - n**4 for n in range(1,61)]) \n"}
{"sequence_id": "A279364", "text": "Sum of 5th powers of proper divisors of n.", "sequence": "0,1,1,33,1,276,1,1057,244,3158,1,9076,1,16840,3369,33825,1,67101,1,104182,17051,161084,1,290676,3126,371326,59293,555688,1,870552,1,1082401,161295,1419890,19933,2206525,1,2476132,371537,3336950,1,4646784,1,5315740,821793,6436376,1,9301876,16808,9868783", "code": "\nfrom sympy.ntheory import divisor_sigma\nprint([divisor_sigma(n,5) - n**5 for n in range(1,51)]) \n"}
{"sequence_id": "A279409", "text": "Triangle read by rows: T(n,m) (n>=m>=1) = maximum number of nonattacking kings on an n X m toroidal board.", "sequence": "1,1,1,1,1,1,2,2,2,4,2,2,2,4,5,3,3,3,6,6,9,3,3,3,6,7,9,10,4,4,4,8,8,12,12,16,4,4,4,8,9,12,13,16,18,5,5,5,10,10,15,15,20,20,25,5,5,5,10,11,15,16,20,22,25,27,6,6,6,12,12,18,18,24,24,30,30,36", "code": "\ndef T(n,m):\n....if m==1:\n........if n==1: return 1\n........return n/2\n....return min(m*(n/2), n*(m/2))/2\ni=1\nfor n in range(1,126):\n....for m in range(1, n+1):\n........print str(i)+\" \"+str(T(n,m))\n........i+=1 \n"}
{"sequence_id": "A279430", "text": "Numbers k such that k^2 has an odd number of digits in base 2 and the middle digit is 0.", "sequence": "0,2,4,5,8,9,10,16,17,18,19,22,32,33,34,35,36,37,40,41,44,64,65,66,67,68,69,70,71,76,77,80,81,84,85,87,90,128,129,130,131,132,133,134,135,136,137,138,139,144,145,146,147,151,152,153,156,157,160,161,164", "code": "\ni=0\nj=1\nwhile i<=164:\n    n=str(bin(i**2)[2:])\n    l=len(n)\n    if l%2 and n[(l-1)//2]==\"0\":\n        print(str(i), end=\",\")\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A279431", "text": "Numbers k such that k^2 has an odd number of digits in base 2 and the middle digit is 1.", "sequence": "1,11,20,21,38,39,42,43,45,72,73,74,75,78,79,82,83,86,88,89,140,141,142,143,148,149,150,154,155,158,159,162,163,166,167,169,170,172,173,175,178,180,181,272,273,274,275,276,277,278,284,285,286,287,292,293", "code": "\ni=0\nj=1\nwhile i<=293:\n    n=str(bin(i**2)[2:])\n    l=len(n)\n    if l%2 and n[(l-1)//2]==\"1\":\n        print(str(i), end=\",\")\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A279436", "text": "Number of nonprimes less than or equal to n that do not divide n.", "sequence": "0,0,0,0,1,1,2,1,3,4,5,3,6,6,7,6,9,7,10,8,11,12,13,9,14,15,15,15,18,15,19,16,20,21,22,18,24,24,25,22,27,24,28,26,27,30,31,25,32,31,34,33,36,32,37,34,39,40,41,34,42,42,41,40,45,43,47,45,48,46,50,42,51,51,50,51,54,52,56,50,55,58,59,52,60,61,62,59,64,57,65,64,67,68,69,62,71,69,70,68", "code": "\nfrom sympy import primepi, divisor_count, primefactors\ndef a(n): return 0 if n==1 else n - primepi(n) - divisor_count(n) + len(primefactors(n)) \n"}
{"sequence_id": "A279483", "text": "Number of 2 X 2 matrices with entries in {0,1,...,n} and odd determinant with no entry repeated.", "sequence": "0,0,0,8,24,144,240,672,960,2000,2640,4680,5880,9408,11424,17024,20160,28512,33120,45000,51480,67760,76560,98208,109824,137904,152880,188552,207480,252000,275520,330240,359040,425408,460224,539784,581400,675792,725040,836000,893760,1023120,1090320,1240008", "code": "\ndef t(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            for c in range(0,n+1):\n                for d in range(0,n+1):\n                   if (a!=b  and a!=d and b!=d and c!=a and c!=b and c!=d):\n                        if (a*d-b*c)%2==1:\n                            s+=1\n    return s\nfor i in range(0,201):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A279506", "text": "Total number of 1's in the binary expansion of A003418.", "sequence": "1,1,1,2,2,4,4,4,4,6,6,6,6,12,12,12,12,12,12,12,12,12,12,14,14,21,21,18,18,17,17,22,22,22,22,22,22,28,28,28,28,25,25,32,32,32,32,40,40,40,40", "code": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\ndef lcm(a, b):\n    return a * b // gcd(a, b)\ndef c(*ar):\n    return reduce(lcm, ar)\ndef a(n):\n    if n==0:\n        return 1\n    x=bin(c(*range(1,n+1)))[2:]\n    return x.count(\"1\")\nfor i in range(0,10001):\n    print str(i)+\" \"+str(a(i))\n"}
{"sequence_id": "A279512", "text": "Sierpinski octahedron numbers a(n) = 2*6^n + 3*2^n + 1.", "sequence": "6,19,85,457,2641,15649,93505,560257,3360001,20156929,120935425,725600257,4353576961,26121412609,156728377345,940370067457,5642220011521,33853319282689,203119914123265,1218719481593857,7312316883271681,43873901287047169,263243407697117185", "code": "\ndef a(n): return 2*6**n + 3*2**n + 1\nprint([a(n) for n in range(23)]) \n"}
{"sequence_id": "A279515", "text": "Number of 0's in the binary expansion of the least common multiple of the first n integers.", "sequence": "0,0,1,1,2,2,2,5,6,6,6,9,9,7,7,7,8,12,12,16,16,16,16,19,19,14,14,19,19,25,25,25,26,26,26,26,26,25,25,25,25,33,33,32,32,32,32,29,29,32,32,32,32,35,35,35,35,35,35,46,46,45", "code": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\ndef lcm(a, b):\n    return a * b // gcd(a, b)\ndef c(*ar):\n    return reduce(lcm, ar)\ndef a(n):\n    if n==0:\n        return 0\n    x=bin(c(*range(1, n+1)))[2:]\n    return x.count(\"0\")\nfor i in range(0, 10001):\n    print str(i)+\" \"+str(a(i))\n"}
{"sequence_id": "A279521", "text": "Maximum number of single-direction edges in leveled binary trees with n nodes.", "sequence": "0,1,1,2,3,3,3,4,5,6,7,7,7,7,7,8,9,10,11,12,13,14,15,15,15,15,15,15,15,15,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,32,33,34,35,36,37,38", "code": "\nclass Max(object):\n    def a(n):\n    h = math.floor(math.log(n) / math.log(2))\n    p2h = math.pow(2, h)\n    p2h_1 = math.pow(2, h - 1)\n    hs = Max.heaviside(-n + 3 * p2h_1 - 1)\n    return ((n + p2h_1 - 1) * hs + math.pow(-1, hs) * (p2h - 1))\n    a = staticmethod(a)\n    def heaviside(x):\n    return 1 if x >= 0 else 0\n    heaviside = staticmethod(heaviside)\n\n"}
{"sequence_id": "A279607", "text": "Beatty sequence for e/2; i.e., a(n) = floor(n*e/2).", "sequence": "1,2,4,5,6,8,9,10,12,13,14,16,17,19,20,21,23,24,25,27,28,29,31,32,33,35,36,38,39,40,42,43,44,46,47,48,50,51,53,54,55,57,58,59,61,62,63,65,66,67,69,70,72,73,74,76,77,78,80,81,82,84,85,86,88,89", "code": "\nimport math\nfrom mpmath import mp\nmp.dps=100\nprint([int(math.floor(n*e/2)) for n in range(1, 101)]) \n"}
{"sequence_id": "A279608", "text": "Beatty sequence for e/(e - 2); i.e., a(n) = floor(n*e/(e - 2)).", "sequence": "3,7,11,15,18,22,26,30,34,37,41,45,49,52,56,60,64,68,71,75,79,83,87,90,94,98,102,105,109,113,117,121,124,128,132,136,140,143,147,151,155,158,162,166,170,174,177,181,185,189,193,196,200,204,208,211,215", "code": "\nimport math\nfrom mpmath import*\nmp.dps=100\nprint([int(math.floor(n*e/(e - 2))) for n in range(1, 101)]) \n"}
{"sequence_id": "A279610", "text": "a(n) = concatenate n consecutive integers, starting with the last number of the previous batch.", "sequence": "1,12,234,4567,7891011,111213141516,16171819202122,2223242526272829,293031323334353637,37383940414243444546,4647484950515253545556,565758596061626364656667,67686970717273747576777879,7980818283848586878889909192", "code": "\nfrom __future__ import division\ndef A279610(n):\n    return int(''.join(str(d) for d in range((n-1)*(n-2)//2+1,n*(n-1)//2+2))) \n"}
{"sequence_id": "A279857", "text": "Prime numbers p with the property that p is the sum of the squares of two or more distinct one-digit numbers.", "sequence": "5,13,17,29,37,41,53,59,61,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,163,167,179,181,191,197,199,211,223,227,229,233,239,251,269,271,281", "code": "\nfrom sympy import isprime\nfrom itertools import chain, combinations\ndef powerset(s): \n  return chain.from_iterable(combinations(s, r) for r in range(2, len(s)+1))\ndef aupto(limit):\n  sosds = set(sum(ss) for ss in powerset([i**2 for i in range(1, 10)]))\n  return sorted(filter(isprime, (t for t in sosds if t <= limit)))\nprint(aupto(281)) \n"}
{"sequence_id": "A279895", "text": "a(n) = n*(5*n + 11)/2.", "sequence": "0,8,21,39,62,90,123,161,204,252,305,363,426,494,567,645,728,816,909,1007,1110,1218,1331,1449,1572,1700,1833,1971,2114,2262,2415,2573,2736,2904,3077,3255,3438,3626,3819,4017,4220,4428,4641,4859,5082,5310,5543,5781,6024,6272,6525", "code": " [n*(5*n+11)/2 for n in range(60)]\n"}
{"sequence_id": "A279905", "text": "Number of 2 X 2 matrices with entries in {0,1,...,n} and odd trace with no elements repeated.", "sequence": "0,0,0,16,72,216,480,960,1680,2800,4320,6480,9240,12936,17472,23296,30240,38880,48960,61200,75240,91960,110880,133056,157872,186576,218400,254800,294840,340200,389760,445440,505920,573376,646272,727056,813960,909720", "code": "\ndef t(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            if a!=b:\n                for c in range(0,n+1):\n                    if a!=c and b!=c:\n                        for d in range(0,n+1):\n                            if d!=a and d!=b and d!=c:\n                                if (a+d)%2==1:\n                                    s+=1\n    return s\nfor i in range(0,201):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A279905", "text": "Number of 2 X 2 matrices with entries in {0,1,...,n} and odd trace with no elements repeated.", "sequence": "0,0,0,16,72,216,480,960,1680,2800,4320,6480,9240,12936,17472,23296,30240,38880,48960,61200,75240,91960,110880,133056,157872,186576,218400,254800,294840,340200,389760,445440,505920,573376,646272,727056,813960,909720", "code": "\ndef a(x):\n    return ((x-3)*(x-2)*(2*x**2+(-1)**x-1))/4\n"}
{"sequence_id": "A279909", "text": "Number of steps to reach 1 or a cycle in the Collatz-like problem '3x/2' and '(x-1)/2'.", "sequence": "0,2,1,3,3,3,2,8,3,4,4,7,4,6,3,11,9,6,4,15,5,12,5,11,8,6,5,7,7,14,4,18,11,10,10,11,7,9,5,11,16,6,6,15,13,12,6,17,12,9,9,11,7,11,6,19,8,8,8,11,15,14,5,24,19,14,11,13,11,13,11,16,12,8,8,10,10,10,6,16,11,17,17,18,7,26,7,24,16,11,14,13,13,15,7,23,18,14,13,23", "code": "\ndef a(n):\n    if n==1: return 0\n    l=[n, ]\n    while True:\n        if n%2==0: n=(n/2)*3\n        else: n = (n - 1)/2\n        if not n in l:\n            l+=[n, ]\n            if n<2: break\n        else: break\n    if l[-1]==1: return len(l)-1\n    return len(l)\nfor n in range(1, 20001):\n    print str(n)+\" \"+str(a(n)) \n"}
{"sequence_id": "A280013", "text": "Numbers n such that sum of squarefree divisors of n > sum of squarefree divisors of m for all m < n.", "sequence": "1,2,3,5,6,10,14,21,22,26,30,42,66,78,102,114,130,138,170,174,186,210,318,330,390,462,510,546,570,690,798,858,870,930,1110,1218,1230,1290,1410,1554,1590,1722,1770,1830,1974,2010,2130,2190,2310,2730,3390,3570,3990,4290,4830,5610", "code": "\nfrom sympy.ntheory.factor_ import core\nfrom sympy import divisors\ndef s(n): return sum(list(filter(lambda i: core(i) == i, divisors(n))))\ndef ok(n):\n    m=1\n    while m<n:\n        if not s(n)>s(m): return False\n        m+=1\n    return True \n"}
{"sequence_id": "A280056", "text": "Number of 2 X 2 matrices with entries in {0,1,...,n} and even trace with no entries repeated.", "sequence": "0,0,0,8,48,144,360,720,1344,2240,3600,5400,7920,11088,15288,20384,26880,34560,44064,55080,68400,83600,101640,121968,145728,172224,202800,236600,275184,317520,365400,417600,476160,539648,610368,686664,771120,861840,961704,1068560,1185600", "code": "\ndef a(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            if a!=b:\n                for c in range(0,n+1):\n                    if a!=c and b!=c:\n                        for d in range(0,n+1):\n                            if d!=a and d!=b and d!=c:\n                                if (a+d)%2==0:\n                                    s+=1\n    return s\nfor i in range(0,201):\n    print str(i)+\" \"+str(a(i))\n"}
{"sequence_id": "A280056", "text": "Number of 2 X 2 matrices with entries in {0,1,...,n} and even trace with no entries repeated.", "sequence": "0,0,0,8,48,144,360,720,1344,2240,3600,5400,7920,11088,15288,20384,26880,34560,44064,55080,68400,83600,101640,121968,145728,172224,202800,236600,275184,317520,365400,417600,476160,539648,610368,686664,771120,861840,961704,1068560,1185600", "code": "\ndef A280056(x):\n    return -((x**2-5*x+6)*(-2*x**2+4*x+(-1)**x-1))/4\n"}
{"sequence_id": "A280056", "text": "Number of 2 X 2 matrices with entries in {0,1,...,n} and even trace with no entries repeated.", "sequence": "0,0,0,8,48,144,360,720,1344,2240,3600,5400,7920,11088,15288,20384,26880,34560,44064,55080,68400,83600,101640,121968,145728,172224,202800,236600,275184,317520,365400,417600,476160,539648,610368,686664,771120,861840,961704,1068560,1185600", "code": "\nfrom __future__ import division\ndef A280056(n):\n    return (n**2 - (n % 2))*(n-1)*(n-2)//2 \n"}
{"sequence_id": "A280058", "text": "Number of 2 X 2 matrices with entries in {0,1,...,n} with determinant = permanent with no entries repeated.", "sequence": "0,0,0,12,48,120,240,420,672,1008,1440,1980,2640,3432,4368,5460,6720,8160,9792,11628,13680,15960,18480,21252,24288,27600,31200,35100,39312,43848,48720,53940,59520,65472,71808,78540,85680,93240,101232,109668,118560", "code": "\ndef t(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            if a!=b:\n                for c in range(0,n+1):\n                    if a!=c and b!=c:\n                        for d in range(0,n+1):\n                            if d!=a and d!=b and d!=c:\n                                if (a*d-b*c)==(a*d+b*c):\n                                    s+=1\n    return s\nfor i in range(0,201):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A280062", "text": "a(n) = A049502(A000142(n)).", "sequence": "0,0,0,0,0,0,13,16,22,38,47,73,60,127,160,166,194,249,348,345,359,497,532,682,709,727,1000,887,1312,1155,1297,1934,2069,1722,1796,2148,2337,1839,2595,2774,2440,3314,3450,3253,3379,3786,4466,4366,4795,5189,5598", "code": "\nimport math\ndef m(N):\n    x=bin(int(N))[2:][::-1]\n    s=0\n    for i in range(1,len(x)):\n        if x[i-1]==\"1\" and x[i]==\"0\":\n            s+=i\n    return s\na=lambda n: m(math.factorial(n))\n"}
{"sequence_id": "A280191", "text": "Essential dimension of the spin group Spin_n over an algebraically closed field of characteristic different from 2.", "sequence": "0,0,4,5,5,4,5,6,6,7,23,24,120,103,341,326,814,793,1795,1780,3796,3771,7841,7818,15978,15949,32303,32304,65008,64975,130477,130446,261478,261441,523547,523516,1047756,1047715,2096249,2096210,4193314,4193269,8387527,8387496,16776040,16775991", "code": "\ndef a(n):\n    if n > 14:\n        if n%2 == 1:\n            return 2**((n-1)/2) - n*(n-1)/2\n        if n%4 == 2:\n            return 2**((n-2)/2) - n*(n-1)/2\n        if n%4 == 0:\n            return 2**((n-2)/2) - n*(n-1)/2 + biggestdivisor(n,2)\n    elif n >= 5:\n        return [0,0,4,5,5,4,5,6,6,7][n-5]\n    return \"Error\"\ndef biggestdivisor(n,d): \n    if n%d != 0:\n        return 1;\n    else:\n        return d*biggestdivisor(n/d, d);\n"}
{"sequence_id": "A280211", "text": "a(n) = n*(2^(n^2)).", "sequence": "0,2,32,1536,262144,167772160,412316860416,3940649673949184,147573952589676412928,21760664753063325144711168,12676506002282294014967032053760,29243015907268149203883755326167580672,267608942382367477698428619271780338071764992,9727754898074489823563726246559579778829887006048256", "code": " a=lambda n: n<<(n**2)\n"}
{"sequence_id": "A280294", "text": "a(n) = a(n-1) + 2^n * a(n-2) with a(0) = 1 and a(1) = 1.", "sequence": "1,1,5,13,93,509,6461,71613,1725629,38391485,1805435581,80431196861,7475495336637,666367860021949,123144883455482557,21958686920654707389,8092381769059159562941,2886261393833112966453949,2124255587862077437434059453", "code": "\ndef a():\n    a, b, p = 1, 0, 1\n    while True:\n        p, a, b = p + p, b, b + p * a\n        yield b\nA280294 = a()\nprint([next(A280294) for _ in range(19)]) \n"}
{"sequence_id": "A280321", "text": "Number of 2 X 2 matrices with all elements in {0,..,n} having determinant = n*permanent.", "sequence": "1,12,25,49,81,121,169,225,289,361,441,529,625,729,841,961,1089,1225,1369,1521,1681,1849,2025,2209,2401,2601,2809,3025,3249,3481,3721,3969,4225,4489,4761,5041,5329,5625,5929,6241,6561,6889,7225,7569,7921,8281,8649,9025,9409,9801,10201", "code": "\ndef t(n):\n    s=0\n    for a in range(n+1):\n        for b in range(n+1):\n            for c in range(n+1):\n                for d in range(n+1):\n                    if (a*d-b*c)==n*(a*d+b*c):\n                        s+=1\n    return s\nfor i in range(41):\n    print(str(i)+\" \"+str(t(i)))\n"}
{"sequence_id": "A280343", "text": "Number of 2 X 2 matrices with all elements in {-n,..,0,..,n} with determinant = 2*permanent.", "sequence": "1,25,81,233,401,585,1009,1289,1681,2377,2913,3353,4497,5033,5793,7097,8065,8761,10721,11513,12961,14873,16113,17065,19873,21225,22689,25465,27585,28793,32561,33865,36113,39177,41121,43481,48801,50361,52529,56201,59793", "code": "\ndef t(n):\n    s=0\n    for a in range(-n,n+1):\n        for b in range(-n,n+1):\n            for c in range(-n,n+1):\n                for d in range(-n,n+1):\n                    if (a*d-b*c)==2*(a*d+b*c):\n                        s+=1\n    return s\nfor i in range(0,146):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A280344", "text": "Number of 2 X 2 matrices with all elements in {0,...,n} with determinant = permanent^n.", "sequence": "0,12,30,56,90,132,182,240,306,380,462,552,650,756,870,992,1122,1260,1406,1560,1722,1892,2070,2256,2450,2652,2862,3080,3306,3540,3782,4032,4290,4556,4830,5112,5402,5700,6006,6320,6642,6972,7310,7656,8010,8372,8742,9120,9506,9900,10302", "code": "\ndef t(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            for c in range(0,n+1):\n                for d in range(0,n+1):\n                    if (a*d-b*c)==(a*d+b*c)**n:\n                        s+=1\n    return s\nfor i in range(0,41):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A280364", "text": "Number of 2 X 2 matrices with all elements in {0,...,n} with permanent = determinant^n.", "sequence": "0,12,35,56,99,132,195,240,323,380,483,552,675,756,899,992,1155,1260,1443,1560,1763,1892,2115,2256,2499,2652,2915,3080,3363,3540,3843,4032,4355,4556,4899,5112,5475,5700,6083,6320,6723,6972,7395,7656,8099,8372,8835,9120,9603,9900,10403", "code": "\ndef t(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            for c in range(0,n+1):\n                for d in range(0,n+1):\n                    if (a*d-b*c)**n==(a*d+b*c):\n                        s+=1\n    return s\nfor i in range(0,51):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A280364", "text": "Number of 2 X 2 matrices with all elements in {0,...,n} with permanent = determinant^n.", "sequence": "0,12,35,56,99,132,195,240,323,380,483,552,675,756,899,992,1155,1260,1443,1560,1763,1892,2115,2256,2499,2652,2915,3080,3363,3540,3843,4032,4355,4556,4899,5112,5475,5700,6083,6320,6723,6972,7395,7656,8099,8372,8835,9120,9603,9900,10403", "code": "\ndef a(n):\n    if n==2:\n        return 12\n    return (((-2*(n-1)-1)*a(n-1))/(2*(n-1)-1))+8*(n-1)**2+10*(n-1)+3\nfor i in range(2,1001):\n    print str(i)+\" \"+str(a(i))\n"}
{"sequence_id": "A280382", "text": "Numbers k such that k-1 has the same number of prime factors counted with multiplicity as k+1.", "sequence": "4,5,6,12,18,19,29,30,34,42,43,50,51,55,56,60,67,69,72,77,86,89,92,94,102,108,115,120,122,138,142,144,150,151,160,171,173,180,184,186,187,189,192,197,198,202,204,214,216,218,220,228,233,236,237,240,243,245,248,249,266,267,270,271,274,282", "code": "\nfrom sympy import primeomega\ndef aupto(limit):\n  prv, cur, nxt, alst = 1, 1, 2, []\n  for n in range(3, limit+1):\n    if prv == nxt: alst.append(n)\n    prv, cur, nxt = cur, nxt, primeomega(n+2)\n  return alst\nprint(aupto(282)) \n"}
{"sequence_id": "A280385", "text": "a(n) = Sum_{k=1..n} prime(k)^2*floor(n/prime(k)) .", "sequence": "0,4,13,17,42,55,104,108,117,146,267,280,449,502,536,540,829,842,1203,1232,1290,1415,1944,1957,1982,2155,2164,2217,3058,3096,4057,4061,4191,4484,4558,4571,5940,6305,6483,6512,8193,8255,10104,10229,10263,10796,13005,13018,13067,13096,13394,13567,16376,16389,16535", "code": "\nfrom sympy import prime\nprint([sum([prime(k)**2 * (n//prime(k)) for k in range(1, n + 1)]) for n in range(1, 21)]) \n"}
{"sequence_id": "A280391", "text": "Number of 2 X 2 matrices with all elements in {0,...,n} with permanent = determinant * n.", "sequence": "1,12,25,57,81,141,169,259,297,413,441,621,625,825,873,1079,1089,1403,1369,1739,1729,2021,2025,2507,2433,2859,2905,3301,3249,4029,3721,4509,4305,4793,4989,5551,5329,6027,6025,6807,6561,7917,7225,8357,8121,8677,8649,9843,9481,10889", "code": "\ndef t(n):\n    s=0\n    for a in range(0,n+1):\n        for b in range(0,n+1):\n            for c in range(0,n+1):\n                for d in range(0,n+1):\n                    if (a*d-b*c)*n==(a*d+b*c):\n                        s+=1\n    return s\nfor i in range(0,201):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A280407", "text": "Number of 2 X 2 matrices with all elements in {-n,..,0,..,n} with permanent = determinant * n.", "sequence": "1,45,81,233,289,601,625,1113,1153,1785,1681,2761,2401,3577,3505,4665,4225,6185,5329,7673,6945,8601,7921,11033,9665,12265,11793,14089,12769,18073,14641,19945,17281,20121,20593,23961,21025,25417,24177,29177,25921,35449,28561,36233", "code": "\ndef t(n):\n    s=0\n    for a in range(-n,n+1):\n        for b in range(-n,n+1):\n            for c in range(-n,n+1):\n                for d in range(-n,n+1):\n                    if (a*d-b*c)*n==(a*d+b*c):\n                        s+=1\n    return s\nfor i in range(0,156):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A280408", "text": "Irregular triangle read by rows listing the prime numbers that appear from the trajectory of n in Collatz Problem.", "sequence": "2,2,3,5,2,2,5,2,3,5,2,7,11,17,13,5,2,2,7,11,17,13,5,2,5,2,11,17,13,5,2,3,5,2,13,5,2,7,11,17,13,5,2,23,53,5,2,2,17,13,5,2,7,11,17,13,5,2,19,29,11,17,13,5,2,5,2,2,11,17,13,5,2,23,53,5,2,3,5,2,19,29,11,17,13,5,2", "code": "\nfrom sympy import isprime\ndef a(n):\n    if n==1: return [2]\n    l=[n, ]\n    while True:\n        if n%2==0: n/=2\n        else: n = 3*n + 1\n        l+=[n, ]\n        if n<2: break\n    return list(filter(lambda i: isprime(i), l))\nfor n in range(1, 21): print a(n) \n"}
{"sequence_id": "A280531", "text": "a(n) = A049501(A000142(n)).", "sequence": "0,0,1,2,2,4,11,16,16,25,30,64,39,83,111,139,139,165,205,242,283,320,336,474,440,395,637,655,886,842,1019,1159,1159,1153,1327,1366,1328,1243,1487,1756,1623,2362,2394,2274,2487,2642,2907,2843,3211,3049,3736", "code": "\nimport math\ndef M(n):\n    x=bin(int(n))[2:]\n    s=0\n    for i in range(1,len(x)):\n        if x[i-1]==\"1\" and x[i]==\"0\":\n            s+=i\n    return s\na=lambda n: M(math.factorial(n))\n"}
{"sequence_id": "A280588", "text": "Number of 2 X 2 matrices with all terms in {0,1,...,n} and (sum of terms) = determinant.", "sequence": "1,1,2,9,18,41,58,97,130,185,226,313,354,457,538,649,738,889,954,1145,1266,1449,1578,1809,1930,2177,2362,2609,2770,3129,3242,3609,3810,4097,4402,4793,5026,5433,5674,6097,6346,6929,7090,7641,8010,8433,8810,9369,9626,10297,10690", "code": "\ndef t(n):\n    s=0\n    for a in range(n+1):\n        for b in range(n+1):\n            for c in range(n+1):\n                for d in range(n+1):\n                    if (a+b+c+d)==(a*d-b*c):\n                        s+=1\n    return s\nfor i in range(51):\n    print(str(i)+\" \"+str(t(i)))\n"}
{"sequence_id": "A280640", "text": "Numbers k such that k^3 has an odd number of digits and the middle digit is 0.", "sequence": "0,30,40,42,100,101,115,116,123,126,135,163,164,171,199,200,201,214,468,479,487,498,500,502,513,520,525,543,557,562,564,575,576,577,578,579,585,596,600,615,623,642,656,661,666,690,695,697,700,705,709,717,721", "code": "\ni=0\nj=1\nwhile i<=721:\n    n=str(i**3)\n    l=len(n)\n    if l%2 and n[(l-1)//2]==\"0\":\n        print(str(i), end=\",\")\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A280641", "text": "Numbers k such that k^3 has an odd number of digits and the middle digit is 1.", "sequence": "1,6,8,23,44,45,102,106,110,114,117,121,137,148,152,153,162,168,176,185,189,194,206,210,478,488,512,533,553,560,574,580,626,639,655,662,669,671,676,682,683,684,685,693,704,710,730,731,737,742,758,761,767,771", "code": "\ni=0\nj=1\nwhile i<=771:\n    n=str(i**3)\n    l=len(n)\n    if l%2 and n[(l-1)//2]==\"1\":\n        print(str(i), end=', ')\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A280642", "text": "Numbers k such that k^3 has an odd number of digits and the middle digit is 2.", "sequence": "5,9,103,113,133,146,151,154,165,180,198,202,470,473,493,496,504,507,521,531,538,542,566,569,581,591,593,599,612,618,620,650,654,673,681,686,703,711,715,728,729,732,740,779,801,829,841,850,855,856,857,858,874", "code": "\ni=0\nj=1\nwhile i<=874:\n    n=str(i**3)\n    l=len(n)\n    if l%2 and n[(l-1)//2]==\"2\":\n        print(str(i), end=', ')\n        j+=1\n    i+=1 \n"}
{"sequence_id": "A280650", "text": "Numbers k such that k^3 has an odd number of digits in base 2 and the middle digit is 0.", "sequence": "0,3,4,12,16,17,29,30,31,43,44,46,48,50,64,65,68,78,79,80,102,104,105,107,108,109,112,114,116,117,118,121,127,163,167,169,170,172,173,174,175,176,179,183,186,187,188,189,191,192,193,195,196,198,200,202,203", "code": "\ni=0\nj=1\nwhile i<=203:\n....n=str(bin(i**3)[2:])\n....l=len(n)\n....if l%2==1 and n[(l-1)/2]==\"0\":\n........print (str(i))+\",\",\n........j+=1\n....i+=1 \n"}
{"sequence_id": "A280651", "text": "Numbers k such that k^3 has an odd number of digits in base 2 and the middle digit is 1.", "sequence": "1,5,7,11,18,19,20,26,27,28,41,42,45,47,49,66,67,69,70,71,72,73,74,75,76,77,103,106,110,111,113,115,119,120,122,123,124,125,126,162,164,165,166,168,171,177,178,180,181,182,184,185,190,194,197,199,201,259", "code": "\ni=0\nj=1\nwhile i<=259:\n....n=str(bin(i**3)[2:])\n....l=len(n)\n....if l%2==1 and n[(l-1)/2]==\"1\":\n........print (str(i))+\",\",\n........j+=1\n....i+=1 \n"}
{"sequence_id": "A280660", "text": "Least k such that at least half of the last n digits of 2^k are 9.", "sequence": "12,53,53,232,93,1862,93,3244,93,93,93,55754,12864,55756,23353,361353,16441,361353,304362,361353,361353,361353,361353,3748854,3748854,78055893,66290232,119133355,119133355,379371432,20958353,130883333,20958353,130883333", "code": "\ndef A280660(n):\n    m, k, l = 10**n,1,2\n    while True:\n        if 2*str(l).count('9') >= n:\n            return k\n        k += 1\n        l = (l*2) % m \n"}
{"sequence_id": "A280700", "text": "Binary weight of terms of A005187: a(n) = A000120(A005187(n)).", "sequence": "0,1,2,1,3,1,2,3,4,1,2,3,3,4,3,3,5,1,2,3,3,4,3,3,4,5,3,3,4,4,3,4,6,1,2,3,3,4,3,3,4,5,3,3,4,4,3,4,5,6,3,3,4,4,3,4,5,5,3,4,4,5,6,4,7,1,2,3,3,4,3,3,4,5,3,3,4,4,3,4,5,6,3,3,4,4,3,4,5,5,3,4,4,5,6,4,6,7,3,3,4,4,3,4,5,5,3,4,4,5,6,4,6,6,3,4,4,5,6,4,5", "code": "\ndef A(n): return bin(2*n - bin(2*n)[2:].count(\"1\"))[2:].count(\"1\")\nprint([A(n) for n in range(151)]) \n"}
{"sequence_id": "A280717", "text": "Given a prime number p, let b = -p and c = p^2. Assuming that the polynomial P(x) := x^2+b*x+c takes at least one prime value for some positive integer x<p, we define the next term of the sequence to be the maximal element in the set S := {P(x) : x is an integer, 0 < x < p, and P(x) is a prime number}. The first term of the present sequence is p=3.", "sequence": "3,7,43,1693,2864557,8205572225569,67331415548799635795058613,4533519519805137360312930667312809111343819483374997,20552799236454203238557860425684304712780972342513397945121797314302926172950212696842909492430773376197", "code": "\nfrom __future__ import division\nfrom sympy import isprime\nA280717_list, n = [3], 3\nfor _ in range(10):\n    for i in range(1,n//2+1):\n        j = i**2+n*(n-i)\n        if isprime(j):\n            n = j\n            A280717_list.append(n)\n            break \n"}
{"sequence_id": "A280824", "text": "Numbers with an even number of digits and with an even number of distinct digits.", "sequence": "10,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,34,35,36,37,38,39,40,41,42,43,45,46,47,48,49,50,51,52,53,54,56,57,58,59,60,61,62,63,64,65,67,68,69,70,71,72,73,74,75,76,78,79,80,81,82,83,84,85,86,87,89,90,91,92,93,94,95,96,97,98,1000,1001,1010", "code": "\ndef ok(n): s = str(n); return len(s)%2 == 0 == len(set(s))%2\nprint(list(filter(ok, range(1011)))) \n"}
{"sequence_id": "A280844", "text": "Number of 2 X 2 matrices with entries in {-n,..,0,..,n} with no entries repeated having permanent = trace^n.", "sequence": "0,0,0,4,16,20,16,36,56,60,72,76,80,100,112,100,136,124,152,172,192,196,224,196,232,236,264,252,288,276,288,308,344,332,344,332,384,388,416,404,456,428,456,444,496,468,512,468,536,556,648", "code": "\ndef t(n):\n    s=0\n    for a in range(-n,n+1):\n        for b in range(-n,n+1):\n            if a!=b:\n                for c in range(-n,n+1):\n                    if a!=c and b!=c:\n                        for d in range(-n,n+1):\n                            if d!=a and d!=b and d!=c:\n                                if (a*d+b*c)==(a+d)**n:\n                                    s+=1\n    return s\nfor i in range(0,104):\n    print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A280870", "text": "Numerator of the mediant of prime(n) / prime(n+1) and prime(n+2) / prime(n+3).", "sequence": "7,5,4,5,7,4,5,8,9,11,9,10,11,48,53,19,21,33,14,25,13,14,18,19,25,52,53,55,59,61,44,135,143,145,153,157,27,168,173,177,185,187,97,49,204,211,219,113,115,78,237,245,249,257,263,89,91,69,40,287,295", "code": "\nfrom math import gcd\nfrom sympy import nextprime\ndef aupton(terms):\n    alst, p, q, r, s = [], 2, 3, 5, 7\n    while len(alst) < terms:\n        alst.append((p+r)//gcd(p+r, q+s))\n        p, q, r, s = q, r, s, nextprime(s)\n    return alst\nprint(aupton(61)) \n"}
{"sequence_id": "A280871", "text": "Denominator of the mediant of prime(n) / prime(n+1) and prime(n+2) / prime(n+3).", "sequence": "10,8,5,7,8,5,6,9,11,12,10,11,12,53,57,21,22,35,15,26,14,15,19,20,26,53,55,59,61,66,45,143,145,153,157,162,28,173,177,185,187,194,98,51,211,219,226,115,117,79,245,249,257,263,267,91,92,70,41,295,302", "code": "\nfrom math import gcd\nfrom sympy import nextprime\ndef aupton(terms):\n    alst, p, q, r, s = [], 2, 3, 5, 7\n    while len(alst) < terms:\n        alst.append((q+s)//gcd(p+r, q+s))\n        p, q, r, s = q, r, s, nextprime(s)\n    return alst\nprint(aupton(61)) \n"}
{"sequence_id": "A280873", "text": "Numbers whose binary expansion does not begin 10 and do not contain 2 adjacent 0's; Ahnentafel numbers of X-chromosome inheritance of a male.", "sequence": "0,1,3,6,7,13,14,15,26,27,29,30,31,53,54,55,58,59,61,62,63,106,107,109,110,111,117,118,119,122,123,125,126,127,213,214,215,218,219,221,222,223,234,235,237,238,239,245,246,247,250,251,253,254,255", "code": "\ndef A280873():\n    yield 1\n    for x in A280873():\n        if ((x & 1) and (x > 1)):\n            yield 2*x\n        yield 2*x+1\ndef take(n, g):\n  '''Returns a list composed of the next n elements returned by generator g.'''\n  z = []\n  if 0 == n: return(z)\n  for x in g:\n    z.append(x)\n    if n > 1: n = n-1\n    else: return(z)\ntake(120, A280873())\n\n"}
{"sequence_id": "A280877", "text": "Occurrences of decrease of the probability density P(a(n)) of coprime numbers k,m, satisfying 1 <= k <= a(n) and 1 <= m <= a(n); i.e., P(a(n)) < P(a(n)-1).", "sequence": "2,4,6,8,10,12,14,15,16,18,20,21,22,24,26,28,30,32,33,34,36,38,40,42,44,45,46,48,50,52,54,56,58,60,62,63,64,66,68,70,72,74,75,76,78,80,82,84,86,88,90,92,94,96,98,99,100,102,104,105,106,108,110,112,114,116,118,120,122,124,126,128", "code": "\nfrom fractions import gcd\nt = 1\nto = 1\ni = 1\nx = 1\nwhile x < 10000:\n....x = x + 1\n....y = 0\n....while y < x:\n........y = y + 1\n........if gcd(x,y) == 1:\n............t = t + 2\n....e = t*(x-1)*(x-1) - to*x*x\n....if e < 0:\n........print(i,x)\n........i = i + 1\n....to = t\n"}
{"sequence_id": "A280878", "text": "Occurrences of decrease of the probability density P(n) of coprime numbers k,m, satisfying 1 <= k <= a(n) and 1 <= m <= a(n), and a(n) congruent to 1(mod 2) and a(n) congruent to {3,9,21,27}(mod 30).", "sequence": "21,33,63,99,147,189,231,273,297,357,363,399,429,441,483,561,567,609,627,651,663,693,741,759,777,819,861,891,897,903,957,969,987,1023,1029,1071,1089,1113,1131,1173,1197,1209,1221,1239,1281,1287,1311,1323,1353,1407,1419,1443,1449", "code": "\nfrom fractions import gcd\nt = 1\nto = 1\ni = 1\nx = 1\nwhile x > 0:\n....x = x + 1\n....y = 0\n....while y < x:\n........y = y + 1\n........if gcd(x,y) == 1:\n............t = t + 2\n....e = t*(x-1)*(x-1) - to*x*x\n....if (e < 0 and x%2 == 1 and x%6 == 3 and x%30 != 15):\n........print(i,x)\n........i = i + 1\n....to = t\n"}
{"sequence_id": "A280879", "text": "Occurrences of decrease of the probability density P(n) of coprime numbers k,m, satisfying 1 <= k <= a(n) and 1 <= m <= a(n), and a(n) congruent to 1 (mod 2) and a(n) not congruent to 3 (mod 6).", "sequence": "5005,6545,7315,7735,8645,8855,10465,11165,11935,14245,25025,32725,35035,36575,38675,43225,44275,45815,51205,52325,54145,55055,55825,59675,60515,61985,65065,71225,71995,73255,78155,80465,83545,85085,95095,97405,99715", "code": "\nfrom fraction import gcd\nt = 1\nto = 1\ni = 1\nx = 1\nwhile x > 0:\n....x = x + 1\n....y = 0\n....while y < x:\n........y = y + 1\n........if gcd(x,y) == 1:\n............t = t + 2\n....e = t*(x-1)*(x-1) - to*x*x\n....if (e < 0 and x%2 == 1 and x%6 != 3):\n........print(i,x)\n........i = i + 1\n....to = t\n"}
{"sequence_id": "A280879", "text": "Occurrences of decrease of the probability density P(n) of coprime numbers k,m, satisfying 1 <= k <= a(n) and 1 <= m <= a(n), and a(n) congruent to 1 (mod 2) and a(n) not congruent to 3 (mod 6).", "sequence": "5005,6545,7315,7735,8645,8855,10465,11165,11935,14245,25025,32725,35035,36575,38675,43225,44275,45815,51205,52325,54145,55055,55825,59675,60515,61985,65065,71225,71995,73255,78155,80465,83545,85085,95095,97405,99715", "code": "\nfrom sympy import totient\nA280879_list, n, t = [], 1, 1\nwhile len(A280879_list) < 1000:\n    n += 1\n    h = totient(n)\n    t2 = t+h\n    if n % 2 and n % 6 != 3 and 2*(n*(h*n - 2*t2 + 1) + t2) <  1:\n        A280879_list.append(n)\n    t = t2 \n"}
{"sequence_id": "A280913", "text": "Number of dots in International Morse numeral representation of n.", "sequence": "0,1,2,3,4,5,4,3,2,1,1,2,3,4,5,6,5,4,3,2,2,3,4,5,6,7,6,5,4,3,3,4,5,6,7,8,7,6,5,4,4,5,6,7,8,9,8,7,6,5,5,6,7,8,9,10,9,8,7,6,4,5,6,7,8,9,8,7,6,5,3,4,5,6,7,8,7,6,5,4,2,3,4,5,6,7,6,5,4,3,1,2,3,4,5,6,5,4,3,2,1,2,3,4,5,6,5,4,3,2", "code": "\nM={\"1\":\".----\",\"2\":\"..---\",\"3\":\"...--\",\"4\":\"....-\",\"5\":\".....\",\"6\":\"-....\",\"7\":\"--...\",\"8\":\"---..\",\"9\":\"----.\",\"0\":\"-----\"}\ndef A280913(n):\n    z=\"\".join(M[i] for i in str(n))\n    return z.count(\".\")\nprint([A280913(n) for n in range(101)])\n"}
{"sequence_id": "A280914", "text": "Number of 2 X 2 matrices with all terms in {-n,...,0,...,n} and (sum of terms) = permanent.", "sequence": "1,21,52,172,268,428,588,812,1004,1324,1580,1900,2252,2668,2988,3532,3916,4460,5004,5548,6028,6764,7308,8044,8716,9548,10156,11116,11852,12620,13548,14444,15244,16524,17228,18380,19340,20588,21548", "code": "\ndef t(n):\n....s=0\n....for a in range(-n,n+1):\n........for b in range(-n,n+1):\n............for c in range(-n,n+1):\n................for d in range(-n,n+1):\n....................if (a+b+c+d)==(a*d+b*c):\n........................s+=1\n....return s\nfor i in range(0,169):\n....print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A280916", "text": "Number of dashes in International Morse numeral representation of n.", "sequence": "5,4,3,2,1,0,1,2,3,4,9,8,7,6,5,4,5,6,7,8,8,7,6,5,4,3,4,5,6,7,7,6,5,4,3,2,3,4,5,6,6,5,4,3,2,1,2,3,4,5,5,4,3,2,1,0,1,2,3,4,6,5,4,3,2,1,2,3,4,5,7,6,5,4,3,2,3,4,5,6,8,7,6,5,4,3,4,5,6,7,9,8,7,6,5,4,5,6,7,8,14", "code": "\nM={\"1\":\".----\",\"2\":\"..---\",\"3\":\"...--\",\"4\":\"....-\",\"5\":\".....\",\"6\":\"-....\",\"7\":\"--...\",\"8\":\"---..\",\"9\":\"----.\",\"0\":\"-----\"}\ndef A280916(n):\n    z=\"\".join(M[i] for i in str(n))\n    return z.count(\"-\")\nprint([A280916(n) for n in range(100)])\n"}
{"sequence_id": "A280920", "text": "Seventh column of Euler's difference table in A068106.", "sequence": "0,0,0,0,0,720,4320,30960,256320,2399760,25022880,287250480,3597143040,48773612880,711607724640,11113078385520,184925331414720,3265974496290960,61006644910213920,1201583921745846960,24885771463659934080,540624959563046320080,12291921453805577987040", "code": "\nf=math.factorial\ndef C(n,r):return f(n)/f(r)/f(n-r)\ndef A280920(n):\n....s=0\n....for j in range(0,n-5):\n........s+=(-1)**j*C(n-6,j)*f(n-j)\n....return s \n"}
{"sequence_id": "A280934", "text": "Number of 2 X 2 matrices with all elements in {0,..,n} and (sum of terms) = permanent.", "sequence": "1,1,4,36,52,76,92,116,136,160,176,208,224,248,272,300,316,348,364,396,420,444,460,500,520,544,568,600,616,656,672,704,728,752,776,820,836,860,884,924,940,980,996,1028,1060,1084,1100,1148,1168,1200,1224,1256,1272,1312,1336,1376,1400,1424,1440,1496,1512,1536", "code": "\ndef t(n):\n    s=0\n    for a in range(n+1):\n        for b in range(n+1):\n            for c in range(n+1):\n                for d in range(n+1):\n                    if (a+b+c+d)==(a*d+b*c):\n                        s+=1\n    return s\nfor i in range(201):\n    print(str(i)+\" \"+str(t(i)))\n"}
{"sequence_id": "A280934", "text": "Number of 2 X 2 matrices with all elements in {0,..,n} and (sum of terms) = permanent.", "sequence": "1,1,4,36,52,76,92,116,136,160,176,208,224,248,272,300,316,348,364,396,420,444,460,500,520,544,568,600,616,656,672,704,728,752,776,820,836,860,884,924,940,980,996,1028,1060,1084,1100,1148,1168,1200,1224,1256,1272,1312,1336,1376,1400,1424,1440,1496,1512,1536", "code": "\nfrom sympy import divisor_count\nA280934_list = [1,1,4,36]\nfor i in range(4,100):\n    A280934_list.append(A280934_list[-1]+4*divisor_count(i+1)+8) \n"}
{"sequence_id": "A280987", "text": "{Concatenation n, n-1, n-2, ...3,2,1} mod sigma(n).", "sequence": "0,0,1,2,3,9,1,6,4,1,9,21,1,9,9,16,9,24,1,33,17,1,9,21,0,9,1,41,21,33,17,6,33,19,33,25,25,21,1,1,33,81,17,21,45,1,33,85,49,69,57,77,27,81,1,81,1,1,21,57,59,81,33,60,21,33,45,51,81,1,9,66,41,9,97,1,81,81,1,57,117,73,33,145", "code": "\ndef sigma(n):\n    s=0\n    for i in range(1,n+1):\n        if n%i==0:\n            s+=i\n    return s\ndef C(n):\n    s=\"\"\n    for i in range(n,0,-1):\n        s+=str(i)\n    return int(s)\nfor i in range(1,10001):\n    print str(i)+\" \"+str(C(i)%sigma(i))\n"}
{"sequence_id": "A280995", "text": "a(n) is the number produced when n is converted to binary reflected Gray code, the binary digits are reversed and the code is converted back to decimal.", "sequence": "0,1,3,1,3,7,5,1,3,11,15,7,5,13,9,1,3,19,27,11,15,31,23,7,5,21,29,13,9,25,17,1,3,35,51,19,27,59,43,11,15,47,63,31,23,55,39,7,5,37,53,21,29,61,45,13,9,41,57,25,17,49,33,1,3,67,99,35,51,115,83,19,27,91,123,59,43", "code": "\ndef a(n):\n....return int(bin(n^(n/2))[2:][::-1],2)\n"}
{"sequence_id": "A281015", "text": "Numbers with a prime number of dots in their International Morse numeral representation.", "sequence": "2,3,5,7,8,11,12,14,16,18,19,20,21,23,25,27,29,30,32,34,36,38,41,43,47,49,50,52,58,61,63,67,69,70,72,74,76,78,80,81,83,85,87,89,91,92,94,96,98,99,101,102,104,106,108,109,110,111,113,115,117,119,120,122,124,126", "code": " \nfrom sympy import isprime\ni=0\nj=1\nwhile j<=100:\n    if isprime(A280913(i)):\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1\n"}
{"sequence_id": "A281017", "text": "Numbers with a prime number of dashes in their International Morse numeral representation.", "sequence": "0,2,3,7,8,12,14,16,18,21,23,25,27,29,30,32,34,35,36,38,41,43,44,46,47,49,50,52,53,57,58,61,63,64,66,67,69,70,72,74,75,76,78,81,83,85,87,89,92,94,96,98,101,103,107,109,110,112,118,121,125,129,130,134,136,143", "code": " \nfrom sympy import isprime\ni=0\nj=1\nwhile j<=100:\n    if isprime(A280916(i)):\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1\n"}
{"sequence_id": "A281018", "text": "Numbers with a prime number of dots and a prime number of dashes in their International Morse numeral representation.", "sequence": "2,3,7,8,12,14,16,18,21,23,25,27,29,30,32,34,36,38,41,43,47,49,50,52,58,61,63,67,69,70,72,74,76,78,81,83,85,87,89,92,94,96,98,101,109,110,190,200,355,445,454,456,465,535,544,546,553,557,564,566,575,645", "code": " \nfrom sympy import isprime\ni=0\nj=1\nwhile j<=1000:\n    if isprime(A280913(i)) and isprime(A280916(i)):\n        print(str(j)+\" \"+str(i))\n        j+=1\n    i+=1\n"}
{"sequence_id": "A281020", "text": "Numbers with a prime number of raised dots in their Braille representation.", "sequence": "0,1,4,6,8,12,13,15,19,21,31,47,51,67,70,74,76,78,87,91,100,104,106,108,111,127,137,140,144,146,148,157,160,164,166,168,172,173,175,177,179,180,184,186,188,197,202,203,205,207,209,217,220,224,226,228,230,234,236,238", "code": "\nfrom sympy import isprime\nB=[3, 1, 2, 2, 3, 2, 3, 4, 3, 2]\ndef a(n):\n    s=0\n    for i in str(n):\n        s+=B[int(i)]\n    return s+4\ni=0\nj=1\nwhile j<=10000:\n    if isprime(a(i))==True :\n        print str(j)+\" \"+str(i)\n        j+=1\n    i+=1\n"}
{"sequence_id": "A281026", "text": "a(n) = floor(3*n*(n+1)/4).", "sequence": "0,1,4,9,15,22,31,42,54,67,82,99,117,136,157,180,204,229,256,285,315,346,379,414,450,487,526,567,609,652,697,744,792,841,892,945,999,1054,1111,1170,1230,1291,1354,1419,1485,1552,1621,1692,1764,1837,1912,1989,2067,2146", "code": " [int(3*n*(n+1)/4) for n in range(60)]\n"}
{"sequence_id": "A281066", "text": "Concatenation R(n)R(n-1)R(n-2)...R(2)R(1) read mod n, where R(x) is the digit-reversal of x (with leading zeros not omitted).", "sequence": "0,1,0,1,1,3,3,1,0,1,4,9,5,7,6,1,6,9,17,1,15,15,19,9,21,1,18,13,28,21,26,17,15,3,16,9,30,3,15,1,1,33,10,37,36,43,22,33,19,21,48,45,2,45,26,49,27,33,33,21,48,25,36,49,36,15,22,5,27,11,42,9,2,73,21,17,59,57,5,1", "code": "\ndef A281066(n):\n....s=\"\"\n....for i in range(n,0,-1):\n........s+=str(i)[::-1]\n....return int(s)%n \n"}
{"sequence_id": "A281090", "text": "Number of 2 X 2 matrices with all elements in {0,...,n} and prime permanent.", "sequence": "0,1,27,85,139,307,399,765,1043,1517,1889,3021,3523,5299,6269,7671,9209,12729,14179,18995,21307,24991,28303,36261,39307,47541,52833,61173,67113,82125,86601,104655,114695,128069,139213,156653,165819,194591,209753,230835,245457,283887", "code": "\nfrom sympy import isprime\ndef t(n):\n....s=0\n....for a in range(0, n+1):\n........for b in range(0, n+1):\n............for c in range(0, n+1):\n................for d in range(0, n+1):\n....................if isprime(a*d+b*c)==True:\n........................s+=1\n....return s\nfor i in range(0, 152):\n....print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A281149", "text": "Elias gamma code (EGC) for n.", "sequence": "1,100,101,11000,11001,11010,11011,1110000,1110001,1110010,1110011,1110100,1110101,1110110,1110111,111100000,111100001,111100010,111100011,111100100,111100101,111100110,111100111,111101000,111101001,111101010,111101011,111101100,111101101,111101110", "code": "\ndef unary(n):\n....return \"1\"*(n-1)+\"0\"\ndef elias_gamma(n):\n....if n ==1:\n........return \"1\"\n....k=int(math.log(n,2))\n....fp=unary(1+k)    \n....sp=n-2**(k)      \n....nb=k             \n....sp=bin(sp)[2:]\n....if len(sp)<nb:\n........sp=(\"0\"*(nb-len(sp)))+sp\n....return fp+sp\n"}
{"sequence_id": "A281150", "text": "Elias delta code for n.", "sequence": "1,1000,1001,10100,10101,10110,10111,11000000,11000001,11000010,11000011,11000100,11000101,11000110,11000111,110010000,110010001,110010010,110010011,110010100,110010101,110010110,110010111,110011000,110011001,110011010", "code": "\ndef unary(n):\n....return \"1\"*(n-1)+\"0\"\ndef elias_gamma(n):\n....if n==1:\n........return \"1\"\n....k=int(math.log(n, 2))\n....fp=unary(1+k)    \n....sp=n-2**(k)      \n....nb=k             \n....sp=bin(sp)[2:]\n....if len(sp)<nb:\n........sp=(\"0\"*(nb-len(sp)))+sp\n....return fp+sp\ndef elias_delta(n):\n....if n==1:\n........return \"1\"\n....k=int(math.log(n, 2))\n....fp=elias_gamma(1+k)\n....sp=n-2**(k)        \n....nb=k               \n....sp=bin(sp)[2:]\n....if len(sp)<nb:\n........sp=(\"0\"*(nb-len(sp)))+sp\n....return fp+sp\n"}
{"sequence_id": "A281151", "text": "a(n) = floor(4*n*(n+1)/5).", "sequence": "0,1,4,9,16,24,33,44,57,72,88,105,124,145,168,192,217,244,273,304,336,369,404,441,480,520,561,604,649,696,744,793,844,897,952,1008,1065,1124,1185,1248,1312,1377,1444,1513,1584,1656,1729,1804,1881,1960,2040,2121,2204,2289", "code": " [int(4*n*(n+1)/5) for n in range(60)]\n"}
{"sequence_id": "A281190", "text": "Concatenation of the reversed digits of numbers from 1 to n, mod n.", "sequence": "0,0,0,2,0,0,5,6,0,1,6,9,3,1,6,9,5,9,1,2,18,6,12,18,2,6,18,26,7,3,20,27,6,3,28,27,7,19,12,24,4,24,12,28,9,8,42,12,22,5,3,45,41,45,50,45,45,23,16,6,6,54,27,30,61,6,37,30,21,67,47,63,52,67,57,19,28,15,58,28,72,22,56,24,83,34,3,72,72,9,85,69,57", "code": "\ndef A281190(n):\n....s=\"\"\n....for i in range(1,n+1):\n........s+=str(i)[::-1]\n....return int(s)%n \n"}
{"sequence_id": "A281193", "text": "Elias's omega code for n.", "sequence": "0,100,110,101000,101010,101100,101110,1110000,1110010,1110100,1110110,1111000,1111010,1111100,1111110,10100100000,10100100010,10100100100,10100100110,10100101000,10100101010,10100101100,10100101110,10100110000,10100110010,10100110100", "code": "\ndef E(n):\n....s=\"\"\n....if n==1:\n........return \"0\"\n....else:\n........b=(bin(n)[2:])\n........s+=E(len(b)-1)+b\n....return s\ndef elias_omega(n):\n....return E(n)[1:]+\"0\"\n"}
{"sequence_id": "A281194", "text": "Number of 2 X 2 matrices with all terms in {-n,..,0,..,n} and (sum of terms) = determinant.", "sequence": "1,31,111,271,479,831,1167,1711,2239,2975,3631,4687,5407,6655,7759,9135,10367,12127,13231,15375,16991,19135,20879,23471,25215,27999,30319,33167,35359,39167,41039,44975,47615,50975,54511,58767,61791,66239,69391", "code": "\ndef t(n):\n....s=0\n....for a in range(-n,n+1):\n........for b in range(-n,n+1):\n............for c in range(-n,n+1):\n................for d in range(-n,n+1):\n....................if (a+b+c+d)==(a*d-b*c):\n........................s+=1\n....return s\nfor i in range(0,187):\n....print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A281223", "text": "The decimal representation of the Elias omega code for n (A281193(n)).", "sequence": "0,4,6,40,42,44,46,112,114,116,118,120,122,124,126,1312,1314,1316,1318,1320,1322,1324,1326,1328,1330,1332,1334,1336,1338,1340,1342,2752,2754,2756,2758,2760,2762,2764,2766,2768,2770,2772,2774,2776,2778,2780,2782,2784,2786,2788,2790", "code": "\ndef E(n):\n....s=\"\"\n....if n==1:\n........return \"0\"\n....else:\n........b=(bin(n)[2:])\n........s+=E(len(b)-1)+b\n....return s\ndef elias_omega(n):\n....return int(E(n)[1:]+\"0\",2)\n"}
{"sequence_id": "A281225", "text": "The decimal representation of the Elias delta code for n (A281150(n)).", "sequence": "1,8,9,20,21,22,23,192,193,194,195,196,197,198,199,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857", "code": "\ndef unary(n):\n....return \"1\"*(n-1)+\"0\"\ndef elias_gamma(n):\n....if n==1:\n........return \"1\"\n....k=int(math.log(n, 2))\n....fp=unary(1+k)    \n....sp=n-2**(k)      \n....nb=k             \n....sp=bin(sp)[2:]\n....if len(sp)<nb:\n........sp=(\"0\"*(nb-len(sp)))+sp\n....return fp+sp\ndef elias_delta(n):\n....if n==1:\n........return \"1\"\n....k=int(math.log(n, 2))\n....fp=elias_gamma(1+k)\n....sp=n-2**(k)        \n....nb=k               \n....sp=bin(sp)[2:]\n....if len(sp)<nb:\n........sp=(\"0\"*(nb-len(sp)))+sp\n....return fp+sp\ndef a(n):\n....return int(elias_delta(n),2)\n"}
{"sequence_id": "A281227", "text": "Primes whose binary reflected Gray code representation is also the decimal representation of a prime.", "sequence": "2,53,233,281,397,521,613,673,733,773,797,829,1049,1129,1433,1553,1697,1933,2129,2237,2273,2281,2437,2521,2557,2617,2729,2969,3121,3181,3413,3457,3517,3637,3709,3761,3881,4337,4357,4729,4733,4877,4889,5101,5657,5813,5857,6113,6133", "code": "\nfrom sympy import isprime\ndef gray(n):\n....return bin(n^(n/2))[2:]\ni=1\nj=1\nwhile j<=481:\n....if isprime(i)==True and isprime(int(gray(i)))==True:\n........print str(j)+\" \"+str(i)\n........j+=1\n....i+=1\n"}
{"sequence_id": "A281253", "text": "Alternately concatenate the decimal digits from front to back 1...n such that n is always to the right.", "sequence": "1,12,213,3124,42135,531246,6421357,75312468,864213579,97531246810,1086421357911,119753124681012,12108642135791113,1311975312468101214,141210864213579111315,15131197531246810121416,1614121086421357911131517", "code": "\ndef a(n):\n....if n==1:\n........return [\"1\"]\n....return a(n-1)[::-1]+[str(n)]\ndef A281253(n):\n....return \"\".join(a(n)) \n"}
{"sequence_id": "A281254", "text": "Concatenate the decimal numbers n n-2 n-4 ...5 3 1 2 4 ... n-5 n-3 n-1 if n is odd, or n n-2 n-4 ... 6 4 2 1 3 5 ... n-5 n-3 n-1 if n is even.", "sequence": "1,21,312,4213,53124,642135,7531246,86421357,975312468,10864213579,1197531246810,121086421357911,13119753124681012,1412108642135791113,151311975312468101214,16141210864213579111315,1715131197531246810121416", "code": "\ndef a(n):\n....if n==1:\n........return [\"1\"]\n....return [str(n)]+a(n-1)[::-1]\ndef A281254(n):\n....return \"\".join(a(n)) \n"}
{"sequence_id": "A281313", "text": "Write n in Elias's delta code, interchange the 1's and 0's and convert it back to decimal.", "sequence": "0,7,6,11,10,9,8,63,62,61,60,59,58,57,56,111,110,109,108,107,106,105,104,103,102,101,100,99,98,97,96,191,190,189,188,187,186,185,184,183,182,181,180,179,178,177,176,175,174,173,172,171,170,169,168,167,166,165,164,163,162", "code": "\ndef a(n):\n....s=\"\"\n....for i in A281150(n):\n........if i==\"1\":\n............s+=\"0\"\n........else:\n............s+=\"1\"\n....return int(s,2)\n"}
{"sequence_id": "A281315", "text": "Number of 2 X 2 matrices with all elements in {0,...,n} and prime determinant.", "sequence": "0,0,13,46,83,191,272,509,687,1010,1291,2019,2364,3468,4132,5079,6072,8298,9234,12189,13621,15984,18095,22965,24886,29942,33248,38385,42073,51053,53882,64609,70619,78663,85424,96024,101521,118804,127940,140598,149375,172123,179424,205334,218216", "code": "\nfrom sympy import isprime\ndef t(n):\n    s=0\n    for a in range(n+1):\n        for d in range(n+1):\n            ad = a * d\n            for c in range(n+1):\n                for b in range(n+1):\n                    if isprime(ad-b*c):\n                        s+=1\n    return s\nfor i in range(187):\n    print(str(i)+\" \"+str(t(i)))\n"}
{"sequence_id": "A281316", "text": "Prime number p such that the decimal representation of its binary reflected Gray code is also a prime.", "sequence": "2,3,5,13,29,41,53,73,113,149,157,173,181,197,229,233,241,293,313,317,349,373,397,541,557,653,661,673,733,757,769,773,797,809,857,953,977,1009,1033,1109,1181,1193,1217,1277,1289,1301,1433,1549,1637,1709,1733,1741,1877,1993,2029,2053,2081", "code": "\nfrom sympy import isprime\ndef G(n):\n....return int(bin(n^(n/2))[2:],2)\ni=1\nj=1\nwhile j<=10000:\n....if  isprime(i)==True and isprime(G(i))==True:\n........print str(j)+\" \"+str(i)\n........j+=1\n....i+=1\n"}
{"sequence_id": "A281333", "text": "a(n) = 1 + floor(n/2) + floor(n^2/3).", "sequence": "1,1,3,5,8,11,16,20,26,32,39,46,55,63,73,83,94,105,118,130,144,158,173,188,205,221,239,257,276,295,316,336,358,380,403,426,451,475,501,527,554,581,610,638,668,698,729,760,793,825,859,893,928,963,1000,1036,1074,1112,1151,1190", "code": " [1+int(n/2)+int(n**2/3) for n in range(60)]\n"}
{"sequence_id": "A281363", "text": "Smallest m>0 such that (2*n)^2 - 1 divides (2^m)^(2*n) - 1.", "sequence": "1,1,2,3,3,5,6,1,4,9,3,55,90,9,14,5,30,1,18,3,10,21,6,161,84,2,130,45,9,29,30,3,2,33,11,35,90,15,5,351,27,82,28,7,22,15,90,3,120,3,50,51,6,53,18,9,154,33,12,11,110,25,50,7,7,195,18,9,34,69", "code": "\ndef A281363(n):\n    m, q = 1, 4*n**2-1\n    p = pow(2, 2*n, q)\n    r = p\n    while r != 1:\n        m += 1\n        r = (r*p) % q\n    return m \n"}
{"sequence_id": "A281377", "text": "Write n in Elias's omega code, interchange the 1's and 0's and convert it back to decimal.", "sequence": "1,3,1,23,21,19,17,15,13,11,9,7,5,3,1,735,733,731,729,727,725,723,721,719,717,715,713,711,709,707,705,1343,1341,1339,1337,1335,1333,1331,1329,1327,1325,1323,1321,1319,1317,1315,1313,1311,1309,1307,1305,1303,1301,1299,1297,1295,1293", "code": "\ndef a(n):\n....s=\"\"\n....for i in A281193(n):\n........if i==\"1\":\n............s+=\"0\"\n........else:\n............s+=\"1\"\n....return int(s, 2)\n"}
{"sequence_id": "A281378", "text": "Palindromic numbers which are also palindromic in their binary reflected Gray code representation.", "sequence": "0,1,2,5,6,66,77,626,5005,7777,22122,64446,87978,399993,1287821,5614165,5679765,6407046,6865686,7107017,8349438,8547458,282777282,1220330221,43474247434,43833533834,64630703646,68622322686,73855855837,1249451549421,2468208028642", "code": "\ndef G(n):\n....return bin(n^(n/2))[2:]\ni=1\nj=1\nwhile j<=23:\n....if  i==int(str(i)[::-1]) and G(i)==G(i)[::-1]:\n........print str(j)+\" \"+str(i)\n........j+=1\n....i+=1\n"}
{"sequence_id": "A281379", "text": "Numbers which are palindromic in their binary reflected Gray code representation.", "sequence": "0,1,2,5,6,10,14,18,21,25,30,34,42,54,62,66,77,85,90,102,105,113,126,130,146,170,186,198,214,238,254,258,285,301,306,330,341,357,378,390,409,425,438,462,465,481,510,514,546,594,626,650,682,730,762,774,806,854,886,910,942", "code": "\ndef G(n):\n....return bin(n^(n/2))[2:]\ni=0\nj=1\nwhile j<=10000:\n....if G(i)==G(i)[::-1]:\n........print str(j)+\" \"+str(i)\n........j+=1\n....i+=1\n"}
{"sequence_id": "A281380", "text": "Numbers which are palindromic in their Elias delta code representation.", "sequence": "1,3,5,11,19,43,91,123,135,327,455,551,935,1127,1383,1767,2023,2071,2839,3223,3991,4183,4695,5463,5975,6359,6871,7639,8151,8247,9783,10551,12087,12471,14007,14775,16311,16503,17527,19063,20087,20855,21879,23415,24439,24823,25847,27383", "code": "\ni=1\nj=1\nwhile j<=1012:\n....if  A281150(i)==A281150(i)[::-1] :\n........print str(j)+\" \"+str(i)\n........j+=1\n....i+=1\n"}
{"sequence_id": "A281382", "text": "Numbers n such that the decimal equivalent of the binary reflected Gray code representation of n is a palindromic prime.", "sequence": "2,3,5,6,13,70,213,217,229,253,422,426,446,465,534,541,705,741,857,869,8441,8481,9190,9221,9293,10210,10349,10453,10929,11049,12006,12281,12329,12721,12793,14109,14282,20578,20934,21009,21629,21701,22810,22866,23221,23421,28705,29397", "code": "\nfrom sympy import isprime\ndef G(n):\n....return int(bin(n^(n/2))[2:],2)\ni=0\nj=1\nwhile j<=1281:\n....if G(i)==int(str(G(i))[::-1]) and isprime(G(i))==True:\n........print str(j)+\" \"+str(i)\n........j+=1\n....i+=1\n"}
{"sequence_id": "A281388", "text": "Write n in binary reflected Gray code and sum the positions where there is a '1' followed immediately to the right by a '0', counting the leftmost digit as position 1.", "sequence": "0,0,1,2,0,1,1,2,2,0,3,4,1,1,1,2,2,2,6,4,0,3,3,4,4,1,5,5,1,1,1,2,2,2,7,7,2,6,6,4,4,0,5,8,3,3,3,4,4,4,9,6,1,5,5,5,5,1,6,6,1,1,1,2,2,2,8,8,2,7,7,7,7,2,8,12,6,6,6,4,4,4,10,6,0,5,5,8,8,3,9,9,3,3,3", "code": "\ndef g(n):\n....return bin(n^(n/2))[2:]\ndef a(n):\n....x=g(n)\n....s=0\n....for i in range(1,len(x)):\n........if x[i-1]==\"1\" and x[i]==\"0\":\n............s+=i\n....return s\n"}
{"sequence_id": "A281424", "text": "Numbers k such that 16*(10^k - 1)/3 + 1 is prime.", "sequence": "6,23,65,82,108,188,300,342,401,584,1570,4119", "code": "\nfrom sympy import isprime\ndef afind(limit, startk=1):\n    pow10 = 10**startk\n    for k in range(startk, limit+1):\n        if isprime(16*(pow10 - 1)//3 + 1): print(k, end=\", \")\n        pow10 *= 10\nafind(600) \n"}
{"sequence_id": "A281487", "text": "a(n+1) = -Sum_{d|n} a(d), a(1) = 1.", "sequence": "1,-1,0,-1,1,-2,2,-3,4,-5,4,-5,8,-9,7,-9,13,-14,12,-13,18,-21,17,-18,29,-31,23,-28,36,-37,36,-37,50,-55,42,-46,64,-65,53,-62,83,-84,75,-76,94,-107,90,-91,129,-132,107,-121,145,-146,135,-141,180,-193,157", "code": "\na = [1]\nfor n in range(1, 100):\n   a.append(-sum(a[d-1] for d in range(1, n+1) if n%d == 0))\nprint(a)\n"}
{"sequence_id": "A281497", "text": "Write n in binary reflected Gray code and sum the positions where there is a '1' followed immediately to the left by a '0', counting the rightmost digit as position 1.", "sequence": "0,0,0,0,0,1,0,0,1,0,0,2,2,1,0,0,1,2,2,0,0,1,0,3,4,3,3,2,2,1,0,0,1,2,2,3,3,4,3,0,1,0,0,2,2,1,0,4,5,6,6,4,4,5,4,3,4,3,3,2,2,1,0,0,1,2,2,3,3,4,3,4,5,4,4,6,6,5,4,0,1,2,2,0,0,1,0,3,4,3,3,2,2,1,0,5,6,7,7,8,8,9,8,5,6,5,5,7,7,6", "code": "\ndef G(n):\n....return bin(n^(n/2))[2:]\ndef a(n):\n....x=G(n)[::-1]\n....s=0\n....for i in range(1,len(x)):\n........if x[i-1]==\"1\" and x[i]==\"0\":\n............s+=i\n....return s\n"}
{"sequence_id": "A281499", "text": "Write n in binary reflected Gray code, interchange the 1's and 0's, reverse the code and convert it back to decimal.", "sequence": "1,0,0,2,4,0,2,6,12,4,0,8,10,2,6,14,28,12,4,20,16,0,8,24,26,10,2,18,22,6,14,30,60,28,12,44,36,4,20,52,48,16,0,32,40,8,24,56,58,26,10,42,34,2,18,50,54,22,6,38,46,14,30,62,124,60,28,92,76,12,44,108,100,36,4,68,84,20,52,116,112,48,16,80,64,0,32,96,104,40,8,72,88,24,56,120", "code": "\ndef G(n):\n....return bin(n^(n/2))[2:]\ndef a(n):\n....s=\"\"\n....x=G(n)\n....for i in x:\n........if i==\"1\":s+=\"0\"\n........else:s+=\"1\"\n....s=s[::-1]\n....return int(s,2)\n"}
{"sequence_id": "A281550", "text": "Number of 2 X 2 matrices with all elements in 0..n such that the sum of the elements is prime.", "sequence": "0,10,46,114,234,458,826,1370,2090,3010,4174,5658,7534,9930,12954,16662,21074,26242,32246,39182,47186,56386,66874,78798,92290,107434,124282,142942,163550,186266,211250,238626,268526,301134,336610,375086,416678,461454,509434,560662,615182,673106", "code": "\nfrom sympy import isprime\ndef t(n):\n....s=0\n....for a in range(0, n+1):\n........for b in range(0, n+1):\n............for c in range(0, n+1):\n................for d in range(0, n+1):\n....................if isprime(a+b+c+d)==True:\n........................s+=1\n....return s\nfor i in range(0, 201):\n....print str(i)+\" \"+str(t(i))\n"}
{"sequence_id": "A281551", "text": "Prime numbers p such that the decimal representation of its Elias gamma code is also a prime.", "sequence": "3,23,41,47,59,89,101,149,179,227,317,347,353,383,389,479,503,599,821,887,929,977,1019,1109,1229,1283,1319,1511,1571,1619,1667,1709,1733,1787,1847,1889,1907,1913,1931,2207,2309,2333,2357,2399,2417,2459,2609,2753,2789,2909,2963,2999,3203,3257,3299", "code": "\nimport math\nfrom sympy import isprime\ndef unary(n):\n....return \"1\"*(n-1)+\"0\"\ndef elias_gamma(n):\n....if n ==1:\n........return \"1\"\n....k=int(math.log(n,2))\n....fp=unary(1+k)    \n....sp=n-2**(k)      \n....nb=k             \n....sp=bin(sp)[2:]\n....if len(sp)<nb:\n........sp=(\"0\"*(nb-len(sp)))+sp\n....return int(fp+sp,2)\ni=1\nj=1\nwhile j<=2014:\n....if isprime(i)==True and isprime(elias_gamma(i))==True:\n........print str(j)+\" \"+str(i)\n........j+=1\n....i+=1\n"}
{"sequence_id": "A281552", "text": "Write n in the Elias gamma code and sum the positions where there is a '1' followed immediately to the right by a '0', counting the leftmost digit as position 1.", "sequence": "0,1,1,2,2,6,2,3,3,9,3,8,8,9,3,4,4,12,4,11,11,12,4,10,10,18,10,11,11,12,4,5,5,15,5,14,14,15,5,13,13,23,13,14,14,15,5,12,12,22,12,21,21,22,12,13,13,23,13,14,14,15,5,6,6,18,6,17,17,18,6,16,16,28,16,17,17,18,6", "code": "\ndef a(n):\n....x= A281149(n)\n....s=0\n....for i in range(1,len(x)):\n........if x[i-1]==\"1\" and x[i]==\"0\":\n............s+=i\n....return s\n"}
{"sequence_id": "A281553", "text": "Write n in binary reflected Gray code, rotate one binary place to the right and convert the code back to decimal.", "sequence": "0,1,3,1,3,7,6,2,6,14,15,7,5,13,12,4,12,28,29,13,15,31,30,14,10,26,27,11,9,25,24,8,24,56,57,25,27,59,58,26,30,62,63,31,29,61,60,28,20,52,53,21,23,55,54,22,18,50,51,19,17,49,48,16,48,112,113,49,51,115,114,50,54,118", "code": "\ndef rotation(n):\n....x=bin(n^(n/2))[2:]\n....return int(x[-1]+x[:-1],2)\n"}
{"sequence_id": "A281581", "text": "a(n) = (15*2^(2*n+2) + 15*2^(n+2) + 5*2^(n+3)*3^(n+1) - 24*5^(n+1))/120.", "sequence": "1,4,21,127,807,5179,33111,210067,1321887,8255899,51225351,316067107,1941032367,11873549419,72394874391,440204293747,2670669533247,16172309991739,97779619272231,590423692897987,3561340764760527,21462312506478859", "code": " def A281581(n): return (15*2**(2*n+2) + 15*2**(n+2) + 5*2**(n+3)*3**(n+1) - 24*5**(n+1)) / 120 \n"}
{"sequence_id": "A281593", "text": "a(n) = b(n) - Sum_{j=0..n-1} b(n) with b(n) = binomial(2*n, n).", "sequence": "1,1,3,11,41,153,573,2157,8163,31043,118559,454479,1747771,6740059,26055459,100939779,391785129,1523230569,5931153429,23126146629,90282147849,352846964649,1380430179489,5405662979649,21186405207549,83101804279101,326199124351701", "code": "\nimport math\ndef C(n,r): return f(n)/f(r)/f(n-r)\ndef A281593(n):\n    s=0\n    for j in range(0,n):\n        s+=C(2*j,j)\n    return C(2*n,n)-s \n"}
{"sequence_id": "A281795", "text": "Number of unit squares (partially) covered by a disk of radius n centered at the origin.", "sequence": "0,4,16,36,60,88,132,172,224,284,344,416,484,568,664,756,856,956,1076,1200,1324,1452,1600,1740,1884,2040,2212,2392,2560,2732,2928,3120,3332,3536,3748,3980,4192,4428,4660,4920,5172,5412,5688,5956,6248,6528,6804,7104,7400,7716", "code": "\na = lambda n: sum(4 for x in range(n) for y in range(n)\n                    if x*x + y*y < n*n)\n(Matlab / Octave)\na = @(n) 4*sum(ceil(sqrt(n.^2-(0:n-1).^2))); % _Luis Mendo_, Aug 09 2021\n"}
{"sequence_id": "A281873", "text": "a(n+1) is the smallest number greater than a(n) such that Sum_{j=1..n+1} 1/a(j) <= 4, a(1) = 1.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,200,77706,16532869712,3230579689970657935732,36802906522516375115639735990520502954652700", "code": "\nfrom sympy import egyptian_fraction\nprint(egyptian_fraction(4)) \n"}
{"sequence_id": "A281899", "text": "a(n) = n + 6*floor(n/3).", "sequence": "0,1,2,9,10,11,18,19,20,27,28,29,36,37,38,45,46,47,54,55,56,63,64,65,72,73,74,81,82,83,90,91,92,99,100,101,108,109,110,117,118,119,126,127,128,135,136,137,144,145,146,153,154,155,162,163,164,171,172,173,180,181,182,189", "code": " [n+6*int(n/3) for n in range(70)]\n"}
{"sequence_id": "A282046", "text": "From solution to a certain functional equation.", "sequence": "1,6,66,852,11874,172860,2586108,39403704,608191266,9477587436,148782847572,2349371691528,37276209494076,593819849120712,9492182832078888,152184075600182352,2446292788927524258,39414680294672271756,636376864032528135204,10294159197891381551208", "code": "\nfact = [1]\nfor i in range(1, 80):\n    fact.append(fact[-1]*i)\ndef cnk(n, k):\n    return fact[n]//fact[k]//fact[n-k]\ndef cc(N): \n    c = [1]\n    for n in range(1, N):\n        c.append(sum(cnk(n+k+1, 3*k+1)*4**(n-2*k)*c[k] for k in range(n//2+1)) - sum(cnk(n+2*k+1, 3*k+1)*(-2)**(n-k)*c[k] for k in range(n)))\n    return c\ndef dd(ccc):\n    d = [1]\n    for n in range(1, len(ccc)):\n        d.append((ccc[n]-sum(d[k]*d[n-k] for k in range(1, n)))//2)\n    return d\nprint(dd(cc(25)))\n\n"}
{"sequence_id": "A282087", "text": "Number of length-n ternary strings that do not contain both \"00\" and \"11\".", "sequence": "1,3,9,27,79,229,657,1871,5295,14909,41801,116783,325287,903741,2505377,6932479,19151519,52833853,145578265,400705135,1101936119,3027902045,8314284721,22816209855,62579270191,171559358493,470132335209,1287861941487,3526800739399", "code": "\nimport itertools\n\ndef find_a_sub_n(n):\n    c = 0\n    for q in itertools.product(*([['0','1','2']]*n)):\n        h = ''.join(q)\n        if not (('11' in h) and ('00' in h)):\n            c = c+1\n    return c\n"}
{"sequence_id": "A282094", "text": "Larger member of a pair (x,y) which solves x^2 + y^2 = z^3 for nonnegative x, y and z.", "sequence": "0,1,2,8,10,11,16,26,27,30,39,46,52,54,64,68,80,88,100,110,117,120,125,128,130,142,145,170,198,205,208,216,222,236,240,250,270,286,297,310,312,322,343,350,366,368,371,377,406,414,415,416,432,455,481", "code": "\nfrom sympy import factorint\ndef is_cube(n):\n    if n==0: return True\n    return all(i%3==0 for i in factorint(n).values())\ndef ok(n):\n    return any(is_cube(x**2 + n**2) for x in range(n + 1))\nprint([n for n in range(501) if ok(n)]) \n"}
{"sequence_id": "A282137", "text": "Expansion of (24x^2-10x-1)/(16x^3-16x^2+x-1).", "sequence": "1,11,-29,-189,451,3011,-7229,-48189,115651,771011,-1850429,-12336189,29606851,197379011,-473709629,-3158064189,7579354051,50529027011,-121269664829,-808464432189,1940314637251,12935430915011,-31045034196029,-206966894640189", "code": "\nprint([[1, 11, -29, -189][n%4] + [450, 3000, -7200, -48000][n%4]*(256**(n//4)-1)//255 for n in range(24)])\n"}
{"sequence_id": "A282212", "text": "Number of maximal squarefree words of length n over the alphabet {0,1,2}.", "sequence": "0,0,0,0,0,0,6,0,0,0,6,6,6,6,24,24,24,36,54,54,120,138,216,240,384,444,528,690,966,1236,1602,2112,2712,3522,4818,6150,8094,10452,13854,17784,23082,29970,39438,51030,66792,86502,113064,147036,191952,249390", "code": "\ndef isf(s): \n    for l in range(1, len(s)//2 + 1):\n        if s[-2*l:-l] == s[-l:]: return False\n    return True\ndef aupton(nn, verbose=False):\n    alst, sfs = [], set(\"0\")\n    for n in range(1, nn+1):\n        an, sfsnew = 0, set()\n        for s in sfs:\n            se = [s+i for i in \"012\" if isf(s+i)]\n            if len(se) > 0: sfsnew.update(se)\n            else: an += 3\n        alst, sfs = alst+[an], sfsnew\n        if verbose: print(n, an)\n    return alst\nprint(aupton(40)) \n"}
{"sequence_id": "A282319", "text": "a(n) = (2097203 mod n)^2 + (2097203 mod n) + 41.", "sequence": "41,43,47,53,53,71,53,53,71,53,131,173,61,53,113,53,281,71,47,53,347,131,347,173,53,347,71,53,151,593,547,421,461,281,53,593,83,503,347,53,197,347,97,1033,593,347,313,1301,53,53,1097,1933,2203,71", "code": "\ndef formul(i):\n    return ((i*i+2097203)%i)*((i*i+2097203)%i)+((i*i+2097203)%i)+41\nfor i in range(1, 169):\n    n=formul(i)\n    print(n, end=\", \")\n"}
{"sequence_id": "A282329", "text": "Start with 2, then successively subtract the primes 3, 5, 7, ...", "sequence": "2,-1,-6,-13,-24,-37,-54,-73,-96,-125,-156,-193,-234,-277,-324,-377,-436,-497,-564,-635,-708,-787,-870,-959,-1056,-1157,-1260,-1367,-1476,-1589,-1716,-1847,-1984,-2123,-2272,-2423,-2580,-2743,-2910", "code": " from sympy import prime, isprime\nsub=2\nprint(sub, end=\", \")\nfor i in range (3, 200, 2):\n    if (isprime(i)==True):\n        sub=sub-i\n        print(sub, end=\", \")\n"}
{"sequence_id": "A282384", "text": "Numbers n such that the decimal expansion of n^2 contains n+1.", "sequence": "11,76,101,759,1001,2434,3826,5618,10001,36559,47576,62511,67947,68443,82621,100001,105125,312511,684429,880618,1000001,4687499,5123596,7130618,8703826,10000001,26452434,33620473,38837976,39904875,43605459,54687499,86421306,100000001", "code": "\nA282384_list = [i for i in range(1,10**6) if str(i+1) in str(i**2)]\n"}
{"sequence_id": "A282389", "text": "Number of squares in triangle-shaped polyominoes obtained by adding three identical polyominoes to the previous one, starting with one L-tetromino.", "sequence": "4,10,25,70,238,901,3445,13390,52942,210226,838450,3350725,13393093,53547790,214151950,856558645,3426077749,13703917774,54815043790,219258602290,877031899954,3508124454085,14032487779525,56129938535185,224519713993489,898078755310654", "code": "\nm = [3, 1]\nfor i in range(25):\n    w, h = m[0], len(m)\n    print(sum(m)) \n    m2 = [w-x for x in reversed(m) if w>x]\n    m = [w+x for x in m2] + [w for x in m if x==w] + m2\n\n"}
{"sequence_id": "A282390", "text": "Width of polyominoes in A282389.", "sequence": "3,5,8,14,27,53,104,206,410,818,1635,3269,6536,13070,26139,52277,104552,209102,418202,836402,1672803,3345605,6691209,13382417,26764832,53529662,107059322,214118642,428237283,856474565,1712949128,3425898254,6851796507", "code": "\nw, h, bp, bp2 = 3, 2, 0b10, 0b01\nfor i in range(1, 10):\n    print(w)\n    w, h, bp, bp2 = w*2-(2 if (bp&1) else 1), 2**i+1, ((bp2&((1<<(h-1))-1))<<h)+bp2, (bp<<(h-1))+(bp>>1)\nfor i in range(100):\n    print(w)\n    w, h, bp, bp2 = w*2-(2 if (bp&1) else 1), h-1, bp2, (bp>>1)\n\n"}
{"sequence_id": "A282409", "text": "Numbers n for which the number of odd members and the number of even members in the Collatz (3x+1) trajectory are both prime.", "sequence": "3,9,10,12,13,22,23,40,42,73,88,90,92,93,114,115,118,119,144,148,149,152,154,162,163,164,165,166,192,208,212,213,226,227,251,295,318,319,350,351,576,592,596,597,608,616,618,625,640,642,643,648,650,652,653", "code": "\nfrom sympy import isprime\ndef a(n):\n    l=[n]\n    while True:\n        if n%2==0: n//=2\n        else: n = 3*n + 1\n        l.append(n)\n        if n<2: break\n    o=list(filter(lambda i: i%2==1, l))\n    e=list(filter(lambda i: i%2==0, l))\n    return [o, e]\nprint([n for n in range(2, 1001) if isprime(len(a(n)[0])) and isprime(len(a(n)[1]))]) \n"}
{"sequence_id": "A282444", "text": "Numbers k such that A282442(k) = k + 1.", "sequence": "1,2,5,8,14,50,119,200,269,299,1154,5369,47249,48299,58643,130325,148979,282074,887480", "code": "\ndef A282442():\n    n = 0\n    while True:\n        n += 1\n        h = n\n        k = 2\n        while h >= k:\n            h = h % k\n            h = n - h\n            k += 1\n        yield k\nn=0\nfor i in A282442():\n    n += 1\n    if i == n+1:\n        print(n) \n"}
{"sequence_id": "A282473", "text": "Multiples of 9 which cannot be expressed as the difference between a natural number k and its digit sum s(k).", "sequence": "90,189,288,387,486,585,684,783,882,981,990,1089,1188,1287,1386,1485,1584,1683,1782,1881,1980,1989,2088,2187,2286,2385,2484,2583,2682,2781,2880,2979,2988,3087,3186,3285,3384,3483,3582,3681,3780,3879,3978,3987,4086,4185,4284,4383,4482,4581,4680,4779,4878,4977,4986", "code": "\nfrom math import ceil\ndef a(n): \n    def s(n):\n        r = 0\n        while n:\n            r, n = r + n% 10, n//10\n        return r\n    mult9=[]\n    if n%9==0:\n        for x in range(1, ceil(n/9)+1):\n            mult9.append(9*x)\n    else:\n        for x in range(1, ceil(n/9)):\n            mult9.append(9*x)\n    for y in range(1, ceil(n/10)+1):\n        mult9.remove(10*y-s(10*y))\n    return mult9\n"}
{"sequence_id": "A282539", "text": "a(1)=1, a(n) is the smallest integer not included earlier such that a(n)*a(n-1)-1 and a(n)*a(n-1)+1 are twin primes.", "sequence": "1,4,3,2,6,5,12,9,8,24,10,15,16,27,30,14,33,20,21,22,39,28,51,42,11,18,29,72,26,57,74,45,36,23,84,13,66,7,60,17,126,38,111,68,54,37,90,31,48,44,75,34,63,56,105,32,81,50,93,106,138,40,78,19,222,110,69,58", "code": "\nfrom sympy import isprime\na = [1]\nfound = True\nwhile found:\n  found = False\n  prev = a[len(a)-1]\n  for k in range(2,10001):\n    if isprime(prev*k-1) and isprime(prev*k+1) and (k not in a):\n      print str(k)+',',\n      a.append(k)\n      found = True\n      break\n"}
{"sequence_id": "A282721", "text": "Let p = n-th prime == 3 mod 8; a(n) = sum of quadratic residues mod p that are < p/2.", "sequence": "1,13,32,137,306,314,555,876,1400,1416,1742,2450,3099,3788,4816,5430,6351,7344,8393,9546,12858,13373,15265,17277,16311,18403,19521,22344,21805,23590,25495,26805,30767,30863,31570,35980,40678,43946,45640,49124,50055,52776,58418,66210,71521,71665,83666,81628", "code": "\nfrom sympy import isprime\ndef a(p):\n    r=(p - 1)//2\n    t=0\n    for j in range(1, r + 1):\n        q=(j**2)%p\n        if q<=r:t+=q\n    return t\nprint([a(p) for p in range(3, 2001, 8) if isprime(p)]) \n"}
{"sequence_id": "A282727", "text": "Let p = n-th prime == 3 mod 8; a(n) = (sum of quadratic residues mod p that are < p/2) + (sum of all quadratic residues mod p).", "sequence": "2,35,108,567,1073,1386,2132,3551,5330,6003,8262,9968,13860,16046,19625,24957,29376,34155,37541,44793,54758,61217,68036,75215,77688,85347,93366,98912,101745,107531,119583,129042,135548,145607,149040,170478,193356,205335,213521,230373,243432,256851,280016,294395", "code": "\nfrom sympy import isprime\ndef v(x, r):\n    return 2*x if x<=r else x\ndef a(p):\n    r=(p - 1)//2\n    return sum(v((j**2)%p, r) for j in range(1, r + 1))\nprint([a(p) for p in range(3, 2001, 8) if isprime(p)]) \n"}
{"sequence_id": "A282852", "text": "37-gonal numbers: a(n) = n*(35*n-33)/2.", "sequence": "0,1,37,108,214,355,531,742,988,1269,1585,1936,2322,2743,3199,3690,4216,4777,5373,6004,6670,7371,8107,8878,9684,10525,11401,12312,13258,14239,15255,16306,17392,18513,19669,20860,22086,23347,24643,25974", "code": "\nfor n in range(0,51):\n... print(n*(35*n-33)/2)\n"}
{"sequence_id": "A283001", "text": "a(n) = (A004186(n) - n)/9.", "sequence": "0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,0,0,0,1,2,3,4,5,6,7,0,0,0,0,1,2,3,4,5,6,0,0,0,0,0,1,2,3,4,5,0,0,0,0,0,0,1,2,3,4,0,0,0,0,0,0,0,1,2,3,0,0,0,0,0,0,0,0,1,2,0,0,0,0,0,0,0,0,0,1", "code": " def A283001(n): return (int(\"\".join(sorted(str(n),reverse=True)))-n)/9 \n"}
{"sequence_id": "A283026", "text": "Number of inequivalent 4 X 4 matrices with entries in {1,2,3,..,n} up to row permutations.", "sequence": "0,1,3876,1929501,183181376,6419043125,118091211876,1388168405001,11745311589376,77279801651001,416916712502500,1915356782994501,7705740009485376,27731516944463501,90762229896563876,273716119247180625,768684707117285376,2027695320242670001", "code": " def A283026(n) : return n**4*(n**4 + 1)*(n**4 + 2)*(n**4 + 3)/24 \n"}
{"sequence_id": "A283027", "text": "Number of inequivalent 4 X 4 matrices with entries in {1,2,3,...,n} up to rotations.", "sequence": "0,1,16456,10763361,1073758336,38147070625,705277897416,8308234084801,70368748374016,463255057977921,2500000025005000,11487432519490081,46221064831264896,166354152499741921,544488334821309256,1642102089568970625,4611686019501162496", "code": " def A283027(n) : return n**4*(n**4 + 1)*(n**8 - n**4 + 2)/4 \n"}
{"sequence_id": "A283028", "text": "Number of inequivalent 4 X 4 matrices with entries in {1,2,3,...,n} up to vertical and horizontal reflections.", "sequence": "0,1,16576,10766601,1073790976,38147265625,705278736576,8308236966001,70368756760576,463255079498001,2500000075000000,11487432626662201,46221065046245376,166354152907593001,544488335559184576,1642102090850390625,4611686021648613376", "code": " def A283028(n): return n**8*(n**8 + 3)/4 \n"}
{"sequence_id": "A283029", "text": "Number of inequivalent 5 X 5 matrices with entries in {1,2,3,..,n} when a matrix and its transpose are considered equivalent.", "sequence": "0,1,16793600,423651479175,562950490292224,149011627197265625,14215144250057342976,670534312205763205375,18889465949070766899200,358948993948871860432449,5000000000500000000000000,54173529719030485105622951,476981083228048575587942400", "code": " def A283029(n): return n**15*(n**2+1)*(n**8-n**6+n**4-n**2+1)/2 \n"}
{"sequence_id": "A283030", "text": "Number of inequivalent 5 X 5 matrices with entries in {1,2,3,...,n} up to row permutations.", "sequence": "0,1,376992,7355513529,9474438804480,2491483056641250,237223883948569056,11182222570880983622,314920519245916176384,5983496429606726016735,83341666958337500020000,902948225666983587054711,7950004204832195461143552,58805000552467321853765064", "code": " def A283030(n): return (10*n**20 + 35*n**15 + 50*n**10 + 24*n**5 + n**25)/120 \n"}
{"sequence_id": "A283031", "text": "Number of inequivalent 5 X 5 matrices with entries in {1,2,3,...,n} up to rotations.", "sequence": "0,1,8390720,211822552035,281474993496064,74505806274453125,7107572010747738816,335267154940213889575,9444732965876730429440,179474496923598616041129,2500000000002500005000000,27086764858479561198237131,238490541610199280719585280", "code": " def A283031(n): return n**7*(n**2 + 1)*(n**4 - n**2 + 1)*(n**12 - n**6 + 2)/4 \n"}
{"sequence_id": "A283032", "text": "Number of inequivalent 5 X 5 matrices with entries in {1,2,3,...,n} up to vertical and horizontal reflections.", "sequence": "0,1,8407040,211829725395,281475530358784,74505821533203125,7107572245840091136,335267157313994232775,9444732983468915425280,179474497026544179696969,2500000000502500000000000,27086764860568185273201371,238490541617902791488962560", "code": " def A283032(n): return n**13*(n**2 + 1)*(n**10 - n**8 + n**6 - n**4 + n**2 + 1)/4 \n"}
{"sequence_id": "A283033", "text": "Number of inequivalent 5 X 5 matrices with entries in {1,2,3,...,n} up to rotations and reflections.", "sequence": "0,1,4211744,105918450471,140738033618944,37252918396015625,3553786240466361696,167633579843887699759,4722366500530551259136,89737248564744874067889,1250000000501250002500000,13543382431328404683826391,119245270812803151147085824", "code": " def A283033(n): return n**7*(n**18 + 4*n**8 + n**6 + 2)/8 \n"}
{"sequence_id": "A283070", "text": "Sierpinski tetrahedron or tetrix numbers: a(n) = 2*4^n + 2.", "sequence": "4,10,34,130,514,2050,8194,32770,131074,524290,2097154,8388610,33554434,134217730,536870914,2147483650,8589934594,34359738370,137438953474,549755813890,2199023255554,8796093022210,35184372088834,140737488355330,562949953421314", "code": "\ndef a(n): return 2*4**n + 2\nprint([a(n) for n in range(25)]) \n"}
{"sequence_id": "A283165", "text": "a(0) = 0; a(1) = 1; a(2*n) = 2*a(n), a(2*n+1) = 2*a(n) + (-1)^a(n+1).", "sequence": "0,1,2,3,4,3,6,7,8,7,6,7,12,11,14,15,16,15,14,15,12,11,14,15,24,23,22,23,28,27,30,31,32,31,30,31,28,27,30,31,24,23,22,23,28,27,30,31,48,47,46,47,44,43,46,47,56,55,54,55,60,59,62,63,64,63,62,63,60,59,62,63,56,55,54,55,60,59,62,63,48,47,46,47,44,43,46,47,56,55,54", "code": "\ndef a(n):\n....if n<2: return n\n....if n%2==0: return 2*a(n/2)\n....else: return 2*a((n-1)/2)+(-1)**a((n+1)/2) \n"}
{"sequence_id": "A283187", "text": "a(0) = 0; a(1) = 1; a(2*n) = 2*a(n), a(2*n+1) = a(n) + (-1)^a(n+1).", "sequence": "0,1,2,2,4,3,4,3,8,3,6,4,8,3,6,4,16,7,6,4,12,7,8,5,16,7,6,4,12,7,8,5,32,15,14,8,12,7,8,5,24,11,14,8,16,7,10,6,32,15,14,8,12,7,8,5,24,11,14,8,16,7,10,6,64,31,30,16,28,15,16,9,24,11,14,8,16,7,10,6,48,23,22,12,28,15,16,9,32,15,14", "code": "\ndef a(n):\n....if n==0 or n==1: return n\n....if n%2==0: return 2*a(n/2)\n....else: return a((n-1)/2)+(-1)**a((n+1)/2) \n"}
{"sequence_id": "A283188", "text": "A periodic sequence of 8-bit binary numbers for single-bit multi-frequency generation.", "sequence": "255,127,191,31,207,71,163,33,240,80,152,24,236,108,174,6,215,87,179,51,235,73,137,9,252,116,180,20,198,70,170,42,251,91,155,17,229,101,165,5,220,92,186,58,234,66,130,2,247,117,189,29,205,77,169,33,242,82,146,18,238,110,174,12,221", "code": "\ndef A283188(n):\n....s=0\n....for k in range(1,9):\n........s+=(((n-k)/k)%2) * 2**(8-k)\n....return s \n"}
{"sequence_id": "A283207", "text": "a(n) = a(floor(n/a(n-1))) + a(floor(n/a(n-2))) with a(1) = a(2) = 2.", "sequence": "2,2,4,4,4,4,4,4,4,4,4,8,6,4,6,6,4,8,6,6,8,6,6,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A283207(n):\n    return 2 if n <= 2 else A283207(n//A283207(n-1)) + A283207(n//A283207(n-2)) \n"}
{"sequence_id": "A283240", "text": "Triangle read by rows: T(n,k) = number of directed self-avoiding walks (SAWs) of length k in an n-ladder graph that use all rows of the graph.", "sequence": "2,2,0,4,8,8,0,0,4,12,20,16,0,0,0,4,16,32,40,28,0,0,0,0,4,20,48,72,72,44,0,0,0,0,0,4,24,68,120,144,120,64,0,0,0,0,0,0,4,28,92,188,264,264,188,88,0,0,0,0,0,0,0,4,32,120,280,452,528,452,280,116", "code": "\nmaxN=20\nTnk=[[0 for column in range(0, row*2)] for row in range(0,maxN+1)]\nTnk[1][0]=2 \nTnk[1][1]=2 \nfor row in range(2,maxN+1):\n    for column in range(0, row*2):\n        if(column+1 < row):\n            \n            Tnk[row][column] = 0\n        elif(column+1 == row):\n            \n            Tnk[row][column] = 4\n        elif(column == row*2 -1):\n            \n            Tnk[row][column] = 2*(row*row - row + 2)\n        elif(column == 2*(row-1)):\n            \n            Tnk[row][column] = Tnk[row-1][column-1] + Tnk[row-1][column-2] + 4\n        else:\n            \n            Tnk[row][column] = Tnk[row-1][column-1] + Tnk[row-1][column-2]\nprint(Tnk)\n"}
{"sequence_id": "A283241", "text": "Triangle read by rows: S(n,k) = total number of directed self-avoiding walks (SAWs) of length k in an n-ladder graph.", "sequence": "2,2,4,8,8,8,6,14,20,28,20,16,8,20,32,52,56,64,40,28,10,26,44,76,96,132,128,128,72,44,12,32,56,100,136,204,240,296,264,232,120,64,14,38,68,124,176,276,356,492,548,608,504,392,188,88", "code": "\n\nmaxN=20\nTnk=[[0 for column in range(0, maxN*2)] for row in range(0, maxN+1)]\nTnk[1][0]=2 \nTnk[1][1]=2 \nfor row in range(2, maxN+1):\n    for column in range(0, row*2):\n        if(column+1 < row):\n            \n            Tnk[row][column] = 0\n        elif(column+1 == row):\n            \n            Tnk[row][column] = 4\n        elif(column == row*2 -1):\n            \n            Tnk[row][column] = 2*(row*row - row + 2)\n        elif(column == 2*(row-1)):\n            \n            Tnk[row][column] = Tnk[row-1][column-1] + Tnk[row-1][column-2] + 4\n        else:\n            \n            Tnk[row][column] = Tnk[row-1][column-1] + Tnk[row-1][column-2]\n\nSnk=[[0 for column in range(0,row*2)] for row in range(0,maxN+1)]\nfor row in range(1,maxN+1):\n    for column in range(0,(row*2)):\n        for i in range(0,row):\n            Snk[row][column]+=(i+1)*Tnk[row-i][column]\nprint(Snk)\n"}
{"sequence_id": "A283298", "text": "Diagonal of the Euler-Seidel matrix for the Catalan numbers.", "sequence": "1,3,26,305,4120,60398,934064,15000903,247766620,4182015080,71816825856,1250772245698,22039796891026,392213323252200,7038863826811100,127248841020380105,2315130641074743540,42358284517663463380,778876539384226875800", "code": "\nfrom sympy import binomial, catalan\ndef a(n): return sum(binomial(n, i)*catalan(n + i) for i in range(n + 1))\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A283321", "text": "Triangle read by rows: T(n,k) (0 <= k <= n) = number of elements of alternating semigroup A_n of height k.", "sequence": "1,1,1,1,2,1,1,9,9,3,1,16,72,48,12,1,25,200,600,300,60,1,36,450,2400,5400,2160,360,1,49,882,7350,29400,52920,17640,2520,1,64,1568,18816,117600,376320,564480,161280,20160,1,81,2592,42336,381024,1905120,5080320,6531840,1632960,181440", "code": "\nfrom sympy import binomial, factorial\ndef T(n,k):\n    if k==n: return factorial(n)//2\n    elif k==n-1: return n**2 * factorial(n - 1) // 2\n    else: return binomial(n, k)**2 * factorial(k)\ni = 0\nfor n in range(10):\n    for k in range(n + 1):\n        if n < 2: print(\"1\")\n        else: print(T(n, k))\n    i += 1 \n"}
{"sequence_id": "A283322", "text": "Row sums of triangle in A283321.", "sequence": "1,2,4,22,149,1186,10807,110762,1260289,15757714,214703831,3165856882,50220944017,852735163034,15429720661279,296365775922106,6021825238479617,129039801791351842,2908148713706872999,68758376703814729154,1701649010958291917521,43990236798804135274282", "code": "\nimport math\nf=math.factorial\ndef C(n,r): return f(n)/f(r)/f(n - r)\ndef T(n,k):\n....if k==n: return f(n)/2\n....elif k==n-1: return n**2 * f(n - 1) / 2\n....else: return C(n, k)**2 * f(k)\ni=0\nl=[]\nfor n in range(0,401):\n....for k in range(0, n+1):\n........if n<2: l+=[1,]\n........else: l+=[T(n,k),]\n....print str(i)+\" \"+str(sum(l))\n....l=[]\n....i+=1 \n"}
{"sequence_id": "A283393", "text": "a(n) = gcd(n^2-1, n^2+9).", "sequence": "1,10,1,2,5,2,5,2,1,10,1,10,1,2,5,2,5,2,1,10,1,10,1,2,5,2,5,2,1,10,1,10,1,2,5,2,5,2,1,10,1,10,1,2,5,2,5,2,1,10,1,10,1,2,5,2,5,2,1,10,1,10,1,2,5,2,5,2,1,10,1,10,1,2,5,2,5,2,1,10,1,10,1,2,5,2,5,2,1,10", "code": " [1, 10, 1, 2, 5, 2, 5, 2, 1, 10]*10\n"}
{"sequence_id": "A283394", "text": "a(n) = 3*n*(3*n + 7)/2 + 4.", "sequence": "4,19,43,76,118,169,229,298,376,463,559,664,778,901,1033,1174,1324,1483,1651,1828,2014,2209,2413,2626,2848,3079,3319,3568,3826,4093,4369,4654,4948,5251,5563,5884,6214,6553,6901,7258,7624,7999,8383,8776,9178,9589,10009", "code": " [3*n*(3*n+7)/2+4 for n in range(50)]\n"}
{"sequence_id": "A283477", "text": "If 2n = 2^e1 + 2^e2 + ... + 2^ek [e1 .. ek distinct], then a(n) = A002110(e1) * A002110(e2) * ... * A002110(ek).", "sequence": "1,2,6,12,30,60,180,360,210,420,1260,2520,6300,12600,37800,75600,2310,4620,13860,27720,69300,138600,415800,831600,485100,970200,2910600,5821200,14553000,29106000,87318000,174636000,30030,60060,180180,360360,900900,1801800,5405400,10810800,6306300,12612600,37837800,75675600", "code": "\nfrom sympy import prime, primerange, factorint\nfrom operator import mul\nfrom functools import reduce\ndef P(n): return reduce(mul, [i for i in primerange(2, n + 1)])\ndef a108951(n):\n    f = factorint(n)\n    return 1 if n==1 else reduce(mul, [P(i)**f[i] for i in f])\ndef a019565(n): return reduce(mul, (prime(i+1) for i, v in enumerate(bin(n)[:1:-1]) if v == '1')) if n > 0 else 1 \ndef a(n): return a108951(a019565(n))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A283478", "text": "a(n) = A097248(A108951(n)).", "sequence": "1,2,6,3,30,5,210,6,15,7,2310,10,30030,11,21,5,510510,30,9699690,14,33,13,223092870,15,105,17,14,22,6469693230,42,200560490130,10,39,19,165,7,7420738134810,23,51,21,304250263527210,66,13082761331670030,26,70,29,614889782588491410,30,1155,210,57,34,32589158477190044730,21,195,33,69,31", "code": "\nfrom sympy import primerange, factorint, nextprime\nfrom operator import mul\ndef P(n): return reduce(mul, [i for i in primerange(2, n + 1)])\ndef a108951(n):\n    f = factorint(n)\n    return 1 if n==1 else reduce(mul, [P(i)**f[i] for i in f])\ndef a097246(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [(nextprime(i)**int(f[i]/2))*(i**(f[i]%2)) for i in f])\ndef a097248(n):\n    k=a097246(n)\n    while k!=n:\n        n=k\n        k=a097246(k)\n    return k\ndef a(n): return a097248(a108951(n)) \n"}
{"sequence_id": "A283556", "text": "Digital root of the sum of the first n primes.", "sequence": "0,2,5,1,8,1,5,4,5,1,3,7,8,4,2,4,3,8,6,1,9,1,8,1,9,7,9,4,3,4,9,1,6,8,3,8,6,1,2,7,9,8,9,2,6,5,6,1,8,1,5,4,9,7,6,2,4,3,4,2,4,8,4,5,1,8,1,8,3,8,6,8,7,5,9,1,6,8,9,5,9,5,3,2,3,1,3,2,9,2,6,5,7,8,4,8,7,3,2,3", "code": "\nfrom sympy import primerange\nfrom itertools import accumulate\nprime_sum = [0] + list(accumulate(primerange(2, 1000)))\ndef dig_root(n): return 1+(n-1)%9\ndef a(n):\n    return 0 if n<1 else dig_root(prime_sum[n])\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A283608", "text": "Numbers whose largest decimal digit is 5.", "sequence": "5,15,25,35,45,50,51,52,53,54,55,105,115,125,135,145,150,151,152,153,154,155,205,215,225,235,245,250,251,252,253,254,255,305,315,325,335,345,350,351,352,353,354,355,405,415,425,435,445,450,451,452,453,454", "code": "\nfrom sympy.ntheory.factor_ import digits\nprint([n for n in range(1, 501) if max(digits(n)[1:])==5]) \n"}
{"sequence_id": "A283609", "text": "Numbers whose largest decimal digit is 6.", "sequence": "6,16,26,36,46,56,60,61,62,63,64,65,66,106,116,126,136,146,156,160,161,162,163,164,165,166,206,216,226,236,246,256,260,261,262,263,264,265,266,306,316,326,336,346,356,360,361,362,363,364,365,366,406,416,426", "code": "\nfrom sympy.ntheory.factor_ import digits\nprint([n for n in range(1, 501) if max(digits(n)[1:])==6]) \n"}
{"sequence_id": "A283610", "text": "Numbers n whose largest decimal digit is 7.", "sequence": "7,17,27,37,47,57,67,70,71,72,73,74,75,76,77,107,117,127,137,147,157,167,170,171,172,173,174,175,176,177,207,217,227,237,247,257,267,270,271,272,273,274,275,276,277,307,317,327,337,347,357,367,370,371,372", "code": "\nfrom sympy.ntheory.factor_ import digits\n[n for n in range(1, 401) if max(digits(n)[1:]) == 7]  \n"}
{"sequence_id": "A283624", "text": "Number of {0,1} n X n matrices with no rows or columns in which all entries are the same.", "sequence": "1,0,2,102,22874,17633670,46959933962,451575174961302,16271255119687320314,2253375946574190518740230,1219041140314101911449662059402,2601922592659455476330065914740044182,22040870572750372076278589658097827953983034", "code": "\nimport math\nf = math.factorial\ndef C(n,r): return f(n)/f(r)/f(n - r)\ndef A(n):\n....s=0\n....for k in range(0, n+1):\n........s+=(-1)**(n + k) * C(n, k) * (2**k -1)**n\n....return 2*s + 2**(n**2) + 2*(2**n - 2)**n - 4*(2**n - 1)**n \n"}
{"sequence_id": "A283642", "text": "Decimal representation of the x-axis, from the origin to the right edge, of the n-th stage of growth of the two-dimensional cellular automaton defined by \"Rule 678\", based on the 5-celled von Neumann neighborhood.", "sequence": "1,3,5,11,21,43,85,171,341,683,1365,2731,5461,10923,21845,43691,87381,174763,349525,699051,1398101,2796203,5592405,11184811,22369621,44739243,89478485,178956971,357913941,715827883,1431655765,2863311531,5726623061,11453246123", "code": " print([(4*2**n + 1)//3 for n in range(50)]) \n"}
{"sequence_id": "A283654", "text": "Triangle read by rows: number of n X m binary matrices with no rows or columns in which all entries are the same (n >= 1, 1 <= m <= n).", "sequence": "0,0,2,0,6,102,0,14,906,22874,0,30,6510,417810,17633670,0,62,42666,6644714,622433730,46959933962,0,126,267582,99044946,20218802310,3204360965106,451575174961302,0,254,1641786,1430529674,630917888610,208308918928634,60134626974122946,16271255119687320314", "code": "\nimport math\nf=math.factorial\ndef C(n,r): return f(n)/f(r)/f(n - r)\ndef T(n,m): return sum([(-1)**j*C(m,j)*(2**(m - j) - 1)**n for j in range (0, m+1)])\ni=1\nfor n in range(1,11):\n....for m in range(1, n+1):\n........print str(i)+\" \"+str(2*T(n, m) + 2**(n*m) + (2**n - 2)**m + (2**m - 2)**n - 2*(2**m - 1)**n - 2*(2**n - 1)**m)\n........i+=1 \n"}
{"sequence_id": "A283678", "text": "Number of possible draws of 2n pairs of consecutive cards from a set of 4n + 1 cards, so that the card that initially occupies the central position is not selected.", "sequence": "1,2,54,4500,771750,225042300,99843767100,62673358948200,52880646612543750,57733914846094987500,79199384385873103852500,133357363417740148141455000,270426506783940730406180497500,650063718230626755784087734375000,1827886309419060919156885553671875000", "code": "\nfrom sympy import binomial, factorial2\nprint([binomial(2*n, n) * factorial2(2*n - 1)**2 for n in range(15)]) \n"}
{"sequence_id": "A283716", "text": "Row n=3 of A283674.", "sequence": "3,32,746,19748,531698,14349932,387424586,10460369588,282429602018,7625597747132,205891133143226,5559060570749828,150094635313776338,4052555153086085132,109418989131780794666,2954312706551907440468,79766443076876804830658", "code": " def A283716(n): return 1 + 4**n + 27**n \n"}
{"sequence_id": "A283718", "text": "Numbers m such that sum of digits of 27*m is 27.", "sequence": "37,74,107,111,137,144,147,148,174,177,181,184,185,207,211,214,217,218,221,222,237,244,247,248,251,254,255,257,258,259,274,277,281,284,285,287,288,291,292,294,295,296,307,311,314,317", "code": "\ndef D(n): return sum([int(i) for i in str(n)])\nfor n in range(37,317):\n....if D(27*n)==27:print str(n)+\",\", \n"}
{"sequence_id": "A283750", "text": "a(n) = n^2 XOR (n + 1)^2.", "sequence": "1,5,13,25,9,61,21,113,17,53,29,233,57,109,37,481,33,101,45,249,41,93,1013,81,49,213,125,457,89,205,69,1985,65,197,77,473,73,253,85,945,209,117,477,169,121,4013,229,417,97,165,1005,185,105,413,181,1937,241,405,189,905,153,397,133,8065,129,389,141,921", "code": " def A283750(n): return (n**2)^(n + 1)**2 \n"}
{"sequence_id": "A283756", "text": "Smallest prime p such that q = 2*p^(2*n + 1) - 1 and r = 2*q^(2*n + 1) - 1 are also prime.", "sequence": "2,523,1531,2731,12781,785503,1439089,372901,1678459,3418531,2986689,62651791,24463189,11887633,14486959,144025633,5546251,55402591,50246569,896263,64925929,110217193,130868911,206925703,93252169,201500821,15370051,352151431,465719869,246405823,1397904439,441472981,662770291,233944933,426610519", "code": "\nfrom sympy import isprime, nextprime\ndef A283756(n):\n....p=2\n....m=2*n + 1\n....while True:\n........q=2*p**m - 1\n........if (not isprime(q) or not isprime(2*q**m - 1)): p = nextprime(p)\n........else: break\n....return p \n"}
{"sequence_id": "A283769", "text": "Numbers k such that L(k) = 0 mod 3, where L = A000201 = lower Wythoff sequence.", "sequence": "2,4,6,8,13,15,17,19,21,26,28,30,32,39,41,43,45,52,54,56,58,65,67,69,71,78,80,82,84,89,91,93,95,97,102,104,106,108,110,115,117,119,121,128,130,132,134,141,143,145,147,154,156,158,160,167,169,171,173", "code": "\nimport math\nfrom sympy import sqrt\nr = (1 + sqrt(5))/2\n[n for n in range(1, 351) if int(math.floor(n*r)) % 3 == 0]  \n"}
{"sequence_id": "A283770", "text": "Numbers k such that L(k) = 1 mod 3, where L = A000201 = lower Wythoff sequence.", "sequence": "1,3,10,12,14,16,23,25,27,29,34,36,38,40,42,47,49,51,53,55,60,62,64,66,73,75,77,79,86,88,90,92,99,101,103,105,112,114,116,118,123,125,127,129,131,136,138,140,142,144,149,151,153,155,162,164,166,168,175", "code": "\nimport math\nfrom sympy import sqrt\nr = (1 + sqrt(5))/2\n[n for n in range(1, 351) if int(math.floor(n*r))%3==1] \n"}
{"sequence_id": "A283771", "text": "Numbers k such that L(k) = 2 mod 3, where L = A000201 = lower Wythoff sequence.", "sequence": "5,7,9,11,18,20,22,24,31,33,35,37,44,46,48,50,57,59,61,63,68,70,72,74,76,81,83,85,87,94,96,98,100,107,109,111,113,120,122,124,126,133,135,137,139,146,148,150,152,157,159,161,163,165,170,172,174,176,183", "code": "\nimport math\nfrom sympy import sqrt\nr = (1 + sqrt(5))/2\n[n for n in range(1, 351) if int(math.floor(n*r))%3==2] \n"}
{"sequence_id": "A283772", "text": "Numbers k such that U(k) = 0 mod 3, where U = A001950 = upper Wythoff sequence.", "sequence": "6,7,14,15,21,22,23,29,30,31,37,38,39,45,46,47,53,54,61,62,69,70,76,77,78,84,85,86,92,93,94,100,101,102,108,109,116,117,124,125,131,132,133,139,140,141,147,148,149,155,156,157,163,164,171,172,179,180", "code": "\nimport math\nfrom sympy import sqrt\nr = (3 + sqrt(5))/2\n[n for n in range(1, 351) if int(math.floor(n*r))%3==0] \n"}
{"sequence_id": "A283773", "text": "Numbers k such that U(k) = 1 mod 3, where U = A001950 = upper Wythoff sequence.", "sequence": "3,4,5,11,12,13,19,20,27,28,35,36,42,43,44,50,51,52,58,59,60,66,67,68,74,75,82,83,90,91,97,98,99,105,106,107,113,114,115,121,122,123,129,130,137,138,144,145,146,152,153,154,160,161,162,168,169,170,176", "code": "\nimport math\nfrom sympy import sqrt\nr = (3 + sqrt(5))/2\n[n for n in range(1, 351) if int(math.floor(n*r))%3==1] \n"}
{"sequence_id": "A283774", "text": "Numbers k such that U(k) == 2 mod 3, where U = A001950 = upper Wythoff sequence.", "sequence": "1,2,8,9,10,16,17,18,24,25,26,32,33,34,40,41,48,49,55,56,57,63,64,65,71,72,73,79,80,81,87,88,89,95,96,103,104,110,111,112,118,119,120,126,127,128,134,135,136,142,143,150,151,158,159,165,166,167,173", "code": "\nimport math\nfrom sympy import sqrt\nr = (3 + sqrt(5))/2\n[n for n in range(1, 351) if int(math.floor(n*r))%3==2] \n"}
{"sequence_id": "A283775", "text": "Numbers k such that floor(k*sqrt(3)) is even.", "sequence": "4,5,6,7,12,13,14,19,20,21,22,27,28,29,34,35,36,37,42,43,44,49,50,51,52,56,57,58,59,64,65,66,67,71,72,73,74,79,80,81,82,86,87,88,89,94,95,96,97,101,102,103,104,109,110,111,116,117,118,119,124,125", "code": "\nimport math\nfrom sympy import sqrt\nprint([n for n in range(1, 126) if int(math.floor(n*sqrt(3)))%2==0]) \n"}
{"sequence_id": "A283776", "text": "Numbers k such that floor(k*sqrt(3)) is odd.", "sequence": "1,2,3,8,9,10,11,15,16,17,18,23,24,25,26,30,31,32,33,38,39,40,41,45,46,47,48,53,54,55,60,61,62,63,68,69,70,75,76,77,78,83,84,85,90,91,92,93,98,99,100,105,106,107,108,112,113,114,115,120,121,122,123", "code": "\nimport math\nfrom sympy import sqrt\nprint([n for n in range(1, 126) if int(math.floor(n*sqrt(3)))%2==1]) \n"}
{"sequence_id": "A283777", "text": "Numbers k such that floor(k*e) is even.", "sequence": "1,3,4,6,9,12,14,15,17,18,20,23,26,28,29,31,32,34,37,39,40,42,43,45,48,51,53,54,56,57,59,62,65,67,68,70,71,73,76,78,79,81,82,84,87,90,92,93,95,96,98,101,104,106,107,109,112,115,117,118,120,121,123", "code": "\nfrom mpmath import *\nimport math\nmp.dps = 100\nprint([n for n in range(1, 126) if int(math.floor(n*e))%2==0]) \n"}
{"sequence_id": "A283778", "text": "Numbers k such that floor(k*e) is odd.", "sequence": "2,5,7,8,10,11,13,16,19,21,22,24,25,27,30,33,35,36,38,41,44,46,47,49,50,52,55,58,60,61,63,64,66,69,72,74,75,77,80,83,85,86,88,89,91,94,97,99,100,102,103,105,108,110,111,113,114,116,119,122,124,125", "code": "\nfrom mpmath import *\nimport math\nmp.dps=100\nprint([n for n in range(1, 126) if int(math.floor(n*e))%2==1]) \n"}
{"sequence_id": "A283806", "text": "Odd numbers which are uniquely decomposable into the sum of a prime and a power of two.", "sequence": "3,5,17,29,41,53,59,65,89,97,119,137,163,179,185,191,193,209,217,219,221,223,233,239,247,253,269,281,305,307,311,343,359,389,403,407,415,419,427,431,457,491,505,521,533,545,547,557,569,575,581,583,597,613,637", "code": "\nfrom sympy import isprime\nimport math\nprint([n for n in range(1001) if n%2 and sum([isprime(n-2**k) for k in range(int(math.floor(math.log(n)/math.log(2))) + 1)]) == 1]) \n"}
{"sequence_id": "A283808", "text": "Numbers k such that phi(phi(k)) divides k, where phi(k) is A000010(k).", "sequence": "1,2,3,4,6,8,10,12,14,16,18,20,24,28,32,36,40,48,54,56,64,72,80,96,108,112,128,144,160,162,192,216,224,256,288,320,324,384,432,448,486,512,576,640,648,768,864,896,972", "code": "\nfrom sympy import totient as e\nprint([n for n in range(1, 1001) if n%e(e(n))==0]) \n"}
{"sequence_id": "A283811", "text": "Poly-Bernoulli numbers B_n^(k) with k = -5.", "sequence": "1,32,454,4718,41506,329462,2441314,17234438,117437746,779305142,5067707074,32440729958,205120773586,1284333040022,7978977787234,49258610238278,302555048903026,1850666770922102,11281963755617794,68586728901231398,416015651355490066", "code": " def A283811(n): return 120*6**n - 240*5**n + 150*4**n - 30*3**n + 2**n  \n"}
{"sequence_id": "A283812", "text": "Poly-Bernoulli numbers B_n^(k) with k = -6.", "sequence": "1,64,1394,20266,237686,2441314,22934774,202229266,1701740006,13821281314,109214866454,844558486066,6419351203526,48118995192514,356641942834934,2618939805811666,19085432672558246,138206899494338914,995563711729120214", "code": " def A283812(n): return 720*7**n - 1800*6**n + 1560*5**n - 540*4**n + 62*3**n - 2**n \n"}
{"sequence_id": "A283813", "text": "Poly-Bernoulli numbers B_n^(k) with k = -7.", "sequence": "1,128,4246,85310,1315666,17234438,202229266,2193664790,22447207906,219680806598,2076319823986,19088476874870,171615294959746,1515094215592358,13177154171845906,113190802751806550,962272631860465186,8109687887324611718,67845242760941615026", "code": " def A283813(n): return 5040*8**n - 15120*7**n + 16800*6**n - 8400*5**n + 1806*4**n - 126*3**n + 2**n \n"}
{"sequence_id": "A283845", "text": "Square array read by antidiagonals: T(1,1) = T(1,2) = T(2,1) = T(2,2) = 1; thereafter T(m,n) = min {T(m,n-2) + T(m,n-1), T(m-2,n) + T(m-1,n), T(m-2,n-2) + T(m-1,n-1)}.", "sequence": "1,1,1,2,1,2,3,2,2,3,5,3,2,3,5,8,5,3,3,5,8,13,8,5,3,5,8,13,21,13,8,5,5,8,13,21,34,21,13,8,5,8,13,21,34,55,34,21,13,8,8,13,21,34,55,89,55,34,21,13,8,13,21,34,55,89,144,89,55,34,21,13,13,21,34,55,89,144", "code": "\nfrom sympy import fibonacci\nfor n in range(1, 21):\n....print [fibonacci(max(m, n - m + 1)) for m in range(1, n + 1)] \n"}
{"sequence_id": "A283867", "text": "Numbers n such that 30*n^2 - 1 and 30*n^2 + 1 are (twin) primes.", "sequence": "1,3,10,14,18,38,62,73,116,118,143,183,221,232,242,330,333,413,430,455,470,496,507,533,538,556,606,622,645,675,687,701,720,777,792,819,846,879,881,895,913,1000,1019,1030,1092,1155,1214,1238,1253,1261,1313,1337,1350,1407,1418,1429,1431", "code": "\nfrom sympy import isprime\n[i for i in range(1, 1501) if isprime(30*i**2 - 1) and isprime(30*i**2 + 1)] \n"}
{"sequence_id": "A283869", "text": "Primes p such that p+12, (p+1)/2, and (p+13)/2 are also prime.", "sequence": "61,661,1201,4261,5101,6121,6361,12421,12541,12841,13921,15361,17041,18301,19801,21661,26821,31321,36901,47521,54121,55921,56101,71341,80701,83221,87421,91381,101161,107761,109441,126481,128461,129841,131101,135601,146941,151141,151561", "code": "\nfrom sympy import isprime\n[i for i in range(1, 160001) if i%60 == 1 and isprime(i) and isprime(i + 12) and isprime((i + 1)/2) and isprime((i + 13)/2)] \n"}
{"sequence_id": "A283930", "text": "Numbers k such that tau(2^k - 1) = tau(2^k + 1).", "sequence": "2,11,14,21,23,29,45,47,53,71,73,74,82,86,95,99,101,105,113,115,121,142,167,169,179,181,199,203,209,233,235,277,307,311,317,335,337,343,347,349,353,355,358,361,382,434,449,465,494,509,515,518,529,535,547,549,570,583,585,599", "code": "\nfrom sympy import divisor_count\nprint([n for n in range(1, 601) if divisor_count(2**n + 1) == divisor_count(2**n - 1)]) \n"}
{"sequence_id": "A283939", "text": "Interspersion of the signature sequence of sqrt(2).", "sequence": "1,3,2,6,5,4,11,9,8,7,17,15,13,12,10,25,22,20,18,16,14,34,31,28,26,23,21,19,44,41,38,35,32,29,27,24,56,52,49,46,42,39,36,33,30,69,65,61,58,54,50,47,43,40,37,84,79,75,71,67,63,59,55,51,48,45,100", "code": "\nfrom sympy import sqrt\nimport math\ndef s(n): return 1 if n<1 else s(n - 1) + 1 +\nint(math.floor(n*sqrt(2)))\ndef p(n): return n + 1 + sum([int(math.floor((n - k)/sqrt(2))) for k in range(0, n+1)])\nv=[s(n) for n in range(0, 101)]\nu=[p(n) for n in range(0, 101)]\ndef w(i,j): return u[i - 1] + v[j - 1] + (i - 1) * (j - 1) - 1\nfor n in range(1, 11):\n....print [w(k, n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A283940", "text": "Interspersion of the signature sequence of sqrt(3).", "sequence": "1,3,2,7,5,4,13,10,8,6,20,17,14,11,9,29,25,22,18,15,12,40,35,31,27,23,19,16,53,47,42,37,33,28,24,21,67,61,55,49,44,39,34,30,26,83,76,70,63,57,51,46,41,36,32,101,93,86,79,72,65,59,54,48,43,38", "code": "\nfrom sympy import sqrt\nimport math\ndef s(n): return 1 if n<1 else s(n - 1) + 1 +\nint(math.floor(n*sqrt(3)))\ndef p(n): return n + 1 + sum([int(math.floor((n - k)/sqrt(3))) for k in range(0, n+1)])\nv=[s(n) for n in range(0, 101)]\nu=[p(n) for n in range(0, 101)]\ndef w(i,j): return u[i - 1] + v[j - 1] + (i - 1) * (j - 1) - 1\nfor n in range(1, 11):\n....print [w(k, n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A283941", "text": "Interspersion of the signature sequence of sqrt(5).", "sequence": "1,4,2,9,6,3,16,12,8,5,25,20,15,11,7,37,30,24,19,14,10,51,43,35,29,23,18,13,67,58,49,41,34,28,22,17,85,75,65,56,47,40,33,27,21,106,94,83,73,63,54,46,39,32,26,129,116,103,92,81,71,61,53,45,38,31", "code": "\nfrom sympy import sqrt\nimport math\ndef s(n): return 1 if n<1 else s(n - 1) + 1 + int(math.floor(n*sqrt(5)))\ndef p(n): return n + 1 + sum([int(math.floor((n - k)/sqrt(5))) for k in range(0, n+1)])\nv=[s(n) for n in range(0, 101)]\nu=[p(n) for n in range(0, 101)]\ndef w(i,j): return u[i - 1] + v[j - 1] + (i - 1) * (j - 1) - 1\nfor n in range(1, 11):\n....print [w(k, n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A283942", "text": "Rectangular array by antidiagonals: interspersion of the signature sequence of sqrt(8).", "sequence": "1,4,2,10,6,3,19,13,8,5,31,23,16,11,7,46,36,27,20,14,9,63,52,41,32,24,17,12,83,70,58,47,37,28,21,15,106,91,77,65,53,42,33,25,18,132,115,99,85,72,59,48,38,29,22,161,142,124,108,93,79,66,54,43,34", "code": "\n\nimport math\nfrom sympy import sqrt\ndef s(n): return 1 if n<1 else s(n - 1) + 1 + int(math.floor(n*sqrt(8)))\ndef p(n): return n + 1 + sum([int(math.floor((n - k)/sqrt(8))) for k in range(0, n+1)])\nv=[s(n) for n in range(0, 101)]\nu=[p(n) for n in range(0, 101)]\ndef w(i, j): return u[i - 1] + v[j - 1] + (i - 1) * (j - 1) - 1\nfor n in range(1, 11):\n....print [w(k, n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A283943", "text": "Interspersion of the signature sequence of e (a rectangular array, by antidiagonals).", "sequence": "1,4,2,10,6,3,19,13,8,5,30,23,16,11,7,44,35,27,20,14,9,61,50,40,32,24,17,12,81,68,56,46,37,28,21,15,103,89,75,63,52,42,33,25,18,128,112,97,83,70,58,48,38,29,22,156,138,121,106,91,77,65,54,43,34", "code": "\n\nimport math\nfrom mpmath import *\nmp.dps = 100\ndef s(n): return 1 if n<1 else s(n - 1) + 1 + int(math.floor(n*e))\ndef p(n): return n + 1 + sum([int(math.floor((n - k)/e)) for k in range(0, n+1)])\nv=[s(n) for n in range(0, 101)]\nu=[p(n) for n in range(0, 101)]\ndef w(i, j): return u[i - 1] + v[j - 1] + (i - 1) * (j - 1) - 1\nfor n in range(1, 11):\n....print [w(k, n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A283944", "text": "Interspersion of the signature sequence of Pi (rectangular array by antidiagonals).", "sequence": "1,5,2,12,7,3,22,15,9,4,35,26,18,11,6,51,40,30,21,14,8,70,57,45,34,25,17,10,92,77,63,50,39,29,20,13,118,100,84,69,56,44,33,24,16,147,127,108,91,76,62,49,38,28,19,179,157,136,116,99,83,68,55,43,32", "code": "\n\nimport math\nfrom mpmath import *\nmp.dps = 100\ndef s(n): return 1 if n<1 else s(n - 1) + 1 + int(math.floor(n*pi))\ndef p(n): return n + 1 + sum([int(math.floor((n - k)/pi)) for k in range(0, n+1)])\nv=[s(n) for n in range(0, 101)]\nu=[p(n) for n in range(0, 101)]\ndef w(i, j): return u[i - 1] + v[j - 1] + (i - 1) * (j - 1) - 1\nfor n in range(1, 11):\n....print [w(k, n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A283962", "text": "Interspersion of the signature sequence of sqrt(1/2).", "sequence": "1,2,3,4,5,6,7,8,9,11,10,12,13,15,17,14,16,18,20,22,25,19,21,23,26,28,31,34,24,27,29,32,35,38,41,44,30,33,36,39,42,46,49,52,56,37,40,43,47,50,54,58,61,65,69,45,48,51,55,59,63,67,71,75,79,84,53", "code": "\nfrom sympy import sqrt\nimport math\ndef s(n): return 1 if n<1 else s(n - 1) + 1 +\nint(math.floor(n*sqrt(1/2)))\ndef p(n): return n + 1 + sum([int(math.floor((n - k)/sqrt(1/2))) for k in\nrange(0, n+1)])\nv=[s(n) for n in range(0, 101)]\nu=[p(n) for n in range(0, 101)]\ndef w(i,j): return u[i - 1] + v[j - 1] + (i - 1) * (j - 1) - 1\nfor n in range(1, 11):\n....print [w(k, n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A283968", "text": "a(n) = a(n-1) + 1 + floor(n*(3 + sqrt(5))/2), a(0) = 1.", "sequence": "1,2,3,5,7,9,12,15,19,23,27,32,37,42,48,54,61,68,75,83,91,100,109,118,128,138,148,159,170,182,194,206,219,232,245,259,273,288,303,318,334,350,367,384,401,419,437,455,474,493,513,533,553,574,595,617,639", "code": "\nfrom sympy import sqrt\nimport math\ndef a(n):\n    return n + 1 + sum([int(math.floor((n - k)/r)) for k in range(n + 1)])\nprint([a(n) for n in range(61)]) \n"}
{"sequence_id": "A283969", "text": "a(n) = n + 1 + Sum_({k=0..n} floor((n-k)/r, where r = (3+sqrt(5))/2).", "sequence": "1,4,10,18,29,43,59,78,99,123,150,179,211,246,283,323,365,410,458,508,561,616,674,735,798,864,933,1004,1078,1154,1233,1315,1399,1486,1576,1668,1763,1860,1960,2063,2168,2276,2386,2499,2615,2733,2854,2978,3104", "code": "\nimport math\nfrom sympy import sqrt\ndef a(n):\n    return 1 if n<1 else a(n - 1) + 1 + int(math.floor(n*(3 + sqrt(5))/2))\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A283981", "text": "a(n) = A029931(n) - A280700(n).", "sequence": "0,0,0,2,0,3,3,3,0,4,4,4,4,4,6,7,0,5,5,5,5,5,7,8,5,5,8,9,8,9,11,11,0,6,6,6,6,6,8,9,6,6,9,10,9,10,12,12,6,6,10,11,10,11,13,13,10,11,14,14,14,14,14,17,0,7,7,7,7,7,9,10,7,7,10,11,10,11,13,13,7,7,11,12,11,12,14,14,11,12,15,15,15,15,15,18,7,7,12,13,12,13,15,15,12", "code": "\nimport math\ndef L(n): return int(math.floor(math.log(n,2)))\ndef a(n): return 0 if n<1 else a(n - 2**L(n)) + L(n) + 1\ndef A(n): return bin(2*n - bin(2*n)[2:].count(\"1\"))[2:].count(\"1\")\nprint([a(n) - A(n) for n in range(151)]) \n"}
{"sequence_id": "A283985", "text": "Sums of distinct terms of A143293: a(n) = Sum_{k>=0} A030308(n,k)*A143293(k).", "sequence": "0,1,3,4,9,10,12,13,39,40,42,43,48,49,51,52,249,250,252,253,258,259,261,262,288,289,291,292,297,298,300,301,2559,2560,2562,2563,2568,2569,2571,2572,2598,2599,2601,2602,2607,2608,2610,2611,2808,2809,2811,2812,2817,2818,2820,2821,2847,2848,2850,2851,2856,2857,2859,2860,32589", "code": "\nfrom sympy import primorial, primepi, prime, primerange, factorint\nfrom operator import mul\nfrom functools import reduce\ndef a002110(n): return 1 if n<1 else primorial(n)\ndef a276085(n):\n    f=factorint(n)\n    return sum([f[i]*a002110(primepi(i) - 1) for i in f])\ndef P(n): return reduce(mul, [i for i in primerange(2, n + 1)])\ndef a108951(n):\n    f = factorint(n)\n    return 1 if n==1 else reduce(mul, [P(i)**f[i] for i in f])\ndef a019565(n): return reduce(mul, (prime(i+1) for i, v in enumerate(bin(n)[:1:-1]) if v == '1')) if n > 0 else 1 \ndef a(n): return a276085(a108951(a019565(n)))\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A283996", "text": "a(n) = n OR A005187(floor(n/2)), where OR is bitwise-or (A003986).", "sequence": "0,1,3,3,7,7,6,7,15,15,10,11,14,15,15,15,31,31,18,19,22,23,23,23,30,31,31,31,29,29,30,31,63,63,34,35,38,39,39,39,46,47,47,47,45,45,46,47,62,63,63,63,53,53,54,55,61,61,62,63,60,61,63,63,127,127,66,67,70,71,71,71,78,79,79,79,77,77,78,79,94,95,95,95,85,85,86,87,93,93,94,95", "code": "\ndef A(n): return 2*n - bin(2*n)[2:].count(\"1\")\nprint([n|A(n//2) for n in range(101)]) \n"}
{"sequence_id": "A283997", "text": "a(n) = n XOR A005187(floor(n/2)), where XOR is bitwise-xor (A003987).", "sequence": "0,1,3,2,7,6,2,3,15,14,2,3,6,7,5,4,31,30,2,3,6,7,5,4,14,15,13,12,5,4,4,5,63,62,2,3,6,7,5,4,14,15,13,12,5,4,4,5,30,31,29,28,5,4,4,5,13,12,12,13,4,5,7,6,127,126,2,3,6,7,5,4,14,15,13,12,5,4,4,5,30,31,29,28,5,4,4,5,13,12,12,13,4,5,7,6,62,63,61,60,5,4,4,5,13,12,12", "code": "\ndef A(n): return 2*n - bin(2*n)[2:].count(\"1\")\nprint([n^A(n//2) for n in range(111)]) \n"}
{"sequence_id": "A283998", "text": "a(n) = n AND A005187(floor(n/2)), where AND is bitwise-and (A004198).", "sequence": "0,0,0,1,0,1,4,4,0,1,8,8,8,8,10,11,0,1,16,16,16,16,18,19,16,16,18,19,24,25,26,26,0,1,32,32,32,32,34,35,32,32,34,35,40,41,42,42,32,32,34,35,48,49,50,50,48,49,50,50,56,56,56,57,0,1,64,64,64,64,66,67,64,64,66,67,72,73,74,74,64,64,66,67,80,81,82,82,80,81,82,82,88,88,88,89", "code": "\ndef A(n): return 2*n - bin(2*n)[2:].count(\"1\")\nprint([n&A(n//2) for n in range(101)]) \n"}
{"sequence_id": "A283999", "text": "a(n) = A005187(n) XOR A006068(n), where XOR is bitwise-xor (A003987).", "sequence": "0,0,0,6,0,14,14,14,0,30,30,30,30,30,18,16,0,62,62,62,62,62,50,48,62,62,34,32,34,32,44,44,0,126,126,126,126,126,114,112,126,126,98,96,98,96,108,108,126,126,66,64,66,64,76,76,66,64,92,92,92,92,92,82,0,254,254,254,254,254,242,240,254,254,226,224,226,224,236,236,254,254,194,192,194", "code": "\ndef A(n): return 2*n - bin(2*n)[2:].count(\"1\")\ndef a(n): return n if n<2 else 2*a(n//2) + (n%2 + a(n//2)%2)%2\nprint([A(n)^a(n) for n in range(111)]) \n"}
{"sequence_id": "A284013", "text": "a(n) = n - A002487(n).", "sequence": "0,0,1,1,3,2,4,4,7,5,7,6,10,8,11,11,15,12,14,12,17,13,17,16,22,18,21,19,25,22,26,26,31,27,29,26,32,26,31,29,37,30,34,30,39,33,39,38,46,40,43,39,47,40,46,44,53,47,51,48,56,52,57,57,63,58,60,56,63,55,61,58,68,58,63,57,69,60,68,66,77,67,71,64,76,64", "code": "\ndef a(n): return n if n<2 else (a(n//2) if n%2==0 else a((n - 1)//2) + a((n + 1)//2))\nprint([n - a(n) for n in range(101)]) \n"}
{"sequence_id": "A284032", "text": "Poly-Bernoulli numbers B_n^(k) with k = -8.", "sequence": "1,256,12866,354106,7107302,117437746,1701740006,22447207906,276054834902,3216941445106,35934231683846,388027036757506,4076344795442102,41866470995832466,422006961657805286,4187561159054335906,41007540680799210902,397101660070601067826", "code": " def a(n): return 40320*9**n - 141120*8**n + 191520*7**n - 126000*6**n + 40824*5**n - 5796*4**n + 254*3**n - 2**n \n"}
{"sequence_id": "A284033", "text": "Poly-Bernoulli numbers B_n^(k) with k = -9.", "sequence": "1,512,38854,1455278,37712866,779305142,13821281314,219680806598,3216941445106,44222780245622,578333776748674,7265797378375718,88340967898764946,1045408905465897302,12094777018030598434,137292855542017989638", "code": " def a(n): return 362880*10**n - 1451520*9**n + 2328480*8**n - 1905120*7**n + 834120*6**n - 186480*5**n + 18150*4**n - 510*3**n + 2**n \n"}
{"sequence_id": "A284036", "text": "Positive integers n such that (n^2 - 3)/2 and (n^2 + 1)/2 are twin primes.", "sequence": "3,5,11,19,25,29,65,79,101,205,209,221,245,275,289,299,349,371,409,415,449,521,535,569,571,575,595,649,661,695,739,781,791,935,949,991,1081,1091,1099,1129,1181,1225,1241,1285,1345,1349,1459,1489,1531,1541,1615", "code": "\nfrom sympy import isprime\nprint([n for n in range(3, 1700, 2) if isprime((n**2 - 3)//2) and isprime((n**2 + 1)//2)]) \n"}
{"sequence_id": "A284053", "text": "Relative of Hofstadter Q-sequence.", "sequence": "9,20,5,5,20,9,20,5,5,20,9,5,10,10,20,9,5,15,15,40,9,10,20,15,40,9,15,25,15,40,9,20,25,15,60,9,25,25,20,60,9,25,30,25,60,9,25,40,20,60,9,30,45,20,80,9,40,35,30,80,9,45,35,30,100,9,35,55,25,80,9,35,55,35,100", "code": "\nfrom functools import cache\n@cache\ndef a(n):\n    if n <= 0: return 0\n    if n < 16:\n        return [9, 20, 5, 5, 20, 9, 20, 5, 5, 20, 9, 5, 10, 10, 20][n-1]\n    return a(n - a(n-1)) + a(n - a(n-2))\nprint([a(n) for n in range(1, 76)]) \n"}
{"sequence_id": "A284054", "text": "Relative of Hofstadter Q-sequence.", "sequence": "7,26,8,8,8,8,8,26,7,8,16,16,16,16,16,26,7,16,24,8,16,24,8,26,7,24,16,24,24,16,24,52,7,16,48,8,24,32,24,52,7,48,8,8,48,32,16,78,7,8,16,16,48,40,24,78,7,16,24,16,72,32,24,104,7,24,24,16,96,40,24,130,7,24,32", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef a(n):\n    if n <= 0: return 0\n    if n < 17:\n        return [7, 26, 8, 8, 8, 8, 8, 26, 7, 8, 16, 16, 16, 16, 16, 26][n-1]\n    return a(n - a(n-1)) + a(n - a(n-2))\nprint([a(n) for n in range(1, 76)]) \n"}
{"sequence_id": "A284061", "text": "Triangle read by rows: T(n,k) = pi(prime(k) * prime(n+1)).", "sequence": "3,4,6,6,8,11,8,11,16,21,9,12,18,24,34,11,15,23,30,42,47,12,16,24,32,46,53,66,14,19,30,37,54,62,77,84,16,23,34,46,66,74,94,101,121,18,24,36,47,68,79,99,107,127,154,21,29,42,55,79,92,114,126,146,180", "code": "\nfrom sympy import prime, primepi\nfor n in range(1, 13):\n....print[primepi(prime(k) * prime(n + 1)) for k in range(1, n+1)] \n"}
{"sequence_id": "A284062", "text": "Numbers whose smallest decimal digit is 1.", "sequence": "1,11,12,13,14,15,16,17,18,19,21,31,41,51,61,71,81,91,111,112,113,114,115,116,117,118,119,121,122,123,124,125,126,127,128,129,131,132,133,134,135,136,137,138,139,141,142,143,144,145,146,147,148,149,151,152", "code": "\nfrom sympy.ntheory.factor_ import digits\nprint([n for n in range(1, 301) if min(digits(n)[1:])==1]) \n"}
{"sequence_id": "A284063", "text": "Numbers whose smallest decimal digit is 2.", "sequence": "2,22,23,24,25,26,27,28,29,32,42,52,62,72,82,92,222,223,224,225,226,227,228,229,232,233,234,235,236,237,238,239,242,243,244,245,246,247,248,249,252,253,254,255,256,257,258,259,262,263,264,265,266,267,268", "code": "\ndef ok(n): return '2' == min(str(n))\nprint([m for m in range(269) if ok(m)]) \n"}
{"sequence_id": "A284069", "text": "Numbers whose smallest decimal digit is 8.", "sequence": "8,88,89,98,888,889,898,899,988,989,998,8888,8889,8898,8899,8988,8989,8998,8999,9888,9889,9898,9899,9988,9989,9998,88888,88889,88898,88899,88988,88989,88998,88999,89888,89889,89898,89899,89988,89989,89998,89999,98888", "code": "\nprint([n for n in range(8, 10**6) if min(str(n))=='8']) \n"}
{"sequence_id": "A284094", "text": "Indices k such that scalar product (p,q,r).(s,t,u) = p*s+q*t+r*u is prime, where (p,q,r,s,t,u) are 6 consecutive primes starting with p=prime(k).", "sequence": "6,7,9,10,12,13,15,19,21,31,33,34,43,46,51,55,56,58,63,66,68,76,86,90,121,123,136,161,162,169,174,181,182,211,218,230,238,248,253,255,262,264,287,291,294,300,305,312", "code": "\nfrom sympy import prime, isprime\nprint([n for n in range(1, 501) if isprime(prime(n)*prime(n+3) + prime(n+1)*prime(n+4) + prime(n+2)*prime(n+5))]) \n"}
{"sequence_id": "A284097", "text": "a(n) = Sum_{d|n, d=1 mod 5} d.", "sequence": "1,1,1,1,1,7,1,1,1,1,12,7,1,1,1,17,1,7,1,1,22,12,1,7,1,27,1,1,1,7,32,17,12,1,1,43,1,1,1,1,42,28,1,12,1,47,1,23,1,1,52,27,1,7,12,57,1,1,1,7,62,32,22,17,1,84,1,1,1,1,72,43,1,1,1,77,12,33,1", "code": "\nfrom sympy import divisors\ndef a(n): return sum([d for d in divisors(n) if d%5==1]) \n"}
{"sequence_id": "A284098", "text": "Sum_{d|n, d=1 mod 6} d.", "sequence": "1,1,1,1,1,1,8,1,1,1,1,1,14,8,1,1,1,1,20,1,8,1,1,1,26,14,1,8,1,1,32,1,1,1,8,1,38,20,14,1,1,8,44,1,1,1,1,1,57,26,1,14,1,1,56,8,20,1,1,1,62,32,8,1,14,1,68,1,1,8,1,1,74,38,26,20,8,14,80,1,1", "code": "\nfrom sympy import divisors\ndef a(n): return sum([d for d in divisors(n) if d%6==1]) \n"}
{"sequence_id": "A284099", "text": "Sum_{d|n, d=1 mod 7} d.", "sequence": "1,1,1,1,1,1,1,9,1,1,1,1,1,1,16,9,1,1,1,1,1,23,1,9,1,1,1,1,30,16,1,9,1,1,1,37,1,1,1,9,1,1,44,23,16,1,1,9,1,51,1,1,1,1,1,9,58,30,1,16,1,1,1,73,1,23,1,1,1,1,72,45,1,1,16,1,1,79,1,9,1,1", "code": "\nfrom sympy import divisors\ndef a(n): return sum([d for d in divisors(n) if d%7==1]) \n"}
{"sequence_id": "A284100", "text": "Sum_{d|n, d=1 mod 8} d.", "sequence": "1,1,1,1,1,1,1,1,10,1,1,1,1,1,1,1,18,10,1,1,1,1,1,1,26,1,10,1,1,1,1,1,34,18,1,10,1,1,1,1,42,1,1,1,10,1,1,1,50,26,18,1,1,10,1,1,58,1,1,1,1,1,10,1,66,34,1,18,1,1,1,10,74,1,26,1,1,1,1,1", "code": "\nfrom sympy import divisors\ndef a(n): return sum([d for d in divisors(n) if d%8==1]) \n"}
{"sequence_id": "A284103", "text": "a(n) = Sum_{d|n, d=4 mod 5} d.", "sequence": "0,0,0,4,0,0,0,4,9,0,0,4,0,14,0,4,0,9,19,4,0,0,0,28,0,0,9,18,29,0,0,4,0,34,0,13,0,19,39,4,0,14,0,48,9,0,0,28,49,0,0,4,0,63,0,18,19,29,59,4,0,0,9,68,0,0,0,38,69,14,0,37,0,74,0,23,0,39,79", "code": "\nfrom sympy import divisors\ndef a(n): return sum([d for d in divisors(n) if d%5==4]) \n"}
{"sequence_id": "A284104", "text": "a(n) = Sum_{d|n, d=5 mod 6} d.", "sequence": "0,0,0,0,5,0,0,0,0,5,11,0,0,0,5,0,17,0,0,5,0,11,23,0,5,0,0,0,29,5,0,0,11,17,40,0,0,0,0,5,41,0,0,11,5,23,47,0,0,5,17,0,53,0,16,0,0,29,59,5,0,0,0,0,70,11,0,17,23,40,71,0,0,0,5,0,88,0,0,5", "code": "\nfrom sympy import divisors\ndef a(n): return sum([d for d in divisors(n) if d%6==5]) \n"}
{"sequence_id": "A284105", "text": "a(n) = Sum_{d|n, d=6 mod 7} d.", "sequence": "0,0,0,0,0,6,0,0,0,0,0,6,13,0,0,0,0,6,0,20,0,0,0,6,0,13,27,0,0,6,0,0,0,34,0,6,0,0,13,20,41,6,0,0,0,0,0,54,0,0,0,13,0,33,55,0,0,0,0,26,0,62,0,0,13,6,0,34,69,0,0,6,0,0,0,76,0,19,0,20,27,41", "code": "\nfrom sympy import divisors\ndef a(n): return sum([d for d in divisors(n) if d%7==6]) \n"}
{"sequence_id": "A284115", "text": "Hosoya triangle of Lucas type.", "sequence": "1,3,3,4,9,4,7,12,12,7,11,21,16,21,11,18,33,28,28,33,18,29,54,44,49,44,54,29,47,87,72,77,77,72,87,47,76,141,116,126,121,126,116,141,76,123,228,188,203,198,198,203,188,228,123,199,369,304,329,319,324,319,329,304,369,199", "code": "\nfrom sympy import lucas\nfor n in range(1, 11):\n....print [lucas(k) * lucas(n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A284118", "text": "Sum of nonprime squarefree divisors of n.", "sequence": "1,1,1,1,1,7,1,1,1,11,1,7,1,15,16,1,1,7,1,11,22,23,1,7,1,27,1,15,1,62,1,1,34,35,36,7,1,39,40,11,1,84,1,23,16,47,1,7,1,11,52,27,1,7,56,15,58,59,1,62,1,63,22,1,66,128,1,35,70,130,1,7,1,75,16,39,78,150,1,11,1,83,1,84,86,87,88,23,1,62", "code": "\nfrom sympy import divisors\nfrom sympy.ntheory.factor_ import core\ndef a(n): return sum([i for i in divisors(n) if core(i)==i and isprime(i)==0]) \n"}
{"sequence_id": "A284126", "text": "Hosoya triangle of Pell-Lucas type.", "sequence": "4,12,12,28,36,28,68,84,84,68,164,204,196,204,164,396,492,476,476,492,396,956,1188,1148,1156,1148,1188,956,2308,2868,2772,2788,2788,2772,2868,2308,5572,6924,6692,6732,6724,6732,6692,6924,5572,13452,16716,16156,16252,16236,16236,16252,16156,16716,13452", "code": "\ndef a(n): return 2 if n<2 else 2*a(n - 1) + a(n - 2)\nfor n in range(1, 21): print [a(k)*a(n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A284127", "text": "Hosoya triangle of Pell type, read by rows.", "sequence": "1,2,2,5,4,5,12,10,10,12,29,24,25,24,29,70,58,60,60,58,70,169,140,145,144,145,140,169,408,338,350,348,348,350,338,408,985,816,845,840,841,840,845,816,985,2378,1970,2040,2028,2030,2030,2028,2040,1970,2378,5741,4756,4925,4896,4901,4900,4901,4896,4925,4756,5741", "code": "\ndef a(n): return n if n<2 else 2*a(n - 1) + a(n - 2)\nfor n in range(1, 21): print [a(k)*a(n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A284128", "text": "Hosoya triangle of Fermat Lucas type, read by rows.", "sequence": "9,15,15,27,25,27,51,45,45,51,99,85,81,85,99,195,165,153,153,165,195,387,325,297,289,297,325,387,771,645,585,561,561,585,645,771,1539,1285,1161,1105,1089,1105,1161,1285,1539,3075,2565,2313,2193,2145,2145,2193,2313,2565,3075", "code": "\nfor n in range(1, 11):\n....print [(2**k + 1) * (2**(n - k + 1) + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A284129", "text": "Hosoya triangle Jacobsthal Lucas type.", "sequence": "1,5,5,7,25,7,17,35,35,17,31,85,49,85,31,65,155,119,119,155,65,127,325,217,289,217,325,127,257,635,455,527,527,455,635,257,511,1285,889,1105,961,1105,889,1285,511,1025,2555,1799,2159,2015,2015,2159,1799,2555,1025,2047,5125", "code": "\ndef a(n): return 2**n + (-1)**n\nfor n in range(1, 11):\n....print [a(k) * a(n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A284131", "text": "Hosoya triangle of Morgan Voyce type, read by rows.", "sequence": "9,21,21,54,49,54,141,126,126,141,369,329,324,329,369,966,861,846,846,861,966,2529,2254,2214,2209,2214,2254,2529,6621,5901,5796,5781,5781,5796,5901,6621,17334,15449,15174,15134,15129,15134,15174,15449,17334,45381,40446,45381", "code": "\nfrom sympy import lucas\nfor n in range(1, 11):\n....print [lucas(2*k) * lucas(2*(n - k + 1)) for k in range(1, n + 1)] \n"}
{"sequence_id": "A284150", "text": "Sum_{d|n, d==1 or 4 mod 5} d.", "sequence": "1,1,1,5,1,7,1,5,10,1,12,11,1,15,1,21,1,16,20,5,22,12,1,35,1,27,10,19,30,7,32,21,12,35,1,56,1,20,40,5,42,42,1,60,10,47,1,51,50,1,52,31,1,70,12,75,20,30,60,11,62,32,31,85,1,84,1,39,70,15,72,80,1", "code": "\nfrom sympy import divisors\ndef a(n): return sum([d for d in divisors(n) if d%5==1 or d%5 == 4]) \n"}
{"sequence_id": "A284151", "text": "Sum_{d|n, d=1 or 6 mod 7} d.", "sequence": "1,1,1,1,1,7,1,9,1,1,1,7,14,1,16,9,1,7,1,21,1,23,1,15,1,14,28,1,30,22,1,9,1,35,1,43,1,1,14,29,42,7,44,23,16,1,1,63,1,51,1,14,1,34,56,9,58,30,1,42,1,63,1,73,14,29,1,35,70,1,72,51,1,1,16,77,1", "code": "\nfrom sympy import divisors\ndef a(n): return sum([d for d in divisors(n) if d%7==1 or d%7 == 6]) \n"}
{"sequence_id": "A284153", "text": "Pairs of integers (x, y) such that D(x+y+1) = D(x) union D(y), 1 < y < x, where D(n) is the set of distinct prime divisors of n.", "sequence": "3,2,5,4,8,3,9,2,9,5,9,8,17,16,20,9,24,5,27,8,27,14,32,3,32,11,33,32,49,20,50,9,54,5,54,11,56,27,65,64,80,9,81,41,98,27,99,32,104,25,125,9,125,14,125,24,125,49,125,54,125,84,128,43,129,128,144,5", "code": "\nfrom sympy.ntheory import primefactors\nl=[]\nfor x in range(2, 145):\n    for y in range(2, x):\n        if primefactors(x + y + 1) == sorted(primefactors(x) + primefactors(y)):\n            l+=[x, y]\nprint(l) \n"}
{"sequence_id": "A284167", "text": "a(n) = Sum_{i=1..A000005(n)} d(n+k(i)), where d(t) is the number of divisors of t and k(i) is the i-th divisor of n.", "sequence": "2,5,7,10,8,15,8,18,16,18,10,29,8,19,25,28,10,33,10,35,26,20,12,50,18,20,31,36,12,51,10,42,27,23,33,62,8,22,30,60,12,53,10,40,52,22,14,78,20,41,28,38,12,63,36,63,30,24,16,95,8,23,59,60,32,54,10", "code": "\nfrom sympy import divisor_count, divisors\ndef a(n):\n    return sum(divisor_count(n + d) for d in divisors(n)) \n"}
{"sequence_id": "A284172", "text": "a(1)=2; thereafter a(n+1) = a(n)+i if a(n) is a prime and a(1),...,a(n) contains i primes, or a(n+1) = a(n)-i if a(n) is composite and a(1),...,a(n) contains i composite terms.", "sequence": "2,3,5,8,7,11,16,14,11,17,24,20,15,9,2,10,2,11,21,12,2,13,25,14,2,15,2,16,2,17,33,18,2,19,37,56,39,21,2,22,2,23,45,24,2,25,2,26,2,27,2,28,2,29,57,30,2,31,61,92,63,33,2,34,2,35,2,36,2,37,73,110,75,39,2,40,2,41,81,42,2,43,85,44,2,45", "code": "\nfrom sympy import isprime\na=[2]\np=0\nfor n in range(1, 1000):\n    if isprime(a[n - 1]):\n        p+=1\n        a.append(a[n - 1] + p)\n    else:\n        a.append(a[n - 1] - n + p)\nprint(a) \n"}
{"sequence_id": "A284191", "text": "Numbers k such that 4*10^k - 87 is prime.", "sequence": "2,5,7,13,16,20,29,37,43,49,101,888,2533,2569,2599,2666,3689,6335,9634,12445,17669,51208,79729", "code": "\nfrom sympy import isprime\ndef ok(n): return 1 if isprime(4*10**n - 87) else 0 \n"}
{"sequence_id": "A284203", "text": "Number of twin prime (A001097) divisors of n.", "sequence": "0,0,1,0,1,1,1,0,1,1,1,1,1,1,2,0,1,1,1,1,2,1,0,1,1,1,1,1,1,2,1,0,2,1,2,1,0,1,2,1,1,2,1,1,2,0,0,1,1,1,2,1,0,1,2,1,2,1,1,2,1,1,2,0,2,2,0,1,1,2,1,1,1,0,2,1,2,2,0,1,1,1,0,2,2,1,2,1,0,2,2,0,2,0,2,1,0,1,2,1,1,2,1,1,3,0,1,1,1,2", "code": "\nfrom sympy import isprime, divisors\nprint([len([i for i in divisors(n) if isprime(i) and (isprime(i - 2) or isprime(i + 2))]) for n in range(1, 111)]) \n"}
{"sequence_id": "A284252", "text": "a(n) = smallest prime dividing n which is larger than the square of smallest prime dividing n, or 1 if no such prime exists, a(1) = 1.", "sequence": "1,1,1,1,1,1,1,1,1,5,1,1,1,7,1,1,1,1,1,5,1,11,1,1,1,13,1,7,1,5,1,1,11,17,1,1,1,19,13,5,1,7,1,11,1,23,1,1,1,5,17,13,1,1,1,7,19,29,1,5,1,31,1,1,1,11,1,17,23,5,1,1,1,37,1,19,1,13,1,5,1,41,1,7,1,43,29,11,1,5,1,23,31,47,1,1,1,7,11,5,1,17,1,13,1,53,1,1,1,5,37", "code": "\nfrom sympy import primefactors\ndef a(n):\n    for i in primefactors(n):\n        if i>min(primefactors(n))**2: return i\n    return 1\nprint([a(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A284253", "text": "a(n) = n / A284252(n).", "sequence": "1,2,3,4,5,6,7,8,9,2,11,12,13,2,15,16,17,18,19,4,21,2,23,24,25,2,27,4,29,6,31,32,3,2,35,36,37,2,3,8,41,6,43,4,45,2,47,48,49,10,3,4,53,54,55,8,3,2,59,12,61,2,63,64,65,6,67,4,3,14,71,72,73,2,75,4,77,6,79,16,81,2,83,12,85,2,3,8,89,18,91,4,3,2,95,96,97,14,9,20,101,6", "code": "\nfrom sympy import primefactors\ndef a(n):\n    pf = primefactors(n)\n    if pf: min_pf2 = min(pf)**2\n    for i in pf:\n        if i > min_pf2: return i\n    return 1\nprint([n//a(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A284254", "text": "Largest divisor of n such that all its prime factors are greater than the square of smallest prime factor of n, a(1) = 1.", "sequence": "1,1,1,1,1,1,1,1,1,5,1,1,1,7,1,1,1,1,1,5,1,11,1,1,1,13,1,7,1,5,1,1,11,17,1,1,1,19,13,5,1,7,1,11,1,23,1,1,1,25,17,13,1,1,1,7,19,29,1,5,1,31,1,1,1,11,1,17,23,35,1,1,1,37,1,19,1,13,1,5,1,41,1,7,1,43,29,11,1,5,1,23,31,47,1,1,1,49,11,25,1,17,1,13,1,53,1,1,1,55", "code": "\nfrom sympy import primefactors\ndef A(n):\n     for i in primefactors(n):\n         if i>min(primefactors(n))**2: return i\n     return 1\ndef a(n): return 1 if A(n) == 1 else A(n)*a(n//A(n))\nprint([a(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A284255", "text": "Largest divisor of n such that all its prime factors are less than the square of the smallest prime factor of n, a(1) = 1.", "sequence": "1,2,3,4,5,6,7,8,9,2,11,12,13,2,15,16,17,18,19,4,21,2,23,24,25,2,27,4,29,6,31,32,3,2,35,36,37,2,3,8,41,6,43,4,45,2,47,48,49,2,3,4,53,54,55,8,3,2,59,12,61,2,63,64,65,6,67,4,3,2,71,72,73,2,75,4,77,6,79,16,81,2,83,12,85,2,3,8,89,18,91,4,3,2,95,96,97,2,9,4,101,6", "code": "\nfrom sympy import primefactors\ndef A(n):\n    pf = primefactors(n)\n    if pf: min_pf2 = min(pf)**2\n    for i in pf:\n        if i > min_pf2: return i\n    return 1\ndef a(n): return 1 if A(n)==1 else A(n)*a(n//A(n))\nprint([n//a(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A284256", "text": "a(n) = number of prime factors of n that are > the square of smallest prime factor of n (counted with multiplicity), a(1) = 0.", "sequence": "0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,0,2,1,1,0,0,0,1,1,1,0,1,0,1,0,0,0,1,0,1,1,2,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,0,0,2,1,2,0,1,0,1,0,1,0,0,0,2,1,1,0,1,0,1,1,1,0,1", "code": "\nfrom sympy import primefactors\ndef A(n):\n    pf = primefactors(n)\n    if pf: min_pf2 = min(pf)**2\n    for i in pf:\n        if i > min_pf2: return i\n    return 1\ndef a(n): return 0 if A(n)==1 else 1 + a(n//A(n))\nprint([a(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A284257", "text": "a(n) = number of prime factors of n that are < the square of smallest prime factor of n (counted with multiplicity), a(1) = 0.", "sequence": "0,1,1,2,1,2,1,3,2,1,1,3,1,1,2,4,1,3,1,2,2,1,1,4,2,1,3,2,1,2,1,5,1,1,2,4,1,1,1,3,1,2,1,2,3,1,1,5,2,1,1,2,1,4,2,3,1,1,1,3,1,1,3,6,2,2,1,2,1,1,1,5,1,1,3,2,2,2,1,4,4,1,1,3,2,1,1,3,1,3,2,2,1,1,2,6,1,1,2,2,1,2,1,3,3,1,1,5,1,1,1,4,1,2,2,2,2,1,2,4", "code": "\nfrom sympy import primefactors\ndef Omega(n): return 0 if n==1 else Omega(n//min(primefactors(n))) + 1\ndef A(n):\n    pf = primefactors(n)\n    if pf: min_pf2 = min(pf)**2\n    for i in pf:\n        if i > min_pf2: return i\n    return 1\ndef a(n): return 1 if A(n)==1 else A(n)*a(n//A(n))\nprint([Omega(n//a(n)) for n in range(1, 151)]) \n"}
{"sequence_id": "A284258", "text": "a(n) = number of distinct prime factors of n that are > the square of smallest prime factor of n, a(1) = 0.", "sequence": "0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,0,0,1,1,1,0,1,0,1,0,0,0,1,0,1,1,2,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,0,2,1,1,0,1,0,1,1,1,0,1", "code": "\nfrom sympy import primefactors\ndef omega(n): return len(primefactors(n))\ndef A(n):\n    for i in primefactors(n):\n        if i>min(primefactors(n))**2: return i\n    return 1\ndef a(n): return 1 if A(n)==1 else A(n)*a(n//A(n))\nprint([omega(a(n)) for n in range(1, 151)]) \n"}
{"sequence_id": "A284259", "text": "a(n) = number of distinct prime factors of n that are < the square of smallest prime factor of n, a(1) = 0.", "sequence": "0,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,2,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,2,2,1,1,1,1,2,1,1,2,1,2,2,1,1,1,1,1,2,1,1,2,1,2,2,1,1,1,1,1,2,2,1,1,1,1,2,2,1,1,1,2,2,1,1,1,1,1,2,1,1,3,1,1,2,1,1,1,1,1,2,2,1,1,1,2,2", "code": "\nfrom sympy import primefactors\ndef omega(n): return len(primefactors(n))\ndef A(n):\n    for i in primefactors(n):\n        if i>min(primefactors(n))**2: return i\n    return 1\ndef a(n): return 1 if A(n)==1 else A(n)*a(n//A(n))\nprint([omega(n//a(n)) for n in range(1, 151)]) \n"}
{"sequence_id": "A284260", "text": "Greatest prime dividing n which is less than A020639(n)^2, where A020639(n) is the smallest prime dividing n, a(1) = 1.", "sequence": "1,2,3,2,5,3,7,2,3,2,11,3,13,2,5,2,17,3,19,2,7,2,23,3,5,2,3,2,29,3,31,2,3,2,7,3,37,2,3,2,41,3,43,2,5,2,47,3,7,2,3,2,53,3,11,2,3,2,59,3,61,2,7,2,13,3,67,2,3,2,71,3,73,2,5,2,11,3,79,2,3,2,83,3,17,2,3,2,89,3,13,2,3,2,19,3,97,2,3,2,101,3,103,2,7,2,107,3,109", "code": "\nfrom sympy import primefactors\ndef A(n):\n    for i in primefactors(n):\n        if i>min(primefactors(n))**2: return i\n    return 1\ndef a(n): return 1 if A(n)==1 else A(n)*a(n//A(n))\ndef gpf(n): return 1 if n<2 else max(primefactors(n))\nprint([gpf(n//a(n)) for n in range(1, 151)]) \n"}
{"sequence_id": "A284262", "text": "a(n) = where A284259 for the first time obtains value n (positions of its records).", "sequence": "1,2,6,105,5005,85085,1616615,37182145,6685349671,247357937827,10141675450907,436092044389001,20496326086283047,9156001667401012567,558516101711461766587,37420578814667938361329,2656861095841423623654359,193950859996423924526768207,15322117939717490037614688353,1271735788996551673122019133299", "code": "\nfrom sympy import prime\nfrom operator import mul\nfrom functools import reduce\ndef A(n):\n    if n<1: return 0\n    k=1\n    while prime(n + k - 1)>prime(k)**2:k+=1\n    return k - 1\ndef a(n): return n + 1 if n<2 else reduce(mul, [prime(i) for i in range(A(n) + 1, A(n) + n + 1)])\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A284263", "text": "a(n) = A252459(2*A000040(n)), a(0) = 0 by convention.", "sequence": "0,0,0,1,2,2,2,2,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9", "code": "\nfrom sympy import prime\ndef a(n):\n    if n<1: return 0\n    k=1\n    while prime(n + k - 1)>prime(k)**2:k+=1\n    return k - 1 \n"}
{"sequence_id": "A284275", "text": "Number of primes between n and 2^n exclusive.", "sequence": "0,1,2,4,8,15,27,50,93,168,304,559,1022,1894,3506,6536,12244,22993,43382,82017,155603,295939,564154,1077862,2063680,3957800,7603544,14630834,28192740,54400018,105097554,203280210,393615795,762939100,1480206268,2874398504", "code": "\nfrom sympy import primepi\ndef a(n): return primepi(2**n - 1) - primepi(n) \n"}
{"sequence_id": "A284280", "text": "Sum_{d|n, d = 2 mod 5} d.", "sequence": "0,2,0,2,0,2,7,2,0,2,0,14,0,9,0,2,17,2,0,2,7,24,0,14,0,2,27,9,0,2,0,34,0,19,7,14,37,2,0,2,0,51,0,24,0,2,47,14,7,2,17,54,0,29,0,9,57,2,0,14,0,64,7,34,0,24,67,19,0,9,0,86,0,39,0,2,84,2,0,2", "code": "\nfrom sympy import divisors\ndef a(n): return sum([d for d in divisors(n) if d%5==2]) \n"}
{"sequence_id": "A284281", "text": "Sum_{d|n, d = 3 mod 5} d.", "sequence": "0,0,3,0,0,3,0,8,3,0,0,3,13,0,3,8,0,21,0,0,3,0,23,11,0,13,3,28,0,3,0,8,36,0,0,21,0,38,16,8,0,3,43,0,3,23,0,59,0,0,3,13,53,21,0,36,3,58,0,3,0,0,66,8,13,36,0,68,26,0,0,29,73,0,3,38,0,94,0,8", "code": "\nfrom sympy import divisors\ndef a(n): return sum([d for d in divisors(n) if d%5==3]) \n"}
{"sequence_id": "A284288", "text": "Numbers n such that the average of the strong divisors of n is an integer.", "sequence": "2,3,4,5,7,9,11,13,17,19,23,25,27,28,29,31,37,41,43,47,49,53,54,56,59,61,64,67,68,71,73,79,81,83,89,91,97,98,99,100,101,103,107,109,113,121,127,131,133,137,138,139,148,149,151,154,157,163,165,167,169,173,179,181,188,191,192,193,197,199", "code": "\nfrom sympy.ntheory import divisor_sigma, divisor_count\nprint([n for n in range(2, 201) if (divisor_sigma(n) - 1)%(divisor_count(n) - 1) == 0]) \n"}
{"sequence_id": "A284292", "text": "Primes containing a digit 8.", "sequence": "83,89,181,281,283,383,389,487,587,683,787,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,983,1087,1181,1187,1283,1289,1381,1481,1483,1487,1489,1583,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867", "code": "\nfrom sympy import primerange\nprint([n for n in primerange(2, 2000) if '8' in str(n)]) \n"}
{"sequence_id": "A284318", "text": "Triangle read by rows in which row n lists divisors d of n such that n divides d^n.", "sequence": "1,2,3,2,4,5,6,7,2,4,8,3,9,10,11,6,12,13,14,15,2,4,8,16,17,6,18,19,10,20,21,22,23,6,12,24,5,25,26,3,9,27,14,28,29,30,31,2,4,8,16,32,33,34,35,6,12,18,36,37,38,39,10,20,40,41,42,43,22,44,15,45,46,47,6,12,24,48,7,49,10,50", "code": "\nfor n in range(1, 51):\n....print [i for i in range(1, n + 1) if n%i==0 and (i**n)%n==0] \n"}
{"sequence_id": "A284326", "text": "Sum of the divisors of n that are not divisible by 6.", "sequence": "1,3,4,7,6,6,8,15,13,18,12,10,14,24,24,31,18,15,20,42,32,36,24,18,31,42,40,56,30,36,32,63,48,54,48,19,38,60,56,90,42,48,44,84,78,72,48,34,57,93,72,98,54,42,72,120,80,90,60,60,62,96,104,127,84,72,68", "code": "\nfrom sympy import divisors\nprint([sum([i for i in divisors(n) if i%6]) for n in range(1, 101)]) \n"}
{"sequence_id": "A284327", "text": "a(n) is the least positive integer such that n^2 + a(n)^2 and n^2 + (a(n) - 2)^2 are primes.", "sequence": "1,1,10,1,4,1,10,5,16,1,6,25,10,1,4,1,10,7,16,1,46,15,20,1,6,1,22,15,6,13,6,5,190,11,18,1,30,15,46,1,46,25,10,21,16,21,10,37,6,19,16,5,12,1,6,1,52,5,26,31,26,45,40,11,4,1,20,7,196,19,16", "code": "\nfrom sympy import isprime\ndef a(n):\n    k=0\n    while True:\n        if isprime(n**2 + k**2) and isprime(n**2 + (k - 2)**2): return k\n        else: k+=1\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A284341", "text": "Sum of the divisors of n that are not divisible by 8.", "sequence": "1,3,4,7,6,12,8,7,13,18,12,28,14,24,24,7,18,39,20,42,32,36,24,28,31,42,40,56,30,72,32,7,48,54,48,91,38,60,56,42,42,96,44,84,78,72,48,28,57,93,72,98,54,120,72,56,80,90,60,168,62,96,104,7,84,144,68", "code": "\nfrom sympy import divisors\nprint([sum([i for i in divisors(n) if i%8]) for n in range(1, 101)]) \n"}
{"sequence_id": "A284342", "text": "Numbers n such that A065642(n) < n*lpf(n), where lpf = least prime factor (A020639).", "sequence": "12,18,24,36,40,45,48,50,54,56,60,63,72,75,80,84,90,96,98,100,108,112,120,126,132,135,144,147,150,156,160,162,168,175,176,180,189,192,196,198,200,204,208,216,224,225,228,234,240,242,245,250,252,264,270,275,276,280,288,294,297,300", "code": "\nfrom operator import mul\nfrom sympy import primefactors\nfrom functools import reduce\ndef a007947(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a065642(n):\n    if n==1: return 1\n    r=a007947(n)\n    n = n + r\n    while a007947(n)!=r:\n        n+=r\n    return n\nprint([n for n in range(10, 301) if a065642(n)<n*min(primefactors(n))]) \n"}
{"sequence_id": "A284344", "text": "Sum of the divisors of n that are not divisible by 10.", "sequence": "1,3,4,7,6,12,8,15,13,8,12,28,14,24,24,31,18,39,20,12,32,36,24,60,31,42,40,56,30,32,32,63,48,54,48,91,38,60,56,20,42,96,44,84,78,72,48,124,57,33,72,98,54,120,72,120,80,90,60,48,62,96,104,127,84,144", "code": "\nfrom sympy import divisors\nprint([sum([i for i in divisors(n) if i%10]) for n in range(1, 101)]) \n"}
{"sequence_id": "A284359", "text": "Double triangle (2*n+2 terms by row). Every row is 2*n + 1 followed by 2*n + 1 times 2*n + 2.", "sequence": "1,2,3,4,4,4,5,6,6,6,6,6,7,8,8,8,8,8,8,8,9,10,10,10,10,10,10,10,10,10,11,12,12,12,12,12,12,12,12,12,12,12,13,14,14,14,14,14,14,14,14,14,14,14,14,14,15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17", "code": "\nfor n in range(0, 11):\n....print[2*n + 2 -(k==1) for k in range(1, 2*n + 3)] \n"}
{"sequence_id": "A284380", "text": "Numbers n with digits 5 and 7 only.", "sequence": "5,7,55,57,75,77,555,557,575,577,755,757,775,777,5555,5557,5575,5577,5755,5757,5775,5777,7555,7557,7575,7577,7755,7757,7775,7777,55555,55557,55575,55577,55755,55757,55775,55777,57555,57557,57575,57577,57755,57757", "code": "\nfrom sympy.utilities.iterables import multiset_permutations\ndef aupton(terms):\n  n, digits, alst = 0, 1, []\n  while len(alst) < terms:\n    mpstr = \"\".join(d*digits for d in \"57\")\n    for mp in multiset_permutations(mpstr, digits):\n      alst.append(int(\"\".join(mp)))\n      if len(alst) == terms: break\n    else: digits += 1\n  return alst\nprint(aupton(44)) \n"}
{"sequence_id": "A284381", "text": "Numbers n with digits 5 and 8 only.", "sequence": "5,8,55,58,85,88,555,558,585,588,855,858,885,888,5555,5558,5585,5588,5855,5858,5885,5888,8555,8558,8585,8588,8855,8858,8885,8888,55555,55558,55585,55588,55855,55858,55885,55888,58555,58558,58585,58588,58855,58858", "code": "\ndef a(n): return int(bin(n+1)[3:].replace('0', '5').replace('1', '8'))\nprint([a(n) for n in range(1, 45)]) \n"}
{"sequence_id": "A284382", "text": "Numbers n with digits 5 and 9 only.", "sequence": "5,9,55,59,95,99,555,559,595,599,955,959,995,999,5555,5559,5595,5599,5955,5959,5995,5999,9555,9559,9595,9599,9955,9959,9995,9999,55555,55559,55595,55599,55955,55959,55995,55999,59555,59559,59595,59599,59955,59959", "code": "\ndef a(n): return int(bin(n+1)[3:].replace('0', '5').replace('1', '9'))\nprint([a(n) for n in range(1, 45)]) \n"}
{"sequence_id": "A284462", "text": "Number of length-n binary strings s whose longest repeated suffix appears exactly twice in s.", "sequence": "2,2,6,10,22,44,92,178,362,724,1444,2888,5792,11616,23300,46670,93434,186988,374012,747976,1495656,2990440,5979368,11956444,23910164,47819272,95645168,191318496,382719072,765644448,1531761528,3064550802,6131253398,12266876820", "code": " \nfrom itertools import product\ndef ok(s):\n    for i in range(len(s)-1, 0, -1):\n        count = 1 + sum(s[j:].startswith(s[-i:]) for j in range(len(s)-i))\n        if count > 1: return count == 2\n    return False\ndef a(n):\n    if n == 1: return 2\n    return 2*sum(ok(\"1\"+\"\".join(p)) for p in product(\"01\", repeat=n-1))\nprint([a(n) for n in range(1, 17)]) \n"}
{"sequence_id": "A284463", "text": "Number of compositions (ordered partitions) of n into prime divisors of n.", "sequence": "1,0,1,1,1,1,2,1,1,1,2,1,12,1,2,2,1,1,65,1,23,2,2,1,351,1,2,1,38,1,15778,1,1,2,2,2,10252,1,2,2,1601,1,302265,1,80,750,2,1,299426,1,13404,2,107,1,1618192,2,5031,2,2,1,707445067,1,2,2398,1,2,119762253,1,173,2,39614048,1,255418101,1,2,154603", "code": "\nfrom sympy import divisors, isprime\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n):\n    l=[x for x in divisors(n) if isprime(x)]\n    @cacheit\n    def b(m): return 1 if m==0 else sum(b(m - j) for j in l if j <= m)\n    return b(n)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A284464", "text": "Number of compositions (ordered partitions) of n into squarefree divisors of n.", "sequence": "1,1,2,2,5,2,25,2,34,19,129,2,1046,2,742,450,1597,2,44254,2,27517,3321,29967,2,1872757,571,200390,18560,854850,2,154004511,2,3524578,226020,9262157,51886,3353855285,2,63346598,2044895,1255304727,2,185493291001,2,1282451595,345852035,2972038875,2,6006303471178", "code": "\nfrom sympy import divisors\nfrom sympy.ntheory.factor_ import core\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n):\n    l=[x for x in divisors(n) if core(x)==x]\n    @cacheit\n    def b(m): return 1 if m==0 else sum(b(m - j) for j in l if j <= m)\n    return b(n)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A284465", "text": "Number of compositions (ordered partitions) of n into prime power divisors of n (not including 1).", "sequence": "1,0,1,1,2,1,2,1,6,2,2,1,36,1,2,2,56,1,90,1,201,2,2,1,4725,2,2,20,1085,1,15778,1,5272,2,2,2,476355,1,2,2,270084,1,302265,1,35324,3910,2,1,67279595,2,14047,2,219528,1,5863044,2,14362998,2,2,1,47466605656,1,2,35662,47350056,2,119762253,1,9479643", "code": "\nfrom sympy import divisors, primefactors\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n):\n    l=[x for x in divisors(n) if len(primefactors(x))==1]\n    @cacheit\n    def b(m): return 1 if m==0 else sum(b(m - j) for j in l if j <= m)\n    return b(n)\nprint([a(n) for n in range(71)]) \n"}
{"sequence_id": "A284466", "text": "Number of compositions (ordered partitions) of n into odd divisors of n.", "sequence": "1,1,1,2,1,2,6,2,1,20,8,2,60,2,10,450,1,2,726,2,140,3321,14,2,5896,572,16,26426,264,2,394406,2,1,226020,20,51886,961584,2,22,2044895,38740,2,20959503,2,676,478164163,26,2,56849086,31201,652968,184947044,980,2,1273706934,6620376,153366,1803937344", "code": "\nfrom sympy import divisors\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n):\n    l=[x for x in divisors(n) if x%2]\n    @cacheit\n    def b(m): return 1 if m==0 else sum(b(m - j) for j in l if j <= m)\n    return b(n)\nprint([a(n) for n in range(61)]) \n"}
{"sequence_id": "A284551", "text": "Triangular array read by rows, demonstrating that the difference between a pentagonal number (left edge of triangle) and a square (right edge) is a triangular number.", "sequence": "1,5,4,12,11,9,22,21,19,16,35,34,32,29,25,51,50,48,45,41,36,70,69,67,64,60,55,49,92,91,89,86,82,77,71,64,117,116,114,111,107,102,96,89,81,145,144,142,139,135,130,124,117,109,100,176,175,173,170,166,161,155,148,140,131,121,210,209", "code": "\ndef T(n, m): return (n*(3*n - 1) - m*(m - 1))/2\nfor n in range(1, 13):\n....print [T(n,k) for k in range(1, n + 1)] \n"}
{"sequence_id": "A284570", "text": "a(n) = A000005((n+1)^2) - A000005(n^2).", "sequence": "2,0,2,-2,6,-6,4,-2,4,-6,12,-12,6,0,0,-6,12,-12,12,-6,0,-6,18,-16,4,-2,8,-12,24,-24,8,-2,0,0,16,-22,6,0,12,-18,24,-24,12,0,-6,-6,24,-22,10,-6,6,-12,18,-12,12,-12,0,-6,42,-42,6,6,-2,-4,18,-24,12,-6,18,-24,32,-32,6,6,0,-6,18,-24,24,-18,0,-6,42,-36,0,0,12,-18,42,-36,6,-6", "code": "\nfrom sympy import divisor_count as D\nprint([D((n + 1)**2) - D(n**2) for n in range(1, 101)]) \n"}
{"sequence_id": "A284571", "text": "Permutation of natural numbers: a(1) = 1, a(A005117(1+n)) = 2*a(n), a(A065642(1+n)) = 1 + 2*a(n).", "sequence": "1,2,4,3,8,6,16,9,5,12,32,17,18,10,24,33,64,65,34,11,36,20,48,129,7,66,19,37,128,130,68,49,22,72,40,97,96,258,14,69,132,38,74,73,21,256,260,81,13,29,136,15,98,521,44,39,144,80,194,257,192,516,23,137,28,138,264,45,76,148,146,197,42,512,147,193,520,162,26,27", "code": "\nfrom operator import mul\nfrom sympy import primefactors\nfrom sympy.ntheory.factor_ import core\ndef a007947(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a285328(n):\n    if core(n) == n: return 1\n    k=n - 1\n    while k>0:\n        if a007947(k) == a007947(n): return k\n        else: k-=1\ndef a013928(n): return sum(1 for i in range(1, n) if core(i) == i)\ndef a(n):\n    if n==1: return 1\n    if core(n)==n: return 2*a(a013928(n))\n    else: return 1 + 2*a(a285328(n) - 1)\n[a(n) for n in range(1, 121)] \n"}
{"sequence_id": "A284584", "text": "a(1) = 0; for n > 1, if n is not squarefree, then a(n) = A057627(n), otherwise a(n) = A013928(n).", "sequence": "0,1,2,1,3,4,5,2,3,6,7,4,8,9,10,5,11,6,12,7,13,14,15,8,9,16,10,11,17,18,19,12,20,21,22,13,23,24,25,14,26,27,28,15,16,29,30,17,18,19,31,20,32,21,33,22,34,35,36,23,37,38,24,25,39,40,41,26,42,43,44,27,45,46,28,29,47,48,49,30,31,50,51,32,52,53,54,33,55,34,56,35,57,58,59,36", "code": "\nfrom sympy import mobius\nfrom sympy.ntheory.factor_ import core\ndef a057627(n): return n - sum([mobius(k)**2 for k in range(1, n + 1)])\ndef a013928(n): return sum([1 for i in range(1, n) if core(i) == i])\ndef a(n):\n    if n==1: return 0\n    if core(n)==n: return a013928(n)\n    else: return a057627(n)\nprint([a(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A284597", "text": "a(n) is the least number that begins a run of exactly n consecutive numbers with a nondecreasing number of divisors, or -1 if no such number exists.", "sequence": "46,5,43,1,1613,241,17011,12853,234613,376741,78312721,125938261,4019167441,16586155153,35237422882,1296230533473,42301168491121,61118966262061", "code": "\nfrom sympy import divisor_count\ndef A284597(n):\n    count, starti, s, i = 0,1,0,1\n    while True:\n        d = divisor_count(i)\n        if d < s:\n            if count == n:\n                return starti\n            starti = i\n            count = 0\n        s = d\n        i += 1\n        count += 1 \n"}
{"sequence_id": "A284599", "text": "Sum of twin prime (A001097) divisors of n.", "sequence": "0,0,3,0,5,3,7,0,3,5,11,3,13,7,8,0,17,3,19,5,10,11,0,3,5,13,3,7,29,8,31,0,14,17,12,3,0,19,16,5,41,10,43,11,8,0,0,3,7,5,20,13,0,3,16,7,22,29,59,8,61,31,10,0,18,14,0,17,3,12,71,3,73,0,8,19,18,16,0,5,3,41,0,10,22,43,32,11,0,8", "code": "\nfrom sympy import divisors, isprime\ndef a(n): return sum([i for i in divisors(n) if isprime(i) and (isprime(i - 2) or isprime(i + 2))])\nprint([a(n) for n in range(1, 91)]) \n"}
{"sequence_id": "A284600", "text": "a(n) = n/(largest prime power dividing n).", "sequence": "1,1,1,1,1,2,1,1,1,2,1,3,1,2,3,1,1,2,1,4,3,2,1,3,1,2,1,4,1,6,1,1,3,2,5,4,1,2,3,5,1,6,1,4,5,2,1,3,1,2,3,4,1,2,5,7,3,2,1,12,1,2,7,1,5,6,1,4,3,10,1,8,1,2,3,4,7,6,1,5,1,2,1,12,5,2,3,8,1,10", "code": "\nfrom sympy import lcm\ndef a003418(n): return 1 if n<1 else lcm(range(1, n + 1))\ndef a(n):\n    m=1\n    while True:\n        if a003418(m)%n==0: return m\n        else: m+=1\nprint([n//a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A284635", "text": "Numbers with digits 6 and 8 only.", "sequence": "6,8,66,68,86,88,666,668,686,688,866,868,886,888,6666,6668,6686,6688,6866,6868,6886,6888,8666,8668,8686,8688,8866,8868,8886,8888,66666,66668,66686,66688,66866,66868,66886,66888,68666,68668,68686,68688,68866,68868", "code": "\ndef a(n): return int(bin(n+1)[3:].replace('0', '6').replace('1', '8'))\nprint([a(n) for n in range(1, 45)]) \n"}
{"sequence_id": "A284636", "text": "Numbers with digits 6 and 9 only.", "sequence": "6,9,66,69,96,99,666,669,696,699,966,969,996,999,6666,6669,6696,6699,6966,6969,6996,6999,9666,9669,9696,9699,9966,9969,9996,9999,66666,66669,66696,66699,66966,66969,66996,66999,69666,69669,69696,69699,69966,69969", "code": "\ndef a(n): return int(bin(n+1)[3:].replace('0', '6').replace('1', '9'))\nprint([a(n) for n in range(1, 45)]) \n"}
{"sequence_id": "A284648", "text": "Numerator of sum of reciprocals of all divisors of all positive integers <= n.", "sequence": "1,5,23,67,407,527,4169,9913,33379,7583,89461,102397,1408777,1532329,8238221,17872837,316811189,343357709,6768841271,7257705647,7612437167,7993370447,189434541721,202820113921,1047296788661,1090542483461,3390610314383,3551237180783,105395281238707", "code": "\nfrom sympy import divisor_sigma, Integer\nprint([sum(divisor_sigma(k)/Integer(k) for k in range(1, n + 1)).numerator() for n in range(1, 30)]) \n"}
{"sequence_id": "A284650", "text": "Denominator of sum of reciprocals of all divisors of all positive integers <= n.", "sequence": "1,2,6,12,60,60,420,840,2520,504,5544,5544,72072,72072,360360,720720,12252240,12252240,232792560,232792560,232792560,232792560,5354228880,5354228880,26771144400,26771144400,80313433200,80313433200,2329089562800", "code": "\nfrom sympy import divisor_sigma, Integer\nprint([sum(divisor_sigma(k)/Integer(k) for k in range(1, n + 1)).denominator() for n in range(1, 30)]) \n"}
{"sequence_id": "A284670", "text": "Exponents of powers of 5 that contain all ten decimal digits.", "sequence": "19,22,26,27,28,29,31,34,35,37,39,40,41,49,50,51,52,56,57,59,60,61,62,63,64,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104", "code": "\nfrom sympy.ntheory.factor_ import digits\nr10 = set(range(10))\nprint([n for n in range(1, 111) if set(sorted(digits(5**n)[1:])) == r10]) \n"}
{"sequence_id": "A284720", "text": "Number of indecomposable permutations avoiding the vincular pattern 1 2_ 3_.", "sequence": "1,1,3,11,43,179,801,3861,19991,110679,652127,4071179,26823449,185864737,1350279523,10256563803,81258332915,669990127123,5737790656217,50947129880373,468260045596695,4448381809651895,43618802110132167,440918949811405787", "code": "\nfrom sympy import bell\nprint([bell(n) - sum(bell(k) for k in range(n - 1)) for n in range(1, 30)]) \n"}
{"sequence_id": "A284783", "text": "Numbers k such that k and k + 5040 have the same number of divisors.", "sequence": "11,19,22,37,38,39,41,46,47,51,55,57,58,59,61,62,65,67,68,73,74,76,78,79,87,88,91,92,99,102,104,107,113,114,115,116,118,123,124,125,127,129,131,132,133,136,138,139,142,143,146,148,149,153,155,156,157,159", "code": "\nfrom sympy.ntheory import divisor_count as D\nprint([n for n in range(1, 201) if D(n) == D(n + 5040)]) \n"}
{"sequence_id": "A284838", "text": "Number of edges in the n-Keller graph.", "sequence": "0,40,1088,21888,397312,6883328,116244480,1932230656,31778668544,518791888896,8424565768192,136279337467904,2198302774788096,35386835907641344,568757233463066624,9130929873047519232,146464646890277306368,2347871574175904694272", "code": " def a(n): return 2**(2*n-1)*(4**n-3**n-n) \n"}
{"sequence_id": "A284843", "text": "Number of permutations on [n+2] with no circular 2-successions.", "sequence": "3,12,55,318,2163,16952,150183,1483290,16153027,192234372,2481692343,34538108822,515428409715,8210201868528,139028223047143,2493848817565362,47236883312958723,942120664413581180,19735072617803491767,433187081497364626542", "code": "\nfrom sympy import factorial\nprint([(n + 2) * sum([(-1)**j * (n - j + 1) * factorial(n)//factorial(j) for j in range(n + 1)]) for n in range(1, 50)]) \n"}
{"sequence_id": "A284850", "text": "a(n) = 4^n - 3^n - n.", "sequence": "0,5,34,171,776,3361,14190,58967,242452,989517,4017146,16245763,65514528,263652473,1059392902,4251920559,17050729004,68332056229,273715645458,1096024843355,4387586157880,17560804984785,70274600998814,281192547174151,1125052618233156", "code": " def a(n): return 4**n - 3**n - n \n"}
{"sequence_id": "A284859", "text": "Row sums of the Sheffer triangle (exp(x), exp(3*x)-1) given in A282629.", "sequence": "1,4,25,199,1876,20257,245017,3266914,47450923,743935375,12497579698,223619318215,4240423494685,84855613320004,1785410320771933,39373503608087299,907548770965519660,21810536356271794549,545305573054110017125,14155835044848094831018", "code": "\nfrom sympy import binomial, factorial\ndef T(n, m): return sum([binomial(m, k) * (-1)**(k - m) * (1 + 3*k)**n for k in range(m + 1)])//factorial(m)\ndef a(n): return sum([T(n, k) for k in range(n + 1)])\nprint([a(n) for n in range(20)]) \n"}
{"sequence_id": "A284861", "text": "Triangle read by rows: T(n, k) = S2[3,1](n, k)*k! with the Sheffer triangle S2[3,1] = (exp(x), exp(3*x) -1) given in A282629.", "sequence": "1,1,3,1,15,18,1,63,216,162,1,255,1890,3564,1944,1,1023,14760,52650,68040,29160,1,4095,109458,659340,1516320,1487160,524880,1,16383,790776,7578522,27624240,46539360,36741600,11022480,1,65535,5633730,82902204,450057384,1158993360,1535798880,1014068160,264539520", "code": " \nfrom sympy import binomial\nfor n in range(11):\n    print([sum([binomial(k, m)*(-1)**(k - m)*(1 + 3*m)**n for m in range(k + 1)]) for k in range(n + 1)])\n"}
{"sequence_id": "A284864", "text": "Row sums of Sheffer triangle S2[3,2] given by A225466.", "sequence": "1,5,34,287,2839,31898,399079,5480609,81724300,1311990425,22521232003,411039834356,7938680371957,161596770440945,3454818798460858,77340712165173755,1808096791948934755,44038966942707463946,1115155787752634260483,29301563957596710001709", "code": "\nfrom sympy import binomial, factorial\ndef T(n, k): return sum([binomial(k, j)*(-1)**(j - k)*(2 + 3*j)**n/factorial(k) for j in range(k + 1)])\ndef a(n): return sum([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A284873", "text": "Array read by antidiagonals: T(n,k) = number of double palindromes of length n using a maximum of k different symbols.", "sequence": "1,2,1,3,4,1,4,9,8,1,5,16,21,16,1,6,25,40,57,32,1,7,36,65,136,123,52,1,8,49,96,265,304,279,100,1,9,64,133,456,605,880,549,160,1,10,81,176,721,1056,2125,1768,1209,260,1,11,100,225,1072,1687,4356,4345,4936,2127,424,1", "code": "\nfrom sympy import totient, divisors\ndef r(d, k): return (d//2)*(k + 1)*k**(d//2) if d%2 == 0 else d*k**((d + 1)//2)\ndef a(n, k): return r(n, k) - sum([totient(n//d)*a(d, k) for d in divisors(n) if d<n])\nfor n in range(1, 21): print([a(k, n - k + 1) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A284877", "text": "Irregular triangle T(n,k) for 1 <= k <= n/2 + 1: T(n,k) = number of double palindrome structures of length n using exactly k different symbols.", "sequence": "1,1,1,1,3,1,7,2,1,15,5,1,25,21,3,1,49,42,7,1,79,122,44,4,1,129,225,90,9,1,211,570,375,80,5,1,341,990,715,165,11,1,517,2321,2487,930,132,6,1,819,3913,4550,1820,273,13,1,1275,8827,14350,8330,2009,203,7", "code": "\nfrom sympy import totient, divisors, binomial, factorial\ndef r(d, k): return (d//2)*(k + 1)*k**(d//2) if d%2 == 0 else d*k**((d + 1)//2)\ndef a(n, k): return r(n, k) - sum([totient(n//d)*a(d, k) for d in divisors(n) if d<n])\ndef T(n, k): return (sum([(-1)**j * binomial(k, j) * a(n, k - j) for j in range(k + 1)]))//factorial(k)\nfor n in range(1, 21): print([T(n, k) for k in range(1, n//2 + 2)]) \n"}
{"sequence_id": "A284900", "text": "a(n) = Sum_{d|n} (-1)^(n/d+1)*d^4.", "sequence": "1,15,82,239,626,1230,2402,3823,6643,9390,14642,19598,28562,36030,51332,61167,83522,99645,130322,149614,196964,219630,279842,313486,391251,428430,538084,574078,707282,769980,923522,978671,1200644,1252830,1503652,1587677", "code": "\nfrom sympy import divisors\nprint([sum([(-1)**(n//d + 1)*d**4 for d in divisors(n)]) for n in range(1, 51)]) \n"}
{"sequence_id": "A284926", "text": "a(n) = Sum_{d|n} (-1)^(n/d+1)*d^5.", "sequence": "1,31,244,991,3126,7564,16808,31711,59293,96906,161052,241804,371294,521048,762744,1014751,1419858,1838083,2476100,3097866,4101152,4992612,6436344,7737484,9768751,11510114,14408200,16656728,20511150,23645064,28629152,32472031,39296688", "code": "\nfrom sympy import divisors\nprint([sum((-1)**(n//d + 1)*d**5 for d in divisors(n)) for n in range(1, 51)]) \n"}
{"sequence_id": "A284927", "text": "a(n) = Sum_{d|n} (-1)^(n/d+1)*d^6.", "sequence": "1,63,730,4031,15626,45990,117650,257983,532171,984438,1771562,2942630,4826810,7411950,11406980,16510911,24137570,33526773,47045882,62988406,85884500,111608406,148035890,188327590,244156251,304089030,387952660,474247150,594823322", "code": "\nfrom sympy import divisors\nprint([sum([(-1)**(n//d + 1)*d**6 for d in divisors(n)]) for n in range(1, 51)]) \n"}
{"sequence_id": "A284968", "text": "Least hairpin family matchings with n edges that are both L&P and C&C whose leftmost edge is part of a hairpin.", "sequence": "0,1,5,18,59,190,618,2047,6908,23703,82488,290499,1033398,3707837,13402681,48760350,178405139,656043838,2423307027,8987427446,33453694465,124936258104,467995871753,1757900019076,6619846420527,24987199492678,94520750408681", "code": "\nfrom sympy import catalan\ndef a(n): return sum(catalan(k) for k in range(1, n + 1)) - n\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A284971", "text": "Numbers with digits 4 and 7 only.", "sequence": "4,7,44,47,74,77,444,447,474,477,744,747,774,777,4444,4447,4474,4477,4744,4747,4774,4777,7444,7447,7474,7477,7744,7747,7774,7777,44444,44447,44474,44477,44744,44747,44774,44777,47444,47447,47474,47477,47744,47747", "code": "\ndef a(n):\n  b = bin(n+1)[3:]\n  return int(\"\".join(b.replace(\"0\", \"4\").replace(\"1\", \"7\")))\nprint([a(n) for n in range(1, 45)]) \n"}
{"sequence_id": "A285011", "text": "Numbers with digits 7 and 9 only.", "sequence": "7,9,77,79,97,99,777,779,797,799,977,979,997,999,7777,7779,7797,7799,7977,7979,7997,7999,9777,9779,9797,9799,9977,9979,9997,9999,77777,77779,77797,77799,77977,77979,77997,77999,79777,79779,79797,79799,79977,79979", "code": "\ndef a(n): return int(bin(n+1)[3:].replace('0', '7').replace('1', '9'))\nprint([a(n) for n in range(1, 45)]) \n"}
{"sequence_id": "A285056", "text": "a(n) = the first positive integer, not ending in zero, whose cube has a substring of exactly n identical digits.", "sequence": "1,11,126,753,1923,32183,134708,1487139,23908603,215443469,106917811,15056809703,27354803113,681048619195,361160395301", "code": " import collections\nimport re\ncur = 1\ndef repeat( num , reps ):\n    r = str(num)\n    n = 1\n    while n < reps:\n        r += str(num)\n        n += 1\n    return r;\nwhile True:\n    k = 0\n    while k < 10:\n        rep = repeat(k,9)\n        while re.search(rep, str(cur**3)) != None:\n            if re.search(rep + str(k), str(cur**3)) == None:\n                print(str(cur) + \", \" + str(cur**3))\n                rep += str(k)\n            else:\n                rep += str(k)\n        k += 1\n    cur += 1\n    if cur % 10 == 0:\n        cur += 1 \n"}
{"sequence_id": "A285057", "text": "a(n) = lcm(n, A001177(n)).", "sequence": "1,6,12,12,5,12,56,24,36,30,110,12,91,168,60,48,153,36,342,60,168,330,552,24,25,546,108,168,406,60,930,96,660,306,280,36,703,342,1092,120,820,168,1892,660,180,552,752,48,392,150,612,1092,1431,108,110,168,684,1218,3422,60", "code": "\nfrom sympy import fibonacci, lcm\ndef z(n):\n    k=1\n    while fibonacci(k)%n: k+=1\n    return k\ndef a(n): return lcm(n, z(n))\nprint([a(n) for n in range(1,201)]) \n"}
{"sequence_id": "A285058", "text": "Numbers k such that k = A104714(A285057(k)).", "sequence": "1,2,5,7,10,12,13,17,24,25,26,29,34,35,36,37,38,43,47,48,49,50,53,55,58,59,60,65,67,72,73,74,85,89,91,96,97,103,106,108,109,110,113,118,120,125,127,130,137,139,144,145,146,149,156,157,158,163,168,169,170,173,175", "code": "\nfrom sympy import fibonacci, gcd, lcm\ndef z(n):\n    k=1\n    while fibonacci(k)%n: k+=1\n    return k\ndef l(n): return lcm(n, z(n))\ndef g(n): return gcd(n, fibonacci(n))\nprint([n for n in range(1, 201) if n==g(l(n))]) \n"}
{"sequence_id": "A285064", "text": "Row sums of Sheffer triangle S2[4,1] = A285061.", "sequence": "1,5,41,429,5329,75989,1215481,21453693,412820385,8579772325,191166679497,4538638641997,114238219541617,3035305413035125,84819458105387417,2484842038066995485,76101249873390595905,2430497813260105226053,80769536433102942870377,2787318255464814752951533", "code": "\nfrom sympy import binomial, bell\ndef a(n): return sum([binomial(n, k)*bell(k)*4**k for k in range(n + 1)]) \n"}
{"sequence_id": "A285065", "text": "Alternating row sums of Sheffer triangle S2[4,1] = A285061.", "sequence": "1,-3,-7,53,497,-147,-44055,-437339,971745,90858205,1254551513,-56188139,-361749699119,-7793811482035,-47717641321527,2053219888651909,77548473901557697,1171383881442334141,-8155337883596701767", "code": "\nfrom sympy import bell, binomial\ndef a(n): return sum([binomial(n, k)*bell(k, -1)*4**k for k in range(n + 1)]) \n"}
{"sequence_id": "A285066", "text": "Triangle read by rows: T(n, m) = A285061(n, m)*m!, 0 <= m <= n.", "sequence": "1,1,4,1,24,32,1,124,480,384,1,624,5312,10752,6144,1,3124,52800,203520,276480,122880,1,15624,500192,3279360,7956480,8110080,2949120,1,78124,4626720,48633984,187729920,329441280,268369920,82575360,1,390624,42265472,687762432,3969552384,10672865280,14615838720,9909043200,2642411520,1,1953124,383514240,9448097280,78486589440,303521218560,621544734720,696605736960,404288962560,95126814720", "code": "\nfrom sympy import binomial\ndef T(n, m):\n    return sum([binomial(m, k)*(-1)**(k - m)*(1 + 4*k)**n for k in range(n + 1)])\nfor n in range(21):\n    print([T(n, m) for m in range(n + 1)])\n\n"}
{"sequence_id": "A285068", "text": "Denominators of the generalized Bernoulli numbers B[3,1] = 3^n*B(n, 1/3).", "sequence": "1,2,2,1,10,1,14,1,10,1,22,1,910,1,2,1,170,1,266,1,110,1,46,1,910,1,2,1,290,1,4774,1,170,1,2,1,639730,1,2,1,4510,1,602,1,230,1,94,1,15470,1,22", "code": "\nfrom sympy import bernoulli, Rational\ndef a(n):\n    return (3**n * bernoulli(n, Rational(1,3))).as_numer_denom()[1]\nprint([a(n) for n in range(101)])  \n"}
{"sequence_id": "A285097", "text": "a(n) = difference between the positions of two least significant 1-bits in base-2 representation of n, or 0 if there are less than two 1-bits in n (when n is either zero or a power of 2).", "sequence": "0,0,0,1,0,2,1,1,0,3,2,1,1,2,1,1,0,4,3,1,2,2,1,1,1,3,2,1,1,2,1,1,0,5,4,1,3,2,1,1,2,3,2,1,1,2,1,1,1,4,3,1,2,2,1,1,1,3,2,1,1,2,1,1,0,6,5,1,4,2,1,1,3,3,2,1,1,2,1,1,2,4,3,1,2,2,1,1,1,3,2,1,1,2,1,1,1,5,4,1,3,2,1,1,2,3,2,1,1,2,1,1,1,4,3,1,2,2,1,1,1", "code": "\nimport math\ndef a007814(n): return int(math.log(n - (n & n - 1), 2))\ndef a285099(n): return 0 if bin(n)[2:].count(\"1\") < 2 else a007814(n & (n - 1))\ndef a(n): return 0 if bin(n)[2:].count(\"1\")<2 else a285099(n) - a007814(n) \n"}
{"sequence_id": "A285098", "text": "Row sums of irregular triangle A070168.", "sequence": "1,3,23,7,20,29,124,15,147,30,117,41,63,138,296,31,106,165,231,50,84,139,281,65,294,89,40616,166,212,326,40486,63,377,140,258,201,259,269,986,90,40589,126,588,183,253,327,40455,113,382,344,514,141,223,40670,41000,222", "code": "\ndef a(n):\n    if n==1: return 1\n    l=[n]\n    while True:\n        if n%2==0: n//=2\n        else: n = (3*n + 1)//2\n        l.append(n)\n        if n<2: break\n    return sum(l)\nprint([a(n) for n in range(1, 101)])\n"}
{"sequence_id": "A285099", "text": "a(n) is the zero-based index of the second least significant 1-bit in the base-2 representation of n, or 0 if there are fewer than two 1-bits in n.", "sequence": "0,0,0,1,0,2,2,1,0,3,3,1,3,2,2,1,0,4,4,1,4,2,2,1,4,3,3,1,3,2,2,1,0,5,5,1,5,2,2,1,5,3,3,1,3,2,2,1,5,4,4,1,4,2,2,1,4,3,3,1,3,2,2,1,0,6,6,1,6,2,2,1,6,3,3,1,3,2,2,1,6,4,4,1,4,2,2,1,4,3,3,1,3,2,2,1,6,5,5,1,5,2,2,1,5,3,3,1,3,2,2,1,5,4,4,1,4,2,2,1,4", "code": "\nimport math\ndef a007814(n): return int(math.log(n - (n & n - 1), 2))\ndef a(n): return 0 if bin(n)[2:].count(\"1\") < 2 else a007814(n & (n - 1)) \n"}
{"sequence_id": "A285100", "text": "Numbers n for which A065642(n) = A285109(n).", "sequence": "1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,37,38,39,41,42,43,44,46,47,49,51,52,53,55,57,58,59,61,62,64,65,66,67,68,69,70,71,73,74,76,77,78,79,81,82,83,85,86,87,88,89,91,92,93,94,95,97,99,101", "code": "\nfrom operator import mul\nfrom sympy import primefactors\nfrom functools import reduce\ndef a007947(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a020639(n): return 1 if n==1 else primefactors(n)[0]\ndef a065642(n):\n    if n==1: return 1\n    r=a007947(n)\n    n += r\n    while a007947(n)!=r:\n        n+=r\n    return n\nprint([n for n in range(1, 102) if a065642(n) == n*a020639(n)]) \n"}
{"sequence_id": "A285101", "text": "a(0) = 2, for n > 0, a(n) = a(n-1)*A242378(n,a(n-1)), where A242378(n,a(n-1)) shifts the prime factorization of a(n-1) n primes towards larger primes with A003961.", "sequence": "2,6,210,3573570,64845819350301990,28695662573739152697846686144187168109530,1038300112150956151877699324649731518883355380534272386781875587619359740733888844803014212990", "code": "\nfrom sympy import factorint, prime, primepi\nfrom operator import mul\nfrom functools import reduce\ndef a003961(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [prime(primepi(i) + 1)**f[i] for i in f])\ndef a242378(k, n):\n    while k>0:\n        n=a003961(n)\n        k-=1\n    return n\nl=[2]\nfor n in range(1, 7):\n    x=l[n - 1]\n    l.append(x*a242378(n, x))\nprint(l) \n"}
{"sequence_id": "A285102", "text": "a(n) = A007913(A285101(n)).", "sequence": "2,6,210,72930,620310,278995269860970,12849025509071310,492608110538467706074890,1342951001046021018427857601026746070,37793589449865555275592120894959094883390892772270,728982633030274864467458719371654181886452163442582606072870,28339554655955912942523491885490197708224606885407444005070", "code": " \nfrom sympy import factorint, prime, primepi\nfrom sympy.ntheory.factor_ import core\nfrom operator import mul\ndef a003961(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [prime(primepi(i) + 1)**f[i] for i in f])\ndef a242378(k, n):\n    while k>0:\n        n=a003961(n)\n        k-=1\n    return n\nl=[2]\nfor n in range(1, 12):\n    x=l[n - 1]\n    l.append(x*a242378(n, x))\nprint([core(j) for j in l]) \n"}
{"sequence_id": "A285103", "text": "Number of odd terms on row n of A053632: a(n) = A000120(A068052(n)).", "sequence": "1,2,4,6,6,12,12,16,22,28,32,30,36,52,48,62,62,68,88,104,116,108,128,128,132,168,160,168,200,204,240,232,242,284,300,324,332,348,352,352,412,440,400,466,460,516,496,566,582,580,608,646,676,736,716,782,728,816,832,856,916,924,948,1034,1008,1044,1096,1154,1112,1212,1204,1188", "code": " \nl=[1]\nfor n in range(1, 101):\n    x = l[n - 1]\n    l.append(x^(2**n*x))\nprint([A000120(k) for k in l]) \n"}
{"sequence_id": "A285110", "text": "a(n) = A001222(A285323(n)).", "sequence": "0,2,2,1,2,2,1,1,2,2,1,1,1,2,1,1,2,2,2,1,1,2,1,1,1,2,1,1,1,2,1,1,2,2,2,1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,2,1,1,2,1,1,1,2,1,1,1,2,1,1,2,2,2,1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,2,1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,2,1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,2,1,1,2,1,1,1", "code": "\nfrom operator import mul\nfrom sympy import prime, primefactors\nfrom functools import reduce\ndef a001222(n): return 0 if n<2 else a001222(n//min(primefactors(n))) + 1\ndef a019565(n): return reduce(mul, (prime(i+1) for i, v in enumerate(bin(n)[:1:-1]) if v == '1')) if n > 0 else 1 \ndef a007947(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a065642(n):\n    if n==1: return 1\n    r=a007947(n)\n    n += r\n    while a007947(n)!=r:\n        n+=r\n    return n\ndef a285323(n): return a065642(a065642(a019565(n)))//a019565(n)\ndef a(n): return a001222(a285323(n))\nprint([a(n) for n in range(121)]) \n"}
{"sequence_id": "A285111", "text": "Permutation of nonnegative integers: a(1) = 0, a(2) = 1, a(A005117(1+n)) = 2*a(n), a(A065642(n)) = 1 + 2*a(n).", "sequence": "0,1,2,3,4,6,8,7,5,12,16,13,14,10,24,15,32,27,26,25,28,20,48,55,9,30,11,21,64,54,52,31,50,56,40,111,96,110,18,51,60,22,42,41,49,128,108,223,17,103,104,61,62,447,100,43,112,80,222,109,192,220,57,63,36,102,120,113,44,84,82,895,98,256,99,221,216,446,34,207,23", "code": "\nfrom operator import mul\nfrom sympy import primefactors\nfrom sympy.ntheory.factor_ import core\nfrom functools import reduce\ndef a007947(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a285328(n):\n    if core(n) == n: return 1\n    k=n - 1\n    while k>0:\n        if a007947(k) == a007947(n): return k\n        else: k-=1\ndef a013928(n): return sum([1 for i in range(1, n) if core(i) == i])\ndef a(n):\n    if n<3: return n - 1\n    if core(n)==n: return 2*a(a013928(n))\n    else: return 1 + 2*a(a285328(n))\nprint([a(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A285199", "text": "Product of n! and the n-th Legendre polynomial evaluated at 2.", "sequence": "1,2,11,102,1329,22290,457155,11083590,310107105,9834291810,348584413275,13657116176550,586048630115025,27335806776328050,1377091347432275475,74513480022911679750,4309990208248262162625,265383902858519912717250,17331286029912646125208875", "code": "\nfrom sympy import legendre, factorial\ndef a(n): return legendre(n, 2)*factorial(n)\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A285270", "text": "a(n) = H_n(n), where H_n is the physicist's n-th Hermite polynomial.", "sequence": "1,2,14,180,3340,80600,2389704,83965616,3409634960,157077960480,8093278209760,461113571640128,28784033772836544,1953535902100115840,143219579014652040320,11279408109860685024000,949705205977314865582336,85131076752851318807814656,8094279370190580822082014720", "code": "\nfrom sympy import hermite\ndef a(n): return hermite(n, n) \n"}
{"sequence_id": "A285282", "text": "Numbers n such that n^2 + 1 is 13-smooth.", "sequence": "1,2,3,5,7,8,18,57,239", "code": "\nfrom sympy import primefactors\ndef ok(n): return max(primefactors(n**2 + 1))<=13 \n"}
{"sequence_id": "A285309", "text": "Sum of nonsquare divisors of n.", "sequence": "0,2,3,2,5,11,7,10,3,17,11,23,13,23,23,10,17,29,19,37,31,35,23,55,5,41,30,51,29,71,31,42,47,53,47,41,37,59,55,85,41,95,43,79,68,71,47,103,7,67,71,93,53,110,71,115,79,89,59,163,61,95,94,42,83,143,67,121,95,143,71,145,73,113,98", "code": "\nimport gmpy\nfrom sympy import divisors\ndef a(n): return sum([d for d in divisors(n) if gmpy.is_square(d)==0]) \n"}
{"sequence_id": "A285313", "text": "Number of pairs (a,b) such that a*b = n and d(a) = d(b) with d = A000005 and a <= b.", "sequence": "1,0,0,1,0,1,0,0,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,1,2,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,1,1,1,0,1,1,1,1,0,0,1", "code": "\nfrom sympy import divisors, divisor_count\ndef a(n): return sum([d<=(n/d) and divisor_count(d)==divisor_count(n/d) for d in divisors(n)]) \n"}
{"sequence_id": "A285315", "text": "Numbers n for which A019565(n) < n.", "sequence": "8,16,32,33,64,65,66,128,129,130,131,132,136,256,257,258,259,260,261,264,272,512,513,514,515,516,517,518,520,521,528,544,576,640,768,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1040,1041,1042,1056,1057,1088,1089,1152,1280,1536,2048,2049,2050,2051", "code": "\nfrom sympy import prime, prod\ndef a019565(n): return prod(prime(i+1) for i, v in enumerate(bin(n)[:1:-1]) if v == '1') if n > 0 else 1\n[n for n in range(1, 3001) if a019565(n)<n] \n"}
{"sequence_id": "A285316", "text": "Numbers n for which A019565(n) > n.", "sequence": "0,1,2,3,4,5,6,7,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87", "code": "\nfrom operator import mul\nfrom sympy import prime\nfrom functools import reduce\ndef a019565(n): return reduce(mul, (prime(i+1) for i, v in enumerate(bin(n)[:1:-1]) if v == '1')) if n > 0 else 1\nprint([n for n in range(101) if a019565(n)>n]) \n"}
{"sequence_id": "A285317", "text": "Squarefree numbers n for which A019565(n) < n.", "sequence": "33,65,66,129,130,131,257,258,259,514,515,517,518,521,1027,1030,1031,1033,1034,1041,1042,1057,2049,2051,2053,2054,2055,2059,2065,2066,2081,2082,2113,2114,2177,2305,2561,3073,4097,4098,4099,4101,4102,4103,4105,4106,4109,4115,4129,4130,4161,4162,4226,4353,4354,4609,4610,5122", "code": "\nfrom operator import mul\nfrom functools import reduce\nfrom sympy import prime\nfrom sympy.ntheory.factor_ import core\ndef a019565(n): return reduce(mul, (prime(i+1) for i, v in enumerate(bin(n)[:1:-1]) if v == '1')) if n > 0 else 1\nprint([n for n in range(1, 5201) if core(n) == n and a019565(n) < n]) \n"}
{"sequence_id": "A285321", "text": "Square array A(1,k) = A019565(k), A(n,k) = A065642(A(n-1,k)), read by descending antidiagonals.", "sequence": "2,3,4,6,9,8,5,12,27,16,10,25,18,81,32,15,20,125,24,243,64,30,45,40,625,36,729,128,7,60,75,50,3125,48,2187,256,14,49,90,135,80,15625,54,6561,512,21,28,343,120,225,100,78125,72,19683,1024", "code": "\nfrom operator import mul\nfrom sympy import prime, primefactors\ndef a019565(n): return reduce(mul, (prime(i+1) for i, v in enumerate(bin(n)[:1:-1]) if v == '1')) if n > 0 else 1 \ndef a007947(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a065642(n):\n    if n==1: return 1\n    r=a007947(n)\n    n = n + r\n    while a007947(n)!=r:\n        n+=r\n    return n\ndef A(n, k): return a019565(k) if n==1 else a065642(A(n - 1, k))\nfor n in range(1, 11): print([A(k, n - k + 1) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A285322", "text": "Transpose of square array A285321.", "sequence": "2,4,3,8,9,6,16,27,12,5,32,81,18,25,10,64,243,24,125,20,15,128,729,36,625,40,45,30,256,2187,48,3125,50,75,60,7,512,6561,54,15625,80,135,90,49,14,1024,19683,72,78125,100,225,120,343,28,21", "code": "\nfrom operator import mul\nfrom sympy import prime, primefactors\ndef a019565(n): return reduce(mul, (prime(i+1) for i, v in enumerate(bin(n)[:1:-1]) if v == '1')) if n > 0 else 1 \ndef a007947(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a065642(n):\n    if n==1: return 1\n    r=a007947(n)\n    n = n + r\n    while a007947(n)!=r:\n        n+=r\n    return n\ndef A(n, k): return a019565(k) if n==1 else a065642(A(n - 1, k))\nfor n in range(1, 11): print [A(n - k + 1, k) for k in range(1, n + 1)] \n"}
{"sequence_id": "A285323", "text": "a(n) = A065642(A065642(A019565(n))) / A019565(n).", "sequence": "1,4,9,3,25,4,5,3,49,4,7,3,7,4,5,3,121,4,9,3,11,4,5,3,11,4,7,3,7,4,5,3,169,4,9,3,13,4,5,3,13,4,7,3,7,4,5,3,13,4,9,3,11,4,5,3,11,4,7,3,7,4,5,3,289,4,9,3,17,4,5,3,17,4,7,3,7,4,5,3,17,4,9,3,11,4,5,3,11,4,7,3,7,4,5,3,17,4,9,3,13,4,5,3,13,4,7,3,7,4,5,3", "code": "\nfrom operator import mul\nfrom sympy import prime, primefactors\nfrom functools import reduce\ndef a019565(n): return reduce(mul, (prime(i+1) for i, v in enumerate(bin(n)[:1:-1]) if v == '1')) if n > 0 else 1 \ndef a007947(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a065642(n):\n    if n==1: return 1\n    r=a007947(n)\n    n += r\n    while a007947(n)!=r:\n        n+=r\n    return n\ndef a(n): return a065642(a065642(a019565(n)))//a019565(n)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A285326", "text": "a(0) = 0, for n > 0, a(n) = n + A006519(n).", "sequence": "0,2,4,4,8,6,8,8,16,10,12,12,16,14,16,16,32,18,20,20,24,22,24,24,32,26,28,28,32,30,32,32,64,34,36,36,40,38,40,40,48,42,44,44,48,46,48,48,64,50,52,52,56,54,56,56,64,58,60,60,64,62,64,64,128,66,68,68,72,70,72,72,80,74,76,76,80,78,80,80,96,82,84,84,88,86,88,88,96,90,92,92", "code": "\nfrom sympy import gcd\ndef a(n): return n + gcd(2**n, n) if n>0 else 0 \n"}
{"sequence_id": "A285328", "text": "a(n) = 1 if n is squarefree (A005117), otherwise a(n) = Max {m < n | same prime factors as n, ignoring multiplicity}.", "sequence": "1,1,1,2,1,1,1,4,3,1,1,6,1,1,1,8,1,12,1,10,1,1,1,18,5,1,9,14,1,1,1,16,1,1,1,24,1,1,1,20,1,1,1,22,15,1,1,36,7,40,1,26,1,48,1,28,1,1,1,30,1,1,21,32,1,1,1,34,1,1,1,54,1,1,45,38,1,1,1,50,27,1,1,42,1,1,1,44,1,60,1,46,1,1,1,72,1,56,33,80,1,1,1,52,1,1,1,96", "code": "\nfrom operator import mul\nfrom sympy import primefactors\nfrom sympy.ntheory.factor_ import core\ndef a007947(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a(n):\n    if core(n) == n: return 1\n    r = a007947(n)\n    k = n - r\n    while k>0:\n        if a007947(k) == r: return k\n        else: k -= r\nprint([a(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A285329", "text": "a(n) = A013928(A007947(n)).", "sequence": "0,1,2,1,3,4,5,1,2,6,7,4,8,9,10,1,11,4,12,6,13,14,15,4,3,16,2,9,17,18,19,1,20,21,22,4,23,24,25,6,26,27,28,14,10,29,30,4,5,6,31,16,32,4,33,9,34,35,36,18,37,38,13,1,39,40,41,21,42,43,44,4,45,46,10,24,47,48,49,6,2,50,51,27,52,53,54,14,55,18,56,29,57,58,59,4,60,9,20,6", "code": "\nfrom operator import mul\nfrom sympy import primefactors\nfrom sympy.ntheory.factor_ import core\nfrom functools import reduce\ndef a007947(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a013928(n): return sum(1 for i in range(1, n) if core(i) == i)\nprint([a013928(a007947(n)) for n in range(1, 101)]) \n"}
{"sequence_id": "A285332", "text": "a(0) = 1, a(1) = 2, a(2n) = A019565(a(n)), a(2n+1) = A065642(a(n)).", "sequence": "1,2,3,4,6,9,5,8,15,12,14,27,10,25,7,16,210,45,35,18,105,28,462,81,21,20,154,125,30,49,11,32,10659,420,910,75,78,175,33,24,3094,315,385,56,780045,924,374,243,110,63,55,40,4389,308,170170,625,1155,60,286,343,42,121,13,64,54230826,31977,28405,630,1330665,1820,714", "code": "\nfrom operator import mul\nfrom sympy import prime, primefactors\ndef a007947(n): return 1 if n<2 else reduce(mul, primefactors(n))\ndef a019565(n): return reduce(mul, (prime(i+1) for i, v in enumerate(bin(n)[:1:-1]) if v == '1')) if n > 0 else 1 \ndef a065642(n):\n    if n==1: return 1\n    r=a007947(n)\n    n = n + r\n    while a007947(n)!=r:\n        n+=r\n    return n\ndef a(n):\n    if n<2: return n + 1\n    if n%2==0: return a019565(a(n//2))\n    else: return a065642(a((n - 1)//2))\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A285336", "text": "a(n) = numerator of A065642(n)/n.", "sequence": "1,2,3,2,5,2,7,2,3,2,11,3,13,2,3,2,17,4,19,2,3,2,23,3,5,2,3,2,29,2,31,2,3,2,5,4,37,2,3,5,41,2,43,2,5,2,47,9,7,8,3,2,53,4,5,7,3,2,59,3,61,2,7,2,5,2,67,2,3,2,71,4,73,2,9,2,7,2,79,5,3,2,83,3,5,2,3,2,89,4,7,2,3,2,5,9,97,8,3,8,101,2,103,2,3,2,107,4,109,2,3", "code": "\nfrom sympy import primefactors, prod, Integer\ndef a007947(n): return 1 if n<2 else prod(primefactors(n))\ndef a065642(n):\n    if n==1: return 1\n    r=a007947(n)\n    n += r\n    while a007947(n)!=r:\n        n += r\n    return n\ndef a(n): return (a065642(n)/Integer(n)).numerator() \n"}
{"sequence_id": "A285337", "text": "a(n) = denominator of A065642(n)/n.", "sequence": "1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,3,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,4,1,1,1,1,3,1,1,8,1,5,1,1,1,3,1,4,1,1,1,2,1,1,3,1,1,1,1,1,1,1,1,3,1,1,5,1,1,1,1,4,1,1,1,2,1,1,1,1,1,3,1,1,1,1,1,8,1,7,1,5,1,1,1,1,1,1,1,3,1,1,1,4,1,1,1,1,1,1,1,4", "code": "\nfrom sympy import primefactors, prod, Integer\ndef a007947(n): return 1 if n<2 else prod(primefactors(n))\ndef a065642(n):\n    if n==1: return 1\n    r=a007947(n)\n    n += r\n    while a007947(n)!=r:\n        n+=r\n    return n\ndef a(n): return (a065642(n)/Integer(n)).denominator() \n"}
{"sequence_id": "A285356", "text": "Numbers n such that the entries in the n-th row of the irregular triangle A237591 are in nonincreasing order.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,13,15,16,17,18,19,21,22,23,24,26,28,29,30,31,32,36,37,38,40,41,45,46,47,48,51,55,57,58,59,66,67,70,71,78,79,80,84,92,93,94,108,109,120,136,137,155", "code": "\nimport math\nfrom sympy import sqrt\ndef T(n, k): return int(math.ceil((n + 1)/k - (k + 1)/2)) - int(math.ceil((n + 1)/(k + 1) - (k + 2)/2))\ndef isok(n):\n    l = [T(n, k) for k in range(1, int(math.floor((sqrt(8*n + 1) - 1)/2)) + 1)]\n    for i in range(len(l) - 1):\n        if l[i + 1] > l[i]: return 0\n    return 1\nprint([n for n in range(1, 156) if isok(n)]) \n"}
{"sequence_id": "A285388", "text": "a(n) = numerator of ((1/n) * Sum_{k=0..n^2-1} binomial(2k,k)/4^k).", "sequence": "1,35,36465,300540195,79006629023595,331884405207627584403,22292910726608249789889125025,11975573020964041433067793888190275875,411646257111422564507234009694940786177843149765,56592821660064550728377610673427602421565368547133335525825", "code": "\nfrom sympy import binomial, Integer\ndef a(n): return (Integer(2)**(1 - 2*n**2)*n*binomial(2*n**2, n**2)).numerator() \n"}
{"sequence_id": "A285389", "text": "Denominator of Sum_{k=0..n^2-1}((-1)^k*sqrt(Pi)/(Gamma(1/2-k)*Gamma(1+k))/n.", "sequence": "1,32,32768,268435456,70368744177664,295147905179352825856,19807040628566084398385987584,10633823966279326983230456482242756608,365375409332725729550921208179070754913983135744,50216813883093446110686315385661331328818843555712276103168", "code": "\nfrom sympy import binomial, Integer\ndef a(n): return (Integer(2)**(1-2*n**2) * Integer(n) * binomial(2*n**2, n**2)).denominator() \n"}
{"sequence_id": "A285406", "text": "Base-2 logarithm of denominator of Sum_{k=0..n^2-1}((-1)^k*sqrt(Pi)/(Gamma(1/2-k)*Gamma(1+k)))/n).", "sequence": "0,5,15,28,46,68,94,123,158,195,236,283,333,387,445,506,574,643,716,794,875,961,1054,1146,1244,1346,1451,1562,1676,1794,1916,2041,2174,2307,2444,2586,2731,2881,3034,3193,3356,3520,3690,3864,4041,4227,4413,4601,4796,4993", "code": "\nfrom sympy import binomial, integer_log, Integer\ndef a(n): return integer_log((Integer(2)**(1 - 2*n**2)*n*binomial(2*n**2, n**2)).denominator(), 2)[0] \n"}
{"sequence_id": "A285426", "text": "Numbers n such that at least two consecutive elements of the n-th row of A237591 are in increasing order.", "sequence": "14,20,25,27,33,34,35,39,42,43,44,49,50,52,53,54,56,60,61,62,63,64,65,68,69,72,73,74,75,76,77,81,82,83,85,86,87,88,89,90,91,95,96,97,98,99,100,101,102,103,104,105,106,107,110,111,112,113,114,115,116,117,118,119,121,122,123,124,125,126,127,128", "code": "\nimport math\nfrom sympy import sqrt\ndef T(n, k): return int(math.ceil((n + 1)/k - (k + 1)/2)) - int(math.ceil((n + 1)/(k + 1) - (k + 2)/2))\ndef isok(n):\n    l = [T(n, k) for k in range(1, int(math.floor((sqrt(8*n + 1) - 1)/2)) + 1)]\n    return any(l[i + 1] > l[i] for i in range(len(l) - 1))\nprint([n for n in range(1, 151) if isok(n)]) \n"}
{"sequence_id": "A285508", "text": "Numbers with exactly three prime factors, not all distinct.", "sequence": "8,12,18,20,27,28,44,45,50,52,63,68,75,76,92,98,99,116,117,124,125,147,148,153,164,171,172,175,188,207,212,236,242,244,245,261,268,275,279,284,292,316,325,332,333,338,343,356,363,369,387,388,404,412,423,425,428,436,452", "code": "\nfrom sympy import primefactors\ndef omega(n): return 0 if n==1 else len(primefactors(n))\ndef bigomega(n): return 0 if n==1 else bigomega(n//min(primefactors(n))) + 1\nprint([n for n in range(1, 501) if omega(n)<3 and bigomega(n) == 3]) \n"}
{"sequence_id": "A285551", "text": "Volume of each square prism building the next 3-dimensional box in A100538 where side lengths form the Padovan spiral number sequence (A134816), starting with 1 X 1 X 1, 1 X 1 X 2, 2 X 2 X 2, 2 X 2 X 3, 4 X 4 X 5, ...", "sequence": "1,2,8,12,36,80,175,441,972,2304,5376,12348,29008,67081,156065,363350,843144,1962396,4560200,10600000,24648975,57288465,133194600,309636096,719790336,1673379352,3890033728,9043304417,21023197601,48872682810,113615800200,264124052396", "code": "\nfrom sympy import binomial\ndef A(n): return sum([binomial(k, n - 2*k) for k in range(int(n/2) + 1)])\ndef a000931(n): return 1 if n==0 else 0 if n<3 else A(n - 3)\ndef a(n): return a000931(n + 5)**2*a000931(n + 6) \n"}
{"sequence_id": "A285699", "text": "a(1) = 1; for n > 1, a(n) = n - A079277(n).", "sequence": "1,1,2,2,4,2,6,4,6,2,10,3,12,6,6,8,16,2,18,4,12,6,22,6,20,10,18,12,28,3,30,16,6,2,10,4,36,6,12,8,40,6,42,12,18,14,46,12,42,10,24,20,52,6,30,7,30,26,58,6,60,30,14,32,40,2,66,4,42,6,70,8,72,10,30,12,28,6,78,16,54,18,82,3,60,22,6,24,88,9,42,28,12,30,70,15,96,34,18,20", "code": "\nfrom sympy import divisors\nfrom sympy.ntheory.factor_ import core\ndef a007947(n): return max(i for i in divisors(n) if core(i) == i)\ndef a079277(n):\n    k=n - 1\n    while True:\n        if a007947(k*n) == a007947(n): return k\n        else: k-=1\ndef a(n): return 1 if n<2 else n - a079277(n)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A285700", "text": "a(n) = Number of iterations x -> 2x-1 needed to get a nonprime number, when starting with x = n.", "sequence": "0,3,2,0,1,0,2,0,0,0,1,0,1,0,0,0,1,0,3,0,0,0,1,0,0,0,0,0,1,0,2,0,0,0,0,0,2,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,3,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0", "code": "\nfrom sympy import isprime\ndef a(n): return 0 if isprime(n) == 0 else 1 + a(2*n - 1) \n"}
{"sequence_id": "A285707", "text": "a(n) = gcd(n, A079277(n)), a(1) = 1.", "sequence": "1,1,1,2,1,2,1,4,3,2,1,3,1,2,3,8,1,2,1,4,3,2,1,6,5,2,9,4,1,3,1,16,3,2,5,4,1,2,3,8,1,6,1,4,9,2,1,12,7,10,3,4,1,6,5,7,3,2,1,6,1,2,7,32,5,2,1,4,3,2,1,8,1,2,15,4,7,6,1,16,27,2,1,3,5,2,3,8,1,9,7,4,3,2,5,3,1,2,9,20,1,6,1,8,3,2,1,12,1,10,3,14,1,6,5,4,9", "code": "\nfrom sympy import divisors, gcd\nfrom sympy.ntheory.factor_ import core\ndef a007947(n):\n    return max(i for i in divisors(n) if core(i) == i)\ndef a079277(n):\n    k=n - 1\n    while True:\n        if a007947(k*n) == a007947(n): return k\n        else: k-=1\ndef a(n): return 1 if n==1 else gcd(n, a079277(n))\nprint([a(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A285708", "text": "a(n) = n / A285707(n).", "sequence": "1,2,3,2,5,3,7,2,3,5,11,4,13,7,5,2,17,9,19,5,7,11,23,4,5,13,3,7,29,10,31,2,11,17,7,9,37,19,13,5,41,7,43,11,5,23,47,4,7,5,17,13,53,9,11,8,19,29,59,10,61,31,9,2,13,33,67,17,23,35,71,9,73,37,5,19,11,13,79,5,3,41,83,28,17,43,29,11,89,10,13,23,31,47,19,32,97,49,11,5", "code": "\nfrom sympy import divisors, gcd\nfrom sympy.ntheory.factor_ import core\ndef a007947(n): return max(i for i in divisors(n) if core(i) == i)\ndef a079277(n):\n    k=n - 1\n    while True:\n        if a007947(k*n) == a007947(n): return k\n        else: k-=1\ndef a285707(n): return 1 if n==1 else gcd(n, a079277(n))\nprint([n//a285707(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A285709", "text": "a(n) = A000010(n) - A285699(n).", "sequence": "0,0,0,0,0,0,0,0,0,2,0,1,0,0,2,0,0,4,0,4,0,4,0,2,0,2,0,0,0,5,0,0,14,14,14,8,0,12,12,8,0,6,0,8,6,8,0,4,0,10,8,4,0,12,10,17,6,2,0,10,0,0,22,0,8,18,0,28,2,18,0,16,0,26,10,24,32,18,0,16,0,22,0,21,4,20,50,16,0,15,30,16,48,16,2,17,0,8,42,20,0,26,0,8,24,10,0,24,0,30,42,34,0,30,-2", "code": "\nfrom sympy import divisors, totient\nfrom sympy.ntheory.factor_ import core\ndef a007947(n): return max(i for i in divisors(n) if core(i) == i)\ndef a079277(n):\n    k=n - 1\n    while True:\n        if a007947(k*n) == a007947(n): return k\n        else: k-=1\ndef a285699(n): return 1 if n<2 else n - a079277(n)\ndef a(n): return totient(n) - a285699(n)\nprint([a(n) for n in range(1, 116)]) \n"}
{"sequence_id": "A285710", "text": "Numbers n for which A000010(n) = A285699(n); positions of zeros in A285709.", "sequence": "1,2,3,4,5,6,7,8,9,11,13,14,16,17,19,21,23,25,27,28,29,31,32,37,41,43,47,49,53,59,61,62,64,67,71,73,79,81,83,89,97,101,103,107,109,113,121,124,125,127,128,131,137,139,149,151,157,163,167,169,173,179,181,191,193,197,199,211,223,227,229,233,237", "code": "\nfrom sympy import divisors, totient\nfrom sympy.ntheory.factor_ import core\ndef a007947(n): return max(i for i in divisors(n) if core(i) == i)\ndef a079277(n):\n    k=n - 1\n    while True:\n        if a007947(k*n) == a007947(n): return k\n        else: k-=1\ndef a285699(n): return 1 if n<2 else n - a079277(n)\nprint([n for n in range(1, 301) if totient(n) == a285699(n)]) \n"}
{"sequence_id": "A285711", "text": "a(n) = gcd(A051953(n), A079277(n)), a(1) = 1.", "sequence": "1,1,1,2,1,4,1,4,3,2,1,1,1,8,1,8,1,4,1,4,9,4,1,2,5,2,9,16,1,1,1,16,1,2,1,8,1,4,3,8,1,6,1,8,3,8,1,4,7,10,1,4,1,12,5,1,3,2,1,2,1,32,1,32,1,2,1,4,1,2,1,16,1,2,5,8,1,18,1,16,27,2,1,3,1,4,1,16,1,3,1,16,3,16,1,1,1,8,3,20,1,2,1,8,3,2,1,24,1,10,3,2,1,6,1", "code": "\nfrom sympy import divisors, totient, gcd\nfrom sympy.ntheory.factor_ import core\ndef a007947(n): return max(i for i in divisors(n) if core(i) == i)\ndef a079277(n):\n    k=n - 1\n    while True:\n        if a007947(k*n) == a007947(n): return k\n        else: k-=1\ndef a(n): return 1 if n==1 else gcd(n - totient(n), a079277(n))\nprint([a(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A285717", "text": "a(n) = A007814(n) + A159918(n) = A007814(n) + A000120(n^2).", "sequence": "1,2,2,3,3,3,3,4,3,4,5,4,4,4,4,5,3,4,5,5,6,6,3,5,5,5,6,5,5,5,5,6,3,4,5,5,6,6,7,6,5,7,7,7,8,4,4,6,5,6,5,6,8,7,7,6,6,6,7,6,6,6,6,7,3,4,5,5,6,6,7,6,6,7,9,7,7,8,5,7,6,6,8,8,7,8,7,8,9,9,5,5,6,5,5,7,5,6,6,7,9,6,7,7,6,9,8,8,8,8,4,7,7,7,8,7,9,8,8,7", "code": "\nimport math\ndef a(n): return int(math.log(n - (n & n - 1), 2)) + bin(n**2)[2:].count(\"1\") \n"}
{"sequence_id": "A285718", "text": "a(1) = 0, and for n > 1, a(n) = the least squarefree number x such that n-x is also squarefree.", "sequence": "0,1,1,1,2,1,1,1,2,3,1,1,2,1,1,1,2,1,2,1,2,1,1,1,2,3,1,2,3,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,3,1,1,2,3,5,1,2,1,2,1,2,1,1,1,2,1,1,2,3,1,1,1,2,1,1,1,2,1,1,2,3,1,1,1,2,3,1,1,2,1,1,1,2,1,2,1,2,1,1,1,2,1,2,3,6,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,3,1,1", "code": "\nfrom sympy.ntheory.factor_ import core\ndef issquarefree(n): return core(n) == n\ndef a285718(n):\n    if n==1: return 0\n    x = 1\n    while True:\n        if issquarefree(x) and issquarefree(n - x):return x\n        else: x+=1\nprint([a285718(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A285719", "text": "a(1) = 1, and for n > 1, a(n) = the largest squarefree number k such that n-k is also squarefree.", "sequence": "1,1,2,3,3,5,6,7,7,7,10,11,11,13,14,15,15,17,17,19,19,21,22,23,23,23,26,26,26,29,30,31,31,33,34,35,35,37,38,39,39,41,42,43,43,43,46,47,47,47,46,51,51,53,53,55,55,57,58,59,59,61,62,62,62,65,66,67,67,69,70,71,71,73,74,74,74,77,78,79,79,79,82,83,83,85,86,87,87,89,89,91,91", "code": "\nfrom sympy.ntheory.factor_ import core\ndef issquarefree(n): return core(n) == n\ndef a285718(n):\n    if n==1: return 0\n    x = 1\n    while True:\n        if issquarefree(x) and issquarefree(n - x):return x\n        else: x+=1\ndef a285719(n): return n - a285718(n)\nprint([a285719(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A285720", "text": "Number of ways to write n as a sum of two unordered squarefree numbers so that their addition in base-2 does not produce carries.", "sequence": "0,0,1,0,0,0,2,0,0,0,1,0,0,0,3,0,0,0,1,0,0,0,3,0,0,0,2,0,0,0,5,0,0,0,2,0,0,0,4,0,0,0,3,0,0,0,6,0,0,0,1,0,0,0,4,0,0,0,4,0,0,0,11,0,0,0,2,0,0,0,4,0,0,0,3,0,0,0,7,0,0,0,2,0,0,0,6,0,0,0,3,0,0,0,11,0,0,0,3,0,0,0,7,0,0,0,7,0,0,0,13,0,0,0,3,0,0,0,9,0", "code": "\nfrom sympy import mobius\ndef a003987(n, i): return i^(n - i) == n\ndef a(n): return sum([abs(mobius(i)*mobius(n - i))*(1*a003987(n, i)) for i in range(1, n//2 + 1)])\nprint([a(n) for n in range(1,121)]) \n"}
{"sequence_id": "A285721", "text": "Square array read by antidiagonals: A(n,k) = number of steps in simple Euclidean algorithm for gcd(n,k) to reach the termination test n=k, read by antidiagonals as A(1,1), A(1,2), A(2,1), A(1,3), A(2,2), A(3,1), etc.", "sequence": "0,1,1,2,0,2,3,2,2,3,4,1,0,1,4,5,3,3,3,3,5,6,2,3,0,3,2,6,7,4,1,4,4,1,4,7,8,3,4,2,0,2,4,3,8,9,5,4,4,5,5,4,4,5,9,10,4,2,1,4,0,4,1,2,4,10,11,6,5,5,4,6,6,4,5,5,6,11,12,5,5,3,5,3,0,3,5,3,5,5,12,13,7,3,5,1,2,7,7,2,1,5,3,7,13,14,6,6,2,6,3,5,0,5,3,6,2,6,6,14", "code": "\ndef A(n, k): return 0 if n==k else 1 + A(abs(n - k), min(n, k))\nfor n in range(1, 21): print([A(n - k + 1, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A285722", "text": "Square array A(n,k) read by antidiagonals, A(n,n) = 0, otherwise, if n > k, A(n,k) = T(n-k,k), else A(n,k) = T(n,k-n), where T(n,k) is sequence A000027 considered as a two-dimensional table.", "sequence": "0,1,1,2,0,3,4,3,2,6,7,5,0,5,10,11,8,6,4,9,15,16,12,9,0,8,14,21,22,17,13,10,7,13,20,28,29,23,18,14,0,12,19,27,36,37,30,24,19,15,11,18,26,35,45,46,38,31,25,20,0,17,25,34,44,55,56,47,39,32,26,21,16,24,33,43,54,66,67,57,48,40,33,27,0,23,32,42,53,65,78,79,68,58,49,41,34,28,22,31,41,52,64,77,91", "code": "\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)//2\ndef A(n, k): return 0 if n == k else T(n - k, k) if n>k else T(n, k - n)\nfor n in range(1, 21): print([A(k, n - k + 1) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A285723", "text": "Transpose of square array A285722.", "sequence": "0,1,1,3,0,2,6,2,3,4,10,5,0,5,7,15,9,4,6,8,11,21,14,8,0,9,12,16,28,20,13,7,10,13,17,22,36,27,19,12,0,14,18,23,29,45,35,26,18,11,15,19,24,30,37,55,44,34,25,17,0,20,25,31,38,46,66,54,43,33,24,16,21,26,32,39,47,56,78,65,53,42,32,23,0,27,33,40,48,57,67,91,77,64,52,41,31,22,28,34,41,49,58,68,79", "code": "\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef A(n, k): return 0 if n == k else T(n - k, k) if n>k else T(n, k - n)\nfor n in range(1, 21): print [A(n - k + 1, k) for k in range(1, n + 1)] \n"}
{"sequence_id": "A285729", "text": "Compound filter: a(n) = T(A032742(n), A046523(n)), where T(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,2,2,12,2,31,2,59,18,50,2,142,2,73,50,261,2,199,2,220,73,131,2,607,33,166,129,314,2,961,2,1097,131,248,73,1396,2,295,166,923,2,1246,2,550,340,401,2,2509,52,655,248,692,2,1252,131,1303,295,590,2,3946,2,661,517,4497,166,1924,2,1024,401,2051,2,5707,2,898,655,1214,131,2317,2,3781,888", "code": "\nfrom sympy import divisors, factorint\ndef a032742(n): return 1 if n==1 else max(divisors(n)[:-1])\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n   f = factorint(n)\n   return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(a032742(n), a046523(n)) \n"}
{"sequence_id": "A285730", "text": "Square array: If A001222(n) < k, then A(n,k) = n, otherwise A(n,k) = product of k largest prime factors of n (taken with multiplicity), read by descending antidiagonals.", "sequence": "1,1,2,1,2,3,1,2,3,2,1,2,3,4,5,1,2,3,4,5,3,1,2,3,4,5,6,7,1,2,3,4,5,6,7,2,1,2,3,4,5,6,7,4,3,1,2,3,4,5,6,7,8,9,5,1,2,3,4,5,6,7,8,9,10,11,1,2,3,4,5,6,7,8,9,10,11,3,1,2,3,4,5,6,7,8,9,10,11,6,13,1,2,3,4,5,6,7,8,9,10,11,12,13,7", "code": "\nfrom sympy import primefactors\ndef a006530(n): return 1 if n==1 else max(primefactors(n))\ndef A(n, k): return a006530(n) if k==1 else a006530(n)*A(n/a006530(n), k - 1)\nfor n in range(1, 21): print [A(k, n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A285731", "text": "Transpose of square array A285730.", "sequence": "1,2,1,3,2,1,2,3,2,1,5,4,3,2,1,3,5,4,3,2,1,7,6,5,4,3,2,1,2,7,6,5,4,3,2,1,3,4,7,6,5,4,3,2,1,5,9,8,7,6,5,4,3,2,1,11,10,9,8,7,6,5,4,3,2,1,3,11,10,9,8,7,6,5,4,3,2,1,13,6,11,10,9,8,7,6,5,4,3,2,1,7,13,12,11,10,9,8,7,6,5,4,3,2,1", "code": "\nfrom sympy import primefactors\ndef a006530(n): return 1 if n==1 else max(primefactors(n))\ndef A(n, k): return a006530(n) if k==1 else a006530(n)*A(n/a006530(n), k - 1)\nfor n in range(1, 21): print [A(n - k + 1, k) for k in range(1, n + 1)] \n"}
{"sequence_id": "A285732", "text": "Square array A(n,k) read by antidiagonals, A(n,n) = -n, otherwise, if n > k, A(n,k) = T(n-k,k), else A(n,k) = T(n,k-n), where T(n,k) is sequence A000027 considered as a two-dimensional table.", "sequence": "-1,1,1,2,-2,3,4,3,2,6,7,5,-3,5,10,11,8,6,4,9,15,16,12,9,-4,8,14,21,22,17,13,10,7,13,20,28,29,23,18,14,-5,12,19,27,36,37,30,24,19,15,11,18,26,35,45,46,38,31,25,20,-6,17,25,34,44,55,56,47,39,32,26,21,16,24,33,43,54,66,67,57,48,40,33,27,-7,23,32,42,53,65,78", "code": "\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)//2\ndef A(n, k): return -n if n == k else T(n - k, k) if n>k else T(n, k - n)\nfor n in range(1, 21): print([A(k, n - k + 1) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A285733", "text": "Transpose of square array A285732.", "sequence": "-1,1,1,3,-2,2,6,2,3,4,10,5,-3,5,7,15,9,4,6,8,11,21,14,8,-4,9,12,16,28,20,13,7,10,13,17,22,36,27,19,12,-5,14,18,23,29,45,35,26,18,11,15,19,24,30,37,55,44,34,25,17,-6,20,25,31,38,46,66,54,43,33,24,16,21,26,32,39,47,56,78,65,53,42,32,23,-7,27,33,40,48,57,67", "code": "\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef A(n, k): return -n if n == k else T(n - k, k) if n>k else T(n, k - n)\nfor n in range(1, 21): print [A(n - k + 1, k) for k in range(1, n + 1)] \n"}
{"sequence_id": "A285734", "text": "a(1) = 0, and for n > 1, a(n) = the largest squarefree number x such that x < n-x, and n-x is also squarefree.", "sequence": "0,1,1,2,2,3,2,3,3,5,5,6,6,7,5,6,7,7,6,10,10,11,10,11,11,13,13,14,14,15,14,15,14,17,14,17,15,19,17,19,19,21,21,22,22,23,21,22,23,21,22,26,23,23,26,26,26,29,29,30,30,31,30,31,31,33,33,34,34,35,34,35,35,37,37,38,38,39,38,39,39,41,41,42,42,43,41,42,43,43,38,46,46,47,42", "code": "\nfrom sympy.ntheory.factor_ import core\ndef issquarefree(n): return core(n) == n\ndef a285734(n):\n    if n==1: return 0\n    j=n//2\n    while True:\n        if issquarefree(j) and issquarefree(n - j): return j\n        else: j-=1\nprint([a285734(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A285735", "text": "a(1) = 1, and for n > 1, a(n) = the least squarefree number x such that x > n-x, and n-x is also squarefree.", "sequence": "1,1,2,2,3,3,5,5,6,5,6,6,7,7,10,10,10,11,13,10,11,11,13,13,14,13,14,14,15,15,17,17,19,17,21,19,22,19,22,21,22,21,22,22,23,23,26,26,26,29,29,26,30,31,29,30,31,29,30,30,31,31,33,33,34,33,34,34,35,35,37,37,38,37,38,38,39,39,41,41,42,41,42,42,43,43,46,46,46,47,53,46,47,47", "code": "\nfrom sympy.ntheory.factor_ import core\ndef issquarefree(n): return core(n) == n\ndef a285734(n):\n    if n==1: return 0\n    j=n//2\n    while True:\n        if issquarefree(j) and issquarefree(n - j): return j\n        else: j-=1\ndef a285735(n): return n - a285734(n)\nprint([a285735(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A285736", "text": "a(n) = A285735(n) - A285734(n) = n - 2*A285734(n).", "sequence": "1,0,1,0,1,0,3,2,3,0,1,0,1,0,5,4,3,4,7,0,1,0,3,2,3,0,1,0,1,0,3,2,5,0,7,2,7,0,5,2,3,0,1,0,1,0,5,4,3,8,7,0,7,8,3,4,5,0,1,0,1,0,3,2,3,0,1,0,1,0,3,2,3,0,1,0,1,0,3,2,3,0,1,0,1,0,5,4,3,4,15,0,1,0,11,10,5,4,7,6,9,0,11,2,11,0,15,2,7,0,5,2,3,0,1,0,1,0,3", "code": "\nfrom sympy.ntheory.factor_ import core\ndef issquarefree(n): return core(n) == n\ndef a285734(n):\n    if n==1: return 0\n    j=n//2\n    while True:\n        if issquarefree(j) and issquarefree(n - j): return j\n        else: j-=1\ndef a285736(n): return n - 2*a285734(n)\nprint([a285736(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A285769", "text": "(Product of distinct prime factors)^(Product of prime exponents).", "sequence": "1,2,3,4,5,6,7,8,9,10,11,36,13,14,15,16,17,36,19,100,21,22,23,216,25,26,27,196,29,30,31,32,33,34,35,1296,37,38,39,1000,41,42,43,484,225,46,47,1296,49,100,51,676,53,216,55,2744,57,58,59,900,61,62,441", "code": "\nfrom sympy import divisor_count, divisors\nfrom sympy.ntheory.factor_ import core\ndef rad(n): return max(list(filter(lambda i: core(i) == i, divisors(n))))\ndef a(n): return rad(n)**divisor_count(n/rad(n)) \n"}
{"sequence_id": "A285786", "text": "Number of primes p with 2(n-1)^2 < p <= 2n^2.", "sequence": "1,3,3,4,4,5,5,6,6,9,7,8,7,9,10,10,9,12,10,11,13,11,14,13,14,13,14,16,16,15,15,16,17,18,19,14,22,19,18,16,22,18,24,20,22,22,20,23,24,22,23,21,25,27,24,27,26,25,27,25,23,33,28,25,29,28,31,30,33,29", "code": "\nfrom sympy import primepi\ndef a(n): return primepi(2*n**2) - primepi(2*(n - 1)**2) \n"}
{"sequence_id": "A285788", "text": "Irregular triangle T(n,m): nonprime 1 <= k <= n such that n and k are coprime.", "sequence": "1,1,1,1,1,4,1,1,4,6,1,1,4,8,1,9,1,4,6,8,9,10,1,1,4,6,8,9,10,12,1,9,1,4,8,14,1,9,15,1,4,6,8,9,10,12,14,15,16,1,1,4,6,8,9,10,12,14,15,16,18,1,9,1,4,8,10,16,20,1,9,15,21,1,4,6,8,9,10", "code": "\nfrom sympy import gcd, isprime\ndef a(n): return list(filter(lambda k: isprime(k)==0 and gcd(k, n)==1, range(1, n + 1)))\nfor n in range(1, 21): print a(n) \n"}
{"sequence_id": "A285791", "text": "Primes equal to a heptagonal number plus 1.", "sequence": "2,19,113,149,541,617,971,1289,1783,2357,3011,3187,5689,6427,7481,7757,9829,12497,12853,14327,15881,17099,18793,21023,24851,28463,30637,31193,45361,50909,54539,60607,63761,66179,69473,70309,83449,88079,90917,91873,94771", "code": "\nfrom sympy import isprime\ndef heptagonal(n): return n*(5*n-3)//2\ndef aupto(limit):\n  alst, n, hn = [], 1, heptagonal(1)\n  while hn < limit:\n    if isprime(hn+1): alst.append(hn+1)\n    n, hn = n+1, heptagonal(n+1)\n  return alst\nprint(aupto(94771)) \n"}
{"sequence_id": "A285802", "text": "Smallest number that when multiplied by n contains the digit 7.", "sequence": "7,35,9,18,14,12,1,9,3,7,7,6,6,5,5,11,1,4,3,35,7,8,9,3,3,3,1,17,3,9,7,18,9,5,2,2,1,2,2,18,7,9,4,4,6,6,1,12,3,14,7,11,7,5,5,12,1,3,3,12,7,6,6,9,11,11,1,4,3,1,1,1,1,1,1,1,1,1,1,9,7,7", "code": "\ndef a(n):\n    k=1\n    while True:\n        if \"7\" in str(n*k): return k\n        k+=1\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A285815", "text": "Numbers k such that, for any divisor d of k, the digital sum of d divides k.", "sequence": "1,2,3,4,5,6,7,8,9,10,12,18,20,21,24,27,30,36,40,54,60,63,72,81,90,108,120,162,180,216,243,270,324,360,486,540,648,810,972,1080,1458,1620,1944,2430,2916,3240,4374,4860,5832,7290,8748,9720,13122,14580,17496", "code": "\nfrom sympy import divisors\nfrom sympy.ntheory.factor_ import digits\ndef ok(n):\n   return all(n%sum(digits(d)[1:])==0 for d in divisors(n))\nprint([n for n in range(1, 20001) if ok(n)]) \n"}
{"sequence_id": "A285850", "text": "Number of ways n couples can sit in a row such that exactly one couple sits next to each other.", "sequence": "0,2,8,288,15744,1401600,183582720,33223034880,7939197665280,2421184409763840,917547530747904000,422959572499916390400,233037523912020826521600,151234400024881955183001600,114177664785555609793383628800,99217287255932372662490234880000", "code": "\nfrom sympy import binomial, subfactorial\ndef a007060(n): return sum([(-1)**(n - k)*binomial(n, k)*subfactorial(2*k) for k in range(n + 1)])\ndef a(n): return 0 if n<1 else a007060(n) + 2*n*a007060(n - 1) \n"}
{"sequence_id": "A285863", "text": "Numerators of Bernoulli numbers 3^n*B(n), with B(n) = A027641(n)/A027642(n).", "sequence": "1,-3,3,0,-27,0,243,0,-2187,0,98415,0,-122408577,0,11160261,0,-51899996619,0,5664991530321,0,-202943637014337,0,8938507796555139,0,-22252066887294301257,0,7246946747292751629,0,-181103830292539169071623", "code": "\nfrom sympy import bernoulli\ndef a(n): return (3**n * bernoulli(n)).numerator()\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A285864", "text": "Triangle read by rows: a(n,m) = numerator(binomial(n,m)*2^(n-m)*B(n-m) with B(k) the Bernoulli numbers A027641(k)/A027642(k).", "sequence": "1,-1,1,2,-2,1,0,2,-3,1,-8,0,4,-4,1,0,-8,0,20,-5,1,32,0,-8,0,10,-6,1,0,32,0,-56,0,14,-7,1,-128,0,128,0,-112,0,56,-8,1,0,-384,0,128,0,-336,0,24,-9,1,2560,0,-384,0,320,0,-112,0,30,-10,1", "code": "\nfrom sympy import binomial, bernoulli\ndef T(n, m): return (binomial(n, m) * 2**(n - m) * bernoulli(n - m)).numerator()\nfor n in range(21): print([T(n, m) for m in range(n + 1)]) \n"}
{"sequence_id": "A285865", "text": "Denominator of the coefficient triangle B2(n, m) of generalized Bernoulli polynomials PB2(n, x) read by rows.", "sequence": "1,1,1,3,1,1,1,1,1,1,15,1,1,1,1,1,3,1,3,1,1,21,1,1,1,1,1,1,1,3,1,3,1,1,1,1,15,1,3,1,3,1,3,1,1,1,5,1,1,1,5,1,1,1,1,33,1,1,1,1,1,1,1,1,1,1", "code": "\nfrom sympy import binomial, bernoulli\ndef T(n, m):\n    return (binomial(n, m) * 2**(n - m) * bernoulli(n - m)).denominator()\nfor n in range(21): print([T(n, m) for m in range(n + 1)]) \n"}
{"sequence_id": "A285871", "text": "Decimal expansion of 1/sqrt(2 - sqrt(2)) (reciprocal of A101464).", "sequence": "1,3,0,6,5,6,2,9,6,4,8,7,6,3,7,6,5,2,7,8,5,6,6,4,3,1,7,3,4,2,7,1,8,7,1,5,3,5,8,3,7,6,1,1,8,8,3,4,9,2,6,9,5,2,7,5,4,8,8,9,8,3,6,6,9,0,8,0,8,1,0,4,1,4,6,1,1,9,2,0,5,0,9,5,1,8,5,3,7,2,0,1,9,2,6,2,8,1,4", "code": "\nfrom sympy import N, sqrt\nprint(N(1/sqrt(2 - sqrt(2)), 100)) \n"}
{"sequence_id": "A285879", "text": "Number of odd squarefree numbers <= n.", "sequence": "1,1,2,2,3,3,4,4,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,11,11,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,19,19,20,20,20,20,21,21,22,22,23,23,24,24,25,25,26,26,26,26,27,27,28,28,29,29,30,30,31,31,31,31,32,32,33,33,33,33,34,34,35", "code": "\nfrom sympy.ntheory.factor_ import core\ndef a(n): return sum([1 for k in range(1, n + 1) if k%2==1 and core(k)==k]) \n"}
{"sequence_id": "A285881", "text": "Number of even squarefree numbers <= n.", "sequence": "0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16,17,17,17,17,18,18,18,18", "code": "\nfrom sympy.ntheory.factor_ import core\ndef a(n): return sum([1 for k in range(1, n + 1) if k%2==0 and core(k)==k]) \n"}
{"sequence_id": "A285898", "text": "Triangle read by row: T(n,k) = number of partitions of n into exactly k consecutive parts (1 <= k <= n).", "sequence": "1,1,0,1,1,0,1,0,0,0,1,1,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom sympy import binomial\ndef T(n, k):\n    n=n - binomial(k, 2)\n    if n>0:\n        return 1 if n%k==0 else 0\n    return 0\nfor n in range(1, 21): print([T(n, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A285914", "text": "Irregular triangle read by rows: T(n,k), n>=1, k>=1, in which column k lists k's interleaved with k-1 zeros, and the first element of column k is in row k(k+1)/2.", "sequence": "1,1,1,2,1,0,1,2,1,0,3,1,2,0,1,0,0,1,2,3,1,0,0,4,1,2,0,0,1,0,3,0,1,2,0,0,1,0,0,4,1,2,3,0,5,1,0,0,0,0,1,2,0,0,0,1,0,3,4,0,1,2,0,0,0,1,0,0,0,5,1,2,3,0,0,6,1,0,0,4,0,0,1,2,0,0,0,0,1,0,3,0,0,0,1,2,0,0,5,0,1,0,0,4,0,0,1,2,3,0,0,6", "code": "\nfrom sympy import sqrt\nimport math\ndef a237048(n, k):\n    return int(n%k == 0) if k%2 else int(((n - k//2)%k) == 0)\ndef T(n, k): return k*a237048(n, k)\nfor n in range(1, 29): print([T(n, k) for k in range(1, int(math.floor((sqrt(8*n + 1) - 1)/2)) + 1)]) \n"}
{"sequence_id": "A286032", "text": "a(n) = a(n-1) - n*a(n-2); a(0) = a(1) = 1.", "sequence": "1,1,-1,-4,0,20,20,-120,-280,800,3600,-5200,-48400,19200,696800,408800,-10740000,-17689600,175630400,511732800,-3000875200,-13747264000,52271990400,368459062400,-886068707200,-10097545267200,12940241120000,285573963334400", "code": "\nl=[1, 1]\na=b=1\ni=2\nwhile i<=30:\n    l.append(b - i*a)\n    b=l[-1]\n    a=l[-2]\n    i+=1\nprint(l) \n"}
{"sequence_id": "A286034", "text": "Compound filter: a(n) = P(A046523(n), A161942(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,8,3,49,8,34,3,239,124,97,8,165,30,34,34,1051,47,1237,17,508,21,97,8,727,565,331,74,165,122,733,3,4403,34,502,34,7911,192,196,72,2302,233,526,68,508,1237,97,8,3051,1774,5368,97,1782,380,727,97,727,51,1231,122,3220,498,34,288,18019,331,733,155,2713,34,733,47,35317,705,1897,873,1047,34", "code": "\nfrom sympy import factorint, divisors, divisor_sigma\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a000265(n): return max(list(filter(lambda i: i%2 == 1, divisors(n))))\ndef a161942(n): return a000265(divisor_sigma(n))\ndef a(n): return T(a046523(n), a161942(n)) \n"}
{"sequence_id": "A286098", "text": "Square array read by antidiagonals: A(n,k) = T(n AND k, n OR k), where T(n,k) is sequence A001477 considered as a two-dimensional table, AND is bitwise-and (A004198) and OR is bitwise-or (A003986).", "sequence": "0,1,1,3,4,3,6,6,6,6,10,11,12,11,10,15,15,17,17,15,15,21,22,21,24,21,22,21,28,28,28,28,28,28,28,28,36,37,38,37,40,37,38,37,36,45,45,47,47,49,49,47,47,45,45,55,56,55,58,59,60,59,58,55,56,55,66,66,66,66,70,70,70,70,66,66,66,66,78,79,80,79,78,83,84,83,78,79,80,79,78", "code": "\ndef T(a, b): return ((a + b)**2 + 3*a + b)/2\ndef A(n, k): return T(n&k, n|k)\nfor n in range(0, 21): print [A(k, n - k) for k in range(0, n + 1)] \n"}
{"sequence_id": "A286099", "text": "Square array read by antidiagonals: A(n,k) = T(n OR k, n AND k), where T(n,k) is sequence A001477 considered as a two-dimensional table, AND is bitwise-and (A004198) and OR is bitwise-or (A003986).", "sequence": "0,2,2,5,4,5,9,9,9,9,14,13,12,13,14,20,20,18,18,20,20,27,26,27,24,27,26,27,35,35,35,35,35,35,35,35,44,43,42,43,40,43,42,43,44,54,54,52,52,50,50,52,52,54,54,65,64,65,62,61,60,61,62,65,64,65,77,77,77,77,73,73,73,73,77,77,77,77,90,89,88,89,90,85,84,85,90,89,88,89,90", "code": "\ndef T(a, b): return ((a + b)**2 + 3*a + b)/2\ndef A(n, k): return T(n|k, n&k)\nfor n in range(0, 21): print [A(k, n - k) for k in range(0, n + 1)] \n"}
{"sequence_id": "A286100", "text": "Square array A(n,k): If n = k, then A(n,k) = n, otherwise 0, read by antidiagonals as A(1,1), A(1,2), A(2,1), A(1,3), A(2,2), A(3,1), etc.", "sequence": "1,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0", "code": "\ndef A(n, k): return n if n==k else 0\nfor n in range(1, 21): print [A(k, n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A286103", "text": "a(1) = 0; for n > 1, a(n) = 1 + min(a(A285734(n)), a(A285735(n))).", "sequence": "0,1,1,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,5,6,6,6,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6", "code": "\nfrom sympy.ntheory.factor_ import core\ndef issquarefree(n): return core(n) == n\ndef a285734(n):\n    if n==1: return 0\n    j=n//2\n    while True:\n        if issquarefree(j) and issquarefree(n - j): return j\n        else: j-=1\ndef a285735(n): return n - a285734(n)\ndef a286103(n): return 0 if n==1 else 1 + min(a286103(a285734(n)), a286103(a285735(n)))\nprint([a286103(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A286104", "text": "If A286103(A285734(n)) < A286103(A285735(n)), a(n) = A285734(n), otherwise a(n) = A285735(n), a(1) = 0.", "sequence": "0,1,1,2,3,3,2,3,3,5,6,6,7,7,5,6,7,7,6,10,11,11,13,13,14,13,14,14,15,15,17,17,19,17,14,19,15,19,17,19,19,21,22,22,23,23,26,26,26,29,29,26,30,31,29,30,31,29,30,30,31,31,33,33,34,33,34,34,35,35,37,37,38,37,38,38,39,39,41,41,39,41,41,42,43,43,41,46,46,47,38,46,47,47,53,53", "code": "\nfrom sympy.ntheory.factor_ import core\ndef issquarefree(n): return core(n) == n\ndef a285734(n):\n    if n==1: return 0\n    j=n//2\n    while True:\n        if issquarefree(j) and issquarefree(n - j): return j\n        else: j-=1\ndef a285735(n): return n - a285734(n)\ndef a286103(n): return 0 if n==1 else 1 + min(a286103(a285734(n)), a286103(a285735(n)))\ndef a286104(n): return 0 if n==1 else  a285734(n) if a286103(a285734(n)) < a286103(a285735(n)) else a285735(n)\nprint([a286104(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A286105", "text": "a(1) = 0; for n > 1, a(n) = 1 + max(a(A285734(n)), a(A285735(n))).", "sequence": "0,1,2,2,3,3,4,4,4,4,4,4,5,5,5,5,5,5,6,5,5,5,6,6,6,6,6,6,6,6,6,6,7,6,6,7,6,7,6,7,7,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,7,8,8,7,7,7,7,7,8,7,8,8,8,7,8,8,7,8,8,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8", "code": "\nfrom sympy.ntheory.factor_ import core\ndef issquarefree(n): return core(n) == n\ndef a285734(n):\n    if n==1: return 0\n    j=n//2\n    while True:\n        if issquarefree(j) and issquarefree(n - j): return j\n        else: j-=1\ndef a285735(n): return n - a285734(n)\ndef a286105(n): return 0 if n==1 else 1 + max(a286105(a285734(n)), a286105(a285735(n)))\nprint([a286105(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A286106", "text": "a(1) = 0, and for n > 1, a(n) = A286105(A285735(n)) - A286105(A285734(n)).", "sequence": "0,0,1,0,1,0,2,1,1,0,0,0,1,0,1,1,0,0,2,0,0,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,-1,-1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,-1,0,0,0,0,0,1,0,1,0,-1,0,0,1,0,0,-1,0,0,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom sympy.ntheory.factor_ import core\ndef issquarefree(n): return core(n) == n\ndef a285734(n):\n    if n==1: return 0\n    j=n//2\n    while True:\n        if issquarefree(j) and issquarefree(n - j): return j\n        else: j-=1\ndef a285735(n): return n - a285734(n)\ndef a286105(n): return 0 if n==1 else 1 + max(a286105(a285734(n)), a286105(a285735(n)))\ndef a286106(n): return 0 if n==1 else a286105(a285735(n)) - a286105(a285734(n))\nprint([a286106(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A286107", "text": "a(1) = 0, for n > 1, if A286106(n) > 0, then a(n) = A285735(n), otherwise a(n) = A285734(n).", "sequence": "0,1,2,2,3,3,5,5,6,5,5,6,7,7,10,10,7,7,13,10,10,11,13,13,14,13,13,14,14,15,14,15,19,17,14,19,15,19,17,19,19,21,21,22,23,23,26,26,23,29,29,26,23,23,26,26,26,29,29,30,30,31,33,33,31,33,33,34,34,35,34,35,38,37,38,38,38,39,38,41,39,41,41,42,42,43,41,46,46,47,38,46,46,47", "code": "\nfrom sympy.ntheory.factor_ import core\ndef issquarefree(n): return core(n) == n\ndef a285734(n):\n    if n==1: return 0\n    j=n//2\n    while True:\n        if issquarefree(j) and issquarefree(n - j): return j\n        else: j-=1\ndef a285735(n): return n - a285734(n)\ndef a286105(n): return 0 if n==1 else 1 + max(a286105(a285734(n)), a286105(a285735(n)))\ndef a286106(n): return 0 if n==1 else a286105(a285735(n)) - a286105(a285734(n))\ndef a286107(n): return 0 if n==1 else a285735(n) if a286106(n)>0 else a285734(n)\nprint([a286107(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A286108", "text": "Square array read by antidiagonals: A(n,k) = T(2*(n AND k), n XOR k), where T(n,k) is sequence A001477 considered as a two-dimensional table, AND is bitwise-and (A004198) and XOR is bitwise-xor (A003987).", "sequence": "0,1,1,3,5,3,6,6,6,6,10,12,14,12,10,15,15,19,19,15,15,21,23,21,27,21,23,21,28,28,28,28,28,28,28,28,36,38,40,38,44,38,40,38,36,45,45,49,49,53,53,49,49,45,45,55,57,55,61,63,65,63,61,55,57,55,66,66,66,66,74,74,74,74,66,66,66,66,78,80,82,80,78,88,90,88,78,80,82,80,78", "code": "\ndef T(a, b): return ((a + b)**2 + 3*a + b)//2\ndef A(n, k): return T(2*(n&k), n^k)\nfor n in range(21): print([A(k, n - k) for k in range(n + 1)]) \n"}
{"sequence_id": "A286109", "text": "Square array read by antidiagonals: A(n,k) = T(n XOR k, 2*(n AND k)), where T(n,k) is sequence A001477 considered as a two-dimensional table, AND is bitwise-and (A004198) and XOR is bitwise-xor (A003987).", "sequence": "0,2,2,5,3,5,9,9,9,9,14,12,10,12,14,20,20,16,16,20,20,27,25,27,21,27,25,27,35,35,35,35,35,35,35,35,44,42,40,42,36,42,40,42,44,54,54,50,50,46,46,50,50,54,54,65,63,65,59,57,55,57,59,65,63,65,77,77,77,77,69,69,69,69,77,77,77,77,90,88,86,88,90,80,78,80,90,88,86,88,90", "code": "\ndef T(a, b): return ((a + b)**2 + 3*a + b)//2\ndef A(n, k): return T(n^k, 2*(n&k))\nfor n in range(21): print([A(k, n - k) for k in range(n + 1)]) \n"}
{"sequence_id": "A286110", "text": "Number of distinct hexaflexagons of length n.", "sequence": "1,1,1,3,3,7,8,17,21,47,63,132,205,411,685,1353,2385,4643,8496,16430,30735,59343,112531,217245,415628,803209,1545463,2991191,5778267,11201883,21702708,42141575,81830748,159140895,309590883,602938098,1174779397,2290920127", "code": "\nfrom sympy import binomial as C, totient, divisors, gcd, floor, ceiling\ndef a007148(n):\n    if n==1: return 1\n    return 2**(n - 2) + sum(totient(2*d)*2**(n//d) for d in divisors(n))//(4*n)\ndef a052307(n, k): return 1 if n==0 else C((n//2) - k%2 * (1 - n%2), (k//2))/2 + sum(totient(d)*C(n//d, k//d) for d in divisors(gcd(n, k)))/(2*n)\ndef a(n):\n    if n%2: return sum([a052307(n, ceiling(n/2) + 1 + 3*i) for i in range(n//6 + 2)])\n    else:\n        s=sum([a052307(n, ceiling(n/2) + 3*i) for i in range(n//6 + 1)])\n        return s - a052307(n, n//2)//2 + a007148(n//2)//2 - 1\nprint([a(n) for n in range(3, 41)]) \n"}
{"sequence_id": "A286142", "text": "Compound filter: a(n) = T(A257993(n), A046523(n)), where T(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,5,2,12,2,31,2,38,7,23,2,94,2,23,16,138,2,94,2,80,16,23,2,328,7,23,29,80,2,532,2,530,16,23,16,706,2,23,16,302,2,499,2,80,67,23,2,1228,7,80,16,80,2,328,16,302,16,23,2,1957,2,23,67,2082,16,499,2,80,16,467,2,2704,2,23,67,80,16,499,2,1178,121,23,2,1894,16,23,16,302,2,1957,16", "code": "\nfrom sympy import factorint, prime, primepi, gcd\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a053669(n):\n    x=1\n    while True:\n        if gcd(prime(x), n) == 1: return prime(x)\n        else: x+=1\ndef a257993(n): return primepi(a053669(n))\ndef a(n): return T(a257993(n), a046523(n)) \n"}
{"sequence_id": "A286143", "text": "Compound filter: a(n) = T(A055881(n), A046523(n)), where T(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,5,2,12,2,31,2,38,7,23,2,94,2,23,16,138,2,94,2,80,16,23,2,355,7,23,29,80,2,499,2,530,16,23,16,706,2,23,16,302,2,499,2,80,67,23,2,1279,7,80,16,80,2,328,16,302,16,23,2,1894,2,23,67,2082,16,499,2,80,16,467,2,2779,2,23,67,80,16,499,2,1178,121,23,2,1894,16,23,16,302,2,1894,16", "code": "\nfrom sympy import factorial, factorint\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a055881(n):\n    m = 1\n    while n%factorial(m)==0:\n        m+=1\n    return m - 1\ndef a(n): return T(a055881(n), a046523(n)) \n"}
{"sequence_id": "A286144", "text": "Compound filter: a(n) = T(A000010(n), A257993(n)), where T(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,2,3,5,10,8,21,14,21,14,55,19,78,27,36,44,136,34,171,44,78,65,253,53,210,90,171,90,406,63,465,152,210,152,300,103,666,189,300,152,820,103,903,230,300,275,1081,169,903,230,528,324,1378,208,820,324,666,434,1711,187,1830,495,666,560,1176,251,2211,560,990,324,2485,349,2628,702,820,702", "code": "\nfrom sympy import prime, primepi, gcd, totient\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a053669(n):\n    x=1\n    while True:\n        if gcd(prime(x), n) == 1: return prime(x)\n        else: x+=1\ndef a257993(n): return primepi(a053669(n))\ndef a(n): return T(totient(n), a257993(n)) \n"}
{"sequence_id": "A286145", "text": "Square array read by antidiagonals: A(n,k) = T(n XOR k, k), where T(n,k) is sequence A001477 considered as a two-dimensional table, and XOR is bitwise-xor (A003987).", "sequence": "0,4,2,12,1,5,24,18,13,9,40,17,3,8,14,60,50,11,7,26,20,84,49,61,6,42,19,27,112,98,85,73,62,52,43,35,144,97,59,72,10,51,25,34,44,180,162,83,71,22,16,41,33,64,54,220,161,181,70,38,15,23,32,88,53,65,264,242,221,201,58,48,39,31,116,102,89,77,312,241,179,200,222,47,21,30,148,101,63,76,90", "code": "\ndef T(a, b): return ((a + b)**2 + 3*a + b)//2\ndef A(n, k): return T(n^k, k)\nfor n in range(21): print([A(k, n - k) for k in range(n + 1)]) \n"}
{"sequence_id": "A286146", "text": "Lower triangular region of square array A286101.", "sequence": "1,2,5,4,16,13,7,12,67,25,11,46,106,191,41,16,23,31,80,436,61,22,92,211,379,596,862,85,29,38,277,59,781,302,1541,113,37,154,58,631,991,193,1954,2557,145,46,57,436,212,96,467,2416,822,4006,181,56,232,529,947,1486,2146,2927,3829,4852,5996,221,67,80,94,109,1771,142,3487,355,706,1832,8647", "code": "\nfrom sympy import lcm, gcd\ndef t(n, k): return (2 + ((gcd(n, k) + lcm(n, k))**2) - gcd(n, k) - 3*lcm(n, k))/2\nfor n in range(1, 21): print [t(n, k) for k in range(1, n + 1)] \n"}
{"sequence_id": "A286147", "text": "Square array read by antidiagonals: A(n,k) = T(n XOR k, n), where T(n,k) is sequence A001477 considered as a two-dimensional table, and XOR is bitwise-xor (A003987)", "sequence": "0,2,4,5,1,12,9,13,18,24,14,8,3,17,40,20,26,7,11,50,60,27,19,42,6,61,49,84,35,43,52,62,73,85,98,112,44,34,25,51,10,72,59,97,144,54,64,33,41,16,22,71,83,162,180,65,53,88,32,23,15,38,70,181,161,220,77,89,102,116,31,39,48,58,201,221,242,264,90,76,63,101,148,30,21,47,222,200,179,241,312", "code": "\ndef T(a, b): return ((a + b)**2 + 3*a + b)//2\ndef A(n, k): return T(n^k, k)\nfor n in range(21): print([A(n - k, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A286148", "text": "Triangle A286146 reversed.", "sequence": "1,5,2,13,16,4,25,67,12,7,41,191,106,46,11,61,436,80,31,23,16,85,862,596,379,211,92,22,113,1541,302,781,59,277,38,29,145,2557,1954,193,991,631,58,154,37,181,4006,822,2416,467,96,212,436,57,46,221,5996,4852,3829,2927,2146,1486,947,529,232,56,265,8647,1832,706,355,3487,142,1771,109,94,80,67", "code": "\nfrom sympy import lcm, gcd\ndef t(n, k): return (2 + ((gcd(n, k) + lcm(n, k))**2) - gcd(n, k) - 3*lcm(n, k))/2\nfor n in range(1, 21): print [t(n, k) for k in range(1, n + 1)][::-1] \n"}
{"sequence_id": "A286149", "text": "Compound filter: a(n) = T(A046523(n), A109395(n)), where T(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,5,8,14,17,34,30,44,19,51,68,103,93,72,196,152,155,103,192,132,72,126,278,349,32,159,53,165,437,976,498,560,709,237,786,739,705,282,159,402,863,660,948,243,337,384,1130,1273,49,132,1546,288,1433,349,126,459,282,567,1772,2761,1893,636,165,2144,2421,1921,2280,390,2707,2046,2558,2773,2703", "code": "\nfrom sympy import factorint, totient, gcd\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(a046523(n), n/gcd(n, totient(n))) \n"}
{"sequence_id": "A286150", "text": "Square array read by antidiagonals: A(n,k) = T(n XOR k, min(n,k)), where T(n,k) is sequence A001477 considered as a two-dimensional table, and XOR is bitwise-xor (A003987).", "sequence": "0,2,2,5,1,5,9,13,13,9,14,8,3,8,14,20,26,7,7,26,20,27,19,42,6,42,19,27,35,43,52,62,62,52,43,35,44,34,25,51,10,51,25,34,44,54,64,33,41,16,16,41,33,64,54,65,53,88,32,23,15,23,32,88,53,65,77,89,102,116,31,39,39,31,116,102,89,77,90,76,63,101,148,30,21,30,148,101,63,76,90", "code": "\ndef T(a, b): return ((a + b)**2 + 3*a + b)//2\ndef A(n, k): return T(n^k, min(n, k))\nfor n in range(21): print([A(k, n - k) for k in range(n + 1)]) \n"}
{"sequence_id": "A286151", "text": "Square array read by descending antidiagonals: If n > k, A(n,k) = T(n XOR k, k), and otherwise A(n,k) = T(n, n XOR k), where T(n,k) is sequence A001477 considered as a two-dimensional table, and XOR is bitwise-xor (A003987).", "sequence": "0,1,2,3,2,5,6,11,13,9,10,7,5,8,14,15,22,8,7,26,20,21,16,38,9,42,19,27,28,37,47,58,62,52,43,35,36,29,23,48,14,51,25,34,44,45,56,30,39,19,16,41,33,64,54,55,46,80,31,25,20,23,32,88,53,65,66,79,93,108,32,41,39,31,116,102,89,77,78,67,57,94,140,33,27,30,148,101,63,76,90", "code": "\ndef T(a, b): return ((a + b)**2 + 3*a + b)//2\ndef A(n, k): return T(n^k, k) if n>k else T(n, n^k)\nfor n in range(21): print([A(k, n - k) for k in range(n + 1)]) \n"}
{"sequence_id": "A286152", "text": "Compound filter: a(n) = T(A051953(n), A046523(n)), where T(n,k) is sequence A000027 used as a pairing function.", "sequence": "0,2,2,12,2,40,2,59,18,61,2,179,2,86,73,261,2,265,2,265,100,148,2,757,33,185,129,367,2,1297,2,1097,166,271,131,1735,2,320,205,1105,2,1741,2,619,517,430,2,3113,52,850,295,769,2,1747,205,1517,346,625,2,5297,2,698,730,4497,248,2821,2,1117,460,2821,2,7069,2,941,1070,1315,248,3457,2,4513", "code": "\nfrom sympy import factorint, totient\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(n - totient(n), a046523(n)) \n"}
{"sequence_id": "A286153", "text": "Square array read by descending antidiagonals A(1,1), A(1,2), A(2,1), ...: If n > k, A(n,k) = T(n XOR k, k), and otherwise A(n,k) = T(n, n XOR k), where T(n,k) is sequence A001477 considered as a two-dimensional table, and XOR is bitwise-xor (A003987).", "sequence": "2,11,13,7,5,8,22,8,7,26,16,38,9,42,19,37,47,58,62,52,43,29,23,48,14,51,25,34,56,30,39,19,16,41,33,64,46,80,31,25,20,23,32,88,53,79,93,108,32,41,39,31,116,102,89,67,57,94,140,33,27,30,148,101,63,76,106,68,81,157,176,34,29,184,166,87,75,118,92,138,69,175,158,216,35,224,165,185,74,150,103", "code": "\ndef T(a, b): return ((a + b)**2 + 3*a + b)/2\ndef A(n, k): return T(n^k, k) if n>k else T(n, n^k)\nfor n in range(1, 21): print [A(k, n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A286154", "text": "Compound filter: a(n) = T(A055396(n), A000010(n)), where T(n,k) is sequence A000027 used as a pairing function.", "sequence": "0,1,5,2,18,2,40,7,23,7,96,7,142,16,38,29,238,16,308,29,80,46,444,29,234,67,173,67,676,29,791,121,212,121,328,67,1093,154,302,121,1339,67,1499,191,302,232,1785,121,994,191,530,277,2227,154,864,277,668,379,2718,121,2944,436,668,497,1228,191,3505,497,992,277,3936,277,4207,631,822,631", "code": "\nfrom sympy import primepi, isprime, primefactors, totient\ndef a049084(n): return primepi(n)*(1*isprime(n))\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a(n): return T(a055396(n), totient(n)) \n"}
{"sequence_id": "A286156", "text": " A(n,k) = T(remainder(n,k), quotient(n,k)), where T(n,k) is sequence A001477 considered as a two-dimensional table, square array read by descending antidiagonals.", "sequence": "1,2,3,2,1,6,2,5,4,10,2,5,1,3,15,2,5,9,4,7,21,2,5,9,1,8,6,28,2,5,9,14,4,3,11,36,2,5,9,14,1,8,7,10,45,2,5,9,14,20,4,13,12,16,55,2,5,9,14,20,1,8,3,6,15,66,2,5,9,14,20,27,4,13,7,11,22,78,2,5,9,14,20,27,1,8,19,12,17,21,91,2,5,9,14,20,27,35,4,13,3,18,10,29,105", "code": "\ndef T(a, b): return ((a + b)**2 + 3*a + b)//2\ndef A(n, k): return T(n%k, n//k)\nfor n in range(1, 21): print([A(k, n - k + 1) for k in range(1, n + 1)])  \n"}
{"sequence_id": "A286157", "text": "Transpose of square array A286156.", "sequence": "1,3,2,6,1,2,10,4,5,2,15,3,1,5,2,21,7,4,9,5,2,28,6,8,1,9,5,2,36,11,3,4,14,9,5,2,45,10,7,8,1,14,9,5,2,55,16,12,13,4,20,14,9,5,2,66,15,6,3,8,1,20,14,9,5,2,78,22,11,7,13,4,27,20,14,9,5,2,91,21,17,12,19,8,1,27,20,14,9,5,2,105,29,10,18,3,13,4,35,27,20,14,9,5,2", "code": "\ndef T(a, b): return ((a + b)**2 + 3*a + b)/2\ndef A(n, k): return T(n%k, int(n/k))\nfor n in range(1, 21): print [A(n - k + 1, k) for k in range(1, n + 1)] \n"}
{"sequence_id": "A286158", "text": "Lower triangular region of array A286156.", "sequence": "1,3,1,6,4,1,10,3,4,1,15,7,8,4,1,21,6,3,8,4,1,28,11,7,13,8,4,1,36,10,12,3,13,8,4,1,45,16,6,7,19,13,8,4,1,55,15,11,12,3,19,13,8,4,1,66,22,17,18,7,26,19,13,8,4,1,78,21,10,6,12,3,26,19,13,8,4,1,91,29,16,11,18,7,34,26,19,13,8,4,1,105,28,23,17,25,12,3,34,26,19,13,8,4,1", "code": "\ndef T(a, b): return ((a + b)**2 + 3*a + b)/2\ndef A(n, k): return T(n%k, int(n/k))\nfor n in range(1, 21): print [A(k, n - k + 1) for k in range(1, n + 1)]  \n"}
{"sequence_id": "A286159", "text": "Lower triangular region of array A286156, transposed.", "sequence": "1,1,3,1,4,6,1,4,3,10,1,4,8,7,15,1,4,8,3,6,21,1,4,8,13,7,11,28,1,4,8,13,3,12,10,36,1,4,8,13,19,7,6,16,45,1,4,8,13,19,3,12,11,15,55,1,4,8,13,19,26,7,18,17,22,66,1,4,8,13,19,26,3,12,6,10,21,78,1,4,8,13,19,26,34,7,18,11,16,29,91,1,4,8,13,19,26,34,3,12,25,17,23,28,105", "code": "\ndef T(a, b): return ((a + b)**2 + 3*a + b)/2\ndef a(n, k): return T(n%k, int(n/k))\nfor n in range(1, 21): print [a(n , k) for k in range(1, n + 1)][::-1]  \n"}
{"sequence_id": "A286160", "text": "Compound filter: a(n) = T(A000010(n), A046523(n)), where T(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,2,5,12,14,23,27,59,42,40,65,109,90,61,86,261,152,142,189,179,148,115,275,473,273,148,318,265,434,674,495,1097,320,226,430,1093,702,271,430,757,860,832,945,485,619,373,1127,1969,1032,485,698,619,1430,838,1030,1105,856,556,1769,2791,1890,625,1117,4497,1426,1196,2277,935,1220", "code": "\nfrom sympy import factorint, totient\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(totient(n), a046523(n)) \n"}
{"sequence_id": "A286161", "text": "Compound filter: a(n) = T(A001511(n), A046523(n)), where T(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,5,2,18,2,23,2,59,7,23,2,94,2,23,16,195,2,80,2,94,16,23,2,355,7,23,29,94,2,467,2,672,16,23,16,706,2,23,16,355,2,467,2,94,67,23,2,1331,7,80,16,94,2,302,16,355,16,23,2,1894,2,23,67,2422,16,467,2,94,16,467,2,2779,2,23,67,94,16,467,2,1331,121,23,2,1894,16,23,16,355,2,1832", "code": "\nfrom sympy import factorint\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a001511(n): return 2 + bin(n - 1)[2:].count(\"1\") - bin(n)[2:].count(\"1\")\ndef a(n): return T(a001511(n), a046523(n)) \n"}
{"sequence_id": "A286162", "text": "Compound filter: a(n) = T(A001511(n), A278222(n)), where T(n,k) is sequence A000027 used as a pairing function.", "sequence": "2,5,7,9,16,12,29,14,16,23,67,18,67,38,121,20,16,23,67,31,436,80,277,25,67,80,631,48,277,138,497,27,16,23,67,31,436,80,277,40,436,467,1771,94,1771,302,1129,33,67,80,631,94,1771,668,2557,59,277,302,2557,156,1129,530,2017,35,16,23,67,31,436,80,277,40,436,467,1771,94,1771,302,1129,50", "code": "\nfrom sympy import prime, factorint\nimport math\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef A(n): return n - 2**int(math.floor(math.log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a005940(n): return b(n - 1)\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a278222(n): return a046523(a005940(n + 1))\ndef a001511(n): return bin(n)[2:][::-1].index(\"1\") + 1\ndef a(n): return T(a001511(n), a278222(n)) \n"}
{"sequence_id": "A286163", "text": "Compound filter: a(n) = T(A046523(n), A278222(n)), where T(n,k) is sequence A000027 used as a pairing function.", "sequence": "2,5,12,14,23,42,38,44,40,61,80,117,80,84,216,152,23,148,80,148,601,142,302,375,109,142,911,183,302,1020,530,560,61,61,142,856,467,142,412,430,467,1741,1832,265,2497,412,1178,1323,109,265,826,265,1832,1735,2932,489,412,412,2630,2835,1178,672,2787,2144,61,625,80,148,601,850,302,2998,467,601", "code": "\nfrom sympy import prime, factorint\nimport math\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef A(n): return n - 2**int(math.floor(math.log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a005940(n): return b(n - 1)\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a278222(n): return a046523(a005940(n + 1))\ndef a(n): return T(a046523(n), a278222(n)) \n"}
{"sequence_id": "A286164", "text": "Compound filter: a(n) = T(A055396(n), A046523(n)), where T(n,k) is sequence A000027 used as a pairing function.", "sequence": "0,2,5,7,9,16,14,29,12,16,20,67,27,16,23,121,35,67,44,67,23,16,54,277,18,16,38,67,65,436,77,497,23,16,31,631,90,16,23,277,104,436,119,67,80,16,135,1129,25,67,23,67,152,277,31,277,23,16,170,1771,189,16,80,2017,31,436,209,67,23,436,230,2557,252,16,80,67,40,436,275,1129,138,16,299", "code": "\nfrom sympy import primepi, isprime, primefactors, factorint\ndef a049084(n): return primepi(n)*(1*isprime(n))\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(a055396(n), a046523(n)) \n"}
{"sequence_id": "A286193", "text": "Decimal expansion of Sum_{n>=1} 1/(n^n+n).", "sequence": "7,0,4,1,8,8,3,4,9,9,2,3,3,1,4,7,1,8,1,7,1,2,6,2,0,0,0,4,4,2,2,1,8,5,7,8,0,3,0,4,1,5,8,5,3,7,7,2,9,0,9,4,4,5,0,7,4,2,2,2,3,4,0,3,8,6,1,3,9,0,6,9,3,8,2,4,0,7,7,6,1,5,5,9,0,4,5,6,8,5,6,2,3,5,3,0,5,6", "code": " from decimal import *;getcontext().prec=300;print sum([Decimal(1)/Decimal(n**n+n)for n in range(1,200)])\n"}
{"sequence_id": "A286234", "text": "Square array A(n,k) = P(A000010(k), floor((n+k-1)/k)), read by descending antidiagonals as A(1,1), A(1,2), A(2,1), etc. Here P is a two-argument form of sequence A000027 used as a pairing function N x N -> N.", "sequence": "1,1,2,3,1,4,3,3,2,7,10,3,3,2,11,3,10,3,5,4,16,21,3,10,3,5,4,22,10,21,3,10,5,5,7,29,21,10,21,3,10,5,8,7,37,10,21,10,21,3,14,5,8,11,46,55,10,21,10,21,3,14,5,8,11,56,10,55,10,21,10,21,5,14,8,12,16,67,78,10,55,10,21,10,21,5,14,8,12,16,79,21,78,10,55,10,21,10,27,5,14,8,12,22,92", "code": "\nfrom sympy import totient\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef t(n, k): return T(totient(k), int(n/k))\nfor n in range(1, 21): print [t(n, k) for k in range(1, n + 1)][::-1] \n"}
{"sequence_id": "A286235", "text": "Triangular table T(n,k) = P(phi(k), floor(n/k)), where P is sequence A000027 used as a pairing function N x N -> N, and phi is Euler totient function, A000010. Table is read by rows as T(1,1), T(2,1), T(2,2), etc.", "sequence": "1,2,1,4,1,3,7,2,3,3,11,2,3,3,10,16,4,5,3,10,3,22,4,5,3,10,3,21,29,7,5,5,10,3,21,10,37,7,8,5,10,3,21,10,21,46,11,8,5,14,3,21,10,21,10,56,11,8,5,14,3,21,10,21,10,55,67,16,12,8,14,5,21,10,21,10,55,10,79,16,12,8,14,5,21,10,21,10,55,10,78,92,22,12,8,14,5,27,10,21,10,55,10,78,21", "code": "\nfrom sympy import totient\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef t(n, k): return T(totient(k), int(n/k))\nfor n in range(1, 21): print [t(n, k) for k in range(1, n + 1)] \n"}
{"sequence_id": "A286236", "text": "Square array A(n,k) = P(A000010(k), (n+k-1)/k) if k divides (n+k-1), 0 otherwise, read by descending antidiagonals as A(1,1), A(1,2), A(2,1), etc. Here P is a two-argument form of sequence A000027 used as a pairing function N x N -> N.", "sequence": "1,1,2,3,0,4,3,0,2,7,10,0,0,0,11,3,0,0,5,4,16,21,0,0,0,0,0,22,10,0,0,0,5,0,7,29,21,0,0,0,0,0,8,0,37,10,0,0,0,0,14,0,0,11,46,55,0,0,0,0,0,0,0,0,0,56,10,0,0,0,0,0,5,0,8,12,16,67,78,0,0,0,0,0,0,0,0,0,0,0,79,21,0,0,0,0,0,0,27,0,0,0,0,22,92,36,0,0,0,0,0,0,0,0,0,19,0,17,0,106", "code": "\nfrom sympy import totient\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef t(n, k): return 0 if n%k!=0 else T(totient(k), n/k)\nfor n in range(1, 21): print [t(n, k) for k in range(1, n + 1)][::-1] \n"}
{"sequence_id": "A286237", "text": "Triangular table: T(n,k) = 0 if k does not divide n, otherwise T(n,k) = P(phi(k), n/k), where P is sequence A000027 used as a pairing function N x N -> N, and phi is Euler totient function, A000010. Table is read by rows as T(1,1), T(2,1), T(2,2), etc.", "sequence": "1,2,1,4,0,3,7,2,0,3,11,0,0,0,10,16,4,5,0,0,3,22,0,0,0,0,0,21,29,7,0,5,0,0,0,10,37,0,8,0,0,0,0,0,21,46,11,0,0,14,0,0,0,0,10,56,0,0,0,0,0,0,0,0,0,55,67,16,12,8,0,5,0,0,0,0,0,10,79,0,0,0,0,0,0,0,0,0,0,0,78,92,22,0,0,0,0,27,0,0,0,0,0,0,21,106,0,17,0,19,0,0,0,0,0,0,0,0,0,36", "code": "\nfrom sympy import totient\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef t(n, k): return 0 if n%k!=0 else T(totient(k), n/k)\nfor n in range(1, 21): print [t(n, k) for k in range(1, n + 1)] \n"}
{"sequence_id": "A286238", "text": "Triangle A286239 reversed.", "sequence": "1,2,1,4,0,3,7,0,2,3,11,0,0,0,10,16,0,0,4,5,3,22,0,0,0,0,0,21,29,0,0,0,7,0,5,10,37,0,0,0,0,0,8,0,21,46,0,0,0,0,11,0,0,14,10,56,0,0,0,0,0,0,0,0,0,55,67,0,0,0,0,0,16,0,12,8,5,10,79,0,0,0,0,0,0,0,0,0,0,0,78,92,0,0,0,0,0,0,22,0,0,0,0,27,21,106,0,0,0,0,0,0,0,0,0,17,0,19,0,36", "code": "\nfrom sympy import totient\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef t(n, k): return 0 if n%k!=0 else T(totient(n/k), k)\nfor n in range(1, 21): print [t(n, k) for k in range(1, n + 1)][::-1] \n"}
{"sequence_id": "A286239", "text": "Triangular table: T(n,k) = 0 if k does not divide n, otherwise T(n,k) = P(A000010(n/k), k), where P is sequence A000027 used as a pairing function N x N -> N. Table is read by rows as T(1,1), T(2,1), T(2,2), etc.", "sequence": "1,1,2,3,0,4,3,2,0,7,10,0,0,0,11,3,5,4,0,0,16,21,0,0,0,0,0,22,10,5,0,7,0,0,0,29,21,0,8,0,0,0,0,0,37,10,14,0,0,11,0,0,0,0,46,55,0,0,0,0,0,0,0,0,0,56,10,5,8,12,0,16,0,0,0,0,0,67,78,0,0,0,0,0,0,0,0,0,0,0,79,21,27,0,0,0,0,22,0,0,0,0,0,0,92,36,0,19,0,17,0,0,0,0,0,0,0,0,0,106", "code": "\nfrom sympy import totient\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef t(n, k): return 0 if n%k!=0 else T(totient(n/k), k)\nfor n in range(1, 21): print [t(n, k) for k in range(1, n + 1)] \n"}
{"sequence_id": "A286240", "text": "Compound filter: a(n) = P(A278222(n), A278222(1+n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "2,5,12,14,23,42,59,44,23,61,142,117,109,183,261,152,23,61,142,148,601,850,607,375,109,265,1093,939,473,765,1097,560,23,61,142,148,601,850,607,430,601,1741,3946,2545,2497,3463,2509,1323,109,265,1093,1117,2497,4525,5707,3153,473,1105,4489,3813,1969,3129,4497,2144,23,61,142,148,601,850,607,430,601,1741", "code": "\nfrom sympy import prime, factorint\nimport math\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef A(n): return n - 2**int(math.floor(math.log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a005940(n): return b(n - 1)\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a278222(n): return a046523(a005940(n + 1))\ndef a(n): return T(a278222(n), a278222(n + 1)) \n"}
{"sequence_id": "A286241", "text": "Compound filter: a(n) = P(A278219(n), A278219(1+n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "2,12,14,12,59,86,27,12,109,363,269,86,142,148,27,12,109,1093,1117,363,1097,1517,489,86,601,1408,619,148,142,148,27,12,109,1093,1117,1093,5707,8587,2545,363,1969,6153,4529,1517,4489,4537,489,86,601,3946,3976,1408,2509,5719,2545,148,601,1408,619,148,142,148,27,12,109,1093,1117,1093,5707,8587", "code": "\nfrom sympy import prime, factorint\nimport math\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef A(n): return n - 2**int(math.floor(math.log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a005940(n): return b(n - 1)\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a003188(n): return n^int(n/2)\ndef a243353(n): return a005940(1 + a003188(n))\ndef a278219(n): return a046523(a243353(n))\ndef a(n): return T(a278219(n), a278219(n + 1)) \n"}
{"sequence_id": "A286242", "text": "Compound filter: a(n) = P(A278222(n), A278219(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,5,12,14,12,84,40,44,12,142,216,183,40,265,86,152,12,142,826,265,216,1860,607,489,40,832,607,1117,86,619,226,560,12,142,826,265,826,5080,2497,619,216,2956,4308,4155,607,8575,1105,1533,40,832,2497,2116,607,5731,4501,3475,86,1402,1105,3475,226,1759,698,2144,12,142,826,265,826,5080,2497,619,826", "code": "\nfrom sympy import prime, factorint\nimport math\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef A(n): return n - 2**int(math.floor(math.log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a005940(n): return b(n - 1)\ndef P(n):\n    f=factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a003188(n): return n^(n>>1)\ndef a243353(n): return a005940(1 + a003188(n))\ndef a278219(n): return a046523(a243353(n))\ndef a278222(n): return a046523(a005940(n + 1))\ndef a(n): return T(a278222(n), a278219(n)) \n"}
{"sequence_id": "A286244", "text": "Square array A(n,k) = P(A046523(k), floor((n+k-1)/k)), read by descending antidiagonals as A(1,1), A(1,2), A(2,1), etc. Here P is a two-argument form of sequence A000027 used as a pairing function N x N -> N.", "sequence": "1,3,2,3,3,4,10,3,5,7,3,10,3,5,11,21,3,10,5,8,16,3,21,3,10,5,8,22,36,3,21,3,14,5,12,29,10,36,3,21,3,14,8,12,37,21,10,36,3,21,5,14,8,17,46,3,21,10,36,3,21,5,14,8,17,56,78,3,21,10,36,3,27,5,19,12,23,67,3,78,3,21,10,36,3,27,5,19,12,23,79", "code": "\nfrom sympy import factorint\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef A(n, k): return T(a046523(k), int((n + k - 1)/k))\nfor n in range(1, 21): print [A(k, n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A286245", "text": "Triangular table T(n,k) = P(A046523(k), floor(n/k)), read by rows as T(1,1), T(2,1), T(2,2), etc. Here P is sequence A000027 used as a pairing function N x N -> N.", "sequence": "1,2,3,4,3,3,7,5,3,10,11,5,3,10,3,16,8,5,10,3,21,22,8,5,10,3,21,3,29,12,5,14,3,21,3,36,37,12,8,14,3,21,3,36,10,46,17,8,14,5,21,3,36,10,21,56,17,8,14,5,21,3,36,10,21,3,67,23,12,19,5,27,3,36,10,21,3,78,79,23,12,19,5,27,3,36,10,21,3,78,3", "code": "\nfrom sympy import factorint\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef t(n, k): return T(a046523(k), int(n/k))\nfor n in range(1, 21): print [t(n, k) for k in range(1, n + 1)] \n"}
{"sequence_id": "A286246", "text": "Square array A(n,k) = P(A046523(k), (n+k-1)/k) if k divides (n+k-1), 0 otherwise, read by descending antidiagonals as A(1,1), A(1,2), A(2,1), etc. Here P is a two-argument form of sequence A000027 used as a pairing function N x N -> N.", "sequence": "1,3,2,3,0,4,10,0,5,7,3,0,0,0,11,21,0,0,5,8,16,3,0,0,0,0,0,22,36,0,0,0,14,0,12,29,10,0,0,0,0,0,8,0,37,21,0,0,0,0,5,0,0,17,46,3,0,0,0,0,0,0,0,0,0,56,78,0,0,0,0,0,27,0,19,12,23,67,3,0,0,0,0,0,0,0,0,0,0,0,79,21,0,0,0,0,0,0,5,0,0,0,0,30,92,21,0,0,0,0,0,0,0,0,0,8,0,17,0,106", "code": "\nfrom sympy import factorint\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef A(n, k): return 0 if (n + k - 1)%k!=0 else T(a046523(k), (n + k - 1)/k)\nfor n in range(1, 21): print [A(k, n - k + 1) for k in range(1, n + 1)] \n"}
{"sequence_id": "A286247", "text": "Triangular table: T(n,k) = 0 if k does not divide n, otherwise T(n,k) = P(A046523(k), n/k), where P is sequence A000027 used as a pairing function N x N -> N. Table is read by rows as T(1,1), T(2,1), T(2,2), etc.", "sequence": "1,2,3,4,0,3,7,5,0,10,11,0,0,0,3,16,8,5,0,0,21,22,0,0,0,0,0,3,29,12,0,14,0,0,0,36,37,0,8,0,0,0,0,0,10,46,17,0,0,5,0,0,0,0,21,56,0,0,0,0,0,0,0,0,0,3,67,23,12,19,0,27,0,0,0,0,0,78,79,0,0,0,0,0,0,0,0,0,0,0,3,92,30,0,0,0,0,5,0,0,0,0,0,0,21,106,0,17,0,8,0,0,0,0,0,0,0,0,0,21", "code": "\nfrom sympy import factorint\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef t(n, k): return 0 if n%k!=0 else T(a046523(k), n/k)\nfor n in range(1, 21): print [t(n, k) for k in range(1, n + 1)] \n"}
{"sequence_id": "A286248", "text": "Triangle A286249 reversed.", "sequence": "1,2,3,4,0,3,7,0,5,10,11,0,0,0,3,16,0,0,8,5,21,22,0,0,0,0,0,3,29,0,0,0,12,0,14,36,37,0,0,0,0,0,8,0,10,46,0,0,0,0,17,0,0,5,21,56,0,0,0,0,0,0,0,0,0,3,67,0,0,0,0,0,23,0,12,19,27,78,79,0,0,0,0,0,0,0,0,0,0,0,3,92,0,0,0,0,0,0,30,0,0,0,0,5,21,106,0,0,0,0,0,0,0,0,0,17,0,8,0,21", "code": "\nfrom sympy import factorint\nimport math\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef t(n, k): return 0 if n%k!=0 else T(a046523(n/k), k)\nfor n in range(1, 21): print [t(n, k) for k in range(1, n + 1)][::-1] \n"}
{"sequence_id": "A286249", "text": "Triangular table: T(n,k) = 0 if k does not divide n, otherwise T(n,k) = P(A046523(n/k), k), where P is sequence A000027 used as a pairing function N x N -> N. Table is read by rows as T(1,1), T(2,1), T(2,2), etc.", "sequence": "1,3,2,3,0,4,10,5,0,7,3,0,0,0,11,21,5,8,0,0,16,3,0,0,0,0,0,22,36,14,0,12,0,0,0,29,10,0,8,0,0,0,0,0,37,21,5,0,0,17,0,0,0,0,46,3,0,0,0,0,0,0,0,0,0,56,78,27,19,12,0,23,0,0,0,0,0,67,3,0,0,0,0,0,0,0,0,0,0,0,79,21,5,0,0,0,0,30,0,0,0,0,0,0,92,21,0,8,0,17,0,0,0,0,0,0,0,0,0,106", "code": "\nfrom sympy import factorint\nimport math\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef t(n, k): return 0 if n%k!=0 else T(a046523(n/k), k)\nfor n in range(1, 21): print [t(n, k) for k in range(1, n + 1)] \n"}
{"sequence_id": "A286250", "text": "Filter-sequence: a(n) = A278223(A064216(n)) = A046523((2*A064216(n))-1).", "sequence": "1,2,2,4,2,2,6,2,4,6,2,2,2,6,12,6,8,2,2,2,2,16,2,6,4,6,6,2,2,30,12,6,6,4,12,6,6,6,6,6,2,2,6,6,30,2,6,2,6,6,2,6,2,6,6,6,6,2,6,6,2,12,2,36,2,6,4,2,12,30,12,12,2,12,2,24,2,2,6,6,24,2,2,12,2,24,12,2,2,30,30,6,6,2,2,4,6,2,30,6,32,2,6,2,6,2,6,12,4,2,30,2,2", "code": "\nfrom sympy import factorint, prevprime\nfrom operator import mul\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a064216(n):\n    f=factorint(2*n - 1)\n    return 1 if n==1 else reduce(mul, [prevprime(i)**f[i] for i in f])\ndef a(n): return a046523((2*a064216(n)) - 1) \n"}
{"sequence_id": "A286251", "text": "Compound filter: a(n) = P(A001511(1+n), A046523(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "3,2,9,7,5,16,14,29,12,16,9,67,5,16,50,121,5,67,9,67,23,16,14,277,12,16,48,67,5,436,27,497,23,16,31,631,5,16,40,277,5,436,9,67,80,16,20,1129,12,67,31,67,5,277,40,277,23,16,9,1771,5,16,160,2017,23,436,9,67,23,436,14,2557,5,16,94,67,23,436,20,1129,138,16,9,1771,23,16,40,277,5", "code": "\nfrom sympy import factorint\ndef a001511(n): return 2 + bin(n - 1)[2:].count(\"1\") - bin(n)[2:].count(\"1\")\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(a001511(n + 1), a046523(n)) \n"}
{"sequence_id": "A286252", "text": "Compound filter: a(n) = P(A001511(1+n), A278222(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,5,2,18,2,23,7,59,2,23,16,94,7,80,29,195,2,23,16,94,16,467,67,355,7,80,67,706,29,302,121,672,2,23,16,94,16,467,67,355,16,467,436,1894,67,1832,277,1331,7,80,67,706,67,1832,631,2779,29,302,277,2704,121,1178,497,2422,2,23,16,94,16,467,67,355,16,467,436,1894,67,1832,277,1331,16,467,436", "code": "\nfrom sympy import prime, factorint\nimport math\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef A(n): return n - 2**int(math.floor(math.log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a005940(n): return b(n - 1)\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a278222(n): return a046523(a005940(n + 1))\ndef a001511(n): return 2 + bin(n - 1)[2:].count(\"1\") - bin(n)[2:].count(\"1\")\ndef a(n): return T(a001511(n + 1), a278222(n)) \n"}
{"sequence_id": "A286253", "text": "Compound filter: a(n) = P(A055396(n), A001511(1+n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "0,1,8,1,9,1,25,1,5,1,26,1,27,1,17,1,35,1,53,1,5,1,75,1,9,1,8,1,65,1,131,1,5,1,13,1,90,1,12,1,104,1,134,1,5,1,186,1,14,1,8,1,152,1,18,1,5,1,188,1,189,1,30,1,9,1,229,1,5,1,273,1,252,1,8,1,14,1,347,1,5,1,323,1,9,1,12,1,324,1,19,1,5,1,31,1,350,1,8,1,377,1,462,1,5", "code": "\nfrom sympy import primepi, isprime, primefactors\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a049084(n): return primepi(n)*(1*isprime(n))\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef a001511(n): return 2 + bin(n - 1)[2:].count(\"1\") - bin(n)[2:].count(\"1\")\ndef a(n): return T(a055396(n), a001511(n + 1)) \n"}
{"sequence_id": "A286254", "text": "Compound filter: a(n) = P(A001511(n), A055396(1+n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,5,1,13,1,12,1,14,1,17,1,31,1,5,1,60,1,38,1,9,1,47,1,19,1,5,1,69,1,68,1,27,1,8,1,94,1,5,1,124,1,107,1,9,1,122,1,33,1,5,1,156,1,8,1,14,1,155,1,193,1,5,1,43,1,192,1,9,1,212,1,280,1,5,1,18,1,255,1,20,1,278,1,13,1,5,1,355,1,12,1,9,1,8,1,441,1,5,1,381,1,380,1,14", "code": "\nfrom sympy import primepi, isprime, primefactors\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a049084(n): return primepi(n)*(1*isprime(n))\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef a001511(n): return 2 + bin(n - 1)[2:].count(\"1\") - bin(n)[2:].count(\"1\")\ndef a(n): return T(a001511(n), a055396(n + 1)) \n"}
{"sequence_id": "A286255", "text": "Compound filter: a(n) = P(A046523(n), A046523(1+n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "2,5,12,14,23,27,38,63,40,27,80,90,23,61,216,152,80,90,80,148,61,27,302,375,40,84,179,90,467,495,530,698,61,61,826,702,23,61,412,324,467,495,80,265,148,27,1178,1323,109,148,142,90,302,430,412,430,61,27,1832,1890,23,142,2787,2410,601,495,80,148,601,495,2630,2700,23,142,265,148,601,495,1178", "code": "\nfrom sympy import factorint\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(a046523(n), a046523(n + 1)) \n"}
{"sequence_id": "A286256", "text": "Compound filter: a(n) = P(A046523(n), A046523(2+n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "2,12,5,40,5,84,12,86,14,142,5,148,23,216,27,367,5,265,23,148,27,412,12,430,59,142,44,832,5,1860,23,698,61,826,27,856,23,412,27,1402,5,850,80,148,90,1384,12,1759,40,265,27,607,23,1105,61,430,27,2086,5,2140,80,2352,148,4342,27,850,23,832,27,5080,5,2998,80,142,148,832,27,2956,138,1426", "code": "\nfrom sympy import factorint\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(a046523(n), a046523(n + 2)) \n"}
{"sequence_id": "A286257", "text": "Compound filter: a(n) = P(A046523(n), A046523(2n-1)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,5,5,14,12,27,5,86,14,27,23,90,12,84,27,152,23,148,5,148,27,27,80,324,25,61,44,148,23,495,5,935,61,27,61,702,5,142,61,324,138,495,23,148,90,61,23,1426,14,265,27,90,467,324,27,430,27,61,80,2140,12,61,183,2144,61,495,23,607,27,495,23,2998,23,142,90,90,142,625,5,1426,226,27,467", "code": "\nfrom sympy import factorint\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(a046523(n), a046523(2*n - 1)) \n"}
{"sequence_id": "A286258", "text": "Compound filter: a(n) = P(A046523(n), A046523(2n+1)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "2,5,5,25,5,27,23,44,14,61,5,117,38,27,27,226,23,90,23,90,27,142,5,375,40,27,86,148,5,495,80,698,27,61,27,702,80,61,27,765,5,625,23,90,148,61,23,1224,109,90,27,832,5,324,61,324,61,142,23,2013,23,84,90,2410,27,625,302,90,27,625,23,2998,80,27,90,265,61,495,23,1426,152,601,5,2013,142,27,142", "code": "\nfrom sympy import factorint\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(a046523(n), a046523(2*n + 1)) \n"}
{"sequence_id": "A286259", "text": "Compound filter: a(n) = P(A001511(n), A049820(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,2,1,6,4,5,11,25,16,23,37,31,56,57,56,110,106,80,137,123,137,173,211,175,232,255,254,279,352,255,407,471,407,467,466,409,596,597,596,599,742,597,821,783,742,905,991,866,1036,992,1082,1131,1276,1083,1276,1279,1379,1487,1597,1228,1712,1713,1597,1960,1831,1713,2081,2019,2081,1955,2347,1957", "code": "\nfrom sympy import divisor_count as d\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a001511(n): return 2 + bin(n - 1)[2:].count(\"1\") - bin(n)[2:].count(\"1\")\ndef a(n): return T(a001511(n), n - d(n)) \n"}
{"sequence_id": "A286260", "text": "Compound filter: a(n) = P(A001511(n), A161942(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,8,1,39,4,8,1,157,79,47,4,39,22,8,4,600,37,782,11,256,1,47,4,157,466,233,11,39,106,47,1,2284,4,380,4,4281,172,122,22,1132,211,8,56,256,742,47,4,600,1597,4373,37,1278,352,122,37,157,11,1037,106,256,466,8,79,8785,211,47,137,2083,4,47,37,19507,667,1655,466,669,4,233,11,4661,7261", "code": "\nfrom sympy import factorint, divisors, divisor_sigma\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a000265(n): return max(list(filter(lambda i: i%2 == 1, divisors(n))))\ndef a161942(n): return a000265(divisor_sigma(n))\ndef a001511(n): return 2 + bin(n - 1)[2:].count(\"1\") - bin(n)[2:].count(\"1\")\ndef a(n): return T(a001511(n), a161942(n)) \n"}
{"sequence_id": "A286261", "text": "Numbers whose binary expansion is not a cubefree string.", "sequence": "7,8,14,15,16,17,23,24,28,29,30,31,32,33,34,35,39,40,42,46,47,48,49,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,78,79,80,81,84,85,87,88,92,93,94,95,96,97,98,99,103,104,106,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130", "code": "\nfrom __future__ import division\ndef is_cubefree(s):\n    l = len(s)\n    for i in range(l-2):\n        for j in range(1,(l-i)//3+1):\n            if s[i:i+2*j] == s[i+j:i+3*j]:\n                return False\n    return True\nA286261_list = [n for n in range(10**4) if not is_cubefree(bin(n)[2:])] \n"}
{"sequence_id": "A286262", "text": "Numbers whose binary expansion is a cubefree string.", "sequence": "0,1,2,3,4,5,6,9,10,11,12,13,18,19,20,21,22,25,26,27,36,37,38,41,43,44,45,50,51,52,53,54,73,74,75,76,77,82,83,86,89,90,91,100,101,102,105,107,108,109,146,147,148,150,153,154,155,164,165,166,172,173,178,179,180,181,182", "code": "\nfrom __future__ import division\ndef is_cubefree(s):\n    l = len(s)\n    for i in range(l-2):\n        for j in range(1,(l-i)//3+1):\n            if s[i:i+2*j] == s[i+j:i+3*j]:\n                return False\n    return True\nA286262_list = [n for n in range(10**4) if is_cubefree(bin(n)[2:])] \n"}
{"sequence_id": "A286265", "text": "Totient abundant numbers: numbers k such that A092693(k) > k.", "sequence": "5,7,11,13,17,19,23,25,29,31,33,35,37,41,43,47,49,51,53,55,59,61,65,67,69,71,73,77,79,83,85,87,89,91,95,97,101,103,107,109,113,115,119,121,123,125,127,131,133,137,139,141,143,145,149,151,153,155,157", "code": "\nfrom sympy import totient\ndef a092693(n): return 0 if n==1 else totient(n) + a092693(totient(n))\nprint([n for n in range(1, 201) if a092693(n) > n]) \n"}
{"sequence_id": "A286282", "text": "Stage at which Ken Knowlton's elevator (version 2) reaches floor n for the first time.", "sequence": "1,2,5,18,79,408,2469,17314,138555,1247052,12470593,137176614,1646119479,21399553360,299593747197,4493906208138,71902499330419,1222342488617364,22002164795112825,418041131107143982,8360822622142879983,175577275065000480024,3862700051430010560949", "code": "\ntimes = {1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1, 15: 1, 16: 1}\nfirst = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0, 14: 0, 15: 0, 16: 0}\nfloor = 1\nsteps = 1\nwhile floor < 17:\n....if first[floor] == 0:\n........first[floor] = 1\n........print(\"First Time: \",floor,steps)\n....if floor == 1:\n........floor += 1\n....else:\n........if times[floor] < floor:\n............times[floor] += 1\n............floor -= 1\n........else:\n............times[floor] = 0\n............floor += 1\n....steps += 1\nprint(floor, steps)\n\n"}
{"sequence_id": "A286298", "text": "a(0) = 0, a(1) = 1; thereafter, a(2n) = a(n) + 1 + (n mod 2), a(2n+1) = a(n) + 2 - (n mod 2).", "sequence": "0,1,3,2,4,5,4,3,5,6,7,6,5,6,5,4,6,7,8,7,8,9,8,7,6,7,8,7,6,7,6,5,7,8,9,8,9,10,9,8,9,10,11,10,9,10,9,8,7,8,9,8,9,10,9,8,7,8,9,8,7,8,7,6,8,9,10,9,10,11,10,9,10,11,12,11,10,11,10,9,10,11,12,11,12,13,12,11,10,11,12", "code": "\ndef A286298(n):\n    if n <= 1:\n        return n\n    a, b = divmod(n, 2)\n    return A286298(a) + 1 + b + (-1)**b*(a % 2) \n"}
{"sequence_id": "A286308", "text": "Numbers m such that gcd(m, F(m)) = 2, where F(m) denotes the m-th Fibonacci number.", "sequence": "6,18,42,54,66,78,102,114,126,138,162,174,186,198,222,234,246,258,282,294,318,354,366,378,402,414,426,438,462,474,486,498,522,534,558,582,594,606,618,642,654,666,678,702,714,726,738,762,774,786,798,822,834,846,858", "code": "\nfrom sympy import fibonacci, gcd\n[n for n in range(1001) if gcd(n, fibonacci(n)) == 2] \n"}
{"sequence_id": "A286328", "text": "Least integer k such that the area of the triangle (prime(n), k, k+1) is integer.", "sequence": "4,3,24,60,14,9,180,264,20,480,19,84,924,1104,51,1740,155,2244,2520,2664,3120,3444,99,51,51,5304,5724,65,399,8064,8580,9384,9660,221,11400,12324,13284,13944,14964,16020,819,18240,194,99,19800,22260,24864,25764,26220", "code": "\nfrom __future__ import division\nfrom sympy import prime\nfrom gmpy2 import is_square\ndef A286328(n): \n    p, area = prime(n), 0\n    k, q, kq = (p + 1)//2, (p**2 - 1)//2, (p - 1)*(p + 1)**2//4\n    while True:\n        area += kq\n        if is_square(area):\n            return k\n        k += 1\n        kq += q \n"}
{"sequence_id": "A286333", "text": "Primes p where all the cyclic shifts of their digits to the left also produce primes except the last one before reaching p again.", "sequence": "19,23,29,41,43,47,53,59,61,67,83,89,101,103,107,127,149,157,163,181,191,307,317,331,359,367,701,709,727,739,757,761,787,797,907,937,941,947,983,1103,1109,1123,1181,1301,1319,1327,1949,1951,1979,1987,1993,3121,3187,3361,3373,3701", "code": "\nfrom itertools import product\nfrom sympy import isprime\nA286333_list = []\nfor l in range(14):\n    for w in product('1379',repeat=l):\n        for d in '0123456789':\n            for t in '1379':\n                s = ''.join(w)+d+t\n                n = int(s)\n                for i in range(l+1):\n                    if not isprime(int(s)):\n                        break\n                    s = s[1:]+s[0]\n                else:\n                    if n > 10 and not isprime(int(s)):\n                        A286333_list.append(n) \n"}
{"sequence_id": "A286334", "text": "The smallest number a such that there exists an integer b such that a/b is equal to n% rounded to the nearest percent.", "sequence": "0,1,1,1,1,1,1,1,1,1,1,1,2,1,1,2,3,1,2,3,1,3,2,3,4,1,5,3,5,2,3,4,6,1,10,6,4,7,3,7,2,7,5,3,4,5,6,7,10,17,1,18,11,8,7,6,5,4,7,10,3,11,8,5,7,11,19,2,13,9,7,5,13,8,14,3,13,10,7,11,4,13,9,5,16,11,6,13,7,8,9,10,11,13,15,18,22,28,39,66,1", "code": " \nfrom __future__ import division\nfrom math import floor\nleast = [None] * 101\ni = 1\nwhile None in least.values():\n....for j in range(i+1):\n........p = int(floor(100*j/i+.5))\n........if least[p] is None:\n............least[p] = j\n....i += 1\nprint(least)\n"}
{"sequence_id": "A286356", "text": "Compound filter: a(n) = P(A061395(n), A046523(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "0,2,5,7,9,23,14,29,12,31,20,80,27,40,31,121,35,80,44,94,40,50,54,302,18,61,38,109,65,499,77,497,50,73,40,668,90,86,61,328,104,532,119,125,94,100,135,1178,25,94,73,142,152,302,50,355,86,115,170,1894,189,131,109,2017,61,566,209,160,100,532,230,2630,252,148,94,179,50,601,275,1228,138", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a061395(n): return 0 if n == 1 else primepi(max(primefactors(n)))\ndef a(n): return T(a061395(n), a046523(n)) \n"}
{"sequence_id": "A286357", "text": "One more than the exponent of the highest power of 2 dividing sigma(n): a(n) = A001511(A000203(n)).", "sequence": "1,1,3,1,2,3,4,1,1,2,3,3,2,4,4,1,2,1,3,2,6,3,4,3,1,2,4,4,2,4,6,1,5,2,5,1,2,3,4,2,2,6,3,3,2,4,5,3,1,1,4,2,2,4,4,4,5,2,3,4,2,6,4,1,3,5,3,2,6,5,4,1,2,2,3,3,6,4,5,2,1,2,3,6,3,3,4,3,2,2,5,4,8,5,4,3,2,1,3,1,2,4,4,2,7,2,3,4,2,4,4,4,2,5,5,2,2,3,5,4", "code": "\nfrom sympy import divisor_sigma as D\ndef a001511(n): return bin(n)[2:][::-1].index(\"1\") + 1\ndef a(n): return a001511(D(n)) \n"}
{"sequence_id": "A286359", "text": "Compound filter: a(n) = P(sigma(n), sigma(2n)), where P(n,k) is sequence A000027 used as a pairing function, and sigma is the sum of divisors (A000203).", "sequence": "4,39,109,217,259,753,473,1005,1288,1729,1093,3769,1499,3105,4489,4309,2503,8295,3101,8557,8033,7057,4489,16713,7534,9633,12601,15281,7051,28513,8033,17829,18193,15985,18193,40561,11363,19761,24809,37765,13903,50817,15269,34537,48283,28513,18193,70249,25708,47679,41113,47069,23059,79521,41113,67281,50801", "code": "\nfrom sympy import divisor_sigma as D\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a(n): return T(D(n), D(2*n)) \n"}
{"sequence_id": "A286360", "text": "Compound filter (prime signature & sum of the divisors): a(n) = P(A046523(n), A000203(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,8,12,49,23,142,38,239,124,259,80,753,107,412,412,1051,173,1237,212,1390,672,826,302,3427,565,1087,1089,2223,467,5080,530,4403,1384,1717,1384,7911,743,2086,1836,6352,905,7780,992,4477,3928,2932,1178,14583,1774,5368,2932,5898,1487,10177,2932,10177,3576,4471,1832,25711,1955,5056,6567,18019,3922", "code": "\nfrom sympy import factorint, divisor_sigma as D\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(a046523(n), D(n)) \n"}
{"sequence_id": "A286361", "text": "Least number with the same prime signature as {the largest divisor of n with only prime factors of the form 4k+1} has: a(n) = A046523(A170818(n)).", "sequence": "1,1,1,1,2,1,1,1,1,2,1,1,2,1,2,1,2,1,1,2,1,1,1,1,4,2,1,1,2,2,1,1,1,2,2,1,2,1,2,2,2,1,1,1,2,1,1,1,1,4,2,2,2,1,2,1,1,2,1,2,2,1,1,1,6,1,1,2,1,2,1,1,2,2,4,1,1,2,1,2,1,2,1,1,6,1,2,1,2,2,2,1,1,1,2,1,2,1,1,4,2,2,1,2,2,2,1,1,2,2,2,1,2,1,2,2,2,1,2,2", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a072438(n):\n    f = factorint(n)\n    return 1 if n == 1 else reduce(mul, [1 if i%4==1 else i**f[i] for i in f])\ndef a(n): return a046523(n/a072438(n)) \n"}
{"sequence_id": "A286363", "text": "Least number with the same prime signature as {the largest divisor of n with only prime factors of the form 4k+3} has: a(n) = A046523(A097706(n)).", "sequence": "1,1,2,1,1,2,2,1,4,1,2,2,1,2,2,1,1,4,2,1,6,2,2,2,1,1,8,2,1,2,2,1,6,1,2,4,1,2,2,1,1,6,2,2,4,2,2,2,4,1,2,1,1,8,2,2,6,1,2,2,1,2,12,1,1,6,2,1,6,2,2,4,1,1,2,2,6,2,2,1,16,1,2,6,1,2,2,2,1,4,2,2,6,2,2,2,1,4,12,1,1,2,2,1,6,1,2,8,1,2,2,2,1,6,2,1,4,2,2,2", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a072436(n):\n    f = factorint(n)\n    return 1 if n == 1 else reduce(mul, [1 if i%4==3 else i**f[i] for i in f])\ndef a(n): return a046523(n/a072436(n)) \n"}
{"sequence_id": "A286364", "text": "Compound filter: a(n) = P(A286361(n), A286363(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,1,2,1,3,2,2,1,7,3,2,2,3,2,5,1,3,7,2,3,16,2,2,2,10,3,29,2,3,5,2,1,16,3,5,7,3,2,5,3,3,16,2,2,12,2,2,2,7,10,5,3,3,29,5,2,16,3,2,5,3,2,67,1,21,16,2,3,16,5,2,7,3,3,14,2,16,5,2,3,121,3,2,16,21,2,5,2,3,12,5,2,16,2,5,2,3,7,67,10,3,5,2,3,23,3,2,29,3,5,5,2,3", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef A(n, k):\n    f = factorint(n)\n    return 1 if n == 1 else reduce(mul, [1 if i%4==k else i**f[i] for i in f])\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a(n): return T(a046523(n/A(n, 1)), a046523(n/A(n, 3))) \n"}
{"sequence_id": "A286365", "text": "Compound filter: a(n) = 2*A286364(n) + A000035(A007814(n)).", "sequence": "2,3,4,2,6,5,4,3,14,7,4,4,6,5,10,2,6,15,4,6,32,5,4,5,20,7,58,4,6,11,4,3,32,7,10,14,6,5,10,7,6,33,4,4,24,5,4,4,14,21,10,6,6,59,10,5,32,7,4,10,6,5,134,2,42,33,4,6,32,11,4,15,6,7,28,4,32,11,4,6,242,7,4,32,42,5,10,5,6,25,10,4,32,5,10,5,6,15,134,20,6,11,4,7,46,7", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef A(n, k):\n    f = factorint(n)\n    return 1 if n == 1 else reduce(mul, [1 if i%4==k else i**f[i] for i in f])\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a286364(n): return T(a046523(n/A(n, 1)), a046523(n/A(n, 3)))\ndef a007814(n): return 1 + bin(n - 1)[2:].count(\"1\") - bin(n)[2:].count(\"1\")\ndef a(n): return 2*a286364(n) + a007814(n)%2 \n"}
{"sequence_id": "A286366", "text": "Compound filter: a(n) = 2*A286365(n) + floor(A072400(n)/4).", "sequence": "4,6,8,4,13,11,9,6,28,14,8,8,13,11,21,4,12,30,8,13,65,11,9,11,40,14,116,9,13,23,9,6,64,14,20,28,13,11,21,14,12,66,8,8,49,11,9,8,28,42,20,13,13,119,21,11,64,14,8,21,13,11,269,4,84,66,8,12,65,23,9,30,12,14,56,8,65,23,9,13,484,14,8,65,85,11,21,11,12,50,20,9,65,11,21,11", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef A(n, k):\n    f = factorint(n)\n    return 1 if n == 1 else reduce(mul, [1 if i%4==k else i**f[i] for i in f])\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a286364(n): return T(a046523(n/A(n, 1)), a046523(n/A(n, 3)))\ndef a007814(n): return 1 + bin(n - 1)[2:].count(\"1\") - bin(n)[2:].count(\"1\")\ndef a286365(n): return 2*a286364(n) + a007814(n)%2\ndef a072400(n): return int(str(int(''.join(map(str, digits(n, 4)[1:]))[::-1]))[::-1], 4)%8\ndef a(n): return 2*a286365(n) + int(a072400(n)/4) \n"}
{"sequence_id": "A286367", "text": "Compound filter: a(n) = P(A001511(n), A286364(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,3,2,6,4,5,2,10,22,8,2,9,4,5,11,15,4,30,2,13,121,5,2,14,46,8,407,9,4,17,2,21,121,8,11,39,4,5,11,19,4,138,2,9,67,5,2,20,22,57,11,13,4,437,11,14,121,8,2,24,4,5,2212,28,211,138,2,13,121,17,2,49,4,8,92,9,121,17,2,26,7261,8,2,156,211,5,11,14,4,80,11,9,121,5,11,27,4,30", "code": "\nfrom sympy import factorint\nfrom operator import mul\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef A(n, k):\n    f = factorint(n)\n    return 1 if n == 1 else reduce(mul, [1 if i%4==k else i**f[i] for i in f])\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a286364(n): return T(a046523(n/A(n, 1)), a046523(n/A(n, 3)))\ndef a001511(n): return 2 + bin(n - 1)[2:].count(\"1\") - bin(n)[2:].count(\"1\")\ndef a(n): return T(a001511(n), a286364(n)) \n"}
{"sequence_id": "A286369", "text": "Compound filter: a(n) = 2*A286364(n) + floor(A072400(n)/4).", "sequence": "2,2,4,2,7,5,5,2,14,6,4,4,7,5,11,2,6,14,4,7,33,5,5,5,20,6,58,5,7,11,5,2,32,6,10,14,7,5,11,6,6,32,4,4,25,5,5,4,14,20,10,7,7,59,11,5,32,6,4,11,7,5,135,2,42,32,4,6,33,11,5,14,6,6,28,4,33,11,5,7,242,6,4,33,43,5,11,5,6,24,10,5,33,5,11,5,6,14,134,20,7,11,5,6,46,6", "code": "\nfrom sympy.ntheory.factor_ import digits\nfrom sympy import factorint\nfrom operator import mul\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef A(n, k):\n    f = factorint(n)\n    return 1 if n == 1 else reduce(mul, [1 if i%4==k else i**f[i] for i in f])\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a286364(n): return T(a046523(n/A(n, 1)), a046523(n/A(n, 3)))\ndef a072400(n): return int(str(int(''.join(map(str, digits(n, 4)[1:]))[::-1]))[::-1], 4)%8\ndef a(n): return 2*a286364(n) + int(a072400(n)/4) \n"}
{"sequence_id": "A286374", "text": "a(n) = A278222(n^2).", "sequence": "1,2,2,6,2,12,6,12,2,30,12,48,6,210,12,24,2,30,30,420,12,360,48,30,6,120,210,1260,12,420,24,48,2,30,30,420,30,4620,420,480,12,420,360,1080,48,960,30,210,6,420,120,2310,210,3360,1260,1680,12,1260,420,6300,24,840,48,96,2,30,30,420,30,4620,420,2520,30,4620,4620,6720,420,9240,480,180", "code": "\nfrom sympy import prime, factorint\nimport math\ndef A(n): return n - 2**int(math.floor(math.log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a005940(n): return b(n - 1)\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a278222(n): return a046523(a005940(n + 1))\ndef a(n): return a278222(n**2) \n"}
{"sequence_id": "A286379", "text": "Compound filter (\"discard the smallest prime factor\" & \"signature for 1-runs in base-2\"): a(n) = P(A032742(n), A278222(n)), where P(n,k) is sequence A000027 used as a pairing function, with a(1) = 1.", "sequence": "1,2,7,5,16,18,29,14,31,50,67,42,67,98,195,44,16,100,67,115,637,242,277,117,125,289,955,224,277,450,497,152,131,248,160,271,436,454,643,320,436,1246,1771,550,2716,1058,1129,375,160,655,1343,692,1771,1918,3332,623,880,1355,2557,1020,1129,1922,3507,560,166,736,67,775,1349,1070,277,856,436", "code": "\nfrom sympy import factorint, divisors\nimport math\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef A(n): return n - 2**int(math.floor(math.log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a005940(n): return b(n - 1)\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a278222(n): return a046523(a005940(n + 1))\ndef a(n): return 1 if n==1 else T(divisors(n)[-2], a278222(n)) \n"}
{"sequence_id": "A286385", "text": "a(n) = A003961(n) - A000203(n).", "sequence": "0,0,1,2,1,3,3,12,12,3,1,17,3,9,11,50,1,36,3,21,23,3,5,75,18,9,85,43,1,33,5,180,17,3,29,134,3,9,29,99,1,69,3,33,97,15,5,281,64,54,23,55,5,255,19,177,35,3,1,147,5,15,171,602,35,51,3,45,49,87,1,480,5,9,121,67,47,87,3,381,504,3,5,271,25,9,35,171,7,291,75,93,57,15,41,963", "code": "\nfrom sympy import factorint, nextprime, divisor_sigma as D\nfrom operator import mul\ndef a048673(n):\n    f = factorint(n)\n    return 1 if n==1 else (1 + reduce(mul, [nextprime(i)**f[i] for i in f]))/2\ndef a(n): return 2*a048673(n) - D(n) - 1 \n"}
{"sequence_id": "A286386", "text": "Compound filter: a(n) = 2*A286473(n) + (1 if n is a square, 0 otherwise).", "sequence": "3,12,14,21,10,28,14,36,31,44,14,52,10,60,46,69,10,76,14,84,62,92,14,100,43,108,78,116,10,124,14,132,94,140,58,149,10,156,110,164,10,172,14,180,126,188,14,196,63,204,142,212,10,220,90,228,158,236,14,244,10,252,174,261,106,268,14,276,190,284,14,292,10,300,206,308,94,316,14,324,223", "code": "\nfrom sympy import sqrt, divisors, primefactors\nimport math\ndef a010052(n): return 1 if n<1 else int(math.floor(sqrt(n))) - int(math.floor(sqrt(n - 1)))\ndef a286473(n): return 1 if n==1 else 4*divisors(n)[-2] + (min(primefactors(n))%4)\ndef a(n): return 2*a286473(n) + a010052(n) \n"}
{"sequence_id": "A286388", "text": "Compound filter (\"discard the smallest prime factor\" & \"number of trailing 1-bits in base-2\"): a(n) = P(A032742(n), A001511(1+n)), where P(n,k) is sequence A000027 used as a pairing function, with a(1) = 0.", "sequence": "0,1,4,3,2,6,7,10,9,15,4,21,2,28,41,36,2,45,4,55,35,66,7,78,20,91,64,105,2,120,16,136,77,153,43,171,2,190,133,210,2,231,4,253,135,276,11,300,35,325,188,351,2,378,102,406,209,435,4,465,2,496,372,528,104,561,4,595,299,630,7,666,2,703,376,741,77,780,11,820,405,861,4,903,170,946", "code": "\nfrom sympy import divisors\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a001511(n): return bin(n)[2:][::-1].index(\"1\") + 1\ndef a(n): return 0 if n==1 else T(divisors(n)[-2], a001511(n + 1)) \n"}
{"sequence_id": "A286415", "text": "Primes p where all the cyclic shifts of their digits to the right also produce primes except the last one before reaching p again.", "sequence": "19,23,29,41,43,47,53,59,61,67,83,89,173,271,277,313,379,397,419,479,491,571,577,593,617,631,673,811,839,877,911,977,1777,1913,2131,2311,2377,2399,2713,2791,2939,2971,4177,4339,4919,4993,5119,5791,6133,6737,6997,7193,7333,7919,8111", "code": "\nfrom itertools import product\nfrom sympy import isprime\nA286415_list = []\nfor l in range(1,15):\n    for d in '123456789':\n        for w in product('1379',repeat=l):\n            s = d+''.join(w)\n            n = int(s)\n            for i in range(l):\n                if not isprime(int(s)):\n                    break\n                s = s[-1]+s[:-1]\n            else:\n                if not isprime(int(s)):\n                    A286415_list.append(n) \n"}
{"sequence_id": "A286451", "text": "Compound filter (2-adic valuation of sigma(n) & 2-adic valuation of n): a(n) = P(A286357(n), A001511(n)), where P(n,k) is sequence A000027 used as a pairing function, with a(1) = 0 by an explicit convention.", "sequence": "0,2,6,4,3,9,10,7,1,5,6,13,3,14,10,11,3,2,6,8,21,9,10,18,1,5,10,19,3,14,21,16,15,5,15,4,3,9,10,12,3,27,6,13,3,14,15,24,1,2,10,8,3,14,10,25,15,5,6,19,3,27,10,22,6,20,6,8,21,20,10,7,3,5,6,13,21,14,15,17,1,5,6,34,6,9,10,18,3,5,15,19,36,20,10,31,3,2,6,4,3,14,10", "code": "\nfrom sympy import divisor_sigma as D\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a001511(n): return bin(n)[2:][::-1].index(\"1\") + 1\ndef a(n): return 0 if n==1 else T(a001511(D(n)), a001511(n)) \n"}
{"sequence_id": "A286452", "text": "Compound filter (largest prime factor of n & prime signature of 2n-1): a(n) = P(A061395(n), A046523(2n-1)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "0,2,5,2,18,5,14,16,5,9,50,5,42,59,9,2,73,23,44,31,14,20,199,5,18,61,5,40,115,9,77,67,50,35,40,5,90,179,61,9,391,14,185,50,9,100,205,23,14,94,35,27,1006,5,20,40,44,115,395,31,228,131,59,2,61,20,295,442,54,14,320,23,346,265,9,44,125,61,275,31,23,104,1349,14,52,314,65,125,430", "code": "\nfrom sympy import primepi, primefactors, factorint\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a061395(n): return 0 if n==1 else primepi(primefactors(n)[-1])\ndef a(n): return T(a061395(n), a046523(2*n - 1)) \n"}
{"sequence_id": "A286460", "text": "Compound filter (2-adic valuation & sum of the divisors): a(n) = P(A001511(n), A000203(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,8,7,39,16,80,29,157,79,173,67,438,92,302,277,600,154,782,191,949,497,668,277,1957,466,905,781,1656,436,2630,497,2284,1129,1487,1129,4281,704,1832,1541,4282,862,4658,947,3658,3004,2630,1129,8133,1597,4373,2557,4953,1432,7262,2557,7507,3161,4097,1771,14368,1892,4658,5357,8785,3487,10442,2279", "code": "\nfrom sympy import divisor_sigma as D\ndef a001511(n): return bin(n)[2:][::-1].index(\"1\") + 1\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)//2\ndef a(n): return T(a001511(n), D(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A286462", "text": "Compound filter (3-adic valuation & the length of rightmost run of 1's in base-2): a(n) = P(A051064(n), A089309(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,1,5,1,1,5,4,1,6,1,2,5,1,4,12,1,1,6,2,1,3,2,4,5,1,1,14,4,1,12,11,1,3,1,2,6,1,2,8,1,1,3,2,2,6,4,7,5,1,1,5,1,1,14,4,4,3,1,2,12,1,11,31,1,1,3,2,1,3,2,4,6,1,1,5,2,1,8,7,1,15,1,2,3,1,2,8,2,1,6,2,4,3,7,11,5,1,1,9,1,1,5,4,1,3,1,2,14,1,4,12,4,1,3,2,1", "code": "\nfrom sympy import divisors, divisor_count, mobius\ndef a051064(n): return -sum([mobius(3*d)*divisor_count(n/d) for d in divisors(n)])\ndef v(n): return bin(n)[2:][::-1].index(\"1\")\ndef a089309(n): return  0 if n==0 else v(n/2**v(n) + 1)\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a(n): return T(a051064(n), a089309(n)) \n"}
{"sequence_id": "A286463", "text": "Compound filter (3-adic valuation & prime-signature): a(n) = P(A051064(n), A046523(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,2,5,7,2,23,2,29,18,16,2,80,2,16,23,121,2,94,2,67,23,16,2,302,7,16,59,67,2,467,2,497,23,16,16,706,2,16,23,277,2,467,2,67,94,16,2,1178,7,67,23,67,2,355,16,277,23,16,2,1832,2,16,94,2017,16,467,2,67,23,436,2,2704,2,16,80,67,16,467,2,1129,195,16,2,1832,16,16,23,277,2,1894,16", "code": "\nfrom sympy import factorint, divisors, divisor_count, mobius\ndef a051064(n): return -sum([mobius(3*d)*divisor_count(n/d) for d in divisors(n)])\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a(n): return T(a051064(n), a046523(n)) \n"}
{"sequence_id": "A286465", "text": "Compound filter: a(1) = 1, a(n) = P(A112049(n-1), A278223(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,2,2,5,12,2,2,23,5,2,16,9,18,29,2,5,23,16,2,23,5,2,67,9,25,16,2,23,23,2,2,80,23,2,16,14,9,67,16,5,138,2,16,23,5,16,16,31,9,67,2,5,467,2,2,23,5,16,67,40,33,16,29,5,23,2,16,302,5,2,16,31,31,67,2,5,80,16,2,23,23,2,436,9,42,67,2,80,23,2,2,23,23,16,277,14,9,436,2,5", "code": "\nfrom sympy import jacobi_symbol as J, factorint, isprime, primepi\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a278223(n): return a046523(2*n - 1)\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a049084(n): return primepi(n) if isprime(n) else 0\ndef a112046(n):\n    i=1\n    while True:\n        if J(i, 2*n + 1)!=1: return i\n        else: i+=1\ndef a112049(n): return a049084(a112046(n))\ndef a(n): return 1 if n==1 else T(a112049(n - 1), a278223(n)) \n"}
{"sequence_id": "A286466", "text": "Compound filter: a(n) = P(A112049(n), A046523(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,2,5,12,2,16,5,38,7,16,9,94,2,16,23,138,2,67,5,80,16,16,9,355,7,16,38,80,2,436,5,530,16,16,40,706,2,16,23,302,2,436,5,80,67,16,9,1228,7,67,23,80,2,277,23,302,16,16,14,2021,2,16,80,2082,16,436,5,80,16,436,9,2704,2,16,80,80,16,436,5,1178,121,16,9,2086,16,16,23,302,2,1771", "code": "\nfrom sympy import jacobi_symbol as J, factorint, isprime, primepi\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a049084(n): return primepi(n) if isprime(n) else 0\ndef a112046(n):\n    i=1\n    while True:\n        if J(i, 2*n + 1)!=1: return i\n        else: i+=1\ndef a112049(n): return a049084(a112046(n))\ndef a(n): return T(a112049(n), a046523(n)) \n"}
{"sequence_id": "A286469", "text": "a(n) = maximum of {the index of least prime dividing n} and {the maximal gap between indices of the successive primes in the prime factorization of n}.", "sequence": "0,1,2,1,3,1,4,1,2,2,5,1,6,3,2,1,7,1,8,2,2,4,9,1,3,5,2,3,10,1,11,1,3,6,3,1,12,7,4,2,13,2,14,4,2,8,15,1,4,2,5,5,16,1,3,3,6,9,17,1,18,10,2,1,3,3,19,6,7,2,20,1,21,11,2,7,4,4,22,2,2,12,23,2,4,13,8,4,24,1,4,8,9,14,5,1,25,3,3,2,26,5,27,5,2,15,28,1,29,2,10,3", "code": "\nfrom sympy import primepi, isprime, primefactors, divisors\ndef a049084(n): return primepi(n)*(1*isprime(n))\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef x(n): return 1 if n==1 else divisors(n)[-2]\ndef a286470(n): return 0 if n==1 or len(primefactors(n))==1 else max(a055396(x(n)) - a055396(n), a286470(x(n)))\ndef a(n): return max(a055396(n), a286470(n)) \n"}
{"sequence_id": "A286470", "text": "a(n) = maximal gap between indices of successive primes in the prime factorization of n.", "sequence": "0,0,0,0,0,1,0,0,0,2,0,1,0,3,1,0,0,1,0,2,2,4,0,1,0,5,0,3,0,1,0,0,3,6,1,1,0,7,4,2,0,2,0,4,1,8,0,1,0,2,5,5,0,1,2,3,6,9,0,1,0,10,2,0,3,3,0,6,7,2,0,1,0,11,1,7,1,4,0,2,0,12,0,2,4,13,8,4,0,1,2,8,9,14,5,1,0,3,3,2,0,5,0,5,1,15,0,1,0,2,10,3,0,6,6,9,4,16,3,1", "code": "\nfrom sympy import primepi, isprime, primefactors, divisors\ndef a049084(n): return primepi(n)*(1*isprime(n))\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef x(n): return 1 if n==1 else divisors(n)[-2]\ndef a(n): return 0 if n==1 or len(primefactors(n))==1 else max(a055396(x(n)) - a055396(n), a(x(n))) \n"}
{"sequence_id": "A286471", "text": "If n is noncomposite, then a(n) = 0, otherwise 1 + difference between indices of the two smallest (not necessarily distinct) prime factors of n.", "sequence": "0,0,0,1,0,2,0,1,1,3,0,1,0,4,2,1,0,2,0,1,3,5,0,1,1,6,1,1,0,2,0,1,4,7,2,1,0,8,5,1,0,2,0,1,1,9,0,1,1,3,6,1,0,2,3,1,7,10,0,1,0,11,1,1,4,2,0,1,8,3,0,1,0,12,2,1,2,2,0,1,1,13,0,1,5,14,9,1,0,2,3,1,10,15,6,1,0,4,1,1,0,2,0,1,2,16,0,1,0,3,11,1,0,2,7,1,1,17", "code": "\nfrom sympy import primepi, isprime, primefactors, divisors\ndef a049084(n): return primepi(n)*(1*isprime(n))\ndef a055396(n): return 0 if n==1 else a049084(min(primefactors(n)))\ndef a(n): return 0 if n==1 or isprime(n) else 1 + a055396(divisors(n)[-2]) - a055396(n) \n"}
{"sequence_id": "A286472", "text": "Compound filter (for counting prime gaps): a(1) = 1, a(n) = 2*A032742(n) + (1 if n is composite and spf(A032742(n)) > nextprime(spf(n)), and 0 otherwise). Here spf is the smallest prime factor, A020639.", "sequence": "1,2,2,4,2,6,2,8,6,11,2,12,2,15,10,16,2,18,2,20,15,23,2,24,10,27,18,28,2,30,2,32,23,35,14,36,2,39,27,40,2,42,2,44,30,47,2,48,14,51,35,52,2,54,23,56,39,59,2,60,2,63,42,64,27,66,2,68,47,71,2,72,2,75,50,76,22,78,2", "code": "\nfrom sympy import primefactors, divisors, nextprime\ndef ok(n): return 1 if isprime(n)==0 and min(primefactors(divisors(n)[-2])) > nextprime(min(primefactors(n))) else 0\ndef a(n): return 1 if n==1 else 2*divisors(n)[-2] + ok(n) \n"}
{"sequence_id": "A286473", "text": "Compound filter (for counting primes of form 4k+1, 4k+2 and 4k+3): a(n) = 4*A032742(n) + (A020639(n) mod 4), a(1) = 1.", "sequence": "1,6,7,10,5,14,7,18,15,22,7,26,5,30,23,34,5,38,7,42,31,46,7,50,21,54,39,58,5,62,7,66,47,70,29,74,5,78,55,82,5,86,7,90,63,94,7,98,31,102,71,106,5,110,45,114,79,118,7,122,5,126,87,130,53,134,7,138,95,142,7,146,5,150,103,154,47,158,7,162,111,166,7,170,69,174,119,178,5,182,55", "code": "\nfrom sympy import divisors, primefactors\ndef a(n): return 1 if n==1 else 4*divisors(n)[-2] + (min(primefactors(n))%4) \n"}
{"sequence_id": "A286474", "text": "Compound filter: a(n) = 4*A032742(n) + (n mod 4), a(1) = 1.", "sequence": "1,6,7,8,5,14,7,16,13,22,7,24,5,30,23,32,5,38,7,40,29,46,7,48,21,54,39,56,5,62,7,64,45,70,31,72,5,78,55,80,5,86,7,88,61,94,7,96,29,102,71,104,5,110,47,112,77,118,7,120,5,126,87,128,53,134,7,136,93,142,7,144,5,150,103,152,45,158,7,160,109,166,7,168,69,174,119,176,5,182,55", "code": "\nfrom sympy import divisors, primefactors\ndef a(n): return 1 if n==1 else 4*divisors(n)[-2] + n%4 \n"}
{"sequence_id": "A286475", "text": "Compound filter (for counting primes of form 6k+1, 6k+2, 6k+3 and 6k+5): a(n) = 6*A032742(n) + (A020639(n) mod 6), a(1) = 1.", "sequence": "1,8,9,14,11,20,7,26,21,32,11,38,7,44,33,50,11,56,7,62,45,68,11,74,35,80,57,86,11,92,7,98,69,104,47,110,7,116,81,122,11,128,7,134,93,140,11,146,43,152,105,158,11,164,71,170,117,176,11,182,7,188,129,194,83,200,7,206,141,212,11,218,7,224,153,230,67,236,7,242,165,248,11,254,107", "code": "\nfrom sympy import divisors, primefactors\ndef a(n): return 1 if n==1 else 6*divisors(n)[-2] +(min(primefactors(n))%6) \n"}
{"sequence_id": "A286476", "text": "Compound filter: a(n) = 6*A032742(n) + (n mod 6), a(1) = 1.", "sequence": "1,8,9,16,11,18,7,26,21,34,11,36,7,44,33,52,11,54,7,62,45,70,11,72,31,80,57,88,11,90,7,98,69,106,47,108,7,116,81,124,11,126,7,134,93,142,11,144,43,152,105,160,11,162,67,170,117,178,11,180,7,188,129,196,83,198,7,206,141,214,11,216,7,224,153,232,71,234,7,242,165,250,11,252,103", "code": "\nfrom sympy import divisors\ndef a(n): return 1 if n==1 else 6*divisors(n)[-2] + n%6 \n"}
{"sequence_id": "A286479", "text": "a(n) = A046523(n+A000005(n)).", "sequence": "2,4,2,2,2,6,4,12,12,6,2,12,6,12,2,6,2,24,6,6,4,6,4,32,12,30,2,6,2,6,6,6,2,6,6,12,6,30,2,48,2,12,12,12,6,12,4,6,12,24,6,6,6,6,2,64,2,6,2,72,12,30,6,2,6,6,6,6,2,30,2,60,12,30,16,6,16,6,16,60,6,6,6,96,2,60,6,96,6,30,6,12,2,12,12,72,12,24,30,2,2,30,30,48,2,30", "code": "\nfrom sympy import factorint, divisor_count\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return a046523(n + divisor_count(n)) \n"}
{"sequence_id": "A286480", "text": "Compound filter (prime signature of n & prime signature of n+d(n)): a(n) = P(A046523(n), A286479(n)), where P(n,k) is sequence A000027 used as a pairing function and d(n) is number of divisors of n (A000005).", "sequence": "2,12,5,14,5,61,12,179,109,61,5,265,23,142,27,226,5,607,23,148,42,61,12,1509,109,601,44,148,5,625,23,698,27,61,61,1117,23,601,27,2509,5,850,80,265,148,142,12,1426,109,607,61,148,23,430,27,3765,27,61,5,8575,80,601,148,2144,61,625,23,148,27,1741,5,8587,80,601,363,148,216,625,138,5719", "code": "\nfrom sympy import factorint, divisor_count\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a286479(n): return a046523(n + divisor_count(n))\ndef a(n): return T(a046523(n), a286479(n)) \n"}
{"sequence_id": "A286529", "text": "a(n) = d(n+d(n)), where d(n) is the number of divisors of n (A000005).", "sequence": "2,3,2,2,2,4,3,6,6,4,2,6,4,6,2,4,2,8,4,4,3,4,3,6,6,8,2,4,2,4,4,4,2,4,4,6,4,8,2,10,2,6,6,6,4,6,3,4,6,8,4,4,4,4,2,7,2,4,2,12,6,8,4,2,4,4,4,4,2,8,2,12,6,8,5,4,5,4,5,12,4,4,4,12,2,12,4,12,4,8,4,6,2,6,6,12,6,8,8,2,2,8,8,10,2,8,2,16,4,4,4,4,4,4,4,4,4", "code": "\nfrom sympy import divisor_count as d\ndef a(n): return d(n + d(n)) \n"}
{"sequence_id": "A286530", "text": "a(n) = d(n+d(n)) - d(n), where d(n) is the number of divisors of n (A000005).", "sequence": "1,1,0,-1,0,0,1,2,3,0,0,0,2,2,-2,-1,0,2,2,-2,-1,0,1,-2,3,4,-2,-2,0,-4,2,-2,-2,0,0,-3,2,4,-2,2,0,-2,4,0,-2,2,1,-6,3,2,0,-2,2,-4,-2,-1,-2,0,0,0,4,4,-2,-5,0,-4,2,-2,-2,0,0,0,4,4,-1,-2,1,-4,3,2,-1,0,2,0,-2,8,0,4,2,-4,0,0,-2,2,2,0,4,2,2,-7,0,0,6,2,-6,4,0,4,2", "code": "\nfrom sympy import divisor_count as d\ndef a(n): return d(n + d(n)) - d(n) \n"}
{"sequence_id": "A286561", "text": "Square array A(n,k): A(n,1) = 1, and for k > 1, A(n,k) = the highest exponent e such that k^e divides n, read by descending antidiagonals as A(1,1), A(1,2), A(2,1), etc.", "sequence": "1,0,1,0,1,1,0,0,0,1,0,0,1,2,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,3,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1", "code": "\ndef a(n, k):\n    i=1\n    if k==1: return 1\n    while n%(k**i)==0:\n        i+=1\n    return i-1\nfor n in range(1, 21): print([a(k, n - k + 1) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A286562", "text": "Transpose of square array A286561.", "sequence": "1,1,0,1,1,0,1,0,0,0,1,2,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1,3,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,2,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,2,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0", "code": "\ndef a(n, k):\n    i=1\n    if k==1: return 1\n    while n%(k**i)==0:\n        i+=1\n    return i-1\nfor n in range(1, 21): print [a(k, n - k + 1) for k in range(1, n + 1)][::-1] \n"}
{"sequence_id": "A286563", "text": "Triangular table T(n,k) read by rows: T(n,1) = 1, and for 1 < k <= n, T(n,k) = the highest exponent e such that k^e divides n.", "sequence": "1,1,1,1,0,1,1,2,0,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,3,0,1,0,0,0,1,1,0,2,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,2,1,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1", "code": "\ndef T(n, k):\n    i=1\n    if k==1: return 1\n    while n%(k**i)==0:\n        i+=1\n    return i-1\nfor n in range(1, 21): print([T(n, k) for k in range(1, n + 1)]) \n"}
{"sequence_id": "A286564", "text": "Triangular table A286563 reversed.", "sequence": "1,1,1,1,0,1,1,0,2,1,1,0,0,0,1,1,0,0,1,1,1,1,0,0,0,0,0,1,1,0,0,0,1,0,3,1,1,0,0,0,0,0,2,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1", "code": "\ndef T(n, k):\n    i=1\n    if k==1: return 1\n    while n%(k**i)==0:\n        i+=1\n    return i-1\nfor n in range(1, 21): print [T(n, k) for k in range(1, n + 1)] [::-1] \n"}
{"sequence_id": "A286568", "text": "Compound filter (phi(n) & 2-adic valuation of sigma(n)): a(n) = P(A000010(n), A286357(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,1,8,3,14,8,42,10,21,14,76,19,90,42,63,36,152,21,208,44,148,76,322,53,210,90,228,117,434,63,625,136,296,152,402,78,702,208,375,152,860,148,988,251,324,322,1271,169,903,210,627,324,1430,228,943,375,816,434,1828,187,1890,625,777,528,1273,296,2344,560,1220,402,2698,300,2700,702,901", "code": "\nfrom sympy import divisor_sigma as D, totient\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a001511(n): return bin(n)[2:][::-1].index(\"1\") + 1\ndef a286357(n): return a001511(D(n))\ndef a(n): return T(totient(n), a286357(n)) \n"}
{"sequence_id": "A286570", "text": "Compound filter (prime signature of n & gcd(n, sigma(n))): a(n) = P(A046523(n), A009194(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,3,3,10,3,61,3,36,10,27,3,117,3,27,34,136,3,103,3,90,21,27,3,619,10,27,36,753,3,625,3,528,34,27,21,666,3,27,21,552,3,625,3,117,103,27,3,1323,10,78,34,90,3,430,21,489,21,27,3,2545,3,27,78,2080,21,625,3,90,34,495,3,2773,3,27,78,117,21,625,3,1224,136,27,3,3801,21,27,34,375,3", "code": "\nfrom sympy import factorint, gcd, divisor_sigma\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(a046523(n), gcd(n, divisor_sigma(n))) \n"}
{"sequence_id": "A286571", "text": "Compound filter (prime signature of n & n/gcd(n, sigma(n))): a(n) = P(A046523(n), A017666(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,5,8,25,17,21,30,113,70,51,68,103,93,72,51,481,155,148,192,222,331,126,278,324,382,159,569,78,437,591,498,1985,126,237,786,2521,705,282,952,375,863,660,948,243,337,384,1130,1759,1330,1842,237,678,1433,520,1776,459,1897,567,1772,2076,1893,636,2713,8065,2421,810,2280,1002,384,2046", "code": "\nfrom sympy import factorint, gcd, divisor_sigma\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(a046523(n), n/gcd(n, divisor_sigma(n))) \n"}
{"sequence_id": "A286572", "text": "Compound filter (2-adic valuation of phi(n) & sigma(n)): a(n) = P(A053574(n), A000203(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "0,1,7,22,23,67,29,122,79,173,67,408,107,277,328,531,214,742,191,949,530,631,277,1894,498,905,781,1598,467,2704,497,2149,1178,1600,1228,4188,743,1771,1656,4282,949,4658,947,3572,3163,2557,1129,8005,1597,4373,2855,4953,1487,7141,2704,7384,3242,4097,1771,14539,1955,4561,5462,8520,3745", "code": "\nfrom sympy import totient, divisor_sigma\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a007814(n): return 1 + bin(n - 1)[2:].count(\"1\") - bin(n)[2:].count(\"1\")\ndef a(n): return T(a007814(totient(n)), divisor_sigma(n)) \n"}
{"sequence_id": "A286573", "text": "Compound filter: a(n) = P(A007733(n), A046523(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,2,5,7,14,23,9,29,42,40,65,80,90,31,40,121,44,142,189,109,61,115,77,302,273,148,318,94,434,532,20,497,115,86,148,826,702,271,148,355,230,601,119,220,265,131,299,1178,297,485,86,265,1430,838,320,328,271,556,1769,1957,1890,50,142,2017,148,751,2277,179,373,832,665,2932,54,856,485", "code": "\nfrom sympy import divisors, factorint\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a002326(n):\n    m=1\n    while True:\n        if (2**m - 1)%(2*n + 1)==0: return m\n        else: m+=1\ndef a000265(n): return max(list(filter(lambda i: i%2 == 1, divisors(n))))\ndef a007733(n): return a002326((a000265(n) - 1)/2)\ndef P(n):\n    f = factorint(n)\n    return sorted([f[i] for i in f])\ndef a046523(n):\n    x=1\n    while True:\n        if P(n) == P(x): return x\n        else: x+=1\ndef a(n): return T(a007733(n), a046523(n)) \n"}
{"sequence_id": "A286574", "text": "Sum of the binary weights of the lengths of 1-runs in base-2 representation of n: a(n) = A000523(A286575(n)).", "sequence": "0,1,1,1,1,2,1,2,1,2,2,2,1,2,2,1,1,2,2,2,2,3,2,3,1,2,2,2,2,3,1,2,1,2,2,2,2,3,2,3,2,3,3,3,2,3,3,2,1,2,2,2,2,3,2,3,2,3,3,3,1,2,2,2,1,2,2,2,2,3,2,3,2,3,3,3,2,3,3,2,2,3,3,3,3,4,3,4,2,3,3,3,3,4,2,3,1,2,2,2,2,3,2,3,2,3,3,3,2,3,3,2,2,3,3,3,3,4,3,4,1", "code": "\nfrom sympy import factorint, prime, log\nimport math\ndef wt(n): return bin(n).count(\"1\")\ndef a037445(n):\n    f=factorint(n)\n    return 2**sum([wt(f[i]) for i in f])\ndef A(n): return n - 2**int(math.floor(log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a286575(n): return a037445(b(n))\ndef a(n): return int(math.floor(log(a286575(n), 2))) \n"}
{"sequence_id": "A286575", "text": "Run-length transform of A001316.", "sequence": "1,2,2,2,2,4,2,4,2,4,4,4,2,4,4,2,2,4,4,4,4,8,4,8,2,4,4,4,4,8,2,4,2,4,4,4,4,8,4,8,4,8,8,8,4,8,8,4,2,4,4,4,4,8,4,8,4,8,8,8,2,4,4,4,2,4,4,4,4,8,4,8,4,8,8,8,4,8,8,4,4,8,8,8,8,16,8,16,4,8,8,8,8,16,4,8,2,4,4,4,4,8,4,8,4,8,8,8,4", "code": "\nfrom sympy import factorint, prime, log\nimport math\ndef wt(n): return bin(n).count(\"1\")\ndef a037445(n):\n    f=factorint(n)\n    return 2**sum([wt(f[i]) for i in f])\ndef A(n): return n - 2**int(math.floor(log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a(n): return a037445(b(n)) \n"}
{"sequence_id": "A286576", "text": "a(n) = A132971(n) mod 3.", "sequence": "1,2,2,0,2,1,0,0,2,1,1,0,0,0,0,0,2,1,1,0,1,2,0,0,0,0,0,0,0,0,0,0,2,1,1,0,1,2,0,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,1,0,1,2,0,0,1,2,2,0,0,0,0,0,1,2,2,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\nfrom sympy import mobius, prime, log\nimport math\ndef A(n): return n - 2**int(math.floor(log(n, 2)))\ndef b(n): return n + 1 if n<2 else prime(1 + (len(bin(n)[2:]) - bin(n)[2:].count(\"1\"))) * b(A(n))\ndef a(n): return mobius(b(n))%3 \n"}
{"sequence_id": "A286582", "text": "a(n) = A001222(A048673(n)).", "sequence": "0,1,1,1,2,3,2,2,1,1,1,1,2,1,3,1,2,2,3,5,3,3,2,3,2,2,3,3,4,1,1,2,2,1,2,1,2,2,1,2,2,1,4,1,4,3,3,2,1,2,5,2,3,3,2,1,2,1,1,2,2,4,3,2,4,3,4,2,1,3,1,3,4,2,2,4,5,7,3,3,1,2,3,4,1,1,3,5,2,1,2,1,2,5,4,6,2,3,1,2,3,2,4,3,1,1", "code": "\nfrom sympy import factorint, nextprime, primefactors, prod\ndef a001222(n): return 0 if n==1 else a001222(n//primefactors(n)[-1]) + 1\ndef a048673(n):\n    f = factorint(n)\n    return 1 if n==1 else (1 + prod(nextprime(i)**f[i] for i in f))//2\ndef a(n): return a001222(a048673(n))\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A286583", "text": "a(n) = A007814(A048673(n)).", "sequence": "0,1,0,0,2,3,1,1,0,0,0,0,0,0,1,0,1,1,2,5,2,2,0,2,0,1,0,1,4,0,0,1,0,0,0,0,0,0,0,0,1,0,3,0,3,2,0,0,0,1,4,0,1,2,1,0,1,0,0,1,1,3,1,0,2,1,2,1,0,2,0,1,3,1,0,3,3,7,1,2,0,0,0,3,0,0,1,4,0,0,1,0,0,4,0,5,0,1,0,0,2,0,1,1,0,0,0,0,0,0,0,1,6", "code": "\nfrom sympy import factorint, nextprime, prod\ndef a007814(n): return 1 + bin(n - 1)[2:].count(\"1\") - bin(n)[2:].count(\"1\")\ndef a048673(n):\n    f = factorint(n)\n    return 1 if n==1 else (1 + prod(nextprime(i)**f[i] for i in f))//2\ndef a(n): return a007814(a048673(n)) \n"}
{"sequence_id": "A286584", "text": "a(n) = A048673(n) mod 4.", "sequence": "1,2,3,1,0,0,2,2,1,3,3,3,1,1,2,1,2,2,0,0,0,0,3,0,1,2,3,2,0,1,3,2,1,1,3,1,1,3,3,3,2,3,0,3,0,0,3,3,1,2,0,1,2,0,2,1,2,3,3,2,2,0,2,1,0,2,0,2,1,0,1,2,0,2,3,0,0,0,2,0,1,1,1,0,3,3,2,0,1,3,2,3,1,0,1,0,3,2,3,1,0,3,2,2,1,1,3,3,1,1,3,2,0", "code": "\nfrom sympy import factorint, nextprime\nfrom operator import mul\ndef a048673(n):\n    f = factorint(n)\n    return 1 if n==1 else (1 + reduce(mul, [nextprime(i)**f[i] for i in f]))/2\ndef a(n): return a048673(n)%4 \n"}
{"sequence_id": "A286585", "text": "a(n) = A053735(A048673(n)).", "sequence": "1,2,1,3,2,4,2,4,3,3,3,5,1,5,2,5,2,4,2,4,2,4,3,6,5,6,3,6,4,7,3,6,3,3,3,5,3,5,5,5,4,3,4,5,4,6,1,7,5,6,4,7,2,8,4,7,4,5,3,8,4,4,4,7,4,6,2,4,5,6,3,6,4,6,5,6,4,6,4,6,7,5,3,4,5,7,6,6,5,5,4,7,3,8,1,8,5,6,3,7,6,7,2,8", "code": "\nfrom sympy.ntheory.factor_ import digits\nfrom sympy import factorint, nextprime\nfrom operator import mul\ndef a053735(n): return sum(digits(n, 3)[1:])\ndef a048673(n):\n    f = factorint(n)\n    return 1 if n==1 else (1 + reduce(mul, [nextprime(i)**f[i] for i in f]))//2\ndef a(n): return a053735(a048673(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A286586", "text": "a(n) = A006047(A048673(n)).", "sequence": "2,3,2,6,4,9,3,12,8,6,6,18,2,18,3,24,4,12,4,12,4,9,6,36,18,27,6,36,12,54,6,48,6,6,8,24,6,18,24,24,12,6,9,18,12,36,2,72,18,27,12,54,4,81,12,72,12,18,8,108,12,9,12,96,9,36,4,12,18,36,8,48,16,27,24,36,9,36,12,48,72,18,6,12,24,54,27,36,24,18,16,72,8,81,2", "code": "\nfrom sympy.ntheory.factor_ import digits\nfrom sympy import factorint, nextprime\nfrom operator import mul\nfrom functools import reduce\ndef a006047(n):\n    d=digits(n, 3)\n    return n + 1 if n<3 else reduce(mul, [1 + d[i] for i in range(1, len(d))])\ndef a048673(n):\n    f = factorint(n)\n    return 1 if n==1 else (1 + reduce(mul, [nextprime(i)**f[i] for i in f]))//2\ndef a(n): return a006047(a048673(n))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A286591", "text": "Compound filter: a(n) = P(A009191(n), A009194(n)), where P(n,k) is sequence A000027 used as a pairing function.", "sequence": "1,3,1,1,1,23,1,10,6,5,1,42,1,5,4,1,1,34,1,5,1,5,1,179,1,5,1,408,1,23,1,3,4,5,1,45,1,5,1,144,1,23,1,12,13,5,1,12,1,3,4,5,1,23,1,113,1,5,1,265,1,5,6,1,1,23,1,5,4,5,1,103,1,5,6,12,1,23,1,65,1,5,1,753,1,5,4,63,1,259,22,12,1,5,11,265,1,3,13,1,1,23,1,44,4,5,1", "code": "\nfrom sympy import divisor_sigma, divisor_count, gcd\ndef T(n, m): return ((n + m)**2 - n - 3*m + 2)/2\ndef a(n): return T(gcd(n, divisor_count(n)), gcd(n, divisor_sigma(n))) \n"}
{"sequence_id": "A286594", "text": "a(n) = number of steps in simple Euclidean algorithm for gcd(n,k) to reach the termination test n=k when starting with n = n and k = A000203(n).", "sequence": "0,2,3,4,5,1,7,8,6,5,11,4,13,5,4,16,17,7,19,11,12,6,23,3,10,6,15,1,29,5,31,32,7,7,9,13,37,7,9,5,41,6,43,11,7,8,47,7,14,14,7,11,53,7,11,8,15,9,59,6,61,9,12,64,10,8,67,11,8,20,71,9,73,10,13,9,23,9,79,17,42,11,83,4,11,11,8,23,89,5,7,9,16,12,8,6,97,17,9,16,101,11", "code": "\nfrom sympy import divisor_sigma\ndef A(n, k): return 0 if n==k else 1 + A(abs(n - k), min(n, k))\ndef a(n): return A(n, divisor_sigma(n)) \n"}
{"sequence_id": "A286604", "text": "a(n) = n mod sum of digits of n in factorial base.", "sequence": "0,0,1,0,2,0,1,0,0,1,3,0,1,2,3,0,2,0,3,0,1,2,5,0,1,0,0,1,1,0,1,2,1,2,0,0,1,2,4,0,5,2,3,4,3,4,5,0,1,2,3,0,3,0,3,0,2,3,5,0,1,2,3,4,2,1,1,2,6,0,7,0,1,2,0,1,5,2,4,0,3,4,6,4,1,2,3,4,1,0,0,1,5,6,5,0,2,3,3,4,3,2,1,2,0,1,3,0,4,5,7,0,5,2,3,4,0,1,9,0", "code": "\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a(n):\n    return n % sum(int(k) for k in str(a007623(n)))\nprint([a(n) for n in range(1, 201)]) \n"}
{"sequence_id": "A286606", "text": "a(n) = n mod product of nonzero digits of n in factorial base.", "sequence": "0,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,1,2,0,4,5,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,1,2,0,4,5,0,1,0,1,0,1,0,1,0,1,2,3,0,1,2,3,0,1,0,1,2,3,10,11,0,1,2,0,4,5,0,1,2,0,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,2,3,0,1,2,3,4,5,6,7,0,1,6,7,8,9,22,23,0", "code": "\nfrom operator import mul\nfrom functools import reduce\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef a(n):\n    x=str(a007623(n)).replace('0', '')\n    return n%reduce(mul, map(int, x))\nprint([a(n) for n in range(1, 201)]) \n"}
{"sequence_id": "A286607", "text": "Numbers that are not divisible by the sum of their factorial base digits (A034968).", "sequence": "3,5,7,10,11,13,14,15,17,19,21,22,23,25,28,29,31,32,33,34,37,38,39,41,42,43,44,45,46,47,49,50,51,53,55,57,58,59,61,62,63,64,65,66,67,68,69,71,73,74,76,77,78,79,81,82,83,84,85,86,87,88,89,92,93,94,95,97,98,99,100,101,102,103,104,106,107", "code": "\ndef a007623(n, p=2): return n if n<p else a007623(n//p, p+1)*10 + n%p\ndef ok(n):\n    x=a007623(n)\n    y=sum(int(k) for k in str(x))\n    return n%y!=0\nprint([n for n in range(1, 111) if ok(n)]) \n"}
{"sequence_id": "A286608", "text": "Numbers k for which the binary representation of the primes that divide k (A087207) is less than k.", "sequence": "1,2,3,4,5,6,8,9,10,12,14,15,16,18,20,21,22,24,25,27,28,30,32,33,35,36,39,40,42,44,45,48,49,50,52,54,55,56,60,63,64,65,66,68,70,72,75,77,78,80,81,84,85,88,90,91,96,98,99,100,102,104,105,108,110,112,117,119,120,121,125,126,128,130", "code": "\nfrom sympy import factorint, primepi\ndef a(n):\n    f=factorint(n)\n    return sum([2**primepi(i - 1) for i in f])\nprint([n for n in range(1, 201) if a(n)<n]) \n"}
{"sequence_id": "A286609", "text": "Numbers n for which the binary representation of the primes that divide n (A087207) is more than n.", "sequence": "7,11,13,17,19,23,26,29,31,34,37,38,41,43,46,47,51,53,57,58,59,61,62,67,69,71,73,74,76,79,82,83,86,87,89,92,93,94,95,97,101,103,106,107,109,111,113,114,115,116,118,122,123,124,127,129,131,133,134,137,138,139,141,142,145,146,148,149,151,155", "code": "\nfrom sympy import factorint, primepi\ndef a(n):\n    f=factorint(n)\n    return sum([2**primepi(i - 1) for i in f])\nprint([n for n in range(1, 201) if a(n)>n]) \n"}
{"sequence_id": "A286629", "text": "a(n) = (A000040(n)-1) * A002110(n).", "sequence": "2,12,120,1260,23100,360360,8168160,174594420,4908043140,181151410440,6016814703900,267146572853160,12170010541088400,549475975930141260,28284929999070604860,1694636240813882325960,111520100308944333066060,7037302881564418258996200,518649222371297625688019940,39055858108868927267719077300", "code": "\nfrom sympy import prime, primorial\ndef a002110(n): return 1 if n<1 else primorial(n)\ndef a(n): return (prime(n) - 1)*a002110(n)\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A286630", "text": "a(0) = 1; for n >= 1, a(n) = A000040(n) * A002110(n).", "sequence": "1,4,18,150,1470,25410,390390,8678670,184294110,5131136010,187621103670,6217375194030,274567310987970,12474260804615610,562558737261811290,28899819781659096270,1727225399291072370690,113442860659098545705130,7154591262923825229979470,526507543922377892743899030,39613798938995626228686492690", "code": "\nfrom sympy import prime, primorial\ndef a002110(n): return 1 if n<1 else primorial(n)\ndef a(n): return 1 if n==0 else prime(n)*a002110(n)\nprint([a(n) for n in range(41)]) \n"}
{"sequence_id": "A286632", "text": "Base-3 digit sum of A254103: a(n) = A053735(A254103(n)).", "sequence": "0,1,2,1,3,2,4,2,4,1,3,3,5,3,5,2,5,4,6,3,4,2,4,2,6,2,4,3,6,1,3,4,6,3,5,4,7,4,6,4,5,5,7,2,5,3,5,3,7,5,7,3,5,4,6,3,7,6,8,4,4,3,5,5,7,6,8,4,6,3,5,6,8,3,5,5,7,5,7,3,6,4,6,5,8,1,3,5,6,2,4,4,6,2,4,2,8,4,6,6,8,2,4,2,6,3,5,4,7,4,6,5,8,5,7,5,9,5,7,4,5", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a254103(n):\n    if n==0: return 0\n    if n%2==0: return 3*a254103(n/2) - 1\n    else: return floor((3*(1 + a254103((n - 1)/2)))/2)\ndef a(n): return sum(digits(a254103(n), 3)[1:]) \n"}
{"sequence_id": "A286633", "text": "Base-3 {digit+1} product of A254103: a(n) = A006047(A254103(n)).", "sequence": "1,2,3,2,6,4,9,3,12,2,6,6,18,8,18,4,24,12,27,6,12,3,9,4,36,4,12,6,36,2,6,12,48,6,18,12,54,16,36,9,24,24,54,4,18,8,18,6,72,24,54,6,24,12,27,6,72,36,81,12,12,6,18,18,96,36,81,12,36,6,18,36,108,8,24,18,72,24,54,8,48,12,36,18,108,2,6,24,36,4,12,12,36,3,9,4", "code": "\nfrom sympy.ntheory.factor_ import digits\nfrom operator import mul\ndef a006047(n):\n    d=digits(n, 3)\nreturn reduce(mul, [1 + d[i] for i in range(1, len(d))])\ndef a254103(n):\n    if n==0: return 0\n    if n%2==0: return 3*a254103(n/2) - 1\n    else: return floor((3*(1 + a254103((n - 1)/2)))/2)\ndef a(n): return a006047(a254103(n)) \n"}
{"sequence_id": "A286812", "text": "a(n) = 105 - 2^n.", "sequence": "104,103,101,97,89,73,41,-23,-151,-407,-919,-1943,-3991,-8087,-16279,-32663,-65431,-130967,-262039,-524183,-1048471,-2097047,-4194199,-8388503,-16777111,-33554327,-67108759,-134217623,-268435351,-536870807,-1073741719,-2147483543", "code": " [105-2**n for n in range(40)] \n"}
{"sequence_id": "A286840", "text": "One of the two successive approximations up to 13^n for 13-adic integer sqrt(-1). Here the 5 (mod 13) case (except for n=0).", "sequence": "0,5,70,239,239,143044,1999509,6826318,6826318,822557039,85658552023,1188526486815,11941488851037,291518510320809,2108769149874327,13920898306972194,13920898306972194,2675587335039691558,63228498770709057089,513050126578538629605", "code": "\ndef A(k, m, n):\n    ary=[0]\n    a, mod = k, m\n    for i in range(n):\n          b=a%mod\n          ary.append(b)\n          a=b**m\n          mod*=m\n    return ary\ndef a286840(n):\n    return A(5, 13, n)\nprint(a286840(100)) \n"}
{"sequence_id": "A286841", "text": "One of the two successive approximations up to 13^n for 13-adic integer sqrt(-1). Here the 8 (mod 13) case (except for n=0).", "sequence": "0,8,99,1958,28322,228249,2827300,55922199,808904403,9781942334,52199939826,603633907222,11356596271444,11356596271444,1828607235824962,37264994707118563,651495710876207647,5974828584341646375,49226908181248336040", "code": "\ndef A(k, m, n):\n    ary=[0]\n    a, mod = k, m\n    for i in range(n):\n          b=a%mod\n          ary.append(b)\n          a=b**m\n          mod*=m\n    return ary\ndef a286841(n):\n    return A(8, 13, n)\nprint(a286841(100)) \n"}
{"sequence_id": "A286851", "text": "Number of compositions (ordered partitions) of n into unitary divisors of n.", "sequence": "1,1,2,2,2,2,25,2,2,2,129,2,170,2,742,450,2,2,4603,2,1503,3321,29967,2,9278,2,200390,2,13460,2,154004511,2,2,226020,9262157,51886,127654,2,63346598,2044895,170354,2,185493291001,2,1304512,567124,2972038875,2,59489916,2,20367343494,184947044,14324735,2", "code": "\nfrom sympy import divisors, gcd\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n):\n    l=[x for x in divisors(n) if gcd(x, n//x)==1]\n    @cacheit\n    def b(m): return 1 if m==0 else sum(b(m - j) for j in l if j <= m)\n    return b(n)\nprint([a(n) for n in range(61)]) \n"}
{"sequence_id": "A286875", "text": "If n = Product (p_j^k_j) then a(n) = Sum (k_j >= 2, p_j^k_j).", "sequence": "0,0,0,4,0,0,0,8,9,0,0,4,0,0,0,16,0,9,0,4,0,0,0,8,25,0,27,4,0,0,0,32,0,0,0,13,0,0,0,8,0,0,0,4,9,0,0,16,49,25,0,4,0,27,0,8,0,0,0,4,0,0,9,64,0,0,0,4,0,0,0,17,0,0,25,4,0,0,0,16,81,0,0,4,0,0,0,8,0,9,0,4,0,0,0,32,0,49,9,29,0,0,0,8,0,0,0,31", "code": "\nfrom sympy import primefactors, isprime, gcd, divisors\ndef a(n): return sum(d for d in divisors(n) if gcd(d, n//d)==1 and len(primefactors(d))==1 and not isprime(d))\nprint([a(n) for n in range(1, 109)]) \n"}
{"sequence_id": "A286877", "text": "One of the two successive approximations up to 17^n for 17-adic integer sqrt(-1). Here the 4 (mod 17) case (except for n=0).", "sequence": "0,4,38,2928,27493,1029745,23747457,313398285,3596107669,94280954402,450044583893,28673959190179,28673959190179,3524407382568745,13428985415474682,13428985415474682,42949774758062711577,91610966633729580058,6709533061724423693474", "code": "\ndef A(k, m, n):\n    ary=[0]\n    a, mod = k, m\n    for i in range(n):\n          b=a%mod\n          ary.append(b)\n          a=b**m\n          mod*=m\n    return ary\ndef a286877(n):\n    return A(4, 17, n)\nprint(a286877(100)) \n"}
{"sequence_id": "A286878", "text": "One of the two successive approximations up to 17^n for 17-adic integer sqrt(-1). Here the 13 (mod 17) case (except for n=0).", "sequence": "0,13,251,1985,56028,390112,390112,96940388,3379649772,24306922095,1565949316556,5597937117454,553948278039582,6380170650337192,154948841143926247,2848994066094341111,5711417117604156904,735629295252607184119,7353551390343301297535", "code": "\ndef A(k, m, n):\n      ary=[0]\n      a, mod = k, m\n      for i in range(n):\n          b=a%mod\n          ary.append(b)\n          a=b**m\n          mod*=m\n      return ary\ndef a286878(n): return A(13, 17, n)\nprint(a286878(100)) \n"}
{"sequence_id": "A286900", "text": "Sum of the numbers from n to nextprime(n).", "sequence": "3,5,12,9,18,13,45,38,30,21,36,25,75,62,48,33,54,37,105,86,66,45,182,159,135,110,84,57,90,61,238,207,175,142,108,73,195,158,120,81,126,85,225,182,138,93,350,303,255,206,156,105,392,339,285,230,174,117", "code": "\nfrom __future__ import division\nfrom sympy import nextprime\ndef A286900(n):\n    m = nextprime(n)\n    return (m + n)*(m - n + 1)//2 \n"}
{"sequence_id": "A286901", "text": "Sum of the numbers from prevprime(n) to n.", "sequence": "5,7,12,11,18,15,24,34,45,23,36,27,42,58,75,35,54,39,60,82,105,47,72,98,125,153,182,59,90,63,96,130,165,201,238,75,114,154,195,83,126,87,132,178,225,95,144,194,245,297,350,107,162,218,275,333,392,119,180,123", "code": "\nfrom __future__ import division\nfrom sympy import prevprime\ndef A286901(n):\n    m = prevprime(n)\n    return (m + n)*(n - m + 1)//2 \n"}
{"sequence_id": "A287055", "text": "Numbers n such that uphi(n) = uphi(n+1), where uphi(n) is the unitary totient function (A047994).", "sequence": "1,20,35,143,194,208,740,1119,1220,1299,1419,1803,1892,2232,2623,3705,3716,3843,4995,5031,5183,5186,5635,7868,10659,17948,18507,18914,21007,23616,25388,25545,30380,30744,31599,32304,34595,37820,38024,47067,60767,70394", "code": "\nfrom math import prod\nfrom sympy import factorint\nA287055_list, a, n = [], 1, 1\nwhile n < 10**5:\n    b = prod(p**e-1 for p, e in factorint(n+1).items())\n    if a == b:\n        A287055_list.append(n)\n    a, n = b, n+1 \n"}
{"sequence_id": "A287170", "text": "a(n) = number of runs of consecutive prime numbers among the prime divisors of n.", "sequence": "0,1,1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,2,2,2,1,1,1,2,1,2,1,1,1,1,2,2,1,1,1,2,2,2,1,2,1,2,1,2,1,1,1,2,2,2,1,1,2,2,2,2,1,1,1,2,2,1,2,2,1,2,2,2,1,1,1,2,1,2,1,2,1,2,1,2,1,2,2,2,2", "code": "\nfrom sympy import factorint, primepi\ndef a087207(n):\n    f=factorint(n)\n    return sum([2**primepi(i - 1) for i in f])\ndef a069010(n): return sum(1 for d in bin(n)[2:].split('0') if len(d)) \ndef a(n): return a069010(a087207(n)) \n"}
{"sequence_id": "A287178", "text": "Smallest number such that the circular adjacent sum set has no multiple entries.", "sequence": "1,2,4,8,10,16,20,28,42,30,32,52,50,68,44,96,76,142,80,148,180,56,138,226,94,188,108,92,286,306,166,256,98,498,150,266,450,250,262,540,290,460,398,474,412,402,598,272,692,144,544,240,110,906,494,752,854,248", "code": "\na, isums, lsums, rsums, xsums = [], set(), set([0]), set([0]), set([0])\nfor i in range(100):\n    for new in range(1, sum(a)+2):\n        nrsums, nxsums = set([0]), set([0])\n        for x in rsums:\n            xn = x+new\n            if xn in isums or xn in lsums:\n                break\n            nrsums.add(xn)\n        else:\n            for x in xsums.union(lsums):\n                xn = x+new\n                if xn in isums or xn in rsums or xn in lsums:\n                    break\n                nxsums.add(xn)\n            else:\n                a.append(new)\n                isums.update(rsums)\n                xsums, rsums = nxsums, nrsums\n                lsums.add(sum(a))\n                break\nprint(a)\n\n"}
{"sequence_id": "A287198", "text": "Numbers with the property that every cyclic permutation of its digits is a composite number with none of its permutations sharing any common prime factors.", "sequence": "4,6,8,9,25,49,52,56,58,65,85,94,116,134,145,158,161,178,187,253,275,295,325,341,358,413,451,514,527,529,532,581,583,589,611,718,752,781,815,817,835,871,895,899,952,958,989,998,1154,1156,1159,1165,1189,1192", "code": "\nfrom gmpy2 import is_prime, gcd, mpz\nA287198_list, n  = [], 2\nwhile n <= 10**6:\n    s = str(n)\n    if not is_prime(n) and '0' not in s:\n        k = n\n        for i in range(len(s)-1):\n            s = s[1:]+s[0]\n            m = mpz(s)\n            if is_prime(m) or gcd(k,m) > 1:\n                break\n            k *= m\n        else:\n            A287198_list.append(n)\n    n += 1 \n"}
{"sequence_id": "A287298", "text": "a(n) is the largest square with distinct digits in base n.", "sequence": "1,1,225,576,38025,751689,10323369,355624164,9814072356,279740499025,8706730814089,23132511879129,11027486960232964,435408094460869201,18362780530794065025,48470866291337805316,39207739576969100808801,1972312183619434816475625,104566626183621314286288961", "code": "\nfrom gmpy2 import isqrt, mpz, digits\ndef A287298(n): \n    m = isqrt(mpz(''.join(digits(i,n) for i in range(n-1,-1,-1)),n))\n    m2 = m**2\n    d = digits(m2,n)\n    while len(set(d)) < len(d):\n        m -= 1\n        m2 -= 2*m+1\n        d = digits(m2,n)\n    return int(m2) \n"}
{"sequence_id": "A287335", "text": "Nonnegative numbers k such that 3*k + 2 is a cube.", "sequence": "2,41,170,443,914,1637,2666,4055,5858,8129,10922,14291,18290,22973,28394,34607,41666,49625,58538,68459,79442,91541,104810,119303,135074,152177,170666,190595,212018,234989,259562,285791,313730,343433,374954,408347,443666,480965", "code": " [9*n**3-9*n**2+3*n-1 for n in range(1,40)]\n"}
{"sequence_id": "A287349", "text": "Number of matchings in the n-gear graph.", "sequence": "4,13,42,131,398,1186,3482,10103,29034,82777,234424,660098,1849552,5160001,14341098,39723791,109701122,302131618,830079014,2275509227,6225274794,16999389733,46341292012,126130604546,342800478748,930414584821,2522124577962,6828859302683", "code": "\nfrom sympy import lucas, fibonacci\ndef a(n): return lucas(2*n) + n*fibonacci(2*n) \n"}
{"sequence_id": "A287350", "text": "Number of independent vertex sets and vertex covers in the n-gear graph.", "sequence": "5,11,26,63,155,386,971,2463,6290,16151,41651,107778,279635,727031,1893266,4936383,12883115,33647426,87928091,229874703,601171730,1572591911,4114506851,10766734338,28177307555,73748411111,193034371346,505287594063,1322694193115", "code": "\nfrom sympy import lucas\ndef a(n): return 2**n + lucas(2*n) \n"}
{"sequence_id": "A287353", "text": "a(0)=0; for n>0, a(n) = 10*a(n-1) + prime(n).", "sequence": "0,2,23,235,2357,23581,235823,2358247,23582489,235824913,2358249159,23582491621,235824916247,2358249162511,23582491625153,235824916251577,2358249162515823,23582491625158289", "code": "\nfrom sympy import prime\nl = [0]\nfor i in range(20):\n    l += [10 * l[i] + prime(i + 1)]\nprint(l) \n"}
{"sequence_id": "A287392", "text": "Domination number for lion's graph on an n X n board.", "sequence": "0,1,1,1,1,1,4,4,4,4,4,9,9,9,9,9,16,16,16,16,16,25,25,25,25,25,36,36,36,36,36,49,49,49,49,49,64,64,64,64,64,81,81,81,81,81,100,100,100,100,100,121,121,121,121,121,144,144,144,144,144,169,169,169", "code": " [int((n+4)/5)**2 for n in range(64)]\n"}
{"sequence_id": "A287393", "text": "Domination number for knight's graph on a 2 X n board.", "sequence": "0,2,4,4,4,4,4,6,8,8,8,8,8,10,12,12,12,12,12,14,16,16,16,16,16,18,20,20,20,20,20,22,24,24,24,24,24,26,28,28,28,28,28,30,32,32,32,32,32,34,36,36,36,36,36,38,40,40,40,40,40,42,44,44,44,44,44,46", "code": " [2*((i+4)//6+(i+5)//6) for i in range(68)]\n"}
{"sequence_id": "A287394", "text": "Domination number for camel's graph on a 2 X n board.", "sequence": "0,2,4,6,6,6,6,6,6,6,8,10,12,12,12,12,12,12,12,14,16,18,18,18,18,18,18,18,20,22,24,24,24,24,24,24,24,26,28,30,30,30,30,30,30,30,32,34,36,36,36,36,36,36,36,38,40,42,42,42,42,42,42,42,44,46,48,48", "code": " [2*(int((i+6)/9)+int((i+7)/9)+int((i+8)/9)) for i in range(68)]\n"}
{"sequence_id": "A287550", "text": "Initial prime in set of 4 consecutive primes in arithmetic progression with difference 72.", "sequence": "491525857,1470227987,2834347387,4314407477,4766711387,6401372837,6871241197,8971400797,10168905497,11776429517,11871902557,14538547967,14925896087,15218517367,15646776877,15875854927,17310026197,17942416307,18347931587,19241492057,19379888947", "code": "\nfrom gmpy2 import is_prime, next_prime\nA287550_list, p = [], 2\nq, r, s = p+72, p+144, p+216\nwhile s <= 10**10:\n    np = next_prime(p)\n    if np == q and is_prime(r) and is_prime(s) and next_prime(q) == r and next_prime(r) == s:\n        A287550_list.append(p)\n    p, q, r, s = np, np+72, np+144, np+216 \n"}
{"sequence_id": "A287609", "text": "Intersection of A034961 and A127345.", "sequence": "31,71,311,551,1151,14831,45791,455471,2035271,6345239,7241615,8290031,8329991,9086231,9324351,10449575,11497199,15454151,16515815,18337271,20650811,22946591,27609311,33220079,40487471,44106191,45015791,49021199,53315519,54536519", "code": "\nfrom __future__ import division\nfrom sympy import isprime, prevprime, nextprime\nA287609_list, p, q, r = [], 2, 3, 5\nwhile r < 10**6:\n    n = p*(q+r) + q*r\n    m = n//3\n    pm, nm = prevprime(m), nextprime(m)\n    k = n - pm - nm\n    if isprime(m):\n        if m == k:\n            A287609_list.append(n)\n    else:\n        if nextprime(nm) == k or prevprime(pm) == k:\n            A287609_list.append(n)\n    p, q, r = q, r, nextprime(r) \n"}
{"sequence_id": "A287653", "text": "Prime numbers of the form p*q + q*r + r*s with p,q,r,s consecutive primes.", "sequence": "127,1427,2003,2713,7639,76519,81703,139663,166643,173777,349589,371027,653357,696083,752033,793699,883549,938617,974713,1150733,1176983,1207223,1310779,1675577,1702577,1880363,2715169", "code": "\nfrom sympy import nextprime, isprime\nA287653_list, pq, qr, rs, s = [], 6, 15, 35, 7\nwhile s <= 10**6:\n    n = pq+qr+rs\n    if isprime(n):\n        A287653_list.append(n)\n    t = nextprime(s)\n    pq, qr, rs, s = qr, rs, s*t, t \n"}
{"sequence_id": "A287686", "text": "Numbers that are sums of three consecutive primes (A034961) and also sums of squares of three consecutive primes (A133529).", "sequence": "83,366819,1055019,1947411,2740107,3694179,6627579,8851251,9430899,20243811,28391619,37545291,38242083,49459179,56550291,88205211,101931891,103429491,108060339,135085851,176962659,183973851,194907051,196911171,212874531,249687699,271986651", "code": "\nfrom __future__ import division\nfrom sympy import prevprime, nextprime, isprime\nA287686_list, p2, q2, r2, r = [], 4, 9, 25, 5\nwhile r < 10**6:\n    n = p2+q2+r2\n    m = n//3\n    pm, nm = prevprime(m), nextprime(m)\n    k = n - pm - nm\n    if isprime(m):\n        if m == k:\n            A287686_list.append(n)\n    else:\n        if nextprime(nm) == k or prevprime(pm) == k:\n            A287686_list.append(n)\n    s = nextprime(r)\n    p2, q2, r2, r = q2, r2, s**2, s \n"}
{"sequence_id": "A287729", "text": "The c-fusc function c(n) = a(n): a(1)=1, a(2n) = s(n), a(2n+1) = s(n)+s(n+1), where s(n) = A287730(n).", "sequence": "1,0,1,1,2,1,1,0,1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1,3,2,3,1,2,1,1,0,1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1,5,4,7,3,8,5,7,2,7,5,8,3,7,4,5,1,6,5,9,4,11,7,10,3,11,8,13,5,12,7,9,2,9,7,12,5,13,8,11,3,10,7,11,4,9,5,6,1,5,4,7,3", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef c(n): return 1 if n==1 else s(n//2) if n%2==0 else s((n - 1)//2) + s((n + 1)//2)\n@cacheit\ndef s(n): return 0 if n==1 else c(n//2) if n%2==0 else c((n - 1)//2) + c((n + 1)//2)\nprint([c(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A287730", "text": "The s-fusc function s(n) = a(n): a(1) = 0, a(2n) = A287729(n), a(2n+1) = A287729(n) + A287729(n+1).", "sequence": "0,1,1,0,1,1,2,1,3,2,3,1,2,1,1,0,1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1,5,4,7,3,8,5,7,2,7,5,8,3,7,4,5,1,4,3,5,2,5,3,4,1,3,2,3,1,2,1,1,0,1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1,5,4,7,3,8,5,7,2,7,5,8,3,7,4,5,1,6,5,9,4", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef c(n): return 1 if n==1 else s(n//2) if n%2==0 else s((n - 1)//2) + s((n + 1)//2)\n@cacheit\ndef s(n): return 0 if n==1 else c(n//2) if n%2==0 else c((n - 1)//2) + c((n + 1)//2)\nprint([s(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A287731", "text": "Bisection of A287729.", "sequence": "1,1,2,1,1,2,3,3,4,5,5,4,3,3,2,1,1,2,3,3,4,5,5,4,5,7,8,7,7,8,7,5,6,9,11,10,11,13,12,9,9,12,13,11,10,11,9,6,5,7,8,7,7,8,7,5,4,5,5,4,3,3,2,1", "code": "\ndef c(n): return 1 if n==1 else s(n/2) if n%2==0 else s((n - 1)/2) + s((n + 1)/2)\ndef s(n): return 0 if n==1 else c(n/2) if n%2==0 else c((n - 1)/2) + c((n + 1)/2)\ndef a(n): return c(2*n - 1) \n"}
{"sequence_id": "A287732", "text": "Bisection of A287730.", "sequence": "0,1,1,2,3,3,2,1,1,2,3,3,4,5,5,4,5,7,8,7,7,8,7,5,4,5,5,4,3,3,2,1,1,2,3,3,4,5,5,4,5,7,8,7,7,8,7,5,6,9,11,10,11,13,12,9,9,12,13,11,10,11,9,6", "code": "\ndef c(n): return 1 if n==1 else s(n/2) if n%2==0 else s((n - 1)/2) + s((n + 1)/2)\ndef s(n): return 0 if n==1 else c(n/2) if n%2==0 else c((n - 1)/2) + c((n + 1)/2)\ndef a(n): return s(2*n - 1) \n"}
{"sequence_id": "A287804", "text": "Number of quinary sequences of length n such that no two consecutive terms have distance 1.", "sequence": "1,5,17,59,205,713,2481,8635,30057,104629,364225,1267923,4413861,15365465,53490097,186209299,648230545,2256616133,7855718641,27347281995,95201200637,331413874569,1153716087665,4016309864843,13981555011321,48672509644725", "code": "\ndef a(n):\n    if n in [0,1,2]:\n        return [1,5,17][n]\n    return 5*a(n-1)-5*a(n-2)-a(n-3)\n"}
{"sequence_id": "A287805", "text": "Number of quinary sequences of length n such that no two consecutive terms have distance 2.", "sequence": "1,5,19,73,281,1083,4175,16097,62065,239307,922711,3557761,13717913,52893147,203943935,786361409,3032030689,11690820555,45077144455,173807214241,670161078089,2583988659867,9963272432111,38416111919777,148123788152017,571131629935179", "code": "\ndef a(n):\n.if n in [0,1,2,3]:\n..return [1,5,19,73][n]\n.return 4*a(n-1)+a(n-2)-6*a(n-3)\n"}
{"sequence_id": "A287806", "text": "Number of senary sequences of length n such that no two consecutive terms have distance 1.", "sequence": "1,6,26,114,500,2194,9628,42252,185422,813722,3571010,15671340,68773514,301811860,1324498252,5812546998,25508302906,111942925778,491260382084,2155891150146,9461106209228,41519967599596,182209952129086,799626506818554,3509152727035810", "code": "\ndef a(n):\n.if n in [0, 1, 2, 3]:\n..return [1, 6, 26, 114][n]\n.return 5*a(n-1)-2*a(n-2)-3*a(n-3)\n"}
{"sequence_id": "A287807", "text": "Number of senary sequences of length n such that no two consecutive terms have distance 2.", "sequence": "1,6,28,132,624,2952,13968,66096,312768,1480032,7003584,33141312,156826368,742110336,3511703808,16617560832,78635142144,372105487872,1760822074368,8332299518976,39428864667648,186579390892032,882903157346304,4177942598725632", "code": "\ndef a(n):\n.if n in [0, 1, 2]:\n..return [1, 6, 28][n]\n.return 6*a(n-1)-6*a(n-2)\n"}
{"sequence_id": "A287808", "text": "Number of septenary sequences of length n such that no two consecutive terms have distance 1.", "sequence": "1,7,37,197,1049,5587,29757,158491,844153,4496123,23947233,127547675,679344041,3618320227,19271886609,102645866251,546712113769,2911896468083,15509334488577,82605772190267,439974623297369,2343391557436483,12481365289466289", "code": "\ndef a(n):\n.if n in [0,1,2,3,4]:\n..return [1, 7, 37, 197, 1049][n]\n.return 7*a(n-1)-8*a(n-2)-6*a(n-3)+6*a(n-4)\n"}
{"sequence_id": "A287809", "text": "Number of septenary sequences of length n such that no two consecutive terms have distance 2.", "sequence": "1,7,39,219,1231,6921,38913,218789,1230147,6916539,38888455,218651553,1229375193,6912200477,38864063403,218514412227,1228604118319,6907865088537,38839687552689,218377358251349,1227833528067027,6903532420748427,38815326992539159", "code": "\ndef a(n):\n.if n in [0, 1, 2, 3, 4]:\n..return [1, 7, 39, 219, 1231][n]\n.return 6*a(n-1)-13*a(n-3)+6*a(n-4)\n"}
{"sequence_id": "A287810", "text": "Number of septenary sequences of length n such that no two consecutive terms have distance 3.", "sequence": "1,7,41,241,1417,8333,49005,288193,1694833,9967141,58615749,344713305,2027224169,11921900829,70111496093,412318635697,2424804301985,14260029486677,83861794865077,493182755657289,2900358033942041,17056713010658765,100308808541321741", "code": "\ndef a(n):\n.if n in [0, 1, 2, 3]:\n..return [1, 7, 41, 241][n]\n.return 6*a(n-1)+a(n-2)-10*a(n-3)\n"}
{"sequence_id": "A287811", "text": "Number of septenary sequences of length n such that no two consecutive terms have distance 5.", "sequence": "1,7,45,291,1881,12159,78597,508059,3284145,21229047,137226717,887047443,5733964809,37064931183,239591481525,1548743682699,10011236540769,64713650292711,418315611378573,2704034619149571,17479154549033145,112987031151647583", "code": "\ndef a(n):\n.if n in [0, 1]:\n..return [1, 7][n]\n.return 6*a(n-1)-3*a(n-2)\n"}
{"sequence_id": "A287812", "text": "Number of octonary sequences of length n such that no two consecutive terms have distance 1.", "sequence": "1,8,50,314,1972,12386,77796,488636,3069120,19277130,121079578,760500364,4776699874,30002433636,188445170924,1183623397912,7434334035874,46695023649050,293291264969380,1842161313673506,11570608166423524,72674945645197500", "code": "\ndef a(n):\n.if n in [0, 1, 2, 3, 4]:\n..return [1, 8, 50, 314, 1972][n]\n.return 7*a(n-1)-3*a(n-2)-10*a(n-3)+3*a(n-4)\n"}
{"sequence_id": "A287813", "text": "Number of octonary sequences of length n such that no two consecutive terms have distance 2.", "sequence": "1,8,52,340,2224,14548,95164,622504,4072036,26636740,174241072,1139777284,7455717772,48770692552,319027694548,2086881784180,13651089405616,89296980486772,584125595190556,3820988224873576,24994540788543364,163498820845182820", "code": "\ndef a(n):\n.if n in [0, 1, 2]:\n..return [1, 8, 52][n]\n.return 7*a(n-1)-3*a(n-2)\n"}
{"sequence_id": "A287814", "text": "Number of octonary sequences of length n such that no two consecutive terms have distance 3.", "sequence": "1,8,54,366,2482,16834,114178,774426,5252642,35626714,241642738,1638972746,11116542082,75399367194,511405842898,3468675479466,23526734684322,159573084361274,1082324835734258,7341006503296586,49791314679463362,337715954398900954", "code": "\ndef a(n):\n.if n in [0, 1, 2, 3]:\n..return [1, 8, 54, 366][n]\n.return 7*a(n-1)-10*a(n-3)\n"}
{"sequence_id": "A287815", "text": "Number of octonary sequences of length n such that no two consecutive terms have distance 7.", "sequence": "1,8,62,482,3746,29114,226274,1758602,13667858,106226618,825593474,6416514026,49869159026,387583197338,3012297335522,23411580532682,181954847741906,1414153417389434,10990803008177474,85420541561578922,663888608980117298,5159743512230294618", "code": "\ndef a(n):\n.if n in [0, 1]:\n..return [1, 8][n]\n.return 7*a(n-1)+6*a(n-2)\n"}
{"sequence_id": "A287816", "text": "Number of nonary sequences of length n such that no two consecutive terms have distance 1.", "sequence": "1,9,65,471,3413,24733,179233,1298853,9412437,68209395,494295113,3582023557,25957960001,188110345129,1363185009337,9878634630295,71587804656589,518777540353453,3759441118026705,27243657291488469,197427447142906157,1430703538380753875", "code": "\ndef a(n):\n.if n in [0, 1, 2, 3, 4]:\n..return [1, 9, 65 , 471, 3413][n]\n.return 9*a(n-1)-11*a(n-2)-15*a(n-3)+19*a(n-4)+a(n-5)\n"}
{"sequence_id": "A287817", "text": "Number of nonary sequences of length n such that no two consecutive terms have distance 2.", "sequence": "1,9,67,501,3747,28025,209609,1567743,11725731,87701095,655949055,4906086571,36694443381,274451368893,2052723708275,15353082914309,114831408642039,858866749063989,6423783365292409,48045861327359751,359352839194448551,2687733333725785179", "code": "\ndef a(n):\n.if n in [0, 1, 2, 3, 4]:\n..return [1, 9, 67 , 501, 3747][n]\n.return 8*a(n-1)-a(n-2)-23*a(n-3)+10*a(n-4)+a(n-5)\n"}
{"sequence_id": "A287818", "text": "Number of nonary sequences of length n such that no two consecutive terms have distance 3.", "sequence": "1,9,69,531,4089,31491,242529,1867851,14385369,110789811,853254609,6571393371,50609994249,389776014531,3001884188289,23119197549291,178053936060729,1371293449053651,10561101680875569,81336980637343611,626421808927336809,4824426473972595171", "code": "\ndef a(n):\n.if n in [0, 1, 2]:\n..return [1, 9, 69][n]\n.return 9*a(n-1)-10*a(n-2)\n"}
{"sequence_id": "A287819", "text": "Number of nonary sequences of length n such that no two consecutive terms have distance 4.", "sequence": "1,9,71,561,4433,35031,276827,2187585,17287073,136608591,1079529611,8530826457,67413620993,532726379847,4209793089371,33267280400913,262889866978817,2077449112980255,16416740845208075,129730917736941417,1025179795159015841", "code": "\ndef a(n):\n    if n in [0, 1, 2, 3]:\n        return [1, 9, 71, 561][n]\n    return 8*a(n-1)+a(n-2)-14*a(n-3)\n"}
{"sequence_id": "A287823", "text": "a(n) = A287729(n)*A001511(n).", "sequence": "1,0,1,3,2,2,1,0,1,2,2,3,3,4,3,5,4,6,5,6,5,6,4,4,3,4,3,3,2,2,1,0,1,2,2,3,3,4,3,4,4,6,5,6,5,6,4,5,5,8,7,9,8,10,7,8,7,10,8,9,7,8,5,7,6,10,9,12,11,14,10,12,11,16,13,15,12,14,9,10,9", "code": "\ndef c(n): return 1 if n==1 else s(n/2) if n%2==0 else s((n - 1)/2) + s((n + 1)/2)\ndef s(n): return 0 if n==1 else c(n/2) if n%2==0 else c((n - 1)/2) + c((n + 1)/2)\ndef a001511(n): return bin(n)[2:][::-1].index(\"1\") + 1\ndef a(n): return c(n)*a001511(n) \n"}
{"sequence_id": "A287824", "text": "a(n) = A287730(n)*A001511(n).", "sequence": "0,2,1,0,1,2,2,4,3,4,3,3,2,2,1,0,1,2,2,3,3,4,3,4,4,6,5,6,5,6,4,6,5,8,7,9,8,10,7,8,7,10,8,9,7,8,5,5,4,6,5,6,5,6,4,4,3,4,3,3,2,2,1,0,1,2,2,3,3,4,3,4,4,6,5,6,5,6,4,5,5,8,7,9,8", "code": "\ndef c(n): return 1 if n==1 else s(n/2) if n%2==0 else s((n - 1)/2) + s((n + 1)/2)\ndef s(n): return 0 if n==1 else c(n/2) if n%2==0 else c((n - 1)/2) + c((n + 1)/2)\ndef a001511(n): return bin(n)[2:][::-1].index(\"1\") + 1\ndef a(n): return s(n)*a001511(n) \n"}
{"sequence_id": "A287825", "text": "Number of sequences over the alphabet {0,1,...,9} such that no two consecutive terms have distance 1.", "sequence": "1,10,82,674,5540,45538,374316,3076828,25291120,207889674,1708825732,14046322404,115458919774,949057110644,7801124426174,64124215108032,527092600834054,4332631742719370,35613662169258228,292739611493034596,2406281042646218328", "code": "\ndef a(n):\n    if n in [0, 1, 2, 3, 4, 5]:\n        return [1, 10, 82, 674, 5540, 45538][n]\n    return 9*a(n-1) - 4*a(n-2) - 21*a(n-3) + 9*a(n-4) + 5*a(n-5)\n"}
{"sequence_id": "A287826", "text": "Number of sequences over the alphabet {0,1,...,9} such that no two consecutive terms have distance 2.", "sequence": "1,10,84,708,5968,50308,424080,3574860,30134944,254028100,2141377008,18051134892,152165391616,1282706408548,10812811724688,91148603152524,768354066287200,6476983198439812,54598931916359472,460251829451302764,3879778213203474880", "code": "\ndef a(n):\n.if n in [0, 1, 2]:\n..return [1, 10, 84][n]\n.return 10*a(n-1)-13*a(n-2)-2*a(n-3)\n"}
{"sequence_id": "A287827", "text": "Number of sequences over the alphabet {0,1,...,9} such that no two consecutive terms have distance 3.", "sequence": "1,10,86,742,6404,55274,477082,4117804,35541714,306768722,2647791524,22853698754,197255539962,1702558017644,14695170558994,126837403201602,1094762853302164,9449150445514434,81557794797885642,703944119701429084,6075903902137709074", "code": "\ndef a(n):\n.if n in [0, 1, 2, 3, 4]:\n..return [1, 10, 86, 742, 6404][n]\n.return 9*a(n-1)-a(n-2)-20*a(n-3)+10*a(n-4)\n"}
{"sequence_id": "A287828", "text": "Number of sequences over the alphabet {0,1,...,9} such that no two consecutive terms have distance 4.", "sequence": "1,10,88,776,6844,60364,532412,4695892,41417932,365307620,3222026092,28418383780,250651147340,2210751960772,19498910274028,171981076403492,1516879160180620,13378927697789188,118002614210453804,1040787219651555556,9179779989094951372", "code": "\ndef a(n):\n.if n in [0, 1, 2, 3]:\n..return [1, 10, 88, 776][n]\n.return 9*a(n-1)-14*a(n-3)\n"}
{"sequence_id": "A287829", "text": "Number of sequences over the alphabet {0,1,...,9} such that no two consecutive terms have distance 6.", "sequence": "1,10,92,848,7816,72040,663992,6120008,56408056,519912520,4792028792,44168084168,407096815096,3752207504200,34584061167992,318760965520328,2938016812018936,27079673239211080,249593092776937592,2300497181470860488,21203660818791619576", "code": "\ndef a(n):\n.if n in [0, 1]:\n..return [1, 10][n]\n.return 9*a(n-1)+2*a(n-2)\n"}
{"sequence_id": "A287830", "text": "Number of sequences over the alphabet {0,1,...,9} such that no two consecutive terms have distance 7.", "sequence": "1,10,94,886,8350,78694,741646,6989590,65872894,620814406,5850821230,55140648694,519669123166,4897584703270,46156938822094,435002788211926,4099652849195710,38636886795609094,364130592557264686,3431722880197818550,32342028292009425694", "code": "\ndef a(n):\n.if n in [0, 1]:\n..return [1, 10][n]\n.return 9*a(n-1)+4*a(n-2)\n"}
{"sequence_id": "A287831", "text": "Number of sequences over the alphabet {0,1,...,9} such that no two consecutive terms have distance 8.", "sequence": "1,10,96,924,8892,85572,823500,7924932,76265388,733938084,7063035084,67970944260,654116708844,6294876045156,60578584659468,582976518206148,5610260171812140,53990200655546148,519573366930788172,5000101506310370436,48118353758378062956", "code": "\ndef a(n):\n.if n in [0, 1]:\n..return [1, 10][n]\n.return 9*a(n-1)+6*a(n-2)\n"}
{"sequence_id": "A287832", "text": "Number of words of length n over the alphabet {0,1,...,10} such that no two consecutive terms have distance 1.", "sequence": "1,11,101,929,8545,78599,722973,6650087,61169169,562649373,5175390189,47604538285,437878494689,4027716327495,37047945974857,340776308298291,3134546038698889,28832341420057365,265207115001514409,2439441626426418609,22438596523731989473", "code": "\ndef a(n):\n.if n in [0,1,2,3,4,5,6]:\n..return [1, 11, 101, 929, 8545, 78599, 722973][n]\n.return 11*a(n-1) - 14*a(n-2) - 28*a(n-3) + 39*a(n-4) + 9*a(n-5) - 10*a(n-6)\n"}
{"sequence_id": "A287833", "text": "Number of words of length n over the alphabet {0,1,...,10} such that no two consecutive terms have distance 2.", "sequence": "1,11,103,967,9079,85243,800351,7514541,70554457,662439857,6219685951,58396989455,548292695881,5147951686649,48334414751849,453814602701801,4260891430727991,40005754941255473,375616336261903907,3526683405274793053,33112233522155404139", "code": "\ndef a(n):\n.if n in [0,1,2,3,4,5]:\n..return [1, 11, 103, 967, 9079, 85243][n]\n.return 10*a(n-1) - 2*a(n-2) - 37*a(n-3) + 16*a(n-4) + 19*a(n-5) + a(n-6)\n"}
{"sequence_id": "A287834", "text": "Number of words of length n over the alphabet {0,1,...,10} such that no two consecutive terms have distance 3.", "sequence": "1,11,105,1005,9621,92105,881753,8441329,80811789,773639469,7406320733,70903294113,678781988705,6498216958121,62209699634757,595555173609653,5701457600593525,54582044135967257,522532964509030377,5002390498942001761,47889630709552579709", "code": "\ndef a(n):\n.if n in [0,1,2,3,4]:\n..return [1, 11, 105, 1005, 9621][n]\n.return 10*a(n-1) - 2*a(n-2) - 21*a(n-3) + 10*a(n-4)\n"}
{"sequence_id": "A287835", "text": "Number of words of length n over the alphabet {0,1,...,10} such that no two consecutive terms have distance 4.", "sequence": "1,11,107,1043,10169,99149,966719,9425675,91901945,896059709,8736735695,85184670011,830565128489,8098152315149,78958372642847,769857662314475,7506244118089817,73187166301583837,713587411625345903,6957599532298617755,67837787583138657929", "code": "\ndef a(n):\n.if n in [0,1,2,3]:\n..return [1, 11, 107, 1043][n]\n.return 10*a(n-1) - a(n-2) - 14*a(n-3)\n"}
{"sequence_id": "A287836", "text": "Number of words over the alphabet {0,1,...,10} such that no two consecutive terms have distance 5.", "sequence": "1,11,109,1081,10721,106329,1054553,10458881,103729441,1028771337,10203182953,101193470929,1003620008177,9953736259545,98719500126905,979083577381409,9710388021269185,96306012787788969,955147011506293513,9472989143467878769,93951530216004879761", "code": "\ndef a(n):\n.if n in [0,1,2,3]:\n..return [1, 11, 109, 1081][n]\n.return 10*a(n-1) + a(n-2) - 18*a(n-3)\n"}
{"sequence_id": "A287837", "text": "Number of words over the alphabet {0,1,...,10} such that no two consecutive terms have distance 7.", "sequence": "1,11,113,1163,11969,123179,1267697,13046507,134268161,1381821131,14221015793,146355621323,1506219260609,15501259470059,159531252482417,1641816303234347,16896756789790721,173893016807610251,1789620438445474673,18417883434877577483", "code": "\ndef a(n):\n.if n in [0,1,2]:\n..return [1, 11, 113][n]\n.return 10*a(n-1) + 3*a(n-2)\n"}
{"sequence_id": "A287838", "text": "Number of words of length n over the alphabet {0,1,...,10} such that no two consecutive terms have distance 8.", "sequence": "1,11,115,1205,12625,132275,1385875,14520125,152130625,1593906875,16699721875,174966753125,1833166140625,19206495171875,201230782421875,2108340300078125,22089556912890625,231437270629296875,2424820490857421875,25405391261720703125", "code": "\ndef a(n):\n.if n in [0,1,2]:\n..return [1, 11, 115][n]\n.return 10*a(n-1) + 5*a(n-2)\n"}
{"sequence_id": "A287839", "text": "Number of words of length n over the alphabet {0,1,...,10} such that no two consecutive terms have distance 9.", "sequence": "1,11,117,1247,13289,141619,1509213,16083463,171399121,1826575451,19465548357,207441511727,2210673955769,23558830139779,251063019088173,2675542001860183,28512861152219041,303857405535211691,3238164083417650197,34508642672922983807", "code": "\ndef a(n):\n.if n in [0,1,2]:\n..return [1, 11, 117][n]\n.return 10*a(n-1) + 7*a(n-2)\n"}
{"sequence_id": "A287841", "text": "Number of iterations of number of distinct prime factors (A001221) needed to reach 1 starting at n (n is counted).", "sequence": "1,2,2,2,2,3,2,2,2,3,2,3,2,3,3,2,2,3,2,3,3,3,2,3,2,3,2,3,2,3,2,2,3,3,3,3,2,3,3,3,2,3,2,3,3,3,2,3,2,3,3,3,2,3,3,3,3,3,2,3,2,3,3,2,3,3,2,3,3,3,2,3,2,3,3,3,3,3,2,3,2,3,2,3,3,3,3,3,2,3,3,3,3,3,3,3,2,3,3,3,2,3,2,3,3", "code": "\nfrom sympy import primefactors\ndef a(n): return 1 if n==1 else a(len(primefactors(n))) + 1 \n"}
{"sequence_id": "A287847", "text": "Number A(n,k) of Dyck paths of semilength n such that no level has more than k peaks; square array A(n,k), n >= 0, k >= 0, read by descending antidiagonals.", "sequence": "1,1,0,1,1,0,1,1,1,0,1,1,2,3,0,1,1,2,4,5,0,1,1,2,5,12,13,0,1,1,2,5,13,31,31,0,1,1,2,5,14,40,90,71,0,1,1,2,5,14,41,119,264,181,0,1,1,2,5,14,42,130,376,797,447,0,1,1,2,5,14,42,131,414,1202,2402,1111,0", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([b(n - j, k, i)*sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(0, i - j), min(k, i - 1) + 1)]) for i in range(1, min(j + k, n - j) + 1)])\n@cacheit\ndef A(n, k):\n    if n==0: return 1\n    m=min(n, k)\n    return sum([b(n, m , j) for j in range(1, m + 1)])\nfor d in range(21): print([A(n, d - n) for n in range(d + 1)]) \n"}
{"sequence_id": "A287865", "text": "a(n) = gpf(2*a(n-1)+1), with a(1)=1, where gpf = A006530.", "sequence": "1,3,7,5,11,23,47,19,13,3,7,5,11,23,47,19,13,3,7,5,11,23,47,19,13,3,7,5,11,23,47,19,13,3,7,5,11,23,47,19,13,3,7,5,11,23,47,19,13,3,7,5,11,23,47,19,13,3,7,5,11,23,47,19,13,3,7,5,11,23,47,19,13,3,7,5", "code": "\nfrom sympy import primefactors\nl=[0, 1]\nfor n in range(2, 77):\n    l.append(primefactors(2*l[n - 1] + 1)[-1])\nprint(l[1:]) \n"}
{"sequence_id": "A287874", "text": "Concatenate prime factorization as in A080670, but write everything in binary.", "sequence": "1,10,11,1010,101,1011,111,1011,1110,10101,1011,101011,1101,10111,11101,10100,10001,101110,10011,1010101,11111,101011,10111,101111,10110,101101,1111,1010111,11101,1011101,11111,10101,111011,1010001,101111,10101110,100101", "code": "\nfrom sympy import factorint\ndef a(n):\n    f=factorint(n)\n    return 1 if n==1 else int(\"\".join(bin(i)[2:] + bin(f[i])[2:] if f[i]!=1 else bin(i)[2:] for i in f))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A287883", "text": "Partial sums of A037276.", "sequence": "1,3,6,28,33,56,63,285,318,343,354,577,590,617,652,2874,2891,3124,3143,3368,3405,3616,3639,5862,5917,6130,6463,6690,6719,6954,6985,29207,29518,29735,29792,32025,32062,32281,32594,34819,34860,35097,35140,37351,37686,37909,37956,60179,60256,60511", "code": "\nfrom sympy import factorint\ndef a037276(n):\n    f=factorint(n)\n    l=sorted([i for i in f])\n    return 1 if n==1 else int(\"\".join(str(i)*f[i] for i in l))\nl=[0, 1]\nfor n in range(2, 101): l.append(l[n - 1] + a037276(n))\nprint(l[1:]) \n"}
{"sequence_id": "A287901", "text": "Number of Dyck paths of semilength n such that each positive level up to the highest nonempty level has at least one peak.", "sequence": "1,1,1,3,6,17,49,147,459,1476,4856,16282,55466,191474,668510,2356944,8380944,30025814,108289093,392871484,1432934360,5251507624,19329771911,71430479820,264914270527,985737417231,3679051573264,13769781928768,51670641652576", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(k, i - j), i)])*b(n - j, k, i) for i in range(1, n - j + 1)])\ndef a(n): return 1 if n==0 else sum([b(n, 1, j) for j in range(1, n + 1)])\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A287922", "text": "a(n) = prime(1)^2 + prime(n)^2.", "sequence": "8,13,29,53,125,173,293,365,533,845,965,1373,1685,1853,2213,2813,3485,3725,4493,5045,5333,6245,6893,7925,9413,10205,10613,11453,11885,12773,16133,17165,18773,19325,22205,22805,24653,26573,27893,29933,32045,32765,36485", "code": "\nfrom sympy import prime, primerange\ndef aupton(terms): return [4 + p*p for p in primerange(2, prime(terms)+1)]\nprint(aupton(43)) \n"}
{"sequence_id": "A287966", "text": "Number of Dyck paths of semilength n such that no level has more than two peaks.", "sequence": "1,1,2,4,12,31,90,264,797,2402,7355,22725,70573,220007,688379,2160568,6798020,21428295,67644503,213806475,676499166,2142338437,6789119425,21527297986,68292751071,216737768906,688082702872,2185085230180,6940609839680,22050162168754", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum(b(n - j, k, i)*sum(binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(0, i - j), min(k, i - 1) + 1)) for i in range(1, min(j + k, n - j) + 1))\ndef a(n):\n    if n==0: return 1\n    m=min(n, 2)\n    return sum(b(n, m , j) for j in range(1, m + 1))\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A287991", "text": "Expansion of Jacobi theta constant (theta_2/2)^48.", "sequence": "1,48,1128,17344,196836,1764192,13051008,82244736,452197434,2210431056,9753024192,39328459968,146436844568,507826976160,1652238451200,5074887938688,14794635174459,41126600601168,109456398969568,279899944411776,689873759134308", "code": "\nfrom sympy import divisors\nfrom sympy.core.cache import cacheit\ndef a002129(n): return -sum((-1)**d*d for d in divisors(n))\n@cacheit\ndef a(n): return 1 if n==0 else 48*sum(a002129(k)*a(n - k) for k in range(1, n + 1))//n\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A288002", "text": "L-fusc, sequence l of the mutual diatomic recurrence pair: l(1)=0, r(1)=1, l(2n) = l(n), r(2n) = r(n), l(2n+1) = l(n)+r(n), r(2n+1) = l(n+1)+r(n+1), where r(n) = A288003(n).", "sequence": "0,0,1,0,1,1,2,0,1,1,3,1,2,2,3,0,1,1,4,1,3,3,5,1,2,2,5,2,3,3,4,0,1,1,5,1,4,4,7,1,3,3,8,3,5,5,7,1,2,2,7,2,5,5,8,2,3,3,7,3,4,4,5,0,1,1,6,1,5,5,9,1,4,4,11,4,7,7,10,1,3,3,11,3,8,8", "code": "\ndef l(n): return 0 if n==1 else l(n//2) if n%2==0 else l((n - 1)//2) + r((n - 1)//2)\ndef r(n): return 1 if n==1 else r(n//2) if n%2==0 else l((n + 1)//2) + r((n + 1)//2)\nprint([l(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A288003", "text": "R-fusc, sequence r of the mutual diatomic recurrence pair: l(1)=0, r(1)=1, l(2n) = l(n), r(2n) = r(n), l(2n+1) = l(n)+r(n), r(2n+1) = l(n+1)+r(n+1), where l(n) = A288002(n).", "sequence": "1,1,1,1,2,1,1,1,3,2,2,1,3,1,1,1,4,3,3,2,5,2,2,1,5,3,3,1,4,1,1,1,5,4,4,3,7,3,3,2,8,5,5,2,7,2,2,1,7,5,5,3,8,3,3,1,7,4,4,1,5,1,1,1,6,5,5,4,9,4,4,3,11,7,7,3,10,3,3,2,11,8,8,5,13,5", "code": "\ndef l(n): return 0 if n==1 else l(n//2) if n%2==0 else l((n - 1)//2) + r((n - 1)//2)\ndef r(n): return 1 if n==1 else r(n//2) if n%2==0 else l((n + 1)//2) + r((n + 1)//2)\nprint([r(n) for n in range(1, 151)]) \n"}
{"sequence_id": "A288040", "text": "Integers whose number of distinct decimal digits is prime.", "sequence": "10,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,34,35,36,37,38,39,40,41,42,43,45,46,47,48,49,50,51,52,53,54,56,57,58,59,60,61,62,63,64,65,67,68,69,70,71,72,73,74,75,76,78,79,80,81,82,83,84,85,86,87,89,90,91,92,93,94,95,96,97,98,100,101", "code": "\nfrom sympy import isprime\nprint([n for n in range(1, 100) if isprime(len(set(str(n))))])\n"}
{"sequence_id": "A288104", "text": "Number of solutions to x^9 + y^9 = z^9 mod n.", "sequence": "1,4,9,20,25,36,55,112,189,100,121,180,109,220,225,704,289,756,487,500,495,484,529,1008,725,436,5103,1100,841,900,1081,4864,1089,1156,1375,3780,973,1948,981,2800,1681,1980,1513,2420,4725,2116,2209,6336,2989,2900,2601", "code": "\ndef A288104(n):\n    ndict = {}\n    for i in range(n):\n        m = pow(i,9,n)\n        if m in ndict:\n            ndict[m] += 1\n        else:\n            ndict[m] = 1\n    count = 0\n    for i in ndict:\n        ni = ndict[i]\n        for j in ndict:\n            k = (i+j) % n\n            if k in ndict:\n                count += ni*ndict[j]*ndict[k]\n    return count \n"}
{"sequence_id": "A288105", "text": "Number of solutions to x^10 + y^10 = z^10 mod n.", "sequence": "1,4,9,24,25,36,49,192,99,100,201,216,169,196,225,1024,289,396,361,600,441,804,529,1728,3125,676,1377,1176,841,900,601,6144,1809,1156,1225,2376,1369,1444,1521,4800,1201,1764,1849,4824,2475,2116,2209,9216,2695,12500", "code": "\ndef A288105(n):\n    ndict = {}\n    for i in range(n):\n        m = pow(i,10,n)\n        if m in ndict:\n            ndict[m] += 1\n        else:\n            ndict[m] = 1\n    count = 0\n    for i in ndict:\n        ni = ndict[i]\n        for j in ndict:\n            k = (i+j) % n\n            if k in ndict:\n                count += ni*ndict[j]*ndict[k]\n    return count \n"}
{"sequence_id": "A288184", "text": "Least odd number k such that the continued fraction for sqrt(k) has period n.", "sequence": "5,3,41,7,13,19,73,31,113,43,61,103,193,179,109,133,157,139,337,151,181,253,853,271,457,211,949,487,821,379,601,463,613,331,1061,1177,421,619,541,589,1117,571,1153,823,1249,739,1069,631,1021,1051,1201,751", "code": "\nfrom sympy import continued_fraction_periodic\ndef A288184(n):\n    d = 1\n    while True:\n        s = continued_fraction_periodic(0,1,d)[-1]\n        if isinstance(s, list) and len(s) == n:\n            return d\n        d += 2 \n"}
{"sequence_id": "A288185", "text": "Least even number k such that the continued fraction for sqrt(k) has period n.", "sequence": "2,6,130,14,74,22,58,44,106,86,298,46,746,134,1066,94,1018,424,922,268,394,166,586,382,1306,214,1354,334,1642,436,2122,508,1114,454,4138,478,3194,1108,4874,526,3418,724,2458,604,9914,694,4618,844,2746,1318", "code": "\nfrom sympy import continued_fraction_periodic\ndef A288185(n):\n    d = 2\n    while True:\n        s = continued_fraction_periodic(0,1,d)[-1]\n        if isinstance(s, list) and len(s) == n:\n            return d\n        d += 2 \n"}
{"sequence_id": "A288310", "text": "a(0) = a(1) = 1; a(2*n) = a(n) - a(n-1), a(2*n+1) = Sum_{k=0..n} a(n-k).", "sequence": "1,1,0,2,-1,2,2,4,-3,3,3,5,0,7,2,11,-7,8,6,11,0,14,2,19,-5,19,7,26,-5,28,9,39,-18,32,15,40,-2,46,5,57,-11,57,14,71,-12,73,17,92,-24,87,24,106,-12,113,19,139,-31,134,33,162,-19,171,30,210,-57,192,50,224,-17,239,25", "code": "\ndef a(n): return 1 if n<2 else a(n/2) - a(n/2 - 1) if n%2==0 else sum([a((n - 1)/2 - k) for k in range((n + 1)/2)]) \n"}
{"sequence_id": "A288312", "text": "Number of endofunctions on [2n] such that the image size equals n.", "sequence": "1,2,84,10800,2857680,1285956000,880599202560,853262368358400,1111400775560275200,1873276460474747328000,3967400888465895264384000,10313998054713896966296473600,32291970618091110826769565696000,119851615755915509174015455948800000", "code": "\nfrom mpmath import *\nmp.dps=100\ndef a(n): return int(stirling2(2*n, n)*fac(n)*binomial(2*n, n))\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A288386", "text": "Number T(n,k) of Dyck paths of semilength n such that no positive level has fewer than k peaks; triangle T(n,k), n >= 0, 0 <= k <= n, read by rows.", "sequence": "1,1,1,2,1,1,5,3,1,1,14,6,1,1,1,42,17,4,1,1,1,132,49,14,1,1,1,1,429,147,35,5,1,1,1,1,1430,459,91,30,1,1,1,1,1,4862,1476,268,96,6,1,1,1,1,1,16796,4856,864,245,57,1,1,1,1,1,1,58786,16282,2833,592,247,7,1,1,1,1,1,1", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum(sum(binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(k, i - j), i))*b(n - j, k, i) for i in range(1, n - j + 1))\n@cacheit\ndef T(n, k): return 1 if n==0 else sum(b(n, k, j) for j in range(k, n + 1))\nfor n in range(16): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A288507", "text": "Least number k such that both prime(k+1) -/+ prime(k) are products of n prime factors (counting multiplicity).", "sequence": "24,319,738,57360,1077529,116552943", "code": "\nfrom sympy import factorint, nextprime\ndef A288507(n):\n    k, p, q = 1, 2, 3\n    while True:\n        if sum(factorint(q-p).values()) == n and sum(factorint(q+p).values()) == n:\n            return k\n        k += 1\n        p, q = q, nextprime(q) \n"}
{"sequence_id": "A288533", "text": "Parse A004736 into distinct phrases [1], [2], [1,3], [2,1], [4], [3], [2,1,5], [4,3], [2,1,6], ... a(n) is the length of n-th phrase.", "sequence": "1,1,2,2,1,1,3,2,3,1,3,2,1,2,2,2,1,2,4,1,1,2,3,3,2,3,5,1,3,3,3,1,1,2,2,4,3,2,3,4,4,1,3,4,4,2,1,2,2,5,5,1,2,4,3,5,1,1,2,3,4,5,2,2,3,5,5,3,1,3,3,3,4,5,1,2,2,4,5,6,1,2,4,4,6,4,1,2,3,4,4,6,2,1,2,3,3,5,5,4,1,2,3,5,6,6,1,1,2,3,4,5,7,3,2,3,4,4,7,6,1,3,3,4,5,6,5,1,2,2", "code": "\na = set()\ni = 2\ns = \"1\"\nseq = \"\"\nwhile i < 100:\n    j = i\n    while j > 0:\n        if s not in a:\n            seq = seq + \",\" + str(len(s)-len(s.replace(\",\",\"\"))+1)\n            a.add(s)\n            s = str(j)\n        else:\n            s = s + \",\" + str(j)\n        j -= 1\n    i += 1\nprint(seq[1:])\n"}
{"sequence_id": "A288574", "text": "Total number of distinct primes in all representations of 2*n+1 as a sum of 3 odd primes.", "sequence": "0,0,0,0,1,2,4,4,6,7,9,10,12,15,17,16,19,19,23,25,26,26,28,33,32,35,43,39,41,45,45,48,54,55,52,60,59,56,75,67,67,81,74,76,92,83,85,100,96,81,106,103,91,121,108,98,131,120,116,143,133,129,151,144,124,163", "code": "\nfrom sympy import primerange, isprime\ndef a(n):\n    n=2*n + 1\n    c=0\n    for p in primerange(3, n//3 + 1):\n        for q in primerange(p, (n - p)//2 + 1):\n            r=n - p - q\n            if isprime(r): c+=1 if p==q and p==r else 2 if p==q or q==r else 3\n    return c\nprint([a(n) for n in range(66)]) \n"}
{"sequence_id": "A288678", "text": "Number of Dyck paths of semilength n such that no positive level has fewer than two peaks.", "sequence": "1,0,1,1,1,4,14,35,91,268,864,2833,9279,30670,102975,351148,1212886,4232714,14900843,52865511,188871400,679029570,2455099043,8922220725,32576194260,119447959183,439700905503,1624436294053,6021371511844,22388679839583,83484414608203", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum(sum(binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(k, i - j), i))*b(n - j, k, i) for i in range(1, n - j + 1))\ndef a(n): return 1 if n==0 else sum(b(n, 2, j) for j in range(2, n + 1))\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A288679", "text": "Number of Dyck paths of semilength n such that no positive level has fewer than three peaks.", "sequence": "1,0,0,1,1,1,1,5,30,96,245,592,1543,4884,17660,64495,226442,766937,2558655,8590293,29408344,102893203,366035420,1314955687,4747101946,17184305311,62359953380,226978626707,829122987011,3040369502702,11191473790567,41342469523031", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(k, i - j), i)])*b(n - j, k, i) for i in range(1, n - j + 1)])\ndef a(n): return 1 if n==0 else sum([b(n, 3, j) for j in range(3, n + 1)])\nprint([a(n) for n in range(36)]) \n"}
{"sequence_id": "A288680", "text": "Number of Dyck paths of semilength n such that no positive level has fewer than four peaks.", "sequence": "1,0,0,0,1,1,1,1,1,6,57,247,718,1795,4210,9969,27596,98507,402924,1626525,6142611,21729644,73308577,241270869,793679894,2666563900,9263663359,33259282181,122178034000,453573262015,1685632454779,6240174176549,22987207140830", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(k, i - j), i)])*b(n - j, k, i) for i in range(1, n - j + 1)])\ndef a(n): return 1 if n==0 else sum([b(n, 4, j) for j in range(4, n + 1)])\nprint([a(n) for n in range(36)]) \n"}
{"sequence_id": "A288681", "text": "Number of Dyck paths of semilength n such that no positive level has fewer than five peaks.", "sequence": "1,0,0,0,0,1,1,1,1,1,1,7,98,575,2009,5468,13365,30910,70156,170830,531334,2203895,10091063,44034478,176213307,650957418,2258314543,7491190627,24204620623,77794583961,254583038843,865776314524,3087754003802,11479621448305", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(k, i - j), i)])*b(n - j, k, i) for i in range(1, n - j + 1)])\ndef a(n): return 1 if n==0 else sum([b(n, 5, j) for j in range(5, n + 1)])\nprint([a(n) for n in range(36)]) \n"}
{"sequence_id": "A288682", "text": "Number of Dyck paths of semilength n such that no positive level has fewer than six peaks.", "sequence": "1,0,0,0,0,0,1,1,1,1,1,1,1,8,156,1213,5232,16091,41834,100320,229851,513699,1166304,3068322,11294356,54431307,271824026,1253186445,5233138157,20031588131,71538367677,242280234545,789260222205,2507719402158,7900354628357", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(k, i - j), i)])*b(n - j, k, i) for i in range(1, n - j + 1)])\ndef a(n): return 1 if n==0 else sum([b(n, 6, j) for j in range(6, n + 1)])\nprint([a(n) for n in range(36)]) \n"}
{"sequence_id": "A288683", "text": "Number of Dyck paths of semilength n such that no positive level has fewer than seven peaks.", "sequence": "1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,9,234,2350,12567,44971,127475,320491,756677,1720610,3821223,8436508,19793620,59810128,268048977,1458971589,7720465569,36927931597,159094351283,626621217546,2296016964863,7949275945740", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(k, i - j), i)])*b(n - j, k, i) for i in range(1, n - j + 1)])\ndef a(n): return 1 if n==0 else sum([b(n, 7, j) for j in range(7, n + 1)])\nprint([a(n) for n in range(36)]) \n"}
{"sequence_id": "A288684", "text": "Number of Dyck paths of semilength n such that no positive level has fewer than eight peaks.", "sequence": "1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,10,335,4241,27915,117971,373845,1002089,2456082,5725439,12935530,28622833,62588817,139046970,353173119,1305216091,7035422989,41539474198,227550374938,1115122502718,4917988882292", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(k, i - j), i)])*b(n - j, k, i) for i in range(1, n - j + 1)])\ndef a(n): return 1 if n==0 else sum([b(n, 8, j) for j in range(8, n + 1)])\nprint([a(n) for n in range(41)]) \n"}
{"sequence_id": "A288685", "text": "Number of Dyck paths of semilength n such that no positive level has fewer than nine peaks.", "sequence": "1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,11,462,7217,57783,289400,1043781,3042593,7833174,18821247,43417043,97550980,215243289,469069428,1020806036,2342090587,6886047798,32238887181,199504672863,1232775909721,6881782444707", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(k, i - j), i)])*b(n - j, k, i) for i in range(1, n - j + 1)])\ndef a(n): return 1 if n==0 else sum([b(n, 9, j) for j in range(9, n + 1)])\nprint([a(n) for n in range(41)]) \n"}
{"sequence_id": "A288686", "text": "Number of Dyck paths of semilength n such that no positive level has fewer than ten peaks.", "sequence": "1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,12,618,11695,112434,665219,2756389,8890492,24410518,60972735,144203914,329766287,737405644,1623087349,3531560786,7633789153,16745585892,41482511559,152244106469,886899776271", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum(sum(binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(k, i - j), i))*b(n - j, k, i) for i in range(1, n - j + 1))\ndef a(n): return 1 if n==0 else sum(b(n, 10, j) for j in range(10, n + 1))\nprint([a(n) for n in range(41)]) \n"}
{"sequence_id": "A288743", "text": "Number of Dyck paths of semilength n such that the maximal number of peaks per level equals two.", "sequence": "1,1,7,18,59,193,616,1955,6244,19926,63490,202068,642816,2044571,6502193,20673020,65714586,208870774,663868055,2109997964,6706282384,21315049217,67748772174,215343287489,684507346839,2175916952697,6917096914771,21989855308501", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum(b(n - j, k, i)*sum(binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(0, i - j), min(k, i - 1) + 1)) for i in range(1, min(j + k, n - j) + 1))\ndef g(n, k): return sum(b(n, k, j) for j in range(1, k + 1))\ndef a(n): return g(n, 2) - g(n, 1)\nprint([a(n) for n in range(2, 36)]) \n"}
{"sequence_id": "A288744", "text": "Number of Dyck paths of semilength n such that the maximal number of peaks per level equals three.", "sequence": "1,1,9,29,112,405,1514,5565,20249,73416,265616,957677,3441282,12329838,44062706,157105923,559009643,1985301783,7038496811,24913917722,88058727525,310832221932,1095854282575,3859201682187,13576884290502,47719628447310,167579774234059", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum(b(n - j, k, i)*sum(binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(0, i - j), min(k, i - 1) + 1)) for i in range(1, min(j + k, n - j) + 1))\ndef g(n, k): return sum(b(n, k, j) for j in range(1, k + 1))\ndef a(n): return g(n, 3) - g(n, 2)\nprint([a(n) for n in range(3, 36)]) \n"}
{"sequence_id": "A288745", "text": "Number of Dyck paths of semilength n such that the maximal number of peaks per level equals four.", "sequence": "1,1,11,38,163,648,2571,10173,40025,156087,605057,2335566,8980883,34412583,131431024,500437733,1900135511,7196366668,27191450135,102522926104,385785153584,1448985664032,5432879981201,20337296148823,76015000686028,283720418696600", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([b(n - j, k, i)*sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(0, i - j), min(k, i - 1) + 1)]) for i in range(1, min(j + k, n - j) + 1)])\ndef g(n, k): return sum([b(n, k, j) for j in range(1, k + 1)])\ndef a(n): return g(n, 4) - g(n, 3)\nprint([a(n) for n in range(4, 36)]) \n"}
{"sequence_id": "A288746", "text": "Number of Dyck paths of semilength n such that the maximal number of peaks per level equals five.", "sequence": "1,1,13,48,220,925,3895,16137,66399,271446,1101626,4442143,17822176,71191082,283269813,1123212251,4439583152,17496345670,68765995160,269595218881,1054499461385,4115767918639,16032123369549,62333852291879,241935803355457,937486479689517", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([b(n - j, k, i)*sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(0, i - j), min(k, i - 1) + 1)]) for i in range(1, min(j + k, n - j) + 1)])\ndef g(n, k): return sum([b(n, k, j) for j in range(1, k + 1)])\ndef a(n): return g(n, 5) - g(n, 4)\nprint([a(n) for n in range(5, 36)]) \n"}
{"sequence_id": "A288747", "text": "Number of Dyck paths of semilength n such that the maximal number of peaks per level equals six.", "sequence": "1,1,15,59,288,1269,5580,24092,102847,434794,1824249,7600076,31459191,129505739,530589496,2164696038,8798355232,35639564649,143919521948,579526079335,2327484839124,9324921648372,37275509745894,148692946409186,591979810055622", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([b(n - j, k, i)*sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(0, i - j), min(k, i - 1) + 1)]) for i in range(1, min(j + k, n - j) + 1)])\ndef g(n, k): return sum([b(n, k, j) for j in range(1, k + 1)])\ndef a(n): return g(n, 6) - g(n, 5)\nprint([a(n) for n in range(6, 36)]) \n"}
{"sequence_id": "A288748", "text": "Number of Dyck paths of semilength n such that the maximal number of peaks per level equals seven.", "sequence": "1,1,17,71,368,1697,7769,34751,153313,668088,2882104,12329145,52358300,220901081,926638057,3867432363,16068748557,66495876593,274178902925,1126793986670,4616878543095,18864740697016,76885237242318,312611605360287,1268261191750753", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([b(n - j, k, i)*sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(0, i - j), min(k, i - 1) + 1)]) for i in range(1, min(j + k, n - j) + 1)])\ndef g(n, k): return sum([b(n, k, j) for j in range(1, k + 1)])\ndef a(n): return g(n, 7) - g(n, 6)\nprint([a(n) for n in range(7, 36)]) \n"}
{"sequence_id": "A288749", "text": "Number of Dyck paths of semilength n such that the maximal number of peaks per level equals eight.", "sequence": "1,1,19,84,461,2222,10577,48943,222627,997735,4417674,19359659,84099436,362570722,1552681071,6609823112,27989970166,117967914457,495087382572,2069827499508,8623283249034,35811917284318,148289870077879,612382134256433,2522591250558641", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum(b(n - j, k, i)*sum(binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(0, i - j), min(k, i - 1) + 1)) for i in range(1, min(j + k, n - j) + 1))\ndef g(n, k): return sum(b(n, k, j) for j in range(1, k + 1))\ndef a(n): return g(n, 8) - g(n, 7)\nprint([a(n) for n in range(8, 36)]) \n"}
{"sequence_id": "A288750", "text": "Number of Dyck paths of semilength n such that the maximal number of peaks per level equals nine.", "sequence": "1,1,21,98,568,2858,14128,67556,316490,1456952,6612520,29652948,131613716,578987886,2527351698,10956840549,47212399022,202328867061,862840720214,3663367687951,15491222396862,65268041732681,274068630138339,1147305286307251", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum(b(n - j, k, i)*sum(binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(0, i - j), min(k, i - 1) + 1)) for i in range(1, min(j + k, n - j) + 1))\ndef g(n, k): return sum(b(n, k, j) for j in range(1, k + 1))\ndef a(n): return g(n, 9) - g(n, 8)\nprint([a(n) for n in range(9, 36)]) \n"}
{"sequence_id": "A288751", "text": "Number of Dyck paths of semilength n such that the maximal number of peaks per level equals ten.", "sequence": "1,1,23,113,690,3620,18562,91628,441694,2086758,9699872,44473357,201530730,904002266,4019194153,17730014882,77671514151,338156070316,1464024164516,6306519136902,27042360481662,115475401501264,491223012388610,2082320685801754", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, k, j): return 1 if j==n else sum([b(n - j, k, i)*sum([binomial(i, m)*binomial(j - 1, i - 1 - m) for m in range(max(0, i - j), min(k, i - 1) + 1)]) for i in range(1, min(j + k, n - j) + 1)])\ndef g(n, k): return sum([b(n, k, j) for j in range(1, k + 1)])\ndef a(n): return g(n, 10) - g(n, 9)\nprint([a(n) for n in range(10, 36)]) \n"}
{"sequence_id": "A288790", "text": "Number of blocks of size >= eight in all set partitions of n.", "sequence": "1,10,101,947,8670,79249,730745,6838642,65197797,634656360,6316333291,64318009411,670336612614,7151290120037,78085166445577,872478836270306,9972817907218608,116575837400037486,1393037460835481622,17010118386233081680,212160149063581345610", "code": "\nfrom sympy import bell, binomial\ndef a(n): return sum(binomial(n, j)*bell(j) for j in range(n - 7))\nprint([a(n) for n in range(8, 31)]) \n"}
{"sequence_id": "A288791", "text": "Number of blocks of size >= nine in all set partitions of n.", "sequence": "1,11,122,1245,12325,121136,1195147,11915997,120572790,1241499241,13030331671,139549798524,1525923634907,17041290249637,194394900237176,2264977282222371,26951265841776186,327445918493429897,4060993235341162405,51396034231430455550", "code": "\nfrom sympy import bell, binomial\ndef a(n): return sum([binomial(n, j)*bell(j) for j in range(n - 8)])\nprint([a(n) for n in range(9, 31)]) \n"}
{"sequence_id": "A288792", "text": "Number of blocks of size >= ten in all set partitions of n.", "sequence": "1,12,145,1600,17032,179132,1883117,19929390,213332101,2316793121,25577181324,287421068697,3290394397097,38393883291996,456753452800691,5540597439008861,68530489547341697,864218608315007230,11109867095322262250,145563654356205885737", "code": "\nfrom sympy import bell, binomial\ndef a(n): return sum([binomial(n, j)*bell(j) for j in range(n - 9)])\nprint([a(n) for n in range(10, 31)]) \n"}
{"sequence_id": "A288872", "text": "Denominators for generalized Bernoulli numbers B[5,j](n), for j=1..4, n >= 0.", "sequence": "1,2,6,1,6,1,42,1,6,1,66,1,546,1,6,1,102,1,798,1,66,1,138,1,546,1,6,1,174,1,14322,1,102,1,6,1,383838,1,6,1,2706,1,1806,1,138,1,282,1,9282,1,66,1,318,1,798,1,174,1,354,1,11357346,1,6,1,102,1,64722,1,6,1,4686", "code": "\nfrom sympy import bernoulli\ndef a(n): return bernoulli(n, 1/Integer(5)).denominator()//(5**n)\nprint([a(n) for n in range(41)]) \n"}
{"sequence_id": "A288873", "text": "Numerators of scaled Bernoulli numbers 4^n*B(n), with B(n) = A027641(n)/A027642(n).", "sequence": "1,-2,8,0,-128,0,2048,0,-32768,0,2621440,0,-5796528128,0,939524096,0,-7767448354816,0,1507258642989056,0,-95993412418797568,0,7516375836686024704,0,-33265288504730187726848,0,19259875741830735724544,0,-855664510723636131971203072,0,4966694343692730467779807805440", "code": "\nfrom sympy import bernoulli\ndef a(n): return (4**n * bernoulli(n)).numerator()\n[a(n) for n in range(31)]  \n"}
{"sequence_id": "A288913", "text": "a(n) = Lucas(4*n + 3).", "sequence": "4,29,199,1364,9349,64079,439204,3010349,20633239,141422324,969323029,6643838879,45537549124,312119004989,2139295485799,14662949395604,100501350283429,688846502588399,4721424167835364,32361122672259149,221806434537978679,1520283919093591604", "code": "\nfrom sympy import lucas\ndef a(n):  return lucas(4*n + 3)\nprint([a(n) for n in range(22)]) \n"}
{"sequence_id": "A288939", "text": "Nonprime numbers k such that k^6 + k^5 + k^4 + k^3 + k^2 + k + 1 is prime.", "sequence": "1,6,14,26,38,40,46,56,60,66,68,72,80,87,93,95,115,122,126,128,146,156,158,160,180,186,192,203,206,208,220,221,235,237,238,264,266,280,282,290,294,300,303,320,341,350,363,381,395,399,404,405,417,418,436,438,447,450", "code": "\nfrom sympy import isprime\nA288939_list = [n for n in range(10**3) if not isprime(n) and isprime(n*(n*(n*(n*(n*(n + 1) + 1) + 1) + 1) + 1) + 1)] \n"}
{"sequence_id": "A289052", "text": "a(1) = 1; a(n) = a(n-A006530(n-1)) + 1 for n > 1.", "sequence": "1,2,2,2,3,2,3,2,4,4,3,2,5,2,3,4,4,2,5,2,5,4,3,2,5,6,3,6,5,2,7,2,8,4,3,6,5,2,3,4,7,2,7,2,5,8,3,2,9,8,9,4,5,2,5,6,9,4,3,2,7,2,3,10,4,6,7,2,5,4,11,2,5,2,3,12,5,8,7,2,13,8,3,2,9,6,3,4,9,2,7,8,5,4,3,6,5", "code": "\nfrom sympy import primefactors\nl=[0, 1, 2]\nfor n in range(3, 201): l.append(l[n - primefactors(n - 1)[-1]] + 1)\nprint(l[1:]) \n"}
{"sequence_id": "A289068", "text": "Recurrence a(n+2) = Sum_{k=0..n} binomial(n,k)*a(k)*a(n+1-k) with a(0)=1, a(1)=-2.", "sequence": "1,-2,-2,2,14,10,-170,-670,2270,30490,26950,-1435150,-8513650,59564650,1050090550,486517250,-113618013250,-831340535750,10136160835750,208459859695250,-121723298991250,-41568491959973750,-338549875950886250,6637158567781561250", "code": "\nfrom sympy import binomial\nl=[1, -2]\nfor n in range(2, 51): l+=[sum([binomial(n - 2, k)*l[k]*l[n - 1 - k] for k in range(n - 1)]), ]\nprint(l) \n"}
{"sequence_id": "A289069", "text": "Recurrence a(n+2) = Sum_{k=0..n} binomial(n,k)*a(k)*a(n+1-k) with a(0)=3, a(1)=-2.", "sequence": "3,-2,-6,-14,-6,202,1506,4594,-29814,-573062,-4098606,2741026,487823034,6657110122,28995776706,-685482188846,-17937265077654,-181680546169382,963087154054194,72085899963332866,1289184007236331674,4679677879996688842,-383123191395931184094", "code": "\nfrom sympy import binomial\nl=[3, -2]\nfor n in range(2, 51): l+=[sum(binomial(n - 2, k)*l[k]*l[n - 1 - k] for k in range(n - 1)), ]\nprint(l) \n"}
{"sequence_id": "A289079", "text": "Number of orderless same-trees of weight n with all leaves equal to 1.", "sequence": "1,1,1,2,1,3,1,5,2,3,1,13,1,3,3,22,1,16,1,15,3,3,1,151,2,3,6,17,1,41,1,334,3,3,3,637,1,3,3,275,1,56,1,21,19,3,1,15591,2,27,3,23,1,902,3,516,3,3,1,7858,1,3,21,69109,3,98,1,27,3,67,1,811756,1", "code": "\nfrom sympy import divisors, binomial\nl=[0, 1]\nfor n in range(2, 101): l+=[sum([binomial(l[n//d] + d - 1, d) for d in divisors(n)[1:]]), ]\nl[1:] \n"}
{"sequence_id": "A289138", "text": "a(n) = smallest expomorphic number in base n: least integer k such that n^k ends in k, or 0 if no such k exists.", "sequence": "1,36,7,6,5,6,3,56,9,0,1,16,7,6,5,6,3,76,9,0,1,96,7,6,5,6,3,96,9,0,1,76,7,6,5,6,3,16,9,0,1,56,7,6,5,6,3,36,9,0,1,36,7,6,5,6,3,56,9,0,1,16,7,6,5,6,3,76,9,0,1,96,7,6,5,6,3,96,9,0,1,76,7,6,5,6,3,16,9,0,1,56,7,6,5,6,3,36,9,0", "code": "\ndef a(n):\n    if n%10==0: return 0\n    k=1\n    while pow(n, k, 10**len(str(k)))!=k: k+=1\n    return k\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A289147", "text": "Number of (n+1) X (n+1) binary matrices M with at most one 1 in each of the first n rows and each of the first n columns and M[n+1,n+1] = 0.", "sequence": "1,5,34,286,2840,32344,414160,5876336,91356544,1542401920,28075364096,547643910400,11389266525184,251428006132736,5869482147358720,144413021660821504,3733822274973040640,101181690628832198656,2867011297057247002624,84764595415605494743040", "code": "\nfrom mpmath import *\nmp.dps=150\nl=chop(taylor(lambda x:exp(4*x/(1-x))/(1-x), 0, 31))\nprint([int(fac(i)*l[i]) for i in range(len(l))]) \n\nfrom mpmath import *\nmp.dps=100\ndef a(n): return int(fac(n)*laguerre(n, 0, -4))\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A289183", "text": "a(n) is the greatest m such that 2*H(n) > H(m), where H(n) is the n-th harmonic number.", "sequence": "3,10,21,35,53,74,99,128,160,196,235,277,324,374,427,484,545,609,676,748,822,901,983,1068,1157,1250,1346,1446,1549,1656,1766,1880,1998,2119,2244,2372,2504,2639,2778,2921,3067,3216,3369,3526,3686,3850,4018,4189", "code": "\nfrom sympy import harmonic\ndef a(n):\n  hn2 = 2 * harmonic(n)\n  m = n\n  while harmonic(m) <= hn2: m += 1\n  return m - 1\nprint([a(n) for n in range(1, 49)]) \n"}
{"sequence_id": "A289192", "text": "A(n,k) = n! * Laguerre(n,-k); square array A(n,k), n>=0, k>=0, read by antidiagonals.", "sequence": "1,1,1,1,2,2,1,3,7,6,1,4,14,34,24,1,5,23,86,209,120,1,6,34,168,648,1546,720,1,7,47,286,1473,5752,13327,5040,1,8,62,446,2840,14988,58576,130922,40320,1,9,79,654,4929,32344,173007,671568,1441729,362880", "code": "\nfrom sympy import binomial, factorial as f\ndef A(n, k): return f(n)*sum(binomial(n, i)*k**i/f(i) for i in range(n + 1))\nfor n in range(13): print([A(k, n - k) for k in range(n + 1)]) \n"}
{"sequence_id": "A289212", "text": "a(n) = n! * Laguerre(n,-6).", "sequence": "1,7,62,654,7944,108696,1649232,27422352,495057024,9631281024,200682406656,4455296877312,104921038236672,2610989435003904,68430995893131264,1883330926998829056,54286270223002140672,1635031821385383247872,51347572582353094508544", "code": "\nfrom mpmath import *\nmp.dps=100\ndef a(n): return int(fac(n)*laguerre(n, 0, -6))\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A289213", "text": "a(n) = n! * Laguerre(n,-7).", "sequence": "1,8,79,916,12113,179152,2921911,51988748,1000578817,20686611736,456805020959,10721879413252,266382974861521,6980304560060384,192311632290456007,5555079068684580988,167822887344661475969,5290815252203206305832,173713426149927498289903", "code": "\nfrom mpmath import *\nmp.dps=100\ndef a(n): return int(fac(n)*laguerre(n, 0, -7))\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A289214", "text": "a(n) = n! * Laguerre(n,-8).", "sequence": "1,9,98,1238,17688,280888,4894672,92676144,1891712384,41361536384,963532779264,23806296960256,621407739476992,17078348640463872,492724294444623872,14883442560920164352,469591293625846038528,15443081743064125505536,528340631093887891603456", "code": "\nfrom mpmath import *\nmp.dps=100\ndef a(n): return int(fac(n)*laguerre(n, 0, -8))\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A289215", "text": "a(n) = n! * Laguerre(n,-9).", "sequence": "1,10,119,1626,24945,422994,7836255,157169826,3388099329,78031713690,1910451937671,49510386761130,1353167691897969,38878205830928226,1170930069982659375,36875214316479123954,1211549306913066598785,41445016025330141416746", "code": "\nfrom mpmath import *\nmp.dps=100\ndef a(n): return int(fac(n)*laguerre(n, 0, -9))\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A289216", "text": "a(n) = n! * Laguerre(n,-10).", "sequence": "1,11,142,2086,34184,616120,12083920,255749840,5801633920,140276126080,3598075308800,97512721964800,2782552712473600,83347512973644800,2613606571616819200,85594543750221568000,2921314815145299968000,103704333851191177216000", "code": "\nfrom mpmath import *\nmp.dps=100\ndef a(n): return int(fac(n)*laguerre(n, 0, -10))\nprint([a(n) for n in range(21)]) \n"}
{"sequence_id": "A289217", "text": "a(1)=1, a(n)=a(n-1) plus the second prime greater than a(n-1).", "sequence": "1,4,11,28,59,126,257,526,1073,2164,4367,8758,17537,35088,70187,140388,280795,561612,1123315,2246642,4493329,8986712,17973451,35946942,71893933,143787890,287575797,575151614,1150303251,2300606554,4601213127,9202426258", "code": "\nfrom sympy import nextprime\nfrom sympy.core.cache import cacheit\n@cacheit\ndef step(n): return n + nextprime(nextprime(n))\ndef a(n): return n if n<2 else step(a(n - 1))\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A289249", "text": "Number of compositions of n if only the order of parts 1 and 2 matters.", "sequence": "1,1,2,4,7,12,21,35,59,98,162,266,437,713,1163,1893,3077,4995,8105,13139,21293,34492,55858,90438,146406,236974,383538,620703,1004471,1625447,2630249,4256087,6886804,11143447,18030911,29175137,47206975,76383199,123591458", "code": "\nfrom sympy import fibonacci, npartitions\ndef a(n): return npartitions(n) + sum([fibonacci(k)*npartitions(n - 2 - k) for k in range(1, n - 1)])\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A289256", "text": "a(1) = a(2) = a(3) = 2;  a(n) = a(n-a(n-1)) + a(n-a(n-3)-1) for n > 3.", "sequence": "2,2,2,4,4,4,4,6,6,8,6,8,8,8,8,10,10,12,10,14,10,14,12,16,14,16,14,16,16,16,16,18,18,20,18,22,18,24,18,24,20,26,22,26,22,28,24,30,24,30,24,30,26,32,28,32,30,32,30,32,32,32,32,34,34,36,34,38,34,40,34,42,34,42,36,44,38,44,38,46,40,48", "code": "\nl=[0, 2, 2, 2]\nfor n in range(4, 101): l+=[l[n - l[n - 1]] + l[n - l[n - 3] - 1], ]\nprint(l[1:]) \n"}
{"sequence_id": "A289282", "text": "The least significant four bytes of n! interpreted in two's complement.", "sequence": "1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,1932053504,1278945280,2004310016,2004189184,-288522240,-898433024,109641728,-2102132736,-1195114496,-522715136,862453760,-775946240,2076180480,-1853882368,1484783616,-1375731712,-1241513984,1409286144,738197504,-2147483648,-2147483648,0,0,0", "code": "\nimport math\ndef A289282(n):\n    f = math.factorial(n)\n    least_four = f & 0xffffffff\n    mask = 0x7fffffff\n    return (least_four & mask) - (least_four & ~mask)\nprint([A289282(n) for n in range(37)]) \n"}
{"sequence_id": "A289320", "text": "a(n) = A289310(n)^2 + A289311(n)^2.", "sequence": "1,5,10,25,26,50,50,125,100,130,122,250,170,250,260,625,290,500,362,650,500,610,530,1250,676,850,1000,1250,842,1300,962,3125,1220,1450,1300,2500,1370,1810,1700,3250,1682,2500,1850,3050,2600,2650,2210,6250,2500", "code": "\nfrom sympy import factorint\nfrom operator import mul\nfrom functools import reduce\ndef a(n): return 1 if n==1 else reduce(mul, [(1 + p**2)**k for p, k in factorint(n).items()])\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A289411", "text": "a(n) = Sum_{k=0..n} sign(A007953(5*k) - A007953(k)).", "sequence": "0,1,0,1,0,1,0,1,0,0,1,2,3,4,5,6,7,8,8,9,8,9,8,9,8,9,8,8,7,6,7,8,9,10,11,12,12,13,12,13,12,13,12,13,12,12,11,10,9,8,9,10,11,12,12,13,12,13,12,13,12,13,12,12,11,10,9,8,7,6,7,8,8,9,8,9,8", "code": "\nfrom sympy import sign\nfrom sympy.ntheory.factor_ import digits\ndef a(n): return sum([sign(sum(digits(5*k)[1:]) - sum(digits(k)[1:])) for k in range(n + 1)])\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A289435", "text": "The arithmetic function v_3(n,3).", "sequence": "1,0,2,2,3,2,4,2,5,4,6,4,7,6,8,6,9,6,10,6,11,8,12,10,13,8,14,10,15,10,16,12,17,14,18,12,19,12,20,14,21,14,22,18,23,16,24,16,25,18,26,18,27,22,28,18,29,20,30,20,31,20,32,26,33,22,34,24,35", "code": "\nfrom sympy import divisors, floor, gcd\ndef a(n): return n*max((floor((d - 1 - gcd(d, 3))/3) + 1)/d for d in divisors(n))\nprint([a(n) for n in range(2, 101)]) \n"}
{"sequence_id": "A289436", "text": "The arithmetic function v_1(n,4).", "sequence": "1,1,2,1,3,2,4,3,5,3,6,3,7,5,8,4,9,5,10,7,11,6,12,6,13,9,14,7,15,8,16,11,17,10,18,9,19,13,20,10,21,11,22,15,23,12,24,14,25,17,26,13,27,15,28,19,29,15,30,15,31,21,32,16,33,17,34,23,35", "code": "\nfrom sympy import divisors, floor\ndef a(n): return int(n*max(int(floor((d - 2)/4) + 1)/d for d in divisors(n)))\nprint([a(n) for n in range(2, 101)]) \n"}
{"sequence_id": "A289437", "text": "The arithmetic function v_2(n,4).", "sequence": "0,1,1,1,2,2,2,3,2,3,4,3,4,5,4,4,6,5,5,7,6,6,8,6,6,9,8,7,10,8,8,11,8,10,12,9,10,13,10,10,14,11,12,15,12,12,16,14,12,17,13,13,18,15,16,19,14,15,20,15,16,21,16,16,22,17,17,23,20", "code": "\nfrom sympy import divisors, floor, gcd\ndef a(n): return n*max([(floor((d - 1 - gcd(d, 2))/4) + 1)/d for d in divisors(n)])\nprint([a(n) for n in range(2, 101)]) \n"}
{"sequence_id": "A289438", "text": "The arithmetic function v_4(n,4).", "sequence": "0,1,0,1,2,2,1,3,2,3,4,3,4,5,3,4,6,5,4,7,6,6,8,6,6,9,8,7,10,8,7,11,8,10,12,9,10,13,9,10,14,11,12,15,12,12,16,14,12,17,12,13,18,15,16,19,14,15,20,15,16,21,15,16,22,17,16,23,20", "code": "\nfrom sympy import divisors, floor, gcd\ndef a(n): return n*max([(floor((d - 1 - gcd(d, 4))/4) + 1)/d for d in divisors(n)])\nprint([a(n) for n in range(2, 101)]) \n"}
{"sequence_id": "A289439", "text": "The arithmetic function v_1(n,5).", "sequence": "1,1,2,1,3,2,4,3,5,2,6,3,7,5,8,4,9,4,10,7,11,5,12,5,13,9,14,6,15,6,16,11,17,10,18,8,19,13,20,8,21,9,22,15,23,10,24,14,25,17,26,11,27,11,28,19,29,12,30,12,31,21,32,15,33,14,34,23,35", "code": "\nfrom sympy import divisors, floor\ndef a(n): return int(n*max(int(floor((d - 2)/5) + 1)/d for d in divisors(n)))\nprint([a(n) for n in range(2, 101)]) \n"}
{"sequence_id": "A289440", "text": "The arithmetic function v_3(n,5).", "sequence": "1,0,2,1,3,2,4,2,5,2,6,3,7,3,8,4,9,4,10,6,11,5,12,5,13,6,14,6,15,6,16,6,17,10,18,8,19,9,20,8,21,9,22,10,23,10,24,14,25,12,26,11,27,11,28,12,29,12,30,12,31,18,32,15,33,14,34,15,35", "code": "\nfrom sympy import divisors, floor, gcd\ndef a(n): return n*max([(floor((d - 1 - gcd(d, 3))/5) + 1)/d for d in divisors(n)])\nprint([a(n) for n in range(2, 101)]) \n"}
{"sequence_id": "A289441", "text": "The arithmetic function v_5(n,5).", "sequence": "1,1,2,0,3,2,4,3,5,2,6,3,7,5,8,4,9,4,10,7,11,5,12,4,13,9,14,6,15,6,16,11,17,10,18,8,19,13,20,8,21,9,22,15,23,10,24,14,25,17,26,11,27,10,28,19,29,12,30,12,31,21,32,15,33,14,34,23,35", "code": "\nfrom sympy import divisors, floor, gcd\ndef a(n): return n*max([(floor((d - 1 - gcd(d, 5))/5) + 1)/d for d in divisors(n)])\nprint([a(n) for n in range(2, 101)]) \n"}
{"sequence_id": "A289503", "text": "Decimal expansion of 3/sqrt(Pi).", "sequence": "1,6,9,2,5,6,8,7,5,0,6,4,3,2,6,8,8,6,0,8,4,4,2,3,8,3,5,4,6,8,2,3,1,7,7,5,7,5,3,2,1,5,1,8,8,7,9,8,6,9,9,6,5,7,0,5,3,2,2,5,7,1,6,5,1,3,1,9,2,7,4,0,5,3,2,4,4,8,0,2,4,3,4,6,0,2,3,0", "code": "\nfrom mpmath import mp, sqrt, pi\nmp.dps=90\nprint([int(z) for z in list(str(3/sqrt(pi)).replace('.', '')[:-2])]) \n"}
{"sequence_id": "A289504", "text": "Decimal expansion of 2*(1+3^(3/2)/(2*Pi)).", "sequence": "3,6,5,3,9,8,6,6,8,6,2,6,5,3,7,6,1,4,8,5,3,3,9,7,9,4,9,4,9,3,8,9,0,8,3,2,4,1,9,2,1,5,9,4,4,1,0,9,9,9,2,1,9,5,8,3,9,8,0,9,8,0,6,0,8,7,3,0,9,0,9,1,0,4,0,7,8,0,9,3,8,4,5,2,1,1", "code": "\nfrom mpmath import *\nmp.dps=86\nC=2*(1 + 3*sqrt(3)/(2*pi))\nprint([int(n) for n in list(str(C).replace('.', ''))]) \n"}
{"sequence_id": "A289505", "text": "Decimal expansion of arcsec(3)/(2*Pi).", "sequence": "1,9,5,9,1,3,2,7,6,0,1,5,3,0,3,6,3,5,0,8,5,4,2,7,7,7,9,6,1,1,2,1,5,4,5,5,6,5,8,3,1,4,3,2,4,7,1,9,7,0,0,1,4,3,6,4,3,9,6,9,1,4,9,0,1,1,0,0,0,7,0,4,3,3,8,7,2,1,1,2,3,4,3,5,1,0,5,9", "code": "\nfrom mpmath import mp, asec, pi\nmp.dps=89\nprint([int(z) for z in list(str(asec(3)/(2*pi))[2:-1])]) \n"}
{"sequence_id": "A289508", "text": "a(n) is the GCD of the indices j for which the j-th prime p_j divides n.", "sequence": "0,1,2,1,3,1,4,1,2,1,5,1,6,1,1,1,7,1,8,1,2,1,9,1,3,1,2,1,10,1,11,1,1,1,1,1,12,1,2,1,13,1,14,1,1,1,15,1,4,1,1,1,16,1,1,1,2,1,17,1,18,1,2,1,3,1,19,1,1,1,20,1,21,1,1,1,1,1,22,1,2,1,23", "code": "\nfrom sympy import primefactors, primepi, gcd\ndef a(n):\n    return gcd([primepi(d) for d in primefactors(n)])\nprint([a(n) for n in range(2, 101)]) \n"}
{"sequence_id": "A289509", "text": "Numbers k such that the gcd of the indices j for which the j-th prime prime(j) divides k is 1.", "sequence": "2,4,6,8,10,12,14,15,16,18,20,22,24,26,28,30,32,33,34,35,36,38,40,42,44,45,46,48,50,51,52,54,55,56,58,60,62,64,66,68,69,70,72,74,75,76,77,78,80,82,84,85,86,88,90,92,93,94,95,96,98,99,100,102,104", "code": "\nfrom sympy import gcd, primepi, primefactors\ndef ok(n): return gcd([primepi(p) for p in primefactors(n)]) == 1\nprint([n for n in range(1, 151) if ok(n)]) \n"}
{"sequence_id": "A289548", "text": "The lesser of two semiprime brothers.", "sequence": "9,14,21,26,403,12367,41303,66893,68297,73147,111607,116813,118003,130133,146873,222757,260497,418307,429491,439097,478061,559003,628241,729007,822397,1116707,1239869,1595683,1887239,2148589,2225669,2481463,2502977,2539553", "code": "\nfrom sympy import factorint, nextprime\ndef is_semiprime(n):\n    return sum(e for e in factorint(n).values()) == 2\ndef next_semiprime(n):\n    nxt = n + 1\n    while not is_semiprime(nxt): nxt += 1\n    return nxt\ndef are_consecutive(p, q):\n    return max(p, q) == nextprime(min(p, q))\ndef ok(n):\n    if not is_semiprime(n): return False\n    nextsp = next_semiprime(n)\n    fn, fm = factorint(n, multiple=True), factorint(nextsp, multiple=True)\n    return are_consecutive(fn[0], fm[0]) and are_consecutive(fn[1], fm[1])\nprint(list(filter(ok, range(150000)))) \n"}
{"sequence_id": "A289660", "text": "a(n) = A037276(n) - n.", "sequence": "0,0,0,18,0,17,0,214,24,15,0,211,0,13,20,2206,0,215,0,205,16,189,0,2199,30,187,306,199,0,205,0,22190,278,183,22,2197,0,181,274,2185,0,195,0,2167,290,177,0,22175,28,205,266,2161,0,2279,456,2171,262,171,0,2175,0,169,274,222158,448,2245,0", "code": "\nfrom sympy import factorint\ndef A289660(n):\n    return 0 if n == 1 else int(''.join(map(lambda x: str(x[0])*x[1],sorted(factorint(n).items())))) - n \n"}
{"sequence_id": "A289673", "text": "Take n-th string over {1,2} in lexicographic order and apply the Post tag system described in A284116 (but adapted to the alphabet {1,2}) just once.", "sequence": "-1,12,1,1,212,212,11,11,11,11,2212,2212,2212,2212,111,211,111,211,111,211,111,211,12212,22212,12212,22212,12212,22212,12212,22212,1111,1211,2111,2211,1111,1211,2111,2211,1111,1211,2111,2211,1111,1211,2111,2211,112212", "code": "\nfrom itertools import product\nA289673_list = [-1 if s == ('1',) else int((''.join(s)+('2212' if s[0] == '2' else '11'))[3:]) for l in range(1,10) for s in product('12',repeat=l)] \n"}
{"sequence_id": "A289676", "text": "a(n) = A289670(n)/2^f(n), where f(n) = 2*floor((n-1)/3) + ((n+2) mod 3).", "sequence": "2,1,1,2,2,1,4,4,3,5,4,3,10,13,12,21,18,20,43,40,39,85,71,64,146,132,116,250,231,210,462,459,438,960,990,966,2069,2114,2089,4296,4237,4155,8485,8234,8032,16496,16054,15657,32041,31280,30325,61700,60252,58379,118357,115810,112885", "code": "\nfrom __future__ import division\ndef A289676(n):\n    c, k, r, n2, cs, ts = 0, 1+(n-1)//3, 2**((n-1) % 3), 2**(n-1), set(), set()\n    for i in range(2**k):\n        j, l = int(bin(i)[2:],8)*r, n2\n        traj = set([(l,j)])\n        while True:\n            if j >= l:\n                j = j*16+13\n                l *= 2\n            else:\n                j *= 4\n                l //= 2\n            if l == 0:\n                c += 1\n                ts |= traj\n                break\n            j %= 2*l\n            if (l,j) in traj:\n                cs |= traj\n                break\n            if (l,j) in cs:\n                break\n            if (l,j) in ts:\n                c += 1\n                break\n            traj.add((l,j))\n    return c \n"}
{"sequence_id": "A289677", "text": "a(n) = A289671(n)/2^f(n), where f(n) = 2*floor((n-1)/3) + ((n+2) mod 3) = A004523(n).", "sequence": "0,1,1,2,2,3,4,4,5,11,12,13,22,19,20,43,46,44,85,88,89,171,185,192,366,380,396,774,793,814,1586,1589,1610,3136,3106,3130,6123,6078,6103,12088,12147,12229,24283,24534,24736,49040,49482,49879,99031,99792,100747,200444,201892,203765,405931,408478,411403", "code": "\nfrom __future__ import division\ndef A289677(n):\n    c, k, r, n2, cs, ts = 0, 1+(n-1)//3, 2**((n-1) % 3), 2**(n-1), set(), set()\n    for i in range(2**k):\n        j, l = int(bin(i)[2:],8)*r, n2\n        traj = set([(l,j)])\n        while True:\n            if j >= l:\n                j = j*16+13\n                l *= 2\n            else:\n                j *= 4\n                l //= 2\n            if l == 0:\n                ts |= traj\n                break\n            j %= 2*l\n            if (l,j) in traj:\n                c += 1\n                cs |= traj\n                break\n            if (l,j) in cs:\n                c += 1\n                break\n            if (l,j) in ts:\n                break\n            traj.add((l,j))\n    return c \n"}
{"sequence_id": "A289748", "text": "Thue-Morse constant converted to base -2.", "sequence": "1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,0", "code": "\ndef N(x):\n    return x + 0xAAAAAAAAAAAAAAAA ^ 0xAAAAAAAAAAAAAAAA\ndef parityOf(int_type):\n    parity = 0\n    while (int_type):\n        parity = ~parity\n        int_type = int_type & (int_type - 1)\n    return(abs(parity))\nA010060 = \"\"\nfor i in range(0,40):\n    A010060 = A010060 + str(parityOf(i))\nA289748 = \",\".join(bin(N(int(A010060, 2))).replace(\"0b\", \"\"))\nprint(A289748)\n"}
{"sequence_id": "A289776", "text": "Least k such that the sum of the first n divisors of k is a prime number.", "sequence": "2,4,30,16,84,36,60,144,144,144,144,210,324,360,630,756,756,576,660,840,840,2040,900,900,2304,1980,1980,1980,4320,5184,3300,4620,5460,7056,3960,4680,2520,3600,3600,3600,10080,8100,3600,6300,9900,7920,11088,14400", "code": "\nfrom sympy import divisors, isprime\ndef A289776(n):\n    i = 1\n    while len(divisors(i)) < n or not isprime(sum(divisors(i)[:n])):\n        i += 1\n    return i \n"}
{"sequence_id": "A289813", "text": "A binary encoding of the ones in ternary representation of n (see Comments for precise definition).", "sequence": "0,1,0,2,3,2,0,1,0,4,5,4,6,7,6,4,5,4,0,1,0,2,3,2,0,1,0,8,9,8,10,11,10,8,9,8,12,13,12,14,15,14,12,13,12,8,9,8,10,11,10,8,9,8,0,1,0,2,3,2,0,1,0,4,5,4,6,7,6,4,5,4,0,1,0,2,3,2,0,1,0,16", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a(n):\n    d = digits(n, 3)[1:]\n    return int(\"\".join('1' if i==1 else '0' for i in d), 2)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A289814", "text": "A binary encoding of the twos in ternary representation of n (see Comments for precise definition).", "sequence": "0,0,1,0,0,1,2,2,3,0,0,1,0,0,1,2,2,3,4,4,5,4,4,5,6,6,7,0,0,1,0,0,1,2,2,3,0,0,1,0,0,1,2,2,3,4,4,5,4,4,5,6,6,7,8,8,9,8,8,9,10,10,11,8,8,9,8,8,9,10,10,11,12,12,13,12,12,13,14,14,15,0", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a(n):\n    d = digits(n, 3)[1:]\n    return int(\"\".join('1' if i == 2 else '0' for i in d), 2)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A289815", "text": "The first of a pair of coprime numbers whose factorizations depend on the ternary representation of n (see Comments for precise definition).", "sequence": "1,2,1,3,6,3,1,2,1,4,10,5,12,30,15,4,10,5,1,2,1,3,6,3,1,2,1,5,14,7,15,42,21,5,14,7,20,70,35,60,210,105,20,70,35,5,14,7,15,42,21,5,14,7,1,2,1,3,6,3,1,2,1,4,10,5,12,30,15,4,10,5,1,2,1,3,6", "code": "\nfrom sympy import gcd, primefactors\ndef omega(n): return 0 if n==1 else len(primefactors(n))\ndef a(n):\n    v, x, o = 1, 1, 2\n    while True:\n        if n==0: return v\n        if gcd(x, o)==1 and omega(o)==1:\n            if n%3: x*=o\n            if n%3==1:v*=o\n            n //= 3\n        o+=1\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A289816", "text": "The second of a pair of coprime numbers whose factorizations depend on the ternary representation of n (See Comments for precise definition).", "sequence": "1,1,2,1,1,2,3,3,6,1,1,2,1,1,2,3,3,6,4,5,10,4,5,10,12,15,30,1,1,2,1,1,2,3,3,6,1,1,2,1,1,2,3,3,6,4,5,10,4,5,10,12,15,30,5,7,14,5,7,14,15,21,42,5,7,14,5,7,14,15,21,42,20,35,70,20,35,70", "code": "\nfrom sympy import gcd, primefactors\ndef omega(n): return 0 if n==1 else len(primefactors(n))\ndef a(n):\n    v, x, o = 1, 1, 2\n    while True:\n        if n==0: return v\n        if gcd(x, o)==1 and omega(o)==1:\n            if n%3: x*=o\n            if n%3==2:v*=o\n            n //= 3\n        o+=1\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A289829", "text": "Perfect squares of the form prime(k+1)^2 - prime(k)^2 + 1 where prime(k) is the k-th prime number.", "sequence": "25,49,121,169,289,361,841,961,1681,1849,2401,2809,3721,5929,6889,7921,8281,10201,11449,11881,14161,14641,17689,24649,26569,32041,38809,41209,43681,44521,61009,63001,69169,76729,80089,85849,89401,94249,96721,97969,108241", "code": "\nfrom __future__ import division\nfrom sympy import divisors, isprime, prevprime, nextprime\nA289829_list = []\nfor n in range(10**4):\n    m = n**2-1\n    for d in divisors(m):\n        if d*d >= m:\n            break\n        r = m//d\n        if not r % 2:\n            r = r//2\n            if not isprime(r):\n                p, q = prevprime(r), nextprime(r)\n                if m == (q-p)*(q+p):\n                    A289829_list.append(n**2)\n                    break \n"}
{"sequence_id": "A289830", "text": "a(n) satisfies the equation n/(n-1) + a(n)/n! = H(n), where H(n) is the n-th harmonic number.", "sequence": "-1,2,18,124,900,7188,63504,618336,6596640,76635360,963895680,13056819840,189581333760,2938083321600,48416639846400,845487698227200,15598004134809600,303161985274982400,6191998554470400000,132599321499875328000,2970952207377960960000", "code": "\nfrom sympy import factorial, harmonic\ndef a(n): return factorial(n-2)*(harmonic(n)*(n-1) - n)*n\nprint([a(n) for n in range(2, 26)]) \n"}
{"sequence_id": "A289831", "text": "a(n) = A289813(n) + A289814(n).", "sequence": "0,1,1,2,3,3,2,3,3,4,5,5,6,7,7,6,7,7,4,5,5,6,7,7,6,7,7,8,9,9,10,11,11,10,11,11,12,13,13,14,15,15,14,15,15,12,13,13,14,15,15,14,15,15,8,9,9,10,11,11,10,11,11,12,13,13,14,15,15,14,15,15,12", "code": "\nfrom sympy.ntheory.factor_ import digits\nfrom sympy import sign\ndef a(n):\n    d=digits(n, 3)[1:]\n    return int(''.join(str(sign(i)) for i in d), 2)\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A289832", "text": "Triangle read by rows: T(n,k) = number of rectangles all of whose vertices lie on an (n+1) X (k+1) rectangular grid.", "sequence": "1,3,10,6,20,44,10,33,74,130,15,49,110,198,313,21,68,152,276,443,640,28,90,200,364,592,866,1192,36,115,254,462,756,1113,1550,2044,45,143,314,570,935,1385,1944,2586,3305,55,174,380,688,1129,1680,2370,3172,4081,5078", "code": "\nfrom math import gcd\ndef countObliques(a,b,c,d,n,k):\n    if(gcd(a, b) == 1): \n        boundingBox={'width':(b * c) + (a * d),'height':(a * c) + (b * d)}\n        if(boundingBox['width']<n and boundingBox['height']<k):\n            return (n - boundingBox['width']) * (k - boundingBox['height'])\n    return 0\ndef totalRectangles(n,k):\n    \n    ret=(n*(n-1)*k*(k-1))/4\n    \n    ret+=sum(countObliques(a,b,c,d,n,k) for a in range(1,n) \\\n                                        for b in range(1,n) \\\n                                        for c in range(1,k) \\\n                                        for d in range(1,k))\n    return ret\nTnk=[[totalRectangles(n+1,k+1) for k in range(1, n+1)] for n in range(1, 20)]\nprint(Tnk)\n"}
{"sequence_id": "A289834", "text": "Number of perfect matchings on n edges which represent RNA secondary folding structures characterized by the Lyngso and Pedersen (L&P) family and the Cao and Chen (C&C) family.", "sequence": "1,1,3,11,39,134,456,1557,5364,18674,65680,233182,834796,3010712,10929245,39904623,146451871,539972534,1999185777,7429623640,27705320423,103636336176,388775988319,1462261313876,5513152229901,20832701135628,78884459229627", "code": "\nfrom functools import cache\n@cache\ndef a(n):\n    return (\n        [1, 1, 3, 11][n]\n        if n < 4\n        else (\n              2 * (74 * n ** 2 - 69 * n - 110) * a(n - 1)\n            - 3 * (89 * n ** 2 - 139 * n - 70) * a(n - 2)\n            + 2 * (91 * n ** 2 - 204 * n - 52) * a(n - 3)\n            - 4 * (5 * n + 1) * (2 * n - 7) * a(n - 4)\n        )\n        // ((n + 2) * (23 * n - 43))\n    )\nprint([a(n) for n in range(27)])\n\n"}
{"sequence_id": "A289836", "text": "Numbers k such that floor(e*k + Pi) is a square.", "sequence": "5,17,29,36,52,71,132,146,177,211,229,330,648,744,956,1112,1368,1413,1459,1506,1700,1906,2124,2295,2657,2720,2848,2913,2979,3181,3319,3532,3678,3902,3978,4055,4211,4290,4780,5035", "code": "\nfrom gmpy2 import is_square\nfrom mpmath import *\nmp.dps=100\ndef ok(n): return is_square(int(nint(floor(exp(1)*n + pi))))\nprint([n for n in range(1, 6001) if ok(n)]) \n"}
{"sequence_id": "A289838", "text": "a(n) = A289815(n) * A289816(n).", "sequence": "1,2,2,3,6,6,3,6,6,4,10,10,12,30,30,12,30,30,4,10,10,12,30,30,12,30,30,5,14,14,15,42,42,15,42,42,20,70,70,60,210,210,60,210,210,20,70,70,60,210,210,60,210,210,5,14,14,15,42,42,15,42,42,20,70,70", "code": "\nfrom sympy import gcd, primefactors\ndef omega(n): return 0 if n==1 else len(primefactors(n))\ndef a(n):\n    v, o = 1, 2\n    while True:\n        if n==0: return v\n        if gcd(v, o)==1 and omega(o)==1:\n            if n%3: v*=o\n            n //= 3\n        o+=1\nprint([a(n) for n in range(101)]) \n"}
{"sequence_id": "A289869", "text": "Square array T(n,k) (n>=0, k>=0) read by antidiagonals downwards: T(n,k) = A005836(n) + 2*A005836(k).", "sequence": "0,2,1,6,3,3,8,7,5,4,18,9,9,6,9,20,19,11,10,11,10,24,21,21,12,15,12,12,26,25,23,22,17,16,14,13,54,27,27,24,27,18,18,15,27,56,55,29,28,29,28,20,19,29,28,60,57,57,30,33,30,30,21,33,30,30,62,61,59", "code": "\ndef T(n, k): return int(bin(n)[2:], 3) + 2*int(bin(k)[2:], 3)\nfor n in range(11): print [T(k, n - k) for k in range(n + 1)] \n"}
{"sequence_id": "A289900", "text": "Number of maximal matchings in the n-triangular honeycomb rook graph.", "sequence": "1,1,3,9,135,2025,212625,22325625,21097715625,19937341265625,207248662456171875,2154349846231906640625,291128066470548703880859375,39341591262497599098939931640625,79746389028864195813528714933837890625", "code": "\nfrom sympy import factorial2, ceiling\nfrom operator import mul\ndef a001147(n):\n    return factorial2(2*n - 1)\ndef a(n):\n    return reduce(mul, [a001147(ceiling(k/2)) for k in range(1, n + 1)])\nprint([a(n) for n in range(1, 31)]) \n"}
{"sequence_id": "A290059", "text": "a(n) = binomial(2*prime(n)-1, prime(n)-1) where prime(n) is the n-th prime.", "sequence": "3,10,126,1716,352716,5200300,1166803110,17672631900,4116715363800,15033633249770520,232714176627630544,873065282167813104916,212392290424395860814420,3318776542511877736535400,812850570172585125274307760,3136262529306125724764953838760", "code": "\nfrom sympy import prime, binomial\ndef a(n):\n    p=prime(n)\n    return binomial(2*p - 1, p - 1)\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A290099", "text": "Multiplicative with a(2^e) = (-1)^e and a(p^e) = prevprime(p)^e for odd primes p.", "sequence": "1,-1,2,1,3,-2,5,-1,4,-3,7,2,11,-5,6,1,13,-4,17,3,10,-7,19,-2,9,-11,8,5,23,-6,29,-1,14,-13,15,4,31,-17,22,-3,37,-10,41,7,12,-19,43,2,25,-9,26,11,47,-8,21,-5,34,-23,53,6,59,-29,20,1,33,-14,61,13,38,-15,67,-4,71,-31,18,17,35,-22,73,3,16,-37,79,10,39,-41,46,-7,83,-12,55", "code": "\nfrom sympy import factorint, prevprime\nfrom operator import mul\nfrom functools import reduce\ndef a(n): return 1 if n==1 else reduce(mul, [(-1)**e if p==2 else prevprime(p)**e for p, e in factorint(n).items()])\nprint([a(n) for n in range(1, 61)]) \n"}
{"sequence_id": "A290100", "text": "Start from the singleton set S = {n}, and unless 1 is already a member of S, generate on each iteration a new set where each odd number k is replaced by 3k+1, and each even number k is replaced by 3k+1 and k/2. a(n) is the size of the set after the first iteration which has produced 1 as a member.", "sequence": "1,2,12,3,8,23,381,5,73,12,187,47,39,786,537,8,109,124,2020,23,19,381,267,81,7768,60,6061,73,1238,1128,118945,12,1120,187,141,234,190,3999,18578,39,3394,28,2896,747,576,537,56496,128,533,606,9757,109,95,12337,8656,118,11306,2020,9309,2309,1789,258213,176262,19", "code": "\nfrom sympy import flatten\ndef a(n):\n    if n==1: return 1\n    L=[n]\n    while not 1 in L:\n        L=sorted(list(set(flatten([[3*k + 1, k/2] if k%2==0 else 3*k + 1 for k in L]))))\n    return len(L)\nfor i in range(1, 101): print(a(i)) \n"}
{"sequence_id": "A290101", "text": "a(n) = dropping time for the modified Collatz problem, where x -> 3x+1 if x is odd, and x -> either x/2 or 3x+1 if x is even (minimal number of any such steps to reach a lower number than the starting value n); a(1) = 0 by convention.", "sequence": "0,1,6,1,3,1,11,1,3,1,8,1,3,1,11,1,3,1,6,1,3,1,8,1,3,1,16,1,3,1,19,1,3,1,6,1,3,1,11,1,3,1,8,1,3,1,16,1,3,1,6,1,3,1,8,1,3,1,11,1,3,1,19,1,3,1,6,1,3,1,13,1,3,1,8,1,3,1,13,1,3,1,6,1,3,1,8,1,3,1,11,1,3,1,13,1,3,1,6,1,3,1,16,1,3,1,8,1,3", "code": "\nfrom sympy import flatten\ndef ok(n, L):\n    return any(i < n for i in L)\ndef a(n):\n    if n==1: return 0\n    L=[n]\n    i = 0\n    while not ok(n, L):\n        L=set(flatten([[3*k + 1, k//2] if k%2==0 else 3*k + 1 for k in L]))\n        i+=1\n    return i\nprint([a(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A290102", "text": "Start from the singleton set S = {n}, and generate on each iteration a new set where each odd number k is replaced by 3k+1, and each even number k is replaced by 3k+1 and k/2. a(n) is the size of the set after the first iteration which has produced a number smaller than n. a(1) = 1 by convention.", "sequence": "1,2,9,2,3,2,52,2,3,2,18,2,3,2,49,2,3,2,9,2,3,2,18,2,3,2,395,2,3,2,1108,2,3,2,9,2,3,2,52,2,3,2,18,2,3,2,360,2,3,2,9,2,3,2,18,2,3,2,57,2,3,2,1116,2,3,2,9,2,3,2,115,2,3,2,18,2,3,2,109,2,3,2,9,2,3,2,18,2,3,2,56,2,3,2,105,2,3,2,9,2,3,2,368,2,3,2,18", "code": "\nfrom sympy import flatten\ndef ok(n, L):\n    return any(i < n for i in L)\ndef a(n):\n    if n==1: return 1\n    L=[n]\n    while not ok(n, L):\n        L=set(flatten([[3*k + 1, k//2] if k%2==0 else 3*k + 1 for k in L]))\n    return len(L)\nprint([a(n) for n in range(1, 121)]) \n"}
{"sequence_id": "A290125", "text": "Square array read by antidiagonals T(n,k) = sigma(k + n) - sigma(k) - n, with n>=0 and k>=1.", "sequence": "0,0,1,0,0,1,0,2,2,3,0,-2,0,0,1,0,5,3,5,5,6,0,-5,0,-2,0,0,1,0,6,1,6,4,6,6,7,0,-3,3,-2,3,1,3,3,4,0,4,1,7,2,7,5,7,7,8,0,-7,-3,-6,0,-5,0,-2,0,0,1,0,15,8,12,9,15,10,15,13,15,15,16", "code": "\nfrom sympy import divisor_sigma\nl=[]\ndef T(n, k):\n    return 0 if n==0 or k==0 else divisor_sigma(k + n) - divisor_sigma(k) - n\nfor n in range(11): l+=[T(k, n - k + 1) for k in range(n + 1)]\nprint(l) \n"}
{"sequence_id": "A290126", "text": "Least k such that the sum of the n greatest divisors of k is a prime number.", "sequence": "2,2,4,28,16,140,24,90,120,108,60,144,300,288,120,672,252,432,240,630,960,756,480,1200,1080,1728,1680,1008,720,2016,840,3150,2160,2700,1980,4800,2520,3780,3240,8736,3960,3600,6720,6930,10800,6300,4200,16848,9240,5040", "code": "\nfrom sympy import divisors, isprime\ndef A290126(n):\n    i = 1\n    while len(divisors(i)) < n or not isprime(sum(divisors(i)[-n:])):\n        i += 1\n    return i \n"}
{"sequence_id": "A290131", "text": "Number of regions in a regular drawing of the complete bipartite graph K_{n,n}.", "sequence": "0,2,12,40,96,204,368,634,1012,1544,2236,3186,4360,5898,7764,10022,12712,16026,19844,24448,29708,35756,42604,50602,59496,69650,80940,93600,107540,123316,140428,159642,180632,203618,228556,255822,285080,317326,352020,389498", "code": "\nfrom math import gcd\ndef a115004(n):\n    r=0\n    for a in range(1, n + 1):\n        for b in range(1, n + 1):\n            if gcd(a, b)==1:r+=(n + 1 - a)*(n + 1 - b)\n    return r\ndef a(n): return a115004(n - 1) + (n - 1)**2\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A290131", "text": "Number of regions in a regular drawing of the complete bipartite graph K_{n,n}.", "sequence": "0,2,12,40,96,204,368,634,1012,1544,2236,3186,4360,5898,7764,10022,12712,16026,19844,24448,29708,35756,42604,50602,59496,69650,80940,93600,107540,123316,140428,159642,180632,203618,228556,255822,285080,317326,352020,389498", "code": "\nfrom sympy import totient\ndef A290131(n): return 2*(n-1)**2 + sum(totient(i)*(n-i)*(2*n-i) for i in range(2,n)) \n"}
{"sequence_id": "A290132", "text": "The number of edges in a graph induced by a regular drawing of K_{n,n}.", "sequence": "1,6,24,74,170,362,642,1110,1766,2706,3894,5558,7602,10326,13562,17510,22178,28006,34634,42722,51922,62570,74450,88462,103994,121862,141482,163610,187886,215578,245430,279198,315958,356390,399830,447542,498626,555278,615698,681206", "code": "\nfrom math import gcd\ndef a115004(n):\n    r=0\n    for a in range(1, n + 1):\n        for b in range(1, n + 1):\n            if gcd(a, b)==1:r+=(n + 1 - a)*(n + 1 - b)\n    return r\ndef a159065(n):\n    c=0\n    for a in range(1, n):\n        for b in range(1, n):\n            if gcd(a, b)==1:\n                c+=(n - a)*(n - b)\n                if 2*a<n and 2*b<n:c-=(n - 2*a)*(n - 2*b)\n    return c\ndef a290131(n): return a115004(n - 1) + (n - 1)**2\ndef a(n): return 2*n + a290131(n) + a159065(n) - 1\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A290154", "text": "Smallest number k such that exactly half the numbers in [1..k] are prime(n)-smooth.", "sequence": "6,20,42,78,118,184,248,332,428,534,654,772,906,1052,1208,1388,1562,1754,1958,2164,2396,2638,2896,3144,3424,3682,3986,4304,4622,4976,5286,5652,6002,6374,6748,7148,7532,7934,8356,8786,9224,9684,10158,10618,11114,11604", "code": " \nfrom sympy import factorint, prevprime, primerange, prod\ndef aupto(limit):\n    adict, pN = dict(), prevprime(limit+1)\n    pi = {p: i for i, p in enumerate(primerange(1, pN+1), start=1)}\n    smooth = {i: 0 for i in pi.values()}\n    watching = smooth[0] = 1  \n    for n in range(2, limit+1):\n        f = factorint(n, limit=pN)\n        nt = prod(p**f[p] for p in f if p <= pN)\n        if nt == n: smooth[pi[max(f)]] += 1\n        if 2*sum(smooth[i] for i in range(watching+1)) == n:\n            adict[watching] = n\n            watching += 1\n    return sorted(adict.values())\nprint(aupto(12000)) \n"}
{"sequence_id": "A290155", "text": "Let a(n) be the sequence of 0's and 1's that represents n. Then a(0) = 0; and a((1b)_2) = 1a(|b|)b where |b| denotes the length of b.", "sequence": "0,10,1100,1101,1110000,1110001,1110010,1110011,11101000,11101001,11101010,11101011,11101100,11101101,11101110,11101111,111100000000,111100000001,111100000010,111100000011,111100000100,111100000101,111100000110,111100000111", "code": "\ndef a(n):\n    b = bin(n)[3:]\n    return 0 if n == 0 else int('1' + str(a(len(b))) + b)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A290171", "text": "Numbers k such that (k-1)^2 < (k-1)! mod k^2.", "sequence": "5,13,563,1277,780887", "code": "\ndef ok(n):\n    nn = n**2; f = 1%nn\n    for k in range(1, n): f = f*k%nn\n    return (n-1)**2 < f\nprint(list(filter(ok, range(1, 1300)))) \n"}
{"sequence_id": "A290171", "text": "Numbers k such that (k-1)^2 < (k-1)! mod k^2.", "sequence": "5,13,563,1277,780887", "code": " \nfrom math import factorial\ndef afind(limit, startk=1):\n    k = startk; kkprev = (k-1)**2; f = factorial(k-1)\n    while k < limit:\n        kk = k*k\n        if kkprev < f%kk: print(k, end=\", \")\n        kkprev = kk; f *= k; k += 1\nafind(10000) \n"}
{"sequence_id": "A290284", "text": "Number of pairs of integers (x,y) satisfying the Diophantine equation x^2 - A000037(n)*y^2 = m such that x/y gives a convergent series towards sqrt(A000037(n)).", "sequence": "3,3,5,4,5,4,7,6,5,15,8,5,9,7,12,6,10,12,9,6,11,9,12,21,7,17,9,10,11,7,13,10,9,9,19,8,20,15,13,24,12,8,15,12,16,27,16,13,9,14,27,17,12", "code": "\nfrom fractions import Fraction\ndef FracSqrt(p):\n....a = Fraction(p/1)\n....b = Fraction(1/1)\n....e = Fraction(10**(-200))\n....while a-b > e:\n........a = (a+b)/2\n........b = p/a\n....return a\nprint(\"number: \")\npp = int(input())\np = FracSqrt(pp)\nn = 0\nwhile n >= 0:\n....n = n+1\n....q = p.limit_denominator(n)\n....if (n == 1) or (q != q0):\n........t = q*n\n........m = t*t-pp*n*n\n........print(n,q,m)\n....q0 = q\n"}
{"sequence_id": "A290285", "text": "Determinant of circulant matrix of order 3 with entries in the first row (-1)^j * Sum_{k>=0} binomial(n,3*k+j), j=0,1,2.", "sequence": "1,0,0,62,666,5292,39754,307062,2456244,19825910,159305994,1274445900,10184391946,81430393590,651443132340,5212260963062,41700950994186,333607607822412,2668815050206474,21350337149539062,170802697195263924,1366424509598012150", "code": "\nfrom sympy.matrices import Matrix\nfrom sympy import binomial\ndef mj(j, n):\n    return (-1)**j*sum(binomial(n, 3*k + j) for k in range(n//3 + 1))\ndef a(n):\n    m=Matrix(3, 3, [0]*9)\n    for j in range(3):m[0, j]=mj(j, n)\n    for j in range(1, 3):m[1, j]=m[0, j - 1]\n    m[1, 0]=m[0, 2]\n    for j in range(1, 3):m[2, j] = m[1, j - 1]\n    m[2, 0]=m[1, 2]\n    return m.det()\nprint([a(n) for n in range(22)]) \n"}
{"sequence_id": "A290286", "text": "Determinant of circulant matrix of order 4 with entries in the first row (-1)^j*Sum_{k>=0}(-1)^k*binomial(n, 4*k+j), j=0,1,2,3.", "sequence": "1,0,0,0,-1008,-37120,-473600,0,63996160,702013440,2893578240,0,-393379835904,-12971004067840,-160377313820672,0,21792325059543040,239501351489372160,987061897553510400,0,-134124249770961666048,-4422152303189489090560", "code": "\nfrom sympy.matrices import Matrix\nfrom sympy import binomial\ndef mj(j, n): return (-1)**j*sum((-1)**k*binomial(n, 4*k + j) for k in range(n//4 + 1))\ndef a(n):\n    m=Matrix(4, 4, lambda i,j: mj((i-j)%4,n))\n    return m.det()\nprint([a(n) for n in range(22)]) \n"}
{"sequence_id": "A290323", "text": "Minimal number of supporters among total of n voters that may make (but not guarantee) their candidate win in a multi-level selection based on the majority vote at each level.", "sequence": "1,2,2,3,3,4,4,5,4,6,6,6,7,8,6,9,9,8,10,9,8,12,12,10,9,14,8,12,15,12,16,15,12,18,12,12,19,20,14,15,21,16,22,18,12,24,24,18,16,18,18,21,27,16,18,20,20,30,30,18,31,32,16,25,21,24,34,27", "code": "\nfrom sympy import factorint\nfrom functools import reduce\nfrom operator import mul\ndef A290323(n):\n    f = factorint(n)\n    m = f[2] if 2 in f else 0\n    a, b = divmod(m,3)\n    c = 2 if m == 1 else 3**(b*(b+1)%5)*5**(a-(b%2))\n    return c*reduce(mul,(((d+1)//2)**f[d] for d in f if d != 2),1) \n"}
{"sequence_id": "A290324", "text": "Number of (undirected) paths in the complete tripartite graph K_{n,n,n}.", "sequence": "6,396,67554,28336848,23986682550,35931274250076,87017657752978386,318992998488391738944,1683675635040443830593798,12301777316059025283613106700,120545445185882926234784081616546,1543421856441404929844846263740167376", "code": "\nfrom sympy import binomial, factorial\ndef c(n, k, i, j, p): return binomial(n, k)*binomial(n, i + p)*binomial(n, j + p)*binomial(k, i)*binomial(k - i, j)*factorial(k)*factorial(i + p)*factorial(j + p)*2**(k - i - j)*binomial(p + i + j - 1, k - 1)*(1 + n - k)\ndef a(n): return 3*sum([sum([sum([sum([c(n, k, i, j, p) for p in range(k - i - j, n + 1)]) for j in range(k - i + 1)]) for i in range(k + 1)]) for k in range(1, n + 1)])/2\nprint([a(n) for n in range(1, 13)]) \n"}
{"sequence_id": "A290371", "text": "Integers k such that f(k) - f(k-1) equals 1, where f(n) = floor(n/exp(sqrt(log(n)))).", "sequence": "3,9,16,24,33,42,51,61,71,82,93,104,115,127,139,151,163,175,188,200,213,226,239,253,266,279,293,307,321,335,349,363,377,392,406,421,436,451,465,480,495,511,526,541,557,572,588,603,619,635,650,666,682,698,714,730", "code": "\nfrom sympy import floor, exp, sqrt, log\ndef f(n): return floor(n/exp(sqrt(log(n))))\nprint([n for n in range(2, 1001) if f(n) - f(n - 1) == 1]) \n"}
{"sequence_id": "A290434", "text": "Semiprimes of the form pq such that p+q+1 is prime.", "sequence": "4,9,21,25,35,39,55,57,65,77,85,111,115,121,129,155,161,185,187,201,203,205,209,221,235,237,265,291,299,305,309,319,323,327,335,341,365,371,377,381,391,413,415,437,451,485,489,493,497,505,515,517,529,535,579", "code": "\nfrom sympy import factorint, isprime\nA290434_list = [n for n in range(2,10**5) if sum(factorint(n).values()) == 2 and isprime(1+sum(factorint(n).keys())*(3-len(factorint(n))))]\n"}
{"sequence_id": "A290435", "text": "Semiprimes of the form pq where p < q and p+q+1 is prime.", "sequence": "21,35,39,55,57,65,77,85,111,115,129,155,161,185,187,201,203,205,209,221,235,237,265,291,299,305,309,319,323,327,335,341,365,371,377,381,391,413,415,437,451,485,489,493,497,505,515,517,535,579,611,623,649,655", "code": "\nfrom sympy import factorint, isprime\nA290435_list = [n for n in range(2,10**5) if sum(factorint(n).values()) == len(factorint(n)) == 2 and isprime(1+sum(factorint(n).keys()))]\n"}
{"sequence_id": "A290447", "text": "Consider n equally spaced points along a line and join every pair of points by a semicircle above the line; a(n) is the number of intersection points.", "sequence": "0,0,0,1,5,15,35,70,124,200,300,445,627,875,1189,1564,2006,2568,3225,4035,4972,6030,7250,8701,10323,12156,14235,16554,19124,22072,25250,28863,32827,37166,41949,47142,52653,58794,65503,72741,80437", "code": "\nfrom itertools import combinations\nfrom fractions import Fraction\ndef A290447(n):\n    p,p2 = set(), set()\n    for b,c,d in combinations(range(1,n),3):\n        e = b + d - c\n        f1, f2, g = Fraction(b*d,e), Fraction(b*d*(c-b)*(d-c),e**2), (n-1)*e - 2*b*d\n        for i in range(n-d):\n            if 2*i*e < g:\n                p2.add((i+f1, f2))\n            elif 2*i*e == g:\n                p.add(f2)\n            else:\n                break\n    return len(p)+2*len(p2) \n"}
{"sequence_id": "A290480", "text": "Product of proper unitary divisors of n.", "sequence": "1,1,1,1,1,6,1,1,1,10,1,12,1,14,15,1,1,18,1,20,21,22,1,24,1,26,1,28,1,27000,1,1,33,34,35,36,1,38,39,40,1,74088,1,44,45,46,1,48,1,50,51,52,1,54,55,56,57,58,1,216000,1,62,63,1,65,287496,1,68,69,343000,1,72,1,74,75,76,77,474552,1,80", "code": "\nfrom sympy import divisors, gcd, prod\ndef a(n): return prod(d for d in divisors(n) if gcd(d, n//d) == 1)//n\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A290585", "text": "a(n) is the largest number <= n such that 1 + a(1)*a(2)*...*a(n) is prime.", "sequence": "1,2,3,3,4,6,6,4,7,7,3,10,13,12,10,9,13,14,15,16,13,21,22,11,25,26,27,17,29,23,7,11,30,24,34,1,1,1,1,1,1,1,1,1,45,39,23,48,32,25,44,49,53,31,1,1,1,1,59,46,53,55,62,40,62,59,46,41,9,62,59,64,1,1,1,1,1,1,1,80,57,78,80,1,85", "code": "\nfrom sympy import isprime\nA=[0, 1]\np=1\nfor n in range(2, 201):\n    for k in range(n, -1, -1):\n        if isprime(1 + k*p):\n            A.append(k)\n            p*=k\n            break\nprint(A[1:]) \n"}
{"sequence_id": "A290637", "text": "Numerators of the sequence 1, 1/2, (1/2)/(3/4), ((1/2)/(3/4))/((5/6)/(7/8)), ... .", "sequence": "1,1,2,7,286,144305,276620298878,4929053594885296570083,2778177345800469611391891486368048702791639566906088871615186", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import numer, Rational\n@cacheit\ndef g(i, j): return Rational(i) if j==0 else g(i, j - 1)/g(i + 2**(j - 1), j - 1)\ndef a(n): return numer(g(1, n))\nprint([a(n) for n in range(11)]) \n"}
{"sequence_id": "A290638", "text": "Denominators of the sequence 1, 1/2, (1/2)/(3/4), ((1/2)/(3/4))/((5/6)/(7/8)), ... .", "sequence": "1,2,3,10,405,204102,391202754597,6970736012254534531250,3928936098952203755159851968781175221199855588403024634921875", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import denom, Rational\n@cacheit\ndef g(i, j): return Rational(i) if j==0 else g(i, j - 1)/g(i + 2**(j - 1), j - 1)\ndef a(n): return denom(g(1, n))\nprint([a(n) for n in range(12)]) \n"}
{"sequence_id": "A290641", "text": "Multiplicative with a(p^e) = prime(p-1)^e.", "sequence": "1,2,3,4,7,6,13,8,9,14,29,12,37,26,21,16,53,18,61,28,39,58,79,24,49,74,27,52,107,42,113,32,87,106,91,36,151,122,111,56,173,78,181,116,63,158,199,48,169,98,159,148,239,54,203,104,183,214,271,84,281,226,117,64,259", "code": "\nfrom sympy import factorint, prime\nfrom operator import mul\nfrom functools import reduce\ndef a(n):\n    return 1 if n==1 else reduce(mul, [prime(p - 1)**e for p, e in factorint(n).items()])\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A290675", "text": "For a given n, the nonzero digits of n are the prime indices for the factorization of n.", "sequence": "14,154,1196,66079,279174,302768895,2249805789", "code": "\nfrom functools import reduce\nfrom operator import mul\nfrom itertools import combinations_with_replacement\nA290675_list, lmax, ptuple = [], 12, (2,3,5,7,11,13,17,19,23)\nfor l in range(1,lmax+1):\n    for d in combinations_with_replacement(range(1,10),l):\n        n = reduce(mul,(ptuple[i-1] for i in d))\n        if n < 10**lmax and tuple(sorted((int(x) for x in str(n) if x != '0'))) == d:\n            A290675_list.append(n) \n"}
{"sequence_id": "A290759", "text": "Square array A(n,k), n>=0, k>=0, read by antidiagonals, where column k is the expansion of continued fraction 1/(1 - x/(1 - k*x/(1 - k^2*x/(1 - k^3*x/(1 - k^4*x/(1 - ...)))))).", "sequence": "1,1,1,1,1,1,1,1,2,1,1,1,3,5,1,1,1,4,17,14,1,1,1,5,43,171,42,1,1,1,6,89,1252,3113,132,1,1,1,7,161,5885,104098,106419,429,1,1,1,8,265,20466,1518897,25511272,7035649,1430,1,1,1,9,407,57799,12833546,1558435125,18649337311,915028347,4862,1", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef A(n, k): return 1 if n==0 else sum(A(j, k)*A(n - j - 1, k)*k**j for j in range(n))\nfor n in range(13): print([A(k, n - k) for k in range(n + 1)]) \n"}
{"sequence_id": "A290772", "text": "Number of cyclic Gray codes of length 2n which include all-0 bit sequence and use the least possible number of bits.", "sequence": "1,2,24,12,2640,7536,9408,2688,208445760,1082368560,4312566720,12473296800,24050669760", "code": "\nfrom math import log2, ceil\ndef cyclic_gray(nb, n, a):\n    if len(a) == n:\n        if bin(a[-1]).count('1') == 1:\n            return 1\n        return 0\n    r = 0\n    for i in range(nb):\n        x = a[-1] ^ (1<<i)\n        if x not in a:\n            r += cyclic_gray(nb, n, a+[x])\n    return r\nprint([cyclic_gray(ceil(log2(n))+1, n*2, [0]) for n in range(1, 9)])\n\n"}
{"sequence_id": "A290777", "text": "a(n) = n-th Carlitz-Riordan q-Catalan number (recurrence version) for q = n.", "sequence": "1,1,3,43,5885,12833546,583552122727,667480099386451779,22507185898866512901924729,25700910736350654917922270058287454,1123582754598967452437582737448130799606015691,2098715344599001562385695830901626594365732485934286582686", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n, k):\n    if n == 0:\n        return 1\n    return sum(b(j, k) * b(n - j - 1, k) * k**j for j in range(n))\ndef a(n): return b(n, n)\nprint([a(n) for n in range(16)]) \n"}
{"sequence_id": "A290786", "text": "a(n) = n-th Carlitz-Riordan q-Catalan number (recurrence version) for q = -n.", "sequence": "1,1,-1,-23,3429,8425506,-412878084725,-497641562809372379,17436260499054618815283977,20503694883570579788445502041773422,-917439693541287252616828116888122637934368489,-1746281566732870051764961051797990328294109372786185933382", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n, k): return 1 if n==0 else sum([b(j, k)*b(n - j - 1, k)*(-k)**j for j in range(n)])\ndef a(n): return b(n, n)\nprint([a(n) for n in range(16)]) \n"}
{"sequence_id": "A290789", "text": "A(n,k) is the n-th Carlitz-Riordan q-Catalan number (recurrence version) for q = -k; square array A(n,k), n>=0, k>=0, read by antidiagonals.", "sequence": "1,1,1,1,1,1,1,1,0,1,1,1,-1,-1,1,1,1,-2,-7,0,1,1,1,-3,-23,47,2,1,1,1,-4,-55,586,873,0,1,1,1,-5,-109,3429,48778,-26433,-5,1,1,1,-6,-191,13436,885137,-11759396,-1749159,0,1,1,1,-7,-307,40915,8425506,-904638963,-8596478231,220526159,14,1", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef A(n, k):\n    return 1 if n==0 else sum(A(j, k)*A(n - j - 1, k)*(-k)**j for j in range(n))\nfor d in range(16): print([A(n, d - n) for n in range(d + 1)]) \n"}
{"sequence_id": "A290801", "text": "a(n) is the least number of steps to get to n from 0 using only the operations of incrementation, decrementation, and squaring.", "sequence": "0,1,2,3,3,4,5,6,5,4,5,6,7,7,6,5,4,5,6,7,8,9,8,7,6,5,6,7,8,9,10,11,10,9,8,7,6,7,8,9,10,11,12,13,12,11,10,9,8,7,8,9,10,11,12,13,14,13,12,11,10,9,8,7,6,7,8,9,10,11,12,13,14,13,12,11,10,9,8,7,6,5,6,7,8,9,10,11,12,13", "code": "\n\nfrom sympy.core.cache import cacheit\nfrom sympy.core.power import isqrt\n@cacheit\ndef a(n):\n    if n<4: return n\n    else:\n        s=isqrt(n)\n        return 1 + (a(s) if s**2==n else min(a(s) + n - s**2, a(s + 1) + (s + 1)**2 - n))\nprint([a(n) for n in range(91)]) \n"}
{"sequence_id": "A290847", "text": "Number of dominating sets in the n-triangular graph.", "sequence": "1,7,57,973,32057,2079427,267620753,68649126489,35172776136145,36025104013571583,73784683970720501897,302228664636911612364581,2475873390079769597467385417,40564787539999607393632514635067,1329227699017403425105119604848703905", "code": "\nfrom sympy import binomial\ndef b(n): return sum((-1)**(n - k)*binomial(n, k)*2**binomial(k, 2) for k in range(n + 1))\ndef a(n): return b(n) + n*b(n - 1)\nprint([a(n) for n in range(2, 21)]) \n"}
{"sequence_id": "A291115", "text": "Number of endofunctions on [n] such that the LCM of their cycle lengths equals nine.", "sequence": "0,0,0,0,0,0,0,0,0,40320,4032000,266112000,15008716800,794060467200,41179634496000,2142915046272000,113401428940800000,6150985123214131200,343578020565722342400,19818131438503157760000,1182304993642509574656000,73005714001076187082752000", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial, lcm, factorial as f\n@cacheit\ndef b(n, m): return 0 if m>9 else (1 if m==9 else 0) if n==0 else sum([b(n - j, lcm(m, j))*binomial(n - 1, j - 1)*f(j - 1) for j in range(1, n + 1)])\ndef a(n): return sum([b(j, 1)*n**(n - j)*binomial(n - 1, j - 1) for j in range(n + 1)])\nprint([a(n) for n in range(26)]) \n"}
{"sequence_id": "A291116", "text": "Number of endofunctions on [n] such that the LCM of their cycle lengths equals ten.", "sequence": "0,0,0,0,0,0,0,504,32256,1460592,59814720,2403157680,98055619200,4129943329512,180976836968928,8281570545448200,396324506640142080,19840151844921504096,1038497761573246945152,56790713866712335971552,3241264004352759793685760", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial, lcm, factorial as f\n@cacheit\ndef b(n, m): return 0 if m>10 else (1 if m==10 else 0) if n==0 else sum([b(n - j, lcm(m, j))*binomial(n - 1, j - 1)*f(j - 1) for j in range(1, n + 1)])\ndef a(n): return sum([b(j, 1)*n**(n - j)*binomial(n - 1, j - 1) for j in range(n + 1)])\nprint([a(n) for n in range(26)]) \n"}
{"sequence_id": "A291175", "text": "Numbers k such that lambda(k) = lambda(k-1) + lambda(k-2), where lambda(k) is Carmichael lambda function (A002322).", "sequence": "3,5,7,11,13,22,46,371,717,1379,1436,1437,3532,5146,12209,35652,45236,58096,93932,130170,263589,327095,402056,680068,808303,814453,870689,991942,1178628,1670065,1686526,2041276,2319102,2324004,3869372,4290742,4449280", "code": "\nfrom sympy import reduced_totient\nA291175_list, a, b, c, n = [], 1, 1, 2, 3\nwhile n < 10**6:\n    if c == a + b:\n        A291175_list.append(n)\n        print(len(A291175_list),n)\n    n += 1\n    a, b, c = b, c, reduced_totient(n) \n"}
{"sequence_id": "A291199", "text": "Primes p such that phi(p*(p+1)/2) is a triangular number (A000217).", "sequence": "2477,44287823,58192759,110369351,664009019,2574106333,6870260119,7423240007,60370077539,188271042191,235399729007,236767359977,305214702643,717724689959", "code": "\nfrom __future__ import division\nfrom sympy.ntheory.primetest import is_square\nfrom sympy import totient, nextprime\nA291199_list, p = [], 3\nwhile p < 10**8:\n    if is_square(8*(p-1)*totient((p+1)//2)+1):\n        A291199_list.append(p)\n    p = nextprime(p) \n"}
{"sequence_id": "A291301", "text": "a(n) = prime that is eventually reached when x -> sigma(x)-1 is repeatedly applied to the product of the first n primes, or -1 if no prime is ever reached.", "sequence": "2,11,71,743,6911,117239,2013983,34836479,921086711,33596203871,18754852859999,1306753691335679,2795529813471359,200489563747397471,7143750592470475271,146095655504943513599,161739770170976834876927,543475838478389870591999,317180662337566737324195839", "code": "\nfrom sympy import primorial, isprime, divisor_sigma\ndef A291301(n):\n    m = primorial(n)\n    while not isprime(m):\n        m = divisor_sigma(m) - 1\n    return m \n"}
{"sequence_id": "A291302", "text": "a(n) = number of steps to reach a prime when x -> sigma(x)-1 is repeatedly applied to the product of the first n primes, or -1 if no prime is ever reached.", "sequence": "0,1,1,2,1,3,3,1,3,4,46,57,7,9,17,1,45,1,33,8,10,4,3,32,6,47,17,21,41,17,12,11,10,31,74,25,99,11", "code": "\nfrom sympy import primorial, isprime, divisor_sigma\ndef A291302(n):\n    m, c = primorial(n), 0\n    while not isprime(m):\n        m = divisor_sigma(m) - 1\n        c += 1\n    return c \n"}
{"sequence_id": "A291340", "text": "Primes p such that phi(p*(p-1)/2) is a triangular number (A000217).", "sequence": "2,617,11243,72817,134213,1083601,1301617,669175321,2759347757,5023245823,10904836391,11230923643,12828977503,27741297781", "code": "\nfrom __future__ import division\nfrom sympy.ntheory.primetest import is_square\nfrom sympy import totient, nextprime\nA291340_list, p = [2], 3\nwhile p < 10**6:\n    if is_square(8*(p-1)*totient((p-1)//2)+1):\n        A291340_list.append(p)\n    p = nextprime(p)\n"}
{"sequence_id": "A291365", "text": "Number of closed Sturmian words of length n.", "sequence": "2,2,4,6,12,16,26,36,52,64,86,108,142,170,206,242,294,340,404,468,544,610,698,786,894,990,1104,1218,1360,1494,1658,1822,2006,2174,2366,2558,2786,2996,3230,3464", "code": " \nfrom itertools import product\ndef is_strm(w): \n    for l in range(2, len(w)):\n        facts = set(w[j:j+l] for j in range(len(w)-l+1))\n        counts = set(f.count('0') for f in facts)\n        if max(counts) - min(counts) > 1:\n            return False\n    return True\ndef is_clsd(w): \n    if len(set(w)) <= 1: return True\n    for l in range(1, len(w)):\n        if w[:l] == w[-l:] and w[:l] not in w[1:-1]:\n            return True\n    return False\ndef is_cs(w):   \n    return is_clsd(w) and is_strm(w)\ndef a(n):\n    return 2*sum(is_cs(\"0\"+\"\".join(b)) for b in product(\"01\", repeat=n-1))\nprint([a(n) for n in range(1, 17)]) \n"}
{"sequence_id": "A291460", "text": "Even numbers n such that the decimal expansion of n contains the decimal expansion of the greatest odd divisor of n as a substring.", "sequence": "16,128,384,512,1024,1536,1792,2176,2560,2912,3072,5120,7168,8192,9216,11264,13312,15360,15616,16384,17408,19456,21504,23552,25600,27648,28672,29696,31744,33792,35840,37376,37888,39936,41984,43392,57344,66560,90112,98304", "code": "\nA291460_list = [2*x for x in range(1,10**6) if str(int(bin(x).rstrip('0'),2)) in str(2*x)] \n"}
{"sequence_id": "A291481", "text": "Number of terms of A293630 at stage n.", "sequence": "2,4,7,13,37,73,145,289,865,1729,3457,10369,20737,41473,82945,248833,497665,995329,1990657,3981313,11943937,23887873,47775745,143327233,286654465,573308929,1146617857,3439853569,6879707137,20639121409,41278242817,82556485633", "code": "\na, z = [1, 2], [2]\nwhile z[-1]<1000:\n    a += a[:-1]*a[-1]\n    z.append(len(a))\nfor i in range(100):\n    z.append((z[-1]-1)*(a.pop()+1)+1)\nprint(z)\n\n"}
{"sequence_id": "A291592", "text": "Number of bases for which 2^n-1 is a repdigit with at least 3 digits.", "sequence": "0,0,1,1,2,2,1,2,2,2,1,4,2,2,3,3,1,4,1,4,3,2,1,6,2,2,3,4,1,6,1,4,3,2,3,7,1,2,3,6,1,6,1,4,5,2,1,8,2,4,3,4,1,6,3,6,3,2,1,10,1,2,5,5,3,6,1,4,3,6,1,10", "code": "\nfrom sympy.ntheory import count_digits\ndef ok(n, b): return False if n <= b**2 else len(count_digits(n, b)) == 1\ndef a(n): return sum(ok(2**n-1, b) for b in range(2, 2**n))\nprint([a(n) for n in range(1, 21)]) \n"}
{"sequence_id": "A291592", "text": "Number of bases for which 2^n-1 is a repdigit with at least 3 digits.", "sequence": "0,0,1,1,2,2,1,2,2,2,1,4,2,2,3,3,1,4,1,4,3,2,1,6,2,2,3,4,1,6,1,4,3,2,3,7,1,2,3,6,1,6,1,4,5,2,1,8,2,4,3,4,1,6,3,6,3,2,1,10,1,2,5,5,3,6,1,4,3,6,1,10", "code": " \ndef is_repdigit(n, b):\n  if n < b: return True\n  n, r = divmod(n, b)\n  onlyd = r\n  while n > b:\n    n, r = divmod(n, b)\n    if r != onlyd: return False\n  return n == onlyd\ndef a(n):\n  c, target = 0, 2**n - 1\n  for b in range(2, 2**n):\n    if target < b**2: break \n    c += is_repdigit(target, b)\n  return c\nprint([a(n) for n in range(1, 41)]) \n"}
{"sequence_id": "A291625", "text": "Numbers k such that 0 is the smallest decimal digit of k^2.", "sequence": "10,20,30,32,33,40,45,47,48,49,50,51,52,53,55,60,64,70,71,78,80,84,90,95,97,98,99,100,101,102,103,104,105,110,120,130,138,140,142,143,144,145,147,148,149,150,151,152,153,155,160,170,174,175,176,179,180", "code": "\nA291625_list = [k for k in range(1,10**6) if '0' in str(k**2)] \n"}
{"sequence_id": "A291626", "text": "Numbers k such that 1 is the smallest decimal digit of k^2.", "sequence": "1,4,9,11,12,13,14,19,21,29,31,34,35,36,37,38,39,41,42,43,44,46,54,56,59,61,69,72,79,81,89,91,96,106,107,108,109,111,112,113,114,115,116,117,118,119,121,122,123,124,125,126,127,128,129,131,132,133,134", "code": "\nA291626_list = [k for k in range(1,10**6) if min(str(k**2)) == '1'] \n"}
{"sequence_id": "A291630", "text": "Numbers k such that 5 is the smallest decimal digit of k^2.", "sequence": "24,76,87,236,314,316,766,816,834,2366,2383,2387,2424,2563,2626,2976,7613,7666,8117,8184,8234,8286,8366,8716,8814,9266,9316,9363,9474,9786,9837,23634,23784,23866,23874,24474,25663,25684,26076,26187,26374,26417,27687", "code": "\nA291630_list = [k for k in range(1,10**6) if min(str(k**2)) == '5'] \n"}
{"sequence_id": "A291644", "text": "Numbers k such that 5 is the smallest decimal digit of k^3.", "sequence": "19,423,1786,1966,4053,4235,40326,45882,198823,204782,442693,2131842,3911966,4061115,4081435,4603475,8789299,18027632,40987223,42647176,44100092,46097753,88776682,96439993,96540315,98954326,190349299,197967719,423185632,428896755,463968436", "code": "\nA291644_list = [k for k in range(1,10**6) if min(str(k**3)) == '5'] \n"}
{"sequence_id": "A291662", "text": "Number of ordered rooted trees with 2n non-root nodes such that the maximal outdegree equals n.", "sequence": "1,1,8,53,326,1997,12370,77513,490306,3124541,20030000,129024469,834451788,5414950283,35240152706,229911617041,1503232609082,9847379391133,64617565719052,424655979547781,2794563003870310,18412956934908669,121455445321173578", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(u, o, k): return 1 if u + o==0 else sum([b(u - j, o + j - 1, k) for j in range(1, min(1, u) + 1)]) + sum([b(u + j - 1, o - j, k) for j in range(1, min(k, o) + 1)])\ndef a(n): return b(0, 2*n, n) - (0 if n==0 else b(0, 2*n, n - 1))\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A291672", "text": "Numbers k such that 4 is the smallest decimal digit of k^4.", "sequence": "26,46,822,1594,9296,29426,46278,161954,289146,835718,958646,2743904,2764968,5446346,8175708,15381676,30590282,52240108,149140628,260414482,284539894,299068782,471886024,490673642,508339942,827983028,863811282,868389594,911303358,1486895644", "code": "\nA291672_list = [k for k in range(1,10**6) if min(str(k**4)) == '4'] \n"}
{"sequence_id": "A291677", "text": "Number of permutations p of [2n] such that 0p has exactly n alternating runs.", "sequence": "1,1,7,148,6171,425976,43979902,6346283560,1219725741715,301190499710320,92921064554444490,35025128774218944648,15838288022236083603486,8462453158197423495502224,5274234568391796228927038748,3792391176672742840187796835728", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n, k): return (1 if n==0 else 0) if k==0 else 0 if k<0 or k>n else k*b(n - 1, k) + b(n - 1, k - 1) + (n - k + 1)*b(n - 1, k - 2)\ndef a(n): return b(2*n, n)\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A291680", "text": "Number T(n,k) of permutations p of [n] such that in 0p the largest up-jump equals k and no down-jump is larger than 2; triangle T(n,k), n>=0, 0<=k<=n, read by rows.", "sequence": "1,0,1,0,1,1,0,1,3,2,0,1,9,8,4,0,1,25,36,20,10,0,1,71,156,108,58,26,0,1,205,666,586,340,170,74,0,1,607,2860,3098,2014,1078,528,218,0,1,1833,12336,16230,11888,6772,3550,1672,672,0,1,5635,53518,85150,69274,42366,23284,11840,5454,2126", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(u, o, k): return 1 if u + o==0 else sum([b(u - j, o + j - 1, k) for j in range(1, min(2, u) + 1)]) + sum([b(u + j - 1, o - j, k) for j in range(1, min(k, o) + 1)])\ndef T(n, k): return b(0, n, k) - (0 if k==0 else b(0, n, k - 1))\nfor n in range(13): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A291683", "text": "Number of permutations p of [n] such that in 0p the largest up-jump equals 2 and no down-jump is larger than 2.", "sequence": "0,0,1,3,9,25,71,205,607,1833,5635,17577,55515,177191,570699,1852571,6055079,19910729,65823751,218654099,729459551,2443051213,8210993363,27685671843,93625082139,317470233149,1079183930827,3676951654519,12554734605495,42952566314235", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(u, o, k): return 1 if u + o==0 else sum([b(u - j, o + j - 1, k) for j in range(1, min(2, u) + 1)]) + sum([b(u + j - 1, o - j, k) for j in range(1, min(k, o) + 1)])\ndef a(n): return b(0, n, 2) - b(0, n, 1)\nfor n in range(31): print (a(n)) \n"}
{"sequence_id": "A291770", "text": "A binary encoding of the zeros in ternary representation of n.", "sequence": "0,0,1,0,0,1,0,0,3,2,2,1,0,0,1,0,0,3,2,2,1,0,0,1,0,0,7,6,6,5,4,4,5,4,4,3,2,2,1,0,0,1,0,0,3,2,2,1,0,0,1,0,0,7,6,6,5,4,4,5,4,4,3,2,2,1,0,0,1,0,0,3,2,2,1,0,0,1,0,0,15,14,14,13,12,12,13,12,12,11,10,10,9,8,8,9,8,8,11,10,10,9,8,8,9,8,8,7,6,6", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a(n):\n    k=digits(n, 3)[1:]\n    return int(\"\".join('1' if i==0 else '0' for i in k), 2)\nprint([a(n) for n in range(1, 111)]) \n"}
{"sequence_id": "A291793", "text": "Period of orbit of Post's tag system applied to the word (100)^n (version 2), or -1 if the orbit increases without limit.", "sequence": "2,6,6,6,0,10,28,6,10,6,6,6,0,0,6,28,10,6,10,6,6,0,6,6,0,6,6,6,6,6,6,52,6,6,6,6,6,6,6,6,6,6,6,28,6,0,0,28,6,6,6,6,6,0,6,6,6,10,6,6,6,6,0,6,0,6,6,6,6,0,6,6,6,0,6,6,6,0,10,0,10,6,6", "code": "\ndef step(w):\n    i = 0\n    while w[0] != alfabet[i]:\n        i = i+1\n    w = w+suffix[i]\n    return w[n:len(w)]\nalfabet, suffix, n, ws, w0, m = \"01\", [\"00\",\"1101\"], 3, \"100\", \"\", 0\nwhile m < 83:\n    w0, m = w0+ws, m+1\n    w, ww, i, a = w0, w0, 0, 0\n    while w != \"\" and a == 0:\n        w, i = step(w), i+1\n        if i%1000 == 0:\n            ww = w\n        else:\n            if w == ww or w == \"\":\n                if w != \"\":\n                    a = i%1000\n                print(m,a) \n"}
{"sequence_id": "A291878", "text": "Triangle read by rows: T(n,k) = number of fountains of n coins and height k.", "sequence": "1,0,1,0,1,0,1,1,0,1,2,0,1,4,0,1,7,1,0,1,12,2,0,1,20,5,0,1,33,11,0,1,54,22,1,0,1,88,44,2,0,1,143,85,5,0,1,232,161,12,0,1,376,302,25,0,1,609,559,52,1,0,1,986,1026,105,2,0,1,1596,1870,207,5,0,1", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import Symbol, Poly, flatten\nx=Symbol('x')\n@cacheit\ndef b(n, i, h): return x**h if n==0 else sum([b(n - j, j, max(h, j)) for j in range(1, min(i + 1, n) + 1)])\ndef T(n): return 1 if n==0 else Poly(b(n, 0, 0)).all_coeffs()[::-1]\nprint(flatten(map(T, range(31)))) \n"}
{"sequence_id": "A291883", "text": "Number T(n,k) of symmetrically unique Dyck paths of semilength n and height k; triangle T(n,k), n>=0, 0<=k<=n, read by rows.", "sequence": "1,0,1,0,1,1,0,1,2,1,0,1,5,3,1,0,1,9,11,4,1,0,1,19,31,19,5,1,0,1,35,91,69,29,6,1,0,1,71,250,252,127,41,7,1,0,1,135,690,855,540,209,55,8,1,0,1,271,1863,2867,2117,1005,319,71,9,1,0,1,527,5017,9339,8063,4411,1705,461,89,10,1", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import Poly, Symbol, flatten\nz=Symbol('z')\n@cacheit\ndef b(x, y, k): return z**k if x==0 else (b(x - 1, y + 1, max(y + 1, k)) if y<x - 1 else 0) + (b(x - 1, y - 1, k) if y>0 else 0)\n@cacheit\ndef g(x, y, k): return z**k if x==0 else (g(x - 2, y - 1, k) if y>0 else 0) + g(x - 2, y + 1, max(y + 1, k))\ndef T(n): return 1 if n==0 else [i//2 for i in Poly(b(2*n, 0, 0) + g(2*n, 0, 0)).all_coeffs()[::-1]]\nprint(flatten(map(T, range(15)))) \n"}
{"sequence_id": "A291885", "text": "Number of symmetrically unique Dyck paths of semilength 2n and height n.", "sequence": "1,1,5,31,252,2117,18546,164229,1469596,13229876,119712521,1087573357,9914033252,90633332870,830621140260,7628813061585,70200092854044,647070588612140,5973385906039684,55217660246861884,511054426374819184,4735208302827742549", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(x, y, k): return 1 if x==0 else (b(x - 1, y + 1, k) if y + 1<=min(k, x - 1) else 0) + (b(x - 1, y - 1, k) if y>0 else 0)\n@cacheit\ndef g(x, y, k): return 1 if x==0 else (g(x - 2, y - 1, k) if y>0 else 0) + (g(x - 2, y + 1, k) if y + 1<=k else 0)\ndef a(n): return 1 if n==0 else (b(4*n, 0, n) + g(4*n, 0, n) - b(4*n, 0, n - 1) - g(4*n, 0, n - 1))//2\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A291896", "text": "Number of 1-dimensional sand piles with n grains piling up against the wall.", "sequence": "1,1,1,2,3,5,9,14,24,40,67,112,186,312,520,868,1449,2417,4034,6730,11229,18735,31254,52143,86989,145119,242096,403871,673751,1123964,1875014,3127926,5218034,8704769,14521354,24224601,40411595,67414781,112461579,187608762", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n, i): return 1 if n==0 else sum(b(n - j, j) for j in range(max(1, i - 1), min(i + 1, n) + 1))\ndef a(n): return b(n, 0)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A291905", "text": "Row sums of A291904.", "sequence": "1,1,0,1,1,0,2,1,1,3,2,3,4,4,6,8,8,11,14,16,21,26,32,39,49,60,75,93,114,142,176,217,268,334,411,510,632,779,967,1196,1477,1832,2266,2801,3470,4291,5310,6572,8129,10061,12449,15401,19058,23581,29178,36102,44668", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n, i): return 1 if n==0 else sum(b(n - j, j) for j in range(max(1, i - 1), min(i + 1, n) + 1) if j != i)\ndef a(n): return b(n, 0)\nprint([a(n) for n in range(61)]) \n"}
{"sequence_id": "A291926", "text": "a(n) is the smallest integer k>=0 such that 2^k contains every digit in base n, or 0 if no such integer exists.", "sequence": "1,5,0,18,25,20,0,61,68,64,72,103,110,134,0,138,141,140,141,172,191,228,225,244,306,281,272,339,384,412,0,390,421,372,472,395,441,486,495,473,566,576,629,735,626,661,706,707,741,825,782,751,811,924,930,908,927,975,1049,934,1018,1070,0", "code": "\ndef floorLog(b,n):\n    x=-1\n    while(n>0):\n        x+=1\n        n//=b\n    return x\ndef distinctDigits(n,b):\n    li=[]\n    while(n>0):\n        li.append(n%b)\n        n//=b\n    li=list(set(li))\n    li.sort()\n    return li\ndef iroot(k,n):\n    u, s = n, n+1\n    while u < s:\n        s = u\n        t = (k-1) * s + n // (s**(k-1))\n        u = t // k\n    return s\ndef perfectPower(n):\n    if(n==1): return 0\n    x=1\n    for i in range(2,floorLog(2,n)+1):\n        if(iroot(i,n)**i==n): x=i\n    return x\ndef leastPandigital(b,n):\n    if(n<=1 or b<=1): return 0\n    if(n==2): return 2 if (b==(1<<b.bit_length())-1) else 1\n    if(iroot(perfectPower(n),n)==iroot(perfectPower(b),b)): return 0\n    a=(floorLog(b,n)*(n-1))\n    while(distinctDigits(b**a,n)!=list(range(n))): a+=1\n    return a\nfor i in range(2,257):\n    print(str(i)+\" \"+str(leastPandigital(2,i)))\n"}
{"sequence_id": "A291926", "text": "a(n) is the smallest integer k>=0 such that 2^k contains every digit in base n, or 0 if no such integer exists.", "sequence": "1,5,0,18,25,20,0,61,68,64,72,103,110,134,0,138,141,140,141,172,191,228,225,244,306,281,272,339,384,412,0,390,421,372,472,395,441,486,495,473,566,576,629,735,626,661,706,707,741,825,782,751,811,924,930,908,927,975,1049,934,1018,1070,0", "code": "\nfrom sympy.ntheory.digits import digits\ndef a(n):\n    b = bin(n)[2:]\n    if b.strip('0') == '1': return int(n == 2)\n    k = (len(b)-1)*(n-1)\n    while len(set(digits(2**k, n)[1:])) != n: k += 1\n    return k\nprint([a(n) for n in range(2, 65)]) \n"}
{"sequence_id": "A291977", "text": "Triangle read by rows, T(n, k) = Sum_{j=0..n} (-1)^(k-j)*Eulerian1(n, j)* binomial(n-j, n-k) for 0 <= k <= n.", "sequence": "1,1,-1,1,-1,0,1,1,-4,2,1,7,-16,8,0,1,21,-28,-26,48,-16,1,51,32,-356,408,-136,0,1,113,492,-1774,1072,912,-1088,272,1,239,2592,-5008,-6656,20736,-15872,3968,0,1,493,10628,-50,-94432,154528,-57856,-45056,39680,-7936", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef eulerian1(n, k): return 1 if k==0 else 0 if k==n else eulerian1(n - 1, k)*(k + 1) + eulerian1(n - 1, k - 1)*(n - k)\ndef T(n, k): return sum([(-1)**(k - j)*eulerian1(n, j)*binomial(n - j, n - k) for j in range(n + 1)])\nfor n in range(10): print([T(n, k) for k in range(n + 1)]) \n"}
{"sequence_id": "A292030", "text": "Table read by ascending antidiagonals: T(n,k) = A000045(k+1)*n + A000045(k).", "sequence": "0,1,1,2,2,1,3,3,3,2,4,4,5,5,3,5,5,7,8,8,5,6,6,9,11,13,13,8,7,7,11,14,18,21,21,13,8,8,13,17,23,29,34,34,21,9,9,15,20,28,37,47,55,55,34,10,10,17,23,33,45,60,76,89,89,55,11,11,19,26,38,53,73,97,123,144,144", "code": "\ndef nextAntidiagonal(d):\n  if(d[0]==0): return [d[1]+1,0]\n  return [d[0]-1,d[1]+1]\ndef fibonacciM(m,n):\n  f0,f1=0,1\n  if(n<0):\n    for _ in range(-n): f1,f0=f0,f1-f0\n  else:\n    for _ in range(n): f0,f1=f1,f0+f1\n  return f1*m+f0\nd=[0,0]\nfor i in range(10001):\n  print(str(i)+\" \"+str(fibonacciM(d[0],d[1])))\n  d=nextAntidiagonal(d)\n"}
{"sequence_id": "A292031", "text": "a(n) is the smallest value m such that n appears in row m of A292030.", "sequence": "0,0,0,0,3,0,5,3,0,4,9,3,11,0,4,7,15,5,3,9,6,0,21,4,23,12,8,13,5,3,29,15,10,6,0,11,35,4,7,19,39,13,41,8,14,5,45,3,9,24,16,25,51,6,53,0,18,28,11,19,4,7,20,12,63,21,65,33,13,8,69,23,71,5,24,37,3,9,15,39,26", "code": "\ndef smallestSeq(n):\n  if(n<0): return []\n  if(n==0): return [0,0]\n  j,r0,r1=0,0,1\n  while(r1<=n): r0,r1=r1,r0+r1 ; j+=1\n  while(r1>1):\n    if(n%r1==r0): return [n//r1,j]\n    r1,r0=r0,r1-r0\n    j-=1\n  return [n-1, j]\nfor i in range(10001):\n  print(str(i)+\" \"+str(smallestSeq(i)[0]))\n"}
{"sequence_id": "A292032", "text": "a(n) is the value k such that A292030(A292031(n), k) = n.", "sequence": "0,2,3,4,1,5,1,2,6,2,1,3,1,7,3,2,1,3,4,2,3,8,1,4,1,2,3,2,4,5,1,2,3,4,9,3,1,5,4,2,1,3,1,4,3,5,1,6,4,2,3,2,1,5,1,10,3,2,4,3,6,5,3,4,1,3,1,2,4,5,1,3,1,6,3,2,7,5,4,2,3,2,1,4,1,5,6,2,4,11", "code": "\ndef smallestSeq(n):\n  if(n<0): return []\n  if(n==0): return [0,0]\n  j,r0,r1=0,0,1\n  while(r1<=n): r0,r1=r1,r0+r1 ; j+=1\n  while(r1>1):\n    if(n%r1==r0): return [n//r1,j]\n    r1,r0=r0,r1-r0\n    j-=1\n  return [n-1, j]\nfor i in range(10001):\n  print(str(i)+\" \"+str(smallestSeq(i)[1]))\n"}
{"sequence_id": "A292046", "text": "The list of distinct values of A072464.", "sequence": "1,3,6,7,11,12,13,14,16,17,18,19,20,21,22,23,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,78,79", "code": "\nfrom math import log\na = [1]\nfor i in range(1, 66): a.append(i+a[int(log(i, 2))]+1)\nprint(a)\n\n"}
{"sequence_id": "A292068", "text": "Square array A(n,k), n>=0, k>=0, read by antidiagonals, where column k is the expansion of Product_{j>=1} 1/(1 + j^k*x^j).", "sequence": "1,1,-1,1,-1,0,1,-1,-1,-1,1,-1,-3,-2,1,1,-1,-7,-6,2,-1,1,-1,-15,-20,6,-1,1,1,-1,-31,-66,20,5,4,-1,1,-1,-63,-212,66,71,40,-1,2,1,-1,-127,-666,212,605,442,11,18,-2,1,-1,-255,-2060,666,4439,4660,215,226,-22,2", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import factorial as f\n@cacheit\ndef b(n, i, k):\n    m=i*(i + 1)/2\n    return 0 if m<n else f(i)**k if n==m else b(n, i - 1, k) + (0 if i>n else i**k*b(n - i, i - 1, k))\n@cacheit\ndef A(n, k): return 1 if n==0 else -sum([b(n - i, n - i, k)*A(i, k) for i in range(n)])\nfor d in range(13): print([A(n, d - n) for n in range(d + 1)]) \n"}
{"sequence_id": "A292072", "text": "Main diagonal of A292068.", "sequence": "1,-1,-3,-20,66,4439,454420,4873175,-3803048954,-7320203267692,-1403057989033446,6669491545211096686,78492109668913945526447,69591502229308312804788424,-6243846072108996200105800383026,-604234376454072219680822138902122079", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import factorial as f\n@cacheit\ndef b(n, i, k):\n    m=i*(i + 1)/2\n    return 0 if m<n else f(i)**k if n==m else b(n, i - 1, k) + (0 if i>n else i**k*b(n - i, i - 1, k))\n@cacheit\ndef g(n, k): return 1 if n==0 else -sum([b(n - i, n - i, k)*g(i, k) for i in range(n)])\ndef a(n): return g(n, n)\nprint([a(n) for n in range(16)]) \n"}
{"sequence_id": "A292186", "text": "Number of rooted unlabeled connected four-regular maps on a compact closed oriented surface with n vertices (and thus 2*n edges).", "sequence": "1,3,24,297,4896,100278,2450304,69533397,2247492096,81528066378,3280382613504,145009234904922,6986546222800896,364418301804218028,20459842995693256704,1230262900677124568397,78884016707711348637696,5372823210133041283250178,387394283866652086938107904", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n): return n*2 + 1 if n < 2 else 4*n*a(n - 1) + sum([a(k)*a(n - k - 1) for k in range(1, n - 1)])\n[a(n) for n in range(21)]\n"}
{"sequence_id": "A292187", "text": "Number of rooted unlabelled bipartite cubic maps on a compact closed oriented surface with 2*n vertices (and thus 3*n edges).", "sequence": "1,2,12,112,1392,21472,394752,8421632,204525312,5572091392,168331164672,5585571889152,201973854584832,7905697598963712,333049899230625792,15025907115679875072,722841343143300759552,36935846945562562527232,1997902532753538016346112,114050521905958855289864192,6852141240070150728132329472", "code": "\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n): return n + 1 if n < 2 else 3*n*a(n - 1) + sum([a(k)*a(n - k - 1) for k in range(1, n - 1)])\n[a(n) for n in range(21)]\n"}
{"sequence_id": "A292348", "text": "\"Pri-most\" numbers: the majority of bits in the binary representation of these numbers satisfy the following: complementing this bit produces a prime number.", "sequence": "6,7,15,19,21,23,27,43,45,63,71,75,77,81,99,101,105,111,135,147,159,165,175,183,189,195,225,231,235,237,243,255,261,273,285,309,315,335,345,357,363,375,381,423,435,483,495,507,553,555,573,585,645,663,669,675", "code": "\nfrom sympy import isprime\nfor i in range(1000):\n  delta = 0  \n  bit = 1\n  while  bit <= i:\n    if isprime(i^bit): delta += 1\n    else:              delta -= 1\n    bit*=2\n  if delta > 0:  print(str(i), end=',')\n"}
{"sequence_id": "A292349", "text": "Pri-most primes: primes p such that the majority of bits in the binary representation of p satisfy the following: complementing this bit produces a prime number.", "sequence": "7,19,23,43,71,101", "code": "\nfrom sympy import isprime, primerange\nfor i in primerange(1, 1000):\n  delta = 0\n  bit = 1\n  while  bit <= i:\n    if isprime(i^bit): delta += 1\n    else:              delta -= 1\n    bit*=2\n  if delta > 0:  print(str(i), end=',')\n"}
{"sequence_id": "A292370", "text": "A binary encoding of the zeros in base-4 representation of n.", "sequence": "0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,3,2,2,2,1,0,0,0,1,0,0,0,1,0,0,0,3,2,2,2,1,0,0,0,1,0,0,0,1,0,0,0,3,2,2,2,1,0,0,0,1,0,0,0,1,0,0,0,7,6,6,6,5,4,4,4,5,4,4,4,5,4,4,4,3,2,2,2,1,0,0,0,1,0,0,0,1,0,0,0,3,2,2,2,1,0,0,0,1,0,0,0,1,0,0,0,3,2,2,2,1,0,0,0,1", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a(n):\n    k=digits(n, 4)[1:]\n    return 0 if n==0 else int(\"\".join('1' if i==0 else '0' for i in k), 2)\nprint([a(n) for n in range(111)]) \n"}
{"sequence_id": "A292371", "text": "A binary encoding of 1-digits in the base-4 representation of n.", "sequence": "0,1,0,0,2,3,2,2,0,1,0,0,0,1,0,0,4,5,4,4,6,7,6,6,4,5,4,4,4,5,4,4,0,1,0,0,2,3,2,2,0,1,0,0,0,1,0,0,0,1,0,0,2,3,2,2,0,1,0,0,0,1,0,0,8,9,8,8,10,11,10,10,8,9,8,8,8,9,8,8,12,13,12,12,14,15,14,14,12,13,12,12,12,13,12,12,8,9,8,8,10,11,10,10,8,9,8,8,8,9,8,8,8", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a(n):\n    k=digits(n, 4)[1:]\n    return 0 if n==0 else int(\"\".join('1' if i==1 else '0' for i in k), 2)\nprint([a(n) for n in range(116)]) \n"}
{"sequence_id": "A292372", "text": "A binary encoding of 2-digits in base-4 representation of n.", "sequence": "0,0,1,0,0,0,1,0,2,2,3,2,0,0,1,0,0,0,1,0,0,0,1,0,2,2,3,2,0,0,1,0,4,4,5,4,4,4,5,4,6,6,7,6,4,4,5,4,0,0,1,0,0,0,1,0,2,2,3,2,0,0,1,0,0,0,1,0,0,0,1,0,2,2,3,2,0,0,1,0,0,0,1,0,0,0,1,0,2,2,3,2,0,0,1,0,4,4,5,4,4,4,5,4,6,6,7,6,4,4,5,4,0,0,1,0,0,0,1,0,2", "code": "\nfrom sympy.ntheory.factor_ import digits\ndef a(n):\n    k=digits(n, 4)[1:]\n    return 0 if n==0 else int(\"\".join('1' if i==2 else '0' for i in k), 2)\nprint([a(n) for n in range(121)]) \n"}
{"sequence_id": "A292380", "text": "Base-2 expansion of a(n) encodes the steps where multiples of 4 are encountered when map x -> A252463(x) is iterated down to 1, starting from x=n.", "sequence": "0,0,0,1,0,0,0,3,2,0,0,1,0,0,0,7,0,4,0,1,0,0,0,3,4,0,6,1,0,0,0,15,0,0,0,9,0,0,0,3,0,0,0,1,2,0,0,7,8,8,0,1,0,12,0,3,0,0,0,1,0,0,2,31,0,0,0,1,0,0,0,19,0,0,8,1,0,0,0,7,14,0,0,1,0,0,0,3,0,4,0,1,0,0,0,15,0,16,2,17,0,0,0,3,0", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy.ntheory.factor_ import digits\nfrom sympy import factorint, prevprime\nfrom operator import mul\nfrom functools import reduce\ndef a292370(n):\n    k=digits(n, 4)[1:]\n    return 0 if n==0 else int(\"\".join(['1' if i==0 else '0' for i in k]), 2)\ndef a064989(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==2 else prevprime(i)**f[i] for i in f])\ndef a252463(n): return 1 if n==1 else n//2 if n%2==0 else a064989(n)\n@cacheit\ndef a292384(n): return 1 if n==1 else 4*a292384(a252463(n)) + n%4\ndef a(n): return a292370(a292384(n))\nprint([a(n) for n in range(1, 111)]) \n"}
{"sequence_id": "A292381", "text": "Base-2 expansion of a(n) encodes the steps where numbers of the form 4k+1 are encountered when map x -> A252463(x) is iterated down to 1, starting from x=n.", "sequence": "1,2,4,4,9,8,18,8,9,18,36,16,73,36,16,16,147,18,294,36,37,72,588,32,19,146,16,72,1177,32,2354,32,73,294,32,36,4709,588,144,72,9419,74,18838,144,33,1176,37676,64,39,38,292,292,75353,32,74,144,589,2354,150706,64,301413,4708,72,64,147,146,602826,588,1177,64,1205652,72,2411305,9418,36,1176", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy.ntheory.factor_ import digits\nfrom sympy import factorint, prevprime\nfrom operator import mul\nfrom functools import reduce\ndef a292371(n):\n    k=digits(n, 4)[1:]\n    return 0 if n==0 else int(\"\".join(['1' if i==1 else '0' for i in k]), 2)\ndef a064989(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==2 else prevprime(i)**f[i] for i in f])\ndef a252463(n): return 1 if n==1 else n//2 if n%2==0 else a064989(n)\n@cacheit\ndef a292384(n): return 1 if n==1 else 4*a292384(a252463(n)) + n%4\ndef a(n): return a292371(a292384(n))\nprint([a(n) for n in range(1, 111)]) \n"}
{"sequence_id": "A292382", "text": "Base-2 expansion of a(n) encodes the steps where numbers of the form 4k+2 are encountered when map x -> A252463(x) is iterated down to 1, starting from x=n.", "sequence": "0,1,2,2,4,5,8,4,4,9,16,10,32,17,10,8,64,9,128,18,18,33,256,20,8,65,8,34,512,21,1024,16,34,129,20,18,2048,257,66,36,4096,37,8192,66,20,513,16384,40,16,17,130,130,32768,17,36,68,258,1025,65536,42,131072,2049,36,32,68,69,262144,258,514,41,524288,36,1048576,4097,18,514,40", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy.ntheory.factor_ import digits\nfrom sympy import factorint, prevprime\nfrom operator import mul\nfrom functools import reduce\ndef a292372(n):\n    k=digits(n, 4)[1:]\n    return 0 if n==0 else int(\"\".join(['1' if i==2 else '0' for i in k]), 2)\ndef a064989(n):\n    f=factorint(n)\n    return 1 if n==1 else reduce(mul, [1 if i==2 else prevprime(i)**f[i] for i in f])\ndef a252463(n): return 1 if n==1 else n//2 if n%2==0 else a064989(n)\n@cacheit\ndef a292384(n): return 1 if n==1 else 4*a292384(a252463(n)) + n%4\ndef a(n): return a292372(a292384(n))\nprint([a(n) for n in range(1, 111)]) \n"}
{"sequence_id": "A292384", "text": "a(1) = 1; for n > 1, a(n) = 4*a(A252463(n)) + (n mod 4).", "sequence": "1,6,27,24,109,110,439,96,97,438,1759,440,7037,1758,443,384,28149,390,112599,1752,1753,7038,450399,1760,389,28150,387,7032,1801597,1774,7206391,1536,7033,112598,1775,1560,28825565,450398,28155,7008,115302261,7014,461209047,28152,1761,1801598,1844836191,7040,1557,1558,112603,112600", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import factorint, prevprime, prod\ndef a064989(n):\n    f = factorint(n)\n    return 1 if n == 1 else prod(prevprime(i)**f[i] for i in f if i != 2)\ndef a252463(n): return 1 if n==1 else n//2 if n%2==0 else a064989(n)\n@cacheit\ndef a(n): return 1 if n==1 else 4*a(a252463(n)) + n%4\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A292452", "text": "Numbers where 2 outnumbers any other digit.", "sequence": "2,22,122,202,212,220,221,222,223,224,225,226,227,228,229,232,242,252,262,272,282,292,322,422,522,622,722,822,922,1022,1202,1220,1222,1223,1224,1225,1226,1227,1228,1229,1232,1242,1252,1262,1272,1282,1292,1322,1422", "code": "\ndef ok(n):\n  s=str(n); return s.count('2') > max([0]+[s.count(d) for d in s if d!='2'])\nprint([m for m in range(1500) if ok(m)]) \n"}
{"sequence_id": "A292728", "text": "a(n) is the number of terminal states that can be achieved via the following algorithm: start with n piles each containing one stone; stones can be transferred between piles only when the piles start with the same number of stones.", "sequence": "1,1,1,2,2,2,4,6,6,7,11,11,17,18,23,32,37,39,53,58,70,83,103,112,139,158,184,214,255,279,339,390,435,503,578,647,759,854,963,1099,1259,1395,1609,1804,2015,2292,2589,2870,3259,3638,4058,4568,5119,5663,6364,7090,7862,8793,9791,10795", "code": "\ndef A292728(n):\n....s_todo, s_done = set([(1,)*n]), set()\n....count=0\n....while len(s_todo) > 0:\n........s_new = set()\n........for s in s_todo:\n............last = -1 ; idx = 0 ; final = True\n............while (idx+1) < len(s):\n................h = s[idx]\n................if h!=last and s[idx+1]==h:\n....................final = False\n....................for q in range(1,h+1):\n........................lst = list(s[:idx]) + list(s[idx+2:])\n........................lst += [2*h] if h==q else [ h-q, h+q]\n........................t = tuple(sorted(lst))\n........................if (not t in s_todo and\n............................not t in s_new and\n............................not t in s_done):\n............................s_new.add(t)\n................last = s[idx] ; idx += 1\n............if final: count += 1\n........s_done.update(s_todo) ; s_todo = s_new\n....return count\n\n"}
{"sequence_id": "A292729", "text": "a(n) is the maximum number of steps that can occur during the following procedure: start with n piles each containing one stone; any number of stones can be transferred between piles of equal size.", "sequence": "0,1,1,3,4,4,8,10,11,12,16,20,22,24,27,31,35,38,43,45,47,52,57,62,67,71,74,79,83,90,95,101,106,111,114,118,126,132,138,146,152,156,161,167,172,180,189,194,204,208,216,221,228,234,242,249,258,264,274,282", "code": "\ndef A292729(n):\n....s_in = set([(1,)*n])\n....count=-1\n....while len(s_in) > 0:\n........s_out = set()\n........for s in s_in:\n............last = -1 ; idx = 0\n............while (idx+1) < len(s):\n................h = s[idx]\n................if h!=last and s[idx+1]==h:\n....................for q in range(1,h+1):\n........................lst = list(s[:idx]) + list(s[idx+2:])\n........................lst += [2*h] if h==q else [ h-q, h+q]\n........................t = tuple(sorted(lst))\n........................if not t in s_out:\n............................s_out.add(t)\n................last = s[idx] ; idx += 1\n........count += 1\n........s_in = s_out\n....return count\n\n"}
{"sequence_id": "A292732", "text": "Numbers in which 2 outnumbers all other digits together.", "sequence": "2,22,122,202,212,220,221,222,223,224,225,226,227,228,229,232,242,252,262,272,282,292,322,422,522,622,722,822,922,1222,2022,2122,2202,2212,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2232,2242,2252,2262,2272,2282,2292,2322,2422,2522,2622,2722,2822,2922", "code": "\ndef ok(n):\n  s=str(n); return s.count('2') > sum([0]+[s.count(d) for d in s if d!='2'])\nprint([m for m in range(2923) if ok(m)]) \n"}
{"sequence_id": "A292865", "text": "Determinants of the symmetric matrices whose entries on and below the main diagonal correspond to those of Pascal's triangle.", "sequence": "1,0,-1,8,-71,656,-4816,1920,168784,43920880,-3315147449,209095006856,-19095123359744,1814464114046976,320005209305667584,-253215321875947192320,-3298397219599339984896,24417272707694829159671808,265094852554176756050442657024,-931723550682987095264656018072440", "code": "\nfrom sympy import *\ndef m(N):\n    return Matrix([\n        ([binomial(i, n) for n in range(i+1)] +[0] * (N-i))\n        for i in range(N+1)\n    ])\ndef matrix(N):\n    return m(N) + m(N).transpose() - eye(N+1)\n[ matrix(i).det() for i in range(20)]\n\n"}
{"sequence_id": "A292918", "text": "Let A_n be a square n X n matrix with entries A_n(i,j)=1 if i+j is prime, and A_n(i,j)=0 otherwise. Then a(n) counts the 1's in A_n.", "sequence": "1,3,5,9,11,15,19,23,29,37,43,51,57,63,71,81,89,97,105,113,123,135,145,157,169,181,195,209,221,235,249,263,277,293,309,327,345,363,381,401,419,439,457,475,495,515,533,551,571,591,613,637,659,683,709,735", "code": "\nfrom sympy import primepi\nfrom sympy.core.cache import cacheit\n@cacheit\ndef a(n): return 1 if n==1 else a(n - 1) + 2*(primepi(2*n - 1) - primepi(n))\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A292931", "text": "Numbers n such that the sum of digits of 3^n (A004166) is divisible by 7.", "sequence": "25,26,30,32,47,58,79,81,87,89,102,123,141,144,145,151,164,176,178,193,201,227,239,242,257,264,282,289,300,306,319,324,329,335,336,338,348,351,358,365,395,403,437,441,450,460,468,484,489,492,495,517,518,541,542,544,554,555,563,565,570", "code": "\nfrom __future__ import division\nA292931_list = [n for n in range(1000) if not sum(int(d) for d in str(3**n)) % 7] \n"}
{"sequence_id": "A292995", "text": "Sum of digits of 3^n (A004166) divided by 9.", "sequence": "0,0,1,1,1,1,2,2,2,3,3,3,2,3,5,4,3,3,5,4,5,3,5,6,6,7,7,9,8,8,7,9,7,8,11,9,9,10,10,9,10,11,10,12,10,11,12,14,13,12,16,13,13,15,12,10,10,12,14,13,11,15,17,17,16,15,13,18,17,17,16,20,18,17,19,20,17,18", "code": "\nfrom __future__ import division\ndef A292995(n):\n    return sum(int(d) for d in str(3**n))//9 \n"}
{"sequence_id": "A293079", "text": "Decimal expansion of log_Pi(3).", "sequence": "9,5,9,7,1,3,1,1,8,5,6,9,3,9,0,0,1,9,3,3,6,0,2,3,1,9,8,8,4,3,5,0,0,6,5,4,9,4,2,2,4,7,4,3,5,6,3,9,5,7,5,3,4,5,5,1,1,0,4,5,7,2,7,7,0,6,7,3,9,1,3,7,6,7,3,2,8,1,9,1,9,9,8,7,9,2,7,1,5,8,0,3,8,0,0,1,8,8,1,4", "code": "\nfrom math import log, pi\nprint(log(3,pi))\n"}
{"sequence_id": "A293481", "text": "Numbers with last digit greater than or equal to 5 (in base 10).", "sequence": "5,6,7,8,9,15,16,17,18,19,25,26,27,28,29,35,36,37,38,39,45,46,47,48,49,55,56,57,58,59,65,66,67,68,69,75,76,77,78,79,85,86,87,88,89,95,96,97,98,99,105,106,107,108,109,115,116,117,118,119,125,126,127,128,129", "code": " [k for k in range(130) if (k//5) % 2 == 1] \n"}
{"sequence_id": "A293655", "text": "Numbers having in binary representation more zeros than their squares.", "sequence": "181,5221,11309,19637,21577,22805,43151,69451,74969,76845,82709,83539,85029,86283,86581,91205,148245,165013,165061,165418,166027,170021,172213,172615,173095,173101,173162,173331,180405,182433,184587,184885,185363,201829,282713", "code": "\ndef count0(n):\n    return bin(n)[2:].count('0')\nfor n in range(1000000):\n    if count0(n*n) < count0(n):\n        print(str(n), end=',')\n"}
{"sequence_id": "A293709", "text": "Number of Hamiltonian walks on a Sierpinski fractal.", "sequence": "1,2,10,92,1852,78032,6846876,1255156712,482338029046,387869817764474,652822489612455344,2300645402905295350788,16976857303773016457918252", "code": "\n\nfrom graphillion import GraphSet\ndef make_n_triangular_grid_graph(n):\n    s = 1\n    grids = []\n    for i in range(n + 1, 1, -1):\n        for j in range(i - 1):\n            a, b, c = s + j, s + j + 1, s + i + j\n            grids.extend([(a, b), (a, c), (b, c)])\n        s += i\n    return grids\ndef A293709(n):\n    universe = make_n_triangular_grid_graph(n - 1)\n    GraphSet.set_universe(universe)\n    start, goal = 1, n * (n + 1) // 2\n    paths = GraphSet.paths(start, goal, is_hamilton=True)\n    return paths.len()\nprint([A293709(n) for n in range(2, 10)])  \n"}
{"sequence_id": "A293722", "text": "Number of distinct nonempty subsequences of the binary expansion of n.", "sequence": "1,1,3,2,5,6,5,3,7,10,11,9,8,9,7,4,9,14,17,15,16,19,17,12,11,15,16,13,11,12,9,5,11,18,23,21,24,29,27,20,21,29,32,27,25,28,23,15,14,21,25,22,23,27,24,17,15,20,21,17,14,15,11,6,13,22,29,27,32,39,37", "code": "\ndef a(n):\n    if n == 0: return 1\n    r, l = 1, [0, 0]\n    while n:\n        r, l[n%2] = 2*r - l[n%2], r\n        n >>= 1\n    return r - 1\n"}
{"sequence_id": "A293733", "text": "Number of multisets of nonempty words with a total of n letters over ternary alphabet such that within each prefix of a word every letter of the alphabet is at least as frequent as the subsequent alphabet letter.", "sequence": "1,1,3,7,19,48,131,348,954,2607,7212,19995,55816,156246,439267,1238397,3502004,9927260,28208628,80322048,229161413,654966245,1875074366,5376298225,15437286706,44385247519,127776425727,368276055467,1062618076382,3069264747076", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import divisors\n@cacheit\ndef g(n): return 1 if n<2 else g(n - 1) + sum([g(k)*g(n - k - 2) for k in range(n - 1)])\n@cacheit\ndef a(n): return 1 if n==0 else sum([sum([g(d)*d for d in divisors(j)])*a(n - j) for j in range(1, n + 1)])//n\nprint(map(a, range(36))) \n"}
{"sequence_id": "A293734", "text": "Number of multisets of nonempty words with a total of n letters over quaternary alphabet such that within each prefix of a word every letter of the alphabet is at least as frequent as the subsequent alphabet letter.", "sequence": "1,1,3,7,20,53,157,455,1393,4270,13495,42907,139323,455182,1510831,5042858,17044789,57891598,198665585,684615958,2379765470,8302157207,29177909254,102867895209,364981305292,1298526198294,4645569147108,16659856695779,60036951331540", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import divisors\n@cacheit\ndef g(n): return 1 if n<2 else (4*(2*n + 3)*g(n - 1) + 16*(n - 1)*n*g(n - 2))//((n + 3)*(n + 4))\n@cacheit\ndef a(n): return 1 if n==0 else sum(sum(g(d)*d for d in divisors(j))*a(n - j) for j in range(1, n + 1))//n\nprint([a(n) for n in range(36)]) \n"}
{"sequence_id": "A293741", "text": "Number of sets of nonempty words with a total of n letters over binary alphabet such that within each prefix of a word every letter of the alphabet is at least as frequent as the subsequent alphabet letter.", "sequence": "1,1,2,5,10,23,51,111,243,530,1156,2497,5421,11662,25179,53991,116035,248025,531045,1131943,2415495,5135914,10927905,23182313,49199819,104154950,220543471,465997148,984704560,2076988713,4380764650,9225209928,19424814305", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef b(n, i): return 1 if n==0 else 0 if i<1 else sum([b(n - i*j, i - 1)*binomial(binomial(i, i//2), j) for j in range(n//i + 1)])\ndef a(n): return b(n, n)\nprint([a(n) for n in range(36)]) \n"}
{"sequence_id": "A293742", "text": "Number of sets of nonempty words with a total of n letters over ternary alphabet such that within each prefix of a word every letter of the alphabet is at least as frequent as the subsequent alphabet letter.", "sequence": "1,1,2,6,14,39,104,284,775,2145,5941,16563,46329,130100,366432,1035191,2931797,8323290,23680142,67505721,192791938,551537506,1580315319,4534715008,13030197881,37489497472,107991978290,311433926717,899093131819,2598257241179", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef g(n): return 1 if n<2 else g(n - 1) + sum(g(k)*g(n - k - 2) for k in range(n - 1))\n@cacheit\ndef b(n, i): return 1 if n==0 else 0 if i<1 else sum(b(n - i*j, i - 1)*binomial(g(i), j) for j in range(n//i + 1))\ndef a(n): return b(n, n)\nprint([a(n) for n in range(36)]) \n"}
{"sequence_id": "A293743", "text": "Number of sets of nonempty words with a total of n letters over quaternary alphabet such that within each prefix of a word every letter of the alphabet is at least as frequent as the subsequent alphabet letter.", "sequence": "1,1,2,6,15,44,129,386,1185,3690,11725,37578,122577,402477,1340640,4490368,15219148,51825464,178235039,615461671,2143127872,7488890027,26357539204,93050275129,330544091758,1177338456789,4216288462832,15134924595039,54588972553934", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import binomial\n@cacheit\ndef g(n): return 1 if n<2 else (4*(2*n + 3)*g(n - 1) + 16*(n - 1)*n*g(n - 2))//((n + 3)*(n + 4))\n@cacheit\ndef b(n, i): return 1 if n==0 else 0 if i<1 else sum([b(n - i*j, i - 1)*binomial(g(i), j) for j in range(n//i + 1)])\ndef a(n): return b(n, n)\nprint([a(n) for n in range(36)]) \n"}
{"sequence_id": "A293807", "text": "a(0) = a(1) = 1; a(n) = [x^n] Product_{k=1..n-1} 1/(1 - x^a(k))^a(k).", "sequence": "1,1,1,4,9,14,19,24,39,63,87,111,155,235,329,423,552,771,1091,1430,1825,2400,3295,4392,5597,7117,9367,12476,16077,20182,25677,33472,43406,54578,68109,86475,111316,140965,174836,217520,275130,348555,433578,533640,662620,831747", "code": "\nfrom sympy import binomial\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n, i): return 1 if n==0 else 0 if i<1 else sum(b(n - a(i)*j, i - 1) * binomial(a(i) + j - 1, j) for j in range(n//a(i) + 1))\ndef a(n): return 1 if n<2 else b(n, n - 1)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A294092", "text": "Numbers k == 119 (mod 120) such that 2^((k-1)/2), 3^((k-1)/2) and 5^((k-1)/2) are congruent to 1 (mod k).", "sequence": "239,359,479,599,719,839,1319,1439,1559,2039,2399,2879,2999,3119,3359,3719,4079,4679,4799,4919,5039,5279,5399,5519,5639,5879,6359,6599,6719,6959,7079,7559,7919,8039,8999,9239,9479,9719,9839,10079,10559,10799,11159,11279", "code": "\nA294092_list, k, m = [], 119, 59\nwhile len(A294092_list) < 10000:\n    if pow(2,m,k) == 1 and pow(3,m,k) == 1 and pow(5,m,k) == 1:\n        A294092_list.append(k)\n    k += 120\n    m += 60 \n"}
{"sequence_id": "A294247", "text": "Sum of the parts in the partitions of n into exactly two distinct squarefree parts.", "sequence": "0,0,3,4,5,6,14,24,18,10,22,36,39,28,45,80,68,72,57,100,84,88,92,168,125,104,135,168,145,120,155,256,198,204,210,396,259,228,273,440,328,294,387,528,450,322,376,624,490,400,357,676,530,540,385,728,570", "code": "\nfrom sympy import mobius\ndef a(n): return n*sum(mobius(i)**2*mobius(n - i)**2 for i in range(1, ((n - 1)//2) + 1))\nprint([a(n) for n in range(1, 51)]) \n"}
{"sequence_id": "A294269", "text": "a(n) is the smallest number not already in the sequence which shares a factor with an even number of preceding terms; a(1) = 1.", "sequence": "1,2,3,5,6,4,7,9,10,8,11,13,14,12,15,17,18,16,19,21,22,20,23,25,26,24,27,29,30,28,31,33,34,32,35,37,38,36,39,41,42,40,43,45,46,44,47,49,50,48,51,53,54,52,55,57,58,56,59,61,62,60,63,65,66,64,67", "code": "\nfrom math import gcd\ndef getSeq(n):\n    if n == 1:\n        return [1]\n    prev = getSeq(n-1)\n    cand = 1\n    while True:\n        cand += 1\n        if cand in prev:\n            continue\n        if len([n for n in prev if gcd(cand, n) > 1]) % 2 == 0:\n            prev.append(cand)\n            return prev\nprint(getSeq(100))\n"}
{"sequence_id": "A294317", "text": "Triangle read by rows: T(n, k) = 2*n-k, k <= n.", "sequence": "0,2,1,4,3,2,6,5,4,3,8,7,6,5,4,10,9,8,7,6,5,12,11,10,9,8,7,6,14,13,12,11,10,9,8,7,16,15,14,13,12,11,10,9,8,18,17,16,15,14,13,12,11,10,9,20,19,18,17,16,15,14,13,12,11,10", "code": "\ndef f(x):\n    a=[]\n    for k in range(x):\n        for m in range (k+1):\n            a.append(2*k-m)\n    return a\nprint(f(10))\n"}
{"sequence_id": "A294497", "text": "Squares k (not ending in 0) such that the integer that is built up by concatenating the floors of the square roots of the two-digit numbers into which the original number is separated (from right to left) is the square root of the original number.", "sequence": "1,4,9,16,25,36,49,64,81,225,625,1225,2025,2601,2704,2809,2916,3025,3136,3249,3364,3481,4225,5625,7225,9025,22801,23104,23409,50625,63001,63504,75625,123201,180625,203401,225625,390625,432964,455625,573049,680625,732736,765625,2175625,6260004,6270016", "code": "\nimport math\nfor k in range(1,1000000000):\n   p = 0\n   z = 0\n   n = k*k\n   while n >= 100:\n      z = z + int(math.floor(math.sqrt(n % 100)) * math.pow(10, p))\n      n = int((n - (n % 100)) / 100)\n      p = p + 1\n   z = z + int(math.floor(math.sqrt(n)) * math.pow(10, p))\n   if z == k and k % 10 > 0:\n      print(k * k, k)\n"}
{"sequence_id": "A294647", "text": "Differential variant of the Kolakoski sequence, with initial terms 1, 1.", "sequence": "1,1,2,2,2,1,2,2,2,1,1,1,2,1,1,1,2,2,1,1,1,2,2,1,1,1,2,1,1,2,2,1,2,2,2,1,1,2,2,2,1,1,2,1,1,1,2,2,2,1,2,2,2,1,1,2,1,1,1,2,1,1,2,2,2,1,1,2,2,2,1,2,2,2,1,1,1,2,1,1,1,2,2,1,2,2,1", "code": "\na = [1]\nfor n in range(100):\n    a += [3-a[-1] if n%2 else a[-1], a[-1]][:a[n]]\nprint(a)\n\n"}
{"sequence_id": "A294648", "text": "Irregular triangle read by rows, representing a family of sequences L(n), for n=1, 2, 3, ... The sequence L(n) (i.e., the n-th row) is the ordinance of vectors of the n-dimensional Boolean cube (hypercube) {0,1}^n in accordance with their (Hamming) weights, where the lexicographic order is chosen as a second criterion for an ordinance the vectors of equal weights.", "sequence": "0,1,0,1,2,3,0,1,2,4,3,5,6,7,0,1,2,4,8,3,5,6,9,10,12,7,11,13,14,15,0,1,2,4,8,16,3,5,6,9,10,12,17,18,20,24,7,11,13,14,19,21,22,25,26,28,15,23,27,29,30,31,0,1,2,4,8,16,32,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,7,11,13,14,19,21", "code": "\nfrom itertools import product\ndef sortby(x): return (len(x), x.count('1'), x)\ndef agen(maxbindigs):\n    for i in range(1, maxbindigs+1):\n        for t in sorted([p for p in product(\"01\", repeat=i)], key=sortby):\n            yield int(\"\".join(t), 2)\nprint([an for an in agen(6)]) \n"}
{"sequence_id": "A295005", "text": "Numbers n such that the largest digit of n^2 is 5.", "sequence": "5,15,35,39,45,50,55,65,71,105,112,115,145,150,155,185,188,205,211,229,235,335,350,365,368,388,389,390,450,461,485,495,500,501,502,505,550,579,585,595,635,650,652,665,671,710,711,715,718,729,735,745,1005,1015,1050", "code": "\ndef aupto(limit):\n  alst = []\n  for k in range(1, limit+1):\n    if max(str(k*k)) == \"5\": alst.append(k)\n  return alst\nprint(aupto(1050)) \n"}
{"sequence_id": "A295008", "text": "Numbers whose square has largest digit 8.", "sequence": "9,22,28,29,41,59,62,72,78,90,91,92,94,104,109,122,126,128,135,151,159,168,169,178,184,191,192,195,196,202,209,220,221,232,241,242,259,261,262,268,278,279,280,284,285,289,290,291,292,294,295,296,298,322,328,329,341,344,349", "code": "\ndef ok(n): return max(int(d) for d in str(n*n)) == 8\nprint(list(filter(ok, range(350)))) \n"}
{"sequence_id": "A295015", "text": "Squares whose largest digit is 5.", "sequence": "25,225,1225,1521,2025,2500,3025,4225,5041,11025,12544,13225,21025,22500,24025,34225,35344,42025,44521,52441,55225,112225,122500,133225,135424,150544,151321,152100,202500,212521,235225,245025,250000,251001,252004,255025,302500", "code": "\nfrom math import isqrt\ndef aupto(limit):\n  alst, rootlimit = [], isqrt(limit)\n  for k in range(1, rootlimit+1):\n    if max(str(k*k)) == \"5\": alst.append(k*k)\n  return alst\nprint(aupto(302500)) \n"}
{"sequence_id": "A295222", "text": "Array read by antidiagonals: T(n,k) is the number of nonequivalent dissections of a polygon into n k-gons by nonintersecting diagonals rooted at a cell up to rotation (k >= 3).", "sequence": "1,1,1,1,1,3,1,1,5,10,1,1,6,22,30,1,1,8,40,116,99,1,1,9,64,285,612,335,1,1,11,92,578,2126,3399,1144,1,1,12,126,1015,5481,16380,19228,3978,1,1,14,166,1641,11781,54132,129456,111041,14000", "code": "\nfrom sympy import binomial, gcd, totient, divisors\ndef u(n, k, r): return r*binomial((k - 1)*n + r, n)//((k - 1)*n + r)\ndef T(n, k): return sum([totient(d)*u((n - 1)//d, k, k//d) for d in divisors(gcd(n - 1, k))])//k\nfor n in range(1, 11): print([T(n, k) for k in range(3, 9)]) \n"}
{"sequence_id": "A295224", "text": "Array read by antidiagonals: T(n,k) = number of nonequivalent dissections of a polygon into n k-gons by nonintersecting diagonals up to rotation (k >= 3).", "sequence": "1,1,1,1,1,1,1,1,2,4,1,1,2,7,6,1,1,3,12,25,19,1,1,3,19,57,108,49,1,1,4,26,118,366,492,150,1,1,4,35,203,931,2340,2431,442,1,1,5,46,332,1989,7756,16252,12371,1424,1,1,5,57,494,3766,20254,68685,115940,65169,4522", "code": "\nfrom sympy import binomial, gcd, totient, divisors\ndef u(n, k, r): return r*binomial((k - 1)*n + r, n)//((k - 1)*n + r)\ndef T(n, k): return u(n, k, 1) + ((u(n//2, k, 1) if n%2==0 else 0) - u(n, k, 2))//2 + sum([totient(d)*u((n - 1)//d, k, k//d) for d in divisors(gcd(n - 1, k))])//k\nfor n in range(1, 11): print([T(n, k) for k in range(3, 9)]) \n"}
{"sequence_id": "A295259", "text": "Array read by antidiagonals: T(n,k) = number of nonequivalent dissections of a polygon into n k-gons by nonintersecting diagonals rooted at a cell up to rotation and reflection (k >= 3).", "sequence": "1,1,1,1,1,2,1,1,4,6,1,1,4,13,16,1,1,6,22,64,52,1,1,6,35,147,315,170,1,1,8,49,302,1074,1727,579,1,1,8,67,518,2763,8216,9658,1996,1,1,10,87,843,5916,27168,64798,55657,7021", "code": "\nfrom sympy import binomial, gcd, totient, divisors\ndef u(n, k, r): return r*binomial((k - 1)*n + r, n)//((k - 1)*n + r)\ndef F(n, k): return sum([totient(d)*u((n - 1)//d, k, k//d) for d in divisors(gcd(n - 1, k))])//k\ndef T(n, k): return (F(n, k) + ((u((n - 1)//2, k, (k - 1)//2) if n%2 else u(n//2 - 1, k, k - 1)) if k%2 else (u((n - 1)//2, k, k//2 + 1) if n%2 else u(n//2 - 1, k, k))))//2\nfor n in range(1, 11): print([T(n, k) for k in range(3, 9)]) \n"}
{"sequence_id": "A295425", "text": "a(n) = smallest number > a(n-1) such that the number of preceding terms in the sequence dividing a(n) is divisible by 4; a(1) = 2.", "sequence": "2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,210,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,330,331", "code": "\nimport math\ndef getSeq(n):\n....if n == 1:\n........return [2]\n....prev = getSeq(n-1)\n....cand = max(prev)\n....while True:\n........cand += 1\n........if len( [n for n in prev if cand % n == 0] ) % 4 == 0:\n............prev.append(cand)\n............return prev\nprint(getSeq(100))\n"}
{"sequence_id": "A295430", "text": "a(n) is the least nontrivial multiple of n that begins with 3.", "sequence": "3,30,30,32,30,30,35,32,36,30,33,36,39,308,30,32,34,36,38,300,315,308,322,312,300,312,324,308,319,300,310,320,330,306,315,324,333,304,312,320,328,336,301,308,315,322,329,336,343,300,306,312,318,324,330,336,342,348,354,300,305,310,315", "code": "\ndef A295430(n):\n    m = 2*n\n    while True:\n        if str(m)[0] == '3':\n            return m\n        m += n \n"}
{"sequence_id": "A295638", "text": "Take the sequence of nonnegative integers whose decimal digits are not in strictly increasing order. Partition the sequence into subsequences whose elements are consecutive integers. Then a(n) is the number of elements in the n-th partition.", "sequence": "2,3,4,5,6,7,8,9,33,4,5,6,7,8,9,44,5,6,7,8,9,55,6,7,8,9,66,7,8,9,77,8,9,88,9,99,444,5,6,7,8,9,55,6,7,8,9,66,7,8,9,77,8,9,88,9,99,555,6,7,8,9,66,7,8,9,77,8,9,88,9,99,666,7,8", "code": " def a(n):\n    (x,i,count,switch) = (0,0,1,True)\n    while True:\n        if switch == (list(sorted(set(str(i)))) == list(str(i))):\n            count += 1\n        else:\n            if not switch: x += 1\n            if x == n: return count\n            (count, switch) = (1, not switch)\n        i += 1\n"}
{"sequence_id": "A295661", "text": "Numbers with at least one odd exponent larger than one in their prime factorization.", "sequence": "8,24,27,32,40,54,56,72,88,96,104,108,120,125,128,135,136,152,160,168,184,189,200,216,224,232,243,248,250,264,270,280,288,296,297,312,328,343,344,351,352,360,375,376,378,384,392,408,416,424,432,440,456,459,472,480,486,488,500,504,512,513,520,536,540", "code": "\nfrom sympy import factorint\ndef ok(n):\n    return max((e for e in factorint(n).values() if e%2), default=-1) > 1\nprint(list(filter(ok, range(541)))) \n"}
{"sequence_id": "A295863", "text": "Number of ordered pairs of length-n mutually overlapping binary strings.", "sequence": "2,6,30,130,536,2174,8746,35070,140438,562008,2248460,8994530,35979160,143917970,575673270,2302692898,9210765608", "code": "\nfrom itertools import product\ndef overlapping(u, v):\n    for i in range(1, 1+min(len(u), len(v))):\n        if v[:i]==u[-i:]: return True\n    return False\ndef a(n):\n    out = 0\n    for u in product(\"01\", repeat=n-1):\n        u = (\"0\",) + u\n        for v in product(\"01\", repeat=n):\n            if overlapping(u, v) and overlapping(v, u): out += 1\n    return 2*out \nprint([a(n) for n in range(1, 11)]) \n"}
{"sequence_id": "A295864", "text": "a(n) = hypergeom([-n, -n], [1], 1) * n! / (floor(n/2)!)^2.", "sequence": "1,2,12,120,420,7560,18480,480480,900900,30630600,46558512,1955457504,2498640144,124932007200,137680171200,7985449929600,7735904619300,510569704873800,441233078286000,32651247793164000,25467973278667920,2088373808850769440,1484298740174927040", "code": "\ndef A295864():\n    r, c, n = 1, 1, 0\n    while True:\n        yield r * c\n        n += 1\n        c = c*(4*n-2)//n\n        r = (r*4)//n if n % 2 == 0 else r*n\na = A295864(); [next(a) for i in range(23)]\n"}
{"sequence_id": "A295897", "text": "Numbers in whose binary expansion there are no 1-runs of odd length followed by a 0 to their right.", "sequence": "0,1,3,6,7,12,13,15,24,25,27,30,31,48,49,51,54,55,60,61,63,96,97,99,102,103,108,109,111,120,121,123,126,127,192,193,195,198,199,204,205,207,216,217,219,222,223,240,241,243,246,247,252,253,255,384,385,387,390,391,396,397,399,408,409,411,414,415,432", "code": "\n[x ^ (x>>1) for x in range(0,2048) if (x & (x<<1) == 0)]\n\n"}
{"sequence_id": "A295900", "text": "Numbers n such that n^3 contains the consecutive substring 2,3,5,7.", "sequence": "1331,3108,3176,4093,4643,5846,6178,6797,9175,10731,13076,13245,13309,13310,14093,14526,16291,17852,20095,20791,21835,23635,23766,24093,28452,28672,28673,28674,28675,29211,31080,31760,33907,34093,34986,36449,38538,38599,39526", "code": " A295900_list = [n for n in range(1,10**6) if '2357' in str(n**3)] \n"}
{"sequence_id": "A296012", "text": "Primes of the form k + k+1 + k+2 +-1 where k, k+1, and k+2 are all composite numbers.", "sequence": "79,101,103,149,151,167,191,193,227,229,257,277,281,283,347,349,353,359,367,373,401,431,433,439,461,463,479,509,557,563,607,613,617,619,641,643,647,653,659,661,709,733,739,743,761,797,821,823,857,859,863,887,907,911,967,971,977,983,1019,1021", "code": "\nfrom __future__ import division\nfrom sympy import nextprime, isprime\nA296012_list, p = [], 2\nwhile len(A296012_list) < 10000:\n    k = (p-2)//3\n    if not (isprime(k) or isprime(k+2)):\n        A296012_list.append(p)\n    p = nextprime(p) \n"}
{"sequence_id": "A296030", "text": "Pairs of coordinates for successive integers in the square spiral (counterclockwise).", "sequence": "0,0,1,0,1,1,0,1,-1,1,-1,0,-1,-1,0,-1,1,-1,2,-1,2,0,2,1,2,2,1,2,0,2,-1,2,-2,2,-2,1,-2,0,-2,-1,-2,-2,-1,-2,0,-2,1,-2,2,-2,3,-2,3,-1,3,0,3,1,3,2,3,3,2,3,1,3,0,3,-1,3,-2,3,-3,3,-3,2", "code": " def get_coordinate(n):\n....k=ceil((sqrt(n)-1)/2)\n....t=2*k+1\n....m=t**2\n....t=t-1\n....if n >= m - t:\n........return k - (m-n), -k\n....else:\n........m -= t\n....if n >= m - t:\n........return -k, -k+(m-n)\n....else:\n........m -= t\n....if n >= m-t:\n........return -k+(m-n), k\n....else:\n........return k, k-(m-n-t)\n"}
{"sequence_id": "A296103", "text": "Number of shapes of left-leaning height-balanced AVL trees with n (inner) nodes.", "sequence": "1,1,1,1,1,2,2,2,3,5,7,9,11,13,17,26,42,66,97,134,180,241,321,424,564,774,1111,1661,2545,3925,6012,9079,13480,19678,28296,40212,56701,79599,111469,155795,217301,302590,421396,588782,828633,1178919,1699502,2483695", "code": " \n"}
{"sequence_id": "A296104", "text": "Numbers k such that 2^k == 3 (mod k-1).", "sequence": "2,111482,465794,79036178,1781269903308,250369632905748,708229497085910,15673900819204068", "code": "\nA296104_list = [n for n in range(2,10**6) if pow(2,n,n-1) == 3 % (n-1)] \n"}
{"sequence_id": "A296300", "text": "Numbers divisible by their length in every base.", "sequence": "1,2,6,8,12,36,48,60,240,360,540,600,660,720,840,2100,2280,2400,2520,2640,2760,2880,3000,3120,3240,3360,3480,3600,3720,3840,3960,4080,8820,10080,11340,12600,13860,15120,16380,17640,20160,21000,21840,22680,23520,24360", "code": " [n for n in range(1, 100000) if all(n%k == 0 or n**(1/k) >= int(n**(1/(k-1))) for k in range(2, len(bin(n))-1))]\n"}
{"sequence_id": "A296303", "text": "Number of minimal nonnegative nonzero solutions of the linear Diophantine equation x_1 + 2*x_2 + ... + n*x_n = y_1 + 2*y_2 + ... + n*y_n.", "sequence": "1,4,13,34,99,210,559,1164,2531,4940,10735", "code": " See Pommerening link.\n"}
{"sequence_id": "A296369", "text": "Numbers m such that 2^m == -1/2 (mod m).", "sequence": "1,5,65,377,1189,1469,25805,58589,134945,137345,170585,272609,285389,420209,538733,592409,618449,680705,778805,1163065,1520441,1700945,2099201,2831009,4020029,4174169,4516109,5059889,5215769", "code": "\nA296369_list = [n for n in range(1,10**6) if pow(2,n+1,n) == n-1] \n"}
{"sequence_id": "A296516", "text": "a(n) is the number of terms in expanded form of bivariate polynomial Q_n, where (P_n, Q_n) is defined by: P_0 = x, Q_0 = y, P_(n+1) = P_n + Q_n, Q_(n+1) = P_n * Q_n.", "sequence": "1,1,2,5,14,40,111,300,797,2098,5499,14389,37634,98435,257516,673827,1763460,4615686,12082137,31628294", "code": "\ndef A296516(n):\n    P, Q = {(1,0)}, {(0,1)}\n    for _ in range(n): P, Q = P|Q, set((p[0]+q[0],p[1]+q[1]) for p in P for q in Q)\n    return len(Q) \n"}
{"sequence_id": "A296527", "text": "Number of (undirected) cycles in the n X n torus grid graph.", "sequence": "312,14704,2183490,995818716,1383238940818", "code": "\n\nfrom graphillion import GraphSet\ndef make_CnXCk(n, k):\n    grids = []\n    for i in range(1, k + 1):\n        for j in range(1, n):\n            grids.append((i + (j - 1) * k, i + j * k))\n        grids.append((i + (n - 1) * k, i))\n    for i in range(1, k * n, k):\n        for j in range(1, k):\n            grids.append((i + j - 1, i + j))\n        grids.append((i + k - 1, i))\n    return grids\ndef A296527(n):\n    universe = make_CnXCk(n, n)\n    GraphSet.set_universe(universe)\n    cycles = GraphSet.cycles()\n    return cycles.len()\nprint([A296527(n) for n in range(3, 7)])  \n"}
{"sequence_id": "A296689", "text": "Let phi be the one-to-one mapping between binary trees and natural numbers described in the Tychonievich link. Let a(n) = min({phi^{-1}(t)| size(t)=n}); i.e., a(n) is the rank -- starting from 0 -- of the first tree the size of which is n.", "sequence": "0,1,2,4,7,13,24,30,54,64,124,244,383,503,981,1021,1981,3901,6137,8057,13649,16369,32689,65329,98230,130870,229312,261952,491516,524156,1046388,1048564,2093044,4182004,8359924,16715764,25141220,33497060,58703812,67059652,125828996,134184836,259487492,268435204,536866564,1073729284", "code": "\ndef dei(n):\n    n1 = n2 = 0\n    bit = 1\n    while n:\n        if n&1:\n            n1 += bit\n        n >>= 1\n        if n&1:\n            n2 += bit\n        n >>= 1\n        bit <<= 1\n    return (n1, n2)\nr = [0]\nfor n in range(1, 100):\n    r.append(1 + sum(r[x] for x in dei(n-1)))\nprint([r.index(x) for x in range(max(r)+1)])\n\n"}
{"sequence_id": "A296858", "text": "Numbers whose base-2 digits have #(pits) = #(peaks); see Comments.", "sequence": "1,2,3,4,6,7,8,9,10,12,14,15,16,17,19,20,24,25,26,28,30,31,32,33,35,37,38,39,40,41,42,48,49,51,52,56,57,58,60,62,63,64,65,67,69,70,71,75,76,78,79,80,81,83,84,96,97,99,101,102,103,104,105,106,112", "code": "\ndef cwo(subs, s): \n  c = i = 0\n  while i != -1:\n    i = s.find(subs, i)\n    if i != -1: c += 1; i += 1\n  return c\ndef ok(n): b = bin(n)[2:]; return cwo('101', b) == cwo('010', b)\nprint(list(filter(ok, range(1, 113)))) \n"}
{"sequence_id": "A296859", "text": "Numbers whose base-2 digits have #(pits) > #(peaks); see Comments.", "sequence": "5,11,13,21,22,23,27,29,43,44,45,46,47,53,54,55,59,61,77,85,86,87,88,89,90,91,92,93,94,95,107,108,109,110,111,117,118,119,123,125,141,155,157,171,172,173,174,175,176,177,179,180,181,182,183,184,185,186", "code": "\ndef cwo(subs, s): \n  c = i = 0\n  while i != -1:\n    i = s.find(subs, i)\n    if i != -1: c += 1; i += 1\n  return c\ndef ok(n): b = bin(n)[2:]; return cwo('101', b) > cwo('010', b)\nprint(list(filter(ok, range(1, 187)))) \n"}
{"sequence_id": "A296860", "text": "Numbers k whose base-2 digits d(m), d(m-1), ..., d(0) have #(pits) < #(peaks); see Comments.", "sequence": "18,34,36,50,66,68,72,73,74,82,98,100,114,130,132,136,137,138,144,145,146,147,148,162,164,194,196,200,201,202,210,226,228,242,258,260,264,265,266,272,273,274,275,276,288,289,290,291,292,293,294,295,296,297", "code": "\ndef cwo(subs, s): \n  c = i = 0\n  while i != -1:\n    i = s.find(subs, i)\n    if i != -1: c += 1; i += 1\n  return c\ndef ok(n): b = bin(n)[2:]; return cwo('101', b) < cwo('010', b)\nprint(list(filter(ok, range(1, 298)))) \n"}
{"sequence_id": "A297120", "text": "Number of compositions derived from the overpartitions of n.", "sequence": "1,2,5,14,36,92,234,586,1452,3562,8674,20956,50290,119922,284308,670458,1573250,3674700,8546282,19796234,45681908,105041402,240723618,549919604,1252492674,2844551866,6442833156,14555300218,32801922154,73749649900,165443000338", "code": "\nfrom sympy.core.cache import cacheit\nfrom sympy import factorial\n@cacheit\ndef b(n, i, p):  return factorial(p + n)*(n + 1)//factorial(n) if n==0 or i==1 else sum(b(n - i*j, i - 1, p + j)*(j + 1)//factorial(j) for j in range(n//i + 1))\ndef a(n): return b(n, n, 0)\nprint([a(n) for n in range(41)]) \n"}
{"sequence_id": "A297159", "text": "a(n) = 3*n - 2*phi(n) - sigma(n); Difference between the deficiency of n and its Moebius-transform.", "sequence": "0,1,1,1,1,2,1,1,2,4,1,0,1,6,5,1,1,3,1,2,7,10,1,-4,4,12,5,4,1,2,1,1,11,16,9,-7,1,18,13,-2,1,6,1,8,9,22,1,-12,6,17,17,10,1,6,13,0,19,28,1,-20,1,30,13,1,15,14,1,14,23,18,1,-27,1,36,21,16,15,18,1,-10,14,40,1,-20,19,42,29,4,1,-12,17,20,31,46,21,-28,1,39,21,3,1,26", "code": "\nfrom sympy import totient, divisor_sigma\ndef a(n): return 3*n-2*totient(n)-divisor_sigma(n)\nprint([a(n) for n in range(1, 101)]) \n"}
{"sequence_id": "A297345", "text": "a(0)=0; for n>0, a(n) is the least positive integer that cannot be represented as Sum_{k=1..n-1} a(i_k)*a(k), with 0 <= i_k < n.", "sequence": "0,1,2,7,24,85,285,1143,6268,216784,1059813,6100794,226303113", "code": "\n\n\n\n\nimport numpy as np\nimport itertools\nlast=100\ndef generate(i,S):\n    n=len(S)\n    s=np.asarray(S,dtype=np.int)\n    perms = [p for p in itertools.product(S, repeat=n)]\n    for iks in perms:\n        t=np.asarray(iks)\n        if np.dot(t,s) == i:\n            print('%d=' %i, end=',')\n            print(t,'x',s)\n            return 0\n    return -1\nS=[0]\nfor i in range(1,last+1):\n        if generate(i,S) == -1:\n            S.append(i)\n            generate(i,S)\n"}
{"sequence_id": "A297574", "text": "Least integer m > n such that 2^m == 2^n (mod m*n).", "sequence": "2,6,15,6,65,8,16,12,63,30,31,16,85,26,39,20,65,72,73,24,57,32,56,32,1025,170,513,40,85,42,91,40,93,130,155,144,73,56,111,48,341,48,127,64,585,112,2048,60,2107,550,195,64,157,1026,155,80,219,86,233,64,1261,82,171,73,257,96,595,140,201,130,281,126", "code": "\ndef A297574(n):\n    m = n+1\n    mn = m*n\n    while pow(2,m,mn) != pow(2,n,mn):\n        m += 1\n        mn += n\n    return m \n"}
{"sequence_id": "A297621", "text": "a(0) = 1; for n > 0, a(n) = 1 + Sum_{k = 1..n} 2^k a(floor(log_2(k))).", "sequence": "1,3,15,39,279,759,1719,3639,13623,33591,73527,153399,313143,632631,1271607,2549559,20834103,57403191,130541367,276817719,569370423,1154475831,2324686647,4665108279,9345951543,18707638071,37431011127,74877757239,149771249463", "code": "\nfrom math import log\ndef exp_fit(n, a, b):\n    k = int(log(n, 2))\n    return 3 * (a[k] * (2 ** (n + 1)) - b[k])\ndef S(n):\n    if n == 0:\n        return 1\n    k = int(log(n, 2))\n    a = [0]\n    b = [-1]\n    for i in range(1,k + 1):\n        S_0 = exp_fit(i, a, b)\n        S_1 = exp_fit(2 ** i - 1, a, b)\n        a.append(S_0 / 3)\n        b.append(((2 ** 2 ** i) * S_0 - S_1) / 3)\n    return exp_fit(n, a, b)\n"}
{"sequence_id": "A297624", "text": "Numbers k such that Fibonacci(2*k+1) and Fibonacci(2*k-1) are prime.", "sequence": "2,3,6,216,285", "code": "\nfrom sympy import isprime\nA297624_list, k, a, b, c, aflag = [], 1, 1, 1, 2, False\nwhile k < 1000:\n    cflag = isprime(c)\n    if aflag and cflag:\n        A297624_list.append(k)\n    k, a, b, c, aflag = k + 1, c, b + c, b + 2*c, cflag \n"}
{"sequence_id": "A297710", "text": "Partition numbers (A000041) in which parity of digits alternates.", "sequence": "1,2,3,5,7,30,56,101,385,490,3010,4565,8349,10143", "code": "\nfrom sympy import npartitions\nA297710_list = []\nfor i in range(1,10**6):\n    n = npartitions(i)\n    s = [int(d) for d in str(n)]\n    for j in range(len(s)-1):\n        if not (s[j]+s[j+1]) % 2:\n            break\n    else:\n        A297710_list.append(n) \n"}
{"sequence_id": "A297815", "text": "Number of positive integers with n digits whose digit sum is equal to its digit product.", "sequence": "9,1,6,12,40,30,84,224,144,45,605,495,1170,1092,210,240,2448,4896,15846,3420,1750,462,15939,0,8100,67925,80730,19656,11774,164430,930,29760,197472,0,0,1260,23976,50616,54834,395200,1248860,4253340,75852,0,42570", "code": "\nfrom sympy.utilities.iterables import combinations_with_replacement\nfrom sympy import prod, factorial\ndef A297815(n):\n    f = factorial(n)\n    return sum(f//prod(factorial(d.count(a)) for a in set(d)) for d in combinations_with_replacement(range(1,10),n) if prod(d) == sum(d)) \n"}
{"sequence_id": "A297960", "text": "a(1) = number of 1-digit primes (that is, 4: 2,3,5,7); then a(n) = number of distinct n-digit prime numbers obtained by alternately right- and left-concatenating a digit to the a(n-1) primes obtained in the previous iteration.", "sequence": "4,9,30,49,99,74,101,71,72,35,28,9,4", "code": "\nfrom sympy import isprime\ndef alst():\n  primes, alst = [2, 3, 5, 7], []\n  while len(primes) > 0:\n    alst.append(len(primes))\n    if len(alst)%2 == 0:\n      candidates = set(int(d+str(p)) for p in primes for d in \"123456789\")\n    else:\n      candidates = set(int(str(p)+d) for p in primes for d in \"1379\")\n    primes = [c for c in candidates if isprime(c)]\n  return alst\nprint(alst()) \n"}
{"sequence_id": "A297961", "text": "a(1) = number of 1-digit primes (that is, 4: 2,3,5,7); then a(n) = number of distinct n-digit prime numbers obtained by alternately left- and right-concatenating a digit to the a(n-1) primes obtained in the previous iteration.", "sequence": "4,11,20,53,51,100,63,76,42,43,20,13,4,4,1", "code": "\nfrom sympy import isprime\ndef alst():\n  primes, alst = [2, 3, 5, 7], []\n  while len(primes) > 0:\n    alst.append(len(primes))\n    if len(alst)%2 == 1:\n      candidates = set(int(d+str(p)) for p in primes for d in \"123456789\")\n    else:\n      candidates = set(int(str(p)+d) for p in primes for d in \"1379\")\n    primes = [c for c in candidates if isprime(c)]\n  return alst\nprint(alst()) \n"}
{"sequence_id": "A298008", "text": "a(n) = f(n-1,n) + 10*(n-1), where f(a,b) is the number of primes in the range [10*a,10*b].", "sequence": "4,14,22,32,43,52,62,73,82,91,104,111,121,133,141,152,162,172,181,194,200,211,223,232,241,252,262,272,282,291,301,313,320,332,342,352,361,372,382,391,402,411,421,433,442,451,463,471,481,492,502,510,522,530,542,551,562,572,581,592,602,613,620,631,643", "code": "\n\nlast = 1000\np=[2]\nc=1\nfor i in range(3,last+2,2):\n    prime = True\n    for j in p:\n        if i%j == 0:\n            prime=False;\n            break;\n    if prime:\n        p.append(i)\n        c = c + 1\n    ii = (i//10)*10\n    if i-ii == 1:\n        if prime:\n            print(ii-10+c-1, end=',')\n            c = 1\n        else:\n            print(ii-10+c, end=',')\n            c = 0\n"}
{"sequence_id": "A298009", "text": "a(n) = f(n-1,n)+(n-1)*k, n>=1, where the function f(a,b) gives the number of prime numbers in the range [a*k,b*k[ with k=10^p. For this sequence we use p=2.", "sequence": "25,121,216,316,417,514,616,714,815,914,1016,1112,1215,1311,1417,1512,1615,1712,1812,1913,2014,2110,2215,2315,2410,2511,2615,2714,2812,2911,3012,3110,3211,3315,3411,3514,3613,3712,3811,3911,4015,4109,4216,4309,4411,4512,4612,4712,4808,4915", "code": "\n\nlast = 1000\np=[2]\nc=1\nfor i in range(3,last+2,2):\n    prime = True\n    for j in p:\n        if i%j == 0:\n            prime=False;\n            break\n    if prime:\n        p.append(i)\n        c = c + 1\n    ii = (i//100)*100\n    if i-ii == 1:\n        if prime:\n            print(ii-100+c-1, end=',')\n            c = 1\n        else:\n            print(ii-100+c, end=',')\n            c = 0\n"}
{"sequence_id": "A298048", "text": "a(1) = number of 1-digit primes (that is, 4: 2,3,5,7); then a(n) = number of distinct n-digit prime numbers obtained by left- or right-concatenating a digit to the a(n-1) primes obtained in the previous iteration.", "sequence": "4,16,70,243,638,1450,2819,4951,7629,10677,13267,15182,15923,15796,14369,12547,10291,7939,5703,3911,2559,1595,920,561,321,167,72,37,11,6,3", "code": "\nfrom sympy import isprime\ndef alst():\n  primes, alst = [2, 3, 5, 7], []\n  while len(primes) > 0:\n    alst.append(len(primes))\n    candidates = set(int(d+str(p)) for p in primes for d in \"123456789\")\n    candidates |= set(int(str(p)+d) for p in primes for d in \"1379\")\n    primes = [c for c in candidates if isprime(c)]\n  return alst\nprint(alst()) \n"}
{"sequence_id": "A298077", "text": "Oblong numbers that are the sum of 2 successive primes.", "sequence": "12,30,42,90,210,240,462,600,702,930,1482,1560,1722,2352,2862,2970,6162,6480,6642,7656,8010,8556,10920,13572,13806,14280,14762,15006,15750,16002,21462,22350,22650,23562,24492,25122,27060,27390,29070,29412,34410,34782", "code": "\nfrom __future__ import division\nfrom sympy import prevprime,nextprime,isprime\nA298077_list = [n*(n+1) for n in range(3,10**4) if prevprime(n*(n+1)//2) + nextprime(n*(n+1)//2) == n*(n+1)] \n"}
{"sequence_id": "A298312", "text": "The first of three consecutive octagonal numbers the sum of which is equal to the sum of three consecutive primes.", "sequence": "12160,74576,158240,181056,269400,371008,601216,606600,848008,980408,1242920,2075008,3292816,3680776,4477408,4685000,5627960,7505008,8263480,9289280,10397408,10419760,10735208,10757920,12726680,13000008,14200576,15426936,15700256", "code": "\nfrom __future__ import division\nfrom sympy import prevprime, nextprime\nA298312_list, n, m = [], 1, 30\nwhile len(A298312_list) < 10000:\n    k = prevprime(m//3)\n    k2 = nextprime(k)\n    if prevprime(k) + k + k2 == m or k + k2 + nextprime(k2) == m:\n        A298312_list.append(n*(3*n-2))\n    n += 1\n    m += 18*n + 3 \n"}
{"sequence_id": "A298313", "text": "The first of three consecutive primes the sum of which is equal to the sum of three consecutive octagonal numbers.", "sequence": "12541,75521,159617,182519,271181,373091,603901,609289,851197,983819,1246757,2079997,3299081,3687421,4484737,4692497,5636171,7514477,8273437,9299831,10408577,10430921,10746557,10769281,12739037,13012487,14213621,15440531,15713959", "code": "\nfrom __future__ import division\nfrom sympy import prevprime, nextprime\nA298313_list, n, m = [], 1, 30\nwhile len(A298313_list) < 10000:\n    k = prevprime(m//3)\n    k2 = prevprime(k)\n    k3 = nextprime(k)\n    if k2 + k + k3 == m:\n        A298313_list.append(k2)\n    elif k + k3 + nextprime(k3) == m:\n        A298313_list.append(k)\n    n += 1\n    m += 18*n + 3 \n"}
{"sequence_id": "A298356", "text": "a(n) = a(n-1) + a(n-2) + a([n/2]) + a([n/3]) + ... + a([n/n]), where a(0) = 1, a(1) = 1, a(2) = 1.", "sequence": "1,1,1,4,8,16,32,57,103,178,308,514,874,1441,2394,3926,6462,10531,17231,28001,45614,74026,120258,194903,316210,512171,830007,1343883,2176578,3523150,5704107,9231637,14942711,24181525,39135483,63328289,102482212,165828942", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A298356(n):\n    if n <= 2:\n        return 1\n    c, j = A298356(n-1)+A298356(n-2), 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A298356(k1)\n        j, k1 = j2, n//j2\n    return c+n-j+1 \n"}
{"sequence_id": "A298357", "text": "a(n) = a(n-1) + a(n-2) + a([n/2]) + a([n/3]) + ... + a([n/n]), where a(0) = 1, a(1) = 2, a(2) = 3.", "sequence": "1,2,3,9,19,37,74,131,238,410,710,1184,2014,3320,5516,9044,14888,24262,39698,64510,105089,170545,277057,449027,728502,1179967,1912216,3096110,5014519,8116824,13141430,21268343,34425826,55710704,90162442,145899135,236104060", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A298357(n):\n    if n <= 2:\n        return n+1\n    c, j = A298357(n-1)+A298357(n-2), 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A298357(k1)\n        j, k1 = j2, n//j2\n    return c+2*(n-j+1) \n"}
{"sequence_id": "A298369", "text": "a(n) = a(n-1) + a(n-2) + 2*a(floor(n/2)) + 3*a(floor(n/3)) + ... +  n*a(floor(n/n)), where a(0) = 1, a(1) = 1, a(2) = 1.", "sequence": "1,1,1,7,17,38,87,164,318,576,1040,1773,3134,5241,8877,14728,24579,40298,66585,108610,178004,289717,472312,766643,1247081,2021980,3281557,5316888,8619474,13957420,22611507,36603571,59270152,95931095,155290091,251310597", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A298369(n):\n    if n <= 2:\n        return 1\n    c, j = A298369(n-1)+A298369(n-2), 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2*(j2-1)-j*(j-1))*A298369(k1)//2\n        j, k1 = j2, n//j2\n    return c+(n*(n+1)-j*(j-1))//2 \n"}
{"sequence_id": "A298370", "text": "a(n) = a(n-1) + a(n-2) + 2 a(floor(n/2)) + 3 a(floor(n/3)) + ... +  n a(floor(n/n)), where a(0) = 1, a(1) = 2, a(2) = 3.", "sequence": "1,2,3,15,38,83,190,356,695,1254,2267,3861,6829,11417,19340,32076,53545,87784,145048,236589,387765,631106,1028866,1670013,2716595,4404599,7148426,11582096,18776334,30404300,49256015,79735758,129111774,208972513,338277831", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A298370(n):\n    if n <= 2:\n        return n+1\n    c, j = A298370(n-1)+A298370(n-2), 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2*(j2-1)-j*(j-1))*A298370(k1)//2\n        j, k1 = j2, n//j2\n    return c+2*(n*(n+1)-j*(j-1))//2 \n"}
{"sequence_id": "A298406", "text": "a(n) = 2*a(n-1) - a(n-3) + a(floor(n/2)) + a(floor(n/3)) + ... + a(floor(n/n)), where a(0) = 1, a(1) = 1, a(2) = 1.", "sequence": "1,1,1,3,8,19,42,84,163,301,547,961,1682,2879,4902,8241,13807,22917,37962,62487,102690,168096,274798,448000,729829,1186797,1928729,3130905,5080360,8237339,13352743,21634097,35045477,56753250,91896553,148771833,240830555", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A298406(n):\n    if n <= 2:\n        return 1\n    c, j = 2*A298406(n-1)-A298406(n-3), 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A298406(k1)\n        j, k1 = j2, n//j2\n    return c+n-j+1 \n"}
{"sequence_id": "A298407", "text": "a(n) = 2*a(n-1) - a(n-3) + a(floor(n/2)) + a(floor(n/3)) + ... + a(floor(n/n)), where a(0) = 1, a(1) = 2, a(2) = 3.", "sequence": "1,2,3,9,23,52,113,223,431,794,1442,2532,4433,7589,12924,21730,36411,60440,100125,164816,270863,443390,724846,1181713,1925113,3130488,5087530,8258585,13400782,21728136,35221342,57065559,92441545,149701409,242400952,392424193", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A298407(n):\n    if n <= 2:\n        return n+1\n    c, j = 2*A298407(n-1)-A298407(n-3), 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2-j)*A298407(k1)\n        j, k1 = j2, n//j2\n    return c+2*(n-j+1) \n"}
{"sequence_id": "A298408", "text": "a(n) = 2*a(n-1) - a(n-3) + 2*a(floor(n/2)) + 3*a(floor(n/3)) + ... + n*a(floor(n/n)), where a(0) = 1, a(1) = 1, a(2) = 1.", "sequence": "1,1,1,6,20,53,130,277,574,1115,2126,3862,7021,12341,21553,36957,63111,106224,178407,296638,492231,811731,1335994,2188950,3583027,5847108,9532980,15512342,25226123,40967842,66506422,107869832,174908573,283452771,459264017", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A298408(n):\n    if n <= 2:\n        return 1\n    c, j = 2*A298408(n-1)-A298408(n-3), 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2*(j2-1)-j*(j-1))*A298408(k1)//2\n        j, k1 = j2, n//j2\n    return c+(n*(n+1)-j*(j-1))//2 \n"}
{"sequence_id": "A298409", "text": "a(n) = 2*a(n-1) - a(n-3) + 2*a(floor(n/2)) + 3*a(floor(n/3)) + ... + n*a(floor(n/n)), where a(0) = 1, a(1) = 2, a(2) = 3.", "sequence": "1,2,3,15,48,123,300,635,1316,2555,4873,8850,16096,28296,49424,84749,144733,243607,409156,680308,1128889,1861633,3063978,5020133,8217296,13409702,21862824,35575784,57853195,93954953,152524643,247386674,401132014,650065133", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A298409(n):\n    if n <= 2:\n        return n+1\n    c, j = 2*A298409(n-1)-A298409(n-3), 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += (j2*(j2-1)-j*(j-1))*A298409(k1)//2\n        j, k1 = j2, n//j2\n    return c+2*(n*(n+1)-j*(j-1))//2 \n"}
{"sequence_id": "A298463", "text": "The first of two consecutive pentagonal numbers the sum of which is equal to the sum of two consecutive primes.", "sequence": "70,3577,10795,36895,55777,70525,78547,125137,178365,208507,258130,329707,349692,394497,438751,468442,478555,499105,619852,663005,753667,827702,877455,900550,1025480,1085876,1169092,1201090,1211852,1233520,1339065,1508512", "code": "\nfrom __future__ import division\nfrom sympy import prevprime, nextprime\nA298463_list, n, m = [], 1 ,6\nwhile len(A298463_list) < 10000:\n    k = prevprime(m//2)\n    if k + nextprime(k) == m:\n        A298463_list.append(n*(3*n-1)//2)\n    n += 1\n    m += 6*n-1 \n"}
{"sequence_id": "A298464", "text": "The first of two consecutive primes the sum of which is equal to the sum of two consecutive pentagonal numbers.", "sequence": "79,3643,10909,37123,56053,70849,78889,125551,178877,209063,258743,330409,350411,395261,439559,469279,479387,499969,620813,663997,754723,828811,878597,901709,1026709,1087147,1170397,1202429,1213189,1234873,1340477,1510013", "code": "\nfrom __future__ import division\nfrom sympy import prevprime, nextprime\nA298464_list, n, m = [], 1 ,6\nwhile len(A298464_list) < 10000:\n    k = prevprime(m//2)\n    if k + nextprime(k) == m:\n        A298464_list.append(k)\n    n += 1\n    m += 6*n-1 \n"}
{"sequence_id": "A298465", "text": "The first of two consecutive heptagonal numbers the sum of which is equal to the sum of two consecutive primes.", "sequence": "1,18,403,16281,24354,167314,172528,183196,191407,223054,413512,446688,476767,507826,512343,791578,926289,994456,1032658,1248562,1284147,2221708,2278630,2453716,2604571,2738952,2770443,3207523,3333330,4203577,4400332,4628761", "code": "\nfrom sympy import prevprime, nextprime\nA298465_list, n, m = [], 1 ,8\nwhile len(A298465_list) < 10000:\n    k = prevprime(m//2)\n    if k + nextprime(k) == m:\n        A298465_list.append(n*(5*n-3)//2)\n    n += 1\n    m += 10*n-3 \n"}
{"sequence_id": "A298466", "text": "The first of two consecutive primes the sum of which is equal to the sum of two consecutive heptagonal numbers.", "sequence": "3,23,433,16481,24593,167953,173183,183871,192097,223781,414521,447743,477857,508951,513473,792983,927803,996019,1034251,1250309,1285937,2224063,2281003,2456191,2607109,2741561,2773073,3210353,3336209,4206817,4403647,4632161", "code": "\nfrom sympy import prevprime, nextprime\nA298466_list, n, m = [], 1 ,8\nwhile len(A298466_list) < 10000:\n    k = prevprime(m//2)\n    if k + nextprime(k) == m:\n        A298466_list.append(k)\n    n += 1\n    m += 10*n-3 \n"}
{"sequence_id": "A298564", "text": "a(n) = (3^(n+2)+11)/2 - 5*2^(n+1) + 2*n.", "sequence": "0,1,10,53,218,789,2658,8581,26986,83477,255506,776709,2350554,7092565,21359554,64242437,193054922,579820053,1740770802,5224933765,15680044090,47050617941,141172825250,423560418693,1270765142058,3812463198229,11437725138898,34313846505221,102942881692826", "code": "\ndef A298564list(n):\n    def generator():\n        a, b, c = 5, 3, 0\n        while True:\n            yield c\n            a *= 2\n            b *= 3\n            c += 2 - a + b\n    a = generator()\n    return [next(a) for _ in range(n)]\nprint(A298564list(29)) \n"}
{"sequence_id": "A298565", "text": "a(n) is the largest prime p congruent to 1 mod n such that the multiplicative subgroup H of (Z/pZ)* of index n contains no nontrivial mod-p arithmetic progression of length 3.", "sequence": "7,19,37,31,127,197,97,181,191,463,421,937,337,1321,881,2347,3889,2699,1861,1009,2861,1979,3793,1951,2861,3889,1933,1973,4831,1861,7393,8053,8297,5881,8209,3257,7753,17551,7841,6971,16843,16943,15401,12781,17573,41549,12097", "code": " see links.\n"}
{"sequence_id": "A298684", "text": "Numbers i such that Fibonacci(i) is divisible by i, i+1, and i+2.", "sequence": "60,540,660,1200,1320,1620,2160,3060,5580,6120,6600,6720,8100,9180,9240,9600,9720,9900,11160,12240,12300,12600,13200,13440,13680,15120,15360,18300,18480,19440,19800,21000,22500,24480,24840,26880,27360,28920,29400,30240,30780", "code": "\nfrom __future__ import division\nA298684_list, n, a, b = [], 1, 1, 1\nwhile len(A298684_list) < 1000:\n    if not (a % (n*(n+1)*(n+2)//(1 if n % 2 else 2))):\n        A298684_list.append(n)\n    n += 1\n    a, b = b, a+b \n"}
{"sequence_id": "A298687", "text": "Numbers i such that Fibonacci(i) is divisible by i+k for k=0..5.", "sequence": "13440,19440,329400,600600,2499840,3150840,5590200,7660800,69069000,83980800,96049800,98385840,175472640,179663400,237484800,320498640,330663600,375396840,404351640,406380240,429660000,437940000,505234800,574585200,635980800", "code": "\np0 = 0\np1 = 1\nfor i in range(1,1000000):\n  if p1 % i == 0 and p1 % (i+1) == 0 and p1 % (i+2) == 0:\n     if p1 % (i+3) == 0 and p1 % (i+4) == 0 and p1 % (i+5) == 0:  print i\n  p0, p1 = p1, p0+p1\n"}
{"sequence_id": "A298816", "text": "a(n) is the binary XOR of all n-bit squares, with a(2)=0 indicating that no 2-bit squares exist.", "sequence": "1,0,4,9,9,21,12,28,449,577,357,997,6085,14533,12517,15077,121125,152869,400028,1041052,1290704,2556368,4913664,11950592,22421376,63692672,7674753,78355329,312723717,656197893,1089399836,2723474460,4196236289,2416016385,8186515468", "code": "\ni = n = x = L = 1\nwhile L < 47:\n    i+=1\n    nextn = i*i\n    if (nextn ^ n) > n:  \n        print str(x)+',',\n        x = 0\n        prevL = L\n        L = len(bin(nextn))-2\n        for j in range(prevL, L-1):  print '0,',\n    n = nextn\n    x ^= n\n"}
{"sequence_id": "A298817", "text": "a(n) is the binary XOR of all n-bit prime numbers.", "sequence": "0,1,2,6,23,59,99,203,469,807,1615,3349,2266,4576,14042,25002,89193,131215,135904,814531,885682,60842,3969154,3370892,6742296,14350136,42766902,97565102,444197631,515121776,2085329975,2091732354,7999937231,14794305847", "code": "\nfrom sympy import nextprime\nn = x = L = 2\nprint('0', end=',')\nwhile L < 27:\n    nextn = nextprime(n)\n    if (nextn ^ n) > n:  \n        print(str(x), end=',')\n        x = 0\n        prevL = L\n        L = len(bin(nextn))-2\n        for j in range(prevL, L-1):  print('0', end=',')\n    n = nextn\n    x ^= n\n"}
{"sequence_id": "A298818", "text": "a(n) is the binary XOR of all n-bit triangular numbers.", "sequence": "1,3,6,5,9,62,70,204,348,586,1770,3582,6974,9046,22486,12225,54977,97140,201076,34728,347048,1031920,2250480,10857648,24157360,40826080,112612576,21772545,130349313,1060428174,1126848910,1106260993,2017932289,3773334644,13412500596,6378289192,37614057512", "code": "\ni = n = x = L = 1\nwhile L < 47:\n    i+=1\n    nextn = i*(i+1)/2\n    if (nextn ^ n) > n:\n        print str(x)+',',\n        x = 0\n        prevL = L\n        L = len(bin(nextn))-2\n        for j in range(prevL, L-1):  print '0,',\n    n = nextn\n    x ^= n\n"}
{"sequence_id": "A298827", "text": "a(n) is the smallest positive integer k such that 3^n+2 divides 3^(n+k)+2.", "sequence": "4,5,28,41,84,336,990,193,1260,5905,75918,10065,318860,2391485,14348908,20390382,5031420,31624326,5985168,1743333144,8569036,668070480,547062516,141214768241,167874004756,1270932914165,385131186110,2837770056420,784347169884,475536631360,149093578413164,139370386996590", "code": "\ndef fmod(n, mod):\n....return (pow(3, n, mod) + 2) % mod\ndef f(n):\n....return pow(3, n) + 2\n\nterms = 20\nfor x in range(1,terms + 1):\n....div = f(x)\n....y = x + 1\n....while fmod(y, div) != 0:\n........y += 1\n....print(y - x)\n"}
{"sequence_id": "A298827", "text": "a(n) is the smallest positive integer k such that 3^n+2 divides 3^(n+k)+2.", "sequence": "4,5,28,41,84,336,990,193,1260,5905,75918,10065,318860,2391485,14348908,20390382,5031420,31624326,5985168,1743333144,8569036,668070480,547062516,141214768241,167874004756,1270932914165,385131186110,2837770056420,784347169884,475536631360,149093578413164,139370386996590", "code": "\nfrom sympy import n_order\ndef A298827(n):\n    return n_order(3,3**n+2) \n"}
{"sequence_id": "A298940", "text": "a(n) is the smallest positive integer k such that 3^n - 2 divides 3^(n + k) + 2, or 0 if there is no such k.", "sequence": "1,3,10,39,60,121,0,117,4920,0,0,0,28322,0,1434890,0,0,0,116226146,0,0,15690529803,0,108443565,66891206007,0,0,0,0,0,0,0,0,0,0,0,22514195294549868,0,405255515301897626,0,1823649818858539320,0,0,5861731560616733529,0,0,0", "code": "\nfrom sympy import discrete_log\ndef A298940(n):\n    if n == 1:\n        return 1\n    try:\n        return discrete_log(3**n-2,-1,3)\n    except ValueError:\n        return 0 \n"}
{"sequence_id": "A298946", "text": "a(n) = binomial(2*c-1, c-1) (mod c^4), where c is the n-th composite number.", "sequence": "35,462,2339,4627,2378,4238,5148,1260,57635,85026,64410,100509,163716,171918,93876,309780,148969,444220,370712,532771,652200,938386,816466,907874,569300,1107298,2470810,2953692,887812,1341810,2956584,1941390,589961,6248628", "code": "\nfrom sympy import binomial, composite\ndef A298946(n):\n    c = composite(n)\n    return binomial(2*c-1,c-1) % c**4 \n"}
{"sequence_id": "A298950", "text": "Numbers k such that 5*k - 4 is a square.", "sequence": "1,4,8,17,25,40,52,73,89,116,136,169,193,232,260,305,337,388,424,481,521,584,628,697,745,820,872,953,1009,1096,1156,1249,1313,1412,1480,1585,1657,1768,1844,1961,2041,2164,2248,2377,2465,2600,2692,2833,2929,3076,3176,3329,3433", "code": " [(10*n*(n-1)+(2*n-1)*(-1)**n+9)/8 for n in range(1, 60)]\n"}
{"sequence_id": "A298991", "text": "Indices i in A112058 where records of 17*i - 3*A112058(i)/8 occur.", "sequence": "2,5,13,21,24,32,40,43,51,1470,1478,2701,12032,12040,12048,12051,12059,12067,12070,12078,13301,14524,14683,14691,14699,14702,14710,14718,14721,14729", "code": "\ni, n, rec = 0, 0, 0\nwhile n < 1000:\n....i = i+1\n....if 17*i-3*A112058(i)//8 > rec:\n........n, rec = n+1, 17*i-3*A112058(i)//8\n........print(n,i)\n"}
{"sequence_id": "A299038", "text": "Number A(n,k) of rooted trees with n nodes where each node has at most k children; square array A(n,k), n>=0, k>=0, read by antidiagonals.", "sequence": "1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,2,1,0,1,1,1,2,3,1,0,1,1,1,2,4,6,1,0,1,1,1,2,4,8,11,1,0,1,1,1,2,4,9,17,23,1,0,1,1,1,2,4,9,19,39,46,1,0,1,1,1,2,4,9,20,45,89,98,1,0,1,1,1,2,4,9,20,47,106,211,207,1,0", "code": "\nfrom sympy import binomial\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n, i, t, k): return 1 if n==0 else 0 if i<1 else sum([binomial(b(i-1, i-1, k, k)+j-1, j)*b(n-i*j, i-1, t-j, k) for j in range(min(t, n//i)+1)])\ndef A(n, k): return 1 if n==0 else b(n-1, n-1, k, k)\nfor d in range(15): print([A(n, d-n) for n in range(d+1)]) \n"}
{"sequence_id": "A299098", "text": "Number of rooted identity trees with 2n nodes.", "sequence": "0,1,2,6,25,113,548,2770,14426,76851,416848,2294224,12780394,71924647,408310668,2335443077,13446130438,77863375126,453203435319,2649957419351,15558520126830,91687179000949,542139459641933,3215484006733932,19125017153077911", "code": "\nfrom sympy import divisors\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n): return n if n<2 else sum([b(n-k)*sum([b(d)*d*(-1)**(k//d+1) for d in divisors(k)]) for k in range(1, n)])//(n-1)\ndef a(n): return b(2*n)\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A299113", "text": "Number of rooted identity trees with 2n+1 nodes.", "sequence": "1,1,3,12,52,247,1226,6299,33209,178618,976296,5407384,30283120,171196956,975662480,5599508648,32334837886,187737500013,1095295264857,6417886638389,37752602033079,222861754454841,1319834477009635,7839314017612273,46688045740233741", "code": "\nfrom sympy import divisors\nfrom sympy.core.cache import cacheit\n@cacheit\ndef b(n): return n if n<2 else sum([b(n-k)*sum([b(d)*d*(-1)**(k//d+1) for d in divisors(k)]) for k in range(1, n)])//(n-1)\ndef a(n): return b(2*n+1)\nprint([a(n) for n in range(31)]) \n"}
{"sequence_id": "A299144", "text": "a(n) is the least i such that gcd(Fibonacci(i), i+x) > 1 for all x=0..n.", "sequence": "5,10,18,30,30,30,30,180,180,180,180,840,840,1260,1260,1260,1260,24480,24480,63000,63000,63000,63000,63000,63000,63000,63000,63000,63000,356400,356400,356400,356400,356400,356400,356400,356400,5783400,5783400,5783400,5783400,5783400,5783400", "code": "\np0=0\np1=1\ndef GCD(x,y):\n    tmp = y\n    y = x % y\n    if y==0: return tmp\n    return GCD(tmp, y)\nn=0\nfor i in range(1,1000000):\n    p0,p1 = p1, p0+p1\n    for x in range(1000000):\n        if GCD(p0,i+x)==1: break\n    for j in range(n, x):\n        print i\n    if x>n: n=x\n"}
{"sequence_id": "A299300", "text": "Values of k such that A065358(k-1) = 0.", "sequence": "1,3,7,35,39,43,51,55,79,87,91,107,111,115,835,843,1391,1407,1411,1471,1579,1587,1651,1663,1843,1851,3383,3491,3507,3515,3519,3547,3659,3691,3719,3747,3779,3819,3823,3843,3851,3855,3871,3899,3939,3947,3987,3991", "code": "\nfrom sympy import nextprime\nA299300_list, p, d, n, r = [], 2, -1, 0, False\nwhile n <= 10**6:\n    pn, k = p-n, d if r else -d\n    if 0 < k <= pn:\n        A299300_list.append(n+k)\n    d += -pn if r else pn\n    r, n, p = not r, p, nextprime(p) \n"}
{"sequence_id": "A299415", "text": "Number of steps of iterating z -> z^2 + c with c = 1/4 + 10^(-n) to reach z > 2, starting with z = 0.", "sequence": "2,8,30,97,312,991,3140,9933,31414,99344,314157,993457,3141591,9934586,31415925", "code": " A299415 = lambda n: A332061(10**n) \\\\ Warning: may give incorrect result for default (double) precision for n >= 12. -  _M. F. Hasler_, Feb 22 2020\n"}
{"sequence_id": "A299474", "text": "a(n) = 4*p(n), where p(n) is the number of partitions of n.", "sequence": "4,4,8,12,20,28,44,60,88,120,168,224,308,404,540,704,924,1188,1540,1960,2508,3168,4008,5020,6300,7832,9744,12040,14872,18260,22416,27368,33396,40572,49240,59532,71908,86548,104060,124740,149352,178332,212696,253044,300700,356536,422232,499016,589092,694100,816904", "code": "\nfrom sympy.ntheory import npartitions\ndef a(n): return 4*npartitions(n)\nprint([a(n) for n in range(51)]) \n"}
{"sequence_id": "A299504", "text": "Triangle read by rows, T(n,k) = (k+1)^(n-k)*k! for 0 <= k <= n.", "sequence": "1,1,1,1,2,2,1,4,6,6,1,8,18,24,24,1,16,54,96,120,120,1,32,162,384,600,720,720,1,64,486,1536,3000,4320,5040,5040,1,128,1458,6144,15000,25920,35280,40320,40320,1,256,4374,24576,75000,155520,246960,322560,362880,362880", "code": "\nfrom sympy import factorial\ndef T(n, k): return (k+1)**(n-k)*factorial(k)\nfor n in range(21): print([T(n, k) for k in range(n+1)]) \n"}
{"sequence_id": "A299645", "text": "Numbers of the form m*(8*m + 5), where m is an integer.", "sequence": "0,3,13,22,42,57,87,108,148,175,225,258,318,357,427,472,552,603,693,750,850,913,1023,1092,1212,1287,1417,1498,1638,1725,1875,1968,2128,2227,2397,2502,2682,2793,2983,3100,3300,3423,3633,3762,3982,4117,4347,4488,4728,4875", "code": " [(8*n*(n-1)-(2*n-1)*(-1)**n-1)/4 for n in range(1, 60)]\n"}
{"sequence_id": "A299647", "text": "Positive solutions to x^2 == -2 (mod 11).", "sequence": "3,8,14,19,25,30,36,41,47,52,58,63,69,74,80,85,91,96,102,107,113,118,124,129,135,140,146,151,157,162,168,173,179,184,190,195,201,206,212,217,223,228,234,239,245,250,256,261,267,272,278,283,289,294,300,305,311,316", "code": " [5*n-2+(2*n-(-1)**n-3)/4 for n in range(1, 60)]\n"}
{"sequence_id": "A299731", "text": "Number of partitions of 3*n that have exactly n prime parts.", "sequence": "1,2,3,5,8,12,18,25,35,50,69,93,126,167,220,290,377,486,627,800,1017,1290,1623,2032,2542,3161,3917,4843,5960,7312,8957,10925,13291,16139,19534,23588,28437,34180,41000,49099,58657,69941,83269,98917,117314,138930", "code": " See Stauduhar link.\n"}
{"sequence_id": "A300000", "text": "The sum of the first n terms of the sequence is the concatenation of the first n digits of the sequence, with a(1) = 1.", "sequence": "1,10,99,999,9990,99900,999000,9990000,99900000,999000000,9990000000,99899999991,998999999919,9989999999190,99899999991900,998999999918991,9989999999189910,99899999991899109,998999999918991090,9989999999189910900,99899999991899108991,998999999918991089910,9989999999189910899100", "code": "\ndef a(n):\n    alist, c, ckm1 = [1, 10], \"110\", 11\n    for k in range(3, n+1):\n        ck = 10*ckm1 + int(c[k-1])\n        ak, ckm1 = ck - ckm1, ck\n        c += str(ak)\n        alist.append(ak)\n    return alist[n-1]\nprint([a(n) for n in range(1, 24)]) \n"}
{"sequence_id": "A300062", "text": "a(1) = 1, a(n) = the smallest integer > a(n-1) such that Sum_{k=1..n} a(k) written in decimal contains decimal n as a substring.", "sequence": "1,11,18,19,26,31,41,42,50,71,101,201,301,401,501,601,701,801,901,1001,1101,1201,1301,1401,1426,1476,1501,1601,1701,1771,1831,1901,2001,2101,2201,2301,2401,2501,2601,2701,2801,2901,3001,3101,3201,3301,3324,3378,3401", "code": "\nA300062_list, s, j = [1], 1, 1\nfor i in range(2,10001):\n    j, si = j + 1, str(i)\n    while si not in str(s+j):\n        j += 1\n    A300062_list.append(j)\n    s += j\n"}
{"sequence_id": "A300078", "text": "Number of steps of iterating 0 under z^2 + c before escaping, i.e., abs(z^2 + c) > 2, with c = -5/4 - epsilon^2 + epsilon*i, where epsilon = 10^(-n) and i^2 = -1.", "sequence": "1,18,159,1586,15731,157085,1570800,15707976", "code": "\nfrom fractions import Fraction\ndef A300078(n):\n    zr, zc, c = Fraction(0,1), Fraction(0,1), 0\n    cr, cc = Fraction(-5,4)-Fraction(1,10**(2*n)), Fraction(1,10**n)\n    zr2, zc2 = zr**2, zc**2\n    while zr2 + zc2 <= 4:\n        zr, zc = zr2 - zc2 + cr, 2*zr*zc + cc\n        zr2, zc2 = zr**2, zc**2\n        c += 1\n    return c \n"}
{"sequence_id": "A300254", "text": "a(n) = 25*(n + 1)*(4*n + 3)*(5*n + 4)/3.", "sequence": "100,1050,3850,9500,19000,33350,53550,80600,115500,159250,212850,277300,353600,442750,545750,663600,797300,947850,1116250,1303500,1510600,1738550,1988350,2261000,2557500,2878850,3226050,3600100,4002000,4432750,4893350,5384800,5908100,6464250", "code": " [25*(n+1)*(4*n+3)*(5*n+4)/3 for n in range(40)]\n"}
{"sequence_id": "A300392", "text": "a(1)=1, a(n) = max(sum0,sum1) mod n, where sum0 is the sum of previous terms with even indices, sum1 with odd indices.", "sequence": "1,1,1,2,3,5,1,0,8,4,3,5,4,7,9,14,4,2,2,0,19,11,9,16,17,3,0,25,8,5,7,4,5,2,1,34,29,26,10,6,8,4,4,0,41,10,6,8,4,4,0,48,34,30,1,52,43,38,12,6,6,0,57,52,34,28,50,44,13,6,5,70,61,54,26,18,28", "code": "\na = [1]\ns0 = 0\ns1 = 1\nfor n in range(2,1000):\n    v = max(s1, s0) % n\n    a.append(v)\n    if n&1:  s1 += v\n    else:    s0 += v\nprint(a)\n"}
{"sequence_id": "A300522", "text": "a(n) = (5*n + 3)*(5*n + 4)*(5*n + 5)/6.", "sequence": "10,120,455,1140,2300,4060,6545,9880,14190,19600,26235,34220,43680,54740,67525,82160,98770,117480,138415,161700,187460,215820,246905,280840,317750,357760,400995,447580,497640,551300,608685,669920,735130,804440,877975,955860,1038220,1125180", "code": " [(5*n+3)*(5*n+4)*(5*n+5)/6 for n in range(40)]\n"}
{"sequence_id": "A300523", "text": "a(n) = (5*n + 5)*(5*n + 6)*(5*n + 7)/6.", "sequence": "35,220,680,1540,2925,4960,7770,11480,16215,22100,29260,37820,47905,59640,73150,88560,105995,125580,147440,171700,198485,227920,260130,295240,333375,374660,419220,467180,518665,573800,632710,695520,762355,833340,908600,988260,1072445", "code": " [(5*n+5)*(5*n+6)*(5*n+7)/6 for n in range(40)]\n"}
{"sequence_id": "A300730", "text": "Positive integers j of the form Sum_{i=1..k} b(i)c(i), i.e., not in A297345 such that there is only one set {c(1),...,c(k)} where the c(i) are drawn with repetition from {b(0),...,b(k)} and b(k+1) is the smallest element of A297345 that is larger than j, where b() is A297345.", "sequence": "3,5,6,8,10,12,13,17,19,20,22,27,32,34,36,37,41,43,44,46,61,67,68,82,84,91,95,107,119,126,129,131,153,167,204,211,214,252,261,416,452,489,499,537,6006,6265,6266,6312,190852,207403,208524,208806,211967,213074,213594,213677,214781,215042,215075,215077", "code": "\n\nimport numpy as np\nimport itertools\ndef g(i,s,perms):\n   c = 0\n   for iks in perms:\n       t=np.asarray(iks)\n       if np.dot(t,s) == i:\n           c += 1\n       if c == 2:\n           break\n   if c == 1:\n       print i\nS=[1, 2, 7,24,85,285,1143]\nS1=[0,1, 2, 7,24,85,285,1143]\nperms = [p for p in itertools.product(S1, repeat=len(S))]\ns=np.asarray(S,dtype=np.int)\nfor i in range(1,6268):\n   if i not in S:\n       g(i,s,perms)\n"}
{"sequence_id": "A300782", "text": "Number of symmetrically distinct sublattices (supercells, superlattices, HNFs) of the simple cubic lattice of index n.", "sequence": "1,3,3,9,5,13,7,24,14,23,11,49,15,33,31,66,21,70,25,89,49,61,33,162,50,81,75,137,49,177,55,193,97,123,99,296,75,147,129,312,89,291,97,269,218,203,113,534,146,302,203,357,141,451,207,508,247,307,171,789", "code": "\n\ndef a(n): \n    return (dc(u, N, N2)(n) + 6*dc(fin(1, -1, 0, 4), u, u, N)(n)\n      + 3*dc(fin(1, 3), u, u, N)(n)\n      + 8*dc(fin(1, 0, -1, 0, 0, 0, 0, 0, 3), u, u, per(0, 1, -1))(n)\n      + 6*dc(fin(1, 1), u, u, per(0, 1, 0, -1))(n))//24\nprint([a(n) for n in range(1, 300)])\n\n"}
{"sequence_id": "A300783", "text": "Number of symmetrically distinct sublattices (supercells, superlattices, HNFs) of the 3D hexagonal lattice of index n.", "sequence": "1,3,5,11,7,19,11,34,23,33,19,77,25,53,55,104,37,115,45,143,91,105,61,272,90,139,137,235,91,309,103,331,183,219,185,516,141,267,245,544,169,529,185,485,411,375,217,952,278,550,389,647,271,829,397,922,477", "code": "\n\ndef a(n):\n    return (dc(u, N, N2)(n) + 6*dc(fin(1, -1, 0, 4), u, u, N)(n)\n            + dc(fin(1, 3), u, u, N)(n)\n            + 4*dc(fin(1, 0, 1), u, u, per(0, 1, -1))(n)) // 12\nprint([a(n) for n in range(1, 100)])\n\n"}
{"sequence_id": "A300784", "text": "Number of symmetrically distinct sublattices (supercells, superlattices, HNFs) of the tetragonal lattice of index n.", "sequence": "1,5,5,17,9,29,13,51,28,53,25,115,33,81,73,153,51,176,61,219,121,161,85,403,126,213,188,353,129,473,145,487,257,335,261,776,201,405,345,815,243,801,265,731,584,569,313,1407,398,838,559,975,393,1256,573,1375", "code": "\n\ndef a(n):\n    return (dc(u, N, N2)(n) + 2*dc(fin(1, -1, 0, 4), u, u, N)(n)\n      + 3*dc(fin(1, 3), u, u, N)(n)\n      + 2*dc(fin(1, 1), u, u, per(0, 1, 0, -1))(n)) // 8\nprint([a(n) for n in range(1, 300)])\n\n"}
{"sequence_id": "A300817", "text": "Smallest prime p such that p + n^2 is prime, or 0 if no such prime exists.", "sequence": "2,2,3,2,3,0,5,0,3,2,3,0,5,0,3,2,7,0,7,0,19,2,3,0,11,0,7,0,3,0,7,0,7,2,7,0,5,0,3,2,7,0,13,0,13,2,13,0,5,0,3,0,3,0,11,0,31,2,7,0,7,0,3,0,3,0,7,0,13,0,3,0,5,0,3,0,3,0,5,0,73,2,13,0,13,0,37,0,13,0", "code": "\nfrom sympy import nextprime, isprime\ndef A300817(n):\n    p, n2 = 2, n**2\n    if n % 2:\n        return 2 if isprime(2+n2) else 0\n    while not isprime(p+n2):\n        p = nextprime(p)\n    return p \n"}
{"sequence_id": "A300902", "text": "a(n) = n! / Product_{p prime < n}.", "sequence": "1,1,2,3,4,20,24,168,192,1728,17280,190080,207360,2695680,2903040,43545600,696729600,11844403200,12541132800,238281523200,250822656000,5267275776000,115880067072000,2665241542656000,2781121609728000,69528040243200000,1807729046323200000", "code": "\nfrom __future__ import division\nfrom sympy import isprime\nA300902_list, m = [1], 1\nfor n in range(1,501):\n    m *= n\n    A300902_list.append(m)\n    if isprime(n):\n        m //= n \n"}
{"sequence_id": "A301273", "text": "Numerator of mean of first n primes.", "sequence": "2,5,10,17,28,41,58,77,100,129,160,197,238,281,328,381,440,167,568,639,712,791,38,321,212,1161,1264,1371,1480,531,1720,1851,1988,2127,2276,809,2584,2747,2914,3087,3266,1149,3638,3831,4028,4227,4438,4661", "code": "\nfrom fractions import Fraction\nfrom sympy import prime\nA301273_list, mu = [], Fraction(0)\nfor i in range(1,10001):\n    mu += (prime(i)-mu)/i\n    A301273_list.append(mu.numerator) \n"}
{"sequence_id": "A301274", "text": "Denominator of mean of first n primes.", "sequence": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,6,19,20,21,22,1,8,5,26,27,28,29,10,31,32,33,34,35,12,37,38,39,40,41,14,43,44,45,46,47,48,49,50,51,52,1,18,55,8,19,58,59,60,61,62,9,64,65,66,67,68,69", "code": "\nfrom fractions import Fraction\nfrom sympy import prime\nA301274_list, mu = [], Fraction(0)\nfor i in range(1, 10001):\n    mu += (prime(i)-mu)/i\n    A301274_list.append(mu.denominator) \n"}
{"sequence_id": "A301275", "text": "Numerator of variance of first n primes.", "sequence": "0,1,7,59,64,581,649,2287,1001,2443,5669,17915,6665,36637,3529,22413,22813,13065,75865,191819,58778,289013,7627,141973,5213,628001,370333,96211,249436,381167,672727,1565639,453767,691587,1194917,301867,770294", "code": "\nfrom fractions import Fraction\nfrom sympy import prime\nmu, variance = Fraction(prime(1)), Fraction(0)\nA301275_list = [variance.numerator]\nfor i in range(2,10001):\n    datapoint = prime(i)\n    newmu = mu+(datapoint-mu)/i\n    variance = (variance*(i-2) + (datapoint-mu)*(datapoint-newmu))/(i-1)\n    mu = newmu\n    A301275_list.append(variance.numerator) \n"}
{"sequence_id": "A301276", "text": "Denominator of variance of first n primes.", "sequence": "1,2,3,12,5,30,21,56,18,30,55,132,39,182,15,80,68,34,171,380,105,462,11,184,6,650,351,84,203,290,465,992,264,374,595,140,333,1406,741,520,205,574,903,1892,495,230,1081,2256,588,2450,1275,884,13,318,1485", "code": "\nfrom fractions import Fraction\nfrom sympy import prime\nmu, variance = Fraction(prime(1)), Fraction(0)\nA301276_list = [variance.denominator]\nfor i in range(2,10001):\n    datapoint = prime(i)\n    newmu = mu+(datapoint-mu)/i\n    variance = (variance*(i-2) + (datapoint-mu)*(datapoint-newmu))/(i-1)\n    mu = newmu\n    A301275_list.append(variance.denominator) \n"}
{"sequence_id": "A301278", "text": "Numerator of variance of n-th row of Pascal's triangle.", "sequence": "0,0,1,4,47,244,1186,1384,25147,112028,98374,1067720,1531401,39249768,166656772,88008656,2961699667,12412521388,51854046982,108006842264,448816369361,3721813363288,15401045060572,15904199160592,131178778841711,1080387930269464,4443100381114156,9124976352166288", "code": "\nfrom fractions import Fraction\nfrom sympy import binomial\ndef A301278(n):\n    return (Fraction(int(binomial(2*n,n)))/n - Fraction(4**n)/(n*(n+1))).numerator if n > 0 else 0 \n"}
{"sequence_id": "A301279", "text": "Denominator of variance of n-th row of Pascal's triangle.", "sequence": "1,1,3,3,10,15,21,7,36,45,11,33,13,91,105,15,136,153,171,95,105,231,253,69,150,325,351,189,203,435,155,31,528,51,595,315,111,703,741,195,410,861,903,473,495,1035,1081,141,588,1225,255,663,689,1431,1485", "code": "\nfrom fractions import Fraction\nfrom sympy import binomial\ndef A301279(n):\n    return (Fraction(int(binomial(2*n,n)))/n - Fraction(4**n)/(n*(n+1))).denominator if n > 0 else 1 \n"}
{"sequence_id": "A301336", "text": "a(n) = total number of 1's minus total number of 0's in binary expansions of 0, ..., n.", "sequence": "-1,0,0,2,1,2,3,6,4,4,4,6,6,8,10,14,11,10,9,10,9,10,11,14,13,14,15,18,19,22,25,30,26,24,22,22,20,20,20,22,20,20,20,22,22,24,26,30,28,28,28,30,30,32,34,38,38,40,42,46,48,52,56,62,57,54,51,50,47,46,45,46,43,42,41,42", "code": "\ndef A301336(n):\n    return sum(2*bin(i).count('1')-len(bin(i))+2 for i in range(n+1)) \n"}
{"sequence_id": "A301451", "text": "Numbers congruent to {1, 7} mod 9.", "sequence": "1,7,10,16,19,25,28,34,37,43,46,52,55,61,64,70,73,79,82,88,91,97,100,106,109,115,118,124,127,133,136,142,145,151,154,160,163,169,172,178,181,187,190,196,199,205,208,214,217,223,226,232,235,241,244,250,253,259,262,268", "code": " [2*(2*n-1)+(2*n-3*(1-(-1)**n))/4 for n in range(1,70)]\n"}
{"sequence_id": "A301482", "text": "Composite numbers whose sum of aliquot parts divide the sum of the squares of their aliquot parts.", "sequence": "8,22,27,32,77,125,128,243,343,494,512,611,660,1073,1281,1331,1425,2033,2048,2187,2197,2332,3125,4172,4565,4913,5293,6031,6859,8192,9983,12167,13969,15818,15947,16807,17485,19683,23489,23840,24389,25241,25389,29791,32768", "code": "\nfrom sympy import divisors\ndef ok(n):\n    divs = divisors(n)[:-1]\n    return len(divs) > 1 and sum(d**2 for d in divs)%sum(divs) == 0\nprint(list(filter(ok, range(4, 32769)))) \n"}
{"sequence_id": "A301631", "text": "Numerator of population variance of n-th row of Pascal's triangle.", "sequence": "0,0,2,1,94,122,2372,173,50294,56014,983740,266930,18376812,19624884,333313544,5500541,5923399334,6206260694,103708093964,27001710566,1795265477444,1860906681644,30802090121144,1988024895074,524715115366844,540193965134732,8886200762228312", "code": "\nfrom fractions import Fraction\nfrom sympy import binomial\ndef A301631(n):\n    return (Fraction(int(binomial(2*n,n)))/(n+1) - Fraction(4**n)/(n+1)**2).numerator\n"}
{"sequence_id": "A301738", "text": "a(n) is the least A for which there exists B with 0 < B < A so that (A^(2^n) + B^(2^n))/2 is prime.", "sequence": "3,3,3,5,3,3,3,49,7,35,67,75,157,107,71,137,275,531", "code": "\nfrom sympy import isprime\ndef a(n):\n  A, p, Ap = 3, 2**n, 3**(2**n)\n  while True:\n    if any(isprime((Ap + B**p)//2) for B in range(1, A, 2)): return A\n    A += 2; Ap = A**p\nprint([a(n) for n in range(10)]) \n"}
{"sequence_id": "A301861", "text": "a(n) is the sum of the decimal digits of (n!)!.", "sequence": "1,1,2,9,81,783,7164,69048,711009,7961040,95935761,1242436185,17235507996", "code": "\nfrom math import factorial\ndef A301861(n):\n    return sum(int(d) for d in str(factorial(factorial(n)))) \n\nfrom gmpy2 import mpz, digits, fac\ndef A301861(n): return int(sum(mpz(d) for d in digits(fac(fac(n))))) \n"}
{"sequence_id": "A301912", "text": "Numbers k such that the decimal representation of k ends that of the sum of the first k cubes.", "sequence": "0,1,5,25,76,376,500,625,876,1876,2500,5001,5625,9376,15625,25001,40625,50001,62500,65625,71876,75001,90625,109376,171876,265625,375001,390625,500001,765625,875001,890625,1171876,2265625,2890625,4062500,4375001,5000001", "code": "\nA301912_list, k, n = [], 1, 1\nwhile len(A301912_list) < 100:\n    if n % 10**(len(str(k))) == k:\n        A301912_list.append(k)\n    k += 1\n    n += k**3 \n"}
{"sequence_id": "A301943", "text": "Number of primes of the form b^2+1 for b <= 10^n that end in 1.", "sequence": "1,4,42,279,2236,18155,152020,1317648,11634451,104116591,942191087", "code": "\nfrom sympy import isprime\ndef A301943(n):\n    return sum(1 for i in range(1,10**(n-1)+1) if isprime(100*i**2+1)) \n"}
{"sequence_id": "A302021", "text": "Numbers k such that k^2+1, (k+2)^2+1 and (k+6)^2+1 are prime.", "sequence": "4,14,124,204,464,1144,1314,1564,1964,2454,3134,4174,4364,5584,5874,6234,7804,8174,8784,9874,9894,10424,12354,12484,12874,14034,14194,15674,16224,18274,18994,21134,21344,22344,22624,23134,23784,23944,24974,25554,26504,26934,27064,27804,29364", "code": "\nfrom python import isprime\nk, klist, A302021_list = 0, [isprime(i**2+1) for i in range(6)], []\nwhile len(A302021_list) < 10000:\n    i = isprime((k+6)**2+1)\n    if klist[0] and klist[2] and i:\n        A302021_list.append(k)\n    k += 1\n    klist = klist[1:] + [i] \n"}
{"sequence_id": "A302087", "text": "Numbers k such that k^2+1 and (k+6)^2+1 are both prime.", "sequence": "4,10,14,20,84,110,120,124,150,170,204,224,230,250,264,300,400,430,464,490,570,674,680,690,930,960,1004,1054,1060,1140,1144,1150,1314,1410,1434,1550,1564,1570,1580,1654,1784,1870,1964,1974,2050,2074,2080,2120,2260,2304,2314", "code": "\nfrom sympy import isprime\nk, klist, A302087_list = 0, [isprime(i**2+1) for i in range(6)], []\nwhile len(A302087_list) < 10000:\n    i = isprime((k+6)**2+1)\n    if klist[0] and i:\n        A302087_list.append(k)\n    k += 1\n    klist = klist[1:] + [i] \n"}
{"sequence_id": "A302292", "text": "Number of positive integer pairs (x,y) such that there exist positive integers p and q satisfying p*x + q*y = n.", "sequence": "0,1,3,6,9,13,17,23,26,33,37,45,49,59,59,74,75,89,89,103,101,123,119,139,132,161,151,175,169,193,187,219,203,243,211,260,243,287,261,297,281,327,301,351,313,381,341,401,354,421,389,451,405,483,409,489,457,537,471,547,495,593,509,610,521,645,565,669,601", "code": "\ndef sets(n):\n    res=set()\n    for i in range(1,n):\n        for j in range(1,i+1):\n            if i%j==0:\n                for k in range(1,n-i+1):\n                    if (n-i)%(k)==0:\n                        res.add((j,k))\n    return res\n[len(sets(i)) for i in range(1,100)]\n"}
{"sequence_id": "A302292", "text": "Number of positive integer pairs (x,y) such that there exist positive integers p and q satisfying p*x + q*y = n.", "sequence": "0,1,3,6,9,13,17,23,26,33,37,45,49,59,59,74,75,89,89,103,101,123,119,139,132,161,151,175,169,193,187,219,203,243,211,260,243,287,261,297,281,327,301,351,313,381,341,401,354,421,389,451,405,483,409,489,457,537,471,547,495,593,509,610,521,645,565,669,601", "code": "\nfrom __future__ import division\nfrom sympy import divisors\ndef A302292(n):\n    s = set()\n    for i in range(1,(n+3)//2):\n        for j in divisors(i):\n            for k in divisors(n-i):\n                if j != k:\n                    s.add((min(j,k),max(j,k)))\n    return divisor_count(n)+2*len(s)-1 \n"}
{"sequence_id": "A302293", "text": "Number of positive integer pairs (x,y) such that there exist positive integers p and q satisfying p*x^2 + q*y = n.", "sequence": "0,1,2,3,5,7,8,10,10,14,15,17,19,21,22,24,26,30,30,33,34,39,36,44,41,47,44,52,49,57,54,59,58,66,59,66,69,73,71,80,75,85,79,88,80,95,82,98,91,100,98,110,100,112,104,118,113,125,109,133,121,130,115,136,126,147,131,147,138,152,135,159,146,162,145", "code": "\ndef sets(n):\n    s = set()\n    for i in range(1,n):\n        for j in range(1,i+1):\n            if i%j==0:\n                for k in range(1,n-i+1):\n                    if (n-i)%(k**2)==0:\n                        s.add((k, j))\n    return len(s)\n[sets(i) for i in range(1,50)]\n"}
{"sequence_id": "A302293", "text": "Number of positive integer pairs (x,y) such that there exist positive integers p and q satisfying p*x^2 + q*y = n.", "sequence": "0,1,2,3,5,7,8,10,10,14,15,17,19,21,22,24,26,30,30,33,34,39,36,44,41,47,44,52,49,57,54,59,58,66,59,66,69,73,71,80,75,85,79,88,80,95,82,98,91,100,98,110,100,112,104,118,113,125,109,133,121,130,115,136,126,147,131,147,138,152,135,159,146,162,145", "code": "\nfrom sympy import divisors, integer_nthroot\ndef A302293(n):\n    s = set()\n    for i in range(1,n):\n        for j in divisors(i):\n            if integer_nthroot(j,2)[1]:\n                for k in divisors(n-i):\n                    s.add((j,k))\n    return len(s) \n"}
{"sequence_id": "A302294", "text": "Number of nonnegative integer pairs (x,y) such that there exist positive integers p and q satisfying p*x + q*y = n.", "sequence": "2,5,7,12,13,21,21,31,32,41,41,57,53,67,67,84,79,101,93,115,109,131,123,155,138,169,159,187,173,209,191,231,211,251,219,278,247,295,269,313,285,343,305,363,325,389,345,421,360,433,397,463,409,499,417,505,465,545,475,571,499,601,521,624,529,661,569", "code": "\ndef sets(n):\n    res = set()\n    for i in range(n+1):\n        for j in range(1,n+1):\n            if i%j==0:\n                for k in range(1,n+1):\n                    if (n-i)%k==0:\n                        res.add((i//j,(n-i)//k))\n    return res\n[len(sets(i)) for i in range(1,50)]\n"}
{"sequence_id": "A302294", "text": "Number of nonnegative integer pairs (x,y) such that there exist positive integers p and q satisfying p*x + q*y = n.", "sequence": "2,5,7,12,13,21,21,31,32,41,41,57,53,67,67,84,79,101,93,115,109,131,123,155,138,169,159,187,173,209,191,231,211,251,219,278,247,295,269,313,285,343,305,363,325,389,345,421,360,433,397,463,409,499,417,505,465,545,475,571,499,601,521,624,529,661,569", "code": "\nfrom __future__ import division\nfrom sympy import divisors, divisor_count\ndef A302294(n):\n    s = set()\n    for i in range(1,(n+3)//2):\n        for j in divisors(i):\n            for k in divisors(n-i):\n                if j != k:\n                    s.add((min(j,k),max(j,k)))\n    return 3*divisor_count(n)+2*len(s)-1 \n"}
{"sequence_id": "A302300", "text": "a(n) = Sum_{p in P} (Sum_{k_j = 1} 1)^2, where P is the set of partitions of n, and the k_j are the frequencies in p.", "sequence": "0,1,1,5,6,12,21,33,50,79,116,169,246,346,487,675,927,1254,1702,2263,3014,3966,5210,6766,8795,11303,14531,18521,23583,29803,37654,47231,59206,73792,91867,113778,140788,173377,213289,261318,319764,389846,474745,576164", "code": "\ndef frequencies(partition, n):\n    tot = 0\n    freq_list = []\n    i = 0\n    for p in partition:\n        freq = [0 for i in range(n+1)]\n        for i in p:\n            freq[i] += 1\n        for f in freq:\n            if f == 0:\n                tot += 1\n        freq_list.append(freq)\n    return freq_list\ndef sum_square_freqs_of_one(freq_part):\n    tot = 0\n    for f in freq_part:\n        count = 0\n        for i in f:\n            if i == 1:\n                count += 1\n        tot += count*count\n    return tot\n\n  part = partitions(n)\nfreq_part = frequencies(part, n)\nsum_of_ones = sum_square_freqs_of_one(freq_part)\n"}
{"sequence_id": "A302337", "text": "Triangle read by rows: T(n,k) is the number of 2k-cycles in the n X n grid graph (2 <= k <= floor(n^2/2), n >= 2).", "sequence": "1,4,4,5,9,12,26,52,76,32,6,16,24,61,164,446,1100,2102,2436,1874,900,226,25,40,110,332,1070,3504,11144,32172,77874,146680,217470,255156,233786,158652,69544,13732,1072,36,60,173,556,1942,7092,26424,97624,346428,1136164,3313812,8342388,18064642,33777148,54661008,76165128,89790912,86547168,64626638,34785284,12527632,2677024,255088", "code": "\n\nfrom graphillion import GraphSet\nimport graphillion.tutorial as tl\ndef A302337(n):\n    universe = tl.grid(n - 1, n - 1)\n    GraphSet.set_universe(universe)\n    cycles = GraphSet.cycles()\n    return [cycles.len(2 * k).len() for k in range(2, n * n // 2 + 1)]\nprint([i for n in range(2, 8) for i in A302337(n)])  \n"}
{"sequence_id": "A302442", "text": "Number of primes of the form b^2-2 for b <= 10^n.", "sequence": "5,26,157,1153,8888,72928,615643,5328644,47034083,420950239", "code": "\nfrom sympy import isprime\ndef aupton(terms):\n  s, alst = 0, []\n  for n in range(1, terms+1):\n    s += sum(isprime(b**2-2) for b in range(10**(n-1), 10**n))\n    alst.append(s)\n  return alst\nprint(aupton(6)) \n"}
{"sequence_id": "A302484", "text": "Number of Truchet tilings of an n X n square up to rotation and reflection.", "sequence": "1,1,43,32896,536911936,140737496743936,590295810401655390208,39614081257132309534260330496,42535295865117307944451040976113238016,730750818665451459101843020821051317142553624576,200867255532373784442745261543437606940418017880259520626688", "code": " def a(n): return (4**(n*n)+2**(n*n+1))//8 if n%2 else (4**(n*n)+5*4**(n*n//2)+2*4**(n*n//4))//8\n"}
{"sequence_id": "A302552", "text": "Number of segments needed to display the n-th prime number on a 7-segment LCD display.", "sequence": "5,5,5,3,4,7,5,8,10,11,7,8,6,9,7,10,11,8,9,5,8,9,12,13,9,10,13,11,14,9,10,9,10,13,12,9,10,13,11,10,11,11,10,13,11,14,9,15,13,16,15,16,11,12,13,16,17,10,11,14,17,16,14,9,12,10,12,13,12,15,15", "code": "\nfrom sympy import prime\ndef A302552(n):\n    return sum((6, 2, 5, 5, 4, 5, 6, 3, 7, 6)[int(d)] for d in str(prime(n))) \n"}
{"sequence_id": "A302576", "text": "Numbers k such that k/10 + 1 is a square.", "sequence": "-10,0,30,80,150,240,350,480,630,800,990,1200,1430,1680,1950,2240,2550,2880,3230,3600,3990,4400,4830,5280,5750,6240,6750,7280,7830,8400,8990,9600,10230,10880,11550,12240,12950,13680,14430,15200,15990,16800,17630,18480,19350,20240", "code": " [10*n*(n-2) for n in range(1, 50)]\n"}
{"sequence_id": "A302599", "text": "Numbers k such that digit_sum(k) > digit_sum(2k).", "sequence": "5,6,7,8,15,16,17,25,26,35,50,51,52,53,55,56,57,58,59,60,61,62,65,66,67,68,69,70,71,75,76,77,78,79,80,85,86,87,88,89,95,96,97,98,105,106,107,115,116,125,150,151,152,155,156,157,158,159,160,161,165,166", "code": "\nprint([y for y in range(10000) if sum([int(x) for x in str(y)]) > sum([int(z) for z in str(2*y)])])\n"}
{"sequence_id": "A302758", "text": "a(n) = n^2*(n*(4*n + 3) + 3*n*(-1)^n - 4)/96.", "sequence": "0,1,3,14,25,66,98,200,270,475,605,966,1183,1764,2100,2976,3468,4725,5415,7150,8085,10406,11638,14664,16250,20111,22113,26950,29435,35400,38440,45696,49368,58089,62475,72846,78033,90250,96330,110600,117670,134211,142373,161414", "code": " [n**2*(n*(4*n+3)+3*n*(-1)**n-4)/96 for n in range(1, 50)] \n"}
{"sequence_id": "A302829", "text": "a(n) is the number of lattice points in a Cartesian grid between a circle of radius n and an inscribed square whose vertices lie on the coordinate axes.", "sequence": "0,0,4,8,12,28,36,52,72,88,112,128,156,192,220,252,280,324,368,408,448,504,548,592,644,708,776,828,880,952,1016,1096,1164,1236,1324,1388,1472,1548,1648,1736,1808,1912,2004,2116,2212,2300,2408,2508,2624,2728,2860,2976,3076", "code": "\nfor n in range (1,100):\n.count=0\n.for x in range (0, n):\n..for y in range (0,n):\n...if (x*x+y*y<n*n and x+y>n):\n....count=count+1\n.print(4*count)\n"}
{"sequence_id": "A303065", "text": "Number of numbers < n whose binary representation has the same difference between the numbers of 0's and 1's as n does.", "sequence": "0,0,0,0,1,1,2,0,0,1,2,1,3,2,3,0,0,2,3,3,4,4,5,1,5,6,7,2,8,3,4,0,0,1,2,4,3,5,6,4,4,7,8,5,9,6,7,1,5,10,11,8,12,9,10,2,13,11,12,3,13,4,5,0,0,1,2,6,3,7,8,9,4,9,10,10,11,11,12,5,5,12,13", "code": "\nd=[0]*200\nfor n in range(1024):\n    b = bin(n)[2:]\n    c0 = b.count('0')\n    c1 = len(b) - c0\n    diff = c0 - c1\n    print str(d[100+diff])+',',\n    d[100+diff] += 1\n"}
{"sequence_id": "A303108", "text": "a(n) = (2*n-1)*a(n-1) - (n-2)!, with a(1) = 2, n > 1.", "sequence": "2,5,24,166,1488,16344,212352,3184560,54132480,1028476800,21597649920,496742319360,12418518067200,335299508812800,9723679528550400,301433978206771200,9947319973149081600,348156178137427968000,12881778235397406720000,502389344778125156352000", "code": "\nA303108_list = [2,5]\nfor n in range(3,501):\n    A303108_list.append(3*(n-1)*A303108_list[-1]-(2*n-3)*(n-2)*A303108_list[-2]) \n"}
{"sequence_id": "A303109", "text": "a(n) = n*(2*n-1)*a(n-1) + ((n-1)!)^2, with a(0) = 0, n > 0.", "sequence": "0,1,7,109,3088,139536,9223776,839882016,100811243520,15425745960960,2931023414476800,677079576933580800,186875556584590540800,60734785332524728320000,22957787631482390937600000,9986645219749296609853440000,4953377739007903842686730240000,2778845349346570753142308208640000", "code": "\nA303109_list = [0,1]\nfor n in range(2,501):\n    A303109_list.append((3*n*(n-1)+1)*A303109_list[-1]-(2*n-3)*(n-1)**3*A303109_list[-2]) \n"}
{"sequence_id": "A303260", "text": "Determinant of n X n matrix A[i,j] = (j - i - 1 mod n) + [i=j], i.e., the circulant having (n, 0, 1, ..., n-2) as first row.", "sequence": "1,1,4,28,273,3421,52288,941578,19505545,456790123,11931215316,343871642632,10840081272265,371026432467913,13702802011918048,543154131059225686,23000016472483168305,1036227971225610466711,49492629462587441963140,2497992686980609418282548,132849300060919364474261281", "code": "\nfrom sympy import Matrix\ndef A303260(n): return Matrix(n,n, lambda i,j:(j-i-1) % n + (i==j)).det() \n"}
{"sequence_id": "A303331", "text": "a(n) is the minimum size of a square integer grid allowing all triples of n points to form triangles of different areas.", "sequence": "0,1,1,2,4,6,9,11,15,19", "code": "\ndef addNewAreas(plist, used_areas):\n....\n....\n....m=len(plist)\n....for i in range(m-2):\n........for j in range(i+1,m-1):\n............k=m-1\n............p,q,r=plist[i],plist[j],plist[k]\n............\n............s=(p[0]*q[1]-p[1]*q[0]) + (q[0]*r[1]-q[1]*r[0]) + (r[0]*p[1]-r[1]*p[0])\n............if s<0:\n................s=-s\n............if s in used_areas:\n................return False \n............else:\n................used_areas[s]=True\n....return True\ndef solveRecursively(n, L, plist, used_areas):\n....m=len(plist)\n....if m==n:\n........\n........return True\n....newlist=plist+[None]\n....if m>0:\n........startidx=(L+1)*plist[m-1][0] + plist[m-1][1] + 1\n....else:\n........startidx=0\n....for idx in range(startidx, (L+1)**2):\n............newlist[m]=( idx/(L+1) , idx%(L+1) )\n............newareas=dict(used_areas)\n............if addNewAreas(newlist, newareas):\n................if solveRecursively(n, L, newlist, newareas):\n....................return True\n....return False\ndef A303331(n):\n....L=0\n....while not solveRecursively(n, L, [], {0:True}):\n........L+=1\n....return L\ndef A303331_list(N):\n....return [A303331(n) for n in range(1,N+1)]\n\n"}
{"sequence_id": "A303610", "text": "Circle aliasing numbers with 1/n size steps.", "sequence": "10,1010,110100,11010100,1101100100,110110100100,11101010101000,1110110101001000,111011010101001000,11101101101001001000,1110111010101010001000,111011101010101010001000,11110110110101010010010000,1111011011010101010010010000,111101110101101010010100010000", "code": "\ndef closer(pos1, pos2):\n    dpos1 = (pos1[0]**2.0+pos1[1]**2.0)**.5\n    dpos2 = (pos2[0]**2.0+pos2[1]**2.0)**.5\n    if (1.0-dpos1)**2.0 < (1.0-dpos2)**2.0:\n        return True\n    else:\n        return False\ndef converts(path):\n    return ''.join(path)\nl = []\nfor steps in range(1, 20):\n    stepsize = 1.0/steps\n    pos = [-1.0, 0.0]\n    paths = []\n    for i in range(0, 2*steps):\n        if closer([pos[0]+stepsize, pos[1]], [pos[0], pos[1]+stepsize]):\n            pos = [pos[0]+stepsize, pos[1]]\n            paths.append(str(0))\n        else:\n            pos = [pos[0], pos[1]+stepsize]\n            paths.append(str(1))\n    l.append(int(converts(paths)))\nprint(l)\n"}
{"sequence_id": "A303642", "text": "a(n) is the number of lattice points in Cartesian grid between circle of radius n and its inscribed square. The sides of the square are parallel to coordinate axes.", "sequence": "0,0,0,20,20,28,64,72,80,80,148,148,156,248,256,264,264,380,396,404,528,552,560,700,716,740,764,928,936,960,1148,1180,1196,1212,1440,1448,1472,1700,1740,1764,2000,2040,2064,2104,2380,2396,2428,2720,2760,2784,2832,3156", "code": "\nimport math\nfor n in range(1, 100):\n.count = 0\n.for x in range(0, n):\n..for y in range(-n, n):\n...if (x * x + y * y < n * n and x > n / math.sqrt(2)):\n....count = count + 1\n.print(4 * count)\n"}
{"sequence_id": "A303644", "text": "a(n) is the number of lattice points in a Cartesian grid between a square of side length 2*n, centered at the origin, and its inscribed circle. The sides of the square are parallel to the coordinate axes.", "sequence": "0,0,0,4,4,12,24,32,40,48,68,92,100,120,136,168,192,220,244,268,312,336,376,420,444,484,524,576,624,664,724,764,820,868,912,992,1040,1116,1156,1220,1304,1368,1440,1496,1564,1660,1732,1816,1888,1960,2032,2116,2220,2308", "code": "\nimport math\nfor n in range (1,100):\n.count=0\n.for x in range (1, n):\n.for y in range (1,n):\n  .if (x*x+y*y>n*n and x<n and y<n):\n  .count=count+1\n.print(4*count)\n"}
{"sequence_id": "A303646", "text": "a(n) is the number of lattice points in a Cartesian grid between a square with integer sides 2*n and its inscribed circle. The sides of the square are parallel to the bisector of coordinate axes.", "sequence": "0,0,12,12,32,32,32,68,60,104,104,104,156,148,216,216,300,292,276,368,368,468,460,452,560,544,676,668,816,792,784,932,916,1080,1048,1048,1220,1212,1384,1360,1352,1556,1532,1736,1704,1956,1924,1900,2136,2096,2340,2308", "code": "\nimport math\nfor n in range (1, 100):\n   sqn = math.ceil(math.sqrt(2)*n)\n   count = 0\n   for x in range(-sqn, sqn):\n       for y in range(-sqn, sqn):\n           if (x*x+y*y>n*n and abs(x)+abs(y)<n*math.sqrt(2)):\n               count += 1\n   print(count)\n"}
{"sequence_id": "A303669", "text": "a(n) is the number of lattice points in a Cartesian grid between a circle of radius n, centered at the origin, and an inscribed equilateral triangle; one of the sides of triangle is perpendicular to X-axis.", "sequence": "0,2,13,21,36,56,81,103,144,166,215,239,298,342,405,447,514,568,655,707,796,864,961,1019,1128,1208,1337,1405,1524,1614,1749,1847,1990,2082,2249,2333,2502,2600,2789,2899,3064,3192,3383,3519,3718,3832,4047,4175", "code": "\nimport math\ntan=math.sqrt(3)/3\nfor n in range (1,70):\n.count=0\n.count1=0\n.for x in range (-n, n):\n..for y in range (-n,n):\n...if (x*x+y*y<n*n and y>-tan*x+tan*n):\n....count=count+1\n...if (x*x+y*y<n*n and y<-n/2):\n....count1=count1+1\n.print(2*count+count1)\n"}
{"sequence_id": "A303701", "text": "Number of distinct letters in the (American) English name of n, excluding spaces and hyphens.", "sequence": "4,3,3,4,4,4,3,4,5,3,3,4,5,6,7,5,6,5,6,4,5,6,6,7,9,8,8,7,8,6,5,8,7,6,8,8,7,9,7,7,5,7,6,7,6,8,8,9,9,8,4,7,6,7,7,6,6,8,7,6,5,8,7,8,9,8,5,8,8,7,6,7,8,8,10,8,8,6,9,7,6,8,8,7,10,8,8,9,6,7,5,6,7,7,9,7,7,7", "code": "\nfrom num2words import num2words\ndef n2w(n):\n  map = {ord(c): None for c in \"-, \"}\n  return num2words(n).replace(\" and\", \"\").translate(map)\ndef a(n): return len(set(n2w(n)))\nprint([a(n) for n in range(98)]) \n"}
{"sequence_id": "A303706", "text": "a(n) is the number of lattice points in a Cartesian grid between an equilateral triangle and an inscribed circle of radius n; one of the side of triangle is perpendicular to the X-axis; the circle's center is at the origin.", "sequence": "0,5,14,29,42,65,94,123,154,187,234,289,328,383,436,507,572,645,716,789,884,961,1058,1159,1244,1347,1454,1573,1692,1805,1940,2057,2194,2325,2454,2621,2758,2927,3060,3221,3404,3571,3746,3909,4086,4293,4478,4677,4868,5061,5256,5465,5698,5915", "code": "\nimport math\ntan=math.sqrt(3)/3\nfor n in range (1,71):\n  count=0\n  for x in range (-n, 2*n):\n   for y in range (-2*n, 2*n):\n    if (x*x+y*y>n*n and y<-tan*x+2*tan*n and y>tan*x-2*tan*n and x>-n):\n     count=count+1\n  print(count)\n"}
{"sequence_id": "A303743", "text": "a(n) is a number of lattice points in 3D Cartesian grid between cube with edge length 2*n centered in origin and its inscribed sphere. Three pairs of the cube's faces are parallel to the planes XOY, XOZ, YOZ respectively.", "sequence": "0,0,8,92,220,412,784,1272,1848,2696,3692,5020,6460,8176,10248,12720,15464,18476,21988,25924,30016,35040,40248,46052,52388,59132,66364,74416,83256,92304,102500,112988,124076,136252,148936,162648,176928,192332,208100,225284,243088", "code": "\nfor n in range (1, 42):\n  count=0\n  n2 = n*n\n  for x in range(-n+1, n):\n    for y in range(-n+1, n):\n      for z in range(-n+1, n):\n        if x*x+y*y+z*z > n2:\n          count += 1\n  print(count)\n"}
{"sequence_id": "A303748", "text": "a(n) is the number of distinct terms of the form i^j where 0 <= i,j <= n.", "sequence": "1,2,4,8,12,20,29,41,51,61,77,97,116,140,164,190,208,240,271,307,341,379,418,462,504,540,586,622,671,727,780,840,882,942,1004,1068,1114,1186,1255,1327,1398,1478,1554,1638,1718,1800,1885,1977,2064,2136,2226,2322", "code": "\ndef distinct(limit):\n    unique = set()\n    for i in range(limit+1):\n        for j in range(limit+1):\n            if i**j not in unique:\n                unique.add(i**j)\n    return len(unique)\nprint([distinct(i) for i in range(40)])\n"}
{"sequence_id": "A303918", "text": "Prime numbers with property that left half and right half have the same pattern of consecutive increasing/decreasing/equal digits:.", "sequence": "1021,1031,1051,1061,1063,1087,1091,1093,1097,1201,1213,1217,1223,1229,1237,1249,1259,1279,1289,1301,1303,1307,1319,1327,1367,1409,1423,1427,1429,1439,1447,1459,1489,1523,1549,1559,1567,1579,1601,1607,1609,1613,1619,1627,1637,1657,1667,1669,1709,1723,1747", "code": "\n\ndef pattern(p):\n    l=len(p)\n    s=\"\"\n    for k in range(l-1):\n        if p[k+1]>p[k]: s=s+\"+\"\n        elif p[k+1]<p[k]: s=s+\"-\"\n        else: s=s+\"=\"\n    return(s)\ndef is_prime(num):\n    for k in range(2,num):\n       if (num % k) == 0:\n           return(0)\n    return(1)\nfor i in range(1000,999999):\n    if len(str(i)) % 2 == 0:\n        p1=str(i)[0:int(len(str(i))/2)]\n        p2=str(i)[int(len(str(i))/2):len(str(i))]\n        if pattern(p1)==pattern(p2) and is_prime(i):  print(i)\n"}
{"sequence_id": "A303935", "text": "Size of orbit of n under repeated application of sum of factorial of digits of n.", "sequence": "2,1,1,16,8,10,15,32,36,35,2,2,17,33,13,10,15,32,36,35,17,17,9,37,7,12,6,8,33,31,33,33,37,18,34,31,48,39,24,8,13,13,7,34,30,54,42,39,29,52,10,10,12,31,54,10,24,21,41,24,15,15,6,48,42,24,12,42", "code": "\nfor n in count(0):\n    l=[]\n    i=n\n    while i not in l:\n        l.append(i)\n        i=sum(map(factorial,map(int,str(i))))\n    print(n,len(l))\n"}
{"sequence_id": "A304023", "text": "a(n) is the smallest integer with n digits in base 3/2 expressed in base 3/2.", "sequence": "0,20,210,2100,21010,210110,2101100,21011000,210110000,2101100010,21011000110,210110001100,2101100011010,21011000110100,210110001101000,2101100011010010,21011000110100110,210110001101001100,2101100011010011010,21011000110100110100,210110001101001101010", "code": "\ndef f(n): return 0 if n < 1 else f(n//3*2)*10 + n%3\ndef a(n):\n  k = 0\n  while len(str(f(k))) != n: k += 1\n  return f(k)\nprint([a(n) for n in range(1, 22)]) \n"}
{"sequence_id": "A304035", "text": "a(n) is the number of lattice points inside a square bounded by the lines x=-n/sqrt(2), x=n/sqrt(2), y=-n/sqrt(2), y=n/sqrt(2).", "sequence": "1,9,25,25,49,81,81,121,169,225,225,289,361,361,441,529,625,625,729,841,841,961,1089,1089,1225,1369,1521,1521,1681,1849,1849,2025,2209,2401,2401,2601,2809,2809,3025,3249,3249,3481,3721,3969,3969,4225,4489,4489,4761,5041,5329,5329,5625,5929,5929", "code": "\nimport math\nfor n in range (1, 100):\n.count=0\n.for x in range (-n, n):\n..for y in range (-n, n):\n...if ((2*x*x < n*n) and (2*y*y < n*n)):\n....count=count+1\n.print(count)\n"}
{"sequence_id": "A304176", "text": "Number of partitions of n^3 into exactly n parts.", "sequence": "1,1,4,61,1906,91606,6023602,505853354,51900711796,6306147384659,886745696653253,141778041323736643,25417656781153090889,5052180112449982704619,1103058286595668300801794,262487324530101028337614478,67628783852463631751658038290", "code": "\nimport sys\nfrom functools import lru_cache\nsys.setrecursionlimit(10**6)\n@lru_cache(maxsize=None)\ndef b(n,i): return 1 if n == 0 or i == 1 else b(n,i-1)+b(n-i,min(i,n-i))\ndef A304176(n): return b(n**3-n,n) \n"}
{"sequence_id": "A304178", "text": "Number of distinct sets of palindrome prefix lengths, over all binary palindromes of length n.", "sequence": "1,1,2,2,4,4,7,7,11,12,18,17,25,27,38,38,50,51,70,69,92,95,122,118,151,156,197,195,244,242,305,297,369,376,456,441,536,541,658,643,767,761,920,895,1074,1079,1271,1227,1444,1436,1696,1665,1948,1923,2258,2190", "code": "\nfrom itertools import product\ndef pals(n):\n    for p in product(\"01\", repeat=n//2):\n        left = \"\".join(p)\n        right = left[::-1]\n        if n%2==0: yield left+right\n        else:\n            yield left+\"0\"+right\n            yield left+\"1\"+right\ndef pal_prefix_lengths(s): \n    return [i for i in range(2, len(s)+1) if s[:i]==(s[:i])[::-1]]\ndef a(n):\n    sets = set()\n    for p in pals(n):\n        if p[0]==\"1\": break \n        sets.add(tuple(pal_prefix_lengths(p)))\n    return len(sets)\nprint([a(n) for n in range(1,41)]) \n"}
{"sequence_id": "A304212", "text": "Number of partitions of n^3 into exactly n^2 parts.", "sequence": "1,1,5,318,112540,139620591,491579082022,4303961368154069,85434752794871493882,3588523098005804563697043,302194941264401427042462944147,48844693123353655726678707534158535,14615188708581196626576773497618986350642", "code": "\nimport sys\nfrom functools import lru_cache\nsys.setrecursionlimit(10**6)\n@lru_cache(maxsize=None)\ndef b(n,i): return 1 if n == 0 or i == 1 else b(n,i-1)+b(n-i,min(i,n-i))\ndef A304212(n): return b(n**3-n**2,n**2) \n"}
{"sequence_id": "A304231", "text": "Numbers of the form m*k with m <= k < 2m.", "sequence": "1,4,6,9,12,15,16,20,24,25,28,30,35,36,40,42,45,48,49,54,56,60,63,64,66,70,72,77,80,81,84,88,90,91,96,99,100,104,108,110,112,117,120,121,126,130,132,135,140,143,144,150,153,154,156,160,165,168,169,170", "code": " sorted(sum([[i*j for j in range(i,2*i)] for i in range(100)], []))\n"}
{"sequence_id": "A304290", "text": "Numbers k such that k-1 is a substring of k^2.", "sequence": "9,37,99,370,999,3367,9999,22186,99999,221860,333667,625001,625009,859415,926968,999999,1507152,3125001,3701562,7012141,9375009,9999999,20506249,28658098,33336667,46875009,78125001,79632152,86609391,98089448,99999999,306481073", "code": "\nA304290_list = [k for k in range(10**6) if str(k-1) in str(k**2)] \n"}
{"sequence_id": "A304390", "text": "Prime numbers p such that p squared + (p reversed) squared is also prime.", "sequence": "23,41,227,233,283,401,409,419,421,461,491,499,823,827,857,877,2003,2083,2267,2437,2557,2593,2617,2633,2677,2857,2887,2957,4001,4021,4051,4079,4129,4211,4231,4391,4409,4451,4481,4519,4591,4621,4639,4651,4871,6091,6301,6329,6379,6521,6529,6551", "code": "\nnmax=10000\ndef is_prime(num):\n    if num == 0 or num == 1: return(0)\n    for k in range(2, num):\n       if (num % k) == 0:\n           return(0)\n    return(1)\nris = \"\"\nfor i in range(nmax):\n    r=int((str(i)[::-1]))\n    t=pow(i,2)+pow(r,2)\n    if is_prime(i):\n       if is_prime(t):\n          ris = ris+str(i)+\",\"\nprint(ris)\n"}
{"sequence_id": "A304392", "text": "Numbers without a digit 1 with digits in nondecreasing order and the product of digits is a power of 6.", "sequence": "6,23,49,66,229,236,334,389,469,666,2233,2269,2349,2366,2899,3338,3346,3689,4499,4669,6666,22239,22336,22499,22669,23334,23389,23469,23666,26899,33368,33449,33466,34899,36689,44699,46669,66666,88999,222299,222333,222369,223349", "code": "\nfrom math import prod\nfrom sympy.utilities.iterables import multiset_combinations\ndef auptod(maxdigs):\n  n, digs, alst, targets = 0, 1, [], set(6**i for i in range(1, maxdigs*3))\n  for digs in range(1, maxdigs+1):\n    mcstr = \"\".join(str(d)*digs for d in \"234689\")\n    for mc in multiset_combinations(mcstr, digs):\n      if prod(map(int, mc)) in targets: alst.append(int(\"\".join(mc)))\n  return alst\nprint(auptod(6)) \n"}
{"sequence_id": "A304453", "text": "An expanded binary notation for n: the normal binary expansion for n is expanded by mapping each 1 to 10 and retaining the existing 0's.", "sequence": "0,10,100,1010,1000,10010,10100,101010,10000,100010,100100,1001010,101000,1010010,1010100,10101010,100000,1000010,1000100,10001010,1001000,10010010,10010100,100101010,1010000,10100010,10100100,101001010,10101000,101010010,101010100,1010101010,1000000,10000010,10000100", "code": "\ndef a(n): return int(bin(n)[2:].replace('1', '10'))\nprint([a(n) for n in range(35)]) \n"}
{"sequence_id": "A304822", "text": "a(n) = A304821(n+3)/A304821(n) - 1.", "sequence": "1,1,2,5,1,7,1,3,5,11,1,13,7,5,1,17,1,19,5,7,11,23,1,5,13,3,1,29,5,31,1,11,17,1,1,37,19,13,1,41,1,43,11,5,23,47,1,7,1,17,13,53,1,1,1,19,29,59,1,61,31,1,1,13,11,67,17,23,1,71,1,73", "code": "\nfrom math import gcd\nn,an0,an1,an2 = 3,6,6,6\nwhile n-3 < 200:\n    n += 1\n    an0,an1,an2,an3 = an2+an2*(n-2)//gcd(an2,n-2),an0,an1,an2\n    \n    print(n-3,an0//an3-1)\n\n"}
{"sequence_id": "A305188", "text": "Numbers that are equal to a nontrivial multinomial coefficient (i.e., equal to k!/(k1!*...*km!) with k1 + ... + km = k, k-2 >= k1 >= ... >= km).", "sequence": "6,10,12,15,20,21,24,28,30,35,36,42,45,55,56,60,66,70,72,78,84,90,91,105,110,120,126,132,136,140,153,156,165,168,171,180,182,190,210,220,231,240,252,253,272,276,280,286,300,306,325,330,336,342,351,360,364", "code": " \n"}
{"sequence_id": "A305191", "text": "Table read by rows: T(n,k) is the number of pairs (x,y) mod n such that x^2 + y^2 == k (mod n), for k from 0 to n-1.", "sequence": "1,2,2,1,4,4,4,8,4,0,9,4,4,4,4,2,8,8,2,8,8,1,8,8,8,8,8,8,8,16,16,0,8,16,0,0,9,12,12,0,12,12,0,12,12,18,8,8,8,8,18,8,8,8,8,1,12,12,12,12,12,12,12,12,12,12,4,32,16,0,16,32,4,0,16,8,16,0,25,12,12,12,12,12,12,12,12,12,12", "code": " [[len([(x, y) for x in range(n) for y in range(n) if (pow(x,2,n)+pow(y,2,n))%n==d]) for d in range(n)] for n in range(1,10)]\n"}
{"sequence_id": "A305211", "text": "a(n) is the number of possible values of (x^3 + y^3) mod n, where x and y are any integers.", "sequence": "1,2,3,4,5,6,5,8,5,10,11,12,13,10,15,16,17,10,19,20,15,22,23,24,25,26,15,20,29,30,31,32,33,34,25,20,37,38,39,40,41,30,43,44,25,46,47,48,35,50,51,52,53,30,55,40,57,58,59,60,61,62,25,64,65,66,67", "code": " [len(set((pow(x,3,n)+pow(y,3,n))%n for x in range(n) for y in range(x+1))) for n in range(1,51)]\n"}
{"sequence_id": "A305212", "text": "a(n) = n - A305211(n).", "sequence": "0,0,0,0,0,0,2,0,4,0,0,0,0,4,0,0,0,8,0,0,6,0,0,0,0,0,12,8,0,0,0,0,0,0,10,16,0,0,0,0,0,12,0,0,20,0,0,0,14,0,0,0,0,24,0,16,0,0,0,0,0,0,38,0,0,0,0,0,0,20,0,32,0,0,0,0,22,0,0,0,36,0,0", "code": " [n-len(set((pow(x,3,n)+pow(y,3,n))%n for x in range(n) for y in range(x+1))) for n in range(1,51)]\n"}
{"sequence_id": "A305213", "text": "a(n) is the smallest nonnegative integer whose first n binary digits coincide with its first n decimal digits.", "sequence": "0,10,110,10010,10011,110101,10011000,10011000,110100011,10010101000,10010101001,101111000101,10010001101010,10010001101010,101101111110011,1111110010100011,10001110000111111,101100111001011100,1111011010110001101,10001010110010101011,101011110011100111110", "code": "\nRDXHI=10\nRDXLO=2\ndef solvematch(startHi, startLo, digleft, powHi, powLo):\n....global RDXHI,RDXLO\n....if digleft<=0:\n........return startHi\n....if powHi<0 or powLo<0:\n........return None\n....startd = 1 if startHi==0 else 0\n....for d in range(startd,RDXLO):\n........bh=startHi + d * RDXHI**powHi\n........bl=startLo + d * RDXLO**powLo\n........if bh<(bl+RDXLO**powLo) and bl<(bh+RDXHI**powHi):\n............res=solvematch(bh, bl, digleft-1, powHi-1, powLo-1)\n............if res!=None:\n................return res\n....return None\ndef A305213(n):\n....if n<=1:\n........return 0 \n....d_hi =n-1\n....sol=None\n....while sol==None:\n........d_lo=d_hi\n........while(RDXLO**d_lo < 2* RDXHI**d_hi):\n............res=solvematch(0,0,n,d_hi,d_lo)\n............if res!=None:\n................sol = min(sol,res) if sol else res\n............d_lo+=1\n........d_hi+=1\n....return sol\n"}
{"sequence_id": "A305214", "text": "Numbers k such that A305212(k) is not zero.", "sequence": "7,9,14,18,21,27,28,35,36,42,45,49,54,56,63,70,72,77,81,84,90,91,98,99,105,108,112,117,119,126,133,135,140,144,147,153,154,161,162,168,171,175,180,182,189,196,198,203,207,210,216,217,224,225,231,234,238", "code": " [n for n in range(100) if n != len(set((pow(x,3,n) + pow(y,3,n))%n for x in range(n) for y in range(n)))]\n"}
{"sequence_id": "A305233", "text": "Smallest k such that binomial(k, floor(k/2)) >= n.", "sequence": "1,2,3,4,4,4,5,5,5,5,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9", "code": "\nfrom sympy import binomial\ndef f(n): return binomial(n, n // 2)\nsum([[i]*(f(i)-f(i-1)) for i in range(1,10)],[1])\n"}
{"sequence_id": "A305377", "text": "Tribonacci representation of primes, written in base 10.", "sequence": "2,3,5,8,12,16,20,22,27,37,40,48,52,54,67,74,82,84,91,99,101,108,130,137,147,152,154,162,164,169,194,198,205,209,256,258,265,273,277,288,294,297,309,320,324,326,341,358,363,365,387,394,396,409,419,426,434,436,515,520,522,534,554,560", "code": "\nfrom sympy import prime\ndef A305377(n):\n    m, tlist, s = prime(n), [1,2,4], 0\n    while tlist[-1]+tlist[-2]+tlist[-3] <= m:\n        tlist.append(tlist[-1]+tlist[-2]+tlist[-3])\n    for d in tlist[::-1]:\n        s *= 2\n        if d <= m:\n            s += 1\n            m -= d\n    return s \n"}
{"sequence_id": "A305378", "text": "Tribonacci representation of 2n+1, written in base 10.", "sequence": "1,3,5,8,10,12,16,18,20,22,25,27,33,35,37,40,42,44,48,50,52,54,65,67,69,72,74,76,80,82,84,86,89,91,97,99,101,104,106,108,128,130,132,134,137,139,141,145,147,149,152,154,160,162,164,166,169,171,173,177,179,181,192,194,196,198,201", "code": "\ndef A305378(n):\n    m, tlist, s = 2*n+1, [1,2,4], 0\n    while tlist[-1]+tlist[-2]+tlist[-3] <= m:\n        tlist.append(tlist[-1]+tlist[-2]+tlist[-3])\n    for d in tlist[::-1]:\n        s *= 2\n        if d <= m:\n            s += 1\n            m -= d\n    return s \n"}
{"sequence_id": "A305380", "text": "Tribonacci representation of 2^n, written in base 10.", "sequence": "1,2,4,9,19,41,88,195,418,1033,2195,4705,10282,21850,49160,104465,223780,550294,1186344,2525345,5514438,11817057,26297040,56201282,138856076,295217708,632609378,1382640428,2974062096,6603081730,14149570820,34976354857,74361996963", "code": "\ndef A305380(n):\n    m, tlist, s = 2**n, [1,2,4], 0\n    while tlist[-1]+tlist[-2]+tlist[-3] <= m:\n        tlist.append(tlist[-1]+tlist[-2]+tlist[-3])\n    for d in tlist[::-1]:\n        s *= 2\n        if d <= m:\n            s += 1\n            m -= d\n    return s \n"}
{"sequence_id": "A305461", "text": "The number of one-digit numbers, k, in base n such that k^2 and k^3 end in the same digit.", "sequence": "1,2,2,3,2,4,2,3,4,4,2,6,2,4,4,5,2,8,2,6,4,4,2,6,6,4,4,6,2,8,2,5,4,4,4,12,2,4,4,6,2,8,2,6,8,4,2,10,8,12,4,6,2,8,4,6,4,4,2,12,2,4,8,9,4,8,2,6,4,8,2,12,2,4,12,6,4,8,2,10,10,4,2,12,4", "code": " \nfor base in range(1,101):\n....n = 0\n....for j in range(base):\n........if (j**2)%base == (j**3)%base:\n............n += 1\n....print(base,n)\n"}
{"sequence_id": "A305503", "text": "Largest cardinality of subsets A of {0,1,...,n-1} with |A + A| > |A - A|.", "sequence": "0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40", "code": "\nimport numpy as np\nimport itertools\ndef findsubsets(S, m):\n    return itertools.combinations(S, m)\ndef mstd(a):\n    a1 = set()\n    a2 = set()\n    for i in a:\n        for j in a:\n            a1.add(i + j)\n            a2.add(i - j)\n    return len(a1) > len(a2)\ndef a(n):\n    ans = 0\n    Nn = list(range(n))\n    for k in range(1, n):\n        if any(mstd(i) for i in findsubsets(Nn, k)):\n            ans = k\n    return ans\n"}
{"sequence_id": "A305611", "text": "Number of distinct positive subset-sums of the multiset of prime factors of n.", "sequence": "0,1,1,2,1,3,1,3,2,3,1,5,1,3,3,4,1,5,1,5,3,3,1,7,2,3,3,5,1,6,1,5,3,3,3,8,1,3,3,7,1,7,1,5,5,3,1,9,2,5,3,5,1,7,3,7,3,3,1,9,1,3,5,6,3,7,1,5,3,6,1,10,1,3,5,5,3,7,1,9,4,3,1,10,3,3", "code": "\nfrom sympy import factorint\nfrom sympy.utilities.iterables import multiset_combinations\ndef A305611(n):\n    fs = factorint(n)\n    return len(set(sum(d) for i in range(1,sum(fs.values())+1) for d in multiset_combinations(fs,i))) \n"}
{"sequence_id": "A305719", "text": "Numbers whose squares have the same first and last digits.", "sequence": "1,2,3,11,22,26,39,41,68,75,97,101,109,111,119,121,129,131,139,141,202,208,212,218,222,225,235,246,254,256,264,303,307,313,319,321,329,331,339,341,349,351,359,361,369,371,379,381,389,391,399,401,409,411,419,421,429,431,439,441,638", "code": "\ndef ok(n): s = str(n*n); return s[0] == s[-1]\nprint(list(filter(ok, range(1, 639)))) \n"}
{"sequence_id": "A305851", "text": "a(n) = (a(n-1)+a(n-2))^(n-2) with a(1)=a(2)=1.", "sequence": "1,1,2,9,1331,3224179360000,348414297354956334043085401797347258376901025074126347562215651", "code": "\n\nseq_limit=9\nseq_list=[1,1]\nfor seq_no in range(3,seq_limit):\n    seq_list.append((seq_list[-1]+seq_list[-2])**(seq_no-2))\nprint(seq_list)\n"}
{"sequence_id": "A305876", "text": "a(n) = Fibbinary(2^n).", "sequence": "1,2,5,16,36,84,273,648,2114,4757,16516,37161,87045,282896,673924,2184233,5263877,17107472,38830244,134554132,303080705,707272770,2300725397,5457925252,17805431433,42970665029,139654661284,314223120404,1099646108737,2474203744786", "code": "\ndef A305876(n):\n    m, tlist, s = 2**n, [1,2], 0\n    while tlist[-1]+tlist[-2] <= m:\n        tlist.append(tlist[-1]+tlist[-2])\n    for d in tlist[::-1]:\n        s *= 2\n        if d <= m:\n            s += 1\n            m -= d\n    return s \n"}
{"sequence_id": "A305884", "text": "Lexicographically first sequence of positive squares, no two or more of which sum to a square.", "sequence": "1,1,1,4,16,25,25,324,841,1849,2601,14884,18769,103041,292681,774400,3400336,13307904,34892649,179399236,582643044,2008473856,4369606609,22833627664,67113119844,251608579236,1240247504896,3174109249609", "code": "\nfrom sympy import integer_nthroot\nfrom sympy.utilities.iterables import multiset_combinations\nA305884_list, n, m = [], 1, 1\nwhile len(A305884_list) < 30:\n    for l in range(1,len(A305884_list)+1):\n        for d in multiset_combinations(A305884_list,l):\n            if integer_nthroot(sum(d)+m,2)[1]:\n                break\n        else:\n            continue\n        break\n    else:\n        A305884_list.append(m)\n        continue\n    n += 1\n    m += 2*n-1 \n"}
{"sequence_id": "A305989", "text": "Numbers in binary reversed.", "sequence": "0,1,1,11,1,101,11,111,1,1001,101,1101,11,1011,111,1111,1,10001,1001,11001,101,10101,1101,11101,11,10011,1011,11011,111,10111,1111,11111,1,100001,10001,110001,1001,101001,11001,111001,101,100101,10101,110101,1101,101101,11101,111101,11,100011,10011", "code": " print(0)\nfor i in range(1,50):\n   print(format(i, 'b')[::-1].strip(\"0\"))\n"}
{"sequence_id": "A306043", "text": "Lexicographically first sequence of distinct positive squares, no two or more of which sum to a square.", "sequence": "1,4,9,25,49,64,484,625,1225,2209,12100,57600,67600,287296,1517824,7452900,19492225,64352484,161391616,976375009,3339684100,9758278656,33371982400,81598207716,448192758784,1641916765129,4148028762241,23794464493849", "code": "\nfrom itertools import combinations\nfrom sympy import integer_nthroot\nA306043_list, n, m = [], 1, 1\nwhile len(A306043_list) < 30:\n    for l in range(1,len(A306043_list)+1):\n        for d in combinations(A306043_list,l):\n            if integer_nthroot(sum(d)+m,2)[1]:\n                break\n        else:\n            continue\n        break\n    else:\n        A306043_list.append(m)\n    n += 1\n    m += 2*n-1 \n"}
{"sequence_id": "A306184", "text": "a(n) = (2n+1)!! mod (2n)!! where k!! = A006882(k).", "sequence": "1,7,9,177,2715,42975,91665,3493665,97345395,2601636975,70985324025,57891366225,9411029102475,476966861546175,20499289200014625,847876038362978625,35160445175104123875,1487419121780448231375,945654757149212735625,357657177058846280240625", "code": "\no=e=1\nfor n in range(2, 99, 2):\n  o*=n+1\n  e*=n\n  print str(o%e)+',',\n"}
{"sequence_id": "A306185", "text": "a(n) = (2n+1)!! + (2n)!! where k!! = A006882(k).", "sequence": "5,23,153,1329,14235,181215,2672145,44781345,840523635,17465201775,397983749625,9867844134225,264469801070475,7618612476650175,234748657653134625,7703855828862818625,268263758052098683875,9879138385352252391375,383608053176023482431625,15664153113813817068080625", "code": "\no=e=1\nfor n in range(2, 99, 2):\n  o*=n+1\n  e*=n\n  print str(o+e)+',',\n"}
{"sequence_id": "A306192", "text": "a(n) = (n - 1)*prime(n + 1).", "sequence": "0,5,14,33,52,85,114,161,232,279,370,451,516,611,742,885,976,1139,1278,1387,1580,1743,1958,2231,2424,2575,2782,2943,3164,3683,3930,4247,4448,4917,5134,5495,5868,6179,6574,6981,7240,7831,8106,8471,8756,9495,10258", "code": "\nfrom sympy import prime\n[(n-1)*prime(n+1) for n in range(1,100)]\n"}
{"sequence_id": "A306252", "text": "Least primitive root mod A033948(n).", "sequence": "0,1,2,3,2,5,3,2,3,2,2,3,3,5,2,7,5,2,7,2,2,3,3,2,3,6,3,5,5,3,3,2,5,3,2,2,3,2,7,5,5,3,2,7,2,3,3,5,5,3,2,5,3,2,6,3,11,2,7,2,3,2,7,3,2,7,5,2,6,5,3,5,2,5,5,2,2,3,2,2,19,5,5,2,3,3,5", "code": "\nfrom math import gcd\nroots = [0]\nfor n in range(2,140):\n    \n    un = [i for i in range(1,n) if gcd(i,n) == 1]\n    \n    order = len(un)\n    is_cyclic = False\n    for cand in un:\n        is_gen = True\n        run = 1\n        \n        for _ in range(order-1):\n            run = (run * cand) % n\n            if run == 1:\n                is_gen = False\n                break\n        if is_gen:\n            roots.append(cand)\n            is_cyclic = True\n            break\nprint(roots)\n"}
{"sequence_id": "A306302", "text": "Number of regions into which a figure made up of a row of n adjacent congruent rectangles is divided upon drawing diagonals of all possible rectangles (a(0)=0 by convention).", "sequence": "0,4,16,46,104,214,380,648,1028,1562,2256,3208,4384,5924,7792,10052,12744,16060,19880,24486,29748,35798,42648,50648,59544,69700,80992,93654,107596,123374,140488,159704,180696,203684", "code": "\nfrom sympy import totient\ndef A306302(n): return 2*n*(n+1) + sum(totient(i)*(n+1-i)*(2*n+2-i) for i in range(2,n+1)) \n"}
{"sequence_id": "A306305", "text": "Smallest number m such that 2^m*n has 2 or more identical adjacent decimal digits or -1 if no such m exists.", "sequence": "16,15,11,14,17,10,4,13,4,16,0,9,7,3,12,12,5,3,12,15,4,0,7,8,2,6,11,2,2,11,5,11,0,4,5,2,5,11,7,14,9,3,3,0,5,6,2,7,8,1,9,5,6,10,0,1,1,1,1,10,1,4,4,10,8,0,5,3,3,4,4,1,4,4,2,10,0,6,7,13", "code": "\ndef A306305(n):\n    m, k = 0, n\n    while True:\n        s = str(k)\n        for i in range(1,len(s)):\n            if s[i] == s[i-1]:\n                return m\n        m += 1\n        k *= 2\n"}
{"sequence_id": "A306323", "text": "Break up the Kolakoski sequence A000002 into pieces by inserting a space between every pair of equal terms; sequence gives lengths of successive pieces.", "sequence": "2,2,4,3,2,3,2,4,4,2,3,4,3,2,4,4,3,2,3,2,4,3,2,3,4,4,2,3,2,4,3,2,3,2,4,4,3,2,3,4,2,3,2,4,3,2,3,2,4,4,2,3,4,3,2,3,2,4,4,3,2,4,4,2,3,4,4,2,3,2,4,3,2,3,4,2,3,2,3,4,4,2,3,2,4,3,2,3,4,4,2,3,4,3,2,4,4,3,2,3,4,2,3,2,4,3,2,3", "code": "\nlast = count = 0\nfor k in K(n): \n    if k is last:\n        yield count\n        last = k\n        count = 0\n    count += 1\n"}
{"sequence_id": "A306330", "text": "Squarefree n with >= 3 factors that admit idempotent factorizations n = p*q.", "sequence": "30,42,66,78,102,105,114,130,138,165,170,174,182,186,195,210,222,246,255,258,266,273,282,285,290,318,330,345,354,366,370,390,399,402,410,426,434,435,438,455,462,465,474,498,510,518,530,534,546,555,570,582,602", "code": "\n    factor_list = numbthy.factor(n)\n    numFactors = len(factor_list)\n    if numFactors <= 2: \n        continue\n    if not is_composite_and_square_free_with_list(n,factor_list):\n        continue\n    factorCount[numFactors] += 1\n    iPartitions = idempotentPartitions(n,factor_list)\n    numIPs = len(iPartitions)\n    if numIPs > 0:\n        idempotents += 1\n        print(idempotents,n)\n"}
{"sequence_id": "A306334", "text": "a(n) is the number of different linear hydrocarbon molecules with n carbon atoms.", "sequence": "1,3,4,10,18,42,84,192,409,926,2030,4577,10171,22889,51176,115070,257987,579868,1301664,2925209,6569992,14763529,33166848,74527233,167446566,376253517,845401158,1899609267,4268309531,9590827171,21550227328,48422972296,108805058758", "code": "\nfrom numpy import array as npa\nfrom numpy.linalg import matrix_power as npow\ndef F(n):\n     if n<4: return([0,1,3,4][n])\n     m=npa([[0,0,1],[0,1,1],[1,1,1]],dtype=object)\n     m2=npow(m,n//2-2)\n     return((sum(sum(npow(m,n-2)))+sum(sum(m2[j]*min(j+1,3-(n&1)) for j in range(3))))//2)\n"}
{"sequence_id": "A306349", "text": "Number of terms in the greedy Egyptian fraction representation of n.", "sequence": "1,4,13,35,99", "code": "\nfrom sympy.ntheory import egyptian_fraction\ndef A306349(n): return len(egyptian_fraction(n))\n"}
{"sequence_id": "A306360", "text": "Numbers k such that A101337(k)/k is an integer.", "sequence": "1,2,3,4,5,6,7,8,9,153,370,371,407,459,1634,8208,9474,13598,48495,54748,92727,93084,119564,174961,306979,548834,1741725,3194922,4210818,9800817,9926315,12720569,24678050,24678051,88593477,144688641,146511208", "code": "\nA306360_list, k = [], 1\nwhile k < 10**9:\n    s = str(k)\n    l, c = len(s), 0\n    for i in range(l):\n        c = (c + int(s[i])**l) % k\n    if c == 0:\n        A306360_list.append(k)\n    k += 1 \n"}
{"sequence_id": "A306384", "text": "Start with n and repeatedly double it and apply the \"delete any run of identical digits\" operation described in A321801; a(n) is the number of steps needed to reach one of 0, 1, or 5, or -1 if none of these three numbers is ever reached.", "sequence": "0,0,19,12,18,0,11,23,17,4,19,1,10,29,22,32,16,5,3,47,18,15,1,20,9,2,28,26,21,13,31,24,15,1,4,23,2,18,46,21,17,51,14,15,1,24,19,2,8,10,1,33,27,24,25,1,20,19,12,18,30,1,23,7,14,29,6,20,3", "code": "\nfrom re import split\ndef A306384(n):\n    mset, m, c = set(), n, 0\n    while True:\n        if m == 1 or m == 0 or m == 5:\n            return c\n        m = int('0'+''.join(d for d in split('(0+)|(1+)|(2+)|(3+)|(4+)|(5+)|(6+)|(7+)|(8+)|(9+)', str(2*m)) if d != '' and d != None and len(d) == 1))\n        if m in mset:\n            return -1\n        mset.add(m)\n        c += 1\n"}
{"sequence_id": "A306392", "text": "a(n) = 2^n with 1's and 2's swapped.", "sequence": "2,1,4,8,26,31,64,218,156,521,2014,1048,4096,8291,26384,31768,65536,232071,161244,514188,2048576,1097251,4294304,8388608,26777126,33554431,67208864,234127718,168435456,536870921,2073742814,1247483648,4194967196", "code": "\ndef A306392(n):\n    return int(''.join('1' if d == '2' else ('2' if d == '1' else d) for d in str(2**n))) \n"}
{"sequence_id": "A306399", "text": "a(1)=1; a(n) = number of occurrences of a(n-1) if a(n-1) is odd; a(n) = number of occurrences of a(n-2) if a(n-1) is even.", "sequence": "1,1,2,2,2,3,1,3,2,2,5,1,4,4,2,2,7,1,5,2,2,9,1,6,6,2,2,11,1,7,2,2,13,1,8,8,2,2,15,1,9,2,2,17,1,10,10,2,2,19,1,11,2,2,21,1,12,12,2,2,23,1,13,2,2,25,1,14,14,2,2,27,1,15,2,2", "code": "\nn, aa = 1, [1]\nprint(n,1)\nwhile n <= 75:\n    sa = aa[len(aa)-2+aa[len(aa)-1]%2]\n    i, a = 0, 0\n    while i < len(aa):\n        if sa == aa[i]:\n            a = a+1\n        i = i+1\n    print(n,a)\n    n, aa = n+1, aa+[a] \n"}
{"sequence_id": "A306494", "text": "Smallest number m such that n*3^m has 2 or more identical adjacent decimal digits.", "sequence": "11,8,10,8,11,7,9,5,9,11,0,7,2,4,10,2,4,6,7,8,8,0,5,4,2,9,8,4,6,10,4,2,0,8,6,6,1,1,1,8,3,3,3,0,9,5,5,1,2,11,3,7,2,5,0,7,6,2,1,7,6,2,7,5,3,0,6,4,4,9,7,3,5,1,1,1,0,8,2,5,7,3,3,3,1", "code": "\ndef A306494(n):\n    m, k= 0, n\n    while True:\n        s = str(k)\n        for i in range(1,len(s)):\n            if s[i] == s[i-1]:\n                return m\n        m += 1\n        k *= 3\n"}
{"sequence_id": "A306508", "text": "Squarefree numbers that have fully composite idempotent factorizations.", "sequence": "210,462,570,1155,1302,1330,1365,1785,2210,2310,2730,3003,3410,3710,3990,4305,4515,4758,4810,5005,5187,5474,5610,5642,6006,6105,6118,6270,6510,6622,6630,7410,7770,8265,8385,8463,8645,9282,9471,9870,10010,10101,10230,10374,10545,10582", "code": "\nfor n in range(2,max_n):\n    factor_list = numbthy.factor(n)\n    numFactors = len(factor_list)\n    if numFactors <= 3:\n        continue\n    if not bsflib.is_composite_and_square_free_with_list(n,factor_list):\n        continue\n    fciFactorizations = bsflib.fullyCompositeIdempotentFactorizations(n,factor_list)\n    numFCIFs = len(fciFactorizations)\n    if numFCIPs > 0:\n        fcIdempotents += 1\n    print(n)\n"}
{"sequence_id": "A306522", "text": "Number of simple directed cycles in the binary de Bruijn graphs of order n.", "sequence": "3,6,19,179,30176,1202267287", "code": "\nimport networkx as nx\ndef deBruijn(n): return nx.MultiDiGraph(((0, 0), (0, 0))) if n==0 else nx.line_graph(deBruijn(n-1))\ndef A306522(n): return sum(1 for c in nx.simple_cycles(deBruijn(n))) \n"}
{"sequence_id": "A306540", "text": "Least k >= 1 such that the decimal expansion of n^k starts with 99 or 100.", "sequence": "1,93,153,98,93,9,71,31,153,1,145,101,79,130,159,49,13,47,61,93,90,73,47,192,98,147,51,123,93,153,116,97,27,143,68,151,44,188,22,98,31,69,30,115,124,86,61,160,71,93,106,81,29,71,104,139,127,93,48,9,177,53,5,129,155,133,23,197,211", "code": "\ndef A306540(n):\n    if n == 1 or n == 10:\n        return 1\n    k, nk = 1, n\n    while True:\n        s = str(nk)\n        if s[:2] == '99' or s[:3] == '100':\n            return k\n        k += 1\n        nk *= n \n"}
{"sequence_id": "A306572", "text": "Numbers k whose decimal representation ends with that of pi(k) (where pi denotes the prime counting function A000720).", "sequence": "16,17,132,254,374,494,1196,2348,3487,4624,5757,6886,11373,22517,33597,44639,55646,66644,77629,88580,99550,99551,110486,219572,328268,436699,544946,653052,761059,869024,976855,1084604,1192399,2159962,3232398,4303026,4303027", "code": "\nfrom sympy import primepi\nA306572_list = [n for n, p in enumerate(primepi(k) for k in range(10**4)) if n > 0 and n % 10**len(str(p)) == p] \n"}
{"sequence_id": "A306582", "text": "a(n) is the least integer k such that the remainder of k modulo p is strictly increasing over the first n primes.", "sequence": "0,2,4,34,52,194,502,1138,4042,5794,5794,62488,798298,5314448,41592688,483815692,483815692,5037219688,18517814158,18517814158,19566774820732,55249201504132,1257253598786974,6743244322196288,24165921989926702,24165921989926702,5346711077171356252,47449991406350138602,278545375679341352084,5604477496256287791854", "code": "\nfrom sympy import prime\ndef A306582(n):\n    plist, rlist, x = [prime(i) for i in range(1,n+1)], [0]*n, 0\n    while True:\n        for i in range(n-1):\n            if rlist[i] >= rlist[i+1]:\n                break\n        else:\n            return x\n        for i in range(n):\n            rlist[i] = (rlist[i] + 1) % plist[i]\n        x += 1 \n"}
{"sequence_id": "A306591", "text": "a(n) is the denominator of 1/2 - 1/(prime(n)+1), where prime(n) is the n-th prime.", "sequence": "6,4,3,8,12,7,9,20,24,15,32,19,21,44,48,27,60,31,68,72,37,80,84,45,49,51,104,108,55,57,128,132,69,140,75,152,79,164,168,87,180,91,192,97,99,200,212,224,228,115,117,240,121,252,129,264,135,272,139,141,284,147,308,312,157", "code": "\nfrom sympy import prime\nfrom fractions import Fraction\ndef a(n): return (Fraction(1, 2) - Fraction(1, (prime(n)+1))).denominator\nprint([a(n) for n in range(1, 66)]) \n"}
{"sequence_id": "A306612", "text": "a(n) is the least integer k > 2 such that the remainder of -k modulo p is strictly increasing over the first n primes.", "sequence": "3,4,7,8,16,16,157,157,16957,19231,80942,82372,82372,9624266,19607227,118867612,4968215191,31090893772,118903377091,187341482252,1784664085208,12330789708022,68016245854132,68016245854132,10065964847743822,74887595879692807,1825207861455319267,98403562254816509476,283462437415903129597,2126598918934702375802", "code": "\nfrom sympy import prime\ndef A306612(n):\n    plist, x = [prime(i) for i in range(1,n+1)], 3\n    rlist = [-x % p for p in plist]\n    while True:\n        for i in range(n-1):\n            if rlist[i] >= rlist[i+1]:\n                break\n        else:\n            return x\n        for i in range(n):\n            rlist[i] = (rlist[i] - 1) % plist[i]\n        x += 1 \n"}
{"sequence_id": "A306643", "text": "Numbers that, for some x, are the concatenation of x, x+1 and x+2 and are divisible by at least two of x, x+1 and x+2.", "sequence": "123,234,345,456,8910,101112,230231232", "code": "\nfor k in range(1,8):\n..for x in range(10**(k-1),10**k-2): \n....if sum([not (10**k+2)%x,not (10**(2*k)-1)%(x+1),\\\n....not (2*10**(2*k)+10**k)%(x+2)]) >= 2:\n......print(str(x)+str(x+1)+str(x+2)) \n"}
{"sequence_id": "A306666", "text": "Positive integers x such that x*(7-5*x+x^2)*(6-4*x+x^2) is a square.", "sequence": "1,2,3,7,21", "code": "\nfrom sympy.ntheory.primetest import is_square\nA306666_list = [n for n in range(1,10**3) if is_square(n*(n*(n*(n*(n - 9) + 33) - 58) + 42))] \n"}
{"sequence_id": "A306689", "text": "Integers m with decimal expansion m = abc...z such that m is a multiple of both az and za; z may not be zero.", "sequence": "11,22,33,44,55,66,77,88,99,121,242,363,484,1001,1092,1111,1207,1221,1275,1331,1441,1458,1512,1551,1661,1729,1771,1785,1881,1932,1991,2002,2112,2184,2222,2332,2442,2552,2662,2772,2882,2992,3003,3276,3333,3663,3993,4004,4032", "code": "\nfor a in range(1,1000):\n...for b in range (1, 10):\n......numb = 10*a + b\n......f = int(str(zahl)[0])\n......first = 10*f + b\n......last = 10*b + f\n......if numb %  first == 0 and numb % last == 0 :\n.........print(numb)\n"}
{"sequence_id": "A306727", "text": "Square array A(n,k), n >= 0, k >= 0, read by antidiagonals: A(n,k) is the number of partitions of 3*n into powers of 3 less than or equal to 3^k.", "sequence": "1,1,1,1,2,1,1,2,3,1,1,2,3,4,1,1,2,3,5,5,1,1,2,3,5,7,6,1,1,2,3,5,7,9,7,1,1,2,3,5,7,9,12,8,1,1,2,3,5,7,9,12,15,9,1,1,2,3,5,7,9,12,15,18,10,1,1,2,3,5,7,9,12,15,18,22,11,1,1,2,3,5,7,9,12,15,18,23,26,12,1", "code": "\ndef aseq(p, x, k):\n    \n    if x < 0:\n        return 0\n    if x < p:\n        return 1\n    \n    arr = [0]*(x+1)\n    arr[0] = 1\n    m = p**k\n    while m > 0:\n        for i in range(m, x+1, m):\n            arr[i] += arr[i-m]\n        m //= p\n    return arr[x]\ndef A(n, k):\n    p = 3\n    return aseq(p, p*n, k)\n\n\n"}
{"sequence_id": "A306729", "text": "a(n) = Product_{i=0..n, j=0..n} (i! + j!).", "sequence": "2,16,5184,9559130112,109045776752640000000000,27488263744928988967331390258832998400000000000,1147897050240877062218236820013018349788772091106840426434074807527014400000000000000", "code": "\nfrom math import prod, factorial as f\ndef a(n): return prod(f(i)+f(j) for i in range(n) for j in range(n))\nprint([a(n) for n in range(1, 8)]) \n"}
{"sequence_id": "A306773", "text": "Triangle read by rows, 0 <= k < n, n >= 2: T(n,k) is the eventual period of the modified Fibonacci sequence x(j) (or 0 if x(j) never enters a cycle) defined as follows: x(0) = 0, x(1) = 1, and for j > 1 x(j) is obtained from x(j-1) + x(j-2) by deleting all occurrences of the digit k in base n.", "sequence": "1,1,3,1,3,16,1,3,24,6,1,3,13,6,100,1,3,8,252,120,24,1,3,8,42,119,96,576,1,3,60,588,378,36,624,1932,1,3,126,600,144,381,200,936,912,1,3,480,51,9,2760,6220,540,1800,5700,1,3,170,750,2480,14880,10990,300,1440,3660,840,1,3,13800,5880,432,48096,60528,456,17640,8496,10560", "code": "\n\nimport functools,sympy\ndef drop(x,n,k): return functools.reduce(lambda x,j:n*x+j if j!=k else x,sympy.ntheory.factor_.digits(x,n)[1:],0) \ndef A306773(n,k): return next(sympy.cycle_length(lambda x:(x[1],drop(x[0]+x[1],n,k)),(0,1)))[0]\n\n"}
{"sequence_id": "A306777", "text": "a(0)=0, a(1)=1, a(n) = a(n-1) + sum(a(floor(n/d)), d=2^x, x=1...n.", "sequence": "0,1,2,3,6,9,13,17,26,35,47,59,76,93,114,135,170,205,249,293,352,411,482,553,646,739,849,959,1094,1229,1385,1541,1746,1951,2191,2431,2724,3017,3354,3691,4102,4513,4983,5453,6006,6559,7183,7807,8546,9285,10117,10949", "code": "\na = [0]*1000\na[1] = 1\nfor n in range(2, len(a)):\n  a[n] = a[n-1]\n  d = 2\n  while d <= n:\n    a[n] += a[n//d]\n    d *= 2\nprint(a)\n"}
{"sequence_id": "A306792", "text": "Number of distinct eigenvalues of n X n matrices with elements {0, 1, 2}.", "sequence": "3,25,1027,193244", "code": "\nfrom itertools import product\nfrom sympy.matrices import Matrix\ndef a(n):\n  eigset = set()\n  for e in product([0, 1, 2], repeat=n*n):\n    if n > 1 and e[1] > e[n]: continue\n    M = Matrix([list(e[n*r:n*(r+1)]) for r in range(n)])\n    eigset |= set(eig for eig in M.eigenvals().keys())\n  return len(eigset)\nprint([a(n) for n in range(1, 3)]) \n"}
{"sequence_id": "A306800", "text": "Square array whose entry A(n,k) is the number of endofunctions on a set of size n with preimage constraint {0,1,...,k}, for n >= 0, k >= 0, read by descending antidiagonals.", "sequence": "1,1,0,1,1,0,1,1,2,0,1,1,4,6,0,1,1,4,24,24,0,1,1,4,27,204,120,0,1,1,4,27,252,2220,720,0,1,1,4,27,256,3020,29520,5040,0,1,1,4,27,256,3120,44220,463680,40320,0,1,1,4,27,256,3125,46470,765030,8401680,362880,0", "code": "\n\nimport math, sympy; x=sympy.symbols('x')\nk=5; num_entries = 64\nP=range(k+1); eP=sum([x**d/math.factorial(d) for d in P]); r = [1]; curr_pow = 1\nfor term in range(1,num_entries):\n...curr_pow=(curr_pow*eP).expand()\n...r.append(curr_pow.coeff(x**term)*math.factorial(term))\nprint(r)\n"}
{"sequence_id": "A306812", "text": "Maximally idempotent integers with three or more factors.", "sequence": "273,455,1729,2109,2255,2387,3367,3515,4433,4697,4921,5673,6643,6935,7667,8103,8723,8729,9139,9455,10235,10787,11543,13237,13505,14497,16211,16385,16523,17507,18031,18907,20033,20801,21437,22649,23579,24583", "code": "\n\n\nfor n in range(2,max_n):\n    factor_list = numbthy.factor(n)\n    numFactors = len(factor_list)\n    if numFactors <= 2: \n        continue\n    if not bsflib.is_composite_and_square_free_with_list(n,factor_list):\n        continue\n    ipList = bsflib.idempotentPartitions(n, factor_list)\n    if len(ipList) == 2**(numFactors-1)-1:\n        print(n)\n"}
{"sequence_id": "A306853", "text": "Positive integers equal to the permanent of the circulant matrix formed by their decimal digits.", "sequence": "1,2,3,4,5,6,7,8,9,261,370,407,52036,724212,223123410", "code": "\nfrom sympy import Matrix\nA306853_list = []\nfor n in range(1,10**6):\n    s = [int(d) for d in str(n)]\n    m = len(s)\n    if n == Matrix(m, m, lambda i, j: s[(i-j) % m]).per():\n        A306853_list.append(n) \n"}
{"sequence_id": "A306916", "text": "a(1)=1; for n > 1 replace each p^k in the prime factorization of n with prime(k)^p where prime(k) denotes the k-th prime number.", "sequence": "1,4,8,9,32,32,128,25,27,128,2048,72,8192,512,256,49,131072,108,524288,288,1024,8192,8388608,200,243,32768,125,1152,536870912,1024,2147483648,121,16384,524288,4096,243,137438953472,2097152,65536,800,2199023255552,4096", "code": "\nfrom functools import reduce\nfrom operator import mul\nfrom sympy import factorint, prime\ndef a(n):\n....return 1 if n == 1 else reduce(mul, (prime(k)**p for p,k in factorint(n).items()))\n"}
{"sequence_id": "A307026", "text": "Number of (undirected) paths in the m X n king graph (triangle read by rows with m = 1..n and n = 1..).", "sequence": "0,1,30,3,235,5148,6,1448,96956,6014812,10,7909,1622015,329967798,57533191444,15,40674,25281625,16997993692,9454839968415,4956907379126694,21,202719,375341540,834776217484,1482823362091281,2480146959625512771,3954100866385811897908", "code": "\n\nfrom graphillion import GraphSet\ndef make_nXk_king_graph(n, k):\n    grids = []\n    for i in range(1, k + 1):\n        for j in range(1, n):\n            grids.append((i + (j - 1) * k, i + j * k))\n            if i < k:\n                grids.append((i + (j - 1) * k, i + j * k + 1))\n            if i > 1:\n                grids.append((i + (j - 1) * k, i + j * k - 1))\n    for i in range(1, k * n, k):\n        for j in range(1, k):\n            grids.append((i + j - 1, i + j))\n    return grids\ndef A(start, goal, n, k):\n    universe = make_nXk_king_graph(n, k)\n    GraphSet.set_universe(universe)\n    paths = GraphSet.paths(start, goal)\n    return paths.len()\ndef A307026(n, k):\n    m = k * n\n    s = 0\n    for i in range(1, m):\n        for j in range(i + 1, m + 1):\n            s += A(i, j, n, k)\n    return s\nprint([A307026(n, k) for n in range(1, 8) for k in range(1, n + 1)])  \n"}
{"sequence_id": "A307031", "text": "n to the power n double factorial, n^(n!!).", "sequence": "1,4,27,65536,30517578125,22452257707354557240087211123792674816,54361846697263307560529495055267343940077014163990039113495978834700158362117849904436807", "code": "\ndef doublefactorial(n):\n     if n <= 0:\n         return 1\n     else:\n         return n * doublefactorial(n-2)\nfor n in range(1,m):\n    print(n**doublefactorial(n))\n"}
{"sequence_id": "A307070", "text": "The number of decimal places before the decimal expansion of 1/n terminates, or the period of the recurring portion of 1/n if it is recurring.", "sequence": "0,1,1,2,1,1,6,3,1,1,2,1,6,6,1,4,16,1,18,2,6,2,22,1,2,6,3,6,28,1,15,5,2,16,6,1,3,18,6,3,5,6,21,2,1,22,46,1,42,2,16,6,13,3,2,6,18,28,58,1,60,15,6,6,6,2,33,16,22,6,35,1,8,3,1,18,6,6,13", "code": "\ndef sequence(n):\n..count = 0\n..dividend = 1\n..remainder = dividend % n\n..remainders = [remainder]\n..no_recurrence = True\n..while remainder != 0:\n....count += 1\n....dividend = remainder * 10\n....remainder = dividend % n\n....if remainder in remainders:\n......if no_recurrence:\n........no_recurrence = False\n........remainders = [remainder]\n......else:\n........return len(remainders)\n....else:\n......remainders.append(remainder)\n..else:\n....return count\n"}
{"sequence_id": "A307226", "text": "Triangle read by rows: drop and bounce.", "sequence": "0,0,1,0,1,2,0,1,3,2,0,4,1,3,2,0,4,5,1,3,2,0,4,6,5,1,3,2,7,0,4,6,5,1,3,2,7,0,4,6,5,1,3,2,8,7,0,4,6,5,1,3,2,9,8,7,0,4,6,5,1,3,10,2,9,8,7,0,4,6,5,1,11,3,10,2,9,8", "code": "\nseq = [0]\nfor k in range (1, 10):\n  points = k\n  position = seq.index(0)\n  direction = 1\n  while points > 0 and position >= 0 and position < len(seq):\n    if points < seq[position]: direction *= -1\n    points -= 1\n    position += direction\n  else:\n    if position < 0: seq.insert(0, k)\n    elif position == len(seq): seq.append(k)\n    elif points == 0 and direction == 1: seq.insert(position, k)\n    else: seq.insert(position - direction, k)\nprint(seq)\n"}
{"sequence_id": "A307371", "text": "Numbers k such that the digits of sqrt(k) begin with k.", "sequence": "0,1,98,99,100,9998,9999,10000,999998,999999,1000000,99999998,99999999,100000000,9999999998,9999999999,10000000000,999999999998,999999999999,1000000000000,99999999999998,99999999999999,100000000000000,9999999999999998,9999999999999999", "code": "\nA307371_list = [0, 1, 98, 99, 100, 9998]\nfor _ in range(100):\n    A307371_list.append(101*A307371_list[-3]-100*A307371_list[-6]) \n"}
{"sequence_id": "A307437", "text": "a(n) is the smallest k such that 2n divides psi(k), psi = A002322.", "sequence": "3,5,7,17,11,13,29,17,19,25,23,73,53,29,31,97,103,37,191,41,43,89,47,97,101,53,81,113,59,61,311,193,67,137,71,73,149,229,79,187,83,203,173,89,181,235,283,97,197,101,103,313,107,109,121,113,229,233,709,241", "code": "\nfrom sympy import reduced_totient\ndef A307437(n):\n    k = 1\n    while reduced_totient(k) % (2*n):\n        k += 1\n    return k \n"}
{"sequence_id": "A307535", "text": "a(n) is the smallest k >= 0 such that 2^(2^n) + k*2^n + 1 is prime.", "sequence": "0,0,0,0,0,12,15,3,9,202,56,304,635,11095,8948,6415,14441,877", "code": "\nfrom sympy import isprime\ndef A307535(n):\n    r = 2**n\n    m, k = 2**r+1, 0\n    w = m\n    while not isprime(w):\n        k += 1\n        w += r\n    return k \n"}
{"sequence_id": "A307537", "text": "a(n) is the smallest maximally idempotent integer with n factors, n >= 3.", "sequence": "273,63973,72719023,13006678091,7817013532691", "code": "\n\n\n\n\n\n\n\ndef isMaximallyIdempotent(n):\n    factor_list = numbthy.factor(n)\n    partitions_of_n = partitions(n,factor_list)\n    lambda_n = carmichael_lambda_with_list(n,factor_list)\n    for (p,q) in partitions_of_n:\n        pseudo = (p-1)*(q-1)\n        if pseudo % lambda_n != 0:\n            return False\n    return True\n"}
{"sequence_id": "A307720", "text": "Lexicographically earliest sequence of positive integers in which, for all positive k, there are exactly k contiguous pairs whose product is k.", "sequence": "1,1,2,1,3,1,3,2,2,2,2,2,3,2,3,2,3,3,3,3,3,3,3,3,3,3,4,2,4,2,4,2,4,2,4,3,4,3,4,3,4,3,4,3,4,3,5,1,5,1,5,1,7,1,7,1,7,1,7,2,5,2,5,2,5,2,5,2,5,2,7,2,7,2,7,2,7,2,7,2,7,2,7,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,6,3,6,3,6,3,6,3,6,3,6,3,6,3,6,3,6,3,7,3,7,3,7,3,7,3,7,3,7,3,7,3,7,3,7,3,7,3,8,2,8", "code": "\nfrom itertools import islice\nfrom collections import Counter\ndef A307720(): \n    yield 1\n    c, b = Counter(), 1\n    while True:\n        k, kb = 1, b\n        while c[kb] >= kb:\n            k += 1\n            kb += b\n        c[kb] += 1\n        b = k\n        yield k\nA307720_list = list(islice(A307720(),100)) \n"}
{"sequence_id": "A307730", "text": "a(n) = A307720(n) * A307720(n+1).", "sequence": "1,2,2,3,3,3,6,4,4,4,4,6,6,6,6,6,9,9,9,9,9,9,9,9,9,12,8,8,8,8,8,8,8,8,12,12,12,12,12,12,12,12,12,12,12,15,5,5,5,5,5,7,7,7,7,7,7,7,14,10,10,10,10,10,10,10,10,10,10,14,14,14,14,14,14,14", "code": "\nfrom itertools import islice\nfrom collections import Counter\ndef A307730(): \n    c, b = Counter(), 1\n    while True:\n        k, kb = 1, b\n        while c[kb] >= kb:\n            k += 1\n            kb += b\n        c[kb] += 1\n        b = k\n        yield kb\nA307730_list = list(islice(A307730(),100)) \n"}
{"sequence_id": "A307732", "text": "Number of length-n binary words containing no antisquares except 01 and 10.", "sequence": "1,2,4,8,12,20,30,46,72,112,164,248,364,542,796,1180,1732,2550,3744,5504,8076,11854,17386,25498,37382,54808,80342,117770,172618,253008,370820,543490,796546,1167424,1710966,2507572,3675050,5386080,7893712,11568832,16954976", "code": "\nfrom numba import njit\n@njit\ndef aupto(nn, v=False):\n  alst = [1, 2, 4, 8]\n  if nn <= 4: return alst[:nn+1]\n  n, prev_as = 4, [0, 1, 2, 3]  \n  while n <= nn:\n    new_as = []\n    for w in prev_as:\n      for b in [0, 1]:\n        wb = 2*w + b\n        for k in range(2, n//2+1):\n          mask2 = (1<<k) - 1\n          mask1 = mask2 << k\n          if (wb&mask2)^((wb&mask1)>>k)==mask2: break \n        else: new_as.append(wb) \n    alst.append(2*len(new_as))  \n    if v: print(n, 2*len(new_as), alst)\n    prev_as = new_as\n    n += 1\n  return alst\nprint(aupto(30)) \n"}
{"sequence_id": "A307752", "text": "Number of n-digit palindromic pentagonal numbers.", "sequence": "3,1,0,2,1,1,2,2,0,4,0,0,3,1,1,1,3,2,4,1,3,1", "code": "\ndef afind(terms):\n  m, n, c = 0, 1, 0\n  while n <= terms:\n    p = m*(3*m-1)//2\n    s = str(p)\n    if len(s) == n:\n       if s == s[::-1]: c += 1\n    else:\n      print(c, end=\", \")\n      n, c = n+1, int(s == s[::-1])\n    m += 1\nafind(14) \n"}
{"sequence_id": "A307765", "text": "Number of palindromic hexagonal numbers with exactly n digits.", "sequence": "3,1,0,2,2,2,4,0,0,3,1,0,3,1,2,1,4,1,2,1,2,0", "code": "\ndef afind(terms):\n  m, n, c = 0, 1, 0\n  while n <= terms:\n    p = m*(2*m-1)\n    s = str(p)\n    if len(s) == n:\n       if s == s[::-1]: c += 1\n    else:\n      print(c, end=\", \")\n      n, c = n+1, int(s == s[::-1])\n    m += 1\nafind(14) \n"}
{"sequence_id": "A307790", "text": "Number of palindromic heptagonal numbers with exactly n digits.", "sequence": "3,1,1,2,1,1,3,0,0,1,4,3,2,0,1,0,1,1,2,2,2,2", "code": "\ndef afind(terms):\n  m, n, c = 0, 1, 0\n  while n <= terms:\n    p = m*(5*m-3)//2\n    s = str(p)\n    if len(s) == n:\n       if s == s[::-1]: c += 1\n    else:\n      print(c, end=\", \")\n      n, c = n+1, int(s == s[::-1])\n    m += 1\nafind(14) \n"}
{"sequence_id": "A307851", "text": "Prime numbers prime(k) with a zeroless decimal representation such that (product of decimal digits of prime(k)) / k is an integer.", "sequence": "2,17,73,89,2475989", "code": "\nfrom math import prod\nfrom sympy import nextprime\ndef aupton(terms):\n  p, k, t = 2, 1, 0\n  while t < terms:\n    strp = str(p)\n    if '0' not in strp and prod(int(d) for d in strp)%k == 0:\n      t += 1; print(p, end=\", \")\n    p, k = nextprime(p), k+1\naupton(5) \n"}
{"sequence_id": "A308092", "text": "The sum of the first n terms of the sequence is the concatenation of the first n bits of the sequence read as binary, with a(1) = 1.", "sequence": "1,2,3,7,14,28,56,112,224,448,896,1791,3583,7166,14332,28663,57326,114653,229306,458612,917223,1834446,3668892,7337785,14675570,29351140,58702279,117404558,234809116,469618232,939236465,1878472930,3756945860,7513891719", "code": "\ndef aupton(terms):\n  alst, bstr = [1, 2], \"110\"\n  for n in range(3, terms+1):\n    an = int(bstr[:n], 2) - int(bstr[:n-1], 2)\n    alst, bstr = alst + [an], bstr + bin(an)[2:]\n  return alst\nprint(aupton(34)) \n"}
{"sequence_id": "A308190", "text": "Number of steps to reach 5 when iterating x -> A111234(x) starting at x=n.", "sequence": "0,1,3,2,2,4,4,3,4,3,3,5,6,5,5,4,5,5,5,4,5,4,4,6,8,7,7,6,4,6,4,5,7,6,6,6,7,6,6,5,6,6,6,5,4,5,5,7,10,9,6,8,6,8,8,7,6,5,5,7,6,5,7,6,5,8,8,7,8,7,7,7,6,8,8,7,8,7,7,6,6,7,7,7,8,7,5,6,7,5,5,6,7,6,6,8,12", "code": "\nfrom sympy import factorint\ndef A308190(n):\n    c, x = 0, n\n    while x != 5:\n        y = min(factorint(x))\n        x = y + x//y\n        c += 1\n    return c \n"}
{"sequence_id": "A308194", "text": "Number of steps to reach 5 when iterating x -> A063655(x) starting at x=n.", "sequence": "0,1,3,2,2,4,5,4,4,3,3,3,4,3,4,3,5,5,6,5,5,4,5,6,7,6,6,5,4,5,5,5,7,6,4,5,6,5,5,4,4,6,5,4,4,4,4,5,5,4,4,4,6,7,5,4,6,5,4,4,4,5,7,6,5,5,6,5,6,5,4,7,4,5,5,4,4,6,6,5,6,5,6,5,6,5,4,6,6,5,6,4,7,6,4,4,8,7,7,6,6,5", "code": "\nfrom sympy import divisors\ndef A308194(n):\n    c, x = 0, n\n    while x != 5:\n        d = divisors(x)\n        l = len(d)\n        x = d[(l-1)//2] + d[l//2]\n        c += 1\n    return c \n"}
{"sequence_id": "A308249", "text": "Squares of automorphic numbers in base 12 (cf. A201918).", "sequence": "0,1,16,81,4096,6561,263169,1478656,40960000,205549569,54988374016,233605955584,6263292059649,303894740860929,338531738189824,170196776412774400,709858175909625856,18638643564726714369,124592287100855910400,2576097707358918017025,479214351668445504864256", "code": "\ndig = \"0123456789AB\"\ndef To12(n):\n    s = \"\"\n    while n > 0:\n        s, n = dig[n%12]+s, n//12\n    return s\nn, m = 1, 0\nprint(n,m*m)\nwhile n < 100:\n    m = m+1\n    m2, m1 = To12(m*m), To12(m)\n    i, i2, i1 = 0, len(m2), len(m1)\n    while i < i1 and (m2[i2-i-1] == m1[i1-i-1]):\n        i = i+1\n    if i == i1:\n        print(n,m*m)\nn = n+1 \n"}
{"sequence_id": "A308391", "text": "Number of ordered pairs of n-digit positive integers the product of which is a 2n-digit integer.", "sequence": "58,6610,668843,66965113,6697324753,669740590290,66974140069358,6697414817000983,669741489800555031,66974149061059480123", "code": "\nimport math\nende = 1\nfor i in range(1,10):\n   anz = 0\n   for a in range(ende, 10*ende):\n      z = math.ceil((ende*ende*10)/a)\n      if z < ende*10:\n         anz = anz + ende*10 - z\n   ende = ende*10\n   print(i, anz)\n"}
{"sequence_id": "A308395", "text": "Numbers y such that x*(x+1) + y*(y+1) = z*(z+1) is solvable in positive integers x, z with x <= y.", "sequence": "2,5,6,9,10,13,14,17,18,20,21,22,24,25,26,27,29,30,33,34,35,37,38,39,41,42,44,45,46,48,49,50,51,53,54,55,56,57,58,61,62,65,66,68,69,70,73,74,75,76,77,78,80,81,82,84,85,86,89,90,91,92,93,94,95,97", "code": "\nfrom sympy import integer_nthroot\nA308395_list, y, w = [], 1, 0\nwhile len(A308395_list) < 10000:\n    w += y\n    z = 0\n    for x in range(1,y+1):\n        z += x\n        if integer_nthroot(8*(w+z)+1,2)[1]:\n            A308395_list.append(y)\n            break\n    y += 1 \n"}
{"sequence_id": "A308416", "text": "Values of m for which 2*p + m cannot be a square when p is a prime.", "sequence": "1,4,8,9,13,16,17,20,24,25,28,29,33,36,37,40,41,44,48,49,52,53,56,57,61,64,65,68,69,72,73,76,80,81,84,85,88,89,92,93,97,100,101,104,105,108,109,112,113,116,120,121,124,125,128,129,132,133,136,137,141,144,145,148,149", "code": "\na=[]\na.append(0) \niMax=15 \nfor i in range(1,iMax+1):\n  for j in range(0,i):\n   m=i*i+j*4\n   a.append(m)\na.sort()\n"}
{"sequence_id": "A308438", "text": "a(n) is the smallest prime p whose decimal expansion begins with n and is such that the next prime is p+2n, or -1 if no such prime exists.", "sequence": "11,223,31,401,547,619,773,8581,9109,10223,1129,12073,130553,14563,150011,161471,17257,18803,191189,20809,210557,225383,237091,240209,2509433,2613397,277429,283211,2901649,308153,313409,3204139,3300613,3419063,3507739,360091,3727313,3806347,3930061,4045421,41018911", "code": "\nfrom sympy import nextprime\ndef A308438(n):\n    l, p = 1, nextprime(n)\n    while True:\n        q = nextprime(p)\n        if q-p == 2*n:\n            return p\n        p = q\n        if p >= (n+1)*l:\n            l *= 10\n            p = nextprime(n*l) \n"}
{"sequence_id": "A308439", "text": "a(n) is the smallest prime factor of 1 + the product of primes indexed by the binary digits of n.", "sequence": "3,2,7,2,11,2,31,2,3,2,43,2,71,2,211,2,23,2,67,2,3,2,331,2,5,2,463,2,3,2,2311,2,3,2,79,2,131,2,17,2,3,2,547,2,911,2,2731,2,7,2,859,2,3,2,7,2,2003,2,6007,2,3,2,59,2,5,2,103,2,3,2,7,2,239", "code": "\nfrom functools import reduce\nfrom operator import mul\nfrom sympy import prime, primefactors\ndef A308439(n):\n    return min(primefactors(1 + reduce(mul,(prime(i+1) for i,j in enumerate(bin(n)[:1:-1]) if j == '1')))) \n"}
{"sequence_id": "A308465", "text": "Number of prefix normal palindromes of length n.", "sequence": "2,2,3,3,5,4,8,7,12,11,21,18,36,31,57,55,104,91,182,166,308,292,562,512,1009,928,1755,1697,3247,2972,5906,5555,10506,10099,19542,18280,36002,33895,64958,63045,121887,114032,226065,215377,412749,399334,778196,735941", "code": "\nfrom itertools import product\ndef is_prefix_normal(w):\n  for k in range(1, len(w)+1):\n    weight0 = w[:k].count(\"1\")\n    for j in range(1, len(w)-k+1):\n      weightj = w[j:j+k].count(\"1\")\n      if weightj > weight0: return False\n  return True\ndef bin_pals(digits):\n  midrange = [[\"\"], [\"0\", \"1\"]]\n  for p in product(\"01\", repeat=digits//2):\n    left = \"\".join(p)\n    for middle in midrange[digits%2]:\n      yield left+middle+left[::-1]\ndef a(n):\n  return sum(is_prefix_normal(w) for w in bin_pals(n))\nprint([a(n) for n in range(1, 31)]) \n"}
{"sequence_id": "A308470", "text": "a(n) = (gcd(phi(n), 4*n^2 - 1) - 1)/2, where phi is A000010, Euler's totient function.", "sequence": "0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,0,0,1,0,0,2,0,0,0,1,0,1,0,0,1,0,2,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,7,0,0,1,0,1,0,0,1,0,0,1,1,0,4,7,0,1,0,0,2,0,0,0,1,3,2,0,0,1,0,2,0,4", "code": "\nfrom fractions import gcd\ndef A000010(n):\n    if n == 1:\n        return 1\n    d, m = 1, 0\n    while d < n:\n        if gcd(d,n) == 1:\n            m = m+1\n        d = d+1\n    return m\nn = 0\nwhile n < 30:\n    n = n+1\n    print(n,(gcd(A000010(n),4*n**2-1)-1)//2) \n"}
{"sequence_id": "A308472", "text": "Numbers that are divisible by the sum of the digits of the product of their digits.", "sequence": "1,2,3,4,5,6,7,8,9,11,12,15,24,25,28,36,52,54,63,99,111,112,115,125,126,132,138,152,154,156,162,165,168,182,187,189,198,212,215,216,224,234,251,252,255,261,264,276,279,297,312,318,324,333,342,354,369,372,396,432,441", "code": "\ndef dprod(n):\n....x = str(n)\n....start = 1\n....for q in x:\n........start *= int(q)\n....return start\ndef dsum(n):\n....x = str(n)\n....start = 0\n....for q in x:\n........start += int(q)\n....return start\nseq_1 = [n for n in range(1,10000) if dprod(n) != 0 and n % (dsum(dprod(n))) == 0]\nprint(seq_1)\n"}
{"sequence_id": "A308507", "text": "a(n) = (a(n-1) + a(n-2))^4, for n >= 2; a(0)=0, a(1)=1.", "sequence": "0,1,1,16,83521,48698490414981476161,5624216052381164150697569400035392464306474190030694298257503425709420810383376", "code": "\nf0 = 0\nf1 = 1\nnext_val = (f0+f1)**4\ni = 0\nwhile i <= 10:\n     next_val = (f0+f1)**4\n     f0 = f1\n     f1 = next_val\n     i = i+1\n     print(next_val)\n"}
{"sequence_id": "A308575", "text": "a(n) is the least positive even number k such that among the first k prime numbers there are exactly k/2 prime numbers where the n-th least significant bit is one, or a(n) = -1 if no such k exists.", "sequence": "2,2946,4,18,830,86,342,498,36002,2310,14660,3791908,138060,160110,998836,4345842,357341648,56717562,36609556,5972021576,2654687244,8237027666,22719286202,1542163060562,222365303318", "code": "\nfrom sympy import primepi\ndef A308575(n):\n    n2, t1 = 2**(n-1), 0\n    k = n2 - 1\n    kp = primepi(k)\n    kp2 = primepi(k+n2)-kp\n    while kp2 < kp or t1 >= kp:\n        k += n2\n        t1, t2 = kp, kp2\n        kp2 = primepi(k+n2) - kp2\n        kp = t2\n    return 2*kp \n"}
{"sequence_id": "A308619", "text": "Negative van Eck's sequence: For n >= 1, if there exists an m < n such that a(m) = a(n), take the largest such m and set a(n+1) = n-m, otherwise a(n+1) = -a(n). Start with a(1)=0.", "sequence": "0,0,1,-1,1,2,-2,2,2,1,5,-5,5,2,5,2,2,1,8,-8,8,2,5,8,3,-3,3,2,6,-6,6,2,4,-4,4,2,4,2,2,1,22,-22,22,2,5,22,3,20,-20,20,2,7,-7,7,2,4,19,-19,19,2,5,16,-16,16,2,5,5,1,28,-28,28,2,7,19,15,-15,15,2,6,48,-48,48,2,5,17,-17,17,2,5,5,1,23,-23,23,2,7,23,3,51,-51", "code": "\nimport numpy as np\ndef A308619(n):\n    NegVanEck = np.array([0])\n    \n    i=NegVanEck[0]\n    while i < n:\n        last = NegVanEck[-1]\n        pos = np.where(NegVanEck == last)\n        if pos[0].size == 1:\n            NegVanEck = np.append(NegVanEck, -last)\n        else:\n            NegVanEck = np.append(NegVanEck, pos[0][-1] - pos[0][-2])\n        i += 1\n    return NegVanEck\nprint(A308619(1000)) \n"}
{"sequence_id": "A308651", "text": "a(n+1) = k(a(n), n), where k(m, n) = (m*n) mod (m+n) and with a(1) = 5.", "sequence": "5,5,3,3,5,5,8,11,12,3,4,14,12,6,4,3,10,8,14,2,18,27,6,22,22,33,32,38,8,10,20,8,16,38,68,11,20,56,60,63,48,10,4,31,14,40,34,59,50,74,104,34,48,19,4,43,32,44,2,57,27,63,31,73,14,41,31,19,74,101,59,29,68,29,86,10,72,31,20,95,75,147,146,210,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", "code": "\ndef k(a,b):\n    return (a*b)%(a+b)\na = [5]\nfor n in range(1, 100):\n    a.append(k(a[-1], n))\nprint(a)\n"}
{"sequence_id": "A308673", "text": "For n > 2, if there exists an m < n such that a(m) = a(n), take the largest such m and set a(n+1) = a(n)+(n-m); otherwise a(n+1) = 1. Start with a(1)=0, a(2)=0.", "sequence": "0,0,1,1,2,1,3,1,3,5,1,4,1,3,8,1,4,9,1,4,7,1,4,7,10,1,5,22,1,4,11,1,4,7,17,1,5,15,1,4,11,21,1,5,12,1,4,11,18,1,5,12,19,1,5,9,47,1,5,9,13,1,5,9,13,17,48,1,7,42", "code": "\ndef Prog(length):\n    L = 2\n    seq = [0,0]\n    while L < length:\n        x = len(seq)-1\n        while x > 0:\n            if seq[-1] == seq[x-1]:\n                m = len(seq)-x\n                a_n = seq[L-1]\n                seq.append(a_n+m)\n                x = -1\n            else:\n                x -= 1\n            if x == 0:\n                seq.append(1)\n        L += 1\n    return seq\n"}
{"sequence_id": "A308705", "text": "Decimal expansion of the constant formed by concatenating the terms of A076478 (binary vectors of lengths 1, 2, 3, ... in numerical order).", "sequence": "2,7,6,3,8,7,1,1,7,2,7,9,4,8,6,5,2,3,7,3,4,1,9,8,6,7,6,2,1,1,9,0,1,2,3,0,5,5,5,0,8,9,9,8,8,1,6,0,6,8,5,5,0,6,1,4,3,6,7,6,8,1,9,1,1,5", "code": "\nfrom bigfloat import *\nimport string\ndef GenerateBitstring(bitstring, suffix, recurse):\n    if recurse == 0:\n        bitstring = bitstring + suffix\n    else:\n        bitstring = GenerateBitstring(bitstring, suffix + \"0\", recurse-1)\n        bitstring = GenerateBitstring(bitstring, suffix + \"1\", recurse-1)\n    return bitstring\nVulcanBinary = \"\"\nMaxRecursion = 8\nfor i in range(1,MaxRecursion+1):\n    VulcanBinary = GenerateBitstring(VulcanBinary, \"\", i)\nprint('.' + VulcanBinary)\nwith precision(2000):\n    VulcanDecimal = BigFloat(0)\n    b = BigFloat(1)\n    for c in VulcanBinary:\n        b = b/2.\n        if c == '1':\n            VulcanDecimal = VulcanDecimal+b\nprint(VulcanDecimal)\nprint(string.join(x + ',' for x in str(VulcanDecimal)[2:]))\n"}
{"sequence_id": "A308736", "text": "Numbers n such that n, n+2, n+4, n+6 are of the form p^2*q where p and q are distinct primes.", "sequence": "2523,3112819,5656019,10132171,12167825,16639567,25302173,31995475,35158921,37334419,43890719,44816821,47715269,53548223,55534523,90526075,90533525,127558319,142929025,143167073,144989575,147182225", "code": "\nfrom sympy import factorint\nA308736_list, n, m = [], 3, [False]*4\nwhile len(A308736_list) < 100:\n    if mlist[0] and mlist[1] and mlist[2] and mlist[3]:\n        A308736_list.append(n)\n    n += 2\n    f = factorint(n+6)\n    mlist = mlist[1:] + [(len(f),sum(f.values())) == (2,3)] \n"}
{"sequence_id": "A308777", "text": "Number of twin primes between p and p^2 (inclusive) where p is the n-th prime.", "sequence": "1,3,6,9,16,19,32,35,42,58,61,82,96,101,122,148,174,183,220,242,247,276,304,332,374,404,417,436,447,468,552,576,630,641,730,749,788,822,864,910,960,985,1082,1095,1134,1149,1252,1370,1416,1433,1464,1528,1545,1636,1702", "code": "\nfrom sympy import prime, prevprime, nextprime\ndef A308777(n):\n    if n == 1:\n        return 1\n    c, p = 0, prime(n)\n    p2, x = p**2, [prevprime(p), p , nextprime(p)]\n    while x[1] <= p2:\n        if x[1] - x[0] == 2 or x[2] - x[1] == 2:\n            c += 1\n        x = x[1:] + [nextprime(x[2])]\n    return c \n"}
{"sequence_id": "A308818", "text": "a(n) = a(a(n-1) mod n) + a(a(n-2) mod n) with a(0)=2 and a(1)=3.", "sequence": "2,3,5,7,10,7,13,15,22,23,12,6,15,18,13,25,41,37,10,22,17,40,47,40,81,38,22,53,85,134,51,29,156,215,23,47,46,35,69,98,144,81,108,116,102,37,47,37,72,75,85,104,217,111,10,15,37,60,40,147,197,51,110", "code": "\na = [2, 3]\nfor n in range(2, 10**4 + 3):\n    a.append(a[(a[n - 1] % n)] + a[(a[n - 2] % n)])\n    print((n - 2), \",\", a[n - 2], sep=\"\")\n"}
{"sequence_id": "A308832", "text": "Numbers that are palindromic in bases 3, 9 and 27.", "sequence": "0,1,2,4,8,10,20,364,728,730,1460,2920,5840,7300,7381,7462,14600,14681,14762,265720,531440,531442,532171,532900,1062884,1063613,1064342,2125768,2128684,2131600,4251536,4254452,4257368,5314420,5321710,5329000,5373550,5380840,5388130,5432680,5439970,5447260", "code": "\ndef nextpal(n,base): \n    m, pl = n+1, 0\n    while m > 0:\n        m, pl = m//base, pl+1\n    if n+1 == base**pl:\n        pl = pl+1\n    n = n//(base**(pl//2))+1\n    m, n = n, n//(base**(pl%2))\n    while n > 0:\n        m, n = m*base+n%base, n//base\n    return m\ndef rev(n,b):\n    m = 0\n    while n > 0:\n        n, m = n//b, m*b+n%b\n    return m\nn, a = 1, 0\nwhile n <= 20000:\n    if a == rev(a,9) and a == rev(a,3):\n        print(n,a)\n        n = n+1\n    a = nextpal(a,27)\n"}
{"sequence_id": "A308918", "text": "a(n) is the number of palindromic numbers with 7 digits in base n which are also palindromic in base n+1.", "sequence": "0,0,1,2,7,8,13,18,27,35,50,61,75,79,96,113,120,150,173,180,204,227,245,274,295,318,346,363,398,438,448,484,524,537,584,625,648,707,749,771,830,882,914,983,1041,1073,1143,1207,1238,1307,1372,1405,1480,1544,1573,1645", "code": "\ndef nextpal(n,base): \n    m, pl = n+1, 0\n    while m > 0:\n        m, pl = m//base, pl+1\n    if n+1 == base**pl:\n        pl = pl+1\n    n = n//(base**(pl//2))+1\n    m, n = n, n//(base**(pl%2))\n    while n > 0:\n        m, n = m*base+n%base, n//base\n    return m\ndef ispal(n,b):\n    if n%b == 0:\n        return 0\n    else:\n        nn, m = n, 0\n        while n > 0:\n            n, m = n//b, m*b+n%b\n        return m == nn\nn, d = 1, 7\nwhile n < 20000:\n    n = n+1\n    p = n**(d-1)-1\n    a = 0\n    while p < n**d:\n        p = nextpal(p,n+1)\n        if ispal(p,n):\n            a = a+1\n    print(n,a)\n"}
{"sequence_id": "A308935", "text": "a(n) is the smallest m > n such that n^2*(n^2 + 1) divides m^2*(m^2 + 1).", "sequence": "2,8,12,64,18,216,35,112,360,818,660,348,208,2744,693,4096,493,450,3420,4832,1071,2112,1242,13824,7800,17576,1998,4368,10133,1560,1178,1280,3597,3060,8582,46656,5032,1292,29640,12768,1189,14868,3182,13112,36468,6670", "code": "\ndef A308935(n):\n    n2, m, m2 = n**2*(n**2+1), n+1, ((n+1)**2*((n+1)**2+1)) % (n**2*(n**2+1))\n    while m2:\n        m2, m = (m2 + 2*(2*m+1)*(m**2+m+1)) % n2, (m+1) % n2\n    return m \n"}
{"sequence_id": "A309000", "text": "Number of strings of length n from a 3 symbol alphabet (A,B,C, say) containing at least one \"A\" and at least two \"B\"s.", "sequence": "3,22,105,416,1491,5034,16365,51892,161799,498686,1524705,4635528,14037627,42391378,127763925,384536924,1156232175,3474201510,10434138825,31326533680,94029932643,282194655482,846802070205,2540859195396,7623517110231,22872497487694", "code": " [3**n-2**(n+1)-n*2**(n-1)+n+1 for n in range(3,20)]\n"}
{"sequence_id": "A309007", "text": "Largest k such that n^k has distinct digits in base 10 (for n>1).", "sequence": "29,9,10,8,4,8,5,3,1,0,4,4,5,1,5,6,4,3,1,3,3,4,3,4,1,3,2,3,1,2,4,2,1,3,2,2,5,1,1,3,2,2,4,1,1,1,4,4,1,2,2,2,2,2,1,2,1,3,1,2,1,1,2,1,3,1,1,3,1,2,2,3,2,3,3,0,2,2,1,1,2,1,3,1,2,2", "code": "\ndef distinct_digits(n):\n    p = math.floor(math.log(10**10)/math.log(n))\n    while p >= 1:\n        d = n**p\n        if len(set(str(d))) == len(str(d)):\n            return(p)\n        else:\n            p = p - 1\n    return(0)\n"}
{"sequence_id": "A309023", "text": "For n >= 1, if there exists an m < n such that a(m) = a(n), take the largest such m and set a(n+1) = (n-m)^a(n); otherwise a(n+1) = 0. Start with a(1)=1, a(2)=2.", "sequence": "1,2,0,0,1,4,0,1,3,0,1,3,27,0,1,4,10000,0,1,4,256,0,1,4,256", "code": "\ndef Prog(length):\n    L = 2\n    seq = [1,2]\n    while L < length:\n        x = len(seq)-1\n        while x > 0:\n            if seq[-1] == seq[x-1]:\n                m_minus_n = len(seq)-x\n                a_n = seq[L-1]\n                seq.append((m_minus_n)**a_n)\n                x = -1\n            else:\n                x -= 1\n            if x == 0:\n                seq.append(0)\n        L += 1\n    return seq\n"}
{"sequence_id": "A309080", "text": "Product minus sum of all previous terms in the sequence, starting with a(1) = 2 and a(2) = 5.", "sequence": "2,5,3,20,570,341400,116758458000,13632577445813641200000,185847167817698504752014113195034069600000000,34539169785859790805229099212216829464451540660176789302662465332580254227520000000000000", "code": "\na, n, p, s = [2,5], 2, 2, 2\nwhile n < 10:\n    p, s, n = p*a[len(a)-1], s+a[len(a)-1], n+1\n    a = a+[p-s]\nfor n in range(1, 11): print(a[n-1], end=', ') \n"}
{"sequence_id": "A309092", "text": "Integers whose hexadecimal representation contains a run of zeros of prime length.", "sequence": "256,512,768,1024,1280,1536,1792,2048,2304,2560,2816,3072,3328,3584,3840,4096,4097,4098,4099,4100,4101,4102,4103,4104,4105,4106,4107,4108,4109,4110,4111,4352,4608,4864,5120,5376,5632,5888,6144,6400,6656,6912,7168", "code": "\nfrom re import split\nfrom sympy import isprime\nseq_list, n = [],1\nwhile len(seq_list) < 10000:\n    for d in split('[1-9]+|[a-f]+', format(n,'x')):\n        if isprime(len(d)):\n            seq_list.append(n)\n    n += 1\n"}
{"sequence_id": "A309154", "text": "Function of natural numbers satisfying the properties a(2*n) = 2*a(n) and a(2*n+1) = -3 + 2*a(3*n+2).", "sequence": "0,1,2,23,4,13,46,1595,8,6377,26,799,92,101,3190,3283,16,401,12754,12775,52,61,1598,1643,184,51097,202,946891009738223808271,6380,6389,6566,118361376217277976035,32,204385,802,823,25508,25517,25550,6540635,104,473445504869111904137", "code": "\ndef a(x):\n    if x <= 1: return x\n    elif x%2: return -3 + 2 * a((3*x + 1)//2)\n    else: return 2*a(x//2)\n"}
{"sequence_id": "A309179", "text": "Primes to which a record size square needs to be added to reach another prime.", "sequence": "2,3,5,29,41,389,479,881,1931,3461,3701,7589,9749,26171,153089,405701,1036829,1354349,1516829,2677289,4790309,4990961,34648631,46214321,50583209,98999969,305094851,331498961,362822099,4373372351,11037674441,12239355719,16085541359", "code": "\nfrom sympy import isprime, nextprime\nn, p, r = 0, 0, 0\nwhile(True):\n....p = nextprime(p) ; k = 1\n....while not isprime(p + k**2):\n........k += 1\n....if k > r:\n........n += 1 ; r = k\n........print(\"a({}) = {}\".format(n,p))\n"}
{"sequence_id": "A309233", "text": "Lexicographically earliest increasing sequence such that n-th term is divisible by all positive integers up to n.", "sequence": "1,2,6,12,60,120,420,840,2520,5040,27720,55440,360360,720720,1081080,1441440,12252240,24504480,232792560,465585120,698377680,931170240,5354228880,10708457760,26771144400,53542288800,80313433200,160626866400,2329089562800,4658179125600,72201776446800", "code": "\nx = [1] \ny = [1] \nN = 20 \nwhile len(x) < N:\n    x.append(x[-1] + 1)\n    \n    \n    z = y[-1]//x[-1] * x[-1] + x[-1]\n    \n    \n    while any([z%i != 0 for i in x]):\n        z += x[-1]\n    y.append(z)\n    print(\"{}\\t {}\\t\".format(len(x),z))\n"}
{"sequence_id": "A309288", "text": "a(0) = 0, a(1) = 1, and for any n > 1, a(n) = Sum_{k > 1} (-1)^k * a(floor(n/k)).", "sequence": "0,1,1,0,1,0,0,-1,1,1,1,0,-1,-2,-2,-1,3,2,2,1,0,1,1,0,-2,-2,-2,-2,-3,-4,-4,-5,3,4,4,5,5,4,4,5,3,2,2,1,0,0,0,-1,-5,-5,-5,-4,-5,-6,-6,-5,-7,-6,-6,-7,-6,-7,-7,-7,9,10,10,9,8,9,9,8,8,7,7,7", "code": "\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef A309288(n):\n    if n <= 1:\n        return n\n    c, j = 0, 2\n    k1 = n//j\n    while k1 > 1:\n        j2 = n//k1 + 1\n        c += ((j2-j)%2)*(1-2*(j%2))*A309288(k1)\n        j, k1 = j2, n//j2\n    return c+((n+1-j)%2)*(1-2*(j%2)) \n"}
{"sequence_id": "A309320", "text": "a(n) is the smallest positive integer m such that the digits of n in base 10 are also the first digits of sin(m) in base 10 after the decimal point.", "sequence": "0,3,6,53,9,10,7,4,1,2,91,69,47,25,3,41,63,85,107,129,151,160,138,116,94,72,50,6,16,38,60,82,104,148,170,163,141,97,75,53,31,9,13,57,79,101,145,167,166,122,100,78,34,12,10,32,76,98,120,164,147,125,81", "code": " import numpy as np\nimport math as m\nn = 1\ni = 0\ninp = np.zeros(1)\nout = inp\nwhile n < 10001:\n    k=m.fabs( m.trunc( m.sin(i) * m.pow( 10,m.floor( m.log10(n)+1 ) ) ) )\n    if k==n:\n        inp = np.append(inp,int(n))\n        out = np.append(out,int(i))\n        print(n,i)\n        n += 1\n        i = 0\n        continue\n    else:\n        i+=1\n"}
{"sequence_id": "A309372", "text": "a(n) = n^2 - n^3 + n^4.", "sequence": "0,1,12,63,208,525,1116,2107,3648,5913,9100,13431,19152,26533,35868,47475,61696,78897,99468,123823,152400,185661,224092,268203,318528,375625,440076,512487,593488,683733,783900,894691,1016832,1151073,1298188,1458975,1634256,1824877,2031708,2255643,2497600", "code": "\nfor x in range(100):\n    print((x**2)-(x**3)+(x**4))\n"}
{"sequence_id": "A309388", "text": "Numbers y such that x*(x+1) + y*(y+1) = z*(z+1) does not have a solution in positive integers x, z with x <= y.", "sequence": "1,3,4,7,8,11,12,15,16,19,23,28,31,32,36,40,43,47,52,59,60,63,64,67,71,72,79,83,87,88,96,100,103,107,108,112,127,128,131,136,139,148,151,156,163,167,172,176,179,180,183,187,191,192,196,199,211,223,227", "code": "\nfrom sympy import integer_nthroot\nA309388_list, y, w = [], 1, 0\nwhile len(A309388_list) < 10000:\n    w += y\n    z = 0\n    for x in range(1,y+1):\n        z += x\n        if integer_nthroot(8*(w+z)+1,2)[1]:\n            break\n    else:\n        A309388_list.append(y)\n    y += 1 \n"}
{"sequence_id": "A309397", "text": "a(n) = gcd(n^2, A001008(n-1)) for n > 1.", "sequence": "1,3,1,25,1,49,1,1,1,121,1,169,1,1,1,289,1,361,1,1,1,529,1,5,1,1,1,841,1,961,1,1,1,1,1,1369,1,1,1,1681,1,1849,1,1,1,2209,1,7,1,1,1,2809,1,1,1,1,1,3481,1,3721,1,1,1,1,1,4489,1,1,1,5041,1,5329", "code": "\nfrom sympy import gcd, harmonic\ndef A309387(n):\n    return gcd(n**2,harmonic(n-1).p) \n"}
{"sequence_id": "A309408", "text": "Start with X = F(n) = A000045(n). Repeatedly replace X with X - ceiling(X/n); a(n) is the number of steps to reach 0.", "sequence": "0,1,1,2,3,5,7,10,13,18,23,29,36,44,53,63,74,85,98,111,125,140,157,174,192,211,231,251,273,296,319,343,369,395,423,451,481,510,541,573,606,640,675,710,747,785,823,863,903,944,987,1030,1074,1119,1165,1212,1260,1309,1359,1409,1462,1514,1568,1622,1678,1734,1791", "code": "\nn, f1, f0 = 0, 0, 1\nwhile n <= 20000:\n    fn, a = f1, 0\n    while fn > 0:\n        fn, a = fn - (fn+n-1)//n, a+1\n    print(n,a)\n    n, f1, f0 = n+1, f0, f1+f0\n"}
{"sequence_id": "A309417", "text": "Number of steps needed to reduce 10^n to zero by subtracting its digital sum.", "sequence": "2,11,81,611,4798,39320,333583,2897573,25632474,230231687,2091437006,19145032382,176258021378,1630867803755,15161044498785", "code": "\nimport math\ndef digitsum(n):\n   ds = 0\n   while n > 0:\n      ds += n % 10\n      n = n // 10\n   return ds\ndef steps(n):\n   count = 0\n   while n > 0:\n      n = n - digitsum(n)\n      count += 1\n   return count\nn = 1\nfor i in range(1,10):\n   n = 10 * n\n   print(steps(n))\n"}
{"sequence_id": "A309434", "text": "a(n) = floor(n*Im(2*e^(i*Pi/5))/(Im(2*e^(i*Pi/5)) - 1)).", "sequence": "6,13,20,26,33,40,46,53,60,66,73,80,87,93,100,107,113,120,127,133,140,147,154,160,167,174,180,187,194,200,207,214,220,227,234,241,247,254,261,267,274,281,287,294,301,308,314,321,328,334,341", "code": "\nfrom sympy import floor, im, exp, I, pi\nfor n in range(1, 101): print(floor(n*im(2*exp(I*pi/5))/(im(2*exp(I*pi/5)) - 1)), end=', ')\n"}
{"sequence_id": "A309434", "text": "a(n) = floor(n*Im(2*e^(i*Pi/5))/(Im(2*e^(i*Pi/5)) - 1)).", "sequence": "6,13,20,26,33,40,46,53,60,66,73,80,87,93,100,107,113,120,127,133,140,147,154,160,167,174,180,187,194,200,207,214,220,227,234,241,247,254,261,267,274,281,287,294,301,308,314,321,328,334,341", "code": "\nfrom sympy import floor, sqrt\nfor n in range(1, 101): print(floor(n*((5 + sqrt(5))/2 + sqrt(5 + 2*sqrt(5)))), end=', ')\n"}
{"sequence_id": "A309574", "text": "n-th prime minus its ternary (base 3) reversal.", "sequence": "0,2,-2,2,-8,0,-8,8,0,-26,-6,6,-26,-6,-14,-26,-6,14,26,-6,38,26,-80,-128,-48,-80,-24,-128,24,-80,24,-80,-32,24,-56,0,24,80,-24,0,-48,80,24,80,-24,104,80,80,48,104,0,24,80,-398,-338,-278,-434,18,-138", "code": "\nfrom sympy import primerange\ndef rev(n, b):\n    m = 0\n    while n > 0:\n        m, n = m*b+n%b, n//b\n    return m\nn, aa = 1, 1\nwhile n <20:\n    if aa in primerange(1,200):\n        print(n, aa-rev(aa, 3))\n        n = n+1\n    aa = aa+1 \n"}
{"sequence_id": "A309596", "text": "If a(n) is not a term of a(0..n-1), then a(n+1) = a(n) - a(n - a(n)); otherwise a(n+1) is the number of terms equal to a(n) in a(0..n-1). Start with a(0)=0, a(1)=0.", "sequence": "0,0,1,1,1,2,1,3,2,1,4,3,1,5,3,2,2,3,3,4,1,6,4,2,4,3,5,1,7,1,8,4,4,5,2,5,3,6,1,9,1,10,6,2,6,3,7,1,11,5,4,6,4,7,2,7,3,8,1,12,11,1,13,8,2,8,3,9,1,14,7,4", "code": "\nsa, n = [0], 0\nprint(n,sa[n])\nwhile n < 50:\n    i, j = 0, 0\n    while i < n:\n        if sa[i] == sa[n]:\n            j = j+1\n        i = i+1\n    if j == 0:\n        a = sa[n] - sa[n-sa[n]]\n    else:\n        a = j\n    n = n+1\n    print(n,a)\n    sa = sa+[a] \n"}
{"sequence_id": "A309655", "text": "The smallest possible nonnegative difference between the sum of the first n primes (A007504) and the sum of any number of the directly following and consecutive primes.", "sequence": "0,2,0,3,6,15,5,16,25,3,20,39,13,36,61,17,50,6,39,76,14,53,102,28,75,132,46,101,158,46,99,174,64,145,27,114,193,51,144,239,93,194,24,135,244,74,179,294,116,253,43,162,291,61,196,337,101,250,395,139,282,427,149,324", "code": "\n\nfrom sympy import prime\nsumP=0\nfor i in range(1,101):\n  sumP+=prime(i)\n  j=i+1\n  diff=sumP\n  while diff-prime(j) >=0:\n   diff-=prime(j)\n   j+=1\n  print diff,',',\n"}
{"sequence_id": "A309701", "text": "Primes with record Manhattan distance from origin. When starting rightwards in a grid, turn left after a prime number. If not, walk straight on.", "sequence": "2,3,11,29,59,97,151,193,211,223,239,281,307,311,331,337,479,541,593,613,631,641,659,877,881,907,911,997,1409,1861,1907,2267,2281,2287,2309,2311,2503,2579,2609,2617,2657,2671,2677,3671,3691,3697,3727,3761,3767,3793,3797,4201,4327,4357,4391,4397,4507,4721,4751,4909", "code": "\ndef prime(z):\n    isPrime=True\n    for y in range(2,int(z**0.5)+1) :\n        if z%y==0:\n            isPrime=False\n            break\n    return isPrime\nm,n,g,h=[],[],[1,0,-1,0],[0,1,0,-1]\nfor c in range (2,10000):\n    if prime(c)==True:\n        m.append(c)\nca,cb,cc=2,0,0\nfor j in range(2,10000):\n    if j in m:\n        cc=cc+1\n        cd,ce=g[cc%4],h[cc%4]\n    ca,cb=ca+cd,cb+ce\n    n.append([j+1,ca,cb,abs(ca)+abs(cb)])\nv=2\nfor j in n:\n    if j[3]>v and j[0] in m:\n        print (j)\n        v=j[3]\n"}
{"sequence_id": "A309705", "text": "a(n) = lcm(a(n-1), n) - gcd(a(n-1), n) where a(1) = 1.", "sequence": "1,1,2,2,9,15,104,96,285,565,6214,37282,484665,6785309,101779634,814237070,13842030189,83052181131,1577991441488,7889957207436,55229700452049,1215053409945077,27946228428736770,111784913714947074,2794622842873676849,72660193914715598073", "code": "\ndef lcmMinusGcd(n):\n    retlist = [1]\n    for i in range(1, n):\n        g = gcd(retlist[i-1], i+1)\n        retlist.append( floor(retlist[i-1]*(i+1) / g) - g)\n    return ', '.join(map(str,retlist))\n"}
{"sequence_id": "A309707", "text": "a(n) is the least integer k > 1 such that k^n starts with 1.", "sequence": "10,4,5,2,4,5,2,6,3,2,3,4,3,2,3,5,2,6,3,2,3,4,5,2,4,5,2,8,5,2,6,3,5,2,4,3,2,3,5,2,8,3,5,2,4,5,2,10,5,2,7,10,3,2,3,5,2,6,3,2,3,6,3,2,3,5,2,10,5,2,6,6,5,2,4,3,2,3,5,2,6,3,5,2,4,3,2,10,5,2,8", "code": "\nprint(1,10)\nn = 1\nwhile n < 100:\n    n, p = n+1, 2\n    s = str(p**n)\n    while s[0] != \"1\":\n        p = p+1\n        s = str(p**n)\n    print(n,p) \n"}
{"sequence_id": "A309709", "text": "Number of binary digits that change when n is multiplied by 4.", "sequence": "0,2,2,4,2,2,4,4,2,4,2,4,4,4,4,4,2,4,4,6,2,2,4,4,4,6,4,6,4,4,4,4,2,4,4,6,4,4,6,6,2,4,2,4,4,4,4,4,4,6,6,8,4,4,6,6,4,6,4,6,4,4,4,4,2,4,4,6,4,4,6,6,4,6,4,6,6,6,6,6,2,4,4,6,2,2,4,4", "code": "\ndef A309709(n):\n    s = \"\"\n    while n > 0:\n        s, n = str(n%2)+s,n//2\n    s, s4, i, j = \"00\"+s, s+\"00\", 0, 0\n    while i < len(s):\n        if s[i] != s4[i]:\n            j = j+1\n        i = i+1\n    return j \n"}
{"sequence_id": "A309729", "text": "Expansion of Sum_{k>=1} x^k/(1 - x^k - 2*x^(2*k)).", "sequence": "1,2,4,7,12,26,44,92,175,354,684,1396,2732,5506,10938,21937,43692,87578,174764,349884,699098,1398786,2796204,5593886,11184823,22372354,44739418,89483996,178956972,357925242,715827884,1431677702,2863312218,5726666754,11453246178,22906581193", "code": "\nn = 1\nwhile n <= 36:\n    s, d = 0, 1\n    while d <= n:\n        if n%d == 0:\n            s = s+2**d-(-1)**d\n        d = d+1\n    print(n,s//3)\nn = n+1 \n"}
{"sequence_id": "A309735", "text": "a(n) is the least positive integer k such that k^n starts with 2.", "sequence": "2,5,3,4,3,8,3,2,4,7,2,5,9,4,9,6,7,2,4,21,2,5,7,3,5,3,8,2,4,3,2,5,11,4,5,7,8,2,6,23,2,5,6,14,3,16,3,2,3,14,2,4,15,17,5,7,4,2,11,18,2,4,47,14,5,6,4,2,7,3,2,3,13,3,5,15,4,8,6,9,2,4,11,6,5,22,4", "code": "\nn = 1\nwhile n < 100:\n    k, s = 2, str(2**n)\n    while s[0] != \"2\":\n        k = k+1\n        s = str(k**n)\n    print(n,k)\n    n = n+1 \n"}
{"sequence_id": "A309755", "text": "Primes with record Euclidean distance from the origin. When starting rightwards in a grid, turn left after a prime number, if not walk straight on.", "sequence": "2,3,11,29,59,97,149,151,191,193,211,223,239,263,281,307,311,331,337,593,613,631,641,653,659,853,857,877,881,907,911,967,971,991,997,1801,1811,1847,1861,1901,1907,2251,2267,2281,2287,2309,2311,2657,2671,2677,3163,3167,3187,3191,3299,3319,3343,3691,3697,3719,3727", "code": "\ndef prime(z):\n    isPrime=True\n    for y in range(2,int(z**0.5)+1) :\n        if z%y==0:\n            isPrime=False\n            break\n    return isPrime\nm,n, g,h=[],[],[1,0,-1,0],[0,1,0,-1]\nz=10000\nfor c in range (2,z):\n    if prime(c)==True:\n        m.append(c)\nca,cb,cc=2,0,0\nfor j in range(2,z):\n    if j in m:\n        cc=cc+1\n        cd,ce=g[cc%4],h[cc%4]\n    ca,cb=ca+cd,cb+ce\n    n.append([j+1,ca,cb,((ca)**2+(cb)**2)**(0.5)])\n    \nv=2\nfor j in n:\n    if j[3]>v and j[0] in m:\n        print (j)\n        v=j[3]\n"}
{"sequence_id": "A309815", "text": "a(n) is the smallest positive integer x such that sqrt(2) + sqrt(x) is closer to an integer than any other value already in the sequence.", "sequence": "1,2,3,6,7,13,21,112,243,275,466,761,1128,4704,9523,10730,17579,28085,41041,165312,331299,372815,607754,967441,1410360,5648160,11300259,12713402,20707831,32942845,48005301,192060400,384143763,432165299,703818922,1119543881,1631318640", "code": " import math\na = 2**(1/2)\nl = []\nclosest = 1.0\nfor i in range(1, 100000000):\n    b = i**(1/2)\n    c = abs(a+b - round(a+b))\n    if c < closest:\n        print(i, c)\n        closest = c\n        l.append(i)\nprint(l)\n"}
{"sequence_id": "A309828", "text": "Squares formed by concatenating k and 2*k+1.", "sequence": "25,49,1225,4489,112225,444889,11122225,44448889,816416329,1111222225,1451229025,3832476649,4444488889,111112222225,444444888889,10185602037121,11111122222225,44444448888889,46355849271169,997230019944601,1111111222222225,1231148024622961", "code": "\ndef Test(n):\n    s = str(n)\n    ps, ss = s[0:len(s)//2], s[len(s)//2:len(s)]\n    return int(ss) == 2*int(ps)+1 and s[len(s)//2] != \"0\"\nn, a = 1, 4\nwhile n < 23:\n    if Test(a*a):\n        print(n,a*a)\n        n = n+1\n    a = a+1 \n"}
{"sequence_id": "A309844", "text": "Primes of the form n^4 + n^2 + 3.", "sequence": "3,5,23,653,10103,83813,160403,234743,280373,1049603,3420653,6252503,11319863,52207853,92246423,146422103,174913853,221548343,442071653,479807123,577224653,607597853,655385603,937921253,1222865933,1249233683,1387525253,1506177293", "code": "\nfrom sympy import isprime\na = []\nfor n in range(0,1000):\n    x = n**4+n**2+3\n    if isprime(x):\n        a.append(x)\n"}
{"sequence_id": "A309851", "text": "Primes formed by concatenating n and 2n-1.", "sequence": "11,23,47,59,1019,1223,1427,1733,2039,2141,2243,2447,2549,2753,2957,3467,3671,4079,4283,4691,4793,5099,52103,55109,61121,65129,70139,75149,77153,82163,86171,95189,102203,104207,112223,119237,124247,130259,132263,137273,145289,146291,147293,149297,150299,160319", "code": "\nfrom sympy import isprime\nA309851_list = [m for m in (int(str(n)+str(2*n-1)) for n in range(1,10**5)) if isprime(m)] \n"}
{"sequence_id": "A309872", "text": "For each term, take the last digit of the previous term and count all the appearances of that digit up to and including the previous term; the first term is 1.", "sequence": "1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10,1,12,2,3,2,4,2,5,2,6,2,7,2,8,2,9,2,10,2,11,16,3,3,4,3,5,3,6,4,4,5,4,6,5,5,6,6,7,3,7,4,7,5,7,6,8,3,8,4,8,5,8,6,9,3,9,4,9,5,9,6,10,3,10,4,10,5,10,6,11,23,11", "code": "\ns, a, n = \"1\", [1], 1\nwhile n < 100:\n    n = n+1\n    d = s[len(s)-1]\n    i, aa = 0, 0\n    while i < len(s):\n        if s[i] == d:\n            aa = aa+1\n        i = i+1\n    s, a = s+str(aa), a+[aa]\nfor n in range(1, 92): print(a[n-1], end=', ') \n"}
{"sequence_id": "A309883", "text": "Numbers k such that A003132(k^2) = A003132(k), where A003132(n) is the sum of the squares of the digits of n.", "sequence": "0,1,10,35,100,152,350,377,452,539,709,1000,1299,1398,1439,1519,1520,1569,1591,1679,1965,2599,2838,3332,3500,3598,3770,4520,4586,4754,4854,5390,5501,5835,5857,6388,6595,6735,6861,6951,7090,7349,7887,8395,9795,10000,10056,10159,10389,11055,11091,12990,12999", "code": "\ndef A003132(n):\n    s = 0\n    while n > 0:\n        s, n = s+(n%10)**2, n//10\n    return s\nn, a = 0, 0\nwhile n < 50:\n    if A003132(a) == A003132(a*a):\n        n = n+1\n        print(n,a)\n    a = a+1 \n"}
{"sequence_id": "A309898", "text": "For each b = 1, 2, 3, ... numbers k = 1, 2, 3, ... are inserted into the blanks within the sequence along with k * b blanks, skipping existing terms in the sequence.", "sequence": "1,1,2,1,1,3,2,1,1,4,2,1,3,1,5,2,1,1,2,3,6,4,1,1,2,1,1,7,3,2,1,5,1,4,2,8,1,3,1,2,1,1,2,6,9,3,4,1,1,5,2,1,1,3,10,2,1,1,7,4,2,1,3,1,2,11,1,5,6,1,2,3,4,1,8,1,2,12,1,1,3,2,1,1,4,5,2,1,3,7,13", "code": "\nseq = []\nb = 2\nfor n in range(1, 100):\n  seq += [n] + [-1] * n\nwhile -1 in seq:\n  i = seq.index(-1)\n  seq[i] = 1\n  k = 2\n  blanks = b\n  for s in range(i + 1, len(seq)):\n    if seq[s] == -1:\n      blanks -= 1\n      if blanks < 0:\n        seq[s] = k\n        blanks = k * b\n        k += 1\n  b += 1\nprint(seq)\n"}
{"sequence_id": "A309899", "text": "Numbers k = 1, 2, 3, ... are added to the sequence along with k blanks. Next, the numbers k + 1 are inserted on the blanks along with k + 1 blanks. This process is then repeated.", "sequence": "1,2,2,3,4,3,3,5,6,4,4,4,7,8,5,5,9,5,5,10,6,6,11,12,6,6,6,7,7,13,14,8,7,7,15,8,7,7,16,9,17,8,8,18,9,10,8,8,8,19,20,9,9,11,10,21,22,9,9,12,9,9,10,10,23,11,24,13,25,10,10,11,26", "code": "\nseq = []\nfor n in range(1, 100): seq += [n] + n*[-1]\nfor n in range(2, len(seq)):\n  value = n\n  gaps = 0\n  position = n - 1\n  while position < len(seq):\n    if seq[position] == -1:\n      if gaps > 0: gaps -= 1\n      else:\n        seq[position] = value\n        gaps = value\n        value += 1\n    position += 1\nprint(seq)\n"}
{"sequence_id": "A309952", "text": "XOR contraction of binary representation of n.", "sequence": "0,1,1,0,2,3,3,2,2,3,3,2,0,1,1,0,4,5,5,4,6,7,7,6,6,7,7,6,4,5,5,4,4,5,5,4,6,7,7,6,6,7,7,6,4,5,5,4,0,1,1,0,2,3,3,2,2,3,3,2,0,1,1,0,8,9,9,8,10,11,11,10,10,11,11,10,8,9,9,8,12,13,13", "code": "\ndef a(n):\n    n = [int(k) for k in bin(n)[2:]]\n    if len(n) % 2 != 0:\n        n = [0] + n\n    result = []\n    for i in range(0, len(n), 2):\n        result.append(n[i] ^ n[i+1]) \n    return int(\"\".join([str(k) for k in result]), 2)\n"}
{"sequence_id": "A309983", "text": "Numbers n resulting from adding the exponents of 2 associated with the \"1\" terms of their binary representation and subtracting the exponents of 2 associated with the \"0\" terms of their binary representation.", "sequence": "0,1,1,1,1,3,3,0,0,2,2,4,4,6,6,-2,-2,0,0,2,2,4,4,4,4,6,6,8,8,10,10,-5,-5,-3,-3,-1,-1,1,1,1,1,3,3,5,5,7,7,3,3,5,5,7,7,9,9,9,9,11,11,13,13,15,15,-9,-9,-7,-7,-5,-5,-3,-3,-3,-3,-1", "code": "\ndef dec_to_bin(dec_num): \n    bin_num = 0\n    power = 0\n    while dec_num > 0:\n        bin_num += 10 ** power * (dec_num % 2)\n        dec_num //= 2\n        power += 1\n    return bin_num\ndef rev_bin(n):\n    return list(reversed(str(dec_to_bin(n))))\nn = 18\nneg = [pos for pos, num in enumerate(rev_bin(n)) if num == \"0\"]\nposi = [pos for pos, num in enumerate(rev_bin(n)) if num == \"1\"]\nprint(sum(posi)-sum(neg))\n"}
{"sequence_id": "A309983", "text": "Numbers n resulting from adding the exponents of 2 associated with the \"1\" terms of their binary representation and subtracting the exponents of 2 associated with the \"0\" terms of their binary representation.", "sequence": "0,1,1,1,1,3,3,0,0,2,2,4,4,6,6,-2,-2,0,0,2,2,4,4,4,4,6,6,8,8,10,10,-5,-5,-3,-3,-1,-1,1,1,1,1,3,3,5,5,7,7,3,3,5,5,7,7,9,9,9,9,11,11,13,13,15,15,-9,-9,-7,-7,-5,-5,-3,-3,-3,-3,-1", "code": "\ndef A309983(n):\n    r, i = 0, 0\n    while n > 0:\n        d, n = n%2, n//2\n        if d == 1:\n            r = r+i\n        else:\n            r = r-i\n        i = i+1\n    return r \n"}
