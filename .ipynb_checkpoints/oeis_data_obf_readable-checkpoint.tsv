Sequence number	Sequence name	Sequence	Python code	Obfuscated Python code
A000006	Integer part of square root of n-th prime.	1,1,2,2,3,3,4,4,4,5,5,6,6,6,6,7,7,7,8,8,8,8,9,9,9,10,10,10,10,10,11,11,11,11,12,12,12,12,12,13,13,13,13,13,14,14,14,14,15,15,15,15,15,15,16,16,16,16,16,16,16,17,17,17,17,17,18,18,18,18,18	"
from sympy import sieve
A000006 = lambda n: int(sieve[n]**.5)
print([A000006(n) for n in range(1,100+1)])

"	"from sympy import sieve
A000006 = lambda n: int(sieve[n] ** 0.5)
print([A000006(n) for n in range(1, 100 + 1)])"	"from sympy import sieve
A000006 = lambda n: int(sieve[n] ** 0.5)
print([A000006(n) for n in range(1, 100 + 1)])"	"from sympy import sieve
A000006 = lambda n: int(sieve[n] ** 0.5)
print([A000006(n) for n in range(1, 100 + 1)])"	"from sympy import sieve
A000006 = lambda n: int(sieve[n] ** 0.5)
print([A000006(n) for n in range(1, 100 + 1)])"	"from sympy import sieve
A000006 = lambda n: int(sieve[n] ** 0.5)
print([A000006(n) for n in range(1, 100 + 1)])"
A000042	Unary representation of natural numbers.	1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,11111111111,111111111111,1111111111111,11111111111111,111111111111111,1111111111111111,11111111111111111,111111111111111111,1111111111111111111,11111111111111111111	" def a(n): return int(""1""*n) 
"	"def a(n):
    return int('1' * n)"	"def a(n):
    return int('1' * n)"	"def a(n):
    return int('1' * n)"	"def a(n):
    return int('1' * n)"	"def a(n):
    return int('1' * n)"
A000045	Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.	0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155	" 
def fib():
    """""" Generates the Fibonacci numbers, starting with 0 """"""
    x, y = 0, 1
    while 1:
        yield x
        x, y = y, x+y
f = fib()
a = [next(f) for _ in range(100)]
def A000045(n):
    """""" Returns Fibonacci number with index n, offset 0 """"""
    return a[n]
def A000045_list(N):
    """""" Returns a list of the first n Fibonacci numbers """"""
    return a[:N]
"	"def fib():
    """""" Generates the Fibonacci numbers, starting with 0 """"""
    (x, y) = (0, 1)
    while 1:
        yield x
        (x, y) = (y, x + y)
f = fib()
a = [next(f) for _ in range(100)]

def A000045(n):
    """""" Returns Fibonacci number with index n, offset 0 """"""
    return a[n]

def A000045_list(N):
    """""" Returns a list of the first n Fibonacci numbers """"""
    return a[:N]"	"def fib():
    """""" Generates the Fibonacci numbers, starting with 0 """"""
    (x, y) = (0, 1)
    while 1:
        yield x
        (x, y) = (y, x + y)
f = fib()
a = [next(f) for _ in range(100)]

def A000045(n):
    """""" Returns Fibonacci number with index n, offset 0 """"""
    return a[n]

def A000045_list(N):
    """""" Returns a list of the first n Fibonacci numbers """"""
    return a[:N]"	"def fib():
    """""" Generates the Fibonacci numbers, starting with 0 """"""
    (x, y) = (0, 1)
    while 1:
        yield x
        (x, y) = (y, x + y)
f = fib()
a = [next(f) for _ in range(100)]

def A000045(n):
    """""" Returns Fibonacci number with index n, offset 0 """"""
    return a[n]

def A000045_list(N):
    """""" Returns a list of the first n Fibonacci numbers """"""
    return a[:N]"	"def fib():
    """""" Generates the Fibonacci numbers, starting with 0 """"""
    (x, y) = (0, 1)
    while 1:
        yield x
        (x, y) = (y, x + y)
f = fib()
a = {*()}
for _ in range(100):a.append(next(f))

def A000045(n):
    """""" Returns Fibonacci number with index n, offset 0 """"""
    return a[n]

def A000045_list(N):
    """""" Returns a list of the first n Fibonacci numbers """"""
    return a[:N]"	"def fib():
    """""" Generates the Fibonacci numbers, starting with 0 """"""
    (x, y) = (0, 1)
    while 1:
        yield x
        (x, y) = (y, x + y)
f = fib()
a = {*()}
for _ in range(100):a.append(next(f))

def A000045(n):
    """""" Returns Fibonacci number with index n, offset 0 """"""
    return a[n]

def A000045_list(N):
    """""" Returns a list of the first n Fibonacci numbers """"""
    return a[:N]"
A000045	Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.	0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155	" 
from gmpy2 import fib
for n in range(100): print(str(n) + "" "" + str(fib(n)))  
"	"from gmpy2 import fib
for n in range(100):
    print(str(n) + ' ' + str(fib(n)))"	"from gmpy2 import fib
sequence_iterator = iter(range(100))
while True:
    try:
        n = next(sequence_iterator)
        print(str(n) + ' ' + str(fib(n)))
    except StopIteration:
        break"	"from gmpy2 import fib
sequence_iterator = iter(range(100))
while True:
    try:
        n = next(sequence_iterator)
        print(str(n) + ' ' + str(fib(n)))
    except StopIteration:
        break"	"from gmpy2 import fib
sequence_iterator = iter(range(100))
while True:
    try:
        n = next(sequence_iterator)
        print(str(n) + ' ' + str(fib(n)))
    except StopIteration:
        break"	"from gmpy2 import fib
sequence_iterator = iter(range(100))
while True:
    try:
        n = next(sequence_iterator)
        print(str(n) + ' ' + str(fib(n)))
    except StopIteration:
        break"
A000058	Sylvester's sequence: a(n+1) = a(n)^2 - a(n) + 1, with a(0) = 2.	2,3,7,43,1807,3263443,10650056950807,113423713055421844361000443,12864938683278671740537145998360961546653259485195807	"
A000058 = [2]
for n in range(1, 10):
    A000058.append(A000058[n-1]*(A000058[n-1]-1)+1)

"	"A000058 = [2]
for n in range(1, 10):
    A000058.append(A000058[n - 1] * (A000058[n - 1] - 1) + 1)"	"A000058 = [2]
sequence_iterator = iter(range(1, 10))
while True:
    try:
        n = next(sequence_iterator)
        A000058.append(A000058[n - 1] * (A000058[n - 1] - 1) + 1)
    except StopIteration:
        break"	"A000058 = [2]
sequence_iterator = iter(range(1, 10))
while True:
    try:
        n = next(sequence_iterator)
        A000058.append(A000058[n - 1] * (A000058[n - 1] - 1) + 1)
    except StopIteration:
        break"	"A000058 = [2]
sequence_iterator = iter(range(1, 10))
while True:
    try:
        n = next(sequence_iterator)
        A000058.append(A000058[n - 1] * (A000058[n - 1] - 1) + 1)
    except StopIteration:
        break"	"A000058 = [2]
sequence_iterator = iter(range(1, 10))
while True:
    try:
        n = next(sequence_iterator)
        A000058.append(A000058[n - 1] * (A000058[n - 1] - 1) + 1)
    except StopIteration:
        break"
A000059	Numbers n such that (2n)^4 + 1 is prime.	1,2,3,8,10,12,14,17,23,24,27,28,37,40,41,44,45,53,59,66,70,71,77,80,82,87,90,97,99,102,105,110,114,119,121,124,127,133,136,138,139,144,148,156,160,164,167,170,176,182,187,207,215,218,221,233,236,238,244,246	"
from sympy import isprime
print([n for n in range(10**3) if isprime(16*n**4+1)])

"	"from sympy import isprime
print([n for n in range(10 ** 3) if isprime(16 * n ** 4 + 1)])"	"from sympy import isprime
print([n for n in range(10 ** 3) if isprime(16 * n ** 4 + 1)])"	"from sympy import isprime
print([n for n in range(10 ** 3) if isprime(16 * n ** 4 + 1)])"	"from sympy import isprime
print([n for n in range(10 ** 3) if isprime(16 * n ** 4 + 1)])"	"from sympy import isprime
print([n for n in range(10 ** 3) if isprime(16 * n ** 4 + 1)])"
A000073	Tribonacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) for n >= 3 with a(0) = a(1) = 0 and a(2) = 1.	0,0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,66012,121415,223317,410744,755476,1389537,2555757,4700770,8646064,15902591,29249425,53798080,98950096,181997601,334745777,615693474,1132436852	"
def a(n, adict={0:0, 1:0, 2:1}):
    if n in adict:
        return adict[n]
    adict[n]=a(n-1)+a(n-2)+a(n-3)
    return adict[n] 
"	"def a(n, adict={0: 0, 1: 0, 2: 1}):
    if n in adict:
        return adict[n]
    adict[n] = a(n - 1) + a(n - 2) + a(n - 3)
    return adict[n]"	"def a(n, adict={0: 0, 1: 0, 2: 1}):
    if n in adict:
        return adict[n]
    adict[n] = a(n - 1) + a(n - 2) + a(n - 3)
    return adict[n]"	"def a(n, adict={0: 0, 1: 0, 2: 1}):
    if n in adict:
        return adict[n]
    adict[n] = a(n - 1) + a(n - 2) + a(n - 3)
    return adict[n]"	"def a(n, adict={0: 0, 1: 0, 2: 1}):
    if n in adict:
        return adict[n]
    adict[n] = a(n - 1) + a(n - 2) + a(n - 3)
    return adict[n]"	"def a(n, adict={0: 0, 1: 0, 2: 1}):
    if n in adict:
        return adict[n]
    adict[n] = a(n - 1) + a(n - 2) + a(n - 3)
    return adict[n]"
A000078	Tetranacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) + a(n-4) for n >= 4 with a(0) = a(1) = a(2) = 0 and a(3) = 1.	0,0,0,1,1,2,4,8,15,29,56,108,208,401,773,1490,2872,5536,10671,20569,39648,76424,147312,283953,547337,1055026,2033628,3919944,7555935,14564533,28074040,54114452,104308960,201061985,387559437,747044834,1439975216,2775641472	"
A000078 = [0,0,0,1]
for n in range(4, 100):
    A000078.append(A000078[n-1]+A000078[n-2]+A000078[n-3]+A000078[n-4])

"	"A000078 = [0, 0, 0, 1]
for n in range(4, 100):
    A000078.append(A000078[n - 1] + A000078[n - 2] + A000078[n - 3] + A000078[n - 4])"	"A000078 = [0, 0, 0, 1]
sequence_iterator = iter(range(4, 100))
while True:
    try:
        n = next(sequence_iterator)
        A000078.append(A000078[n - 1] + A000078[n - 2] + A000078[n - 3] + A000078[n - 4])
    except StopIteration:
        break"	"A000078 = [0, 0, 0, 1]
sequence_iterator = iter(range(4, 100))
while True:
    try:
        n = next(sequence_iterator)
        A000078.append(A000078[n - 1] + A000078[n - 2] + A000078[n - 3] + A000078[n - 4])
    except StopIteration:
        break"	"A000078 = [0, 0, 0, 1]
sequence_iterator = iter(range(4, 100))
while True:
    try:
        n = next(sequence_iterator)
        A000078.append(A000078[n - 1] + A000078[n - 2] + A000078[n - 3] + A000078[n - 4])
    except StopIteration:
        break"	"A000078 = [0, 0, 0, 1]
sequence_iterator = iter(range(4, 100))
while True:
    try:
        n = next(sequence_iterator)
        A000078.append(A000078[n - 1] + A000078[n - 2] + A000078[n - 3] + A000078[n - 4])
    except StopIteration:
        break"
A000079	Powers of 2: a(n) = 2^n.	1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592	"
def a(n): return 2**n
print([a(n) for n in range(34)]) 
"	"def a(n):
    return 2 ** n
print([a(n) for n in range(34)])"	"def a(n):
    return 2 ** n
print([a(n) for n in range(34)])"	"def a(n):
    return 2 ** n
print([a(n) for n in range(34)])"	"def a(n):
    return 2 ** n
print([a(n) for n in range(34)])"	"def a(n):
    return 2 ** n
print([a(n) for n in range(34)])"
A000118	Number of ways of writing n as a sum of 4 squares; also theta series of lattice Z^4.	1,8,24,32,24,48,96,64,24,104,144,96,96,112,192,192,24,144,312,160,144,256,288,192,96,248,336,320,192,240,576,256,24,384,432,384,312,304,480,448,144,336,768,352,288,624,576,384,96,456,744,576,336,432,960,576,192	"
from sympy import divisors
def a(n): return 1 if n==0 else 8*sum(d for d in divisors(n) if d%4 != 0)
print([a(n) for n in range(57)]) 
"	"from sympy import divisors

def a(n):
    return 1 if n == 0 else 8 * sum((d for d in divisors(n) if d % 4 != 0))
print([a(n) for n in range(57)])"	"from sympy import divisors

def a(n):
    return 1 if n == 0 else 8 * sum((d for d in divisors(n) if d % 4 != 0))
print([a(n) for n in range(57)])"	"from sympy import divisors

def a(n):
    return 1 if n == 0 else 8 * sum((d for d in divisors(n) if d % 4 != 0))
print([a(n) for n in range(57)])"	"from sympy import divisors

def a(n):
    return 1 if n == 0 else 8 * sum((d for d in divisors(n) if d % 4 != 0))
print([a(n) for n in range(57)])"	"from sympy import divisors

def a(n):
    return 1 if n == 0 else 8 * sum((d for d in divisors(n) if d % 4 != 0))
print([a(n) for n in range(57)])"
A000142	Factorial numbers: n! = 1*2*3*4*...*n (order of symmetric group S_n, number of permutations of n letters).	1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,121645100408832000,2432902008176640000,51090942171709440000,1124000727777607680000	"
for i in range(1, 1000):
    y = i
    for j in range(1, i):
       y *= i - j
    print(y, ""\n"")
"	"for i in range(1, 1000):
    y = i
    for j in range(1, i):
        y *= i - j
    print(y, '\n')"	"sequence_iterator = iter(range(1, 1000))
while True:
    try:
        i = next(sequence_iterator)
        y = i
        sequence_iterator = iter(range(1, i))
        while True:
            try:
                j = next(sequence_iterator)
                y *= i - j
            except StopIteration:
                break
        print(y, '\n')
    except StopIteration:
        break"	"sequence_iterator = iter(range(1, 1000))
while True:
    try:
        i = next(sequence_iterator)
        y = i
        sequence_iterator = iter(range(1, i))
        while True:
            try:
                j = next(sequence_iterator)
                y *= i - j
            except StopIteration:
                break
        print(y, '\n')
    except StopIteration:
        break"	"sequence_iterator = iter(range(1, 1000))
while True:
    try:
        i = next(sequence_iterator)
        y = i
        sequence_iterator = iter(range(1, i))
        while True:
            try:
                j = next(sequence_iterator)
                y *= i - j
            except StopIteration:
                break
        print(y, '\n')
    except StopIteration:
        break"	"sequence_iterator = iter(range(1, 1000))
while True:
    try:
        i = next(sequence_iterator)
        y = i
        sequence_iterator = iter(range(1, i))
        while True:
            try:
                j = next(sequence_iterator)
                y *= i - j
            except StopIteration:
                break
        print(y, '\n')
    except StopIteration:
        break"
A000142	Factorial numbers: n! = 1*2*3*4*...*n (order of symmetric group S_n, number of permutations of n letters).	1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,121645100408832000,2432902008176640000,51090942171709440000,1124000727777607680000	"
import math
for i in range(1, 1000):
    math.factorial(i)
    print("""")

"	"import math
for i in range(1, 1000):
    math.factorial(i)
    print('')"	"import math
sequence_iterator = iter(range(1, 1000))
while True:
    try:
        i = next(sequence_iterator)
        math.factorial(i)
        print('')
    except StopIteration:
        break"	"import math
sequence_iterator = iter(range(1, 1000))
while True:
    try:
        i = next(sequence_iterator)
        math.factorial(i)
        print('')
    except StopIteration:
        break"	"import math
sequence_iterator = iter(range(1, 1000))
while True:
    try:
        i = next(sequence_iterator)
        math.factorial(i)
        print('')
    except StopIteration:
        break"	"import math
sequence_iterator = iter(range(1, 1000))
while True:
    try:
        i = next(sequence_iterator)
        math.factorial(i)
        print('')
    except StopIteration:
        break"
A000203	a(n) = sigma(n), the sum of the divisors of n. Also called sigma_1(n).	1,3,4,7,6,12,8,15,13,18,12,28,14,24,24,31,18,39,20,42,32,36,24,60,31,42,40,56,30,72,32,63,48,54,48,91,38,60,56,90,42,96,44,84,78,72,48,124,57,93,72,98,54,120,72,120,80,90,60,168,62,96,104,127,84,144,68,126,96,144	"
from sympy import divisor_sigma
def a(n): return divisor_sigma(n, 1)
print([a(n) for n in range(1, 71)]) 
"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 1)
print([a(n) for n in range(1, 71)])"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 1)
print([a(n) for n in range(1, 71)])"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 1)
print([a(n) for n in range(1, 71)])"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 1)
print([a(n) for n in range(1, 71)])"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 1)
print([a(n) for n in range(1, 71)])"
A000213	Tribonacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) with a(0)=a(1)=a(2)=1.	1,1,1,3,5,9,17,31,57,105,193,355,653,1201,2209,4063,7473,13745,25281,46499,85525,157305,289329,532159,978793,1800281,3311233,6090307,11201821,20603361,37895489,69700671,128199521,235795681,433695873,797691075,1467182629	"
alst = [1, 1, 1]
[alst.append(alst[n-1] + alst[n-2] + alst[n-3]) for n in range(3, 37)]
print(alst) 
"	"alst = [1, 1, 1]
[alst.append(alst[n - 1] + alst[n - 2] + alst[n - 3]) for n in range(3, 37)]
print(alst)"	"alst = [1, 1, 1]
[alst.append(alst[n - 1] + alst[n - 2] + alst[n - 3]) for n in range(3, 37)]
print(alst)"	"alst = [1, 1, 1]
[alst.append(alst[n - 1] + alst[n - 2] + alst[n - 3]) for n in range(3, 37)]
print(alst)"	"alst = [1, 1, 1]
[alst.append(alst[n - 1] + alst[n - 2] + alst[n - 3]) for n in range(3, 37)]
print(alst)"	"alst = [1, 1, 1]
list((alst.append(alst[n - 1] + alst[n - 2] + alst[n - 3]) for n in range(3, 37)))
print(alst)"
A000265	Remove all factors of 2 from n; or largest odd divisor of n; or odd part of n.	1,1,3,1,5,3,7,1,9,5,11,3,13,7,15,1,17,9,19,5,21,11,23,3,25,13,27,7,29,15,31,1,33,17,35,9,37,19,39,5,41,21,43,11,45,23,47,3,49,25,51,13,53,27,55,7,57,29,59,15,61,31,63,1,65,33,67,17,69,35,71,9,73,37,75,19,77	" 
from sympy import divisors
def a(n):
    return max(i for i in divisors(n) if i % 2)
[a(n) for n in range(1, 101)]
"	"from sympy import divisors

def a(n):
    return max((i for i in divisors(n) if i % 2))
[a(n) for n in range(1, 101)]"	"from sympy import divisors

def a(n):
    return max((i for i in divisors(n) if i % 2))
[a(n) for n in range(1, 101)]"	"from sympy import divisors

def a(n):
    return max((i for i in divisors(n) if i % 2))
[a(n) for n in range(1, 101)]"	"from sympy import divisors

def a(n):
    return max((i for i in divisors(n) if i % 2))
[a(n) for n in range(1, 101)]"	"from sympy import divisors

def a(n):
    return max((i for i in divisors(n) if i % 2))
list((a(n) for n in range(1, 101)))"
A000265	Remove all factors of 2 from n; or largest odd divisor of n; or odd part of n.	1,1,3,1,5,3,7,1,9,5,11,3,13,7,15,1,17,9,19,5,21,11,23,3,25,13,27,7,29,15,31,1,33,17,35,9,37,19,39,5,41,21,43,11,45,23,47,3,49,25,51,13,53,27,55,7,57,29,59,15,61,31,63,1,65,33,67,17,69,35,71,9,73,37,75,19,77	"
from __future__ import division
def A000265(n):
    while not n % 2:
        n //= 2
    return n 
"	"from __future__ import division

def A000265(n):
    while not n % 2:
        n //= 2
    return n"	"from __future__ import division

def A000265(n):
    while not n % 2:
        n //= 2
    return n"	"from __future__ import division

def A000265(n):
    while not n % 2:
        n //= 2
    return n"	"from __future__ import division

def A000265(n):
    while not n % 2:
        n //= 2
    return n"	"from __future__ import division

def A000265(n):
    while not n % 2:
        n //= 2
    return n"
A000302	Powers of 4: a(n) = 4^n.	1,4,16,64,256,1024,4096,16384,65536,262144,1048576,4194304,16777216,67108864,268435456,1073741824,4294967296,17179869184,68719476736,274877906944,1099511627776,4398046511104,17592186044416,70368744177664,281474976710656	" print([4**n for n in range(25)]) 
"	print([4 ** n for n in range(25)])	print([4 ** n for n in range(25)])	print([4 ** n for n in range(25)])	print([4 ** n for n in range(25)])	print([4 ** n for n in range(25)])
A000378	Sums of three squares: numbers of the form x^2 + y^2 + z^2.	0,1,2,3,4,5,6,8,9,10,11,12,13,14,16,17,18,19,20,21,22,24,25,26,27,29,30,32,33,34,35,36,37,38,40,41,42,43,44,45,46,48,49,50,51,52,53,54,56,57,58,59,61,62,64,65,66,67,68,69,70,72,73,74,75,76,77,78,80,81,82,83	"
def valuation(n, b):
    v = 0
    while n > 1 and n%b == 0: n //= b; v += 1
    return v
def ok(n): return n//4**valuation(n, 4)%8 != 7
print(list(filter(ok, range(84)))) 
"	"def valuation(n, b):
    v = 0
    while n > 1 and n % b == 0:
        n //= b
        v += 1
    return v

def ok(n):
    return n // 4 ** valuation(n, 4) % 8 != 7
print(list([list_element for list_element in range(84) if ok(list_element)]))"	"def valuation(n, b):
    v = 0
    while n > 1 and n % b == 0:
        n //= b
        v += 1
    return v

def ok(n):
    return n // 4 ** valuation(n, 4) % 8 != 7
print(list([list_element for list_element in range(84) if ok(list_element)]))"	"def valuation(n, b):
    v = 0
    while n > 1 and n % b == 0:
        n //= b
        v += 1
    return v

def ok(n):
    return n // 4 ** valuation(n, 4) % 8 != 7
print(list([list_element for list_element in range(84) if ok(list_element)]))"	"def valuation(n, b):
    v = 0
    while n > 1 and n % b == 0:
        n //= b
        v += 1
    return v

def ok(n):
    return n // 4 ** valuation(n, 4) % 8 != 7
print(list([list_element for list_element in range(84) if ok(list_element)]))"	"def valuation(n, b):
    v = 0
    while n > 1 and n % b == 0:
        n //= b
        v += 1
    return v

def ok(n):
    return n // 4 ** valuation(n, 4) % 8 != 7
print(list([list_element for list_element in range(84) if ok(list_element)]))"
A000408	Numbers that are the sum of three nonzero squares.	3,6,9,11,12,14,17,18,19,21,22,24,26,27,29,30,33,34,35,36,38,41,42,43,44,45,46,48,49,50,51,53,54,56,57,59,61,62,65,66,67,68,69,70,72,73,74,75,76,77,78,81,82,83,84,86,88,89,90,91,93,94,96,97,98,99,101,102,104	"
def aupto(lim):
  squares = [k*k for k in range(1, int(lim**.5)+2) if k*k <= lim]
  sum2sqs = set(a+b for i, a in enumerate(squares) for b in squares[i:])
  sum3sqs = set(a+b for a in sum2sqs for b in squares)
  return sorted(set(range(lim+1)) & sum3sqs)
print(aupto(104)) 
"	"def aupto(lim):
    squares = [k * k for k in range(1, int(lim ** 0.5) + 2) if k * k <= lim]
    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))
    sum3sqs = set((a + b for a in sum2sqs for b in squares))
    return sorted(set(range(lim + 1)) & sum3sqs)
print(aupto(104))"	"def aupto(lim):
    squares = [k * k for k in range(1, int(lim ** 0.5) + 2) if k * k <= lim]
    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))
    sum3sqs = set((a + b for a in sum2sqs for b in squares))
    return sorted(set(range(lim + 1)) & sum3sqs)
print(aupto(104))"	"def aupto(lim):
    squares = [k * k for k in range(1, int(lim ** 0.5) + 2) if k * k <= lim]
    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))
    sum3sqs = set((a + b for a in sum2sqs for b in squares))
    return sorted(set(range(lim + 1)) & sum3sqs)
print(aupto(104))"	"def aupto(lim):
    squares = {*()}
    for k in range(1, int(lim ** 0.5) + 2):
        if k * k <= lim:squares.append(k * k)
    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))
    sum3sqs = set((a + b for a in sum2sqs for b in squares))
    return sorted(set(range(lim + 1)) & sum3sqs)
print(aupto(104))"	"def aupto(lim):
    squares = {*()}
    for k in range(1, int(lim ** 0.5) + 2):
        if k * k <= lim:squares.append(k * k)
    sum2sqs = {a + b for (i, a) in enumerate(squares) for b in squares[i:]}
    sum3sqs = {a + b for a in sum2sqs for b in squares}
    return sorted(set(range(lim + 1)) & sum3sqs)
print(aupto(104))"
A000414	Numbers that are the sum of 4 nonzero squares.	4,7,10,12,13,15,16,18,19,20,21,22,23,25,26,27,28,30,31,33,34,35,36,37,38,39,40,42,43,44,45,46,47,48,49,50,51,52,53,54,55,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81	"
limit = 10026 
from functools import lru_cache
nzs = [k*k for k in range(1, int(limit**.5)+2) if k*k + 3 <= limit]
nzss = set(nzs)
@lru_cache(maxsize=None)
def ok(n, m): return n in nzss if m == 1 else any(ok(n-s, m-1) for s in nzs)
print([n for n in range(4, limit+1) if ok(n, 4)]) 
"	"limit = 10026
from functools import lru_cache
nzs = [k * k for k in range(1, int(limit ** 0.5) + 2) if k * k + 3 <= limit]
nzss = set(nzs)

@lru_cache(maxsize=None)
def ok(n, m):
    return n in nzss if m == 1 else any((ok(n - s, m - 1) for s in nzs))
print([n for n in range(4, limit + 1) if ok(n, 4)])"	"limit = 10026
from functools import lru_cache
nzs = [k * k for k in range(1, int(limit ** 0.5) + 2) if k * k + 3 <= limit]
nzss = set(nzs)

@lru_cache(maxsize=None)
def ok(n, m):
    return n in nzss if m == 1 else any((ok(n - s, m - 1) for s in nzs))
print([n for n in range(4, limit + 1) if ok(n, 4)])"	"limit = 10026
from functools import lru_cache
nzs = [k * k for k in range(1, int(limit ** 0.5) + 2) if k * k + 3 <= limit]
nzss = set(nzs)

@lru_cache(maxsize=None)
def ok(n, m):
    return n in nzss if m == 1 else any((ok(n - s, m - 1) for s in nzs))
print([n for n in range(4, limit + 1) if ok(n, 4)])"	"limit = 10026
from functools import lru_cache
nzs = {*()}
for k in range(1, int(limit ** 0.5) + 2):
    if k * k + 3 <= limit:nzs.append(k * k)
nzss = set(nzs)

@lru_cache(maxsize=None)
def ok(n, m):
    return n in nzss if m == 1 else any((ok(n - s, m - 1) for s in nzs))
print([n for n in range(4, limit + 1) if ok(n, 4)])"	"limit = 10026
from functools import lru_cache
nzs = {*()}
for k in range(1, int(limit ** 0.5) + 2):
    if k * k + 3 <= limit:nzs.append(k * k)
nzss = set(nzs)

@lru_cache(maxsize=None)
def ok(n, m):
    return n in nzss if m == 1 else any((ok(n - s, m - 1) for s in nzs))
print([n for n in range(4, limit + 1) if ok(n, 4)])"
A000419	Numbers that are the sum of 3 but no fewer nonzero squares.	3,6,11,12,14,19,21,22,24,27,30,33,35,38,42,43,44,46,48,51,54,56,57,59,62,66,67,69,70,75,76,77,78,83,84,86,88,91,93,94,96,99,102,105,107,108,110,114,115,118,120,123,126,129,131,132,133,134,138,139,140,141,142	"
def aupto(lim):
  squares = [k*k for k in range(1, int(lim**.5)+2) if k*k <= lim]
  sum2sqs = set(a+b for i, a in enumerate(squares) for b in squares[i:])
  sum3sqs = set(a+b for a in sum2sqs for b in squares)
  return sorted(set(range(lim+1)) & (sum3sqs - sum2sqs - set(squares)))
print(aupto(142)) 
"	"def aupto(lim):
    squares = [k * k for k in range(1, int(lim ** 0.5) + 2) if k * k <= lim]
    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))
    sum3sqs = set((a + b for a in sum2sqs for b in squares))
    return sorted(set(range(lim + 1)) & sum3sqs - sum2sqs - set(squares))
print(aupto(142))"	"def aupto(lim):
    squares = [k * k for k in range(1, int(lim ** 0.5) + 2) if k * k <= lim]
    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))
    sum3sqs = set((a + b for a in sum2sqs for b in squares))
    return sorted(set(range(lim + 1)) & sum3sqs - sum2sqs - set(squares))
print(aupto(142))"	"def aupto(lim):
    squares = [k * k for k in range(1, int(lim ** 0.5) + 2) if k * k <= lim]
    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))
    sum3sqs = set((a + b for a in sum2sqs for b in squares))
    return sorted(set(range(lim + 1)) & sum3sqs - sum2sqs - set(squares))
print(aupto(142))"	"def aupto(lim):
    squares = {*()}
    for k in range(1, int(lim ** 0.5) + 2):
        if k * k <= lim:squares.append(k * k)
    sum2sqs = set((a + b for (i, a) in enumerate(squares) for b in squares[i:]))
    sum3sqs = set((a + b for a in sum2sqs for b in squares))
    return sorted(set(range(lim + 1)) & sum3sqs - sum2sqs - set(squares))
print(aupto(142))"	"def aupto(lim):
    squares = {*()}
    for k in range(1, int(lim ** 0.5) + 2):
        if k * k <= lim:squares.append(k * k)
    sum2sqs = {a + b for (i, a) in enumerate(squares) for b in squares[i:]}
    sum3sqs = {a + b for a in sum2sqs for b in squares}
    return sorted(set(range(lim + 1)) & sum3sqs - sum2sqs - set(squares))
print(aupto(142))"
A000468	Powers of ten written in base 8.	1,12,144,1750,23420,303240,3641100,46113200,575360400,7346545000,112402762000,1351035564000,16432451210000,221411634520000,2657142036440000,34327724461500000,434157115760200000,5432127413542400000,67405553164731000000,1053071060221172000000	"
def a(n): return int(oct(10**n)[2:])
print([a(n) for n in range(20)]) 
"	"def a(n):
    return int(oct(10 ** n)[2:])
print([a(n) for n in range(20)])"	"def a(n):
    return int(oct(10 ** n)[2:])
print([a(n) for n in range(20)])"	"def a(n):
    return int(oct(10 ** n)[2:])
print([a(n) for n in range(20)])"	"def a(n):
    return int(oct(10 ** n)[2:])
print([a(n) for n in range(20)])"	"def a(n):
    return int(oct(10 ** n)[2:])
print([a(n) for n in range(20)])"
A000538	Sum of fourth powers: 0^4 + 1^4 + ... + n^4.	0,1,17,98,354,979,2275,4676,8772,15333,25333,39974,60710,89271,127687,178312,243848,327369,432345,562666,722666,917147,1151403,1431244,1763020,2153645,2610621,3142062,3756718,4463999,5273999,6197520,7246096,8432017,9768353	"
A000538_list, m = [0], [24, -36, 14, -1, 0, 0]
for _ in range(10**2):
    for i in range(5):
        m[i+1] += m[i]
    A000538_list.append(m[-1]) 
"	"(A000538_list, m) = ([0], [24, -36, 14, -1, 0, 0])
for _ in range(10 ** 2):
    for i in range(5):
        m[i + 1] += m[i]
    A000538_list.append(m[-1])"	"(A000538_list, m) = ([0], [24, -36, 14, -1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(5))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000538_list.append(m[-1])
    except StopIteration:
        break"	"(A000538_list, m) = ([0], [24, -36, 14, -1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(5))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000538_list.append(m[-1])
    except StopIteration:
        break"	"(A000538_list, m) = ([0], [24, -36, 14, -1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(5))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000538_list.append(m[-1])
    except StopIteration:
        break"	"(A000538_list, m) = ([0], [24, -36, 14, -1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(5))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000538_list.append(m[-1])
    except StopIteration:
        break"
A000539	Sum of 5th powers: 0^5 + 1^5 + 2^5 + ... + n^5.	0,1,33,276,1300,4425,12201,29008,61776,120825,220825,381876,630708,1002001,1539825,2299200,3347776,4767633,6657201,9133300,12333300,16417401,21571033,28007376,35970000,45735625,57617001,71965908,89176276,109687425,133987425	"
A000539_list, m = [0], [120, -240, 150, -30, 1, 0, 0]
for _ in range(10**2):
    for i in range(6):
        m[i+1] += m[i]
    A000539_list.append(m[-1]) 
"	"(A000539_list, m) = ([0], [120, -240, 150, -30, 1, 0, 0])
for _ in range(10 ** 2):
    for i in range(6):
        m[i + 1] += m[i]
    A000539_list.append(m[-1])"	"(A000539_list, m) = ([0], [120, -240, 150, -30, 1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(6))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000539_list.append(m[-1])
    except StopIteration:
        break"	"(A000539_list, m) = ([0], [120, -240, 150, -30, 1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(6))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000539_list.append(m[-1])
    except StopIteration:
        break"	"(A000539_list, m) = ([0], [120, -240, 150, -30, 1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(6))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000539_list.append(m[-1])
    except StopIteration:
        break"	"(A000539_list, m) = ([0], [120, -240, 150, -30, 1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(6))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000539_list.append(m[-1])
    except StopIteration:
        break"
A000540	Sum of 6th powers: 0^6 + 1^6 + 2^6 + ... + n^6.	0,1,65,794,4890,20515,67171,184820,446964,978405,1978405,3749966,6735950,11562759,19092295,30482920,47260136,71397705,105409929,152455810,216455810,302221931,415601835,563637724,754740700,998881325,1307797101,1695217590	"
A000540_list, m = [0], [720, -1800, 1560, -540, 62, -1, 0, 0]
for _ in range(10**2):
    for i in range(7):
        m[i+1] += m[i]
    A000540_list.append(m[-1]) 
"	"(A000540_list, m) = ([0], [720, -1800, 1560, -540, 62, -1, 0, 0])
for _ in range(10 ** 2):
    for i in range(7):
        m[i + 1] += m[i]
    A000540_list.append(m[-1])"	"(A000540_list, m) = ([0], [720, -1800, 1560, -540, 62, -1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(7))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000540_list.append(m[-1])
    except StopIteration:
        break"	"(A000540_list, m) = ([0], [720, -1800, 1560, -540, 62, -1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(7))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000540_list.append(m[-1])
    except StopIteration:
        break"	"(A000540_list, m) = ([0], [720, -1800, 1560, -540, 62, -1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(7))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000540_list.append(m[-1])
    except StopIteration:
        break"	"(A000540_list, m) = ([0], [720, -1800, 1560, -540, 62, -1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(7))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000540_list.append(m[-1])
    except StopIteration:
        break"
A000541	Sum of 7th powers: 1^7 + 2^7 + ... + n^7.	0,1,129,2316,18700,96825,376761,1200304,3297456,8080425,18080425,37567596,73399404,136147921,241561425,412420800,680856256,1091194929,1703414961,2597286700,3877286700,5678375241,8172733129,11577558576,16164030000,22267545625	"
A000541_list, m = [0], [5040, -15120, 16800, -8400, 1806, -126, 1, 0, 0]
for _ in range(10**2):
    for i in range(8):
        m[i+1] += m[i]
    A000541_list.append(m[-1]) 
"	"(A000541_list, m) = ([0], [5040, -15120, 16800, -8400, 1806, -126, 1, 0, 0])
for _ in range(10 ** 2):
    for i in range(8):
        m[i + 1] += m[i]
    A000541_list.append(m[-1])"	"(A000541_list, m) = ([0], [5040, -15120, 16800, -8400, 1806, -126, 1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(8))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000541_list.append(m[-1])
    except StopIteration:
        break"	"(A000541_list, m) = ([0], [5040, -15120, 16800, -8400, 1806, -126, 1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(8))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000541_list.append(m[-1])
    except StopIteration:
        break"	"(A000541_list, m) = ([0], [5040, -15120, 16800, -8400, 1806, -126, 1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(8))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000541_list.append(m[-1])
    except StopIteration:
        break"	"(A000541_list, m) = ([0], [5040, -15120, 16800, -8400, 1806, -126, 1, 0, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(8))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000541_list.append(m[-1])
    except StopIteration:
        break"
A000542	Sum of 8th powers: 1^8 + 2^8 + ... + n^8.	0,1,257,6818,72354,462979,2142595,7907396,24684612,67731333,167731333,382090214,812071910,1627802631,3103591687,5666482312,9961449608,16937207049,27957167625,44940730666,70540730666,108363590027,163239463563,241550448844	"
A000542_list, m = [0], [40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0]
for _ in range(24):
    for i in range(9):
        m[i+1] += m[i]
    A000542_list.append(m[-1])
print(A000542_list) 
"	"(A000542_list, m) = ([0], [40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0])
for _ in range(24):
    for i in range(9):
        m[i + 1] += m[i]
    A000542_list.append(m[-1])
print(A000542_list)"	"(A000542_list, m) = ([0], [40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0])
sequence_iterator = iter(range(24))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(9))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000542_list.append(m[-1])
    except StopIteration:
        break
print(A000542_list)"	"(A000542_list, m) = ([0], [40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0])
sequence_iterator = iter(range(24))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(9))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000542_list.append(m[-1])
    except StopIteration:
        break
print(A000542_list)"	"(A000542_list, m) = ([0], [40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0])
sequence_iterator = iter(range(24))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(9))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000542_list.append(m[-1])
    except StopIteration:
        break
print(A000542_list)"	"(A000542_list, m) = ([0], [40320, -141120, 191520, -126000, 40824, -5796, 254, -1, 0, 0])
sequence_iterator = iter(range(24))
while True:
    try:
        _ = next(sequence_iterator)
        sequence_iterator = iter(range(9))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
        A000542_list.append(m[-1])
    except StopIteration:
        break
print(A000542_list)"
A000578	The cubes: a(n) = n^3.	0,1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832,6859,8000,9261,10648,12167,13824,15625,17576,19683,21952,24389,27000,29791,32768,35937,39304,42875,46656,50653,54872,59319,64000	"
A000578_list, m = [], [6, -6, 1, 0]
for _ in range(10**2):
    A000578_list.append(m[-1])
    for i in range(3):
        m[i+1] += m[i] 
"	"(A000578_list, m) = ([], [6, -6, 1, 0])
for _ in range(10 ** 2):
    A000578_list.append(m[-1])
    for i in range(3):
        m[i + 1] += m[i]"	"(A000578_list, m) = ([], [6, -6, 1, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        A000578_list.append(m[-1])
        sequence_iterator = iter(range(3))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
    except StopIteration:
        break"	"(A000578_list, m) = ([], [6, -6, 1, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        A000578_list.append(m[-1])
        sequence_iterator = iter(range(3))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
    except StopIteration:
        break"	"(A000578_list, m) = ([], [6, -6, 1, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        A000578_list.append(m[-1])
        sequence_iterator = iter(range(3))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
    except StopIteration:
        break"	"(A000578_list, m) = ([], [6, -6, 1, 0])
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        A000578_list.append(m[-1])
        sequence_iterator = iter(range(3))
        while True:
            try:
                i = next(sequence_iterator)
                m[i + 1] += m[i]
            except StopIteration:
                break
    except StopIteration:
        break"
A000593	Sum of odd divisors of n.	1,1,4,1,6,4,8,1,13,6,12,4,14,8,24,1,18,13,20,6,32,12,24,4,31,14,40,8,30,24,32,1,48,18,48,13,38,20,56,6,42,32,44,12,78,24,48,4,57,31,72,14,54,40,72,8,80,30,60,24,62,32,104,1,84,48,68,18,96,48,72,13,74,38,124	"
from math import prod
from sympy import factorint
def A000593(n): return prod((p**(e+1)-1)//(p-1) for p, e in factorint(n).items() if p > 2) 
"	"from math import prod
from sympy import factorint

def A000593(n):
    return prod(((p ** (e + 1) - 1) // (p - 1) for (p, e) in factorint(n).items() if p > 2))"	"from math import prod
from sympy import factorint

def A000593(n):
    return prod(((p ** (e + 1) - 1) // (p - 1) for (p, e) in factorint(n).items() if p > 2))"	"from math import prod
from sympy import factorint

def A000593(n):
    return prod(((p ** (e + 1) - 1) // (p - 1) for (p, e) in factorint(n).items() if p > 2))"	"from math import prod
from sympy import factorint

def A000593(n):
    return prod(((p ** (e + 1) - 1) // (p - 1) for (p, e) in factorint(n).items() if p > 2))"	"from math import prod
from sympy import factorint

def A000593(n):
    return prod(((p ** (e + 1) - 1) // (p - 1) for (p, e) in factorint(n).items() if p > 2))"
A000720	pi(n), the number of primes <= n. Sometimes called PrimePi(n) to distinguish it from the number 3.14159...	0,1,2,2,3,3,4,4,4,4,5,5,6,6,6,6,7,7,8,8,8,8,9,9,9,9,9,9,10,10,11,11,11,11,11,11,12,12,12,12,13,13,14,14,14,14,15,15,15,15,15,15,16,16,16,16,16,16,17,17,18,18,18,18,18,18,19,19,19,19,20,20,21,21,21,21,21,21	"
from sympy import primepi
for n in range(1,100): print(primepi(n), end=', ') 
"	"from sympy import primepi
for n in range(1, 100):
    print(primepi(n), end=', ')"	"from sympy import primepi
sequence_iterator = iter(range(1, 100))
while True:
    try:
        n = next(sequence_iterator)
        print(primepi(n), end=', ')
    except StopIteration:
        break"	"from sympy import primepi
sequence_iterator = iter(range(1, 100))
while True:
    try:
        n = next(sequence_iterator)
        print(primepi(n), end=', ')
    except StopIteration:
        break"	"from sympy import primepi
sequence_iterator = iter(range(1, 100))
while True:
    try:
        n = next(sequence_iterator)
        print(primepi(n), end=', ')
    except StopIteration:
        break"	"from sympy import primepi
sequence_iterator = iter(range(1, 100))
while True:
    try:
        n = next(sequence_iterator)
        print(primepi(n), end=', ')
    except StopIteration:
        break"
A001023	Powers of 14.	1,14,196,2744,38416,537824,7529536,105413504,1475789056,20661046784,289254654976,4049565169664,56693912375296,793714773254144,11112006825558016,155568095557812224,2177953337809371136,30491346729331195904,426878854210636742656,5976303958948914397184,83668255425284801560576	" print([14**n for n in range(21)]) 
"	print([14 ** n for n in range(21)])	print([14 ** n for n in range(21)])	print([14 ** n for n in range(21)])	print([14 ** n for n in range(21)])	print([14 ** n for n in range(21)])
A001025	Powers of 16: a(n) = 16^n.	1,16,256,4096,65536,1048576,16777216,268435456,4294967296,68719476736,1099511627776,17592186044416,281474976710656,4503599627370496,72057594037927936,1152921504606846976,18446744073709551616,295147905179352825856,4722366482869645213696,75557863725914323419136,1208925819614629174706176	" print([16**n for n in range(20)]) 
"	print([16 ** n for n in range(20)])	print([16 ** n for n in range(20)])	print([16 ** n for n in range(20)])	print([16 ** n for n in range(20)])	print([16 ** n for n in range(20)])
A001128	Reverse digits of previous term and multiply by previous term.	2,4,16,976,662704,269896807264,124883600543123110859968,108643488775144622666209173128243503963147630528	" def a(n): return 2 if n<2 else a(n - 1) * int(str(a(n - 1))[::-1]) 
"	"def a(n):
    return 2 if n < 2 else a(n - 1) * int(str(a(n - 1))[::-1])"	"def a(n):
    return 2 if n < 2 else a(n - 1) * int(str(a(n - 1))[::-1])"	"def a(n):
    return 2 if n < 2 else a(n - 1) * int(str(a(n - 1))[::-1])"	"def a(n):
    return 2 if n < 2 else a(n - 1) * int(str(a(n - 1))[::-1])"	"def a(n):
    return 2 if n < 2 else a(n - 1) * int(str(a(n - 1))[::-1])"
A001129	Iccanobif numbers: reverse digits of two previous terms and add.	0,1,1,2,3,5,8,13,39,124,514,836,1053,4139,12815,61135,104937,792517,1454698,9679838,17354310,9735140,1760750,986050,621360,113815,581437,1252496,7676706,13019288,94367798,178067380,173537220,106496242,265429972,522619163	"
A001129_list, r1, r2 = [0,1], 1, 0
for _ in range(10**2):
    l, r2 = r1+r2, r1
    r1 = int(str(l)[::-1])
    A001129_list.append(l) 
"	"(A001129_list, r1, r2) = ([0, 1], 1, 0)
for _ in range(10 ** 2):
    (l, r2) = (r1 + r2, r1)
    r1 = int(str(l)[::-1])
    A001129_list.append(l)"	"(A001129_list, r1, r2) = ([0, 1], 1, 0)
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        (l, r2) = (r1 + r2, r1)
        r1 = int(str(l)[::-1])
        A001129_list.append(l)
    except StopIteration:
        break"	"(A001129_list, r1, r2) = ([0, 1], 1, 0)
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        (l, r2) = (r1 + r2, r1)
        r1 = int(str(l)[::-1])
        A001129_list.append(l)
    except StopIteration:
        break"	"(A001129_list, r1, r2) = ([0, 1], 1, 0)
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        (l, r2) = (r1 + r2, r1)
        r1 = int(str(l)[::-1])
        A001129_list.append(l)
    except StopIteration:
        break"	"(A001129_list, r1, r2) = ([0, 1], 1, 0)
sequence_iterator = iter(range(10 ** 2))
while True:
    try:
        _ = next(sequence_iterator)
        (l, r2) = (r1 + r2, r1)
        r1 = int(str(l)[::-1])
        A001129_list.append(l)
    except StopIteration:
        break"
A001157	sigma_2(n): sum of squares of divisors of n.	1,5,10,21,26,50,50,85,91,130,122,210,170,250,260,341,290,455,362,546,500,610,530,850,651,850,820,1050,842,1300,962,1365,1220,1450,1300,1911,1370,1810,1700,2210,1682,2500,1850,2562,2366,2650,2210,3410,2451,3255	"
from sympy import divisor_sigma
def a(n): return divisor_sigma(n, 2)
print([a(n) for n in range(1, 51)]) 
"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 2)
print([a(n) for n in range(1, 51)])"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 2)
print([a(n) for n in range(1, 51)])"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 2)
print([a(n) for n in range(1, 51)])"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 2)
print([a(n) for n in range(1, 51)])"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 2)
print([a(n) for n in range(1, 51)])"
A001158	sigma_3(n): sum of cubes of divisors of n.	1,9,28,73,126,252,344,585,757,1134,1332,2044,2198,3096,3528,4681,4914,6813,6860,9198,9632,11988,12168,16380,15751,19782,20440,25112,24390,31752,29792,37449,37296,44226,43344,55261,50654,61740,61544,73710,68922,86688	"
from sympy import divisor_sigma
def a(n): return divisor_sigma(n, 3)
print([a(n) for n in range(1, 43)]) 
"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 3)
print([a(n) for n in range(1, 43)])"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 3)
print([a(n) for n in range(1, 43)])"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 3)
print([a(n) for n in range(1, 43)])"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 3)
print([a(n) for n in range(1, 43)])"	"from sympy import divisor_sigma

def a(n):
    return divisor_sigma(n, 3)
print([a(n) for n in range(1, 43)])"
A001221	Number of distinct primes dividing n (also called omega(n)).	0,1,1,1,1,2,1,1,1,2,1,2,1,2,2,1,1,2,1,2,2,2,1,2,1,2,1,2,1,3,1,1,2,2,2,2,1,2,2,2,1,3,1,2,2,2,1,2,1,2,2,2,1,2,2,2,2,2,1,3,1,2,2,1,2,3,1,2,2,3,1,2,1,2,2,2,2,3,1,2,1,2,1,3,2,2,2,2,1,3,2,2,2,2,2,2,1,2,2,2,1,3,1,2,3,2,1,2,1,3,2	"
from sympy.ntheory import primefactors
print([len(primefactors(n)) for n in range(1, 1001)])  
"	"from sympy.ntheory import primefactors
print([len(primefactors(n)) for n in range(1, 1001)])"	"from sympy.ntheory import primefactors
print([len(primefactors(n)) for n in range(1, 1001)])"	"from sympy.ntheory import primefactors
print([len(primefactors(n)) for n in range(1, 1001)])"	"from sympy.ntheory import primefactors
print([len(primefactors(n)) for n in range(1, 1001)])"	"from sympy.ntheory import primefactors
print([len(primefactors(n)) for n in range(1, 1001)])"
A001370	Sum of digits of 2^n.	1,2,4,8,7,5,10,11,13,8,7,14,19,20,22,26,25,14,19,29,31,26,25,41,37,29,40,35,43,41,37,47,58,62,61,59,64,56,67,71,61,50,46,56,58,62,70,68,73,65,76,80,79,77,82,92,85,80,70,77	" [sum(map(int, str(2**n))) for n in range(56)] 
"	[sum([int(list_element) for list_element in str(2 ** n)]) for n in range(56)]	[sum([int(list_element) for list_element in str(2 ** n)]) for n in range(56)]	[sum([int(list_element) for list_element in str(2 ** n)]) for n in range(56)]	[sum([int(list_element) for list_element in str(2 ** n)]) for n in range(56)]	list((sum([int(list_element) for list_element in str(2 ** n)]) for n in range(56)))
A001591	Pentanacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) + a(n-4) + a(n-5), a(0)=a(1)=a(2)=a(3)=0, a(4)=1.	0,0,0,0,1,1,2,4,8,16,31,61,120,236,464,912,1793,3525,6930,13624,26784,52656,103519,203513,400096,786568,1546352,3040048,5976577,11749641,23099186,45411804,89277256,175514464,345052351,678355061,1333610936,2621810068	"
def pentanacci():
    a, b, c, d, e = 0, 0, 0, 0, 1
    while True:
        yield a
        a, b, c, d, e = b, c, d, e, a + b + c + d + e
f = pentanacci()
print([next(f) for _ in range(100)]) 
"	"def pentanacci():
    (a, b, c, d, e) = (0, 0, 0, 0, 1)
    while True:
        yield a
        (a, b, c, d, e) = (b, c, d, e, a + b + c + d + e)
f = pentanacci()
print([next(f) for _ in range(100)])"	"def pentanacci():
    (a, b, c, d, e) = (0, 0, 0, 0, 1)
    while True:
        yield a
        (a, b, c, d, e) = (b, c, d, e, a + b + c + d + e)
f = pentanacci()
print([next(f) for _ in range(100)])"	"def pentanacci():
    (a, b, c, d, e) = (0, 0, 0, 0, 1)
    while True:
        yield a
        (a, b, c, d, e) = (b, c, d, e, a + b + c + d + e)
f = pentanacci()
print([next(f) for _ in range(100)])"	"def pentanacci():
    (a, b, c, d, e) = (0, 0, 0, 0, 1)
    while True:
        yield a
        (a, b, c, d, e) = (b, c, d, e, a + b + c + d + e)
f = pentanacci()
print([next(f) for _ in range(100)])"	"def pentanacci():
    (a, b, c, d, e) = (0, 0, 0, 0, 1)
    while True:
        yield a
        (a, b, c, d, e) = (b, c, d, e, a + b + c + d + e)
f = pentanacci()
print([next(f) for _ in range(100)])"
A001597	Perfect powers: m^k where m > 0 and k >= 2.	1,4,8,9,16,25,27,32,36,49,64,81,100,121,125,128,144,169,196,216,225,243,256,289,324,343,361,400,441,484,512,529,576,625,676,729,784,841,900,961,1000,1024,1089,1156,1225,1296,1331,1369,1444,1521,1600,1681,1728,1764	"
from sympy import perfect_power
def ok(n): return n==1 or perfect_power(n)
print([m for m in range(1, 1765) if ok(m)]) 
"	"from sympy import perfect_power

def ok(n):
    return n == 1 or perfect_power(n)
print([m for m in range(1, 1765) if ok(m)])"	"from sympy import perfect_power

def ok(n):
    return n == 1 or perfect_power(n)
print([m for m in range(1, 1765) if ok(m)])"	"from sympy import perfect_power

def ok(n):
    return n == 1 or perfect_power(n)
print([m for m in range(1, 1765) if ok(m)])"	"from sympy import perfect_power

def ok(n):
    return n == 1 or perfect_power(n)
print([m for m in range(1, 1765) if ok(m)])"	"from sympy import perfect_power

def ok(n):
    return n == 1 or perfect_power(n)
print([m for m in range(1, 1765) if ok(m)])"
A001622	Decimal expansion of golden ratio phi (or tau) = (1 + sqrt(5))/2.	1,6,1,8,0,3,3,9,8,8,7,4,9,8,9,4,8,4,8,2,0,4,5,8,6,8,3,4,3,6,5,6,3,8,1,1,7,7,2,0,3,0,9,1,7,9,8,0,5,7,6,2,8,6,2,1,3,5,4,4,8,6,2,2,7,0,5,2,6,0,4,6,2,8,1,8,9,0,2,4,4,9,7,0,7,2,0,7,2,0,4,1,8,9,3,9,1,1,3,7,4,8,4,7,5	"
from sympy import S
def alst(n): 
  return list(map(int, str(S.GoldenRatio.n(n+1)).replace(""."", """")))[:-1]
print(alst(105)) 
"	"from sympy import S

def alst(n):
    return list([int(list_element) for list_element in str(S.GoldenRatio.n(n + 1)).replace('.', '')])[:-1]
print(alst(105))"	"from sympy import S

def alst(n):
    return list([int(list_element) for list_element in str(S.GoldenRatio.n(n + 1)).replace('.', '')])[:-1]
print(alst(105))"	"from sympy import S

def alst(n):
    return list([int(list_element) for list_element in str(S.GoldenRatio.n(n + 1)).replace('.', '')])[:-1]
print(alst(105))"	"from sympy import S

def alst(n):
    return list([int(list_element) for list_element in str(S.GoldenRatio.n(n + 1)).replace('.', '')])[:-1]
print(alst(105))"	"from sympy import S

def alst(n):
    return list(list((int(list_element) for list_element in str(S.GoldenRatio.n(n + 1)).replace('.', ''))))[:-1]
print(alst(105))"
A001651	Numbers not divisible by 3.	1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,28,29,31,32,34,35,37,38,40,41,43,44,46,47,49,50,52,53,55,56,58,59,61,62,64,65,67,68,70,71,73,74,76,77,79,80,82,83,85,86,88,89,91,92,94,95,97,98,100,101,103,104	"
print([k for k in range(1, 105) if k%3]) 
"	print([k for k in range(1, 105) if k % 3])	print([k for k in range(1, 105) if k % 3])	print([k for k in range(1, 105) if k % 3])	print([k for k in range(1, 105) if k % 3])	print([k for k in range(1, 105) if k % 3])
A001654	Golden rectangle numbers: F(n)*F(n+1), where F(n) = A000045(n) (Fibonacci numbers).	0,1,2,6,15,40,104,273,714,1870,4895,12816,33552,87841,229970,602070,1576239,4126648,10803704,28284465,74049690,193864606,507544127,1328767776,3478759200,9107509825,23843770274,62423800998,163427632719	"
from sympy import fibonacci as F
def a(n): return F(n)*F(n + 1)
[a(n) for n in range(101)] 
"	"from sympy import fibonacci as F

def a(n):
    return F(n) * F(n + 1)
[a(n) for n in range(101)]"	"from sympy import fibonacci as F

def a(n):
    return F(n) * F(n + 1)
[a(n) for n in range(101)]"	"from sympy import fibonacci as F

def a(n):
    return F(n) * F(n + 1)
[a(n) for n in range(101)]"	"from sympy import fibonacci as F

def a(n):
    return F(n) * F(n + 1)
[a(n) for n in range(101)]"	"from sympy import fibonacci as F

def a(n):
    return F(n) * F(n + 1)
list((a(n) for n in range(101)))"
A001690	Non-Fibonacci numbers.	4,6,7,9,10,11,12,14,15,16,17,18,19,20,22,23,24,25,26,27,28,29,30,31,32,33,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78	"
def f(n):
    a=1
    b=2
    c=3
    while n>0:
        a=b
        b=c
        c=a+b
        n-=(c-b-1)
    n+=(c-b-1)
    return (b+n)
for i in range(1,1001):
    print(str(i)+"" ""+str(f(i))) 
"	"def f(n):
    a = 1
    b = 2
    c = 3
    while n > 0:
        a = b
        b = c
        c = a + b
        n -= c - b - 1
    n += c - b - 1
    return b + n
for i in range(1, 1001):
    print(str(i) + ' ' + str(f(i)))"	"def f(n):
    a = 1
    b = 2
    c = 3
    while n > 0:
        a = b
        b = c
        c = a + b
        n -= c - b - 1
    n += c - b - 1
    return b + n
sequence_iterator = iter(range(1, 1001))
while True:
    try:
        i = next(sequence_iterator)
        print(str(i) + ' ' + str(f(i)))
    except StopIteration:
        break"	"def f(n):
    a = 1
    b = 2
    c = 3
    while n > 0:
        a = b
        b = c
        c = a + b
        n -= c - b - 1
    n += c - b - 1
    return b + n
sequence_iterator = iter(range(1, 1001))
while True:
    try:
        i = next(sequence_iterator)
        print(str(i) + ' ' + str(f(i)))
    except StopIteration:
        break"	"def f(n):
    a = 1
    b = 2
    c = 3
    while n > 0:
        a = b
        b = c
        c = a + b
        n -= c - b - 1
    n += c - b - 1
    return b + n
sequence_iterator = iter(range(1, 1001))
while True:
    try:
        i = next(sequence_iterator)
        print(str(i) + ' ' + str(f(i)))
    except StopIteration:
        break"	"def f(n):
    a = 1
    b = 2
    c = 3
    while n > 0:
        a = b
        b = c
        c = a + b
        n -= c - b - 1
    n += c - b - 1
    return b + n
sequence_iterator = iter(range(1, 1001))
while True:
    try:
        i = next(sequence_iterator)
        print(str(i) + ' ' + str(f(i)))
    except StopIteration:
        break"
A001703	Decimal concatenation of n, n+1, and n+2.	12,123,234,345,456,567,678,789,8910,91011,101112,111213,121314,131415,141516,151617,161718,171819,181920,192021,202122,212223,222324,232425,242526,252627,262728,272829,282930,293031,303132,313233,323334,333435,343536,353637,363738	" for n in range(100): print(int(str(n)+str(n+1)+str(n+2))) 
"	"for n in range(100):
    print(int(str(n) + str(n + 1) + str(n + 2)))"	"sequence_iterator = iter(range(100))
while True:
    try:
        n = next(sequence_iterator)
        print(int(str(n) + str(n + 1) + str(n + 2)))
    except StopIteration:
        break"	"sequence_iterator = iter(range(100))
while True:
    try:
        n = next(sequence_iterator)
        print(int(str(n) + str(n + 1) + str(n + 2)))
    except StopIteration:
        break"	"sequence_iterator = iter(range(100))
while True:
    try:
        n = next(sequence_iterator)
        print(int(str(n) + str(n + 1) + str(n + 2)))
    except StopIteration:
        break"	"sequence_iterator = iter(range(100))
while True:
    try:
        n = next(sequence_iterator)
        print(int(str(n) + str(n + 1) + str(n + 2)))
    except StopIteration:
        break"
A001704	a(n) = n concatenated with n + 1.	12,23,34,45,56,67,78,89,910,1011,1112,1213,1314,1415,1516,1617,1718,1819,1920,2021,2122,2223,2324,2425,2526,2627,2728,2829,2930,3031,3132,3233,3334,3435,3536,3637,3738,3839,3940,4041,4142,4243,4344,4445,4546	" for n in range(1,100): print(str(n)+str(n+1)) 
"	"for n in range(1, 100):
    print(str(n) + str(n + 1))"	"sequence_iterator = iter(range(1, 100))
while True:
    try:
        n = next(sequence_iterator)
        print(str(n) + str(n + 1))
    except StopIteration:
        break"	"sequence_iterator = iter(range(1, 100))
while True:
    try:
        n = next(sequence_iterator)
        print(str(n) + str(n + 1))
    except StopIteration:
        break"	"sequence_iterator = iter(range(1, 100))
while True:
    try:
        n = next(sequence_iterator)
        print(str(n) + str(n + 1))
    except StopIteration:
        break"	"sequence_iterator = iter(range(1, 100))
while True:
    try:
        n = next(sequence_iterator)
        print(str(n) + str(n + 1))
    except StopIteration:
        break"
A001974	Numbers that are the sum of 3 distinct squares, i.e., numbers of the form x^2 + y^2 + z^2 with 0 <= x < y < z.	5,10,13,14,17,20,21,25,26,29,30,34,35,37,38,40,41,42,45,46,49,50,52,53,54,56,58,59,61,62,65,66,68,69,70,73,74,75,77,78,80,81,82,83,84,85,86,89,90,91,93,94,97,98,100,101,104,105,106,107,109,110,113	"
from itertools import combinations
def aupto(lim):
  s = filter(lambda x: x <= lim, (i*i for i in range(int(lim**.5)+2)))
  s3 = set(filter(lambda x: x<=lim, (sum(c) for c in combinations(s, 3))))
  return sorted(s3)
print(aupto(113)) 
"	"from itertools import combinations

def aupto(lim):
    s = [list_element for list_element in (i * i for i in range(int(lim ** 0.5) + 2)) if (lambda x: x <= lim)(list_element)]
    s3 = set([list_element for list_element in (sum(c) for c in combinations(s, 3)) if (lambda x: x <= lim)(list_element)])
    return sorted(s3)
print(aupto(113))"	"from itertools import combinations

def aupto(lim):
    s = [list_element for list_element in (i * i for i in range(int(lim ** 0.5) + 2)) if (lambda x: x <= lim)(list_element)]
    s3 = set([list_element for list_element in (sum(c) for c in combinations(s, 3)) if (lambda x: x <= lim)(list_element)])
    return sorted(s3)
print(aupto(113))"	"from itertools import combinations

def aupto(lim):
    s = [list_element for list_element in (i * i for i in range(int(lim ** 0.5) + 2)) if (lambda x: x <= lim)(list_element)]
    s3 = set([list_element for list_element in (sum(c) for c in combinations(s, 3)) if (lambda x: x <= lim)(list_element)])
    return sorted(s3)
print(aupto(113))"	"from itertools import combinations

def aupto(lim):
    s = {*()}
    for list_element in (i * i for i in range(int(lim ** 0.5) + 2)):
        if (lambda x: x <= lim)(list_element):s.append(list_element)
    s3 = set([list_element for list_element in (sum(c) for c in combinations(s, 3)) if (lambda x: x <= lim)(list_element)])
    return sorted(s3)
print(aupto(113))"	"from itertools import combinations

def aupto(lim):
    s = {*()}
    for list_element in (i * i for i in range(int(lim ** 0.5) + 2)):
        if (lambda x: x <= lim)(list_element):s.append(list_element)
    s3 = set(list((list_element for list_element in (sum(c) for c in combinations(s, 3)) if (lambda x: x <= lim)(list_element))))
    return sorted(s3)
print(aupto(113))"
A002113	Palindromes in base 10.	0,1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,141,151,161,171,181,191,202,212,222,232,242,252,262,272,282,292,303,313,323,333,343,353,363,373,383,393,404,414,424,434,444,454,464,474,484,494,505,515	"
def A002113_list(nMax):
  mlist=[]
  for n in range(nMax+1):
     mstr=str(n)
     if mstr==mstr[::-1]:
        mlist.append(n)
  return(mlist)
"	"def A002113_list(nMax):
    mlist = []
    for n in range(nMax + 1):
        mstr = str(n)
        if mstr == mstr[::-1]:
            mlist.append(n)
    return mlist"	"def A002113_list(nMax):
    mlist = []
    sequence_iterator = iter(range(nMax + 1))
    while True:
        try:
            n = next(sequence_iterator)
            mstr = str(n)
            if mstr == mstr[::-1]:
                mlist.append(n)
        except StopIteration:
            break
    return mlist"	"def A002113_list(nMax):
    mlist = []
    sequence_iterator = iter(range(nMax + 1))
    while True:
        try:
            n = next(sequence_iterator)
            mstr = str(n)
            if mstr == mstr[::-1]:
                mlist.append(n)
        except StopIteration:
            break
    return mlist"	"def A002113_list(nMax):
    mlist = []
    sequence_iterator = iter(range(nMax + 1))
    while True:
        try:
            n = next(sequence_iterator)
            mstr = str(n)
            if mstr == mstr[::-1]:
                mlist.append(n)
        except StopIteration:
            break
    return mlist"	"def A002113_list(nMax):
    mlist = []
    sequence_iterator = iter(range(nMax + 1))
    while True:
        try:
            n = next(sequence_iterator)
            mstr = str(n)
            if mstr == mstr[::-1]:
                mlist.append(n)
        except StopIteration:
            break
    return mlist"
A002113	Palindromes in base 10.	0,1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,141,151,161,171,181,191,202,212,222,232,242,252,262,272,282,292,303,313,323,333,343,353,363,373,383,393,404,414,424,434,444,454,464,474,484,494,505,515	"
from itertools import chain
A002113 = sorted(chain(map(lambda x:int(str(x)+str(x)[::-1]),range(1,10**3)),map(lambda x:int(str(x)+str(x)[-2::-1]), range(10**3)))) 
"	"from itertools import chain
A002113 = sorted(chain([(lambda x: int(str(x) + str(x)[::-1]))(list_element) for list_element in range(1, 10 ** 3)], [(lambda x: int(str(x) + str(x)[-2::-1]))(list_element) for list_element in range(10 ** 3)]))"	"from itertools import chain
A002113 = sorted(chain([(lambda x: int(str(x) + str(x)[::-1]))(list_element) for list_element in range(1, 10 ** 3)], [(lambda x: int(str(x) + str(x)[-2::-1]))(list_element) for list_element in range(10 ** 3)]))"	"from itertools import chain
A002113 = sorted(chain([(lambda x: int(str(x) + str(x)[::-1]))(list_element) for list_element in range(1, 10 ** 3)], [(lambda x: int(str(x) + str(x)[-2::-1]))(list_element) for list_element in range(10 ** 3)]))"	"from itertools import chain
A002113 = sorted(chain([(lambda x: int(str(x) + str(x)[::-1]))(list_element) for list_element in range(1, 10 ** 3)], [(lambda x: int(str(x) + str(x)[-2::-1]))(list_element) for list_element in range(10 ** 3)]))"	"from itertools import chain
A002113 = sorted(chain([(lambda x: int(str(x) + str(x)[::-1]))(list_element) for list_element in range(1, 10 ** 3)], [(lambda x: int(str(x) + str(x)[-2::-1]))(list_element) for list_element in range(10 ** 3)]))"
A002113	Palindromes in base 10.	0,1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,141,151,161,171,181,191,202,212,222,232,242,252,262,272,282,292,303,313,323,333,343,353,363,373,383,393,404,414,424,434,444,454,464,474,484,494,505,515	"
from itertools import chain, count
A002113 = chain(k for k in count(0) if str(k) == str(k)[::-1])
print([next(A002113) for k in range(60)]) 
"	"from itertools import chain, count
A002113 = chain((k for k in count(0) if str(k) == str(k)[::-1]))
print([next(A002113) for k in range(60)])"	"from itertools import chain, count
A002113 = chain((k for k in count(0) if str(k) == str(k)[::-1]))
print([next(A002113) for k in range(60)])"	"from itertools import chain, count
A002113 = chain((k for k in count(0) if str(k) == str(k)[::-1]))
print([next(A002113) for k in range(60)])"	"from itertools import chain, count
A002113 = chain((k for k in count(0) if str(k) == str(k)[::-1]))
print([next(A002113) for k in range(60)])"	"from itertools import chain, count
A002113 = chain((k for k in count(0) if str(k) == str(k)[::-1]))
print([next(A002113) for k in range(60)])"
A002385	Palindromic primes: prime numbers whose decimal expansion is a palindrome.	2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181	"
from itertools import chain
from sympy import isprime
A002385 = sorted((n for n in chain((int(str(x)+str(x)[::-1]) for x in range(1,10**5)),(int(str(x)+str(x)[-2::-1]) for x in range(1,10**5))) if isprime(n))) 
"	"from itertools import chain
from sympy import isprime
A002385 = sorted((n for n in chain((int(str(x) + str(x)[::-1]) for x in range(1, 10 ** 5)), (int(str(x) + str(x)[-2::-1]) for x in range(1, 10 ** 5))) if isprime(n)))"	"from itertools import chain
from sympy import isprime
A002385 = sorted((n for n in chain((int(str(x) + str(x)[::-1]) for x in range(1, 10 ** 5)), (int(str(x) + str(x)[-2::-1]) for x in range(1, 10 ** 5))) if isprime(n)))"	"from itertools import chain
from sympy import isprime
A002385 = sorted((n for n in chain((int(str(x) + str(x)[::-1]) for x in range(1, 10 ** 5)), (int(str(x) + str(x)[-2::-1]) for x in range(1, 10 ** 5))) if isprime(n)))"	"from itertools import chain
from sympy import isprime
A002385 = sorted((n for n in chain((int(str(x) + str(x)[::-1]) for x in range(1, 10 ** 5)), (int(str(x) + str(x)[-2::-1]) for x in range(1, 10 ** 5))) if isprime(n)))"	"from itertools import chain
from sympy import isprime
A002385 = sorted((n for n in chain((int(str(x) + str(x)[::-1]) for x in range(1, 10 ** 5)), (int(str(x) + str(x)[-2::-1]) for x in range(1, 10 ** 5))) if isprime(n)))"
A002407	Cuban primes: primes which are the difference of two consecutive cubes.	7,19,37,61,127,271,331,397,547,631,919,1657,1801,1951,2269,2437,2791,3169,3571,4219,4447,5167,5419,6211,7057,7351,8269,9241,10267,11719,12097,13267,13669,16651,19441,19927,22447,23497,24571,25117,26227,27361,33391	"
from sympy import isprime
def aupto(limit):
    alst, k, d = [], 1, 7
    while d <= limit:
        if isprime(d): alst.append(d)
        k += 1; d = 1+3*k*(k+1)
    return alst
print(aupto(34000)) 
"	"from sympy import isprime

def aupto(limit):
    (alst, k, d) = ([], 1, 7)
    while d <= limit:
        if isprime(d):
            alst.append(d)
        k += 1
        d = 1 + 3 * k * (k + 1)
    return alst
print(aupto(34000))"	"from sympy import isprime

def aupto(limit):
    (alst, k, d) = ([], 1, 7)
    while d <= limit:
        if isprime(d):
            alst.append(d)
        k += 1
        d = 1 + 3 * k * (k + 1)
    return alst
print(aupto(34000))"	"from sympy import isprime

def aupto(limit):
    (alst, k, d) = ([], 1, 7)
    while d <= limit:
        if isprime(d):
            alst.append(d)
        k += 1
        d = 1 + 3 * k * (k + 1)
    return alst
print(aupto(34000))"	"from sympy import isprime

def aupto(limit):
    (alst, k, d) = ([], 1, 7)
    while d <= limit:
        if isprime(d):
            alst.append(d)
        k += 1
        d = 1 + 3 * k * (k + 1)
    return alst
print(aupto(34000))"	"from sympy import isprime

def aupto(limit):
    (alst, k, d) = ([], 1, 7)
    while d <= limit:
        if isprime(d):
            alst.append(d)
        k += 1
        d = 1 + 3 * k * (k + 1)
    return alst
print(aupto(34000))"
A002779	Palindromic squares.	0,1,4,9,121,484,676,10201,12321,14641,40804,44944,69696,94249,698896,1002001,1234321,4008004,5221225,6948496,100020001,102030201,104060401,121242121,123454321,125686521,400080004,404090404,522808225	"
A002779_list = [int(s) for s in (str(m**2) for m in range(10**5)) if s == s[::-1]] 
"	A002779_list = [int(s) for s in (str(m ** 2) for m in range(10 ** 5)) if s == s[::-1]]	A002779_list = [int(s) for s in (str(m ** 2) for m in range(10 ** 5)) if s == s[::-1]]	A002779_list = [int(s) for s in (str(m ** 2) for m in range(10 ** 5)) if s == s[::-1]]	"A002779_list = {*()}
for s in (str(m ** 2) for m in range(10 ** 5)):
    if s == s[::-1]:A002779_list.append(int(s))"	"A002779_list = {*()}
for s in (str(m ** 2) for m in range(10 ** 5)):
    if s == s[::-1]:A002779_list.append(int(s))"
A002796	Numbers that are divisible by each nonzero digit.	1,2,3,4,5,6,7,8,9,10,11,12,15,20,22,24,30,33,36,40,44,48,50,55,60,66,70,77,80,88,90,99,100,101,102,104,105,110,111,112,115,120,122,124,126,128,132,135,140,144,150,155,162,168,175,184,200,202,204,208,210,212	"
A002796_list = []
for i in range(1,10**5):
    for d in set(str(i)):
        if d != '0' and i % int(d):
            break
    else:
        A002796_list.append(i) 
"	"A002796_list = []
for i in range(1, 10 ** 5):
    for d in set(str(i)):
        if d != '0' and i % int(d):
            break
    else:
        A002796_list.append(i)"	"A002796_list = []
sequence_iterator = iter(range(1, 10 ** 5))
while True:
    try:
        i = next(sequence_iterator)
        sequence_iterator = iter(set(str(i)))
        while True:
            try:
                d = next(sequence_iterator)
                if d != '0' and i % int(d):
                    break
            except StopIteration:
                break
    except StopIteration:
        break"	"A002796_list = []
sequence_iterator = iter(range(1, 10 ** 5))
while True:
    try:
        i = next(sequence_iterator)
        sequence_iterator = iter(set(str(i)))
        while True:
            try:
                d = next(sequence_iterator)
                if d != '0' and i % int(d):
                    break
            except StopIteration:
                break
    except StopIteration:
        break"	"A002796_list = []
sequence_iterator = iter(range(1, 10 ** 5))
while True:
    try:
        i = next(sequence_iterator)
        sequence_iterator = iter(set(str(i)))
        while True:
            try:
                d = next(sequence_iterator)
                if d != '0' and i % int(d):
                    break
            except StopIteration:
                break
    except StopIteration:
        break"	"A002796_list = []
sequence_iterator = iter(range(1, 10 ** 5))
while True:
    try:
        i = next(sequence_iterator)
        sequence_iterator = iter(set(str(i)))
        while True:
            try:
                d = next(sequence_iterator)
                if d != '0' and i % int(d):
                    break
            except StopIteration:
                break
    except StopIteration:
        break"
A003098	Palindromic triangular numbers.	0,1,3,6,55,66,171,595,666,3003,5995,8778,15051,66066,617716,828828,1269621,1680861,3544453,5073705,5676765,6295926,35133153,61477416,178727871,1264114621,1634004361,5289009825,6172882716,13953435931	"
A003098_list = [m for m in (n*(n+1)//2 for n in range(10**5)) if str(m) == str(m)[::-1]] 
"	A003098_list = [m for m in (n * (n + 1) // 2 for n in range(10 ** 5)) if str(m) == str(m)[::-1]]	A003098_list = [m for m in (n * (n + 1) // 2 for n in range(10 ** 5)) if str(m) == str(m)[::-1]]	A003098_list = [m for m in (n * (n + 1) // 2 for n in range(10 ** 5)) if str(m) == str(m)[::-1]]	"A003098_list = {*()}
for m in (n * (n + 1) // 2 for n in range(10 ** 5)):
    if str(m) == str(m)[::-1]:A003098_list.append(m)"	"A003098_list = {*()}
for m in (n * (n + 1) // 2 for n in range(10 ** 5)):
    if str(m) == str(m)[::-1]:A003098_list.append(m)"
A003132	Sum of squares of digits of n.	0,1,4,9,16,25,36,49,64,81,1,2,5,10,17,26,37,50,65,82,4,5,8,13,20,29,40,53,68,85,9,10,13,18,25,34,45,58,73,90,16,17,20,25,32,41,52,65,80,97,25,26,29,34,41,50,61,74,89,106,36,37,40,45,52,61,72,85,100,117,49	"
def A003132(n): return sum(int(d)**2 for d in str(n)) 
"	"def A003132(n):
    return sum((int(d) ** 2 for d in str(n)))"	"def A003132(n):
    return sum((int(d) ** 2 for d in str(n)))"	"def A003132(n):
    return sum((int(d) ** 2 for d in str(n)))"	"def A003132(n):
    return sum((int(d) ** 2 for d in str(n)))"	"def A003132(n):
    return sum((int(d) ** 2 for d in str(n)))"
A003325	Numbers that are the sum of 2 positive cubes.	2,9,16,28,35,54,65,72,91,126,128,133,152,189,217,224,243,250,280,341,344,351,370,407,432,468,513,520,539,559,576,637,686,728,730,737,756,793,854,855,945,1001,1008,1024,1027,1064,1072,1125,1216,1241,1332,1339,1343	"
from sympy import integer_nthroot
def aupto(lim):
  cubes = [i*i*i for i in range(1, integer_nthroot(lim-1, 3)[0] + 1)]
  sum_cubes = sorted([a+b for i, a in enumerate(cubes) for b in cubes[i:]])
  return [s for s in sum_cubes if s <= lim]
print(aupto(1343)) 
"	"from sympy import integer_nthroot

def aupto(lim):
    cubes = [i * i * i for i in range(1, integer_nthroot(lim - 1, 3)[0] + 1)]
    sum_cubes = sorted([a + b for (i, a) in enumerate(cubes) for b in cubes[i:]])
    return [s for s in sum_cubes if s <= lim]
print(aupto(1343))"	"from sympy import integer_nthroot

def aupto(lim):
    cubes = [i * i * i for i in range(1, integer_nthroot(lim - 1, 3)[0] + 1)]
    sum_cubes = sorted([a + b for (i, a) in enumerate(cubes) for b in cubes[i:]])
    return [s for s in sum_cubes if s <= lim]
print(aupto(1343))"	"from sympy import integer_nthroot

def aupto(lim):
    cubes = [i * i * i for i in range(1, integer_nthroot(lim - 1, 3)[0] + 1)]
    sum_cubes = sorted([a + b for (i, a) in enumerate(cubes) for b in cubes[i:]])
    return [s for s in sum_cubes if s <= lim]
print(aupto(1343))"	"from sympy import integer_nthroot

def aupto(lim):
    cubes = {*()}
    for i in range(1, integer_nthroot(lim - 1, 3)[0] + 1):cubes.append(i * i * i)
    sum_cubes = sorted([a + b for (i, a) in enumerate(cubes) for b in cubes[i:]])
    return [s for s in sum_cubes if s <= lim]
print(aupto(1343))"	"from sympy import integer_nthroot

def aupto(lim):
    cubes = {*()}
    for i in range(1, integer_nthroot(lim - 1, 3)[0] + 1):cubes.append(i * i * i)
    sum_cubes = sorted([a + b for (i, a) in enumerate(cubes) for b in cubes[i:]])
    return list((s for s in sum_cubes if s <= lim))
print(aupto(1343))"
A003328	Numbers that are the sum of 5 positive cubes.	5,12,19,26,31,33,38,40,45,52,57,59,64,68,71,75,78,82,83,89,90,94,96,97,101,108,109,115,116,120,127,129,131,134,135,136,138,143,145,146,150,152,153,155,157,162,164,169,171,172,176,181,183,188,190,192,194,195,199	"
from collections import Counter
from itertools import combinations_with_replacement as combs_w_rep
def aupto(lim):
  s = filter(lambda x: x<=lim, (i**3 for i in range(1, int(lim**(1/3))+2)))
  s2 = filter(lambda x: x<=lim, (sum(c) for c in combs_w_rep(s, 5)))
  s2counts = Counter(s2)
  return sorted(k for k in s2counts)
print(aupto(200)) 
"	"from collections import Counter
from itertools import combinations_with_replacement as combs_w_rep

def aupto(lim):
    s = [list_element for list_element in (i ** 3 for i in range(1, int(lim ** (1 / 3)) + 2)) if (lambda x: x <= lim)(list_element)]
    s2 = [list_element for list_element in (sum(c) for c in combs_w_rep(s, 5)) if (lambda x: x <= lim)(list_element)]
    s2counts = Counter(s2)
    return sorted((k for k in s2counts))
print(aupto(200))"	"from collections import Counter
from itertools import combinations_with_replacement as combs_w_rep

def aupto(lim):
    s = [list_element for list_element in (i ** 3 for i in range(1, int(lim ** (1 / 3)) + 2)) if (lambda x: x <= lim)(list_element)]
    s2 = [list_element for list_element in (sum(c) for c in combs_w_rep(s, 5)) if (lambda x: x <= lim)(list_element)]
    s2counts = Counter(s2)
    return sorted((k for k in s2counts))
print(aupto(200))"	"from collections import Counter
from itertools import combinations_with_replacement as combs_w_rep

def aupto(lim):
    s = [list_element for list_element in (i ** 3 for i in range(1, int(lim ** (1 / 3)) + 2)) if (lambda x: x <= lim)(list_element)]
    s2 = [list_element for list_element in (sum(c) for c in combs_w_rep(s, 5)) if (lambda x: x <= lim)(list_element)]
    s2counts = Counter(s2)
    return sorted((k for k in s2counts))
print(aupto(200))"	"from collections import Counter
from itertools import combinations_with_replacement as combs_w_rep

def aupto(lim):
    s = {*()}
    for list_element in (i ** 3 for i in range(1, int(lim ** (1 / 3)) + 2)):
        if (lambda x: x <= lim)(list_element):s.append(list_element)
    s2 = {*()}
    for list_element in (sum(c) for c in combs_w_rep(s, 5)):
        if (lambda x: x <= lim)(list_element):s2.append(list_element)
    s2counts = Counter(s2)
    return sorted((k for k in s2counts))
print(aupto(200))"	"from collections import Counter
from itertools import combinations_with_replacement as combs_w_rep

def aupto(lim):
    s = {*()}
    for list_element in (i ** 3 for i in range(1, int(lim ** (1 / 3)) + 2)):
        if (lambda x: x <= lim)(list_element):s.append(list_element)
    s2 = {*()}
    for list_element in (sum(c) for c in combs_w_rep(s, 5)):
        if (lambda x: x <= lim)(list_element):s2.append(list_element)
    s2counts = Counter(s2)
    return sorted((k for k in s2counts))
print(aupto(200))"
A003329	Numbers that are the sum of 6 positive cubes.	6,13,20,27,32,34,39,41,46,48,53,58,60,65,67,69,72,76,79,83,84,86,90,91,95,97,98,102,104,105,109,110,116,117,121,123,124,128,130,132,135,136,137,139,142,143,144,146,147,151,153,154,156,158,160,161,162,163,165,170	"
from collections import Counter
from itertools import combinations_with_replacement as multi_combs
def aupto(lim):
  c = filter(lambda x: x<=lim, (i**3 for i in range(1, int(lim**(1/3))+2)))
  s = filter(lambda x: x<=lim, (sum(mc) for mc in multi_combs(c, 6)))
  counts = Counter(s)
  return sorted(k for k in counts)
print(aupto(170)) 
"	"from collections import Counter
from itertools import combinations_with_replacement as multi_combs

def aupto(lim):
    c = [list_element for list_element in (i ** 3 for i in range(1, int(lim ** (1 / 3)) + 2)) if (lambda x: x <= lim)(list_element)]
    s = [list_element for list_element in (sum(mc) for mc in multi_combs(c, 6)) if (lambda x: x <= lim)(list_element)]
    counts = Counter(s)
    return sorted((k for k in counts))
print(aupto(170))"	"from collections import Counter
from itertools import combinations_with_replacement as multi_combs

def aupto(lim):
    c = [list_element for list_element in (i ** 3 for i in range(1, int(lim ** (1 / 3)) + 2)) if (lambda x: x <= lim)(list_element)]
    s = [list_element for list_element in (sum(mc) for mc in multi_combs(c, 6)) if (lambda x: x <= lim)(list_element)]
    counts = Counter(s)
    return sorted((k for k in counts))
print(aupto(170))"	"from collections import Counter
from itertools import combinations_with_replacement as multi_combs

def aupto(lim):
    c = [list_element for list_element in (i ** 3 for i in range(1, int(lim ** (1 / 3)) + 2)) if (lambda x: x <= lim)(list_element)]
    s = [list_element for list_element in (sum(mc) for mc in multi_combs(c, 6)) if (lambda x: x <= lim)(list_element)]
    counts = Counter(s)
    return sorted((k for k in counts))
print(aupto(170))"	"from collections import Counter
from itertools import combinations_with_replacement as multi_combs

def aupto(lim):
    c = {*()}
    for list_element in (i ** 3 for i in range(1, int(lim ** (1 / 3)) + 2)):
        if (lambda x: x <= lim)(list_element):c.append(list_element)
    s = {*()}
    for list_element in (sum(mc) for mc in multi_combs(c, 6)):
        if (lambda x: x <= lim)(list_element):s.append(list_element)
    counts = Counter(s)
    return sorted((k for k in counts))
print(aupto(170))"	"from collections import Counter
from itertools import combinations_with_replacement as multi_combs

def aupto(lim):
    c = {*()}
    for list_element in (i ** 3 for i in range(1, int(lim ** (1 / 3)) + 2)):
        if (lambda x: x <= lim)(list_element):c.append(list_element)
    s = {*()}
    for list_element in (sum(mc) for mc in multi_combs(c, 6)):
        if (lambda x: x <= lim)(list_element):s.append(list_element)
    counts = Counter(s)
    return sorted((k for k in counts))
print(aupto(170))"
A003331	Numbers that are the sum of 8 positive cubes.	8,15,22,29,34,36,41,43,48,50,55,57,60,62,64,67,69,71,74,76,78,81,83,85,86,88,92,93,95,97,99,100,102,104,106,107,111,112,113,114,118,119,120,121,123,125,126,130,132,133,134,137,138,139,140,141,144,145,146,148,149	"
from itertools import combinations_with_replacement as mc
def aupto(lim):
    cbs = (i**3 for i in range(1, int((lim-7)**(1/3))+2))
    return sorted(set(k for k in (sum(c) for c in mc(cbs, 8)) if k <= lim))
print(aupto(150)) 
"	"from itertools import combinations_with_replacement as mc

def aupto(lim):
    cbs = (i ** 3 for i in range(1, int((lim - 7) ** (1 / 3)) + 2))
    return sorted(set((k for k in (sum(c) for c in mc(cbs, 8)) if k <= lim)))
print(aupto(150))"	"from itertools import combinations_with_replacement as mc

def aupto(lim):
    cbs = (i ** 3 for i in range(1, int((lim - 7) ** (1 / 3)) + 2))
    return sorted(set((k for k in (sum(c) for c in mc(cbs, 8)) if k <= lim)))
print(aupto(150))"	"from itertools import combinations_with_replacement as mc

def aupto(lim):
    cbs = (i ** 3 for i in range(1, int((lim - 7) ** (1 / 3)) + 2))
    return sorted(set((k for k in (sum(c) for c in mc(cbs, 8)) if k <= lim)))
print(aupto(150))"	"from itertools import combinations_with_replacement as mc

def aupto(lim):
    cbs = (i ** 3 for i in range(1, int((lim - 7) ** (1 / 3)) + 2))
    return sorted(set((k for k in (sum(c) for c in mc(cbs, 8)) if k <= lim)))
print(aupto(150))"	"from itertools import combinations_with_replacement as mc

def aupto(lim):
    cbs = (i ** 3 for i in range(1, int((lim - 7) ** (1 / 3)) + 2))
    return sorted(set((k for k in (sum(c) for c in mc(cbs, 8)) if k <= lim)))
print(aupto(150))"
A003336	Numbers that are the sum of 2 positive 4th powers.	2,17,32,82,97,162,257,272,337,512,626,641,706,881,1250,1297,1312,1377,1552,1921,2402,2417,2482,2592,2657,3026,3697,4097,4112,4177,4352,4721,4802,5392,6497,6562,6577,6642,6817,7186,7857,8192,8962,10001,10016,10081,10256,10625	"
def aupto(lim):
  p1 = set(i**4 for i in range(1, int(lim**.25)+2) if i**4 <= lim)
  p2 = set(a+b for a in p1 for b in p1 if a+b <= lim)
  return sorted(p2)
print(aupto(10625)) 
"	"def aupto(lim):
    p1 = set((i ** 4 for i in range(1, int(lim ** 0.25) + 2) if i ** 4 <= lim))
    p2 = set((a + b for a in p1 for b in p1 if a + b <= lim))
    return sorted(p2)
print(aupto(10625))"	"def aupto(lim):
    p1 = set((i ** 4 for i in range(1, int(lim ** 0.25) + 2) if i ** 4 <= lim))
    p2 = set((a + b for a in p1 for b in p1 if a + b <= lim))
    return sorted(p2)
print(aupto(10625))"	"def aupto(lim):
    p1 = set((i ** 4 for i in range(1, int(lim ** 0.25) + 2) if i ** 4 <= lim))
    p2 = set((a + b for a in p1 for b in p1 if a + b <= lim))
    return sorted(p2)
print(aupto(10625))"	"def aupto(lim):
    p1 = set((i ** 4 for i in range(1, int(lim ** 0.25) + 2) if i ** 4 <= lim))
    p2 = set((a + b for a in p1 for b in p1 if a + b <= lim))
    return sorted(p2)
print(aupto(10625))"	"def aupto(lim):
    p1 = {i ** 4 for i in range(1, int(lim ** 0.25) + 2) if i ** 4 <= lim}
    p2 = {a + b for a in p1 for b in p1 if a + b <= lim}
    return sorted(p2)
print(aupto(10625))"
A003337	Numbers n which are the sum of 3 nonzero 4th powers.	3,18,33,48,83,98,113,163,178,243,258,273,288,338,353,418,513,528,593,627,642,657,707,722,768,787,882,897,962,1137,1251,1266,1298,1313,1328,1331,1378,1393,1458,1506,1553,1568,1633,1808,1875,1922,1937,2002,2177	"
def aupto(lim):
  p1 = set(i**4 for i in range(1, int(lim**.25)+2) if i**4 <= lim)
  p2 = set(a+b for a in p1 for b in p1 if a+b <= lim)
  p3 = set(apb+c for apb in p2 for c in p1 if apb+c <= lim)
  return sorted(p3)
print(aupto(2400)) 
"	"def aupto(lim):
    p1 = set((i ** 4 for i in range(1, int(lim ** 0.25) + 2) if i ** 4 <= lim))
    p2 = set((a + b for a in p1 for b in p1 if a + b <= lim))
    p3 = set((apb + c for apb in p2 for c in p1 if apb + c <= lim))
    return sorted(p3)
print(aupto(2400))"	"def aupto(lim):
    p1 = set((i ** 4 for i in range(1, int(lim ** 0.25) + 2) if i ** 4 <= lim))
    p2 = set((a + b for a in p1 for b in p1 if a + b <= lim))
    p3 = set((apb + c for apb in p2 for c in p1 if apb + c <= lim))
    return sorted(p3)
print(aupto(2400))"	"def aupto(lim):
    p1 = set((i ** 4 for i in range(1, int(lim ** 0.25) + 2) if i ** 4 <= lim))
    p2 = set((a + b for a in p1 for b in p1 if a + b <= lim))
    p3 = set((apb + c for apb in p2 for c in p1 if apb + c <= lim))
    return sorted(p3)
print(aupto(2400))"	"def aupto(lim):
    p1 = set((i ** 4 for i in range(1, int(lim ** 0.25) + 2) if i ** 4 <= lim))
    p2 = set((a + b for a in p1 for b in p1 if a + b <= lim))
    p3 = set((apb + c for apb in p2 for c in p1 if apb + c <= lim))
    return sorted(p3)
print(aupto(2400))"	"def aupto(lim):
    p1 = {i ** 4 for i in range(1, int(lim ** 0.25) + 2) if i ** 4 <= lim}
    p2 = {a + b for a in p1 for b in p1 if a + b <= lim}
    p3 = {apb + c for apb in p2 for c in p1 if apb + c <= lim}
    return sorted(p3)
print(aupto(2400))"
A003338	Numbers that are the sum of 4 nonzero 4th powers.	4,19,34,49,64,84,99,114,129,164,179,194,244,259,274,289,304,324,339,354,369,419,434,499,514,529,544,594,609,628,643,658,673,674,708,723,738,769,784,788,803,849,868,883,898,913,963,978,1024,1043,1138,1153,1218	"
limit = 1218
from functools import lru_cache
qd = [k**4 for k in range(1, int(limit**.25)+2) if k**4 + 3 <= limit]
qds = set(qd)
@lru_cache(maxsize=None)
def findsums(n, m):
  if m == 1: return {(n, )} if n in qds else set()
  return set(tuple(sorted(t+(q,))) for q in qds for t in findsums(n-q, m-1))
print([n for n in range(4, limit+1) if len(findsums(n, 4)) >= 1]) 
"	"limit = 1218
from functools import lru_cache
qd = [k ** 4 for k in range(1, int(limit ** 0.25) + 2) if k ** 4 + 3 <= limit]
qds = set(qd)

@lru_cache(maxsize=None)
def findsums(n, m):
    if m == 1:
        return {(n,)} if n in qds else set()
    return set((tuple(sorted(t + (q,))) for q in qds for t in findsums(n - q, m - 1)))
print([n for n in range(4, limit + 1) if len(findsums(n, 4)) >= 1])"	"limit = 1218
from functools import lru_cache
qd = [k ** 4 for k in range(1, int(limit ** 0.25) + 2) if k ** 4 + 3 <= limit]
qds = set(qd)

@lru_cache(maxsize=None)
def findsums(n, m):
    if m == 1:
        return {(n,)} if n in qds else set()
    return set((tuple(sorted(t + (q,))) for q in qds for t in findsums(n - q, m - 1)))
print([n for n in range(4, limit + 1) if len(findsums(n, 4)) >= 1])"	"limit = 1218
from functools import lru_cache
qd = [k ** 4 for k in range(1, int(limit ** 0.25) + 2) if k ** 4 + 3 <= limit]
qds = set(qd)

@lru_cache(maxsize=None)
def findsums(n, m):
    if m == 1:
        return {(n,)} if n in qds else set()
    return set((tuple(sorted(t + (q,))) for q in qds for t in findsums(n - q, m - 1)))
print([n for n in range(4, limit + 1) if len(findsums(n, 4)) >= 1])"	"limit = 1218
from functools import lru_cache
qd = {*()}
for k in range(1, int(limit ** 0.25) + 2):
    if k ** 4 + 3 <= limit:qd.append(k ** 4)
qds = set(qd)

@lru_cache(maxsize=None)
def findsums(n, m):
    if m == 1:
        return {(n,)} if n in qds else set()
    return set((tuple(sorted(t + (q,))) for q in qds for t in findsums(n - q, m - 1)))
print([n for n in range(4, limit + 1) if len(findsums(n, 4)) >= 1])"	"limit = 1218
from functools import lru_cache
qd = {*()}
for k in range(1, int(limit ** 0.25) + 2):
    if k ** 4 + 3 <= limit:qd.append(k ** 4)
qds = set(qd)

@lru_cache(maxsize=None)
def findsums(n, m):
    if m == 1:
        return {(n,)} if n in qds else set()
    return {tuple(sorted(t + (q,))) for q in qds for t in findsums(n - q, m - 1)}
print([n for n in range(4, limit + 1) if len(findsums(n, 4)) >= 1])"
A003339	Numbers that are the sum of 5 positive 4th powers.	5,20,35,50,65,80,85,100,115,130,145,165,180,195,210,245,260,275,290,305,320,325,340,355,370,385,405,420,435,450,500,515,530,545,560,580,595,610,625,629,644,659,674,675,689,690,709,724,739,754,755,770,785,789,800	"
from itertools import combinations_with_replacement as combs_with_rep
def aupto(limit):
  qd = [k**4 for k in range(1, int(limit**.25)+2) if k**4 + 4 <= limit]
  ss = set(sum(c) for c in combs_with_rep(qd, 5))
  return sorted(s for s in ss if s <= limit)
print(aupto(800)) 
"	"from itertools import combinations_with_replacement as combs_with_rep

def aupto(limit):
    qd = [k ** 4 for k in range(1, int(limit ** 0.25) + 2) if k ** 4 + 4 <= limit]
    ss = set((sum(c) for c in combs_with_rep(qd, 5)))
    return sorted((s for s in ss if s <= limit))
print(aupto(800))"	"from itertools import combinations_with_replacement as combs_with_rep

def aupto(limit):
    qd = [k ** 4 for k in range(1, int(limit ** 0.25) + 2) if k ** 4 + 4 <= limit]
    ss = set((sum(c) for c in combs_with_rep(qd, 5)))
    return sorted((s for s in ss if s <= limit))
print(aupto(800))"	"from itertools import combinations_with_replacement as combs_with_rep

def aupto(limit):
    qd = [k ** 4 for k in range(1, int(limit ** 0.25) + 2) if k ** 4 + 4 <= limit]
    ss = set((sum(c) for c in combs_with_rep(qd, 5)))
    return sorted((s for s in ss if s <= limit))
print(aupto(800))"	"from itertools import combinations_with_replacement as combs_with_rep

def aupto(limit):
    qd = {*()}
    for k in range(1, int(limit ** 0.25) + 2):
        if k ** 4 + 4 <= limit:qd.append(k ** 4)
    ss = set((sum(c) for c in combs_with_rep(qd, 5)))
    return sorted((s for s in ss if s <= limit))
print(aupto(800))"	"from itertools import combinations_with_replacement as combs_with_rep

def aupto(limit):
    qd = {*()}
    for k in range(1, int(limit ** 0.25) + 2):
        if k ** 4 + 4 <= limit:qd.append(k ** 4)
    ss = {sum(c) for c in combs_with_rep(qd, 5)}
    return sorted((s for s in ss if s <= limit))
print(aupto(800))"
A003340	Numbers that are the sum of 6 positive 4th powers.	6,21,36,51,66,81,86,96,101,116,131,146,161,166,181,196,211,226,246,261,276,291,306,321,326,336,341,356,371,386,401,406,421,436,451,466,486,501,516,531,546,561,576,581,596,611,626,630,641,645,660,661,675,676,690	"
from itertools import combinations_with_replacement as combs_with_rep
def aupto(limit):
    qd = [k**4 for k in range(1, int(limit**.25)+2) if k**4 + 5 <= limit]
    ss = set(sum(c) for c in combs_with_rep(qd, 6))
    return sorted(s for s in ss if s <= limit)
print(aupto(700)) 
"	"from itertools import combinations_with_replacement as combs_with_rep

def aupto(limit):
    qd = [k ** 4 for k in range(1, int(limit ** 0.25) + 2) if k ** 4 + 5 <= limit]
    ss = set((sum(c) for c in combs_with_rep(qd, 6)))
    return sorted((s for s in ss if s <= limit))
print(aupto(700))"	"from itertools import combinations_with_replacement as combs_with_rep

def aupto(limit):
    qd = [k ** 4 for k in range(1, int(limit ** 0.25) + 2) if k ** 4 + 5 <= limit]
    ss = set((sum(c) for c in combs_with_rep(qd, 6)))
    return sorted((s for s in ss if s <= limit))
print(aupto(700))"	"from itertools import combinations_with_replacement as combs_with_rep

def aupto(limit):
    qd = [k ** 4 for k in range(1, int(limit ** 0.25) + 2) if k ** 4 + 5 <= limit]
    ss = set((sum(c) for c in combs_with_rep(qd, 6)))
    return sorted((s for s in ss if s <= limit))
print(aupto(700))"	"from itertools import combinations_with_replacement as combs_with_rep

def aupto(limit):
    qd = {*()}
    for k in range(1, int(limit ** 0.25) + 2):
        if k ** 4 + 5 <= limit:qd.append(k ** 4)
    ss = set((sum(c) for c in combs_with_rep(qd, 6)))
    return sorted((s for s in ss if s <= limit))
print(aupto(700))"	"from itertools import combinations_with_replacement as combs_with_rep

def aupto(limit):
    qd = {*()}
    for k in range(1, int(limit ** 0.25) + 2):
        if k ** 4 + 5 <= limit:qd.append(k ** 4)
    ss = {sum(c) for c in combs_with_rep(qd, 6)}
    return sorted((s for s in ss if s <= limit))
print(aupto(700))"
A003341	Numbers that are the sum of 7 positive 4th powers.	7,22,37,52,67,82,87,97,102,112,117,132,147,162,167,177,182,197,212,227,242,247,262,277,292,307,322,327,337,342,352,357,372,387,402,407,417,422,437,452,467,482,487,502,517,532,547,562,567,577,582,592,597,612,627	"
from itertools import combinations_with_replacement as mc
def aupto(limit):
    qd = [k**4 for k in range(1, int(limit**.25)+2) if k**4 + 6 <= limit]
    ss = set(sum(c) for c in mc(qd, 7))
    return sorted(s for s in ss if s <= limit)
print(aupto(630)) 
"	"from itertools import combinations_with_replacement as mc

def aupto(limit):
    qd = [k ** 4 for k in range(1, int(limit ** 0.25) + 2) if k ** 4 + 6 <= limit]
    ss = set((sum(c) for c in mc(qd, 7)))
    return sorted((s for s in ss if s <= limit))
print(aupto(630))"	"from itertools import combinations_with_replacement as mc

def aupto(limit):
    qd = [k ** 4 for k in range(1, int(limit ** 0.25) + 2) if k ** 4 + 6 <= limit]
    ss = set((sum(c) for c in mc(qd, 7)))
    return sorted((s for s in ss if s <= limit))
print(aupto(630))"	"from itertools import combinations_with_replacement as mc

def aupto(limit):
    qd = [k ** 4 for k in range(1, int(limit ** 0.25) + 2) if k ** 4 + 6 <= limit]
    ss = set((sum(c) for c in mc(qd, 7)))
    return sorted((s for s in ss if s <= limit))
print(aupto(630))"	"from itertools import combinations_with_replacement as mc

def aupto(limit):
    qd = {*()}
    for k in range(1, int(limit ** 0.25) + 2):
        if k ** 4 + 6 <= limit:qd.append(k ** 4)
    ss = set((sum(c) for c in mc(qd, 7)))
    return sorted((s for s in ss if s <= limit))
print(aupto(630))"	"from itertools import combinations_with_replacement as mc

def aupto(limit):
    qd = {*()}
    for k in range(1, int(limit ** 0.25) + 2):
        if k ** 4 + 6 <= limit:qd.append(k ** 4)
    ss = {sum(c) for c in mc(qd, 7)}
    return sorted((s for s in ss if s <= limit))
print(aupto(630))"
A003342	Numbers that are the sum of 8 positive 4th powers.	8,23,38,53,68,83,88,98,103,113,118,128,133,148,163,168,178,183,193,198,213,228,243,248,258,263,278,293,308,323,328,338,343,353,358,368,373,388,403,408,418,423,433,438,453,468,483,488,498,503,518,533,548,563,568	"
from itertools import combinations_with_replacement as mc
from sympy import integer_nthroot
def iroot4(n): return integer_nthroot(n, 4)[0]
def aupto(lim):
    pows4 = set(i**4 for i in range(1, iroot4(lim)+1) if i**4 <= lim)
    return sorted(t for t in set(sum(c) for c in mc(pows4, 8)) if t <= lim)
print(aupto(568)) 
"	"from itertools import combinations_with_replacement as mc
from sympy import integer_nthroot

def iroot4(n):
    return integer_nthroot(n, 4)[0]

def aupto(lim):
    pows4 = set((i ** 4 for i in range(1, iroot4(lim) + 1) if i ** 4 <= lim))
    return sorted((t for t in set((sum(c) for c in mc(pows4, 8))) if t <= lim))
print(aupto(568))"	"from itertools import combinations_with_replacement as mc
from sympy import integer_nthroot

def iroot4(n):
    return integer_nthroot(n, 4)[0]

def aupto(lim):
    pows4 = set((i ** 4 for i in range(1, iroot4(lim) + 1) if i ** 4 <= lim))
    return sorted((t for t in set((sum(c) for c in mc(pows4, 8))) if t <= lim))
print(aupto(568))"	"from itertools import combinations_with_replacement as mc
from sympy import integer_nthroot

def iroot4(n):
    return integer_nthroot(n, 4)[0]

def aupto(lim):
    pows4 = set((i ** 4 for i in range(1, iroot4(lim) + 1) if i ** 4 <= lim))
    return sorted((t for t in set((sum(c) for c in mc(pows4, 8))) if t <= lim))
print(aupto(568))"	"from itertools import combinations_with_replacement as mc
from sympy import integer_nthroot

def iroot4(n):
    return integer_nthroot(n, 4)[0]

def aupto(lim):
    pows4 = set((i ** 4 for i in range(1, iroot4(lim) + 1) if i ** 4 <= lim))
    return sorted((t for t in set((sum(c) for c in mc(pows4, 8))) if t <= lim))
print(aupto(568))"	"from itertools import combinations_with_replacement as mc
from sympy import integer_nthroot

def iroot4(n):
    return integer_nthroot(n, 4)[0]

def aupto(lim):
    pows4 = {i ** 4 for i in range(1, iroot4(lim) + 1) if i ** 4 <= lim}
    return sorted((t for t in set((sum(c) for c in mc(pows4, 8))) if t <= lim))
print(aupto(568))"
A003344	Numbers that are the sum of 10 positive 4th powers.	10,25,40,55,70,85,90,100,105,115,120,130,135,145,150,160,165,170,180,185,195,200,210,215,225,230,245,250,260,265,275,280,290,295,310,325,330,340,345,355,360,370,375,385,390,400,405,410,420,425,435,440,450,455,465	"
from itertools import count, takewhile, combinations_with_replacement as mc
def aupto(limit):
    pows4 = list(takewhile(lambda x: x <= limit, (i**4 for i in count(1))))
    sum10 = set(sum(c) for c in mc(pows4, 10) if sum(c) <= limit)
    return sorted(sum10)
print(aupto(465)) 
"	"from itertools import count, takewhile, combinations_with_replacement as mc

def aupto(limit):
    pows4 = list(takewhile(lambda x: x <= limit, (i ** 4 for i in count(1))))
    sum10 = set((sum(c) for c in mc(pows4, 10) if sum(c) <= limit))
    return sorted(sum10)
print(aupto(465))"	"from itertools import count, takewhile, combinations_with_replacement as mc

def aupto(limit):
    pows4 = list(takewhile(lambda x: x <= limit, (i ** 4 for i in count(1))))
    sum10 = set((sum(c) for c in mc(pows4, 10) if sum(c) <= limit))
    return sorted(sum10)
print(aupto(465))"	"from itertools import count, takewhile, combinations_with_replacement as mc

def aupto(limit):
    pows4 = list(takewhile(lambda x: x <= limit, (i ** 4 for i in count(1))))
    sum10 = set((sum(c) for c in mc(pows4, 10) if sum(c) <= limit))
    return sorted(sum10)
print(aupto(465))"	"from itertools import count, takewhile, combinations_with_replacement as mc

def aupto(limit):
    pows4 = list(takewhile(lambda x: x <= limit, (i ** 4 for i in count(1))))
    sum10 = set((sum(c) for c in mc(pows4, 10) if sum(c) <= limit))
    return sorted(sum10)
print(aupto(465))"	"from itertools import count, takewhile, combinations_with_replacement as mc

def aupto(limit):
    pows4 = list(takewhile(lambda x: x <= limit, (i ** 4 for i in count(1))))
    sum10 = {sum(c) for c in mc(pows4, 10) if sum(c) <= limit}
    return sorted(sum10)
print(aupto(465))"
A003418	Least common multiple (or LCM) of {1, 2, ..., n} for n >= 1, a(0) = 1.	1,1,2,6,12,60,60,420,840,2520,2520,27720,27720,360360,360360,360360,720720,12252240,12252240,232792560,232792560,232792560,232792560,5354228880,5354228880,26771144400,26771144400,80313433200,80313433200,2329089562800,2329089562800	"
from functools import reduce
from operator import mul
from sympy import sieve
def integerlog(n,b): 
    kmin, kmax = 0,1
    while b**kmax <= n:
        kmax *= 2
    while True:
        kmid = (kmax+kmin)//2
        if b**kmid > n:
            kmax = kmid
        else:
            kmin = kmid
        if kmax-kmin <= 1:
            break
    return kmin
def A003418(n):
    return reduce(mul,(p**integerlog(n,p) for p in sieve.primerange(1,n+1)),1) 
"	"from functools import reduce
from operator import mul
from sympy import sieve

def integerlog(n, b):
    (kmin, kmax) = (0, 1)
    while b ** kmax <= n:
        kmax *= 2
    while True:
        kmid = (kmax + kmin) // 2
        if b ** kmid > n:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    return kmin

def A003418(n):
    return reduce(mul, (p ** integerlog(n, p) for p in sieve.primerange(1, n + 1)), 1)"	"from functools import reduce
from operator import mul
from sympy import sieve

def integerlog(n, b):
    (kmin, kmax) = (0, 1)
    while b ** kmax <= n:
        kmax *= 2
    while True:
        kmid = (kmax + kmin) // 2
        if b ** kmid > n:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    return kmin

def A003418(n):
    return reduce(mul, (p ** integerlog(n, p) for p in sieve.primerange(1, n + 1)), 1)"	"from functools import reduce
from operator import mul
from sympy import sieve

def integerlog(n, b):
    (kmin, kmax) = (0, 1)
    while b ** kmax <= n:
        kmax *= 2
    while True:
        kmid = (kmax + kmin) // 2
        if b ** kmid > n:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    return kmin

def A003418(n):
    return reduce(mul, (p ** integerlog(n, p) for p in sieve.primerange(1, n + 1)), 1)"	"from functools import reduce
from operator import mul
from sympy import sieve

def integerlog(n, b):
    (kmin, kmax) = (0, 1)
    while b ** kmax <= n:
        kmax *= 2
    while True:
        kmid = (kmax + kmin) // 2
        if b ** kmid > n:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    return kmin

def A003418(n):
    return reduce(mul, (p ** integerlog(n, p) for p in sieve.primerange(1, n + 1)), 1)"	"from functools import reduce
from operator import mul
from sympy import sieve

def integerlog(n, b):
    (kmin, kmax) = (0, 1)
    while b ** kmax <= n:
        kmax *= 2
    while True:
        kmid = (kmax + kmin) // 2
        if b ** kmid > n:
            kmax = kmid
        else:
            kmin = kmid
        if kmax - kmin <= 1:
            break
    return kmin

def A003418(n):
    return reduce(mul, (p ** integerlog(n, p) for p in sieve.primerange(1, n + 1)), 1)"
A003418	Least common multiple (or LCM) of {1, 2, ..., n} for n >= 1, a(0) = 1.	1,1,2,6,12,60,60,420,840,2520,2520,27720,27720,360360,360360,360360,720720,12252240,12252240,232792560,232792560,232792560,232792560,5354228880,5354228880,26771144400,26771144400,80313433200,80313433200,2329089562800,2329089562800	" 
from math import gcd
from itertools import accumulate
def lcm(a, b): return a * b // gcd(a, b)
def aupton(nn): return [1] + list(accumulate(range(1, nn+1), lcm))
print(aupton(30)) 
"	"from math import gcd
from itertools import accumulate

def lcm(a, b):
    return a * b // gcd(a, b)

def aupton(nn):
    return [1] + list(accumulate(range(1, nn + 1), lcm))
print(aupton(30))"	"from math import gcd
from itertools import accumulate

def lcm(a, b):
    return a * b // gcd(a, b)

def aupton(nn):
    return [1] + list(accumulate(range(1, nn + 1), lcm))
print(aupton(30))"	"from math import gcd
from itertools import accumulate

def lcm(a, b):
    return a * b // gcd(a, b)

def aupton(nn):
    return [1] + list(accumulate(range(1, nn + 1), lcm))
print(aupton(30))"	"from math import gcd
from itertools import accumulate

def lcm(a, b):
    return a * b // gcd(a, b)

def aupton(nn):
    return [1] + list(accumulate(range(1, nn + 1), lcm))
print(aupton(30))"	"from math import gcd
from itertools import accumulate

def lcm(a, b):
    return a * b // gcd(a, b)

def aupton(nn):
    return [1] + list(accumulate(range(1, nn + 1), lcm))
print(aupton(30))"
