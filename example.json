{"sequence_id":"A000378","text":"Sums of three squares: numbers of the form x^2 + y^2 + z^2.","sequence":"0,1,2,3,4,5,6,8,9,10,11,12,13,14,16,17,18,19,20,21,22,24,25,26,27,29,30,32,33,34,35,36,37,38,40,41,42,43,44,45,46,48,49,50,51,52,53,54,56,57,58,59,61,62,64,65,66,67,68,69,70,72,73,74,75,76,77,78,80,81,82,83","code":"\ndef valuation(n, b):\n    v = 0\n    while n > 1 and n%b == 0: n //= b; v += 1\n    return v\ndef ok(n): return n//4**valuation(n, 4)%8 != 7\nprint(list(filter(ok, range(84)))) \n","obfuscations":["def valuation(n, b):\n    v = 0\n    while n > 1 and n % b == 0:\n        n //= b\n        v += 1\n    return v\n\ndef ok(n):\n    return n // 4 ** valuation(n, 4) % 8 != 7\nprint(list([list_element for list_element in range(84) if ok(list_element)]))","def valuation(n, b):\n    v = 0\n    while n > 1 and n % b == 0:\n        n //= b\n        v += 1\n    return v\n\ndef ok(n):\n    return n // 4 ** valuation(n, 4) % 8 != 7\nprint(list([list_element for list_element in range(84) if ok(list_element)]))","def valuation(n, b):\n    v = 0\n    while n > 1 and n % b == 0:\n        n //= b\n        v += 1\n    return v\n\ndef ok(n):\n    return n // 4 ** valuation(n, 4) % 8 != 7\nprint(list([list_element for list_element in range(84) if ok(list_element)]))","def valuation(n, b):\n    v = 0\n    while n > 1 and n % b == 0:\n        n //= b\n        v += 1\n    return v\n\ndef ok(n):\n    return n // 4 ** valuation(n, 4) % 8 != 7\nprint(list([list_element for list_element in range(84) if ok(list_element)]))","def valuation(n, b):\n    v = 0\n    while n > 1 and n % b == 0:\n        n //= b\n        v += 1\n    return v\n\ndef ok(n):\n    return n // 4 ** valuation(n, 4) % 8 != 7\nprint(list([list_element for list_element in range(84) if ok(list_element)]))"],"completions":{"none":[" a list of Fibonacci numbers less than 84.\n\nmemo = dict()\n\ndef fib3(n: int) -> int:\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        f = 1\n    elif n == 1:\n        f = 1\n    else:\n        f = fib3(n-1) + fib3(n-2)\n    memo[n] ="," an array containing all numbers from 0 to 84, where the n-th element from the array is nth value displayed on the periodic table. The n-th value is True if every possible value of n that makes it to the end is one whose closest divisor apart from one is four to the power of a whole number. Otherwise, the n-th value is False.\n\ndef depth(t):\n    DEPTH_KEY = 42\n    if isinstance("," a list, which is a single level list containing a subset of the elements within an described list, as follows:\n\nReturn all the numbers 0 through 84, displayed by [list_element for list_element in range(84)].\n\nReturn all the numbers in the aforementioned list that divide cleanly by 4 (i.e 4**valuation(n, 4) % 8 != 7).\nprint(list([list_element for list_element in range(15) if"," non-bouncy numbers up to 10**(n-1).\n\nIf a number contains digits x1, x2, ..., xm and is divisible by a number b, then r(xm, b) plus r(x1, b) equals the number of ways in which xm can be split. Incidentally, if the sum of r(xm, b) and r(x1, b) equals zero, then the non-b"," a list of the n for which 1<n<84 and n % 8 != 7. As 1 mod 8 = 1, so n%8 != 7 means n must be any value between 1 and 84 that does not hemise modulo 8, inclusive. This can be seen from plotting n modulo 8: 1  2  3  4  5  6  7    8\n                    0  1  2  3  4  5  6  7\n                    1 "],"p":[" a list of every number in the range [0, 84), which themselves can be written as a sum of squares of two numbers that are themselves some power of two.\n\ndef val(i,b):\n    v = 1\n    j = 0\n    while j < i:\n        v *= b\n        j += 1\n    return v\n\nl = [True]*85\nfor test, k in (missingnum(510051005100"," all possible 2-digit numbers up to, and including, 84 that will not cause an overflow on the 15-bit IOTA tangle hash, which gets truncated to 8 bits. Each resulting number is, conceptually, broken down into two 8-bit parts. \nIn a real computer, each part are stored as individual unsigned integers, where after being added together they form the real number.\nGiven the form of the preceding result, Idea was to use this formula to \"shr"," all numbers less than 1000 that are not the sum of two perfect powers.\n\ndef min_val(*args):\n    m = args[0]\n    for x in args:\n        if x < m:\n            m = x\n    return m\n\nWith the above 4-line code, you're able to write a function that takes multiple arguments and returns their minimum value.\n'''"," a potential set of fully qualified car numbers, written as strings that begin with a fuel type code and end with a running number. Using only a len(list_instance) command instead of list comprehensions not similar to their friends would have been fine, even submitted as a solution, but next time try to think about what can be done for those cases in which simply unwrapping the output of a for loop is shorter and clearer. (In this case I'd argue the benefit is somewhat marginal"," the list of integers of 4'st degree from 2 (M0) to\n34 (M44) which are not the last members of a module 8 factorization of their\ndecimal expansion. The algorithm for doing this is described below:\n    0. If n is even or 1, return False.\n    1. Test for congruence modulo 8 in Z_{4} and calculate the valuation as\n       distance from 1 of the greatest root excluded from F_{n"],"f":[" a list of Sprague-Grundy integers that are not 7.\n\"\"\"\npass"," a list of all positive integers less than or equal to n that are NOT divisible by 7. For example,\n\nprint(list([list_element for list_element in range(84) if ok(list_element)]))\nreturns the list [0, 2, 3, 4, 5... 70] since 0 % 7 = 0 and this is not desired; 210 % 7 = 3 and (1+2+0) % 8 != 7. On the other"," good 2-cocycles on the 4n sphere.\n\ndef A(n):\n    return \"abaaababaab\" [n % 10]\n\n"," a list of Fibonacci numbers between 0 and 84, such that the number in question is divisible by 4. The code gives an error on the first result, 7036876073, so\nwe need to remove it from the list. \n\"\"\""," a list (yes, an entire list) of every n from 0 to 100 such that the n-th Fibonacci number is divisible 7 (but not 8).\n'''"],"pf":[" an iterable containing the list of numbers from 0 to 83 that have an 8th power modulo 4 which is congruent to 1.\n\ndef eval(n: int) -> int:\n    return sum_of((i+1)*list_element for i,list_element in enumerate([0] + digits[toString(n)]))\n\n"," a list of values that are composite but fail Goldbach's conjecture. In other words, it prints a list of odd composite numbers with no prime witness below 10^7\nModular divisions and logs in Python (to compute pow(a, b) % c) can be done as follows: use the fact that for integers a and b this is equivalent to logA + logB = logAB iff A^logA == B if their GCD is 1 -- applied repeatedly we get"," the sequence of values 0, 1 or 2 depending on whether a given entry in the Fibonacci function is as follows:\n\ndef ok(n):\n    return n // 4 ** valuation(n, 4) % 8 != 7  # yields 0 -> F_i mod 8 == 7 are Bad (impairs agreement between Alice and Bob)\n\n"," all the integers between 0 and 84 inclusive (non-inclusively) that are not 7 modulo 8.\n\n# You know nothing, John Snow!\nimport numpy as np\n\n\ndef make_data(n: int) -> np.array:\n    y = np.zeros((18,)) # <1> creates one row of 18 items all equal to zero         <2> The function will have no effect on this line since it only initializes arrays with"," a list, which contains all preferably-prime numbers up to and including 84.\n\nExample: ok(8) = True | 8//4*24 = 3 // i/j in 0.001527785212201996 seconds\n\"\"\""]}}
