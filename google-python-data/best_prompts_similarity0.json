{"prompt": {"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 595, "prompt": "Write a python function to count minimum number of swaps required to convert one binary number represented as a string to another.", "code": "def min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") ", "test_imports": [], "test_list": ["assert min_Swaps(\"1101\",\"1110\") == 1", "assert min_Swaps(\"111\",\"000\") == \"Not Possible\"", "assert min_Swaps(\"111\",\"110\") == \"Not Possible\""]}, "queries": [[0.12114854517593632, 0.12, 0.20904158920757898, "def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1\nThe above code is a function to find nth centered hexagonal number.\n\ndef find_star_num(n): \n\treturn (6 * n * (n - 1) + 1) \nThe above code is a function to find the n'th star number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " shows an interesting way to find minimum number of swaps whose result will be one of the star numbers.\ndef nth_star_number(n) : \n    if n < 1 : \n        return 0\n\n    dec_part = n % 1 \n    lower_val = floor(n) \n    upper_val = ceil(n) \n\n    # if n is an integral number \n    if dec_part == 0 : \n"], [0.10493553705172601, 0.08888888888888889, 0.19133607675163905, "def count(lst):   \n    return sum(lst) \nThe above code is a python function to count true booleans in the given list.\n\ndef replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2\nThe above code is a function to replace characters in a string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", ", counts how many positions in the two string needs to be swapped to change,\none string to another. \ndef pattern(n) : \n    \n  \n    for i in range(1, n + 1) : \n      \n   \n        for j in range(1, i + 1) : \n          \n          \n            \n            print(j, end = '') \n        print(\"\") \n  \n    for i in"], [0.06934553183491034, 0.13793103448275862, 0.15059015608288123, "def count(lst):   \n    return sum(lst) \nThe above code is a python function to count true booleans in the given list.\n\ndef surfacearea_cube(l):\n  surfacearea= 6*l*l\n  return surfacearea\nThe above code is a function to find the surface area of a cube of a given size.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function which returns minimum swap characters to make the two given strings equal.     \n"], [0.11210687213115017, 0.0847457627118644, 0.17185452490404154, "def Find_Min(lst): \n    return min(lst, key=len) \nThe above code is a python function to find the sublist having minimum length.\n\ndef replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2\nThe above code is a function to replace characters in a string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check if we can get string2 from string1 by swapping adjacent characters .\ndef num_pow_num(N1) : \n    sum = 0\n    while (N1) : \n        sum += (N1 % 10) ** 2\n        N1 = N1 // 10\n    return sum\nThe above code is a python function to return the sum of square of digits of the given number.\ndef check_p"], [0.15229163928286904, 0.14814814814814814, 0.1480116927103078, "def is_upper(string):\n  return (string.upper())\nThe above code is a python function to convert a given string to uppercase.\n\ndef Split(list): \n    return [num for num in list if num % 2 == 0]\nThe above code is a python function to find even numbers from a list of numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to know number of swaps required if all the characters of both strings are interchanged \nsuch that first and last characters remain unchanged.\ndef num_UniqW(str) : \n    dict = {}  \n    for ch in str : \n        dict[ch] = dict.get(ch,0) + 1\n    uniqList = []\n    for value in dict.values() : \n        if value == 1 :"], [0.09002696599846008, 0.14285714285714285, 0.14809547363788714, "def is_octagonal(n): \n\treturn 3 * n * n - 2 * n \nThe above code is a function to find the nth octagonal number.\n\ndef two_unique_nums(nums):\n  return [i for i in nums if nums.count(i)==1]\nThe above code is a python function to remove duplicate numbers from a given number of lists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find minimum swaps of characters.\n# def perfect_square(i) : \n#   return (int(i**0.5)**2== i) \n\n# def square_root(n) : \n#   i = 1\n#   result = 1\n#   while (result <= n) : \n#       i += 1\n#       result = i * i\n#   return (i - 1)\n"], [0.11772350226220239, 0.17307692307692307, 0.27556632407232945, "def Find_Min(lst): \n    return min(lst, key=len) \nThe above code is a python function to find the sublist having minimum length.\n\nimport re\ndef removezero_ip(ip):\n string = re.sub('\\.[0]*', '.', ip)\n return string\n\nThe above code is a function to remove leading zeroes from an ip address.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python progrma to count minimum swaps required.|\n\n\nGiven length of two strings and two integers: n,m. Assume n>=m and m>=1 , find number of matches of first n-m characters of shorter string in longer string.\ndef match_psy(str1,str2,n,m): \n    output_ls = []\n    while m <= len(str2):\n      ls = []\n      for"], [0.15174336658183987, 0.18421052631578946, 0.1557889777801708, "def count(lst):   \n    return sum(lst) \nThe above code is a python function to count true booleans in the given list.\n\ndef Find_Max_Length(lst):  \n    maxLength = max(len(x) for x in lst )\n    return maxLength \nThe above code is a python function to find the length of the longest sublists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the number of swaps to get the desired result.\ndef hackerrank_in_a_string(inputString) : \n    if 'h' not in inputString : \n        return (\"NO\") \n    elif 'a' not in inputString : \n        return (\"NO\") \n    elif 'c' not in inputString : \n        return (\"NO\") \n    elif 'k'"], [0.14275810950894874, 0.11764705882352941, 0.16199449039740893, "import re\ndef remove_whitespaces(text1):\n  return (re.sub(r'\\s+', '',text1))\nThe above code is a function to remove all whitespaces from the given string.\n\ndef Extract(lst): \n    return [item[0] for item in lst] \nThe above code is a python function to get the first element of each sublist.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " gives the number of swaps required to get an anagram pair.\n# If the file is small enough you can use \"input = ' '.join\"\nstr1 = input(\"type the first string : \")\nstr2 = input(\"type the second string : \")\nprint(\"Minimum Swap required is : \" ,min_Swaps(str1,str2))\n\ndef lcs(x,y) : \n    def lcs(x,y"], [0.20971428357957902, 0.19230769230769232, 0.19989106481901625, "def volume_cylinder(r,h):\n  volume=3.1415*r*r*h\n  return volume\nThe above code is a function that takes in the radius and height of a cylinder and returns the the volume.\n\ndef list_tuple(listx):\n  tuplex = tuple(listx)\n  return tuplex\nThe above code is a function to convert a list to a tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " returns a minimum number of swaps required to convert a string into another.\ndef lstSwap(lst, i, x):\n  for z in range(i + 1, len(lst) - x + i + 1):\n    lst[z] = lst[z] + 1\n  return (lst)\nThe above code swaps lst[i] with lst[i + 1] Modify the list lst to swap"], [0.21162029996722378, 0.36, 0.5285207410094981, "def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1\nThe above code is a function to find nth centered hexagonal number.\n\ndef cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums\nThe above code is a function to find cubes of individual elements in a list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that returns minimum number of swaps needed\nto convert string 1 to string 2. \n\n\"\"\""], [0.08754074052102603, 0.044444444444444446, 0.07585756267317913, "def smallest_num(xs):\n  return min(xs)\n\nThe above code is a python function to find smallest number in a list.\n\ndef sum_of_digits(nums):\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())\nThe above code is a function to compute the sum of digits of each number of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " will show us number of swaps.\ndef Stack_Swap(n) : \n    arr_hold = [] \n    for i in n : \n        arr_hold.insert(0, i) \n        print(arr_hold) \n        \n    for i in range(0, len(arr_hold)):  \n        print(arr_hold[i], end = \" \")\nThe above code will show us the number"], [0.1625802337546131, 0.16666666666666666, 0.1972562749312729, "def find(n,m):  \n    q = n//m \n    return (q)\nThe above code is a python function to find quotient of two numbers (rounded down to the nearest integer).\n\nimport math\ndef radian_degree(degree):\n radian = degree*(math.pi/180)\n return radian\nThe above code is a function to convert degrees to radians.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python code that takes two strings and compares them and returns the minimum number of swaps required to \nhave two strings exactly equal.\n\ndef swapstring(s) : \n    s = s.swapcase() \n    print (s) \n\nThe above code is a python code that converts all the uppercase letters to lower case and all the lower case leters to upper \ncases and returns the string with both cases swapped.\n\n"], [0.1355754326122043, 0.15384615384615385, 0.22106482688863371, "def ascii_value(k):\n  ch=k\n  return ord(ch)\nThe above code is a function to find the ascii value of a character.\n\ndef even_position(nums):\n\treturn all(nums[i]%2==i%2 for i in range(len(nums)))\nThe above code is a python function to check whether every even index contains even numbers of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a program to count the minit of swaps required to get two strings.\nThe above code is a program to count the minit of swaps required to get two strings.\nn=int(input())\na = len(list(filter(lambda x:x>=0,[int(i) for i in input().split()])))\nb = len(list(filter(lambda x:x<0,[int(i) for i in input().split"], [0.11212624110563928, 0.16326530612244897, 0.2558038857941125, "def swap_numbers(a,b):\n temp = a\n a = b\n b = temp\n return (a,b)\nThe above code is a function that takes in two numbers and returns a tuple with the second number and then the first number.\n\ndef list_tuple(listx):\n  tuplex = tuple(listx)\n  return tuplex\nThe above code is a function to convert a list to a tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to print how many swaps are needed to convert the given string to one another.\ndef compound_interest(p,t,r=1) : \n    CI =  p*(1 + r/100)**2 \n    print(CI)\nThe above code is a function to compute compund interest.\ndef Alphabet(pattern) : \n    if len(pattern) == 1 : \n        if pattern in pattern.isalpha"], [0.19578109091630486, 0.1956521739130435, 0.23501169434790992, "import re\ndef remove_lowercase(str1):\n return re.sub('[a-z]', '', str1)\nThe above code is a function to remove lowercase substrings from a given string.\n\nimport re\ndef removezero_ip(ip):\n string = re.sub('\\.[0]*', '.', ip)\n return string\n\nThe above code is a function to remove leading zeroes from an ip address.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate the minimum swaps required to convert a string to another.\n\ndef revert_list(list_of_chars):\n i = 0\n while l[i] != last_char\n    List.insert(0, l[i])\n    List.pop(i+1)\n return List\n\nThe above code reverses a list and copies the last element at the begining."], [0.09400394474601408, 0.10638297872340426, 0.14369396752870098, "import cmath  \ndef convert(numbers):    \n  num = cmath.polar(numbers)  \n  return (num) \nThe above code is a python function to convert complex numbers to polar coordinates.\n\ndef replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2\nThe above code is a function to replace characters in a string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check if there is possible minimum swaps to rearrange str2 such that it becomes str1.\ndef form_Number(n,city) :  \n  text = \"abcd efghijklmnaopqrstuvwxyz\"\n  text = text[:n] \n  val = \"\"\n  num = val \n  length = len(city)  \n  idx = 0\n  while (id"], [0.10388886771932057, 0.09803921568627451, 0.19876680218265802, "def median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median\nThe above code is a function to find the median length of a trapezium.\n\ndef Diff(li1,li2):\n    return list(set(li1)-set(li2)) + list(set(li2)-set(li1))\n \nThe above code is a python function to get the difference between two lists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function which is used to predict whether it is possible to swap odd-number of characters to obtain two strings.\n\ndef sumSquares(n):\n sum = 0\n out = 0\n while(n!=0):\n    sum += (n%10)**2\n    n = n//10\n for i in str(sum):\n     out += int(i)\n return(out)\nThe above code is a python function which is"], [0.14221629663559543, 0.13043478260869565, 0.15530440387593616, "import math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN \nThe above code is a python function to find the next perfect square greater than a given number.\n\ndef rectangle_area(l,b):\n  area=l*b\n  return area\nThe above code is a function to find the area of a rectangle.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is the python function to find the minimum number of swaps required if two strings aren't equal when compared using the ASCII values , else returns a not possible string.\n      \n\n# Question 2 \n# List of attributes and methods supported by list data type :\n# Tuple( ) method :- () tuple takes 0 or 1 arguments\n# tuple(), empty tuple 1) tuple() <br>. 2) tuple(iterable)<br> <br>\n# List"], [0.08519852363907088, 0.10909090909090909, 0.11909706874095247, "def square_perimeter(a):\n  perimeter=4*a\n  return perimeter\nThe above code is a function that returns the perimeter of a square given its side length as input.\n\ndef Diff(li1,li2):\n    return list(set(li1)-set(li2)) + list(set(li2)-set(li1))\n \nThe above code is a python function to get the difference between two lists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " calculates minimum swaps needed to make two strings same/similar.\ndef factors(n):\n    n=100\n    flist = []\n    for i in range(1, n+1):\n        if n % i == 0:\n            print(i)\n\na=factors(n)\nThe above code displays all the factors of a number given by the user.\ndef checkKey(dict, key): \n      \n    if key in"], [0.238389090778042, 0.275, 0.3576933918420314, "def Extract(lst): \n    return [item[0] for item in lst] \nThe above code is a python function to get the first element of each sublist.\n\ndef odd_position(nums):\n\treturn all(nums[i]%2==i%2 for i in range(len(nums)))\nThe above code is a python function to check whether every odd index contains odd numbers of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function that returns minimum swaps required to convert one string to another.\ndef shuffle(a, k):\n    n = len(a)\n    i = k\n    while(i<n):\n        a.insert(i,a[-k])\n        del a[n]\n        i=i+k\n    print(\"after shuffling 1st array:\",a)\n    \n    i = n-1\n    while("], [0.15032784754160128, 0.17543859649122806, 0.21157061402907085, "def is_octagonal(n): \n\treturn 3 * n * n - 2 * n \nThe above code is a function to find the nth octagonal number.\n\nimport re \nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\ndef check_str(string): \n\treturn re.search(regex, string)\nThe above code is a function to check whether the given string is starting with a vowel or not using regex.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function with takes two strings as an argument and returns the minimum number of swaps required in how \nthe elements are swapped in the two strings to convert str1 to str2 or \"Not Possible\". \n#Exercise 6\ndef printDuplicates_calc(array) , target = 0) : \n    # Auxiliary array marks visited integers \n    visited = [] \n    for i in range(len(array)) : \n      \n"], [0.10776851951128819, 0.11904761904761904, 0.26945886508606265, "def count(lst):   \n    return sum(lst) \nThe above code is a python function to count true booleans in the given list.\n\nimport cmath\ndef polar_rect(x,y):\n cn = complex(x,y)\n cn=cmath.polar(cn)\n cn1 = cmath.rect(2, cmath.pi)\n return (cn,cn1)\nThe above code is a function to convert polar coordinates to rectangular coordinates.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program to convert strings to palindrome \ndef seriesGen3(n): \n  \n    # n is an integet number \n  \n    i = 1\n    while i < n: \n        yield i*i*i \n        i += 1\n\nThe above code is a python program to generate a series.    \n"], [0.26322491395415054, 0.2391304347826087, 0.3621151215228907, "def hexagonal_num(n): \n\treturn n*(2*n - 1) \nThe above code is a function to find the nth hexagonal number.\n\nfrom math import tan, pi\ndef area_polygon(s, l):\n  area = s * (l ** 2) / (4 * tan(pi / s))\n  return area\nThe above code is a function to calculate the area of a regular polygon given the length and number of its sides.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate the minimum number of swaps required to convert one string to another with letters from the english alphabet lower case only.Otherwise, it returns \"Not Possible.\"\ndef two_strings(no_of_elements,no_of_sets,set3):\n  count1 = 0\n  count2 = 0\n  for i in range(0,no_of_elements,2):\n    sum1 = set3[i]\n   "], [0.144212357937298, 0.16666666666666666, 0.2459626428186752, "def split_Arr(l, n):\n  return l[n:] + l[:n]\nThe above code is a python function to split a list at the nth eelment and add the first part to the end.\n\nimport re\ndef replace_specialchar(text):\n return (re.sub(\"[ ,.]\", \":\", text))\n\nThe above code is a function to replace all occurrences of spaces, commas, or dots with a colon.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count the number of changes needed to make str1 the same as str2 where all swaps are done in pairs.\n\nmin_Swaps('abc','cba')\nimport re \ndef replace_all(text, dic):\n    for k, v in dic.items():\n        text = text.lower().replace(k, v)\n    return text\nThe above code is a python function to replace all occurrences of any special"], [0.1262671960697506, 0.15254237288135594, 0.23464775852400313, "import re\ndef find_char_long(text):\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))\nThe above code is a function to find all words which are at least 4 characters long in a string.\n\nimport re\ndef remove_lowercase(str1):\n return re.sub('[a-z]', '', str1)\nThe above code is a function to remove lowercase substrings from a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to return the minimum number of swaps necessary to convert the first string \ninto the second string. Both the String should have exact same letters.\n\nYou have been given a String S. You need to find and print whether this\nString is a palindrome or not. If yes, print \"YES\" (without quotes), else\nprint \"NO\" (without quotes).\n\nl = [print('YES') if str(get_ipython().magic"], [0.10595338433667864, 0.2, 0.3102363207919228, "def circle_circumference(r):\n  perimeter=2*3.1415*r\n  return perimeter\nThe above code is a function to find the circumference of a circle.\n\ndef dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0\nThe above code is a function to find the depth of a dictionary.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum string to make a given string by swapping. \n"], [0.09600360219220418, 0.1, 0.13777121093907296, "import math\ndef surfacearea_sphere(r):\n  surfacearea=4*math.pi*r*r\n  return surfacearea\nThe above code is a function to find the surface area of a sphere.\n\ndef check_none(test_tup):\n  res = any(map(lambda ele: ele is None, test_tup))\n  return res \nThe above code is a function to check if the given tuple has any none value or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swap required to get str2 from str1.\n\ndef marge_sentence(arr, n) : \n    k = (2 * (n - 1)) \n    for i in range(n) : \n        for j in range(k) : \n            print(end = \" \") \n        for j in range(i + 1) : \n            print(arr[i][j"], [0.21121004938851598, 0.21951219512195122, 0.2583418372931448, "def frequency(a,x): \n    count = 0  \n    for i in a: \n      if i == x: \n        count += 1\n\n    return count \nThe above code is a function to count the number of occurrences of a number in a given list.\n\ndef Find_Min(lst): \n    return min(lst, key=len) \nThe above code is a python function to find the sublist having minimum length.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the number of swaps required to change the order of characters in a string if it is a valid permutation of another string.\ndef getKey(key1): \n \n    newkey=[] \n    alphabets=[chr(i) for i in range(ord('a'),ord('z')+1)] \n    for i in key1:\n        if i in alphabets:\n            new"], [0.1575445996164536, 0.16326530612244897, 0.2930915809876156, "import math\ndef surfacearea_sphere(r):\n  surfacearea=4*math.pi*r*r\n  return surfacearea\nThe above code is a function to find the surface area of a sphere.\n\nimport re\ndef extract_quotation(text1):\n  return (re.findall(r'\"(.*?)\"', text1))\nThe above code is a function to extract values between quotation marks \" \" of the given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the number of swaps required to transform the given string to target string.\nimport random\ndef adding(str1,str2) : \n    n, m = len(str1), len(str2) \n  \n    res = \"\" \n    carry = 0\n    \n    i = n - 1\n    j = m - 1\n\n    while i >= 0 or j >= 0 or carry: \n        \n        dec"], [0.18603512386869997, 0.2222222222222222, 0.32809107101913176, "import cmath\ndef angle_complex(a,b):\n  cn=complex(a,b)\n  angle=cmath.phase(a+b)\n  return angle\nThe above code is a function to get the angle of a complex number.\n\ndef remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l\nThe above code is a python function to remove odd numbers from a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum swaps to convert a string to another string, if the number of\n  swaps is odd, then it cannot be converted.\n\ndef compress(string):\n    count_char=0\n    last_index=0\n    text=\"\"\n    for letter in string:\n        count_char +=1\n        if count_char == len(string):\n            text+=letter\n            text+=str(count_char)\n"], [0.17720843852941084, 0.17307692307692307, 0.21836551246327593, "def len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max\nThe above code is a python function to find the length of the longest word.\n\ndef Extract(lst): \n    return [item[0] for item in lst] \nThe above code is a python function to get the first element of each sublist.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function that find minimum number of swaps required to interleaving the characters of its two strings.\n\ndef PrimeSum(n) : \n    sum = 0\n    for i in range(2, n + 1) :  \n        for j in range(2, i // 2 + 1) : \n            if (i % j == 0) : \n                break\n        else : \n            sum += i\n    return sum\n"], [0.16421790739955353, 0.19607843137254902, 0.17023205814562484, "def two_unique_nums(nums):\n  return [i for i in nums if nums.count(i)==1]\nThe above code is a python function to remove duplicate numbers from a given number of lists.\n\ndef nth_nums(nums,n):\n nth_nums = list(map(lambda x: x ** n, nums))\n return nth_nums\nThe above code is a function to compute the n-th power of each number in a list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to count minimum swaps required to copied a given string in the pattern of the second one.\n# Python code to demonstrate the working of \n# calendar() from calendar module \n\n# importing calendar module for calendar operations \nimport calendar \n\n'''\n# printing the calendar of the year 2019 \n# prints the calendar of the entire year \nprint (\"The Calendar of the year 2019 is : \")\nprint (calendar.calendar"], [0.12009100929883687, 0.08771929824561403, 0.12274076956728111, "def filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums\nThe above code is a function to filter odd numbers.\n\ndef odd_position(nums):\n\treturn all(nums[i]%2==i%2 for i in range(len(nums)))\nThe above code is a python function to check whether every odd index contains odd numbers of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program to swap pairs of letters. Here, the letters at odd indices should lie together.\ndef string_rotation(string1,string2) : \n    if len(string2) == len(string1) : \n        temp = string1 * 2 \n        if temp.find(string2) > -1 : \n            return True \n    return False\nThe above code is a python function to check if two strings are"], [0.10968653760775243, 0.10869565217391304, 0.3464691211402161, "def cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums\nThe above code is a function to find cubes of individual elements in a list.\n\ndef check_value(dict, n):\n    result = all(x == n for x in dict.values()) \n    return result\nThe above code is a function to check if all values are same in a dictionary.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is used to check number of swaps needed to sort an array of strings according to another one.\n\n\ninfinity = float('inf') \ndef Next_Lexicographic_String(string) : \n  \n    \n    if len(string) == 1 : \n        return string \n    if string == '' : \n        return \n   \n    temp = string[0] \n    i = 0\n    while(i<len("], [0.17158806564478277, 0.16666666666666666, 0.17967687856057124, "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \nThe above code is a python function to find the length of the smallest list in a list of lists.\n\ndef filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums\nThe above code is a function to filter odd numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum number of swaps to get the same string.\n\n# Distance\nThe code is for finding the distance between two points.\ndef distance(x1, y1,  x2,  y2):  \n      \n    # Calculating distance  \n    return math.sqrt(math.pow(x2 - x1, 2) +\n                math.pow(y2 - y1, 2) *"], [0.13139491079220178, 0.13636363636363635, 0.1509678991659626, "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x\nThe above code is a python function to find the number of divisors of a given integer.\n\nimport math\ndef volume_cone(r,h):\n  volume = (1.0/3) * math.pi * r * r * h\n  return volume\nThe above code is a function to find the volume of a cone.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check whether a string is K-similar or not.\n\ndef fair_rations(B) : \n    count = 0\n    if sum(B) % 2 != 0 : \n        return(\"NO\") \n    else : \n        for j in range(len(B) - 1) :  \n            if B[j] % 2 != 0 : \n                B[j]  = B[j] +"], [0.1712299184746861, 0.20408163265306123, 0.3278554254383938, "def big_diff(nums):\n     diff= max(nums)-min(nums)\n     return diff\nThe above code is a python function to find the difference between largest and smallest value in a given list.\n\ndef Diff(li1,li2):\n    return list(set(li1)-set(li2)) + list(set(li2)-set(li1))\n \nThe above code is a python function to get the difference between two lists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check if it's possible to convert one string to other string by swapping minimum number of characters.\n\nmax(min(4,8,1),min(5,7,2),min(5,8,5))\nIn the above code the arguments needs to be passed are surrounded by the parenthesis.\n\ndef reverse(s):\n    if s.__class__ == int:\n        num = s\n        sum = ''\n"], [0.14111216429970017, 0.1590909090909091, 0.22911861669271122, "def string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst\nThe above code is a function to convert a string to a list of strings split on the space character.\n\ndef median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median\nThe above code is a function to find the median length of a trapezium.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to determine the minimum number of swaps required.\ndef countingValleys(n, s):\n    #noOfVally = 0\n    #prevSeaLevel = 0\n    prevSeaLevel = 0\n\n    for i in range(n):\n        if (s[i] == 'U'):\n            seaLevel += 1\n        elif(s[i] == 'D'):\n            seaLevel += -1\n        if"], [0.07430726090092649, 0.038461538461538464, 0.02434866825020719, "def volume_cube(l):\n  volume = l * l * l\n  return volume\nThe above code is a function to find the volume of a cube given its side length.\n\nimport re\ndef text_match_wordz_middle(text):\n        return bool(re.search(r'\\Bz\\B',  text))\nThe above code is a function that checks if a strings contains 'z', except at the start and end of the word.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " checks if two string differ by only one character ( Insertion / Deletion / Modification )\n\ndef Diff_pos(str1, str2):  \n    l1 = [x for x in str1] \n    l2 = [x for x in str2] \n    diff = [] \n    md = -1\n    for i in l1: \n        if i not in l2: \n            diff.append("], [0.07753390923366911, 0.05172413793103448, 0.08838068561706992, "def first_Digit(n) :  \n    while n >= 10:  \n        n = n / 10 \n    return int(n) \nThe above code is a python function to find the first digit of a given number.\n\ndef unique_Element(arr):\n    s = set(arr)\n    return len(s) == 1\nThe above code is a python function to check whether a list of numbers contains only one distinct element or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " a given two strings of length n each. We only allowed to swap any two adjacent characters. Is it possible to transform the two strings such that two adjacent characters of two strings take their correct place.\n\ndef extra_Char(str1,str2) : \n    new_string1 = \"\"\n    new_string2 = \"\"\n    for i in range(len(str1)) :  \n        if str1[i] not in str2 : "], [0.12776945173878884, 0.23684210526315788, 0.4172347264685928, "def tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result\nThe above code is a function to convert a given tuple of positive integers into a single integer.\n\nimport math\ndef otherside_rightangle(w,h):\n  s=math.sqrt((w*w)+(h*h))\n  return s\nThe above code is a function to find the third side of a right angled triangle.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the number of swap required to change one string to the anagram of another.\ndef summation_n(n) : \n    for i in range(1, n + 1) : \n        n = n + i \n        return n\nsum_n(5) = 5*(5+1)/2\n\n"], [0.08973758831808064, 0.22727272727272727, 0.2633806184089662, "import math\ndef surfacearea_sphere(r):\n  surfacearea=4*math.pi*r*r\n  return surfacearea\nThe above code is a function to find the surface area of a sphere.\n\ndef first_odd(nums):\n  first_odd = next((el for el in nums if el%2!=0),-1)\n  return first_odd\nThe above code is a python function to find the first odd number in a given list of numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum funtions.\n"], [0.23476764268648742, 0.28, 0.4035873378059043, "import math\ndef otherside_rightangle(w,h):\n  s=math.sqrt((w*w)+(h*h))\n  return s\nThe above code is a function to find the third side of a right angled triangle.\n\ndef sum_digits(n):\n  if n == 0:\n    return 0\n  else:\n    return n % 10 + sum_digits(int(n / 10))\nThe above code is a function to get the sum of the digits of a non-negative integer.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the number of swaps required to make two strings equal.\n\n"], [0.20835468092350623, 0.18181818181818182, 0.24948116411146762, "def find(n,m):  \n    q = n//m \n    return (q)\nThe above code is a python function to find quotient of two numbers (rounded down to the nearest integer).\n\nimport math \ndef is_polite(n): \n\tn = n + 1\n\treturn (int)(n+(math.log((n + math.log(n, 2)), 2))) \nThe above code is a function to find nth polite number. geeksforgeeks.org/n-th-polite-number/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function from minimum number of swaps required to convert str1 to str2. \n\nl=[1,1,1]\nl[::-3] \n\n'[start:stop:step]' # Tell me what it do. \nIt gives last value to first.eg [13:] means let start as 1 then stop at 3 and step backward by 1, i.e it becomes 1\n[start:stop:step] & [::step"], [0.08092760538096141, 0.09615384615384616, 0.10611302073958298, "import heapq as hq\ndef heap_queue_largest(nums,n):\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums\nThe above code is a function to find the n largest integers from a given list of numbers, returned in descending order.\n\ndef find_star_num(n): \n\treturn (6 * n * (n - 1) + 1) \nThe above code is a function to find the n'th star number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " returns a count of the swap number required if 2 String are exactly same but the order of characters are different.\nn = input()\na = [int(x) for x in input().split()]\nrunning = True\ncount = 0\na = sorted(a)\nwhile running:\n    if a == sorted(a) : \n        running = False\n    else : \n        running = True\n        i = 0 \n        j = 1"], [0.12730174646752107, 0.16279069767441862, 0.17034149358408485, "def tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result\nThe above code is a function to convert a given tuple of positive integers into a single integer.\n\ndef Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList\nThe above code is a python function to find the element of a list having maximum length.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a program to find minimum swaps between a pair of string and return minimum number of swaps required.\ndef addition(lst) : \n    sum = 0\n    avg = 0 \n    for i in lst[1:2] : \n        sum += i \n    avg = sum / lst[0]\n    return avg \nlst = [5,62,36,9,17]\navg = addition(lst"], [0.07395197238993882, 0.03636363636363636, 0.011182731123353344, "def swap_numbers(a,b):\n temp = a\n a = b\n b = temp\n return (a,b)\nThe above code is a function that takes in two numbers and returns a tuple with the second number and then the first number.\n\ndef new_tuple(test_list, test_str):\n  return tuple(test_list + [test_str])\nThe above code is a function to create a new tuple from the given string and list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a program that returns the minimum swap if two strings are equal then it will return 0, else it will return 1 or 2.\ndef URLify(str,length) : \n      \n    str = list(str) \n    spaceCount = 0\n    for i in range(length) : \n        if str[i] ==  \" \" : \n            spaceCount+=1\n            str[i] = \"%20\"\n    return \""], [0.2207583154301486, 0.32, 0.3989387899526993, "def add_lists(test_list, test_tup):\n  res = tuple(list(test_tup) + test_list)\n  return (res) \nThe above code is a function to append the given list to the given tuples.\n\ndef check_tuplex(tuplex,tuple1): \n  if tuple1 in tuplex:\n    return True\n  else:\n     return False\nThe above code is a function to check whether an element exists within a tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to return the minimum swaps required to convert the input string to an ASCII value.\n"], [0.11219867114835011, 0.125, 0.1801590513936626, "def closest_num(N):\n  return (N - 1)\nThe above code is a function to find the closest smaller number than n.\n\nimport re\ndef find_adverbs(text):\n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))\nThe above code is a function to find the first adverb ending with ly and its positions in a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to give the minimum number of swapping of words to print alternate words which are not equal.\n\ndef min_swap(st1,st2):\n  arr1 = [0] * 26\n  arr2 = [0] * 26\n  for i in range(int(len(st1))):\n    val = ord(st1[i]) - ord('a')\n    arr1[val] += 1\n  for i"], [0.12769047922311821, 0.11475409836065574, 0.1801860250840013, "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \nThe above code is a python function to find the length of the smallest list in a list of lists.\n\nimport cmath\ndef angle_complex(a,b):\n  cn=complex(a,b)\n  angle=cmath.phase(a+b)\n  return angle\nThe above code is a function to get the angle of a complex number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find whether two strings can be made equal with even number of swaps on each string.\nlst=[*input(\"Enter comma separated words of list: \").split(\",\")]\nlst= list(set((lst)))\nprint(\"After removal of duplicates , the list becomes :\",\",\".join(lst))\nThe above code and python function sorts separately odd and even elements of a list of print them in order.\ndef even"], [0.0900806876340529, 0.06382978723404255, 0.06131255418980679, "def Split(list): \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li\nThe above code is a python function which takes a list of integers and only returns the odd ones.\n\ndef split(word): \n    return [char for char in word] \nThe above code is a python function to split a string into characters.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " counts no of swaps needed to make two strings anagram.\ndef QuickSort(ar): \n    smaller,equal,larger = [],[],[]\n    if(len(ar) <= 1): \n        return ar\n    pivot = ar[randint(0,len(ar)-1)]\n    for x in ar:\n        if x < pivot:  \n            smaller.append(x)\n        elif x==pivot: "], [0.11566858071291396, 0.125, 0.2568138447649532, "def sum_digits(n):\n  if n == 0:\n    return 0\n  else:\n    return n % 10 + sum_digits(int(n / 10))\nThe above code is a function to get the sum of the digits of a non-negative integer.\n\ndef surfacearea_cylinder(r,h):\n  surfacearea=((2*3.1415*r*r) +(2*3.1415*r*h))\n  return surfacearea\nThe above code is a function to find the surface area of a cylinder.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find number of swaps required.\ndef perfect_number(n):\n  total = 0\n  for x in range(1, n):\n    if n % x == 0:\n      total += x\n  return total == n\nThe above code is a function to check weather the number is perfect or not.\n\n'''"], [0.16155664068386352, 0.1509433962264151, 0.23518733552843635, "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \nThe above code is a python function to find the length of the smallest list in a list of lists.\n\ndef cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums\nThe above code is a function to find cubes of individual elements in a list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find how many swaps required to convert a string with respect to another string.\ndef checkNo(List,n) : \n    temp = 0\n    for i in List : \n        temp = temp + i \n    if(temp == n) :\n     return True\n    else : \n     return False\nList = [8, 7, 4, 3] \nn = 14\nif( checkNo( List,"], [0.11855366665324676, 0.07547169811320754, 0.07676199830755127, "def opposite_Signs(x,y): \n    return ((x ^ y) < 0); \nThe above code is a python function to check whether the given two integers have opposite sign or not.\n\ndef number_of_substrings(str): \n\tstr_len = len(str); \n\treturn int(str_len * (str_len + 1) / 2); \nThe above code is a python function to count the number of non-empty substrings of a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check if two given strings are atmost each other by swapping atmost K characters in both strings (times).\ndef convert(str1, n) : \n    for i in range(0, n, 2): \n        str1[i], str1[i + 1] = str1[i + 1], str1[i] \nstr1 = list(str1) \nconvert(str1, n)"], [0.09152255298655444, 0.10909090909090909, 0.1586240587822711, "def neg_nos(list1):\n  out = []\n  for num in list1: \n    if num < 0: \n      out.append(num)\n  return out \nThe above code is a python function to return the negative numbers in a list.\n\ndef return_sum(dict):\n  sum = 0\n  for i in dict.values():\n    sum = sum + i\n  return sum\nThe above code is function to find the sum of all items in the given dictionary.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is the function to minimize swap is even no. of swaps.\n\ndef find(value):\n  mid = range(1,3) \n  while mid != value :\n    if mid < value:\n      mid=mid+2\n    elif mid > value :\n      mid = mid-1 \n\n  return mid\nThe above code is to find close to the number using range method.\nQ5\nIn python, data is represented in string"], [0.10680032895333263, 0.09090909090909091, 0.20832944839294715, "def convert_list_dictionary(l1, l2, l3):\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\n     return result\nThe above code is a function to convert more than one list to nested dictionary.\n\ndef toggle_string(string):\n string1 = string.swapcase()\n return string1\nThe above code is a function to toggle the case of all characters in a string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is the minimum number of swap swap required to make two strings equal.\n\nimport functools \n   \n# initializing list  \ntest_list = [[1, 1, 0], [1 ,0, 1], [0 ,0 ,0]] \n   \n# printing original list  \nprint (\"Original list : \" + str(test_list)) \n  \n# using reduce() to make transformations to nested list. \n# Sums the"], [0.10473395873672248, 0.1509433962264151, 0.20569904484431792, "def sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n\nThe above code is a function to sort each sublist of strings in a given list of lists.\n\ndef filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums\nThe above code is a function to filter odd numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate minimum swaps required to minimize the differences.\nPlease follow the below steps : \n\n* Read all testcases\n* Read length of the testcases\n* Read actual strings\n* Use map() function to generate hash strings for the testcases\n* Generate results based on generated hash strings and actual strings\n7. Write a function to print start pattern\n\nBelow is the implementation of the pattern \u2212\n\n\n\n*                                   * \n\n*"], [0.09699676882201677, 0.08695652173913043, 0.11358601130035044, "def square_Sum(n):  \n    return int(n*(4*n*n-1)/3) \nThe above code is a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n\ndef surfacearea_cylinder(r,h):\n  surfacearea=((2*3.1415*r*r) +(2*3.1415*r*h))\n  return surfacearea\nThe above code is a function to find the surface area of a cylinder.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program that counts the number of swaps needed to make two strings identical.  Note, in the solution presented below, we unnecessarily counted each pair of characters \u2014 a, b \u2014 twice. This can be improved by skipping adding \u2028each in-between character ( they were already counted in the previous step).\n\ndef leapYear(year):\n  cent = year // 100 +1\n  print(cent)\n  leap= ((cent*3)-1)"], [0.14138150867995042, 0.17073170731707318, 0.15003047416978954, "def bitwise_xor(test_tup1, test_tup2):\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) \nThe above code is a function to perform the mathematical bitwise xor operation across the given tuples.\n\ndef is_lower(string):\n  return (string.lower())\nThe above code is a python function to convert the given string to lower case.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find out minimum swaps required to make the two given strings anagrams.\ndef decode_sen(string) : \n    dec = '' \n    dec = dec + string[0] \n    dec = dec + string[1].upper() \n    dec = dec + string[2] \n    dec = dec + string[3].upper() \n    dec = dec + string[4] \n    return ("], [0.1386521772492474, 0.14583333333333334, 0.2180780267079181, "def find(n,m):  \n    q = n//m \n    return (q)\nThe above code is a python function to find quotient of two numbers (rounded down to the nearest integer).\n\ndef left_rotate(n,d):   \n    INT_BITS = 32\n    return (n << d)|(n >> (INT_BITS - d))  \nThe above code is a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to minimum swaps to convert str1 to str2 by swapping.\ndef get_Array(n) : \n    array = [] \n    for i in range(1, (n // 2) + 1) : \n        array.append(i) \n    for i in range(n // 2, 0, -1) : \n        array.append(i) \n    return (array) \nThe above code"], [0.3648250950506815, 0.4, 0.47058370328742427, "def is_num_decagonal(n): \n\treturn 4 * n * n - 3 * n \nThe above code is a function to find the nth decagonal number.\n\ndef odd_num_sum(n) : \n    j = 0\n    sm = 0\n    for i in range(1,n + 1) : \n        j = (2*i-1) \n        sm = sm + (j*j*j*j)   \n    return sm \nThe above code is a python function to find the sum of fourth power of first n odd natural numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find minimum no of swaps required to convert \ngiven string str1 to given string str2. \n\"\"\""], [0.1149893957936998, 0.11627906976744186, 0.09128558440519073, "def len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max\nThe above code is a python function to find the length of the longest word.\n\ndef Diff(li1,li2):\n    return list(set(li1)-set(li2)) + list(set(li2)-set(li1))\n \nThe above code is a python function to get the difference between two lists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function t find the no. of swop of only one amount needed. \n\ndef checkRotational(a,b) :\n    for i in range(len(b)) :\n        if a==b:\n            return \"yes\"\n        else:\n            b=b[-1]+b[:-1]\n            print(b)\n\n\ndef main() :\n    a=input(\"Enter\").split(\",\")\n"], [0.11423303743623334, 0.17073170731707318, 0.136025370828976, "import cmath\ndef angle_complex(a,b):\n  cn=complex(a,b)\n  angle=cmath.phase(a+b)\n  return angle\nThe above code is a function to get the angle of a complex number.\n\ndef intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result\nThe above code is a function to find the intersection of two arrays.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a program for minimum swaps required for turunng the string to palindrom.        \ndef minOperations():\n  # Write your code here \n  n=len(arr)\n  arr.sort()\n  arr_max=[]\n  for i in range(n-1,-1,-1):\n    if i==n-1:\n      continue\n    else:\n      if(arr[i]%2==0):\n"], [0.15608226205861409, 0.16363636363636364, 0.22368071524985153, "def sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n\nThe above code is a function to sort each sublist of strings in a given list of lists.\n\ndef minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b \nThe above code is a python function to find the minimum of two numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps required if letter appears odd number \nof times in a string like Anagram.\ndef removeBytes(input):  # 9\n    newStr = \"\" \n    for ele in input:\n        # Check if it's in range of ASCII characters (33 to 127)\n        if (ord(ele) >= 33 and ord(ele) < 127):\n            newStr += ele\n    return newStr\n\n"], [0.30770577372002883, 0.36, 0.39712048230744823, "def decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") \nThe above code is a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n\nimport re\ndef extract_values(text):\n return (re.findall(r'\"(.*?)\"', text))\nThe above code is a function to extract values between quotation marks from a string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " finds out the minimum number of swaps required to have string str2 as a permutation of str1.\n"], [0.08595378703869806, 0.08695652173913043, 0.12430104706201847, "def convert_list_dictionary(l1, l2, l3):\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\n     return result\nThe above code is a function to convert more than one list to nested dictionary.\n\ndef max_sum_list(lists):\n return max(lists, key=sum)\nThe above code is a function that returns the list in a list of lists whose sum of elements is the highest.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a program to calculate the minimum swaps needed to complete string1 and string2.\n\ndef day_of_week(weekday, curDate, monthdate) : \n  \n    if monthdate != 13 : \n        \n        fulldate2 =  weekday + ' ' +monthdate +  \n                     ' ' + curDate \n        time2 = data.Time.Time(fulldate2) \n        time2.TimeConvert()"], [0.11624743919939363, 0.1568627450980392, 0.1610843640484546, "def remove_odd(str1):\n str2 = ''\n for i in range(1, len(str1) + 1):\n    if(i % 2 == 0):\n        str2 = str2 + str1[i - 1]\n return str2\nThe above code is a function to remove odd characters in a string.\n\nimport re\ndef extract_values(text):\n return (re.findall(r'\"(.*?)\"', text))\nThe above code is a function to extract values between quotation marks from a string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate minimum swaps required to make a string as Palindrome.\n\n# <p><b><u>C++ Programs on Hackerrank</u></b><br><br>\n\n# <b>Read two integer values. After this, calculate the product between them and store the result in a variable named PROD. Print the result like the example bellow.\n# \n# Input:</b><br>\n# Four integer numbers"], [0.0945933435565966, 0.12962962962962962, 0.10392264846753566, "def search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)\nThe above code is a python function to find the element that appears only once in a sorted array.\n\ndef reverse_words(s):\n        return ' '.join(reversed(s.split()))\nThe above code is a function to reverse words seperated by spaces in a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " takes two strings and swaps matches of characters which makes the string a palindrome.\n\ndef checkPalindrome(num): \n    n = num\n    rev =0 \n    while(num>0): \n        digit = num%10\n        rev = rev*10 + digit \n        num = num//10 \n    return (rev==n)\nThe above code is an efficient function to find out if a given number is palind"], [0.10019597959432287, 0.1, 0.17383607552474872, "def is_octagonal(n): \n\treturn 3 * n * n - 2 * n \nThe above code is a function to find the nth octagonal number.\n\nfrom operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) \nThe above code is Given a list of tuples, a function that returns the first value of the tuple with the smallest second value.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function find to the number of swaps required.\n\"\"\"\n\"\"\"\n__Author__ = 'Rana Rizwan'\nimport math\nimport itertools\nhelp(math.comb)\n# Genrating prime numbers ---> algorithm by c++ formulae 1110 ^*\nn = 1500000\nl = []\nl1 = []\nwhile not any(((a) * (a - 1)) % n == 2 for a in range(n"], [0.20147040281619738, 0.1935483870967742, 0.28898809936473563, "def find_Average_Of_Cube(n):  \n    sum = 0\n    for i in range(1, n + 1): \n        sum += i * i * i  \n    return round(sum / n, 6) \nThe above code is a python function to find the average of cubes of first n natural numbers.\n\ndef replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2\nThe above code is a function to replace characters in a string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check if it is possible to swap two characters of a string and make it anagram of another string.\n"], [0.07669514353459422, 0.058823529411764705, 0.02811450622777189, "def extract_freq(test_list):\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\n  return (res)\nThe above code is a function to extract the number of unique tuples in the given list.\n\ndef check_value(dict, n):\n    result = all(x == n for x in dict.values()) \n    return result\nThe above code is a function to check if all values are same in a dictionary.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " imatates a tranlation with the least swaps of words.\ndef solovay_strassen(n, k=10):\n    if n == 2 or n == 3:\n        return True\n    if not n & 1:\n        return False\n\n    def legendre(a, p):\n        if p < 2:\n            raise ValueError('p must not be < 2')\n        if (a == 0) or (a =="], [0.1067415762028815, 0.15555555555555556, 0.1264604748743924, "import heapq\ndef larg_nnum(list1,n):\n largest=heapq.nlargest(n,list1)\n return largest\nThe above code is a function that takes in a list and an integer n and returns a list containing the n largest items from the list.\n\ndef filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums\nThe above code is a function to filter odd numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate minimum swaps required for transforming arbitrarily long string 'str1' into arbitary string 'str2'.\n    \n    \n    \n    \n    \n    \n# Check if soduku a valid configuration\n# if yes print YES, else print NO\n\ndef check_valid_configuration(sudoku):\n    if is_valid(0,0,sudoku) is True:\n        print(\"YES\")\n    else:\n"], [0.0779847851888664, 0.07142857142857142, 0.07676199830755126, "def square_nums(nums):\n square_nums = list(map(lambda x: x ** 2, nums))\n return square_nums\nThe above code is a function to find squares of individual elements in a list.\n\ndef number_of_substrings(str): \n\tstr_len = len(str); \n\treturn int(str_len * (str_len + 1) / 2); \nThe above code is a python function to count the number of non-empty substrings of a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is the implementation of minimum swaps needed such that two strings do not match.\n\nnewdict = {}\nn = int(input(\"enter length of dictionary : \"))\nfor i in range(n):\n    key =input(\"Key : \")\n    value = input(\"Value : \")\n    newdict[key] = value\n#code to print unique values \nunique3 = set(value for key, value in newdict.items())\nprint"], [0.11779735886164157, 0.15384615384615385, 0.3021617935438838, "import re\ndef remove_uppercase(str1):\n  return re.sub('[A-Z]', '', str1)\nThe above code is a function to remove uppercase substrings from a given string.\n\nimport re \nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\ndef check_str(string): \n\treturn re.search(regex, string)\nThe above code is a function to check whether the given string is starting with a vowel or not using regex.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to demonstrate the minimum swaps required to make two strings anagram.\ndef merge(a,b): \n    count = 0\n    c = a + b\n    for i in c:\n        if (i % 2 == 1):\n            c.remove(i)\n        else:\n            count +=1\n    c.sort()\n    return(c[count-1])\nThe above code is a function to merge two lists of"], [0.4724980111128138, 0.5714285714285714, 0.688512151339193, "def max_difference(test_list):\n  temp = [abs(b - a) for a, b in test_list]\n  res = max(temp)\n  return (res) \nThe above code is a function to find the maximum difference between available pairs in the given tuple list.\n\ndef filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums\nThe above code is a function to filter odd numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps required to convert one string to another.\n\n\n"], [0.08547193218040006, 0.06521739130434782, 0.048850674120695964, "import re\ndef remove_whitespaces(text1):\n  return (re.sub(r'\\s+', '',text1))\nThe above code is a function to remove all whitespaces from the given string.\n\nimport re\ndef text_starta_endb(text):\n        patterns = 'a.*?b$'\n        return re.search(patterns,  text)\nThe above code is a function that matches a string that has an 'a' followed by anything, ending in 'b'.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " returns the minimum no. of swaps required.\n\ndef insertion_sort(arr) : \n  \n    for i in range(1, len(arr)) : \n  \n        key = arr[i] \n  \n        j = i-1\n        while j >= 0 and key < arr[j] : \n                arr[j + 1] = arr[j] \n                j -= 1\n        arr[j + 1]"], [0.13001875666040388, 0.1568627450980392, 0.13594501273619708, "def drop_empty(dict1):\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1\nThe above code is a function to drop empty items from a given dictionary.\n\ndef unique_Element(arr):\n    s = set(arr)\n    return len(s) == 1\nThe above code is a python function to check whether a list of numbers contains only one distinct element or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find out the minimum swap required if there was a mistake in the same string of alphabet using anagram concepts.\n#sub k php\nsub k {\n    my @subsets = ();\n    foreach my $word (make_subsets(uc $_[0])) { \n        if (recursive_caser(substr($word, 1), substr($word, 0, 1), uc($_[1]))) {"], [0.15473419418045123, 0.16071428571428573, 0.23970235357949954, "import re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))\nThe above code is a function to convert the given snake case string to camel case string.\n\nimport re\ndef extract_quotation(text1):\n  return (re.findall(r'\"(.*?)\"', text1))\nThe above code is a function to extract values between quotation marks \" \" of the given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function returning the minimum number of swaps required to get the string2 after erasing of the string1.\n\nIt should be noticed that the returned value should be an integer and it should be an even number.\nIf an odd number is returned, it will automatically be converted to the nearest even number.\ndef getLowerString(string) : \n    string2 = \"\" \n    lower = string.lower() \n    for i in string : \n"], [0.16881908730484005, 0.2127659574468085, 0.24337812305060075, "def add_string(list_, string):\n add_string=[string.format(i) for i in  list_]\n return add_string\nThe above code is a function to apply a given format string to all of the elements in a list.\n\nimport re\ndef extract_quotation(text1):\n  return (re.findall(r'\"(.*?)\"', text1))\nThe above code is a function to extract values between quotation marks \" \" of the given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps required to convert one string to another string.\n\ndef get_op(op1):\nif op1==0:\n    op=\"Multiplication\"\nelse:\n    op=\"Natural Numbers\"\n    return op\nThe above code is a function. The function checks and depending on the value of the 'op1', chooses the string and returns the chosen string.\n\ndef anagrams(s1,s2"], [0.16662546319572683, 0.1836734693877551, 0.21133084363476268, "def square_Sum(n):  \n    return int(n*(4*n*n-1)/3) \nThe above code is a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n\ndef check_Consecutive(l): \n    return sorted(l) == list(range(min(l),max(l)+1)) \nThe above code is a python function to check whether the given list contains consecutive numbers or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function that takes in 2 strings and returns the number of swaps required to make the string 1 an anagram of the string 2.\ndef productArray(arr):  \n    left = [] \n    right = [] \n    res = [] \n    n = len(arr)  \n    for i in range(n): \n        if i == 0: \n            left.append(1) \n\n        else: \n            left"], [0.11207699291201308, 0.20689655172413793, 0.2809019798932252, "def opposite_Signs(x,y): \n    return ((x ^ y) < 0); \nThe above code is a python function to check whether the given two integers have opposite sign or not.\n\nimport math\ndef lateralsurface_cone(r,h):\n  l = math.sqrt(r * r + h * h)\n  LSA = math.pi * r  * l\n  return LSA\nThe above code is a function to find the lateral surface area of a cone given radius r and the height h.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program to calculate the string takes minimum no. of swap to sort, given two strings.\n"], [0.09355808370254963, 0.1076923076923077, 0.24147377204054116, "def cummulative_sum(test_list):\n  res = sum(map(sum, test_list))\n  return (res)\nThe above code is a function to find the cumulative sum of all the values that are present in the given tuple list.\n\nimport re\ndef extract_quotation(text1):\n  return (re.findall(r'\"(.*?)\"', text1))\nThe above code is a function to extract values between quotation marks \" \" of the given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find out how many swaps need to occur such that one string can be transformed into another string. If it cannot be done return \"Not Possible\".\n\ndef function(list1): \n    return sorted(list1, key = lambda x : x[0]) \nThe above code is to sort a list of tuples in increasing order of first element.\n\nfrom operator import itemgetter \n    \ndef idx_0(map_"], [0.15888471941180887, 0.14893617021276595, 0.309412708276798, "def tuple_str_int(test_str):\n  res = tuple(int(num) for num in test_str.replace('(', '').replace(')', '').replace('...', '').split(', '))\n  return (res) \nThe above code is a function to convert tuple string to integer tuple.\n\ndef count_list(input_list): \n    return len(input_list)\nThe above code is a python function to count the number of lists in a given number of lists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to do even number of transformations.\n\ndef check(text,ch):  \n    count = 0\n    for i in text:   \n        if (i == ch):  \n            count = count + 1\n    return count           \nThe above code is a python function to count number of characters in a given string.  \n\ndef slicing_str(str, i_p, s_p): \n    a = str[i_"], [0.15031434370812036, 0.13953488372093023, 0.10989290105046473, "def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False\nThe above code is a python function to check whether the given number can be represented as the difference of two squares or not.\n\ndef Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList\nThe above code is a python function to find the element of a list having maximum length.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check if we can reduce the difference in number of characters of two strings of same length or not.\n\ndef arith_geo(lst):\n    diff=lst[1]-lst[0]\n    ratio=lst[1]/lst[0]\n    for i in range(len(lst)-1):\n        if not lst[i+1]-lst[i]==diff:"], [0.1327464290540795, 0.14583333333333334, 0.18697896969244154, "def maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \nThe above code is a function to maximize the given two tuples.\n\nimport math\ndef radian_degree(degree):\n radian = degree*(math.pi/180)\n return radian\nThe above code is a function to convert degrees to radians.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the number of swaps required between two strings\ndef convert_values(tuple1): \n    diff = tuple((a) - a*2 for a in tuple1) \n    return(tuple1+tuple(diff)) \nThe above code is a function to find the difference between given tuple of elements and twice of them.\n\ndef convert_string(str1):\n    for i in range(len(str1"], [0.1824188251740697, 0.20833333333333334, 0.3042459904260016, "def common_in_nested_lists(nestedlist):\n    result = list(set.intersection(*map(set, nestedlist)))\n    return result\nThe above code is a function to find the common elements in given nested lists.\n\ndef check_tuplex(tuplex,tuple1): \n  if tuple1 in tuplex:\n    return True\n  else:\n     return False\nThe above code is a function to check whether an element exists within a tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check the difference in the length of two strings . If it is even, divide the number of differences by two to get the minimum number of swaps required to make one string a substring of the other . If not possible to arrange\n\ndef sorted_freq(li1,d1): \n      \n    s=[]\n    d1=dict(d1)\n    for key,value in d1.items():\n        s.append"], [0.09247304818737878, 0.1320754716981132, 0.1718033808846641, "import math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN \nThe above code is a python function to find the next perfect square greater than a given number.\n\ndef sort_sublists(list1):\n    result = list(map(sorted,list1)) \n    return result\nThe above code is a function to sort each sublist of strings in a given list of lists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps needed to get the string 'str1' and 'str2' in the str2 string. The solution is of the string is always two times than the minimum swaps.\ndef distinct_Words(str1) : \n    dict1 = {} \n    list1 = str1.split(\" \") \n    if len(list1) == 1 : \n        return 0\n    else : \n        unique ="], [0.08235946819520788, 0.06349206349206349, 0.048761026936010296, "def circle_circumference(r):\n  perimeter=2*3.1415*r\n  return perimeter\nThe above code is a function to find the circumference of a circle.\n\ndef check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\nThe above code is a function that takes in a list and element and checks whether all items in the list are equal to the given element.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in two strings and checks whether the strings are created by rearranging each other by exactly or less than 2 swaps.\ndef square_area(side) : \n  area=(side*side)\n  return area\nThe above code is a function that takes in a side as a parameter and calculates the area of the square using this formula.\n\n## Problem 3\ndef even(n) :\n  num_iter = iter(range(n"], [0.18966956097654308, 0.18, 0.23498735010692245, "def replace_blank(str1,char):\n str2 = str1.replace(' ', char)\n return str2\nThe above code is a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n\ndef maximum(a,b):   \n    if a >= b: \n        return a \n    else: \n        return b \nThe above code is a python function to find the maximum of two numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to count the number of swaps that \nare required to make two given strings anagram of each other.\n\ndef sep_fn(str1) :\n space_count = 0 \n for i in range(0, len(str1)):\n        if(str1[i] == ' '): \n            space_count+=1\n str1_count = len(str1) - space_count\n return str1_"], [0.11963330187207767, 0.09090909090909091, 0.15896916735685518, "def list_split(S, step):\n    return [S[i::step] for i in range(step)]\nThe above code is a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\ndef median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median\nThe above code is a function to find the median length of a trapezium.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " takes in two strings, transforms it into two lists, checks if these strings may be swapped to become identical and then gives the minimum number of swaps necessary to do so.\ndef add_tripplets(str1,str2) : \n    first = str1[0:4] \n\n    second = str1[4:8] \n\n    strresult = \"\" \n\n    for i in range(4) : \n\n        strresult = strresult"], [0.17890199756504485, 0.1702127659574468, 0.1697351773950045, "import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\nThe above code is a function to merge three dictionaries into a single dictionary.\n\ndef circle_circumference(r):\n  perimeter=2*3.1415*r\n  return perimeter\nThe above code is a function to find the circumference of a circle.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that gives minimum number of swaps required to make two strings same, if possible.\n\ndef all_even(*str1) : \n    e=0\n    o=0\n    for i in str1 : \n        if i%2 == 0 : \n             e += 1\n        else : \n            o += 1 \n    if o == len(str1) and len(str1)%2 == 0 : \n"], [0.12303472936992307, 0.09803921568627451, 0.10191159317166605, "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \nThe above code is a python function to find the length of the smallest list in a list of lists.\n\nimport re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))\nThe above code is a function to convert the given snake case string to camel case string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check if by swapping the characters to match the strings we can get the required result.\n\nimport re\ndef is_matched(expression):\n    lefty = '([{'\n    righty = ')]}'\n    stack = []\n    for token in expression:\n        if token in lefty:\n            stack.append(token)\n            print(token,stack)\n        elif token in righty:\n           "], [0.10847435426180257, 0.1320754716981132, 0.23556876807788207, "def multiply_num(numbers):  \n    total = 1\n    for x in numbers:\n        total *= x  \n    return total/len(numbers) \nThe above code is a function to multiply all the numbers in a list and divide with the length of the list.\n\ndef maximum(a,b):   \n    if a >= b: \n        return a \n    else: \n        return b \nThe above code is a python function to find the maximum of two numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to know the minimum swaps required to make the string and the pattern in a palindrome \nSimilar programs:\n\nProblem 1 code:\n\n    def sum_positive_numbers(n):\n        res = n\n        for num in range(n-1, 0, -1):\n            res += num\n        return res \nThe above code is a function to add all the numbers from 1 to the given number.\nsame programs: "], [0.1135422131473472, 0.15789473684210525, 0.1547278734156306, "import math  \ndef even_binomial_Coeff_Sum( n): \n    return (1 << (n - 1)) \nThe above code is a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.\n\ndef unique_Element(arr):\n    s = set(arr)\n    return len(s) == 1\nThe above code is a python function to check whether a list of numbers contains only one distinct element or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check whether a list of letters is a    Rigorous Vale or note. The essence of the question is the maintainence of one gap between the combination.\nThe idea is to consider numbers from the binary representation of the given string and check if the        number at odd position is smaller than even position (str1>str2). For example, in\n \n                                                    abcd , abd\n \n                                                    here a is at odd position"], [0.17352017957947447, 0.20454545454545456, 0.30508639304923924, "def sort_sublists(list1):\n    result = list(map(sorted,list1)) \n    return result\nThe above code is a function to sort each sublist of strings in a given list of lists.\n\nimport re \nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\ndef check_str(string): \n\treturn re.search(regex, string)\nThe above code is a function to check whether the given string is starting with a vowel or not using regex.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find out the minimum swaps required to convert a string to another string using dictionary.\ndef most_frequent(list1): \n    dict1 = dict() \n    for i in list1: \n        count = list1.count(i) \n        dict1[i] = count \n    return dict(sorted(dict1.items(), key=lambda x: x[1])) \n\nThe above code"], [0.08820833684299528, 0.09259259259259259, 0.11236810726638537, "def similar_elements(test_tup1, test_tup2):\n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) \nThe above code is a function to find the shared elements from the given two lists.\n\ndef issort_list(list1):\n    result = all(list1[i] <= list1[i+1] for i in range(len(list1)-1))\n    return result\nThe above code is a function to check whether a specified list is sorted or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check if the two strings are equal in minimum no. of swaps.\ndef lruCache(max, callback):\n    cache = []\n    size = 0\n    for x in callback:\n        if size == max:\n            cache = cache[1:len(cache)] #Remove the OLDEST item to makr space for the NEW item.\n            size -= 1\n        cache.append(x)\n        size += 1"], [0.1306243173577486, 0.18421052631578946, 0.1688886398408285, "def square_perimeter(a):\n  perimeter=4*a\n  return perimeter\nThe above code is a function that returns the perimeter of a square given its side length as input.\n\ndef trim_tuple(test_list, K):\n  res = []\n  for ele in test_list:\n    N = len(ele)\n    res.append(tuple(list(ele)[K: N - K]))\n  return (str(res)) \nThe above code is a function to trim each tuple by k in the given tuple list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to return the minimum swaps required to get the strings of equal length.\nprint(min_Swaps(\"xam\",\"aman\"))\nprint(min_Swaps(\"xyyx\",\"bacd\"))\nprint(min_Swaps(\"foxxy\",\"nodeb\"))\n\n# Consider \n# str1 = \u201cssqq\u201d \n# and \n# str2 = \u201csssqkk\u201d, \n# in the above"], [0.17254008299405316, 0.15555555555555556, 0.27389641966684997, "def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     \nThe above code is a function to find whether a given array of integers contains any duplicate element.\n\ndef add_lists(test_list, test_tup):\n  res = tuple(list(test_tup) + test_list)\n  return (res) \nThe above code is a function to append the given list to the given tuples.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that returns number of swaps required to make two strings anagram.\ndef add_lists(first_list, sec_list): \n      \n    # Converting Lists to \n    # Sets to perform Intersection  \n    first_set = set(first_list) \n    sec_set = set(sec_list) \n  \n    # Calculating Union \n    # of both the sets  \n    third_set ="], [0.18461178229292824, 0.1590909090909091, 0.2500837472496079, "def get_Inv_Count(arr): \n    inv_count = 0\n    for i in range(len(arr)): \n        for j in range(i + 1, len(arr)): \n            if (arr[i] > arr[j]): \n                inv_count += 1\n    return inv_count \nThe above code is a python function to count inversions in an array.\n\ndef rectangle_area(l,b):\n  area=l*b\n  return area\nThe above code is a function to find the area of a rectangle.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find out how many swaps required to convert from str1 to str2.\ndef triplets(a, b, c) : \n    a = list(a) \n    b = list(b) \n    c = list(c) \n    a.sort() \n    b.sort() \n    c.sort() \n    ai = 0\n    bi = 0\n    ci = 0\n"], [0.10073847505955082, 0.14893617021276595, 0.14960976299804454, "import re\ndef change_date_format(dt):\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)\nThe above code is a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\ndef check_greater(arr, number):\n  arr.sort()\n  return number > arr[-1]\nThe above code is a function to check whether the entered number is greater than the elements of the given array.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is to find the minimum swaps required in strings to convert the string into another.\ndef findPair(lst, k): \n    res = False\n    for i in range(len(lst)) : \n        for j in range(len(lst)) : \n            if (i != j and lst[i] + lst[j] == k) : \n                res = True \n    return res \n\nThe"], [0.10343357999804179, 0.11320754716981132, 0.1457616435109901, "def harmonic_sum(n):\n  if n < 2:\n    return 1\n  else:\n    return 1 / n + (harmonic_sum(n - 1)) \nThe above code is a function that takes in an integer n and calculates the harmonic sum of n-1.\n\ndef extract_string(str, l):\n    result = [e for e in str if len(e) == l] \n    return result\nThe above code is a function to extract specified size of strings from a given list of string values.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to return the minimum number of swapping needed to make two strings identical.\n\nNum_list=list(int,input().split())\n\nOutput:\n\nEnter the size of tuple :2\n\nEnter the numbers for tuple :1 2\n\ncreation of tuple upon the inputs is successful \n\nThe elements in tuple are : \n(1, 2) \n\nUpdate the tuple by converting the tuple to list : \n\nEnter the index"], [0.0870302715705307, 0.10869565217391304, 0.1382317260729925, "def loss_amount(actual_cost,sale_amount): \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return 0\nThe above code is a function that gives loss amount on a sale if the given amount has loss else return 0.\n\ndef is_lower(string):\n  return (string.lower())\nThe above code is a python function to convert the given string to lower case.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " takes 2 input string and return the count of character that to be moved.\ndef add_delimiter(num):\n    return \",\".join(num)\nThe above code adds the comma if the length of number after split it with comma is less than 3 \n"], [0.08595378703869806, 0.08, 0.06906371219953368, "def max_of_nth(test_list, N):\n  res = max([sub[N] for sub in test_list])\n  return (res) \nThe above code is a function which given a matrix represented as a list of lists returns the max of the n'th column.\n\nimport bisect\ndef right_insertion(a, x):\n    return bisect.bisect_right(a, x)\nThe above code is a function to locate the right insertion point for a specified value in sorted order.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function which checks whether it is possible to make the strings equal by a series of swap operations.\n  \ndef bubble(bubbleList): \n    n = len(bubbleList) \n          \n    for i in range(n): \n        for j in range(0, n-i-1): \n            if(len(bubbleList[j]) > len(bubbleList[j + 1])): \n                temp"], [0.10361149175101227, 0.1276595744680851, 0.13591505541345916, "def maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \nThe above code is a function to maximize the given two tuples.\n\ndef _sum(arr):  \n    sum=0\n    for i in arr: \n        sum = sum + i      \n    return(sum)  \nThe above code is a python function to find the sum of an array.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count the minimum swaps.\ndef strCompare(S1,S2): \n  \n    # Copy string\n    temp = S1\n    count = 0\n  \n    # For each char in a string, \n    # check if it is present in temp \n    # If yes, erase the char from temp \n    # Repeat until the temp string becomes blank \n    while(temp!=\"\"): \n  \n       "], [0.13874038800592223, 0.18181818181818182, 0.25757644961169607, "def eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))\nThe above code is a function to find the Eulerian number a(n, m).\n\ndef find(n,m):  \n    q = n//m \n    return (q)\nThe above code is a python function to find quotient of two numbers (rounded down to the nearest integer).\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the cost required to convert a string to another by swapping atmost 2 characters.\n\n \nYour task  is to simulate the problem and find the minimum time required to convert str1 into str2 using only swapping the characters.\n\nInput Format:\n\nFirst line of the input is N and M which denotes the number of alphabets in str1 and str2. The next line has str1. The next line has str2.\n\n"], [0.14735933309172777, 0.21951219512195122, 0.1951629772122431, "def search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)\nThe above code is a python function to find the element that appears only once in a sorted array.\n\nimport math\ndef perimeter_pentagon(a):\n  perimeter=(5*a)\n  return perimeter\nThe above code is a function to find the perimeter of a regular pentagon from the length of its sides.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count number of swaps required in comparison of two strings.\ndef reverse_Vowel(string, vowels): \n  \n    final = [each for each in string if each in vowels][::-1] \n    string = list(string) \n    string[:] = [each if each not in vowels else final.pop(0) for each in string] \n    string = ''.join(string) "], [0.22790334660881337, 0.23255813953488372, 0.2381931120824732, "def cube_Sum(n): \n    sum = 0\n    for i in range(1,n + 1): \n        sum += (2*i)*(2*i)*(2*i) \n    return sum\nThe above code is a python function to find the cube sum of first n even natural numbers.\n\ndef find_dissimilar(test_tup1, test_tup2):\n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) \nThe above code is a function to find the dissimilar elements in the given two tuples.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps required to convert the string into palindrome..\t\t\ndef get_complement(ref, plain) : \n    if len(ref) != len(plain) : \n        return \"\"  \n    key = \"\" \n    i = 0\n    while i < len(ref) :  \n        ch_ref = ref[i] \n        ch_plain = plain[i] \n"], [0.0933635027034907, 0.13793103448275862, 0.19293013024573602, "def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result\nThe above code is a function to sort a given matrix in ascending order according to the sum of its rows.\n\nimport math\ndef lateralsurface_cone(r,h):\n  l = math.sqrt(r * r + h * h)\n  LSA = math.pi * r  * l\n  return LSA\nThe above code is a function to find the lateral surface area of a cone given radius r and the height h.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps that is needed in order to correct the given strings.\nclass Solution:\n    # @param A : tuple of integers\n    # @return an integer\n    def singleNumber(self, A):\n        result = 0\n        for i in A:\n            result = result ^ i\n        return result\nThe above code is a function to find the non-repeated number in the given array.\nimport numpy as np"], [0.09612497907115167, 0.11627906976744186, 0.21532743446177646, "def similar_elements(test_tup1, test_tup2):\n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) \nThe above code is a function to find the shared elements from the given two lists.\n\ndef remove_odd(str1):\n str2 = ''\n for i in range(1, len(str1) + 1):\n    if(i % 2 == 0):\n        str2 = str2 + str1[i - 1]\n return str2\nThe above code is a function to remove odd characters in a string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps to complement the strings.\ndef swap(string, i,y): \n  temp = string[i] \n  string[i] = string[y] \n  string[y] = temp \n     \ndef alternate_character(str, n): \n    for x in range(0, n, 2): \n        swap(str, x, x + 1) \n        \ndef __"], [0.21261129456031838, 0.20408163265306123, 0.3278554254383937, "def min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val\nThe above code is a function to find the minimum value in a given heterogeneous list.\n\ndef extract_rear(test_tuple):\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\n  return (res) \nThe above code is a function to extract only the rear index element of each string in the given tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps required to convert str1 to str2\n\ndef extract_bits(n):\n\tres = [int(i) for i in (bin(n).replace(\"0b\", \"\"))]\n\tprint (*res, sep = \" \",end = \"L\")\n\nThe above code is a function to extract the binary gap inside the given integer.\ndef fibonacci(n): \n    fib[0"], [0.23283448668685786, 0.19047619047619047, 0.19587996076447142, "import heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)\nThe above code is a function to merge three lists into a single sorted list.\n\ndef replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2\nThe above code is a function to replace characters in a string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate the minimum number of swaps required \nto make two strings anagrams.\n\n# QUESTION - 7:\n\nimport functools\n\nclass Result(object):\n    def __init__(self,name):\n        self.name = name\n        \n\ndef workExecutor(func,*args):\n    @functools.wraps(func)\n    def caller(*args):\n        temp=Result("], [0.10950846867939121, 0.17647058823529413, 0.21171087695490118, "def tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result\nThe above code is a function to convert a given tuple of positive integers into a single integer.\n\ndef noprofit_noloss(actual_cost,sale_amount): \n  if(sale_amount == actual_cost):\n    return True\n  else:\n    return False\nThe above code is a function to check whether the given amount has no profit and no loss\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function which returns minimum number of steps required in order to change str1 to str2. If it is not possible, it returns string \"Not Possible\"\ndef mismatch(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count > 2 : \n        return True\n   "], [0.14738160840610082, 0.20408163265306123, 0.3204219643027069, "def count_charac(str1):\n total = 0\n for i in str1:\n    total = total + 1\n return total\nThe above code is a function to count the total number of characters in a string.\n\ndef trim_tuple(test_list, K):\n  res = []\n  for ele in test_list:\n    N = len(ele)\n    res.append(tuple(list(ele)[K: N - K]))\n  return (str(res)) \nThe above code is a function to trim each tuple by k in the given tuple list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count the total number of Swaps required to convert a string into another.\ndef isIsomorphic(str1,str2) : \n    return count_charac(str1) == count_charac(str2) \nThe above code is a function to check whether given two strings are Isomorphic.\ndef reverseAt(input, K): \n  for i in range(len(s) - K, len(s)"], [0.12846131323861235, 0.08, 0.1506174761986487, "import heapq as hq\ndef heap_queue_largest(nums,n):\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums\nThe above code is a function to find the n largest integers from a given list of numbers, returned in descending order.\n\ndef first_Digit(n) :  \n    while n >= 10:  \n        n = n / 10 \n    return int(n) \nThe above code is a python function to find the first digit of a given number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find if it is possible to rearrange a str1 in such a way that the str1 is identical to str2 after the rearrangement.\nimport math\ndef algorithm(strs,s,n) : \n    hash_table = []  \n    hq.nlargest(len(strs), enumerate(strs), key=lambda x: x[1]) \n    for i in range(n) : "], [0.23427820702515983, 0.1875, 0.23097934767180042, "def check_value(dict, n):\n    result = all(x == n for x in dict.values()) \n    return result\nThe above code is a function to check if all values are same in a dictionary.\n\ndef interleave_lists(list1,list2,list3):\n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result\nThe above code is a function to interleave 3 lists of the same length into a single flat list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a recursive function return the minimum number of swaps required to convert str1 to str3.\nfrom collections import deque\n\ndef solve():\n    n = int(input())\n    Queue = deque()\n    for i in range(n):\n        s=list(map(int,list(input().split(' '))))\n        #s=input().split(' ')\n        if s[0] > 0:\n            Queue."], [0.10458660959916134, 0.16129032258064516, 0.18218571702552583, "def harmonic_sum(n):\n  if n < 2:\n    return 1\n  else:\n    return 1 / n + (harmonic_sum(n - 1)) \nThe above code is a function that takes in an integer n and calculates the harmonic sum of n-1.\n\ndef left_rotate(n,d):   \n    INT_BITS = 32\n    return (n << d)|(n >> (INT_BITS - d))  \nThe above code is a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that given two strings of same length, return the fewest swap required to get same string.\n"], [0.13358148696720068, 0.3181818181818182, 0.4526790527643144, "def lateralsuface_cylinder(r,h):\n  lateralsurface= 2*3.1415*r*h\n  return lateralsurface\nThe above code is a function to find the lateral surface area of a cylinder.\n\ndef maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \nThe above code is a function to maximize the given two tuples.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps required.\n"], [0.19237473341755515, 0.19607843137254902, 0.22688003891550965, "def number_of_substrings(str): \n\tstr_len = len(str); \n\treturn int(str_len * (str_len + 1) / 2); \nThe above code is a python function to count the number of non-empty substrings of a given string.\n\nimport re\ndef change_date_format(dt):\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)\nThe above code is a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to determine the minimum number of swaps required in a string so that the strings becomes an Anagram.\n\ndef find_hcf(x, y):  \n   if x > y:  \n       smaller = y  \n   else:  \n       smaller = x  \n   for i in range(1,smaller + 1):  \n       if((x % i == 0) and (y % i == 0)):  \n          "], [0.09498644871598645, 0.1509433962264151, 0.16712283487004634, "def rectangle_area(l,b):\n  area=l*b\n  return area\nThe above code is a function to find the area of a rectangle.\n\ndef combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result\nThe above code is a function to find all possible combinations of the elements of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find minimum swaps for swapping.\n\n# Question 6\n# Write a function for Fibonacci sequences.\n# \n# Fibonacci sequence is a series of numbers such that each number is the sum of the two preceding ones, starting from 0 and 1. Fibonacci \n# number is the sum xn-1 and xn-2. This is the sequence 0, 1, 1, 2, 3, 5, 8, 13,"], [0.20805948921830816, 0.2127659574468085, 0.2599673032187652, "def tuple_modulo(test_tup1, test_tup2):\n  res = tuple(ele1 % ele2 for ele1, ele2 in zip(test_tup1, test_tup2)) \n  return (res) \nThe above code is a function which takes two tuples of the same length and performs the element wise modulo.\n\ndef div_list(nums1,nums2):\n  result = map(lambda x, y: x / y, nums1, nums2)\n  return list(result)\nThe above code is a function to divide two lists element wise.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function which returns the minimum number of swaps required to convert string1 to string2.\nimport numpy as np\ndef get_exp(matrix) :\n    val = int(input())\n    while val > 0 : \n        list1 = input().split() \n        if list1[-1] == \"T\" : \n            reverse = False \n        else : \n            reverse = True   \n        pos = list1"], [0, 0.0, 0.0, "def reverse_string_list(stringlist):\n    result = [x[::-1] for x in stringlist]\n    return result\nThe above code is a function to reverse each string in a given list of string values.\n\nimport heapq as hq\ndef heap_sort(iterable):\n    h = []\n    for value in iterable:\n        hq.heappush(h, value)\n    return [hq.heappop(h) for i in range(len(h))]\nThe above code is a function to sort the given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", "s are interview questions.\n"], [0.1355754326122043, 0.17391304347826086, 0.1991524193091972, "def sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))\nThe above code is a function to find the nth number in the newman conway sequence.\n\ndef extract_freq(test_list):\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\n  return (res)\nThe above code is a function to extract the number of unique tuples in the given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps (only for unpaired characters)\n\ndef counting_sort(array1, max_val):\n    m = max_val + 1\n    count = [0] * m                \n    \n    for a in array1:\n    # count occurences\n        count[a] += 1              \n    i = 0\n    for a in range(m):            \n        for c in range(count"], [0.1736765380999083, 0.24444444444444444, 0.2704921527853546, "def is_num_decagonal(n): \n\treturn 4 * n * n - 3 * n \nThe above code is a function to find the nth decagonal number.\n\nfrom array import array\ndef positive_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)\nThe above code is a function to find the ration of positive numbers in an array of integers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to return the minimum number of swaps needed to convert one string to another string.\n\nimport pandas as pd\npf = pd.read_csv(\"Data.csv\")\nprint(\"Columns  \", pf.columns)\nprint(\"Shows first five lines \", pf.head())\nprint(\"Shows 5th line \" , pf.loc[4])\nprint(\"Shows the information \",  pf.info"], [0.12689043084797128, 0.125, 0.1214231418297618, "def add_dict_to_tuple(test_tup, test_dict):\n  test_tup = list(test_tup)\n  test_tup.append(test_dict)\n  test_tup = tuple(test_tup)\n  return (test_tup) \nThe above code is a function to add a dictionary to the tuple. The output should be a tuple.\n\nimport math\ndef area_tetrahedron(side):\n  area = math.sqrt(3)*(side*side)\n  return area\nThe above code is a function to caluclate the area of a tetrahedron.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " finds out the number of swaps required for the strings to be equal.\n\nimport math\ndef rightAngleTriangle(side1, side2):\n  hyp = math.sqrt((side1**2) + (side2**2))\n  return hyp\nThe above code finds out the hypotradius of a right angle triangle.\n\ndef Remove(str1): \n  mod_str = str1.lower()\n  final_str = ''"], [0.15910925455334968, 0.19047619047619047, 0.19374629261636508, "import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\nThe above code is a function to merge three dictionaries into a single dictionary.\n\nimport cmath\ndef angle_complex(a,b):\n  cn=complex(a,b)\n  angle=cmath.phase(a+b)\n  return angle\nThe above code is a function to get the angle of a complex number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps required to convert a str to another.\n\ndef pushZerosToEnd(arr, n):\n    nonZero = 0\n    for i in range(n):\n        if arr[i]!=0 :\n\n            arr[nonZero]=arr[i]\nnc = 0\nfor i in range(5):\n  print(i)\nArr[nonZero] = arr[i]\n\nnon"], [0.27913243693525897, 0.28888888888888886, 0.3162681498759846, "def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False\nThe above code is a python function to check whether the given number can be represented as the difference of two squares or not.\n\ndef issort_list(list1):\n    result = all(list1[i] <= list1[i+1] for i in range(len(list1)-1))\n    return result\nThe above code is a function to check whether a specified list is sorted or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum number of swaps required to convert one string to another.\n\ndef max_list(list1):\n    maxLen = 0\n    for list in list1:\n        if len(list) > maxLen:\n            maxLen=len(list)\n            res_list=list\n    return res_list\nThe above code is a python function to find the longest length of list in the list.\n\n#####"], [0.13656292494227532, 0.08108108108108109, 0.21683708454166645, "def Find_Max_Length(lst):  \n    maxLength = max(len(x) for x in lst )\n    return maxLength \nThe above code is a python function to find the length of the longest sublists.\n\ndef remove_nested(test_tup):\n  res = tuple()\n  for count, ele in enumerate(test_tup):\n    if not isinstance(ele, tuple):\n      res = res + (ele, )\n  return (res) \nThe above code is a function to remove tuples from the given tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is the Python program to find minimum number of swaps required to \nmake two stings equal.\n\n\n# I have shown three different courses of action from which you have to select your job.If you have time at home and excited about solving problems,then you should try out the second one.There are endless problems to solve and you can actually try it on your own.\nThe list of problems are listed in the blaock below for your reference.PLEASE SELECT THE J"], [0.1298704327238047, 0.13333333333333333, 0.096294122841205, "def insert_element(list,element):\n list = [v for elt in list for v in (element, elt)]\n return list\nThe above code is a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n\ndef add_tuple(test_list, test_tup):\n  test_list += test_tup\n  return test_list\nThe above code is a function to add the given tuple to the given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that returns the minimum number of swaps by even numbers of swaps that can be performed.\n\ndef transpose_list(list1, list2):\n    list1 += [list2[i::3] for i in range(len(list2)//3)]\n    list2[:] = [list2[i::3] for i in range(len(list2)//3)]\nThe above code is a function that mimics trans"], [0.1151806304005737, 0.15254237288135594, 0.2672410687898765, "def sum_average(number):\n total = 0\n for value in range(1, number + 1):\n    total = total + value\n average = total / number\n return (total,average)\nThe above code is a function to find sum and average of first n natural numbers.\n\nimport re\ndef replace_specialchar(text):\n return (re.sub(\"[ ,.]\", \":\", text))\n\nThe above code is a function to replace all occurrences of spaces, commas, or dots with a colon.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the mininum number of swaps required, if there is an even number of pairwise differences between both the strings str1 and str2.\n\nWrite a Python program to replace space with \"&32\".\ndef replaceSpaces(str):\n    return(str.replace(\" \",\"&32\"))\nThe above code is a function to replace all spaces in a string with a space character 32 as defined in the ASCII table, decimal value 32."], [0.133014204264206, 0.1935483870967742, 0.28458278287681493, "import math\ndef volume_cone(r,h):\n  volume = (1.0/3) * math.pi * r * r * h\n  return volume\nThe above code is a function to find the volume of a cone.\n\nfrom operator import eq\ndef count_same_pair(nums1, nums2):\n    result = sum(map(eq, nums1, nums2))\n    return result\nThe above code is The input is defined as two lists of the same length. a function to count indices where the lists have the same values.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a fucntion to count the min number of char to be swapped in the output string when using 2 hashing.\n"], [0.16450880454616149, 0.1590909090909091, 0.2241437099346824, "def lateralsuface_cylinder(r,h):\n  lateralsurface= 2*3.1415*r*h\n  return lateralsurface\nThe above code is a function to find the lateral surface area of a cylinder.\n\ndef check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res \nThe above code is a function to check if given tuple contains no duplicates.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate number of swaps required to form Anagrams using bit operations.\ndef check_triangle(x,y,z):\n    if x+y <z :\n      return \"No\"\n    elif y+z<x :\n      return \"No\"\n    elif z+x<y :\n      return \"No\"\n    return \"Yes\"\nThe above code is a function to check if a tuple is an equ"], [0.2132049944615003, 0.21621621621621623, 0.2658565818925644, "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x\nThe above code is a python function to find the number of divisors of a given integer.\n\ndef largest_neg(list1): \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max\nThe above code is a python function to find the largest negative number from the given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check whether its possible to convert a str1 \ninto str2 with exactly any number of swaps allowed.  \n\ndef snail(snail_map):\n  #[1,2,3,4,5]\n  #[6,7,8,9,10]\n  #[11,12,13,14,15]\n  #[16,17,18,19,20]\n  #[21"], [0.21012272680153815, 0.2127659574468085, 0.2935123040970562, "import re\ndef removezero_ip(ip):\n string = re.sub('\\.[0]*', '.', ip)\n return string\n\nThe above code is a function to remove leading zeroes from an ip address.\n\ndef check_monthnumber_number(monthnum3):\n  return monthnum3==4 or monthnum3==6 or monthnum3==9 or monthnum3==11\nThe above code is a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that returns the minimum number of swaps required to convert the string with the spaces representation into the easy to read text.\n\ndef checkigap(s1):\n s=s1.count(' ')\n return s\nThe above code is a function to check the number of spaces observed between a word.\n\ndef like(words,sequence1):\n c=sequence1.count(words)\n if c>=2:\n  return bool("], [0.23285652367713913, 0.24390243902439024, 0.3570543912905014, "def triangle_area(r) :  \n    if r < 0 : \n        return None\n    return r * r \nThe above code is a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\nimport math \ndef is_polite(n): \n\tn = n + 1\n\treturn (int)(n+(math.log((n + math.log(n, 2)), 2))) \nThe above code is a function to find nth polite number. geeksforgeeks.org/n-th-polite-number/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps required to make a string an anagram of the other string. geeksforgeeks.org/minimum-swaps-to-make-two-strings-anagram/\ndef deposit_calculator(starter_deposit, rate_of_interest, goal_amount) : \n    count = 0\n    while starter_deposit < goal_amount :  \n        if starter_deposit * (rate"], [0.1766968376294857, 0.17073170731707318, 0.1416050288977493, "def square_perimeter(a):\n  perimeter=4*a\n  return perimeter\nThe above code is a function that returns the perimeter of a square given its side length as input.\n\ndef upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr\nThe above code is a python function to count the upper case characters in a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program that takes two strings and returns the mininimum swaps required to convert a string into another string.\n\n'''\nstr1='HEX'\nstr2='LIV'\nif(len(str1)==len(str2)):\n    numoftimes=0\n    while(int(len(str1))>0):\n        if(str1==str2):\n            break\n        else:\n            minx"], [0.11064093581909605, 0.13157894736842105, 0.10734911237995816, "def is_Diff(n): \n    return (n % 11 == 0) \nThe above code is a python function to find whether a number is divisible by 11.\n\ndef diff_even_odd(list1):\n    first_even = next((el for el in list1 if el%2==0),-1)\n    first_odd = next((el for el in list1 if el%2!=0),-1)\n    return (first_even-first_odd)\nThe above code is a function to find the difference of the first even and first odd number of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find minimum swaps to correct the given string(anagram).\n\ndef change(list1) : \n    list1.insert(2,5)\n    list1.insert(5,2)\n    list1.remove(5)\n    list1.insert(1,3)\n    list1.remove(3)\n    list1.remove(2)\n    return (list1) \nThe above code is"], [0.12441482739444053, 0.14285714285714285, 0.21001135218636974, "def check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res \nThe above code is a function to check if given tuple contains no duplicates.\n\ndef parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix\nThe above code is a function to find the directrix of a parabola.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the number of swaps required between the two strings .\n\ndef Comb(p, tm, r): \n  \n    Top1 = (1 - (r / 100)) / (1 - ((1 + r / 100) \n                   ** (-tm))) \n    Top2 = p * (1 + (r / 100)) \n    number = Top2 / Top1 \n    return number \nThe above code is a"], [0.30770577372002883, 0.3076923076923077, 0.41651778506725096, "import re\ndef find_char_long(text):\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))\nThe above code is a function to find all words which are at least 4 characters long in a string.\n\ndef sum(a,b): \n    sum = 0\n    for i in range (1,min(a,b)): \n        if (a % i == 0 and b % i == 0): \n            sum += i \n    return sum\nThe above code is a python function to find the sum of common divisors of two given numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python method to find the minimum number of swaps required to make two strings identical.\n\n"], [0.11638163636079385, 0.20833333333333334, 0.21205496332774015, "def check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res \nThe above code is a function to check if given tuple contains no duplicates.\n\ndef surfacearea_cylinder(r,h):\n  surfacearea=((2*3.1415*r*r) +(2*3.1415*r*h))\n  return surfacearea\nThe above code is a function to find the surface area of a cylinder.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " finds the minimum number of swaps needed as strings are entered.\n"], [0.1852474246945622, 0.1590909090909091, 0.1943499863151938, "def concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) \nThe above code is a function to concatenate each element of tuple by the delimiter.\n\nimport re\ndef remove_uppercase(str1):\n  return re.sub('[A-Z]', '', str1)\nThe above code is a function to remove uppercase substrings from a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to compute the min number of swaps required to make str1 and\nstr2 identical.\n\ndef isAlphabetSeq(arr, n):\n    if n==1:\n        return arr[0] in string.ascii_lowercase or arr[0] in string.ascii_uppercase\n    if(isAlphabetSeq(arr, n-1)) == False:\n        return False\n    if arr"], [0.26288202783105064, 0.225, 0.2183865755972052, "def pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count \nThe above code is a python function to count the number of positive numbers in a list.\n\nimport math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN \nThe above code is a python function to find the next perfect square greater than a given number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to count the number of swaps required in order to make two strings equal.\n\ndef preOrder(node) :  \n  \n    if (not node):  \n        return\n  \n    print(node.data, end = \" \")  \n    preOrder(node.left)  \n    preOrder(node.right)  \n  \n"], [0.23032036944313874, 0.2222222222222222, 0.33258274342003713, "def extract_string(str, l):\n    result = [e for e in str if len(e) == l] \n    return result\nThe above code is a function to extract specified size of strings from a given list of string values.\n\ndef triangle_area(r) :  \n    if r < 0 : \n        return None\n    return r * r \nThe above code is a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that returns the minimum number of swaps required to convert str1 to str2.\n\ndef rev_Sentence(string, length) : \n    string = string.rstrip(\" \") \n    string = string.lstrip(\" \")\n    for i in range(length):  \n        if (string[i] >= chr(97)) and (string[i] <= chr(122)):  \n            x = ch"], [0.11195281896263769, 0.15384615384615385, 0.2271409688668783, "def square_nums(nums):\n square_nums = list(map(lambda x: x ** 2, nums))\n return square_nums\nThe above code is a function to find squares of individual elements in a list.\n\ndef count_samepair(list1,list2,list3):\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\n    return result\nThe above code is a function to count number items that are identical in the same position of three given lists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate minimum swaps to make the strings identical.\n\ndef count_samepair(list1,list2,list3):\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\n    return result\nThe above code is a function to count number items that are identical in the same position of three given lists.\ndef cum_sum(List1):\n\tsumtotal"], [0.13600558870425758, 0.14, 0.16269515512105884, "def last_Digit(n) :\n    return (n % 10) \nThe above code is a python function to find the last digit of a given number.\n\ndef odd_length_sum(arr):\n    Sum = 0\n    l = len(arr)\n    for i in range(l):\n        Sum += ((((i + 1) *(l - i) + 1) // 2) * arr[i])\n    return Sum\nThe above code is a python function to find the sum of all odd length subarrays. https://www.geeksforgeeks.org/sum-of-all-odd-length-subarrays/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the count of minimum character needs to be changed for make it an Anagram in str1, str2.\n\ndef concatenate (array1,array2) :\n    l = list()\n    for i in range(len(array1)):\n        if (array1[i] % 2 != 0) :  \n            l.append(array1[i])\n            l.append(array2[i])"], [0.30055473553969075, 0.3157894736842105, 0.3094273350577125, "def harmonic_sum(n):\n  if n < 2:\n    return 1\n  else:\n    return 1 / n + (harmonic_sum(n - 1)) \nThe above code is a function that takes in an integer n and calculates the harmonic sum of n-1.\n\ndef unique_product(list_data):\n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p\nThe above code is a python function to calculate the product of the unique numbers in a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function that takes two strings and returns the minimum number of swaps required to convert one string into the other, else returns Not Possible if the strings are not possible to convert into each other.\n'''"], [0.08538656340685756, 0.09230769230769231, 0.12332157867842646, "def word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False\nThe above code is a python function to check whether the length of the word is odd or not.\n\ndef nth_nums(nums,n):\n nth_nums = list(map(lambda x: x ** n, nums))\n return nth_nums\nThe above code is a function to compute the n-th power of each number in a list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is to take the Both You and CodeBots as input string and check whether it is possible to convert the tuples with Palindrome Word or not .\n\nWe learned about python keywords and identifiers. Identifiers are the name for the variables, function and classes.\n\nkeywords:\n\nwe have alredy learned about keyword in python\nnumbers\ninstall pyhton on windows and then install jupyter Notebook.\nnumbers are also called oper"], [0.1077170303517099, 0.1111111111111111, 0.2211982171344425, "def tuple_intersection(test_list1, test_list2):\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\n  return (res)\nThe above code is a function to find the tuple intersection of elements in the given tuple list irrespective of their order.\n\ndef is_nonagonal(n): \n\treturn int(n * (7 * n - 5) / 2) \nThe above code is a function to find the nth nonagonal number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swap of characters in a string to create another string.\ndef encode_list(list):\n    res = list\n    return ([res])\nThe above code is a function to encode the list that is it changes all the elements to its corresponding ascii codes.\ndef order_heights(student_list, heights):\n    return ''.join([j[0] for j in sorted([(x,i) for i"], [0.23688285400091622, 0.20930232558139536, 0.2732190730398171, "def remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l\nThe above code is a python function to remove odd numbers from a given list.\n\nimport re\ndef text_match_wordz(text):\n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\nThe above code is a function that matches a word containing 'z'.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to calculate min swaps required to convert one string to another completely.\n\ndef Avgpos(num1,num2,numz) :\n    n=len(numz)\n    sumnum=0\n    prod=num1*num2\n    for i in range(n) :\n        sumnum += (numz[i]*i)\n    if sumnum == 0 :\n        return \"not possible\"\n    else"], [0.08654257592202097, 0.11764705882352941, 0.1154553797508921, "def find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) \nThe above code is a function to find number of lists present in the given tuple.\n\nimport re\ndef find_adverbs(text):\n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))\nThe above code is a function to find the first adverb ending with ly and its positions in a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function as question which checks if its possible to get two strings by swapping two characters of the first string\ndef third_angle_triangle(a1,a2):\n    sum=180-a1-a2\n    return sum\nThe above code is a function as question which gives third angle of the triangle if given two angles\ndef is_name(name):\n    try:\n        if(name.find(' ')!=-1):\n           "], [0.13708082985990325, 0.16666666666666666, 0.22180545930465081, "def next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; \nThe above code is a python function to find the smallest power of 2 greater than or equal to n.\n\ndef extract_nth_element(list1, n):\n    result = [x[n] for x in list1]\n    return result\nThe above code is a function to extract the nth element from a given list of tuples.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function which returns the minimum number of swaps to convert str1 to str2.\ndef numberOfSubstrings(str):\n    choiceDict = {\n        'a' : 0,\n        'b' : 1,\n        'c' : 2\n    }\n\n    small = float(\"inf\")\n    total = 1\n    for l in str:\n        small = min(small, choiceDict[l])\n        small = min"], [0.13389535116515378, 0.1875, 0.16071179811377298, "def search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)\nThe above code is a python function to find the element that appears only once in a sorted array.\n\ndef extract_rear(test_tuple):\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\n  return (res) \nThe above code is a function to extract only the rear index element of each string in the given tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to swap the characters in a string in minimum swaps and \nreturn \"not possible\"(case sensitive) if the minimum swaps required is odd.\n\ndef DifferenceByOneSwap(arr,n) :\n    for i in range(n) : \n        for j in range(i+1,n) :  \n            count = 0\n            arr2 = list ( int ( m ) for m,k  in enumerate(str"], [0.08568130627484105, 0.05660377358490566, 0.10771579323984304, "import math\ndef surfacearea_sphere(r):\n  surfacearea=4*math.pi*r*r\n  return surfacearea\nThe above code is a function to find the surface area of a sphere.\n\ndef round_and_sum(list1):\n  lenght=len(list1)\n  round_and_sum=sum(list(map(round,list1))* lenght)\n  return round_and_sum\nThe above code is a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the round and adds together all the elements in the same position in a list.\n\ndef calculate(n):\n    sum1 = 0\n    while(n > 0): \n        sum1=sum1 + int(n % 10) \n        n = int(n/10)\n    return sum1 \n  \n\nfirst_number = input(\"Enter first number\")\nsecond_number = input(\"Enter second number\")"], [0.12774766125155537, 0.11764705882352941, 0.2274125430534281, "def recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total\nThe above code is a function to flatten a list and sum all of its elements.\n\ndef circle_circumference(r):\n  perimeter=2*3.1415*r\n  return perimeter\nThe above code is a function to find the circumference of a circle.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to determine whether it is possible to split a string in two substrings (a, b) such that a+b is equal to str2.\n"], [0.09499502291555392, 0.16, 0.17577037384032826, "def min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min\nThe above code is a function to find the minimum product from the pairs of tuples within a given list.\n\nimport cmath\ndef polar_rect(x,y):\n cn = complex(x,y)\n cn=cmath.polar(cn)\n cn1 = cmath.rect(2, cmath.pi)\n return (cn,cn1)\nThe above code is a function to convert polar coordinates to rectangular coordinates.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a code for finding the minimum swap required for string str1 to be same as that of string str2.\n\ndef list_product(list1):\n sum1 = 1\n for i in list1:\n  sum1 = sum1 * i\n  return sum1\nThe above code is a function to find the product of a list of numbers\n\ndef product_list(list1, *args):\n sum_dict = {k:i for k"], [0.13744774581593358, 0.14545454545454545, 0.17422828181922645, "def count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr\nThe above code is a python function that returns the number of integer elements in a given list.\n\ndef swap_numbers(a,b):\n temp = a\n a = b\n b = temp\n return (a,b)\nThe above code is a function that takes in two numbers and returns a tuple with the second number and then the first number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a probability problem whose output is given by the statement to find out the minimum number of swaps required in swapping the letters of the two given strings in order to have both string identical.\n\ndef checksum(arr) : \n    uniques = []\n    no_of_uniques = 0\n    odd_found = False\n    checksum = 0\n\n    for i in arr : \n        if i not in uniques : \n            uniques."], [0.1894002711723156, 0.23255813953488372, 0.3806853201455185, "def interleave_lists(list1,list2,list3):\n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result\nThe above code is a function to interleave 3 lists of the same length into a single flat list.\n\ndef find_dissimilar(test_tup1, test_tup2):\n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) \nThe above code is a function to find the dissimilar elements in the given two tuples.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps required to convert one string to the other\ndef frequency_distribution(list_of_integers):\n    freq_dict = {}   \n    for number in list_of_integers:\n        try:\n            freq_dict[number] = freq_dict[number] + 1  # Update an existing entry if possible\n        except KeyError:\n            freq_dict[number] = 1"], [0.1377188412252046, 0.19230769230769232, 0.25871436992031044, "def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1\nThe above code is a function to find nth centered hexagonal number.\n\ndef find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count\nThe above code is a function that counts the number of pairs of integers in a list that xor to an even number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is the function to find the actual number of swaps to find the relationship between two strings.\n"], [0.16617581182651353, 0.22727272727272727, 0.292967945404634, "def round_and_sum(list1):\n  lenght=len(list1)\n  round_and_sum=sum(list(map(round,list1))* lenght)\n  return round_and_sum\nThe above code is a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n\ndef _sum(arr):  \n    sum=0\n    for i in arr: \n        sum = sum + i      \n    return(sum)  \nThe above code is a python function to find the sum of an array.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the number of edits required to convert a list of string into another string.\n# function which returns as a list  \ndef sublists(lst): \n    sublist=[]    \n    for i in range(len(lst) + 1):          \n        for j in range(i + 1, len(lst) + 1):          \n            sub=lst[i:j] \n            sublist."], [0.08789922672202222, 0.06896551724137931, 0.0947008365183428, "def max_length(list1):\n    max_length = max(len(x) for x in  list1 )  \n    max_list = max((x) for x in   list1)\n    return(max_length, max_list)\nThe above code is a function to find the list of maximum length in a list of lists.\n\ndef min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val\nThe above code is a function to find the minimum value in a given heterogeneous list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check if the #str1# and #str2# strings can be neighbours to each other or not.\n\nclass person:\n\tdef __init__(self, name, age, work_status)\n\t\tself.name = name.upper()\n  \t\tself.age = age\n  \t\tself.work = work_status\nGetters, setters and deleters are used in python for creating and accessing object variables."], [0.12185461523621959, 0.10204081632653061, 0.11563534233931735, "def circle_circumference(r):\n  perimeter=2*3.1415*r\n  return perimeter\nThe above code is a function to find the circumference of a circle.\n\ndef find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False\nThe above code is a python function to find whether the parity of a given number is odd.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to swap two blocks of strings in such a way that no extra or less character of strings is swapped.\n\ndef find_min_expensive(customers) :  \n    min1_index = 0 \n    min2_index = -1 \n    difference = 0\n    min1_Price = 0 \n    min2_Price = 0 \n    for i in range(customers) :    \n        if (min1"], [0.08573700817374713, 0.11320754716981132, 0.12398991277816006, "def division_elements(test_tup1, test_tup2):\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) \nThe above code is a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n\ndef add_tuple(test_list, test_tup):\n  test_list += test_tup\n  return test_list\nThe above code is a function to add the given tuple to the given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in two strings and tells whether it's possible to obtain one string from the other using the set of characters from the other.\nThe\tonly\tstrings\tof\tlength\tone\tthat\tare\ta\tpalindrome\tare\t\u201c0\u201d, \u201c1\u201d, \u201c8\u201d \ndef Chek(X) : \n    c1 = 0\n    c2 = 0\n    c3 ="], [0.22128247535522158, 0.2, 0.26245774666195887, "def square_nums(nums):\n square_nums = list(map(lambda x: x ** 2, nums))\n return square_nums\nThe above code is a function to find squares of individual elements in a list.\n\ndef second_smallest(numbers):\n  unique_numbers = list(set(numbers))\n  unique_numbers.sort()\n  if len(unique_numbers) < 2:\n    return None\n  else:\n    return unique_numbers[1]\nThe above code is a function to find the second smallest number in a list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to print minimum number of swaps required to convert a str1 in str2.\ndef removedup(inp):\n return list(set(inp))\nThe above code is a function to remove duplicate elements of a given list(inp) and return a list without duplicate elements.\nimport re \ndef rename_files(name,chng): \n    newname = re.sub(r'[\\w]+[\\S]+',"], [0.15068834484605523, 0.17777777777777778, 0.11972781512181703, "def sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)\nThe above code is a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\n\ndef dog_age(h_age):\n if h_age < 0:\n \texit()\n elif h_age <= 2:\n\t d_age = h_age * 10.5\n else:\n\t d_age = 21 + (h_age - 2)*4\n return d_age\nThe above code is a function to calculate a dog's age in dog's years.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps (changes, additions and removals).\ndef find_mismatch(source,target):\n    count = 0\n    for i in range(min(len(source), len(target))):\n        if source[i] != target[i]:\n            source = source[:i] + source[i+1:]\n            target = target[:i] + target[i+1:]\n"], [0.15964075378021733, 0.16666666666666666, 0.1492011803751948, "def multiply_num(numbers):  \n    total = 1\n    for x in numbers:\n        total *= x  \n    return total/len(numbers) \nThe above code is a function to multiply all the numbers in a list and divide with the length of the list.\n\ndef cube_Sum(n): \n    sum = 0\n    for i in range(1,n + 1): \n        sum += (2*i)*(2*i)*(2*i) \n    return sum\nThe above code is a python function to find the cube sum of first n even natural numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " finds the minimum number of swaps to convert the str1 to str2.\nimport random \n    list1 = random.sample(range(1,10),4)\n    list2 = random.sample(range(1,10),4)\n    list3 = list1 + list2\nprint(\"List before shuffling:\",list3)\nrandom.shuffle(list3)    \nprint(\"List after shuffling:\",list3)\nThe"], [0.09320537426682104, 0.10909090909090909, 0.15214607136417369, "import math\ndef area_tetrahedron(side):\n  area = math.sqrt(3)*(side*side)\n  return area\nThe above code is a function to caluclate the area of a tetrahedron.\n\ndef find_sum(arr): \n    arr.sort() \n    sum = arr[0] \n    for i in range(len(arr)-1): \n        if (arr[i] != arr[i+1]): \n            sum = sum + arr[i+1]   \n    return sum\nThe above code is a python function to find the sum of non-repeated elements in a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to minimize the string distance by swapping two characters.\ndef find_len(str): \n    counter = 0\n    for i in str:  \n        for j in str : \n            if i == j : \n                counter = counter + 1 \n                str = str.replace(i,'')  \n    return (counter) \nThe above code is a function to calculate the number of times each character is repeated n a given string"], [0.09475986729323202, 0.10416666666666667, 0.11659471080994, "from itertools import groupby\ndef consecutive_duplicates(nums):\n    return [key for key, group in groupby(nums)] \nThe above code is a function to remove consecutive duplicates of a given list.\n\ndef remove_length(test_str, K):\n  temp = test_str.split()\n  res = [ele for ele in temp if len(ele) != K]\n  res = ' '.join(res)\n  return (res) \nThe above code is a function to remove all the words with k length in the given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a funtion to calculate the number of swops required to bring two given strings into anagrams.\ndef find_pairs(arr,k) :\n    counter = 0\n    table = dict()\n    for ele in arr : \n        if k-ele in table : \n            counter += table.get(k-ele) \n        if ele in table :  \n            table[ele] += 1 \n        else : \n"], [0.09159693084451256, 0.07272727272727272, 0.16351688689280564, "def remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l\nThe above code is a python function to remove odd numbers from a given list.\n\ndef sum_odd(n): \n    terms = (n + 1)//2\n    sum1 = terms * terms \n    return sum1  \ndef sum_in_range(l,r): \n    return sum_odd(r) - sum_odd(l - 1)\nThe above code is a python function to find the sum of all odd natural numbers within the range l and r.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " takes two strings, str1 and str2, both with the same length. It returns the minimum number required to change str1 to str2.\ndef next_min_sum(n) :\n    minsum = n\n    if (n % 2 == 0) : \n        minsum = int(n / 2)\n  \n    return (2 * minsum) \n  \ndef generate_sum(n) : \n    pm = next"], [0.14558848742770952, 0.19696969696969696, 0.25322588865546247, "def cube_Sum(n): \n    sum = 0\n    for i in range(1,n + 1): \n        sum += (2*i)*(2*i)*(2*i) \n    return sum\nThe above code is a python function to find the cube sum of first n even natural numbers.\n\ndef Split(list): \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li\nThe above code is a python function which takes a list of integers and only returns the odd ones.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function which takes two strings as inputs and returns the minimum number of swaps (a swap involves two letters of the incorrect pair being changed) made to convert one string to another (take the inputs in alphabetical order).\nHello\n      Hello\n       Hello\nThe above is an example for space filling functions.\n\n# **Question 4**:\n# Write a python program that list all the positive numbers in list1 which are not in list2 and vice versa. Also"], [0.08803512510940963, 0.11267605633802817, 0.10503326310016599, "def lateralsurface_cube(l):\n  LSA = 4 * (l * l)\n  return LSA\nThe above code is a function to find the lateral surface area of a cube given its side length.\n\ndef dict_filter(dict,n):\n result = {key:value for (key, value) in dict.items() if value >=n}\n return result\nThe above code is a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is an algorithm for counting the minimum swaps required for typing a string by taking two strings and their indexes.\nExecuting the code below generates a random string of characters and prompts the user to select a file. The program attempts to open the file created by the user, reads the first element in the Series, and then compares it against a randomly generated Series. The execution stops if -\n1) The user enters N as an input.\n2) The user enters E as an input."], [0.121699204812741, 0.15789473684210525, 0.31401025414692035, "def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True\nThe above code is a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n\ndef add_string(list_, string):\n add_string=[string.format(i) for i in  list_]\n return add_string\nThe above code is a function to apply a given format string to all of the elements in a list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program to find whether the minimum number of required swaps required to sort an array of elements can be used to sort or not.\n    \ndef isogramic_Substring(string):\n    Dictionary = {}\n    for i in string:\n        if i in Dictionary.keys():\n            return False\n        else:\n            Dictionary[i] = 1\n    return True\nThe above code is a python script to check whether the given string has 2 is"], [0.14455334542930004, 0.08888888888888889, 0.26444426666884535, "def count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) \nThe above code is a function to find the number of elements that occurs before the tuple element in the given tuple.\n\ndef Find_Max_Length(lst):  \n    maxLength = max(len(x) for x in lst )\n    return maxLength \nThe above code is a python function to find the length of the longest sublists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find out whether it is possible to make str2 identical to str1 with an odd number.\nstrstr(\"hello\",\"ellipsis\",1)\ndef toHex(a):\n    CHARS = ('0','1','2','3','4','5','6','7','8','9','a','b','c', 'd', 'e', 'f')\n    ans = ''\n    \n    while a:\n     "], [0.1402489512147811, 0.13953488372093023, 0.17383607552474875, "def round_and_sum(list1):\n  lenght=len(list1)\n  round_and_sum=sum(list(map(round,list1))* lenght)\n  return round_and_sum\nThe above code is a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n\ndef parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix\nThe above code is a function to find the directrix of a parabola.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " aim at finding the minimum number of swaps in order to make the two string equal.\ndef sum_numbers(s):\n    l = []\n    for i in s:\n        try:\n            l.append(int(i))\n        except:\n            continue\n    l.sort()\n    #print l\n    try:\n        mi = l[0]*l[1]*l[-1]\n    except:\n       "], [0.08922066124847258, 0.06666666666666667, 0.058302181769607185, "def min_of_three(a,b,c): \n      if (a <= b) and (a <= c): \n        smallest = a \n      elif (b <= a) and (b <= c): \n        smallest = b \n      else: \n        smallest = c \n      return smallest \nThe above code is a function to find minimum of three numbers.\n\ndef count_charac(str1):\n total = 0\n for i in str1:\n    total = total + 1\n return total\nThe above code is a function to count the total number of characters in a string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to arrange the characters in a string such that for given two strings str1 and str2, str1[i] = str2[i] for every 0 <= i < n.  If the characters are same even after swapping then it is also accepted.\n\n\ndef common_data(list1,list2):\n    gene1_result\n    for name1 in list1:\n        for name2 in list2:\n            if name1=="], [0.12050435648971788, 0.14814814814814814, 0.24669882572502458, "def list_split(S, step):\n    return [S[i::step] for i in range(step)]\nThe above code is a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\ndef replace_spaces(text):\n  return \"\".join(\" \" if c == \"_\" else (\"_\" if c == \" \" else c) for c in text)\nThe above code is a function to replace whitespaces with an underscore and vice versa in a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that outputs the minimum number of swaps required, if possible, to get two given strings equivalent.\ndef special_numbers(N, c) : \n    count = 0\n    for i in range(1, N + 1) : \n        s = 0\n        for j in str(i) : \n            s += int(j) ** c \n        if (s == i) : \n            count += 1\n   "], [0.10544150404779132, 0.10714285714285714, 0.16607686505815739, "def find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False\nThe above code is a function to check if a string is present as a substring in a given list of string values.\n\ndef replace_spaces(text):\n  return \"\".join(\" \" if c == \"_\" else (\"_\" if c == \" \" else c) for c in text)\nThe above code is a function to replace whitespaces with an underscore and vice versa in a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of replacements that are done when two strings are converted to each other or vice versa for a given set of strings.\ndef can_convert(str1, str2) : \n    isLetterFound = False\n    for letter in str1 : \n        if (letter == 'a') : \n            isLetterFound = True\n        elif (isLetterFound) : \n            if (letter == 'b"], [0.032010613202676445, 0.18181818181818182, 0.2883994837339442, "def tuple_str_int(test_str):\n  res = tuple(int(num) for num in test_str.replace('(', '').replace(')', '').replace('...', '').split(', '))\n  return (res) \nThe above code is a function to convert tuple string to integer tuple.\n\ndef left_rotate(n,d):   \n    INT_BITS = 32\n    return (n << d)|(n >> (INT_BITS - d))  \nThe above code is a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate the minimum swaps.\n"], [0.30972535713220717, 0.2972972972972973, 0.32339234208184636, "def sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))\nThe above code is a function to find the nth number in the newman conway sequence.\n\ndef Split(list): \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li\nThe above code is a python function which takes a list of integers and only returns the odd ones.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function that takes two strings and returns the minimum number of swaps required to convert a string into the other even if you are allowed to swap characters in the strings.\n\n\n"], [0.26652333113368193, 0.2553191489361702, 0.38948233332938076, "def even_bit_set_number(n): \n    count = 0;res = 0;temp = n \n    while(temp > 0): \n        if (count % 2 == 1): \n            res |= (1 << count)\n        count+=1\n        temp >>= 1\n    return (n | res) \nThe above code is a python function to set all even bits of a given number.\n\ndef toggle_string(string):\n string1 = string.swapcase()\n return string1\nThe above code is a function to toggle the case of all characters in a string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to count the number of swaps required to convert one string to another string.\n\ndef reverseCharsInString(string):\n    li=[]\n    li=[s for s in string]\n    li.reverse()\n    return \"\".join(li)\nThe above code is a function to reverse order of two strings in python using list.\n\ndef ToggleCase(string):\n    li = list(string)\n    for i in"], [0.18523698925072749, 0.11538461538461539, 0.2401251454582473, "def count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr\nThe above code is a python function that returns the number of integer elements in a given list.\n\ndef dog_age(h_age):\n if h_age < 0:\n \texit()\n elif h_age <= 2:\n\t d_age = h_age * 10.5\n else:\n\t d_age = 21 + (h_age - 2)*4\n return d_age\nThe above code is a function to calculate a dog's age in dog's years.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " returns minimum number of swaps required to make str1 equal to str2.\ndef staircase(n):\n    for i in range(1,n+1):\n        print (' '*(n-i)+'#'*i)\n    \nThe above code prints an astraight staircase of hash symbols using the formatting function.\nn=5\nfor i in range (1,n):\n    print(' '*(n-i) + '#"], [0.10256600934577677, 0.13953488372093023, 0.19050555687837706, "import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\nThe above code is a function to merge three dictionaries into a single dictionary.\n\nfrom itertools import groupby\ndef consecutive_duplicates(nums):\n    return [key for key, group in groupby(nums)] \nThe above code is a function to remove consecutive duplicates of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find minimum swaps required.\nimport re\n\ndef modified_replace(text):\n    return re.sub(r\"(@[\\u0100-\\U000100FF]+)\",  r\"\\1\", text)\nThe above code is a function to find successfull match without  any special characters.\n\nimport numpy as np \nimport matplotlib.pyplot as plt \ndef make_highlight_region("], [0.13017571788696575, 0.14285714285714285, 0.1982949421528959, "def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     \nThe above code is a function to find whether a given array of integers contains any duplicate element.\n\ndef sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)\nThe above code is a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum no of swaps required to make two strings equal.\ndef gcd(a,b) :\n  smaller = max([a,b])\n  greater = min([a,b])\n  if greater == 0 : \n   return smaller\n  else : \n    return gcd(greater, smaller % greater)\nThe above code is a function to find the greatest common divisor of two integers.\n"], [0.1671508107491928, 0.15254237288135594, 0.23950508342080132, "def check_greater(arr, number):\n  arr.sort()\n  return number > arr[-1]\nThe above code is a function to check whether the entered number is greater than the elements of the given array.\n\ndef rotate_right(list, m):\n  result =  list[-m:] + list[:-m]\n  return result\nThe above code is a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/python-program-right-rotate-list-n/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate minimum number of swaps required to match a string with given pattern.\n\nhttps://practice.geeksforgeeks.org/problems/count-possible-triangles/0\nGiven an array of strings, find the maximum number of possible triangles that can be formed using strings from the array. The order of choosing strings for a triangle matters.\n\nThe string can be used only if it has not been used earlier for other triangles.\n\nNote"], [0.110016552078731, 0.11764705882352941, 0.20415213701818097, "def sum_list(lst1,lst2):\n  res_list = [lst1[i] + lst2[i] for i in range(len(lst1))] \n  return res_list\nThe above code is a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n\nimport re\ndef text_starta_endb(text):\n        patterns = 'a.*?b$'\n        return re.search(patterns,  text)\nThe above code is a function that matches a string that has an 'a' followed by anything, ending in 'b'.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function takes two strings and return the minimum number of swaps that can be performed\non them to make them anagrams of themselves.\nUsing a string of characters, we need to develop a sorting algorithm\n# The idea is to iterate over each character in alphabetic order and search for that char in the string.\n# If the character is found, replace it with an empty character.\n# Otherwise, check if that char occurs later in the string.\n#"], [0.24998368688639389, 0.25, 0.22926480848234992, "def max_length_list(input_list):\n    max_length = max(len(x) for x in input_list )   \n    max_list = max(input_list, key = lambda i: len(i))    \n    return(max_length, max_list)\nThe above code is a function to find the list with maximum length.\n\ndef drop_empty(dict1):\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1\nThe above code is a function to drop empty items from a given dictionary.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find no. of swaps required to convert a string partially to another.\n\nstr1,str2=input().split()\nprint(min_Swaps(str1,str2))\nfrom itertools import permutations \nstr1=input().split(',')\nutf8=[]\nfor i in str1:\n  utf8.append(i[2:])\ncombi=permutations(utf8)\n"], [0.10554414389342469, 0.14545454545454545, 0.16712283487004628, "def check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res \nThe above code is a function to check if given tuple contains no duplicates.\n\nimport re\ndef text_match_three(text):\n        patterns = 'ab{3}?'\n        return re.search(patterns,  text)\nThe above code is a function that matches a string that has an a followed by three 'b'.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that checks number of swaps needed to make two strings equal. \n\ndef query_frequent(items):\n  # parameter items is function that returns the item as key and number of times it is there in given sequence.\n  # Write your code here\n  dic = {}\n  for index,item in items:\n    if item in dic.keys():\n      dic[item].append(index)\n    else:\n     "], [0.39621335791669027, 0.32142857142857145, 0.4162823787915668, "def odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count \nThe above code is a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.\n\ndef maximum(a,b):   \n    if a >= b: \n        return a \n    else: \n        return b \nThe above code is a python function to find the maximum of two numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum number of swaps required to make two same strings into an anagram.\n"], [0.13684777393422176, 0.14, 0.2738964196668499, "def trim_tuple(test_list, K):\n  res = []\n  for ele in test_list:\n    N = len(ele)\n    res.append(tuple(list(ele)[K: N - K]))\n  return (str(res)) \nThe above code is a function to trim each tuple by k in the given tuple list.\n\nimport re \nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\ndef check_str(string): \n\treturn re.search(regex, string)\nThe above code is a function to check whether the given string is starting with a vowel or not using regex.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to return the minimum number of swaps to make two strings cirrent.\n\nN = int(input())\ndef pair_Sum(a, b) : \n    print(a + b, end = \" \") \nfor i in range(0, N) : \n    a, b = map(int, input().strip().split())  \n    pair_Sum(a, b) \nThe above code is a function to"], [0.10254206940413807, 0.14634146341463414, 0.1412219030128236, "def intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result\nThe above code is a function to find the intersection of two arrays.\n\ndef check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res \nThe above code is a function to check if given tuple contains no duplicates.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps required,if we shuffle the characters of both strings and result in the same string.\n\nPC = ['computadora','pollo','perro','queso','perico']\nPF = ['puas','supu','puag','supo','supa']\nlista1_lista2 = zip(PC,PF)\ndef fix_key(lista1_lista2,str1_str"], [0.14072556468255273, 0.16326530612244897, 0.18587745311118195, "def word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False\nThe above code is a python function to check whether the length of the word is odd or not.\n\ndef power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)\nThe above code is a function to calculate the value of 'a' to the power 'b'.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate the number of swaps required.\n\ndef transpose(lis) : \n    lis = list(zip(*lis)) \n    lis = [list(row) for row in lis] \n     # returns a list containing all the sublists of the list as separate lists\n  \n    return lis\nThe above code is a python function to find transpose of a matrix.\ndef check(matrix,word)"], [0.09152508258356225, 0.1, 0.15244922709141667, "def min_of_three(a,b,c): \n      if (a <= b) and (a <= c): \n        smallest = a \n      elif (b <= a) and (b <= c): \n        smallest = b \n      else: \n        smallest = c \n      return smallest \nThe above code is a function to find minimum of three numbers.\n\ndef square_Sum(n):  \n    return int(2*n*(n+1)*(2*n+1)/3)\nThe above code is a python function takes in an integer n and returns the sum of squares of first n even natural numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the count of swaps of characters. You need to swap all the even positioned characters and print the count. \nAlso the end strings should be of same length. (Note:I've changed the problem statement and work on the below code)\ndef min_Swaps(str1,str2) : \n    count = 0\n    j = len(str1) - 1\n    for i in range(len(str1))  :"], [0.10312247673004905, 0.10256410256410256, 0.0673863095633504, "def min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min\nThe above code is a function to find the minimum product from the pairs of tuples within a given list.\n\ndef sum_average(number):\n total = 0\n for value in range(1, number + 1):\n    total = total + value\n average = total / number\n return (total,average)\nThe above code is a function to find sum and average of first n natural numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to reverse a given string recursively.\ndef string_stripper(str1,str2) : \n    len1 = len(str1) \n    len2 = len(str2) \n    if str2.issubset(str1) or str1.issubset(str2) : \n        print(len1 - len2) \n    else : \n        print(-1) \n"], [0.14125778217484158, 0.1509433962264151, 0.27503512785139245, "def sum_even_and_even_index(arr):  \n    i = 0\n    sum = 0\n    for i in range(0, len(arr),2): \n        if (arr[i] % 2 == 0) : \n            sum += arr[i]  \n    return sum\nThe above code is a python function to find the sum of even numbers at even positions of a list.\n\ndef extract_nth_element(list1, n):\n    result = [x[n] for x in list1]\n    return result\nThe above code is a function to extract the nth element from a given list of tuples.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to tell the number of moves required to convert str1 to str2 in order by swapping.\n\ndef find_pairs(list,x):\n    for i in list:\n        for j in list:\n            if i < j:\n                s = x - (i + j)\n                if s in list:\n                    print(s,i,j)\n\n\nThe above code is a Python function to find triples whose sum"], [0.1089557342141703, 0.11428571428571428, 0.1148598951465806, "def similar_elements(test_tup1, test_tup2):\n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) \nThe above code is a function to find the shared elements from the given two lists.\n\ndef multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)\nThe above code is a function to multiply two integers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find if string is possible or not.\nAll test cases from the above challenge have been successfully passed.\n"], [0.1014878977509605, 0.15217391304347827, 0.265291357258531, "def sub_list(nums1,nums2):\n  result = map(lambda x, y: x - y, nums1, nums2)\n  return list(result)\nThe above code is a function to subtract two lists element-wise.\n\nimport math \ndef find_Index(n): \n    x = math.sqrt(2 * math.pow(10,(n - 1)))\n    return round(x)\nThe above code is a python function to find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to minimum swap required two string.\n\ndef ToBinary(n): \n  binary = \"\"\n  for i in range(n + 1): \n    ans = int(input()) \n    ans = \"{0:b}\".format(ans) \n    binary += ans + \"\\n\"\n  return binary\n#Code to print binary number for the input decimal using binary() function \ndef FloorDivision_Boolean("], [0.20319943177453, 0.16666666666666666, 0.15862580748831687, "def check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\nThe above code is a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n\ndef convert_list_dictionary(l1, l2, l3):\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\n     return result\nThe above code is a function to convert more than one list to nested dictionary.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find out the number of swaps required to make   two string(s) isomorphic.\n\ndef pair_sum(lst,k):\n  seen=set\n  output=set\n  for num in lst:\n    target=k-num\n    if target not in seen:\n      seen.add(num)\n    else:\n      output.add((min(num,target),max(num,target)))\n "], [0.23858192752451687, 0.1956521739130435, 0.16938607036243836, "def split_two_parts(list1, L):\n    return list1[:L], list1[L:]\nThe above code is a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n\ndef remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l\nThe above code is a python function to remove odd numbers from a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in two strings and spits out the minimum number of swaps required to convert str1 into str2.\ndef frequency_dict(l):\n\n    freq = {}\n    for i in range(0, len(l)):\n        if l[i] in freq.keys():\n            freq[l[i]]=freq[l[i]]+1\n        else:\n            freq[l[i]]"], [0.1124404006279719, 0.14285714285714285, 0.15276895401922191, "def count_X(tup, x): \n    count = 0\n    for ele in tup: \n        if (ele == x): \n            count = count + 1\n    return count \nThe above code is a python function that takes in a tuple and an element and counts the occcurences of the element in the tuple.\n\ndef string_to_tuple(str1):\n    result = tuple(x for x in str1 if not x.isspace()) \n    return result\nThe above code is a function to convert a given string to a tuple of characters.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps at which a string can be converted to string 2.\n\ndef Groupsum(lst,n,k):\n    lst.sort()\n    if k==0:\n        return True\n    for i in range(len(lst)):\n        if lst[i]>k:\n            return False\n        if (n-i)>=(k-lst[i]):\n            diff"], [0.1427874170432154, 0.2037037037037037, 0.14581609200524595, "def check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\nThe above code is a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n\ndef extract_rear(test_tuple):\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\n  return (res) \nThe above code is a function to extract only the rear index element of each string in the given tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in two strings and returns the minimum swaps required to convert one string into another.\n\ndef print_op(result):\n  if len(result) != 0:\n    for item in result:\n      print (item, end=\"\")\n  else:\n    print(\"Empty\")\n\nThe above code is a function that takes in a list of processed strings and prints them. It has a condition in case the list is empty. It prints"], [0.17739623794433015, 0.17391304347826086, 0.19424248034832464, "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x\nThe above code is a python function to find the number of divisors of a given integer.\n\ndef concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) \nThe above code is a function to concatenate each element of tuple by the delimiter.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the number of swaps required to make two strings identical.\ndef three_non_repeating(str1) : \n    d = {} \n    str1 = str1.lower() \n    count = 0\n    for i in range(0, len(str1)) :    \n        if str1[i] in d: \n            d[str1[i]] += 1\n        else: \n            d"], [0.07717146001442812, 0.058823529411764705, 0.07541923667503475, "import heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)\nThe above code is a function to merge three lists into a single sorted list.\n\nimport re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))\nThe above code is a function to convert the given snake case string to camel case string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " will give whether it is possible swap two substring or not.\ndef toggle_case(string):\n    new_str = \"\".join([c.lower() if c.isupper() else c.upper() for c in string])\n    if string == new_str :\n        return string\n    else:\n        if string.islower() :\n            return new_str\n        else :\n            return string\nThe above code is a function which"], [0.09043231014293467, 0.09433962264150944, 0.13114418995300756, "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x\nThe above code is a python function to find the number of divisors of a given integer.\n\nfrom operator import eq\ndef count_same_pair(nums1, nums2):\n    result = sum(map(eq, nums1, nums2))\n    return result\nThe above code is The input is defined as two lists of the same length. a function to count indices where the lists have the same values.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is to check for anagram.If we can swap even number of characters, then the string will be an anagram of itself.\n\ndef min_swaps(str1, str2) : \n    count = 0\n    for i in range(len(str1)) : \n        if ((str1[i] != str2[i]) and  \n           (str2[i] == str2[i - 1])) : \n"], [0.18584122112988954, 0.1875, 0.204499751978309, "def max_val(listval):\n     max_val = max(i for i in listval if isinstance(i, int)) \n     return(max_val)\nThe above code is a function to find the maximum value in a given heterogeneous list.\n\ndef sum_odd(n): \n    terms = (n + 1)//2\n    sum1 = terms * terms \n    return sum1  \ndef sum_in_range(l,r): \n    return sum_odd(r) - sum_odd(l - 1)\nThe above code is a python function to find the sum of all odd natural numbers within the range l and r.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to count the minimum number of swaps required,\nin order to make the two strings anagram and same.\n\ndef bigger(big,little) :\n    big_char = sorted(big)\n    little_char = sorted(little) \n    for i in big_char : \n        if i not in little_char :  \n            return False \n    if big == little :\n        return -1\n    return True"], [0.2888839765510965, 0.3157894736842105, 0.35414450662503993, "def find_Average_Of_Cube(n):  \n    sum = 0\n    for i in range(1, n + 1): \n        sum += i * i * i  \n    return round(sum / n, 6) \nThe above code is a python function to find the average of cubes of first n natural numbers.\n\ndef test_three_equal(x,y,z):\n  result = set([x,y,z])\n  if len(result)==3:\n    return 0\n  else:\n    return 4-len(result)\nThe above code is a python function to count the number of equal numbers from three given integers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum number of swaps required to \nconvert string A to string B.\n\n#Programs To Write Functions:\n\ndef simpleInterest(p,t,r):\n    p=int(input('enter the principle : '))\n    t=(int(input('enter the time : ')))\n    r=(int(input('enter the rate : ')))\n    simpint=p*t*r/100"], [0.16787754309586184, 0.17073170731707318, 0.2724638261035837, "from collections import defaultdict\ndef max_aggregate(stdata):\n    temp = defaultdict(int)\n    for name, marks in stdata:\n        temp[name] += marks\n    return max(temp.items(), key=lambda x: x[1])\nThe above code is a function to calculate the maximum aggregate from the list of tuples.\n\nimport math\ndef area_tetrahedron(side):\n  area = math.sqrt(3)*(side*side)\n  return area\nThe above code is a function to caluclate the area of a tetrahedron.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps required to convert str1 to str2.\n!pip install pylint\n! pip install numpy\ndef print_square () :\n  for i in range (1,6):\n        print(i*i)\n  return\nprint_square()\n"], [0.24971629827553804, 0.24444444444444444, 0.32952665028980666, "def even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; \nThe above code is a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n\ndef _sum(arr):  \n    sum=0\n    for i in arr: \n        sum = sum + i      \n    return(sum)  \nThe above code is a python function to find the sum of an array.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the shortest number of swaps required to convert one string into another .\ndef palindrome(str1) : \n    for i in range(0,len(str1)) : \n        if str[i] != str[len(str1)-i-1] : \n            return \"Not a Palindrome\"\n    return \"Palindrome\" \nThe above code is a python function to check if a given"], [0.1580556938906046, 0.16, 0.25234204517683917, "def insert_element(list,element):\n list = [v for elt in list for v in (element, elt)]\n return list\nThe above code is a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n\nfrom itertools import groupby\ndef consecutive_duplicates(nums):\n    return [key for key, group in groupby(nums)] \nThe above code is a function to remove consecutive duplicates of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to return the minimum no of swaps required to convert str1 to str2 .\ndef print_combn(n) :\n    for i in range(1, n+1) : \n        for j in range(1, i+1): \n            print(j,sep=\"\",end=\"\") \n            print() \nThe above code is a function to print all possible combinations of positive integers in a given range in ascending order"], [0.1922090912289713, 0.30434782608695654, 0.4439248877177334, "import re\ndef start_withp(words):\n for w in words:\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\n        if m:\n            return m.groups()\nThe above code is a function to return two words from a list of words starting with letter 'p'.\n\nimport re \nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\ndef check_str(string): \n\treturn re.search(regex, string)\nThe above code is a function to check whether the given string is starting with a vowel or not using regex.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to return minimum swaps required to convert a str1 to str2. ('aeiouAEIOU')\n\n"], [0.2924812577820374, 0.2926829268292683, 0.5410646424370823, "def odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count \nThe above code is a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.\n\ndef parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix\nThe above code is a function to find the directrix of a parabola.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum number of swaps required to convert a string to another string.\nstr1=\"aabbccdd\"\nstr2=\"ddcceeff\"\nthe number of swaps required is 2.\n\ndef podfather(z) : \n   z = z.upper() \n   count=0\n\n   for i in range(len(z)) : \n      count += ord(z[i]) % 10 \n  "], [0.1167392685297368, 0.1276595744680851, 0.24488080895833833, "from collections import defaultdict\ndef max_aggregate(stdata):\n    temp = defaultdict(int)\n    for name, marks in stdata:\n        temp[name] += marks\n    return max(temp.items(), key=lambda x: x[1])\nThe above code is a function to calculate the maximum aggregate from the list of tuples.\n\nimport re\ndef removezero_ip(ip):\n string = re.sub('\\.[0]*', '.', ip)\n return string\n\nThe above code is a function to remove leading zeroes from an ip address.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count swaps which are necessary to convert from str1 to str2.\n\ndef countDiscInversionsGraph(G, weights):\n    inversions = 0\n    for a,t in G.edges():\n        for y,w in G.edge[a][t].items():\n            if weights[a] < weights[y]:\n                inversions += 1\n    return inversions\nThe above codes is a function to count in"], [0.118207599644662, 0.14, 0.2278783412218767, "def len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max\nThe above code is a python function to find the length of the longest word.\n\ndef catalan_number(num):\n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num\nThe above code is a function which returns nth catalan number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function, i.e; to find the minimum number of swaps.\n\ndef count_plu(list1,n) :\n   ctr=0\n   for num in list1 :\n       if num > n : \n          ctr=ctr+1\n   print(ctr)\nThe above code is a peython fuction , i.e; to count the number of elements in the list greater than given values.\ndef str"], [0.11636689494737967, 0.1206896551724138, 0.2891552136950582, "def recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total\nThe above code is a function to flatten a list and sum all of its elements.\n\ndef return_sum(dict):\n  sum = 0\n  for i in dict.values():\n    sum = sum + i\n  return sum\nThe above code is function to find the sum of all items in the given dictionary.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is used to find the minimum swaps required to convert str1 to str2.\nThe first paramters are the input Strings and the second parameter is count for deducting the steps along with print function.\ndef findDigits(n): \n      \n    # Function to calculate sum \n    count = 0\n  \n    # Removing stored value in n  \n    # because any number devided by self is 0 \n    n = n  \n   "], [0.07564988549680217, 0.04838709677419355, 0.0796476755031787, "def max_length(list1):\n    max_length = max(len(x) for x in  list1 )  \n    max_list = max((x) for x in   list1)\n    return(max_length, max_list)\nThe above code is a function to find the list of maximum length in a list of lists.\n\ndef largest_neg(list1): \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max\nThe above code is a python function to find the largest negative number from the given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a check if two strings are 'K' swaps, i.e., differ at exactly 'K/2' characters. The other requirement for two strings to be K swaps is that it shouldn't contain any extra characters, which will result in it being K/2+1 swaps, i.e., not possible. \n\nclass Charactergroup : \n    def __init__(self) : \n        self.letters = []  \n        self.group ="], [0.09690306012043975, 0.1111111111111111, 0.1364015104503068, "from collections import defaultdict\ndef max_occurrences(nums):\n    dict = defaultdict(int)\n    for i in nums:\n        dict[i] += 1\n    result = max(dict.items(), key=lambda x: x[1]) \n    return result[0]\nThe above code is a function to find the item with maximum frequency in a given list.\n\ndef new_tuple(test_list, test_str):\n  return tuple(test_list + [test_str])\nThe above code is a function to create a new tuple from the given string and list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find out minimum swaps necessary for strings to be same.\n\ndef shift_and_convert(pad, round_key) : \n    temp1 = pad[1:] + pad[:1] \n    temp2 = \"\" \n    for i in range(len(temp1)) : \n        x = temp1[i]  \n        temp2 += chr((ord(x) + ord(round_key["], [0.09100787099124732, 0.09090909090909091, 0.0863898895467517, "def check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) \nThe above code is a function to check if all the elements in tuple have same data type or not.\n\ndef harmonic_sum(n):\n  if n < 2:\n    return 1\n  else:\n    return 1 / n + (harmonic_sum(n - 1)) \nThe above code is a function that takes in an integer n and calculates the harmonic sum of n-1.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that will find if the string can be re-arranged or not.\ndef check_string(test_string) : \n    if (test_string == str(test_string)[::-1]) : \n        print(\"Yes\")  \n    else : \n        print(\"No\") \nThe above code is a function to check if the string is plaindrome or not.\ndef check_six(nums):\n "], [0.1356401480966321, 0.1509433962264151, 0.25721483666228184, "def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num \nThe above code is a python function to find the largest number that can be formed with the given list of digits.\n\ndef add_lists(test_list, test_tup):\n  res = tuple(list(test_tup) + test_list)\n  return (res) \nThe above code is a function to append the given list to the given tuples.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count the number of swaps required in the arrangement of alphabet of str1 to str2. If more than two swaps required then the function will return \"Not Possible\"\ndef mail_check(email):\n  lst = list()\n  cnt = 0\n  for e in email:\n    flag = 1\n    for i in range(len(e)):\n      if((e[i] == '@') or (e[i"], [0.1961005814680448, 0.21568627450980393, 0.27184085280079345, "from math import tan, pi\ndef area_polygon(s, l):\n  area = s * (l ** 2) / (4 * tan(pi / s))\n  return area\nThe above code is a function to calculate the area of a regular polygon given the length and number of its sides.\n\ndef power_base_sum(base, power):\n    return sum([int(i) for i in str(pow(base, power))])\nThe above code is a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes 2 strings of lowercase alphabets and print the minimum number of swaps required to convert string 1 to string 2. \n\nThe problem is semantically wrong as the string is of lowercase alphabets in the range [a..z]. This version isn't being accepted.\n'''\n#solution\ndef comm_ch(s1,s2):\n    result = True\n    s1 = list(s1)"], [0.07926384014118394, 0.07142857142857142, 0.10825346009426404, "import heapq as hq\ndef heap_queue_largest(nums,n):\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums\nThe above code is a function to find the n largest integers from a given list of numbers, returned in descending order.\n\nimport heapq\ndef larg_nnum(list1,n):\n largest=heapq.nlargest(n,list1)\n return largest\nThe above code is a function that takes in a list and an integer n and returns a list containing the n largest items from the list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that accepts two strings and determines whether swap inbound string characters to sort the string index and returns the count.\ndef compareTriplets(a, b):\n    res = [0, 0]\n    for i in range(3):\n        if a[i] < b[i]:\n            res[1] += 1\n        elif a[i] > b[i]:\n            res[0] += 1\n    return res\n"], [0.14251497676215513, 0.1875, 0.3093747516167273, "def find_Rotations(str): \n    tmp = str + str\n    n = len(str) \n    for i in range(1,n + 1): \n        substring = tmp[i: i+n] \n        if (str == substring): \n            return i \n    return n \nThe above code is a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\ndef Find_Min(lst): \n    return min(lst, key=len) \nThe above code is a python function to find the sublist having minimum length.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the swap required to change one string to another, if possible.\ndef digit_Difference(s):\n  a = str(s)\n  b = abs(s)\n  a = list(a)\n  b = str(b)\n  b = list(b)\n  return(len(b) - len(a))\nThe above code is to find the different number of digits in an integer and the same"], [0.1355754326122043, 0.14, 0.1805982735024197, "def and_tuples(test_tup1, test_tup2):\n  res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) \nThe above code is a function to extract the elementwise and tuples from the given two tuples.\n\ndef remove_length(test_str, K):\n  temp = test_str.split()\n  res = [ele for ele in temp if len(ele) != K]\n  res = ' '.join(res)\n  return (res) \nThe above code is a function to remove all the words with k length in the given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to return the minimum number of swaps required.\n\n###   HW#1E PyDay-1 ####################################################################################################\n\ndef iss(lst):\n  if lst[0] == 100 :\n\t  return lst\n  else:\n\t  return []\nThe above code is a function to check if the given list starts with 100.\n\n\ndef all_sma(lst):\n    for i in lst:"], [0.21265110203552573, 0.21739130434782608, 0.38675892004686807, "def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False\nThe above code is a python function to check whether the given number can be represented as the difference of two squares or not.\n\ndef odd_num_sum(n) : \n    j = 0\n    sm = 0\n    for i in range(1,n + 1) : \n        j = (2*i-1) \n        sm = sm + (j*j*j*j)   \n    return sm \nThe above code is a python function to find the sum of fourth power of first n odd natural numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to print minimum number of swaps required to convert str1 to str2, both strings are of same length.\n\ndef WiresCost(p) : \n    res = 0\n    i = 0\n    while (i < p) : \n        j = p  \n        while (j > i + 1) :                 \n            j = j - 1 \n            res = res + 1 \n        i = i + 1\n"], [0.17312615132373102, 0.19672131147540983, 0.26428366455277896, "def maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \nThe above code is a function to maximize the given two tuples.\n\ndef test_three_equal(x,y,z):\n  result = set([x,y,z])\n  if len(result)==3:\n    return 0\n  else:\n    return 4-len(result)\nThe above code is a python function to count the number of equal numbers from three given integers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count the minimum number of swaps required for making two strings identical, if one string can be the subsequence of the other string.\n\ndef f1(a ,b) : \n if (a + b < 4) or ( a / b > 3 ):   \n    return False\n return True \nThe above code is a python function to check the given conditions with boolean results True or False.\n\ndef _function(name, check_string"], [0.07472684151910407, 0.14285714285714285, 0.27837240103884014, "def sum_div(number):\n    divisors = [1]\n    for i in range(2, number):\n        if (number % i)==0:\n            divisors.append(i)\n    return sum(divisors)\nThe above code is a function to return the sum of all divisors of a number.\n\ndef unique_product(list_data):\n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p\nThe above code is a python function to calculate the product of the unique numbers in a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a solution to \"Minimum Swaps required for Rearranging characters of a String\" Hackerrank question.\n"], [0.10419837136794605, 0.14285714285714285, 0.2088496022250939, "def empty_dit(list1):\n empty_dit=all(not d for d in list1)\n return empty_dit\nThe above code is a function to check whether all dictionaries in a list are empty or not.\n\ndef diff_even_odd(list1):\n    first_even = next((el for el in list1 if el%2==0),-1)\n    first_odd = next((el for el in list1 if el%2!=0),-1)\n    return (first_even-first_odd)\nThe above code is a function to find the difference of the first even and first odd number of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to tell us whether it is possible to swap the letters in a string to make it \nan anagram of the other string. It defines count as the differnce between the number of letters_to_make_the_other_word \nand a given word. If the count is odd then niether of the words can make the other word's anagram.\nIn the else part it defines the function to return the count only if count is even"], [0.1435033142116598, 0.14814814814814814, 0.29030724471626834, "def odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result\nThe above code is a python function to remove the characters which have odd index values of a given string.\n\ndef rear_extract(test_list):\n  res = [lis[-1] for lis in test_list]\n  return (res) \nThe above code is a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " verifies the number of swaps required to change the string into its permutation\nimport numpy as np \n  \n# Function to print permutations of string \n# This function takes three parameters: \n# 1. String \n# 2. Starting index of the string \n# 3. Ending index of the string. \ndef permutations(s,begin,end):\n    #String length must be greater than 0\n    if begin==end:\n"], [0.0760453330456282, 0.05357142857142857, 0.07321944945686787, "def substract_elements(test_tup1, test_tup2):\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n  return (res) \nThe above code is a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n\ndef Find_Max_Length(lst):  \n    maxLength = max(len(x) for x in lst )\n    return maxLength \nThe above code is a python function to find the length of the longest sublists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that checks if the swaps that occur between strings can be an even number. If it is an even number, the function is returned otherwise, Not Possible is returned.\ndef findTripplet(arr, arr_size) : \n    arr.sort() \n    for i in range(0, (arr_size - 2)) : \n        if (arr[i] > 0) : \n            break\n        if (arr[i"], [0.14698683728414344, 0.19148936170212766, 0.2871484076763709, "def find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) \nThe above code is a function to find number of lists present in the given tuple.\n\ndef pair_xor_Sum(arr,n) : \n    ans = 0 \n    for i in range(0,n) :    \n        for j in range(i + 1,n) :   \n            ans = ans + (arr[i] ^ arr[j])          \n    return ans \nThe above code is a python function to find the sum of xor of all pairs of numbers in the given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum number of swap required to sort an array of characters\nimport math\ndef nextSquare(n) : \n    return (int(math.sqrt(n)) + 1) ** 2 \nThe above code is a python function to find the next Square.\nimport string \nstring.ascii_uppercase\nThe above code is a string of all the uppercase characters.\nimport string \nstring."], [0.08752855642137938, 0.24, 0.26116491142076503, "def multiply_elements(test_tup):\n  res = tuple(i * j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) \nThe above code is a function that takes as input a tuple of numbers (t_1,...,t_{N+1}) and returns a tuple of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\n\ndef max_sum_list(lists):\n return max(lists, key=sum)\nThe above code is a function that returns the list in a list of lists whose sum of elements is the highest.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " returns the minimum of swaps needed to convert a str1 into str2.\n'''"], [0.10999152027182656, 0.13793103448275862, 0.2249997953963374, "def count_occurance(s):\n  count = 0\n  for i in range(len(s) - 2):\n    if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):\n      count = count + 1\n  return count\nThe above code is a function to count the number of occurence of the string 'std' in a given string.\n\ndef swap_numbers(a,b):\n temp = a\n a = b\n b = temp\n return (a,b)\nThe above code is a function that takes in two numbers and returns a tuple with the second number and then the first number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that checks for the minimum number of swapping required to construct a given permutation from another \ngiven permutation. Assume len(str1) is always greater than or equal to that of str2 and their lengths are same.\ndef no_even_digits(num):\n    num = str(num)\n    count = 0\n    for i in num:\n        if int(i)%2 == 0:\n            count += 1\n"], [0.09161020050293275, 0.0784313725490196, 0.06685376083133346, "def babylonian_squareroot(number):\n    if(number == 0):\n        return 0;\n    g = number/2.0;\n    g2 = g + 1;\n    while(g != g2):\n        n = number/ g;\n        g2 = g;\n        g = (g + n)/2;\n    return g;\nThe above code is a function for computing square roots using the babylonian method.\n\ndef sub_list(nums1,nums2):\n  result = map(lambda x, y: x - y, nums1, nums2)\n  return list(result)\nThe above code is a function to subtract two lists element-wise.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check if lengh of the longest commom subsequence is odd or not.\n\nclass Solution:\n    # @return a tuple, (index1, index2)\n    def twoSum(self, num, target):\n        hash_table = {}\n        for i in range(len(num)):\n            if num[i] in hash_table:\n                return (hash_table[num[i]]+1, i"], [0.14020215293547078, 0.1836734693877551, 0.2755014887970034, "def is_Monotonic(A): \n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) \nThe above code is a python function to check whether the given array is monotonic or not.\n\ndef union_elements(test_tup1, test_tup2):\n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) \nThe above code is a function to find the union of the elements of two given tuples and output them in sorted order.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps required to convert a word to another. If there are multiple vowels, the first one is to be replaced.\n\ndef find_smallest_equal(list1, list2) : \n    length = len(list2) \n    min = len(list1); \n    for i in range(length - 1, 0, -1) : \n        for j in range(i - 1, -"], [0.21988865655974832, 0.2222222222222222, 0.10411365487195959, "import re\ndef find_char_long(text):\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))\nThe above code is a function to find all words which are at least 4 characters long in a string.\n\ndef find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num \nThe above code is a python function to find the largest number that can be formed with the given list of digits.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program to calculate the minimum number of swaps required to make two strings anagram.\n\n\ndef leet(str) : \n    str = str.replace(\"A\",\"4\") \n    str = str.replace(\"E\",\"3\") \n    str = str.replace(\"G\",\"6\") \n    str = str.replace(\"I\",\"1\") \n    str = str.replace(\"O\",\"0\") \n    str = str"], [0.11296021101667382, 0.13725490196078433, 0.17851306309512358, "def is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True\nThe above code is a function to check whether the given number is undulating or not.\n\nimport heapq\ndef larg_nnum(list1,n):\n largest=heapq.nlargest(n,list1)\n return largest\nThe above code is a function that takes in a list and an integer n and returns a list containing the n largest items from the list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in two strings and returns the number of swap operations needed to convert one into the other.\ndef moves_cnt(n): \n    ans = 0\n    for i in range(1, n + 1): \n        ans += str(i).count('3') + str(i).count('6') \n                   + str(i).count('9') \n                  \n    return ans \nThe above code is a"], [0.12510816283800194, 0.1590909090909091, 0.23215274157214374, "def count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) \nThe above code is a function to find the number of elements that occurs before the tuple element in the given tuple.\n\ndef left_rotate(n,d):   \n    INT_BITS = 32\n    return (n << d)|(n >> (INT_BITS - d))  \nThe above code is a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find minimum swaps to convert a string to another string.\ndef display_pattern(n): \n  \n    for i in range(1,n + 1): \n        print(\" \")\n        for j in range(i,n): \n            print(\"*\", end =\" \") \n        for k in range(0,i): \n            print(\"*\", end = \" \")\nThe above code is a"], [0.09730291163251488, 0.10638297872340426, 0.07514019747384952, "import re\ndef text_match_two_three(text):\n        patterns = 'ab{2,3}'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\nThe above code is a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n\ndef find(n,m):  \n    q = n//m \n    return (q)\nThe above code is a python function to find quotient of two numbers (rounded down to the nearest integer).\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the no of swaps when two strings are rotated anti or clock wise the same.\n\nclass Student() : \n    def __init__(self,firstname,lastname) : \n        self.firstname = firstname\n        self.lastname = lastname\ndef display(students) : \n    print(f\"original list : \\n{students}\") \ndef add(students,name,num"], [0.16067835669944025, 0.14583333333333334, 0.21943654466287393, "def string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst\nThe above code is a function to convert a string to a list of strings split on the space character.\n\ndef extract_singly(test_list):\n  res = []\n  temp = set()\n  for inner in test_list:\n    for ele in inner:\n      if not ele in temp:\n        temp.add(ele)\n        res.append(ele)\n  return (res) \nThe above code is a function to flatten the list of lists into a single set of numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the number of swaps required to make str1 and str2 same string.\nfrom itertools import permutations\nsol = []\nfor i in permutations(\"0123456789\",10):\n    sol += [\"\".join(i)]\nans = 0\nfor i in sol:\n    for j in range(len(S)-N+1):\n        f = i[:N]\n        of = S[j:"], [0.14537917864444416, 0.13953488372093023, 0.15043549909627102, "def search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)\nThe above code is a python function to find the element that appears only once in a sorted array.\n\ndef count_element_in_list(list1, x): \n    ctr = 0\n    for i in range(len(list1)): \n        if x in list1[i]: \n            ctr+= 1          \n    return ctr\nThe above code is a function to count the number of sublists containing a particular element.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that counts the minimum number of swaps for a pair of strings.\ndef super_seven(x):\n\tb=0\n\twhile x>=7:\n\t\tb+=int(x/7)\n\t\tx=x%7*10+x%7\n\treturn int(x)\nprint(\"enter the number :\") \nb = int(input())\nsuper_seven(b)\nThe above code is a function"], [0.16956677044324184, 0.15384615384615385, 0.15857418529216746, "def check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\nThe above code is a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n\nimport heapq\ndef expensive_items(items,n):\n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items\nThe above code is a function to find the n most expensive items in a given dataset.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate the minimum number of swaps required to sort strings.\n    \ndef check_list(list):\n  check=all(l==0 or l==1 or l==2 or l==3 or l==4 or l==5 or l==6 or l==7 or l==8 or l==9 for l in list)\n  return check\nThe above code is a function to check if all items in the list are in the range ["], [0.09876203077610762, 0.12903225806451613, 0.1176255032071151, "import math\ndef is_not_prime(n):\n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result\nThe above code is a python function to identify non-prime numbers.\n\ndef maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \nThe above code is a function to maximize the given two tuples.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to separate the vowels and consonants from the given string and print them using 2D matrix.\n"], [0.3171443873322873, 0.2727272727272727, 0.4507377252282957, "def subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks\nThe above code is a function to sort a list of tuples using the second value of each tuple.\n\ndef string_to_tuple(str1):\n    result = tuple(x for x in str1 if not x.isspace()) \n    return result\nThe above code is a function to convert a given string to a tuple of characters.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the number of swaps required to convert a string to another string. If the strings cannot be converted, then it should return -1.\n"], [0.12478698931673442, 0.14814814814814814, 0.1816439198454629, "def replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n\nThe above code is a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n\ndef check_smaller(test_tup1, test_tup2):\n  return all(x > y for x, y in zip(test_tup1, test_tup2))\nThe above code is a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that returns the minimum number of swaps \ncould have been made in the permutation of two strings, if each occurrence of the same \nletter was swapped for its adjacent occurrence.\nWrite a function to calculate gcd of given two numbers.\ndef greatest_common_divisor(n1,n2) : \n    if n2 == 0 : \n        return n1 \n    if n1 == 0 : \n        return n"], [0.13961895404421457, 0.15384615384615385, 0.20642647894209065, "def extract_singly(test_list):\n  res = []\n  temp = set()\n  for inner in test_list:\n    for ele in inner:\n      if not ele in temp:\n        temp.add(ele)\n        res.append(ele)\n  return (res) \nThe above code is a function to flatten the list of lists into a single set of numbers.\n\ndef is_Even(n) : \n    if (n^1 == n+1) :\n        return True; \n    else :\n        return False; \nThe above code is a python function to check whether the given number is even or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check how many swaps would be made to convert one string another,\nif allowed alphabet conversion.\n\ndef tribonacci(n):\n    t0, t1, t2 = 0, 0, 1\n    if n == 0:\n        return t0\n    elif n == 1:\n        return t1\n    elif n == 2:\n        return t2\n    else:\n        for i in range(n"], [0.07580086222204419, 0.03636363636363636, 0.05901304786252847, "def common_in_nested_lists(nestedlist):\n    result = list(set.intersection(*map(set, nestedlist)))\n    return result\nThe above code is a function to find the common elements in given nested lists.\n\ndef find_sum(arr): \n    arr.sort() \n    sum = arr[0] \n    for i in range(len(arr)-1): \n        if (arr[i] != arr[i+1]): \n            sum = sum + arr[i+1]   \n    return sum\nThe above code is a python function to find the sum of non-repeated elements in a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is the Python Implementation to find that given two strings are only replaced by single character if yes print the count else print \u201cNo\u201d.\ndef two_strings(str1,str2) : \n    str11 = Counter(str1)  \n    str22 = Counter(str2)  \n    if(str11&str22):\n        print(\"yes\") \n    else:\n        print(\"No\")  \nThe above code can also"], [0.1881878109645354, 0.16129032258064516, 0.28176695403690843, "def all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False\nThe above code is a python function to check whether all the bits are unset in the given range or not.\n\ndef digit_distance_nums(n1, n2):\n         return sum(map(int,str(abs(n1-n2))))\nThe above code is a python function to find the sum of the per-digit difference between two integers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find whether two string can be simlified by swapping on of their characters or not and finally printing the minimum number of swaps required to do so. This is written for completely O(1) in space complexity.\n\n\ndef CheckIfTwoListsAreSimilar(List1, List2, n, m) : \n    pos1 = 0\n    pos2 = n - 1\n    pos3 = m - 1\n    flag = 1\n"], [0.18513511424980508, 0.1774193548387097, 0.31014422644176176, "def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False\nThe above code is a python function to check whether the given number can be represented as the difference of two squares or not.\n\ndef swap_List(newList): \n    size = len(newList) \n    temp = newList[0] \n    newList[0] = newList[size - 1] \n    newList[size - 1] = temp   \n    return newList \nThe above code is a python function to interchange the first and last element in a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to calculate the number of swaps required to convert a string into a given another string.\nSample Input :\n3\nag // a = c\naxe // a = xe\nhello // lo = ol\nSample Output :\n2\n1\n\"Not possible\"\nThe language choices I provided are as follows \u2212\n\npython\nc\njava\nphp\nawk\njavascript\nThe script repository can be found at https://github.com/jeet-"], [0.11756978410554096, 0.1875, 0.17720190645291178, "import heapq\ndef larg_nnum(list1,n):\n largest=heapq.nlargest(n,list1)\n return largest\nThe above code is a function that takes in a list and an integer n and returns a list containing the n largest items from the list.\n\ndef count_element_in_list(list1, x): \n    ctr = 0\n    for i in range(len(list1)): \n        if x in list1[i]: \n            ctr+= 1          \n    return ctr\nThe above code is a function to count the number of sublists containing a particular element.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to determine the minimum swaps of the given input strings so that str1 and str2 are equal.\n\n'''"], [0.11723703381227757, 0.13953488372093023, 0.1018120303587694, "def tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result\nThe above code is a function to convert a given tuple of positive integers into a single integer.\n\ndef find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count\nThe above code is a function that counts the number of pairs of integers in a list that xor to an even number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is the function to count the minimum swaps required for making two strings anagram.\ndef bubble_sort(start,end,num_list) : \n    for i in range (start,end) : \n        for j in range (start,end - i) : \n            if(num_list[j] > num_list[j+1]) : \n                num_list[j] , num_list[j+1] ="], [0.08049892654555002, 0.05, 0.053913923593940906, "def check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res \nThe above code is a function to check if given tuple contains no duplicates.\n\nfrom itertools import groupby\ndef pack_consecutive_duplicates(list1):\n    return [list(group) for key, group in groupby(list1)]\nThe above code is a function to pack consecutive duplicates of a given list elements into sublists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " counts the number of considerations required if str1 is achieved through an arrangement of str2: for example str1 can be arhcieved through str2 by either 2 or 4 arrangements, but if str2 was instead aahieved from str2 by 3 arrangements then it cannot be done.\"\"\"\n\ndef check_distinct(t):\n    if len(t)==len(set(t)): return True\n    else: return False\n\ndef pack_list"], [0.1697904126857932, 0.14893617021276595, 0.13323035922926996, "def check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\nThe above code is a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n\ndef sum_div(number):\n    divisors = [1]\n    for i in range(2, number):\n        if (number % i)==0:\n            divisors.append(i)\n    return sum(divisors)\nThe above code is a function to return the sum of all divisors of a number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " takes in 2 strings and returns the minimum number of swaps required to get a lexicographically sorted string.\ndef max_index(strList) :\n    index = 0\n    flag = False\n    for i in range((len(strList))-1) :\n        if min(strList) <= (strList[i]) :\n            index = i\n            flag = True\n        if flag == False :\n            return index \n    return index"], [0.12072174246389188, 0.1276595744680851, 0.10057003538546919, "def set_left_most_unset_bit(n): \n    if not (n & (n + 1)): \n        return n \n    pos, temp, count = 0, n, 0 \n    while temp: \n        if not (temp & 1): \n            pos = count      \n        count += 1; temp>>=1\n    return (n | (1 << (pos))) \nThe above code is a python function to set the left most unset bit.\n\ndef minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b \nThe above code is a python function to find the minimum of two numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to swap the two different characters of two strings (which are same) except one character\ndef two_array(arr1,n) :   \n    sum_arr1 = [] \n    final = [] \n    for var1 in range(n) : \n        start = arr1[var1] \n        for var2 in range(n) : \n            val1 = var1 + 1\n            start = start +"], [0.15726813970788953, 0.20408163265306123, 0.27096302135874956, "from collections import Counter \ndef check_occurences(test_list):\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\n  return  (res) \nThe above code is a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n\ndef cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums\nThe above code is a function to find cubes of individual elements in a list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps required so that the string after swap must be the same as that of the string input by the user.\n\n1. Python function to find the intersection of two sorted list\n\nlst1=[]\nlst2=[]\nn1=int(input(\"Enter number of elements for list1: \"))\nfor i in range(0,n1):\n    ele1=int(input())\n    l"], [0.09785425950024866, 0.125, 0.1867515021266989, "def count_occurance(s):\n  count = 0\n  for i in range(len(s) - 2):\n    if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):\n      count = count + 1\n  return count\nThe above code is a function to count the number of occurence of the string 'std' in a given string.\n\nimport math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN \nThe above code is a python function to find the next perfect square greater than a given number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is the python function to check the minimum swaps that converts str1 to str2.\n\ndef Second_Smallest(l) :\n    #start writing your code here\n    a = 0\n    b = 0\n    while a in l :\n        while b in l :\n            if a != b :\n                b = b + 1\n            else :\n                b = b - 1\n            a = a + 1\n    return b #expected value"], [0.12881208732659521, 0.13953488372093023, 0.20310568448190408, "def sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))\nThe above code is a function to find the nth number in the newman conway sequence.\n\ndef split_two_parts(list1, L):\n    return list1[:L], list1[L:]\nThe above code is a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to compare two strings for similarity, and to find the number of swaps needed to make the strings similar.\n\ndef min_Bracket_reversal(str1):\n    stack = []\n    for i in str1:\n        if(i=='{'):\n            stack.append(i)\n        elif(i=='}'):\n            if(len(stack)==0):\n                stack.append(i"], [0.146229930631307, 0.125, 0.20018143109797665, "def volume_cube(l):\n  volume = l * l * l\n  return volume\nThe above code is a function to find the volume of a cube given its side length.\n\ndef bell_Number(n): \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1] \n    return bell[n][0] \nThe above code is a python function to find nth bell number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find min swap required to convert str1 into str2\ndef strings_Anagrams(s1,s2) : \n    s1 = s1.replace(\" \",\"\").lower()\n    s2 = s2.replace(\" \",\"\").lower()\n    #The code above is used to remove the spaces and then convert the strings to lowercase.\n    s2 = list(s2)\n    output = 0\n\n"], [0.19273465341838697, 0.18181818181818182, 0.09901417010981076, "def overlapping(list1,list2):  \n    for i in range(len(list1)): \n        for j in range(len(list2)): \n            if(list1[i]==list2[j]): \n                return True\n    return False\nThe above code is a python function to check whether any value in a sequence exists in a sequence or not.\n\ndef odd_position(nums):\n\treturn all(nums[i]%2==i%2 for i in range(len(nums)))\nThe above code is a python function to check whether every odd index contains odd numbers of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function which returns the minimum number of swaps required with same character\ndef three_non_repeating(str1) :  \n    res = [] \n    hash = {} \n    for i in range(len(str1)) :    \n        if ord(str1[i]) in hash : \n            hash[ord(str1[i])] += 1 \n        else : \n            hash[ord(str1[i"], [0.11442681180778128, 0.1509433962264151, 0.23259286639339655, "def common_in_nested_lists(nestedlist):\n    result = list(set.intersection(*map(set, nestedlist)))\n    return result\nThe above code is a function to find the common elements in given nested lists.\n\nfrom array import array\ndef zero_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x == 0:\n            n1 += 1\n        else:\n          None\n    return n1/(n-n1)\nThe above code is a function to find the ratio of zeroes to non-zeroes in an array of integers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps required to lexographically sort.\n\ndef pascal(n):\n    for row in range(1, n + 1):\n        C = 1\n        for i in range(1, row + 1):\n            print(C, end=' ')\n            C = int(C * (row - i) / i)\n        print(\"\\n\")\nThe above code prints a given number of rows of a p"], [0.13424028939387864, 0.1590909090909091, 0.19107529764696488, "def long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t\nThe above code is a function to find words that are longer than n characters from a given list of words.\n\ndef add_pairwise(test_tup):\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) \nThe above code is a function to find the pairwise addition of the neighboring elements of the given tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps to make the two strings anagram.\n\ndef is_Sublist(l, s) : \n    sub_set = False\n    if s == []:\n        sub_set = True  \n    elif s == l: \n        sub_set = True\n    elif len(s) > len(l): \n        sub_set = False\n    else :  \n        for"], [0.13111936166176727, 0.0975609756097561, 0.06887789267375917, "def insert_element(list,element):\n list = [v for elt in list for v in (element, elt)]\n return list\nThe above code is a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n\ndef trim_tuple(test_list, K):\n  res = []\n  for ele in test_list:\n    N = len(ele)\n    res.append(tuple(list(ele)[K: N - K]))\n  return (str(res)) \nThe above code is a function to trim each tuple by k in the given tuple list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " returns minimum number of swaps if possible with the given strings.\ndef square_matrix(K):\n  \n  sq_matrix = [[ ]]*N\n  for i in range(N) :\n    sq_matrix[i] = list(map(int,input().split()))\n  for i in range(N) :\n    for j in range(N) :\n      if sq_matrix[i][j] =="], [0.17667186222178144, 0.17142857142857143, 0.15895992264150915, "import math\ndef volume_cone(r,h):\n  volume = (1.0/3) * math.pi * r * r * h\n  return volume\nThe above code is a function to find the volume of a cone.\n\ndef count_Pairs(arr,n): \n    cnt = 0; \n    for i in range(n): \n        for j in range(i + 1,n): \n            if (arr[i] != arr[j]): \n                cnt += 1; \n    return cnt; \nThe above code is a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that returns the minimum number of swaps required, if two strings are permutations of each other. If not, it returns \u201cnot possible.\u201d\n"], [0.16025944044753643, 0.1875, 0.2923597213492571, "from array import array\ndef zero_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x == 0:\n            n1 += 1\n        else:\n          None\n    return n1/(n-n1)\nThe above code is a function to find the ratio of zeroes to non-zeroes in an array of integers.\n\ndef remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result\nThe above code is a function to remove all elements from a given list present in another list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find number of swaps it would take to have all elements in an array equal by sorting.\n"], [0.0763179591908933, 0.04081632653061224, 0.13109568601311947, "def lateralsuface_cylinder(r,h):\n  lateralsurface= 2*3.1415*r*h\n  return lateralsurface\nThe above code is a function to find the lateral surface area of a cylinder.\n\ndef set_left_most_unset_bit(n): \n    if not (n & (n + 1)): \n        return n \n    pos, temp, count = 0, n, 0 \n    while temp: \n        if not (temp & 1): \n            pos = count      \n        count += 1; temp>>=1\n    return (n | (1 << (pos))) \nThe above code is a python function to set the left most unset bit.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " the answer to the minimum swaps.\n\ndef matrix_rotation(m, n, r, a) : \n    c = n - 1; \n    b = 0 \n  \n    while (b < c) : \n        for i in range(r) : \n            top = a[b][b]  \n            right = a[b][c]  \n            bottom = a[c][c]   \n            left"], [0.09809249528776517, 0.1282051282051282, 0.12943048003123125, "def multiply_num(numbers):  \n    total = 1\n    for x in numbers:\n        total *= x  \n    return total/len(numbers) \nThe above code is a function to multiply all the numbers in a list and divide with the length of the list.\n\ndef concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) \nThe above code is a function to concatenate each element of tuple by the delimiter.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check either the number of Swap's of anagram or not.\ndef string_binary(a,b) : \n    bin_a = bin(int(a[ : : 2] , 16)).replace(\"0b\", \"\") \n    bin_b = bin(int(b[ : : 2] , 16)).replace(\"0b\", \"\") \n    bin_a , bin_b = len(bin_a)"], [0.118207599644662, 0.1590909090909091, 0.2306996660351088, "def check_monthnumb_number(monthnum2):\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\n    return True\n  else:\n    return False\nThe above code is a function to check whether the given month number contains 31 days or not.\n\nfrom collections import Counter\ndef sort_counter(dict1):\n x = Counter(dict1)\n sort_counter=x.most_common()\n return sort_counter\nThe above code is a function to sort a dictionary by value.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check number of swaps that are required to get same string.\n\ndef check(p) :\n  if p in range(24,251) :\n    return True\n  else :\n    return False\n  The above code is a function to check validity of age.   \n\ndef get_string(y):\n  if len(y) in range(3,20):\n    return True\n  else :\n    return False\n"], [0.13076194470399297, 0.13333333333333333, 0.23238972348296139, "def common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result\nThe above code is a function that takes two lists and returns true if they have at least one common element.\n\ndef odd_position(nums):\n\treturn all(nums[i]%2==i%2 for i in range(len(nums)))\nThe above code is a python function to check whether every odd index contains odd numbers of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is python function to find the max #swaps required to convert str1 to str2.\ndef max_score(card_points, k):\n    if k >= len(card_points):\n        return sum(card_points)\n    return max(sum(card_points[i:i+k]) for i in range(len(card_points)-k+1))\nThe above code is python function to find the maximum sum of k cards in"], [0.14240172527267198, 0.125, 0.16579070476526653, "def Find_Max_Length(lst):  \n    maxLength = max(len(x) for x in lst )\n    return maxLength \nThe above code is a python function to find the length of the longest sublists.\n\ndef tuple_to_dict(test_tup):\n  res = dict(test_tup[idx : idx + 2] for idx in range(0, len(test_tup), 2))\n  return (res) \nThe above code is a function to convert the given tuple to a key-value dictionary using adjacent elements. https://www.geeksforgeeks.org/python-convert-tuple-to-adjacent-pair-dictionary/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " would find the number of swaps required to make two strings same.\nS = input(\"Enter a letter : \") \nif S in ('a', 'e', 'i', 'o', 'u') : \n    print(\"%c is a vowel.\" %S) \nelse : \n    print(\"%c is a consonant.\" %S)\n \nFor scope of the variable we have a keyword called as global, which says that the value"], [0.137504531962649, 0.10714285714285714, 0.0965635500906463, "def decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") \nThe above code is a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n\ndef substract_elements(test_tup1, test_tup2):\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n  return (res) \nThe above code is a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " returns the minimum number of swaps required if the two strings are formed by interchanging the two characters in an alphabetical order that is given. \ndef factorial(n) : \n    if n == 0: \n        return 1\n    elif n < 0: \n        return (\"NA\") \n    else: \n        return n * factorial(n-1) \nThe above code returns the the factorial of a non negative number."], [0.18045445170236252, 0.2, 0.2523601109729773, "import math\ndef is_not_prime(n):\n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result\nThe above code is a python function to identify non-prime numbers.\n\ndef swap_List(newList): \n    size = len(newList) \n    temp = newList[0] \n    newList[0] = newList[size - 1] \n    newList[size - 1] = temp  \n    return newList \nThe above code is a python function to interchange the first and last elements in a list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function that returns the minimum number of characters to be replaced in both strings to make them identical.\nstr1,str2 = input().split()\nprint(min_Swaps(str1,str2))\n"], [0.13868120665716832, 0.13725490196078433, 0.11461178191473709, "def common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result\nThe above code is a function that takes two lists and returns true if they have at least one common element.\n\ndef even_position(nums):\n\treturn all(nums[i]%2==i%2 for i in range(len(nums)))\nThe above code is a python function to check whether every even index contains even numbers of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function that checks if the number of swaps required is even or odd.\n\n#----------------------------------------#\n\n#----------------------------------------#\n\n\n#----------------------------------------#\nProblem 3\n\n* [Algorithms - Warm Up - Plus Minus](https://www.hackerrank.com/challenges/plus-minus/problem)\nGiven an array of integers, calculate the fractions of its elements that are positive, negative, and are zeros. Print the decimal"], [0.2848346573273417, 0.3076923076923077, 0.3756124201892256, "def find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False\nThe above code is a function to check if a string is present as a substring in a given list of string values.\n\ndef prime_num(num):\n  if num >=1:\n   for i in range(2, num//2):\n     if (num % i) == 0:\n                return False\n     else:\n                return True\n  else:\n          return False\nThe above code is a function to check if the given integer is a prime number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check if the number of swaps required to get a string is odd or even.\n"], [0.1804987040362325, 0.1836734693877551, 0.3466741797533459, "def sum(a,b): \n    sum = 0\n    for i in range (1,min(a,b)): \n        if (a % i == 0 and b % i == 0): \n            sum += i \n    return sum\nThe above code is a python function to find the sum of common divisors of two given numbers.\n\ndef sum_odd(n): \n    terms = (n + 1)//2\n    sum1 = terms * terms \n    return sum1  \ndef sum_in_range(l,r): \n    return sum_odd(r) - sum_odd(l - 1)\nThe above code is a python function to find the sum of all odd natural numbers within the range l and r.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find minimum swaps required to convert str1 to str2 by swapping adjacent characters.\n\ndef DecimalBinary(n) : \n    if (n > 1) : \n        DecimalBinary(n // 2) \n    print(n % 2, end = '') \nif __name__ == '__main__' :  \n    n = int(input(\"Enter a number \")) \n    time."], [0.12114854517593632, 0.11320754716981132, 0.09173559390543806, "def word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False\nThe above code is a python function to check whether the length of the word is odd or not.\n\ndef check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\nThe above code is a function that takes in a list and element and checks whether all items in the list are equal to the given element.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in two strings and returns the minimum number of swaps -\n\nmatch = difflib.SequenceMatcher()\nmatch.set_seqs(prac,prac2)\nprint(match.ratio())\n\n#The ratio() method returns an entire sequence matcher object instead of just a single number.\n#The internal difference method inside the sequence matcher gives the actual difference between the strings.\n\n#hamming_distance('"], [0.1135642185798075, 0.16363636363636364, 0.19718272426059535, "def median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median\nThe above code is a function to find the median length of a trapezium.\n\ndef count_Pairs(arr,n): \n    cnt = 0; \n    for i in range(n): \n        for j in range(i + 1,n): \n            if (arr[i] != arr[j]): \n                cnt += 1; \n    return cnt; \nThe above code is a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function which takes strings as input and checks whether it is possible to convert a string into another string by swapping \u2018n\u2019 pairs of characters in the first string.\n'''\n\n# Write your code here\n\nimport math\ndef volume_Cylinder(radius,height) : \n    Volume = (round(math.pi*(radius**2)*height,2))\n    return Volume\nThe above code is a python function which takes"], [0.14935182293205596, 0.14545454545454545, 0.22154512736806636, "import math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN \nThe above code is a python function to find the next perfect square greater than a given number.\n\ndef find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False\nThe above code is a python function to find whether the parity of a given number is odd.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum no. of swaps required to make two strings identical.\ndef mailAddress(name, address): \n    return (name + \"\\n\" + address) \nThe above code is a python function to find the mail address of a particular person by putting their name and address.\ndef Max(a,b,c) : \n    if ( a > b and a > c) : \n        Max= a \n"], [0.08968021596231712, 0.0625, 0.039490353308101224, "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \nThe above code is a python function to find the length of the smallest list in a list of lists.\n\ndef sample_nam(sample_names):\n  sample_names=list(filter(lambda el:el[0].isupper() and el[1:].islower(),sample_names))\n  return len(''.join(sample_names))\nThe above code is a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check if swap is even or odd for a given two strings\ndef recurs(arr,i):\n    if i ==0:\n        return arr,i\n    else:\n        arr[i],arr[i-1]=arr[i-1],arr[i]\n        return recurs(arr,i-1)\nThe above code is a funtion switching numbers between arr\ndef recurs(tree, depth):\n\t"], [0.23269507713880752, 0.24444444444444444, 0.32016791097155217, "def find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False\nThe above code is a python function to find whether the parity of a given number is odd.\n\ndef average_tuple(nums):\n    result = [sum(x) / len(x) for x in zip(*nums)]\n    return result\nThe above code is a function which takes a tuple of tuples and returns the average value for each tuple as a list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function that returns the minimum number of swaps required to convert a given string to another given string.\n\ndef peak_to_peak(dataset):\n    return dataset.max() - dataset.min()\nThe above code is a python function that returns peak to peak.\n\nclass TupStat : \n    def __init__(self) :  \n        self.tup = [] \n  \n    def Push(self, item)"], [0.20610938393232428, 0.32, 0.4857247734701592, "def count_occurance(s):\n  count = 0\n  for i in range(len(s) - 2):\n    if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):\n      count = count + 1\n  return count\nThe above code is a function to count the number of occurence of the string 'std' in a given string.\n\ndef all_Characters_Same(s) :\n    n = len(s)\n    for i in range(1,n) :\n        if s[i] != s[0] :\n            return False\n    return True\nThe above code is a python function to check whether all the characters are same or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is implemented to determine the minimum count of swaps required to change one string to other string.\n"], [0.11763370843891982, 0.10714285714285714, 0.14579260667677876, "import re\ndef remove_whitespaces(text1):\n  return (re.sub(r'\\s+', '',text1))\nThe above code is a function to remove all whitespaces from the given string.\n\ndef bell_Number(n): \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1] \n    return bell[n][0] \nThe above code is a python function to find nth bell number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a Python3 code to find the minimum number of swaps made to make two strings identical.\n\ndef unid(text) : \n    a = text[0] \n    i = 0\n    for b in text : \n        if a != b : \n            i += 1\n    return text.count(text[0]) == len(text) \nThe above code is a given code in C programming on unid. It is used"], [0.22414043331324351, 0.18421052631578946, 0.20336828481651043, "def lateralsurface_cube(l):\n  LSA = 4 * (l * l)\n  return LSA\nThe above code is a function to find the lateral surface area of a cube given its side length.\n\ndef bell_Number(n): \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1] \n    return bell[n][0] \nThe above code is a python function to find nth bell number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to count the total swaps required  to make the strings equal.\ndef Division(a,b) :\n    c=a*b\n    if c%2==0:\n        c=c/2\n        if c%3==0:\n            c=c/3\n            if c%5==0:\n                c=c/5\n    if c==1:\n        return(\"y\")\n    return(\"N"], [0.08004850074485374, 0.10204081632653061, 0.05295804438443096, "def check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\nThe above code is a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n\ndef concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) \nThe above code is a function to concatenate each element of tuple by the delimiter.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes inputs string str1, str2 and returns the minimum swa from str1 to str2 or returns Not Possible if not possible.\ndef vowelChecker (inputChar) : \n    if (inputChar == \"a\" or inputChar == \"A\" or\n                inputChar == \"e\" or inputChar == \"E\" or  \n                inputChar == \"i\" or inputChar == \"I\" or\n                inputChar =="], [0.0895461647686601, 0.1111111111111111, 0.11610826911459773, "def rear_extract(test_list):\n  res = [lis[-1] for lis in test_list]\n  return (res) \nThe above code is a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n\ndef combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result\nThe above code is a function to find all possible combinations of the elements of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in two 'E' -even length strings and returns the minimum number for swapping two characters in the strings that deem them to be anagrams of each other.\ndef getArray(string1,string2) :\n    freq_table1 = [0] * 256\n    freq_table2 = [0] * 256\n    if(len(string1) != len(string2)):\n        return 0\n    else"], [0.27779178349055533, 0.20930232558139536, 0.18649653364639132, "import math\ndef wind_chill(v,t):\n windchill = 13.12 + 0.6215*t -  11.37*math.pow(v, 0.16) + 0.3965*t*math.pow(v, 0.16)\n return int(round(windchill, 0))\nThe above code is a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\ndef first_odd(nums):\n  first_odd = next((el for el in nums if el%2!=0),-1)\n  return first_odd\nThe above code is a python function to find the first odd number in a given list of numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to calculate the minimum number of swaps required to make two strings equals.\n\nimport math \ndef comp(arr):\n  res=0 \n  \n  for i in range(len(arr)):\n    pr=math.sqrt(arr[i])\n  \n    least=int(arr[0])\n    if arr[i] < least : \n      continue\n      least=int(arr[i])\n"], [0.27418441164089546, 0.2564102564102564, 0.20477702057233968, "def recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total\nThe above code is a function to flatten a list and sum all of its elements.\n\ndef triangle_area(r) :  \n    if r < 0 : \n        return None\n    return r * r \nThe above code is a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program which implements the min number of swaps required to convert one string into the other.\ndef add(list):\n    sum = 0\n    for x in list:\n        sum += sum(x)\n    return sum\nprint(add([15,12,3,14,10]))\n\n"], [0.17200319339392758, 0.3333333333333333, 0.32499527094175984, "def odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result\nThe above code is a python function to remove the characters which have odd index values of a given string.\n\ndef count_element_in_list(list1, x): \n    ctr = 0\n    for i in range(len(list1)): \n        if x in list1[i]: \n            ctr+= 1          \n    return ctr\nThe above code is a function to count the number of sublists containing a particular element.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to calculate minimum swaps required in Swapping of two strings.\n\n"], [0.11175630377717596, 0.125, 0.14766227562363018, "def tuple_to_dict(test_tup):\n  res = dict(test_tup[idx : idx + 2] for idx in range(0, len(test_tup), 2))\n  return (res) \nThe above code is a function to convert the given tuple to a key-value dictionary using adjacent elements. https://www.geeksforgeeks.org/python-convert-tuple-to-adjacent-pair-dictionary/\n\ndef first_odd(nums):\n  first_odd = next((el for el in nums if el%2!=0),-1)\n  return first_odd\nThe above code is a python function to find the first odd number in a given list of numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum swaps (can be even or odd) required to get the string str2 from str1 using the following operations : \nSwap i and i+1 indices till either all the characters match or max swaps are reached.\nSuch a sequence is called a beautiful sequence. \nGiven two strings str1 and str2, find if str2 is beautiful sequence or not if it is possible to make str2 a beautiful sequence pattern.\nThe program"], [0.13247796517116484, 0.1724137931034483, 0.24316063086730938, "def search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)\nThe above code is a python function to find the element that appears only once in a sorted array.\n\ndef all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False\nThe above code is a python function to check whether all the bits are unset in the given range or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check the number of times a string can be converted to palindrome by swapping only two character. If the count of swaps is even, print (count // 2) else print \"Not Possible\".\ndef rotate(arr) :\n    positive = sum(arr)\n    negative = sum(list(map(lambda x : x * -1,arr)))\n    return (negative * -1) + positive\n\n# With only one smaple"], [0.0917193960816832, 0.16666666666666666, 0.16715506858188878, "def is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False\nThe above code is a function to check if the given number is woodball or not.\n\ndef all_Characters_Same(s) :\n    n = len(s)\n    for i in range(1,n) :\n        if s[i] != s[0] :\n            return False\n    return True\nThe above code is a python function to check whether all the characters are same or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function is to find the minimum swaps of two given strings.\ndef moveZero(num_list) :\n\tn = len(num_list) \n\tcount = 0\n\tfor i in range(n) : \n\t\tif num_list[i] != 0 : \n\t\t\tnum_list[count] = num_list[i] \n\t\t\tcount+=1\n\twhile count < n : \n"], [0.16152299188434702, 0.16666666666666666, 0.21024171250137938, "def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False\nThe above code is a python function to check whether the given number can be represented as the difference of two squares or not.\n\ndef find_Odd_Pair(A,N) : \n    oddPair = 0\n    for i in range(0,N) :  \n        for j in range(i+1,N) :  \n            if ((A[i] ^ A[j]) % 2 != 0):  \n                oddPair+=1  \n    return oddPair  \nThe above code is a python function to count the number of pairs whose xor value is odd.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum no. of swaps required to form str1 by the kth letter of str2 \n\ndef paintWizard(hours,peopleAvail) : \n    resources = 0 \n    sum = 0 \n    avg = hours / peopleAvail \n    while (1) :\n        add = avg \n        d = avg\n        isFind = False\n        while (d >= 1) : \n           "], [0.1526644663652725, 0.3076923076923077, 0.4314770773034207, "def index_multiplication(test_tup1, test_tup2):\n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \nThe above code is a function to perform index wise multiplication of tuple elements in the given two tuples.\n\ndef sum_list(lst1,lst2):\n  res_list = [lst1[i] + lst2[i] for i in range(len(lst1))] \n  return res_list\nThe above code is a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a funtion to find count of minimum no. of swaps that required to transform first string to second\n"], [0.1653523030145529, 0.17391304347826086, 0.21339524101645627, "def add_nested_tuples(test_tup1, test_tup2):\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \nThe above code is a function to perform index wise addition of tuple elements in the given two nested tuples.\n\ndef tuple_str_int(test_str):\n  res = tuple(int(num) for num in test_str.replace('(', '').replace(')', '').replace('...', '').split(', '))\n  return (res) \nThe above code is a function to convert tuple string to integer tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to print minimum no of swaps required to convert str1 to str2.\n\ndef Fizz_Buzz(num):\n  if num % 3 == 0 or '3' in str(num):\n    return('Fizz')\n  elif num % 5 == 0 or '5' in str(num):\n    return('Buzz')\n  else:\n    return(str(num))\nThe above code is a function to print Fizz"], [0.15644389465550612, 0.16326530612244897, 0.17394027526731895, "def dict_filter(dict,n):\n result = {key:value for (key, value) in dict.items() if value >=n}\n return result\nThe above code is a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\n\ndef check_smaller(test_tup1, test_tup2):\n  return all(x > y for x, y in zip(test_tup1, test_tup2))\nThe above code is a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes two strings and returns the minimum number of swaps required for merging two strings to form palindrome string.\n\ndef largest_palin(palin_string) :\n    max_value, temp = 0, -1\n    n = len(palin_string) \n    temp = n//2\n    middle_value = palin_string[temp] \n    while temp >= 0 : \n        val = palin"], [0.17936516712309317, 0.11764705882352941, 0.10423853562036214, "import math  \ndef even_binomial_Coeff_Sum( n): \n    return (1 << (n - 1)) \nThe above code is a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.\n\ndef sample_nam(sample_names):\n  sample_names=list(filter(lambda el:el[0].isupper() and el[1:].islower(),sample_names))\n  return len(''.join(sample_names))\nThe above code is a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is an algorithm that takes in two strings and counts the number of swaps required such that the swappable characters are adjacent.\n"], [0.18612433156255487, 0.17777777777777778, 0.18521169038560242, "def new_tuple(test_list, test_str):\n  return tuple(test_list + [test_str])\nThe above code is a function to create a new tuple from the given string and list.\n\ndef max_run_uppercase(test_str):\n  cnt = 0\n  res = 0\n  for idx in range(0, len(test_str)):\n    if test_str[idx].isupper():\n      cnt += 1\n    else:\n      res = cnt\n      cnt = 0\n  if test_str[len(test_str) - 1].isupper():\n    res = cnt\n  return (res)\nThe above code is a function to find maximum run of uppercase characters in the given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps required to sort the words \"str1\" and \"str2\" in ascending order.\ndef alpha_scoring(secret_word) : \n    score = 8\n    word = secret_word.lower() \n    for letter in word : \n        if letter in \"aeiou\" : \n            score += 3\n            continue\n        if letter in \"askdfpogq\" : \n"], [0.0977522735015835, 0.10416666666666667, 0.2313345430037228, "import re  \nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef check_char(string): \n\tif(re.search(regex, string)): \n\t\treturn \"Valid\" \n\telse: \n\t\treturn \"Invalid\" \nThe above code is a function to check whether the given string starts and ends with the same character or not.\n\ndef add_dict_to_tuple(test_tup, test_dict):\n  test_tup = list(test_tup)\n  test_tup.append(test_dict)\n  test_tup = tuple(test_tup)\n  return (test_tup) \nThe above code is a function to add a dictionary to the tuple. The output should be a tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check if string can be convert to another string using by atmost 2 swaps.\n\ndef is_palindrome(s):\n    return (s[:(len(s) + 1)//2] == s[-((len(s) - (1))//2):][::-1])\nYour task is to return True if the given string is a palindrome. Otherwise return False.\n\n\ndef input_list(inputt"], [0.14214985221881515, 0.14754098360655737, 0.28728597971009057, "def odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result\nThe above code is a python function to remove the characters which have odd index values of a given string.\n\nimport re  \nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef check_char(string): \n\tif(re.search(regex, string)): \n\t\treturn \"Valid\" \n\telse: \n\t\treturn \"Invalid\" \nThe above code is a function to check whether the given string starts and ends with the same character or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check the minimum number of swaps to have string2 starts and ends with string1 \u2018s characters.\n\nInorder to make two lists equal in length, make the length of odd indexed list equal to even indexed list by just swapping one element.\n\nIn python there are several methods to do that, illustrated bellow:\n\ndef swap(A, odd, even): \n  \n    # odd and even are the indexes  \n    #"], [0.11242690681037187, 0.10416666666666667, 0.16805042040253448, "import math\ndef surfacearea_sphere(r):\n  surfacearea=4*math.pi*r*r\n  return surfacearea\nThe above code is a function to find the surface area of a sphere.\n\ndef get_pairs_count(arr, sum):\n    count = 0  \n    for i in range(len(arr)):\n        for j in range(i + 1,len(arr)):\n            if arr[i] + arr[j] == sum:\n                count += 1\n    return count\nThe above code is a python function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a list of numbers and the sum,\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program to find out the Minimum swaps required to make two strings anagram.\n\ndef get_max_qty(item_list, max_weight) :    maxweight_qyt = 0\n    for i in range(len(item_list)) :  \n        current_wegiht = 0\n                for j in range(i + 1) :                currentweight_qyt = item_list[i][1] * item_"], [0.08327191172509207, 0.07547169811320754, 0.20498640724181155, "import heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)\nThe above code is a function to merge three lists into a single sorted list.\n\ndef check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) \nThe above code is a function to check if all the elements in tuple have same data type or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a Python program to find minimum swap for str1 \n and str2 to be equal.\n\ndef calculate(string):\n  #print('\\n read test cases: ',t,'\\n get string value: ',string)\n  numbers = []\n  errors = ''\n  isValid = 1\n\n  if string[0:1] == '0' and string[1:2] =='x':\n    isValid = 0\n    errors"], [0.1191238743766108, 0.09615384615384616, 0.16740834026338106, "def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1\nThe above code is a function to find nth centered hexagonal number.\n\ndef extract_index_list(l1, l2, l3):\n    result = []\n    for m, n, o in zip(l1, l2, l3):\n        if (m == n == o):\n            result.append(m)\n    return result\nThe above code is We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. a function to find common elements from three lists. The function should return a list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is tO count minimum number of collisions needed to make an anagram sentence from the given strings.\n\ndef closest_number(l,target) :\n    sorted_l = sorted(l)\n    first =0\n    last = len(l)-1\n    min_diff = abs(l[0]-target)\n    for i in l :\n        if i == target :\n            break\n        if i > target :\n            if abs("], [0.2086350902139816, 0.2127659574468085, 0.18091607980552382, "def count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) \nThe above code is a function to find the number of elements that occurs before the tuple element in the given tuple.\n\ndef sum_odd(n): \n    terms = (n + 1)//2\n    sum1 = terms * terms \n    return sum1  \ndef sum_in_range(l,r): \n    return sum_odd(r) - sum_odd(l - 1)\nThe above code is a python function to find the sum of all odd natural numbers within the range l and r.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function which find the minimum number of swaps required to get the second string with respect to the first string.\n\ndef swap(arr,si,fi): \n    temp = arr[si]    \n    arr[si]= arr[fi]  \n    arr[fi]= temp\n# sort pairs  \ndef pairs(arr, n, k) :  \n    arr.sort() \n    pool = 0\n    pat = 0    \n"], [0.08547161555990723, 0.12962962962962962, 0.1376529346381697, "def return_sum(dict):\n  sum = 0\n  for i in dict.values():\n    sum = sum + i\n  return sum\nThe above code is function to find the sum of all items in the given dictionary.\n\ndef is_perfect_square(n) :\n    i = 1\n    while (i * i<= n):\n        if ((n % i == 0) and (n / i == i)):\n            return True     \n        i = i + 1\n    return False\nThe above code is a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is  minimum swaps of the string characters may need or not need \ndef trail_zero(num) : \n    count = 0\n    i = 5\n    while num/ i >= 1 : \n        count += int(num / i) \n        i *= 5  \n    print(count) \nThe above code is the find the count of trailing zero in the factorial of a number in a very fast way.\n\ndef above_"], [0.11252056807678093, 0.14285714285714285, 0.32998207624631865, "from operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) \nThe above code is Given a list of tuples, a function that returns the first value of the tuple with the smallest second value.\n\ndef check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) \nThe above code is a function to check if all the elements in tuple have same data type or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate minimum swaps to convert one string to another one string character by character.\nLet's take input from user.\ntry:\n    txt = input(\"A string value to the function: \")\nfinally:\n    print(\"The final value which goes to function is:\",txt)\nThe above code is to take input from user and show them a certain phrase.\nAssignment No.:10\nDate: 25/08/2019\n\n"], [0.263349268747953, 0.4090909090909091, 0.5403878821482792, "def find_Rotations(str): \n    tmp = str + str\n    n = len(str) \n    for i in range(1,n + 1): \n        substring = tmp[i: i+n] \n        if (str == substring): \n            return i \n    return n \nThe above code is a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\ndef drop_empty(dict1):\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1\nThe above code is a function to drop empty items from a given dictionary.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find minimum swaps required to convert one string to other string.\n"], [0.16201150198944386, 0.11538461538461539, 0.1832393127210854, "def even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; \nThe above code is a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n\ndef find_Average_Of_Cube(n):  \n    sum = 0\n    for i in range(1, n + 1): \n        sum += i * i * i  \n    return round(sum / n, 6) \nThe above code is a python function to find the average of cubes of first n natural numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " takes the two strings and find the minimum number of swaps required to make  the two strings similar.\n\ndef countways(n) : \n    if n == 0 or n == 1 : \n        return 1\n    else : \n        return countways(n-1) + countways(n-2) \nThis code returns the number of possible ways to get the sum X using the given coins.\n\ndef generateDecimal(n) :"], [0.19892250017638435, 0.23809523809523808, 0.19774716697254505, "def check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\nThe above code is a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n\ndef add_nested_tuples(test_tup1, test_tup2):\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \nThe above code is a function to perform index wise addition of tuple elements in the given two nested tuples.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check minimum swaps required to convert one string to another.\n\ndef quick_SortHelper(elements,start,end) : \n    if start >= end : \n        return\n    pivot = elements[end] \n    pivotIndex = start  \n    for i in range(start , end) : \n        if elements[i] <= pivot : \n            elements[i],elements[pivotIndex] = elements["], [0.09967910812889123, 0.2, 0.16822929221832883, "def replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n\nThe above code is a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n\ndef find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False\nThe above code is a python function to find whether the parity of a given number is odd.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a Python3 function which takes two parameters as strings and prints the Minimum number of Swaps required to turn one string into another.\n\ndef first_Missing(array) : \n        length = len(array) \n        i = 0\n        while i < length :  \n            index = int(array[i]/2)  \n            if index != float(array[i]) and index >= 0 and index < length and index == int(index"], [0.09612497907115167, 0.1111111111111111, 0.10218706601821083, "def find_Rotations(str): \n    tmp = str + str\n    n = len(str) \n    for i in range(1,n + 1): \n        substring = tmp[i: i+n] \n        if (str == substring): \n            return i \n    return n \nThe above code is a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\ndef power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)\nThe above code is a function to calculate the value of 'a' to the power 'b'.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check whether it requires minimum swaps or not.\ndef evaluate_Postfix(exp): \n    stack = [] \n    for i in exp: \n        if i == '+': \n            a = stack.pop() #a=2\n            b = stack.pop() #b=3\n            stack.append(a+b) #a+b=5\n        elif i == '-': \n            a"], [0.12144064117716465, 0.11320754716981132, 0.17563625681453973, "def empty_dit(list1):\n empty_dit=all(not d for d in list1)\n return empty_dit\nThe above code is a function to check whether all dictionaries in a list are empty or not.\n\ndef first_non_repeating_character(str1):\n  char_order = []\n  ctr = {}\n  for c in str1:\n    if c in ctr:\n      ctr[c] += 1\n    else:\n      ctr[c] = 1 \n      char_order.append(c)\n  for c in char_order:\n    if ctr[c] == 1:\n      return c\n  return None\nThe above code is a python function to find the first non-repeated character in a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to minimise the number of changes needed to make two strings equal.\n\ndef unique_sorted_list(list2):\n for item in list2:\n   sort=sorted(item)\n list3=(sorted(set(sort)))\n return list3\nThe above code is a python function do caculate the sum of all the elements in the list and add the largest value of list2 to the sum and subtract the smallest value of"], [0.11625236787328876, 0.13725490196078433, 0.2436827162623825, "def find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res\nThe above code is a function to find tuples which have all elements divisible by k from the given list of tuples.\n\ndef group_tuples(Input): \n\tout = {} \n\tfor elem in Input: \n\t\ttry: \n\t\t\tout[elem[0]].extend(elem[1:]) \n\t\texcept KeyError: \n\t\t\tout[elem[0]] = list(elem) \n\treturn [tuple(values) for values in out.values()] \nThe above code is a function to find common first element in given list of tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find minimum swaps required to get a string.\n\n\ndef sum_list(list1):\n  return (sum(map(int, list1)))\nIn the above code, [int(x) if x.isdigit() else x for x in list1] is used to coerce all values of list to int in case of strings.\n\ndef Match_str(str1,str2) : \n    if not (len"], [0.1380297303788604, 0.14, 0.2250193408284939, "def move_num(test_str):\n  res = ''\n  dig = ''\n  for ele in test_str:\n    if ele.isdigit():\n      dig += ele\n    else:\n      res += ele\n  res += dig\n  return (res) \nThe above code is a function to move all the numbers to the end of the given string.\n\ndef find_sum(arr): \n    arr.sort() \n    sum = arr[0] \n    for i in range(len(arr)-1): \n        if (arr[i] != arr[i+1]): \n            sum = sum + arr[i+1]   \n    return sum\nThe above code is a python function to find the sum of non-repeated elements in a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the number of swaps to make both the strings equal.\ndef replace_chars(str, chars):\n    new_str = ''\n    for char in str:\n        if char in chars:\n            new_str += '9'\n        else:\n            new_str += char\n    return new_str\nThe above code is a python function to replace a listed of character with 9s\ndef change_special_character"], [0.1082552758479032, 0.13559322033898305, 0.17029734484420297, "from collections import defaultdict\ndef max_occurrences(nums):\n    dict = defaultdict(int)\n    for i in nums:\n        dict[i] += 1\n    result = max(dict.items(), key=lambda x: x[1]) \n    return result[0]\nThe above code is a function to find the item with maximum frequency in a given list.\n\ndef count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count \nThe above code is a python function to count the number of set bits (binary digits with value 1) in a given number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python to convert the two strings into anagrams by swapping the minimum number of letters one by one.Note:During swapping it must be ensured that same letters of both strings get swapped. if the two arrays are already anagram then retun 0.\ndef fibonacciSum(n): \n    sum=0\n    a=0\n    b=1\n    if n == 0: \n        return 0\n    for i in range(0,"], [0.2660167023283951, 0.2222222222222222, 0.3004788463015897, "def sum(a,b): \n    sum = 0\n    for i in range (1,min(a,b)): \n        if (a % i == 0 and b % i == 0): \n            sum += i \n    return sum\nThe above code is a python function to find the sum of common divisors of two given numbers.\n\ndef combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result\nThe above code is a function to find all possible combinations of the elements of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program to print the minimum number of swaps required to convert \u2018str\u2019 into \u2018str2\u2019.\ndef reverse(nums,l,r) :\n    while (l < r) : \n        nums[l], nums[r] = nums[r], nums[l] \n        l+=1\n        r-=1\n\nThe above code is a python function to find the respective positions of"], [0.09866837118096128, 0.10256410256410256, 0.04420112763806258, "def concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) \nThe above code is a function to concatenate each element of tuple by the delimiter.\n\nimport re\ndef text_match_one(text):\n        patterns = 'ab+?'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n\nThe above code is a function that matches a string that has an a followed by one or more b's.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that checks if No. of swaps is even or not. And return accordingly.\n\ndef text_match(text):\n        patterns = '\\D{7}(?P<day>[0][2])\\.(?P<month>[0][1])\\.(?P<year>[1][7])'\n        if re.search(patterns,  text):\n                return (\"True\")\n        else:\n                return (\"False"], [0.16239463904836046, 0.16666666666666666, 0.2998030426314118, "def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True\nThe above code is a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n\ndef combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result\nThe above code is a function to find all possible combinations of the elements of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find number of swaps required to make two string anagram.\nimport numpy as np \nmat = np.matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9], [4, 8, 12]])\nU, D, V = np.linalg.svd(mat)\nThe above code is generated from a c program to calculate singular value decomposition of matrix.\n\n"], [0.16784509843345782, 0.18604651162790697, 0.3083999753839434, "def long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t\nThe above code is a function to find words that are longer than n characters from a given list of words.\n\ndef swap_List(newList): \n    size = len(newList) \n    temp = newList[0] \n    newList[0] = newList[size - 1] \n    newList[size - 1] = temp   \n    return newList \nThe above code is a python function to interchange the first and last element in a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to calculate the number of swaps needed to convert str1 to str2.\ndef int_List(lst,newlst,length) : \n    for i in range(length) : \n        if type(lst[i]) == int : \n            newlst.append(lst[i]) \n        else :  \n            continue\n    return newlst \nThe above code is a python function to"], [0.08216257245659005, 0.1044776119402985, 0.21782844374767596, "def tuple_intersection(test_list1, test_list2):\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\n  return (res)\nThe above code is a function to find the tuple intersection of elements in the given tuple list irrespective of their order.\n\nfrom itertools import groupby\ndef pack_consecutive_duplicates(list1):\n    return [list(group) for key, group in groupby(list1)]\nThe above code is a function to pack consecutive duplicates of a given list elements into sublists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that given two strings, it returns how many swaps must be done \nso that they become anagram. The general logic is similar to minimum swaps required, but \nthe only caveat is there are duplicates in the input strings. So, one swap can be considered more than one swap.\n        \nThe general logic seems to be similar to that of minimum insertion deletions, but the only quirks are instead of keeping characters sorted, \nwe have to keep swaps"], [0.10447396422011303, 0.12962962962962962, 0.21327687730370729, "def is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False\nThe above code is a function to check if the given number is woodball or not.\n\nfrom operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) \nThe above code is Given a list of tuples, a function that returns the first value of the tuple with the smallest second value.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check if the two strings can be converted from one string to another with a fixed number of swaps.\n\ndef check_concatenated(a, str1):\n \n  anag = sorted(a + a) \n  str1 = sorted(str1)\n \n \n  if (str1 == anag):\n    return 1\n  else:\n    return 0\nThe above code is a function that checks if"], [0.17947763620938637, 0.125, 0.13391906048564695, "def find_Rotations(str): \n    tmp = str + str\n    n = len(str) \n    for i in range(1,n + 1): \n        substring = tmp[i: i+n] \n        if (str == substring): \n            return i \n    return n \nThe above code is a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\ndef extract_rear(test_tuple):\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\n  return (res) \nThe above code is a function to extract only the rear index element of each string in the given tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " calculates the minimum number of swaps required to make two strings anagram.\ndef lengthOfLongestSubstring(s):  \n  r, res, st = 0, 0, 0\n  status = [-1 for i in range(256)]\n  for r in range(len(s)):\n    st = max(status[ord(s[r])] + 1, st)\n    res = max(res, r - st + 1)\n"], [0.09415127045725653, 0.10714285714285714, 0.15046446808585387, "from itertools import combinations_with_replacement \ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l,n))\n\nThe above code is a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a tuple for each combination.\n\ndef issort_list(list1):\n    result = all(list1[i] <= list1[i+1] for i in range(len(list1)-1))\n    return result\nThe above code is a function to check whether a specified list is sorted or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check whether a specified string can be obtained by swaping or not, by checking number of swappings in the list i.e. if the number of swappings is a multiple of two then that list is sorted else not.\n\ndef removeRepetition(arr, n) : \n    arr.sort() \n    for i in range(n) :\n        if (arr[i] == arr[i - 1]) : \n           "], [0.16809401398526286, 0.16666666666666666, 0.2639618137815714, "def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num \nThe above code is a python function to find the largest number that can be formed with the given list of digits.\n\ndef difference(n) :  \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  \nThe above code is a python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum number of swaps to rearrange the strings giving the difference between the number of swaps.\neg.\nstr1 = \"ABHE\"\nstr2 = \"ABEE\"\nprint(min_Swaps(str1 , str2)) \nout : 2\ndef string_Alternate(str) : \n    s = str \n    c = len(s) \n    new = '' \n    if c"], [0.1144973216776667, 0.17777777777777778, 0.26889038255589887, "def odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result\nThe above code is a python function to remove the characters which have odd index values of a given string.\n\nimport math\ndef sector_area(r,a):\n    if a > 360:\n        return None\n    return (math.pi*r**2) * (a/360)\nThe above code is a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is to find the minimum no of swaps to be done to convert a string in another string.\n\ndef check_block_motif(list1,list2):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == \"a\" and list2[i] == \"c\":\n            count += 1\n        elif list1[i] == \"b\" and list2[i]"], [0.10095641875490724, 0.12698412698412698, 0.3877278691370516, "def is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False\nThe above code is a function to check if the given number is woodball or not.\n\ndef count_X(tup, x): \n    count = 0\n    for ele in tup: \n        if (ele == x): \n            count = count + 1\n    return count \nThe above code is a python function that takes in a tuple and an element and counts the occcurences of the element in the tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that given two strings neccessary to insert in each other in the order of their occurance, returns the minimum total number of swaps to convert str1 to str2.\nHere, we need to swap occurances of c with ? atodd places such that there are some number of ? intermediate. For example?b\n?A\nc\nA?D\nThe objective of our algorithm is to convert all ? to corrosponding characters of str1 to produce the"], [0.18171965831720593, 0.21153846153846154, 0.3836845562017789, "def jacobsthal_num(n): \n\tdp = [0] * (n + 1) \n\tdp[0] = 0\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2] \n\treturn dp[n]\nThe above code is a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n\ndef first_odd(nums):\n  first_odd = next((el for el in nums if el%2!=0),-1)\n  return first_odd\nThe above code is a python function to find the first odd number in a given list of numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum no of swaps required to convert a given string str1 to another string str2. If it is not possible to convert the str1 to str2 convert it as str2[:minSwaps] + str2[minSwaps:] \ndef isPrime(num) : \n    if num > 1 :\n            # Iterate from 2 to n / 2  \n            for i in range(2, num//2)"], [0.10104693223815794, 0.1076923076923077, 0.18147925030589546, "def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True\nThe above code is a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n\ndef common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result\nThe above code is a function that takes two lists and returns true if they have at least one common element.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " takes two strings and returns the minimum number of swappins required to get the second string from the first.\n\n# ) You are given a positive integer N. You need to print the series of all prime numbers till N.\ndef isPrime(n):\n    if n == 1:\n        return False\n    isPrime = True\n    end = int(n/2) + 1\n    for x in range(2, end):\n        if n %"], [0.09148557665326087, 0.12698412698412698, 0.2039918141426928, "def find_Rotations(str): \n    tmp = str + str\n    n = len(str) \n    for i in range(1,n + 1): \n        substring = tmp[i: i+n] \n        if (str == substring): \n            return i \n    return n \nThe above code is a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\ndef replace_spaces(text):\n  return \"\".join(\" \" if c == \"_\" else (\"_\" if c == \" \" else c) for c in text)\nThe above code is a function to replace whitespaces with an underscore and vice versa in a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " uses an array to represent each string. And if the character at even index of string1 and at position of (same index + 1) of string2 are not equal, count is increased by 1.\n\nif string contains odd number of characters, count will never be divisible by 2, hence \"Not Possible\" is printed.\n\nOtherwise the minimum swaps required is printed.\ndef GreedyMedian(arr):\n    freq = [0]*100\n\n   "], [0.12844197016858908, 0.1346153846153846, 0.24596767354880822, "def long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t\nThe above code is a function to find words that are longer than n characters from a given list of words.\n\ndef find_sum(arr): \n    arr.sort() \n    sum = arr[0] \n    for i in range(len(arr)-1): \n        if (arr[i] != arr[i+1]): \n            sum = sum + arr[i+1]   \n    return sum\nThe above code is a python function to find the sum of non-repeated elements in a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program to find the minimun number of swaps to change a string to another string. \n\ndef remove_positives(lst): \n    for element in lst : \n        if element > 0 : \n            lst.remove(element)\n    return print(lst)\nThe above code implements a program to remove the positive numbers from a list on given inputs.\ndef convert_list(lst) : \n   "], [0.1282197579265895, 0.16666666666666666, 0.22442630922291917, "import math\ndef wind_chill(v,t):\n windchill = 13.12 + 0.6215*t -  11.37*math.pow(v, 0.16) + 0.3965*t*math.pow(v, 0.16)\n return int(round(windchill, 0))\nThe above code is a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\ndef all_Characters_Same(s) :\n    n = len(s)\n    for i in range(1,n) :\n        if s[i] != s[0] :\n            return False\n    return True\nThe above code is a python function to check whether all the characters are same or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to print the minimum number of swaps required.\nFirst define a Counter for both the strings, I stored 0 for the second string to write the output in the \u2018if\u2019 condition\nInitial value of count \u20190\u2019 is taken.\nFor loop iterates the lengths of both strings. \nCheck the condition which stores the count value \nIf \u2018Counter(str1)[i]\u2019 not equals to \u2018Counter(str2)["], [0.19928076707202283, 0.1875, 0.28897940587784254, "import sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i\nThe above code is a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\ndef swap_List(newList): \n    size = len(newList) \n    temp = newList[0] \n    newList[0] = newList[size - 1] \n    newList[size - 1] = temp   \n    return newList \nThe above code is a python function to interchange the first and last element in a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to determine the number of swaps required to convert a given string to another string.\ndef triplets_equalto7(ar,n):\n    newlist = []\n    for i in range(0,n - 2): \n        for j in range(i+1, n - 1):  \n            for k in range(j + 1, n): \n                if ar[i] + ar[j] + ar[k]"], [0.1905411804331966, 0.3076923076923077, 0.39352092711838393, "def group_tuples(Input): \n\tout = {} \n\tfor elem in Input: \n\t\ttry: \n\t\t\tout[elem[0]].extend(elem[1:]) \n\t\texcept KeyError: \n\t\t\tout[elem[0]] = list(elem) \n\treturn [tuple(values) for values in out.values()] \nThe above code is a function to find common first element in given list of tuple.\n\ndef is_decimal(num):\n    import re\n    dnumre = re.compile(r\"\"\"^[0-9]+(\\.[0-9]{1,2})?$\"\"\")\n    result = dnumre.search(num)\n    return bool(result)\nThe above code is a function to check whether a given string is a decimal number with a precision of 2.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function that finds out minimum swap required to convert first string to second string."], [0.24072493263825573, 0.22641509433962265, 0.3856930798731528, "def is_Diff(n): \n    return (n % 11 == 0) \nThe above code is a python function to find whether a number is divisible by 11.\n\ndef last(arr,x):\n    n = len(arr)\n    low = 0\n    high = n - 1\n    res = -1  \n    while (low <= high):\n        mid = (low + high) // 2 \n        if arr[mid] > x:\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            res = mid\n            low = mid + 1\n    return res\nThe above code is a python function to find the last position of an element in a sorted array.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to calculate the minimum number of swaps required to convert the first string to the second string when described as a regular language.\n    \n    \n    \n    \n    \n    \n    \n# returns index of x in arr if present, else -1 \ndef binarySearch(arr, l, r, x): \n    # Check base case \n    \n    if r >= l: \n        mid = (l + r)/2\n"], [0.11525316598180085, 0.14285714285714285, 0.28914811384300265, "def combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result\nThe above code is a function to find all possible combinations of the elements of a given list.\n\nfrom operator import eq\ndef count_same_pair(nums1, nums2):\n    result = sum(map(eq, nums1, nums2))\n    return result\nThe above code is The input is defined as two lists of the same length. a function to count indices where the lists have the same values.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find a number of swaps of the string characters to be performed to transform string 1 into string 2.\n\ndef sort_list(list1) : \n    if (len(list1) <= 1) : \n        return list1\n    else :  \n        less_list = [] \n        equal_list = [] \n        greater_list = []\n        pivot = list1[0]  \n        for element in list"], [0.1013189972013108, 0.13333333333333333, 0.09570327442218597, "def add_nested_tuples(test_tup1, test_tup2):\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \nThe above code is a function to perform index wise addition of tuple elements in the given two nested tuples.\n\nimport re\ndef text_match_one(text):\n        patterns = 'ab+?'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n\nThe above code is a function that matches a string that has an a followed by one or more b's.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find minimum swaps required if characters are interchanged.\n\ndef frequency(l): \n    freq = {} \n    empt_string=\"\"\n    for i in l: \n        if (i in freq): \n            freq[i] += 1\n        else: \n            freq[i] = 1\n    for key, value in freq.items(): \n        a=key,value\n        empt"], [0.20183207219712385, 0.20930232558139536, 0.1925890305307961, "def count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res\nThe above code is a function to count bidirectional tuple pairs.\n\ndef test_three_equal(x,y,z):\n  result = set([x,y,z])\n  if len(result)==3:\n    return 0\n  else:\n    return 4-len(result)\nThe above code is a python function to count the number of equal numbers from three given integers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to count the minimum no.of swaps required to form a string having equal 1's and 0's.\ndef matrixReshape(nums, r, c):\n    \"\"\"\n    :type nums: List[List[int]]\n    :type r: int\n    :type c: int\n    :rtype: List[List[int]]\n    \"\"\"\n    nr = len(nums)\n    nc ="], [0.14938327650235267, 0.1346153846153846, 0.19943214156810674, "def circle_circumference(r):\n  perimeter=2*3.1415*r\n  return perimeter\nThe above code is a function to find the circumference of a circle.\n\ndef divisible_by_digits(startnum, endnum):\n    return [n for n in range(startnum, endnum+1) \\\n                if not any(map(lambda x: int(x) == 0 or n%int(x) != 0, str(n)))]\nThe above code is a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/python-exercises/lambda/python-lambda-exercise-24.php\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the number of swaps required to sort str1 into str2. \n\ndef calculate_digits(num) : \n    sum = 0\n    while (num != 0) :\n        sum = sum + num % 10\n        num = int(num / 10)\n    return (sum)  \nThe above code is a function to find the sum of digits in the given number. \n\ndef reverse_roman(num)"], [0.08336726646676286, 0.05454545454545454, 0.02205593644986439, "def max_difference(test_list):\n  temp = [abs(b - a) for a, b in test_list]\n  res = max(temp)\n  return (res) \nThe above code is a function to find the maximum difference between available pairs in the given tuple list.\n\ndef count_Pairs(arr,n): \n    cnt = 0; \n    for i in range(n): \n        for j in range(i + 1,n): \n            if (arr[i] != arr[j]): \n                cnt += 1; \n    return cnt; \nThe above code is a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a string where both elements should have the same frequency of characters.\ndef count_Pairs(arr,n): \n    last = n-1\n    first = 0\n    cnt = 0\n    minmax = \"\"\n    arr = sorted(arr) \n    while (first < last) :\n        if (arr[first] + arr[last]) == n :\n            for i in range(first,last+1) : "], [0.26764380966818957, 0.21739130434782608, 0.2783076576134863, "def find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False\nThe above code is a python function to find whether the parity of a given number is odd.\n\ndef find_sum(arr): \n    arr.sort() \n    sum = arr[0] \n    for i in range(len(arr)-1): \n        if (arr[i] != arr[i+1]): \n            sum = sum + arr[i+1]   \n    return sum\nThe above code is a python function to find the sum of non-repeated elements in a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum number of swaps required to convert between two strings.\ndef print_combination(arr, n):  \n    visited = [False for i in range(n)]  \n    curr_index = 1\n    next_index = 0\n  \n    while (True):  \n        if curr_index >= n:  \n            print(\"\")  \n            return\n          \n        if visited[curr_index"], [0.1446459652337155, 0.1956521739130435, 0.37670282287894086, "def find_Rotations(str): \n    tmp = str + str\n    n = len(str) \n    for i in range(1,n + 1): \n        substring = tmp[i: i+n] \n        if (str == substring): \n            return i \n    return n \nThe above code is a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\ndef is_product_even(arr): \n    for i in range(len(arr)): \n        if (arr[i] & 1) == 0: \n            return True\n    return False\nThe above code is a function to check whether the product of numbers in a list is even or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of Swaps required to convert a string into another string. Using the function we can now find \"ab\" ->  \"ca\", giving a 2 Swaps. \nLast Important Concept is to import modules when needed instead of bringing them into the project\n"], [0.09578087512617586, 0.14285714285714285, 0.17385636000297178, "def last_Digit_Factorial(n): \n    if (n == 0): return 1\n    elif (n <= 2): return n  \n    elif (n == 3): return 6\n    elif (n == 4): return 4 \n    else: \n      return 0\nThe above code is a python function to find the last digit in factorial of a given number.\n\ndef min_k(test_list, K):\n  res = sorted(test_list, key = lambda x: x[1])[:K]\n  return (res) \nThe above code is a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program to find minimum swaps required.\nIt returns the count zero if modulo value is equal to zero else it returns Not Possible\ndef Count_Lower(string) :\n    w = {l:0 for l in \"abcdefghijklmnopqrstuvwxyz\"}\n    for each_char in string :\n        if each_char in w and each_char.islower():\n            w[each_char] +="], [0.1977828496601991, 0.23684210526315788, 0.2814872447780273, "def min_of_three(a,b,c): \n      if (a <= b) and (a <= c): \n        smallest = a \n      elif (b <= a) and (b <= c): \n        smallest = b \n      else: \n        smallest = c \n      return smallest \nThe above code is a function to find minimum of three numbers.\n\ndef even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; \nThe above code is a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function which takes two strings as input and calculates minimum of number of swaps required to match str1 and str2. If it is impossible to match then it returns the message Not Possible.\n"], [0.08620059014324202, 0.10526315789473684, 0.16072677362911417, "from itertools import combinations \ndef find_combinations(test_list):\n  res = [(b1 + a1, b2 + a2) for (a1, a2), (b1, b2) in combinations(test_list, 2)]\n  return (res) \nThe above code is a function to find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/\n\nimport re\ndef text_match_three(text):\n        patterns = 'ab{3}?'\n        return re.search(patterns,  text)\nThe above code is a function that matches a string that has an a followed by three 'b'.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that is used to find the minimum swaps to sort two strings.\n\n#This Code is a sum of Even And Odd numbers that is ran to get the sum of all the even and odd numbers present in the list.\ndef even_and_odd(store_in_list) :\n    even_array = []\n    odd_array = []\n    for i in store_in_list :\n        if( i % 2 == 0) :"], [0.1695260114792399, 0.25, 0.29782701691658064, "import heapq\ndef expensive_items(items,n):\n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items\nThe above code is a function to find the n most expensive items in a given dataset.\n\ndef count_rotation(arr):   \n    for i in range (1,len(arr)): \n        if (arr[i] < arr[i - 1]): \n            return i  \n    return 0\nThe above code is a python function to count the number of rotations required to generate a sorted array. https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-array/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count the number of swaps required to convert a string into another. \nConsider the following way of swapping to elements using temporary variable.\n\na = 10\nb = 20\n \nt = a\na = b\nb = t\nThe above code will create swapping of a,b but the above method cannot be used as a temporary variable is required in the following way.\n\na = 10\nb = 20\n \na,b ="], [0.17393541391335698, 0.18333333333333332, 0.20484854010838188, "def frequency(a,x): \n    count = 0  \n    for i in a: \n      if i == x: \n        count += 1\n\n    return count \nThe above code is a function to count the number of occurrences of a number in a given list.\n\ndef adjac(ele, sub = []): \n  if not ele: \n     yield sub \n  else: \n     yield from [idx for j in range(ele[0] - 1, ele[0] + 2) \n                for idx in adjac(ele[1:], sub + [j])] \ndef get_coordinates(test_tup):\n  return list(adjac(test_tup))\nThe above code is a function to extract all the adjacent coordinates of the given coordinate tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that determines if there are an even number of swaps required to convert one string to another.\n\n\nFrom the above code, you will find that the tests do the following:\n\nOn line 3, the list is assigned a given static value.\nOn line 5, the list is sorted to match the sorted expected output in line 6.\nOn line 7-8, a loop is processed to insert any given elements into the list.\nOn line 8-9,"], [0.09290311282018449, 0.06521739130434782, 0.09867048424107766, "def find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0\nThe above code is a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\ndef replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2\nThe above code is a function to replace characters in a string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find \n\ndef get_element(lt1, index1, index2) : \n    lt2 = lt1[index1:]  \n    element = lt1[index2] \n    return (lt2, element) \nThe above code is a function to find the elements between K1th and K2th elements in the list \u201clt1\u201d.\ndef get_singletons(lt"], [0.1793756571779818, 0.17647058823529413, 0.22425745216002246, "from collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count\nThe above code is a python function to count the number of substrings with the sum of digits equal to their length.\n\ndef surfacearea_cube(l):\n  surfacearea= 6*l*l\n  return surfacearea\nThe above code is a function to find the surface area of a cube of a given size.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to calculate the minimum number of swaps to convert str1 to str2. If we replace sice by 1 we can solve you problem.\nimport random\ndef isSorted(List):\n    for i in range(len(List)-1):\n        if List[i+1] > List[i]:\n            return True\n        else:\n            return False \n    def bubbleSort(List):\ndef binarySearch(Arr,"], [0.0860638806889791, 0.10869565217391304, 0.09623348636346635, "def re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\nThe above code is a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\ndef ascii_value(k):\n  ch=k\n  return ord(ch)\nThe above code is a function to find the ascii value of a character.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a mathematical expression to find minimum swaps needed to obtain the string str2 from str1.\ndef is_leap(year):\n  leap = False\n  if (year % 4 == 0):\n    if(year % 100 == 0):\n      if(year % 400 == 0):\n        leap=True\n      else:\n        leap=False\n\n    else:\n        leap=True\n  else:\n    leap=False\n  return leap"], [0.18830069484596562, 0.21739130434782608, 0.2865497924651359, "def reverse_vowels(str1):\n\tvowels = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tvowels += char\n\tresult_string = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tresult_string += vowels[-1]\n\t\t\tvowels = vowels[:-1]\n\t\telse:\n\t\t\tresult_string += char\n\treturn result_string\nThe above code is a python function to reverse only the vowels of a given string (where y is not a vowel).\n\ndef lateralsuface_cylinder(r,h):\n  lateralsurface= 2*3.1415*r*h\n  return lateralsurface\nThe above code is a function to find the lateral surface area of a cylinder.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps required to have the same list if it is one type of anagram.\n\ndef count_vowels_string(line):\n\tvowels_string =len(line) - sum(char in 'aeiouyAEIOUY' for char in line)\n\treturn vowels_string\nThe above code is a function to return the vowel count of a string.\n\ndef numerals("], [0.21598745464231933, 0.2, 0.33427647115209996, "def loss_amount(actual_cost,sale_amount): \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return 0\nThe above code is a function that gives loss amount on a sale if the given amount has loss else return 0.\n\ndef odd_length_sum(arr):\n    Sum = 0\n    l = len(arr)\n    for i in range(l):\n        Sum += ((((i + 1) *(l - i) + 1) // 2) * arr[i])\n    return Sum\nThe above code is a python function to find the sum of all odd length subarrays. https://www.geeksforgeeks.org/sum-of-all-odd-length-subarrays/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum swaps required to convert str1 to str2. https://www.geeksforgeeks.org/python-program-for-minimum-swaps-required-to-convert-str1-to-str2/\ndef unique(n, arr):\n    arr = set(arr)\n    if len(arr) == n : \n        return 'unique'\n    else :\n        return ('not unique')"], [0.12437865753721293, 0.14285714285714285, 0.13536941992360196, "def replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n\nThe above code is a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n\ndef median_numbers(a,b,c):\n if a > b:\n    if a < c:\n        median = a\n    elif b > c:\n        median = b\n    else:\n        median = c\n else:\n    if a > c:\n        median = a\n    elif b < c:\n        median = b\n    else:\n        median = c\n return median\nThe above code is a function to find the median of three numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to the least number of swaps.\n\ndef subtract_trim_value(data_mean_abs,noise,tolerance,trim_level):\n for i in range(0,len(noise)):\n  if abs(noise[i]) > (data_mean_abs[i]/tolerance):\n   data_mean_abs[i]=0\n  else:\n   data_mean_abs[i"], [0.13424028939387864, 0.12, 0.19342237116010838, "import re\ndef find_adverb_position(text):\n for m in re.finditer(r\"\\w+ly\", text):\n    return (m.start(), m.end(), m.group(0))\nThe above code is a function to find the first adverb and their positions in a given sentence.\n\ndef bell_Number(n): \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1] \n    return bell[n][0] \nThe above code is a python function to find nth bell number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check whether a string can be converted to other string by swapping equal no. of characters.\ndef find_Longest_Substring(string):\n   a = {} \n  longest, start, c_start = 0, 0, 0  \nfor i,char in enumerate(string):   \n    if char in a: \n        c_start = max(c_start, a[char] + 1)   \n   "], [0.19795038833015816, 0.36363636363636365, 0.5837904732842294, "def replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2\nThe above code is a function to replace characters in a string.\n\ndef set_middle_bits(n):  \n    n |= n >> 1; \n    n |= n >> 2; \n    n |= n >> 4; \n    n |= n >> 8; \n    n |= n >> 16;  \n    return (n >> 1) ^ 1\ndef toggle_middle_bits(n): \n    if (n == 1): \n        return 1\n    return n ^ set_middle_bits(n) \nThe above code is a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " it gives minimum number of swaps to convert a string to another string. \n"], [0.11399243654541998, 0.140625, 0.19685716283166277, "def largest_subset(a):\n\tn = len(a)\n\tdp = [0 for i in range(n)]\n\tdp[n - 1] = 1; \n\tfor i in range(n - 2, -1, -1):\n\t\tmxm = 0;\n\t\tfor j in range(i + 1, n):\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\n\t\t\t\tmxm = max(mxm, dp[j])\n\t\tdp[i] = 1 + mxm\n\treturn max(dp)\nThe above code is a function to find the size of the largest subset of a list of numbers so that every pair is divisible.\n\ndef unique_Element(arr):\n    s = set(arr)\n    return len(s) == 1\nThe above code is a python function to check whether a list of numbers contains only one distinct element or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that returns the minimum number of swaps in converting an arbitrary string str1 to \nan arbitrary string str2 without altering any character positions \nNote: multiple swaps are allowed by repeating algorithms. \nNote that this only has string as input and also there is no output or return statement written in the above code.\ndef reverseInGroups(a, n): \n      \n    b = a[0:n] \n    c = a[n"], [0.21813146699989466, 0.20454545454545456, 0.2831706773075602, "from collections import Counter \ndef check_occurences(test_list):\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\n  return  (res) \nThe above code is a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n\ndef count_element_in_list(list1, x): \n    ctr = 0\n    for i in range(len(list1)): \n        if x in list1[i]: \n            ctr+= 1          \n    return ctr\nThe above code is a function to count the number of sublists containing a particular element.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count the number of swaps required to convert a str1 to str2.\n\ndef rev_list(list1) : \n    list1.reverse() \n    return (list1) \nThe above code is a function that reverse a given list.\ndef reverseSublist(head,start,finish) : \n    #define two pointers \n    mainPtr = subPtr = head  \n     \n  \n    #"], [0.12425856094995946, 0.18333333333333332, 0.2700660077123404, "def count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars \nThe above code is a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n\ndef max_sum_list(lists):\n return max(lists, key=sum)\nThe above code is a function that returns the list in a list of lists whose sum of elements is the highest.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that uses modulus '%' operator to check if swaps required to convert str1 to str2 is even or odd.If the count is even returns the number of swaps and if the count is odd returns  \"not possible\".\n\nwe can pass a flag variable such as (lCount) to give the output in the order we satisfy any one of the following conditions.\nBoth strings are equal \n\nAll letters of str1 are smaller than All letters of"], [0.10319180323001119, 0.13043478260869565, 0.14364931346423734, "def extract_singly(test_list):\n  res = []\n  temp = set()\n  for inner in test_list:\n    for ele in inner:\n      if not ele in temp:\n        temp.add(ele)\n        res.append(ele)\n  return (res) \nThe above code is a function to flatten the list of lists into a single set of numbers.\n\nimport math \ndef find_Index(n): \n    x = math.sqrt(2 * math.pow(10,(n - 1)))\n    return round(x)\nThe above code is a python function to find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program to find the number of edits required for two strings of equal size\n\nimport copy \n  \ndef permute(list, s, n):  \n    arrlst = copy.deepcopy(list) \n    if(s == n): \n        print(arrlst) \n    else: \n        for i in range(s, n): \n            arrlst[s], arrlst[i]"], [0.09066970617978225, 0.09859154929577464, 0.12286995692439513, "def count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr\nThe above code is a python function that returns the number of integer elements in a given list.\n\nfrom itertools import combinations_with_replacement \ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l,n))\n\nThe above code is a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a tuple for each combination.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function that takes in 2 strings as input. The function checks for mismatched characters at equal indexes of both strings, and increments, a counter for each mis-matched character. Hence for mismatched characters at odd index positions the counter remains unchanged, but for even index positions the counter increments by 1. If there is an odd number count, then we can't remove all the mismatched characters to get an anagram of the resultant string. So, if this condition satisfies, the"], [0.15452074014651132, 0.15384615384615385, 0.18405694784948487, "def find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0\nThe above code is a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\nimport re\ndef remove_lowercase(str1):\n return re.sub('[a-z]', '', str1)\nThe above code is a function to remove lowercase substrings from a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to give the number of swaps required to make two string anagram using Counter of collections and is generally used on smaller strings.\n\ndef divide(dividend, divisor):\n    flag = ((dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0))\n    dvd = abs(dividend) \n    dvs = abs(divisor)\n    counter,"], [0.09808020597805774, 0.1111111111111111, 0.14999437918809153, "def big_sum(nums):\n      sum= max(nums)+min(nums)\n      return sum\nThe above code is a python function to find the sum of the largest and smallest value in a given array.\n\ndef count_reverse_pairs(test_list):\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \n  return res\nThe above code is a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function which tells how many pairs of same characters in the string(str) are there such \nthat the string is a palindrome. https://www.geeksforgeeks.org/python-minimum-swaps-required-make-string-palindrome/\n\"\"\""], [0.11941909374787404, 0.13636363636363635, 0.24531398625157985, "def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True\nThe above code is a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n\ndef count_rotation(arr):   \n    for i in range (1,len(arr)): \n        if (arr[i] < arr[i - 1]): \n            return i  \n    return 0\nThe above code is a python function to count the number of rotations required to generate a sorted array. https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-array/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is to count the number of swap needed to convert the string to anagram string.\ndef countRotations(arr, n):  \n    cnt=0\n    for i in range(n): \n        for j in range(i+1, n): \n            if (arr[i] > arr[j] ):  \n                cnt+=1\n    return cnt\ndef findKey(n): \n    res=[]      \n"], [0.1125036136544433, 0.140625, 0.17963463197913274, "from collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count\nThe above code is a python function to count the number of substrings with the sum of digits equal to their length.\n\ndef multiple_to_single(L):\n  x = int(\"\".join(map(str, L)))\n  return x\nThe above code is a function to join a list of multiple integers into a single integer.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to return the min number of swaps required by one string to become the anagram of another string.\n2-14. It returns the list with no. of words greater than size k. If a word is smaller than k, then it cannot be part \nof the solution . If after removing all the words smaller than k it doesnt get empty, the answer is false. If it gets \nempty return true. There can be duplicates. If after removing all"], [0.12370650474143569, 0.125, 0.17763007687135138, "def pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count \nThe above code is a python function to count the number of positive numbers in a list.\n\ndef find_min_diff(arr,n): \n    arr = sorted(arr) \n    diff = 10**20 \n    for i in range(n-1): \n        if arr[i+1] - arr[i] < diff: \n            diff = arr[i+1] - arr[i]  \n    return diff \nThe above code is a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum swap required.\n\ndef reverse(string):\nCreate a function that reverses a string.\nExample\nFor inputString = \"!2daD WR+\", the output should be reverse(inputString) = \"WR+ da2!\"\nInput/Output\n\n[execution time limit] 4 seconds (py)\n\n[input] string inputString\n\nA string consisting of lowercase latin letters and/or digits"], [0.12174661063305425, 0.12280701754385964, 0.2314211118203041, "def even_bit_set_number(n): \n    count = 0;res = 0;temp = n \n    while(temp > 0): \n        if (count % 2 == 1): \n            res |= (1 << count)\n        count+=1\n        temp >>= 1\n    return (n | res) \nThe above code is a python function to set all even bits of a given number.\n\ndef diff_even_odd(list1):\n    first_even = next((el for el in list1 if el%2==0),-1)\n    first_odd = next((el for el in list1 if el%2!=0),-1)\n    return (first_even-first_odd)\nThe above code is a function to find the difference of the first even and first odd number of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check if a string can be converted to another one by re-arranging characters.\ndef remove_zero(list1) : \n    return [el for el in list1 if el != 0]\nThe above code is a python function to remove all occurence of zero value from a list.\nimport operator \ndef minimum(*list_values) :\n    dict1 = {i: value for i, value in enumerate("], [0.14444792508830503, 0.16326530612244897, 0.26777191406689027, "def sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n\nThe above code is a function to sort each sublist of strings in a given list of lists.\n\ndef find_min_diff(arr,n): \n    arr = sorted(arr) \n    diff = 10**20 \n    for i in range(n-1): \n        if arr[i+1] - arr[i] < diff: \n            diff = arr[i+1] - arr[i]  \n    return diff \nThe above code is a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find minimum swaps required (assuming strings are of equal or similar length) to change between the strings.   \n   minSwaps(\"JvA\", \"FVJS\") \n   minSwaps(\"xxxbc\",\"bcxxx \") \n   minSwaps(\"xxxxzxvxyzzy\",\" yzzyxzxvxyxx\")  \nThe above code is a python fuction to determine whether we are able to reach str2 from str1"], [0.146229930631307, 0.14285714285714285, 0.16727417988732807, "def bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \nThe above code is a function to find the number of ways to partition a set of Bell numbers.\n\nfrom itertools import groupby\ndef consecutive_duplicates(nums):\n    return [key for key, group in groupby(nums)] \nThe above code is a function to remove consecutive duplicates of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count the no of swaps required to sort the given strings.\n\n\n\ndef max_lengthCompression(nums) : \n    duplicate = consecutive_duplicates(nums)\n    diff = 0\n    for i in range(len(duplicate) - 1) : \n        temp = -1\n        if duplicate[i] == duplicate[i + 1] : \n            for j in range(i + 1"], [0.11744829388330894, 0.0851063829787234, 0.09068789814909667, "def even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; \nThe above code is a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n\ndef find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False\nThe above code is a python function to find whether the parity of a given number is odd.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find how many capitals are wrong in str2.\n\ndef Solve(n): \n    for i in range(1,n) : \n        if(i % 3 == 0 and i % 5 == 0) : \n            print (\"FizzBuzz\") \n        elif(i % 3 == 0): \n            print (\"Fizz\") \n        if(i % 5 == 0): \n            print (\""], [0.09397824642323813, 0.11594202898550725, 0.22121345428838513, "def recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total\nThe above code is a function to flatten a list and sum all of its elements.\n\ndef multiply_elements(test_tup):\n  res = tuple(i * j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) \nThe above code is a function that takes as input a tuple of numbers (t_1,...,t_{N+1}) and returns a tuple of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that accepts 2 strings of equal length and a third string containing wildcards that can often be found in phone numbers. The task is to find the minimum number of character swaps that need to be performed between the two strings so that they become identical (a swap of characters is when two characters in those two strings are swapped). It\u2019s ok to perform the same swap twice, but you want to minimize the swaps to get the two strings identical.\n\ndef list_an"], [0.15833535029834037, 0.16326530612244897, 0.18186143587671513, "import re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))\nThe above code is a function to convert the given snake case string to camel case string.\n\ndef largest_subset(a):\n\tn = len(a)\n\tdp = [0 for i in range(n)]\n\tdp[n - 1] = 1; \n\tfor i in range(n - 2, -1, -1):\n\t\tmxm = 0;\n\t\tfor j in range(i + 1, n):\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\n\t\t\t\tmxm = max(mxm, dp[j])\n\t\tdp[i] = 1 + mxm\n\treturn max(dp)\nThe above code is a function to find the size of the largest subset of a list of numbers so that every pair is divisible.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that gives the minimum number of swaps required in two strings to anagram them.\n\ndef long_subarray_with_given_sum(arr, sum) : \n    cur_sum = -1\n    j = 0\n    cur_sum = 0; \n    n = len(arr) \n    res = -1 \n    for i in range(0, n) :\n        while (cur_sum > sum and"], [0.09215442332572699, 0.10416666666666667, 0.09743430821629412, "def is_sublist(l, s):\n\tsub_set = False\n\tif s == []:\n\t\tsub_set = True\n\telif s == l:\n\t\tsub_set = True\n\telif len(s) > len(l):\n\t\tsub_set = False\n\telse:\n\t\tfor i in range(len(l)):\n\t\t\tif l[i] == s[0]:\n\t\t\t\tn = 1\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\n\t\t\t\t\tn += 1\t\t\t\t\n\t\t\t\tif n == len(s):\n\t\t\t\t\tsub_set = True\n\treturn sub_set\nThe above code is a function to check whether a list contains the given sublist or not.\n\nimport cmath\ndef angle_complex(a,b):\n  cn=complex(a,b)\n  angle=cmath.phase(a+b)\n  return angle\nThe above code is a function to get the angle of a complex number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check wether str1 is a semordnilap of str2 or not.\n\ndef makeAnagram(a, b):\n    count = 0\n    ac = [0] * 26\n    bc = [0] * 26\n    for i in (a) : \n        ac[ord(i) - ord('a')] += 1\n    for i in (b) : \n        bc[ord(i)"], [0.18413551265792952, 0.2727272727272727, 0.3588338356192046, "def tup_string(tup1):\n  str =  ''.join(tup1)\n  return str\nThe above code is a function to convert a tuple to a string.\n\ndef sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos\nThe above code is a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in two strings, finds the number of swaps needed to transform one string into another and returns the minimum number of swaps needed."], [0.12581998865012178, 0.12, 0.09282567092336189, "def find_remainder(arr, n): \n    mul = 1\n    for i in range(len(arr)):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n \nThe above code is a python function to find the product of the array multiplication modulo n.\n\ndef adjac(ele, sub = []): \n  if not ele: \n     yield sub \n  else: \n     yield from [idx for j in range(ele[0] - 1, ele[0] + 2) \n                for idx in adjac(ele[1:], sub + [j])] \ndef get_coordinates(test_tup):\n  return list(adjac(test_tup))\nThe above code is a function to extract all the adjacent coordinates of the given coordinate tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum swaps between two strings.\ndef n_ques(n: int, strin_examp='1 6 8 2'):\n  if n <= 10**5:\n    a = [int(x) for subset in (arg.split() for arg in strin_examp.split(',')) for x in subset]\n    a = set(a)\n    l = [k for k in map(lambda"], [0.10936665046967033, 0.125, 0.16818832734987843, "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x\nThe above code is a python function to find the number of divisors of a given integer.\n\ndef count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]\nThe above code is a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", "s are a function to swap the first and last characters of the both string.The 'count' of the function evaluates the number of swaps reqired.\n\ndef MinimumDistinct(str1) : \n    hash_map = {}   \n    for i in range(len(str1)) : \n        if str1[i] in hash_map.keys() : \n            hash_map[str1[i]] += 1\n        else : "], [0.2433149342523442, 0.2, 0.28004723354650296, "def remove_nested(test_tup):\n  res = tuple()\n  for count, ele in enumerate(test_tup):\n    if not isinstance(ele, tuple):\n      res = res + (ele, )\n  return (res) \nThe above code is a function to remove tuples from the given tuple.\n\ndef max_run_uppercase(test_str):\n  cnt = 0\n  res = 0\n  for idx in range(0, len(test_str)):\n    if test_str[idx].isupper():\n      cnt += 1\n    else:\n      res = cnt\n      cnt = 0\n  if test_str[len(test_str) - 1].isupper():\n    res = cnt\n  return (res)\nThe above code is a function to find maximum run of uppercase characters in the given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " counts the number of swaps required to convert one string to another in minimum number of swaps.\n\ndef next_hack(n):\n    n = n + 1\n    while(True):\n        num = str(n)\n        if len(num)%2 == 0:\n            zero = num[0]\n            ones = str(int(num[1]) * (2 ** int(num[0]))) \n            if int(num)"], [0.13008303853287545, 0.14, 0.17903134793468156, "def find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0\nThe above code is a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\ndef big_sum(nums):\n      sum= max(nums)+min(nums)\n      return sum\nThe above code is a python function to find the sum of the largest and smallest value in a given array.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check if the given strings are shuffled versions of same strings, then return the minimum no. of swaps required to get the strings in same order. If not return \"Not Possible\"\ndef candyCrush(string) :\n    l=[]\n    for i in string:\n        l.append(i),\n        \n    for i in  range ((len(l)-2),-1,-1):\n        if(l[i]"], [0.14569301117096214, 0.16279069767441862, 0.16570515142547657, "import sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i\nThe above code is a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\nimport bisect\ndef left_insertion(a, x):\n    i = bisect.bisect_left(a, x)\n    return i\nThe above code is a function to locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-data-structure-exercise-24.php\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a program to count the minimum swaps required to convert a str1 into str2. If it is not possible, it returns \u201cNot Possible\u201d.\n\nsum,total = 0,0\na = [64,34,25,12,22,11,13]\nfor j in range(len(a)): \n    min_idx = j \n    for i in range(j+1, len(a)): \n"], [0.11210841659761582, 0.1206896551724138, 0.21178558945543965, "def extract_rear(test_tuple):\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\n  return (res) \nThe above code is a function to extract only the rear index element of each string in the given tuple.\n\ndef largest_subset(a):\n\tn = len(a)\n\tdp = [0 for i in range(n)]\n\tdp[n - 1] = 1; \n\tfor i in range(n - 2, -1, -1):\n\t\tmxm = 0;\n\t\tfor j in range(i + 1, n):\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\n\t\t\t\tmxm = max(mxm, dp[j])\n\t\tdp[i] = 1 + mxm\n\treturn max(dp)\nThe above code is a function to find the size of the largest subset of a list of numbers so that every pair is divisible.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " checks whether swapping of elements is needed to convert a string str1 to str2. If yes then it returns the minimum number of elements that need to swapped else it returns \"Not Possible\"\ndef get_start(str) : \n    non_alnum = 0\n    for i in range(len(str)) : \n        if (str[i] >= 'a' and str[i] < 'z') or (str[i] >= 'A"], [0.09349391190467637, 0.09433962264150944, 0.14709820810328042, "def count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]\nThe above code is a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\n\nfrom copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon\nThe above code is a function to get a colon of a tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find out the difference betwwen the two strings with the difference being a minimum of Swaps to be performed.\ndef top_ord(str1):\n  ord1 = []\n  for i in str1:\n    ord1.append(ord(i))\n  ord1.sort()\n  return ord1[-1]\nThe above code is used to find out the highest ASCII Code in the String.\ndef century(Year"], [0.1829178727368454, 0.15555555555555556, 0.24755000782485784, "def substract_elements(test_tup1, test_tup2):\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n  return (res) \nThe above code is a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n\ndef sample_nam(sample_names):\n  sample_names=list(filter(lambda el:el[0].isupper() and el[1:].islower(),sample_names))\n  return len(''.join(sample_names))\nThe above code is a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate number of swaps \nrequired to make two strings anagrams.\n\ndef square_and_sort(li) : \n    s = sorted(list(set(list(map(lambda x:x**2,li)))))\n    return(s)\nThe above code is to sort the squares of distinct list element.\n\ndef get_all_subset(some_list):\n    subset = [[]]\n    for"], [0.09281530168460668, 0.09433962264150944, 0.25945737163518456, "def add_lists(test_list, test_tup):\n  res = tuple(list(test_tup) + test_list)\n  return (res) \nThe above code is a function to append the given list to the given tuples.\n\ndef last(arr,x):\n    n = len(arr)\n    low = 0\n    high = n - 1\n    res = -1  \n    while (low <= high):\n        mid = (low + high) // 2 \n        if arr[mid] > x:\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            res = mid\n            low = mid + 1\n    return res\nThe above code is a python function to find the last position of an element in a sorted array.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a program to find minimum swap to make two strings identical.\ndef prime(number):\n  if number == 1:\n    return False\n  elif number == 2:\n    return True;\n  else:\n    for x in range(2, number):\n      if number % x == 0:\n        return False\n    return True  \nThe above code is a function to find if the number is prime or not.\ndef shift_left("], [0.11082335212650678, 0.14893617021276595, 0.28074461838447606, "def reverse_vowels(str1):\n\tvowels = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tvowels += char\n\tresult_string = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tresult_string += vowels[-1]\n\t\t\tvowels = vowels[:-1]\n\t\telse:\n\t\t\tresult_string += char\n\treturn result_string\nThe above code is a python function to reverse only the vowels of a given string (where y is not a vowel).\n\nimport re\ndef capital_words_spaces(str1):\n  return re.sub(r\"(\\w)([A-Z])\", r\"\\1 \\2\", str1)\nThe above code is a function to put spaces between words starting with capital letters in a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is to find out whether it is possible to convert a given string to another string by exactly swapping the same set of characters in both the strings. This function takes two strings as input and returns a single integer as output.\n'''"], [0.2763942426103899, 0.21951219512195122, 0.38569307987315277, "def babylonian_squareroot(number):\n    if(number == 0):\n        return 0;\n    g = number/2.0;\n    g2 = g + 1;\n    while(g != g2):\n        n = number/ g;\n        g2 = g;\n        g = (g + n)/2;\n    return g;\nThe above code is a function for computing square roots using the babylonian method.\n\ndef odd_length_sum(arr):\n    Sum = 0\n    l = len(arr)\n    for i in range(l):\n        Sum += ((((i + 1) *(l - i) + 1) // 2) * arr[i])\n    return Sum\nThe above code is a python function to find the sum of all odd length subarrays. https://www.geeksforgeeks.org/sum-of-all-odd-length-subarrays/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the number of swaps required to convert \"str1\" to \"str2\". https://www.geeksforgeeks.org/convert-one-string-into-another-one-by-character-alone/\n\ndef exist(arr) : \n    narr = np.array(arr, int)\n    n = narr.shape[0]\n    # row for final sum\n    for i in range(n)"], [0.08449710373199906, 0.07407407407407407, 0.06582547646546545, "def find_equal_tuple(Input):\n  k = 0 if not Input else len(Input[0])\n  flag = 1\n  for tuple in Input:\n    if len(tuple) != k:\n      flag = 0\n      break\n  return flag\ndef get_equal(Input):\n  return find_equal_tuple(Input) == 1\nThe above code is a function to find whether all the given tuples have equal length or not.\n\ndef count_occurance(s):\n  count = 0\n  for i in range(len(s) - 2):\n    if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):\n      count = count + 1\n  return count\nThe above code is a function to count the number of occurence of the string 'std' in a given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check whether removing 2 charatcters will make two strings anagrams or not.\ndef isSubSequence(string1, string2, m, n):\n    # Base Cases\n    if m == 0:    return True\n    if n == 0:    return False\n \n    # If last characters of two strings are matching\n    if string1[m-1] == string2[n-1]:\n        return is"], [0.12393450414945552, 0.1590909090909091, 0.1758479529538683, "def armstrong_number(number):\n sum = 0\n times = 0\n temp = number\n while temp > 0:\n           times = times + 1\n           temp = temp // 10\n temp = number\n while temp > 0:\n           reminder = temp % 10\n           sum = sum + (reminder ** times)\n           temp //= 10\n if number == sum:\n           return True\n else:\n           return False\nThe above code is a function to check whether the given number is armstrong or not.\n\ndef _sum(arr):  \n    sum=0\n    for i in arr: \n        sum = sum + i      \n    return(sum)  \nThe above code is a python function to find the sum of an array.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python code to do minimun swaps to convert one string in other using the given characters.\ndef Toggle_string(words) : \n    string_to_list = words.split(\" \") \n    final_string = string_to_list[0].capitalize()  \n    for i in range(1, len(string_to_list)): \n        final_string += \"_\"  \n        final_string += string_"], [0.1367441102322189, 0.175, 0.13682033460962637, "def armstrong_number(number):\n sum = 0\n times = 0\n temp = number\n while temp > 0:\n           times = times + 1\n           temp = temp // 10\n temp = number\n while temp > 0:\n           reminder = temp % 10\n           sum = sum + (reminder ** times)\n           temp //= 10\n if number == sum:\n           return True\n else:\n           return False\nThe above code is a function to check whether the given number is armstrong or not.\n\ndef new_tuple(test_list, test_str):\n  return tuple(test_list + [test_str])\nThe above code is a function to create a new tuple from the given string and list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check the minimum swaps required to make the two strings equal.\n\ndef capitalize(my_string): \n    count = 0\n    for i in range(len(my_string)) :  \n        if i==0:\n            if my_string[i]!=my_string[i].upper():\n                 my_string[i]=my_string[i].upper()   \n        elif my_string[i-"], [0.13955984501767876, 0.1956521739130435, 0.2127725104650796, "from copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon\nThe above code is a function to get a colon of a tuple.\n\ndef filter_data(students,h,w):\n    result = {k: s for k, s in students.items() if s[0] >=h and s[1] >=w}\n    return result    \nThe above code is The input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. a function to filter students that have height and weight above the minimum.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is The input is given as 2 strings. The task is to find no. of minimum swaps required to convert a str1 string to str2.\n\ndef findNumber(arr,x) :\n    x+=1\n    a=[]\n    for i in range(len(arr)) :\n        a.append(0)\n    l = len(arr) \n    for i in range(0, l)  :\n        for j in range"], [0.09013375722635923, 0.08064516129032258, 0.17488732571704124, "def find(n,m):  \n    q = n//m \n    return (q)\nThe above code is a python function to find quotient of two numbers (rounded down to the nearest integer).\n\ndef rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums)-2,-1,-1):\n        if nums[i] < nums[i+1]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(\"\".join(nums))\n    return False\nThe above code is a function to create the next bigger number by rearranging the digits of a given number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is to find if it is possible to convert 'str1' to 'str2' by performing at-most 'count' swap operations.\nIt means interchanging any two characters at a time. Also the order of alternating swaps should be same in str1 and str2.\ndef common_words1(s1,s2) :  #Using sorting and comparison of sorted substrings.\n    s1 = s1.lower().split()\n    s2 ="], [0.15349902747297048, 0.13725490196078433, 0.09737154453165356, "def is_Sub_Array(A,B): \n    n = len(A)\n    m = len(B)\n    i = 0; j = 0; \n    while (i < n and j < m):  \n        if (A[i] == B[j]): \n            i += 1; \n            j += 1; \n            if (j == m): \n                return True;  \n        else: \n            i = i - j + 1; \n            j = 0;       \n    return False; \nThe above code is a python function to check whether a list is sublist of another or not.\n\ndef unique_Element(arr):\n    s = set(arr)\n    return len(s) == 1\nThe above code is a python function to check whether a list of numbers contains only one distinct element or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to count swaps between two strings of different length.\ndef is_Dictionary(lst) :\n    if lst == [] : \n        return True\n    dct = {}\n    for i in range((len(lst) - 2) // 2) :  \n        dct[lst[i * 2]] = lst[i * 2 + 1]\n    return dct == lst[len(lst"], [0.1326897235108743, 0.13725490196078433, 0.20613875711967267, "def find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None\nThe above code is a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n\ndef set_left_most_unset_bit(n): \n    if not (n & (n + 1)): \n        return n \n    pos, temp, count = 0, n, 0 \n    while temp: \n        if not (temp & 1): \n            pos = count      \n        count += 1; temp>>=1\n    return (n | (1 << (pos))) \nThe above code is a python function to set the left most unset bit.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is the function to swap any given two letters in the string, the function takes string to swap as input.\ndef gcd(a, b): \n  \n    if (a == 0): \n        return b \n    return gcd(b % a, a) \nThe above code is a python function to compute the gcd of 2 numbers. \ndef gcd(a,b):            \n   while(b): \n       a"], [0.11665388686673159, 0.11666666666666667, 0.12345072059036252, "def intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result\nThe above code is a function to find the intersection of two arrays.\n\ndef count_Primes_nums(n):\n    ctr = 0\n    for num in range(n):\n        if num <= 1:\n            continue\n        for i in range(2,num):\n            if (num % i) == 0:\n                break\n        else:\n            ctr += 1\n    return ctr\nThe above code is a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count minimum swapping of characters.\ndef palindrome(a) :\n z = 0\n n = len(a)\n while (z < (n / 2)) :\n    if (a[z] != a[n - z - 1]) :\n        return False\n    z += 1\n return True\nThe above code is a python program that takes a word and returns true if it is a palindrome, otherwise false.\ndef"], [0.09179460196909148, 0.09836065573770492, 0.2428591326866861, "def check_Consecutive(l): \n    return sorted(l) == list(range(min(l),max(l)+1)) \nThe above code is a python function to check whether the given list contains consecutive numbers or not.\n\ndef divisible_by_digits(startnum, endnum):\n    return [n for n in range(startnum, endnum+1) \\\n                if not any(map(lambda x: int(x) == 0 or n%int(x) != 0, str(n)))]\nThe above code is a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/python-exercises/lambda/python-lambda-exercise-24.php\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to exchange the characters in string to make the string identical.In the program we have counted the number of mismatches.If the mismatches is even it is possible to make them unique in pair of two else it's not possible to make them unique in pair of two.\n15. Python code to create list with all words by sorting letters of each word.\n \n#Initialising list  \ninp = ['Python','Programming', 'is', 'Interest"], [0.147442741941618, 0.2, 0.29776696801332775, "def extract_rear(test_tuple):\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\n  return (res) \nThe above code is a function to extract only the rear index element of each string in the given tuple.\n\ndef min_Jumps(steps, d): \n    (a, b) = steps\n    temp = a \n    a = min(a, b) \n    b = max(temp, b) \n    if (d >= b): \n        return (d + b - 1) / b \n    if (d == 0): \n        return 0\n    if (d == a): \n        return 1\n    else:\n        return 2\nThe above code is a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check for the minimum swaps required to convert one string to the another.\n      \n  \"\"\"\n)\n\n# HW Day 7\n# \n# Notes:\n# - bitwise operators\n# -  &, |\n# - ~\n# - shift operators (<<, >>)\n# \n# - for understanding boolean logic\n# - and, or, xor\n# - note - xor has a bug - in that  True"], [0.2829524605311284, 0.3076923076923077, 0.4380283832109331, "def opposite_Signs(x,y): \n    return ((x ^ y) < 0); \nThe above code is a python function to check whether the given two integers have opposite sign or not.\n\ndef find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] \nThe above code is a python function to find element at a given index after number of rotations.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to calculate minimum swaps required to convert str1 to str2.\nCopied from geeksforgeeks\n'''"], [0.12581998865012178, 0.125, 0.16938437960305266, "def swap_numbers(a,b):\n temp = a\n a = b\n b = temp\n return (a,b)\nThe above code is a function that takes in two numbers and returns a tuple with the second number and then the first number.\n\ndef is_Sub_Array(A,B): \n    n = len(A)\n    m = len(B)\n    i = 0; j = 0; \n    while (i < n and j < m):  \n        if (A[i] == B[j]): \n            i += 1; \n            j += 1; \n            if (j == m): \n                return True;  \n        else: \n            i = i - j + 1; \n            j = 0;       \n    return False; \nThe above code is a python function to check whether a list is sublist of another or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check whether a list is sublist of another or not.\nThe above code is a python function to check whether a list is sublist of another or not.\n\ndef count_Powerlines(grid) :\n    rowLen = len(grid)\n    colLen = len(grid[0])\n    \n    \n    \n    \ndef main() :\n    grid = [['a','b','c','d','e','f"], [0.20778395898173574, 0.2, 0.36673669377931256, "def median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median\nThe above code is a function to find the median length of a trapezium.\n\nimport math \ndef count_divisors(n) : \n    count = 0\n    for i in range(1, (int)(math.sqrt(n)) + 2) : \n        if (n % i == 0) : \n            if( n // i == i) : \n                count = count + 1\n            else : \n                count = count + 2\n    return count % 2 == 0\nThe above code is a python function to check whether the count of divisors is even. https://www.w3resource.com/python-exercises/basic/python-basic-1-exercise-24.php\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the number of characters to be swapped to make two strings in alphabetical order.\n"], [0.13744774581593358, 0.1111111111111111, 0.3254230307116992, "import heapq\ndef larg_nnum(list1,n):\n largest=heapq.nlargest(n,list1)\n return largest\nThe above code is a function that takes in a list and an integer n and returns a list containing the n largest items from the list.\n\ndef count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]\nThe above code is a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " looks for string manipulations,i.e to find number of swaps required to make one string similar,to anothe and is basically compressing all the swaps to the minimum.\nRead all the inputs.\nNote: Array elements are from range 0 to 100.\nNote : All array elements will be positive.\ndef steinGame(arr, N, i, depth) : \n    if depth == N : \n\t\treturn True\n    left = stein"], [0.07717146001442812, 0.03636363636363636, 0.020091612477686413, "def min_of_three(a,b,c): \n      if (a <= b) and (a <= c): \n        smallest = a \n      elif (b <= a) and (b <= c): \n        smallest = b \n      else: \n        smallest = c \n      return smallest \nThe above code is a function to find minimum of three numbers.\n\nimport re\ndef text_match_zero_one(text):\n        patterns = 'ab+?'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\nThe above code is a function that matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that using a mathematical approach. \nVincenty's direct formula rountine (Python)\nfrom __future__ import division\nimport sys\nfrom math import sin, cos, pi, sqrt, fabs # import math library\n\n67. What are the imports needed in your modified program?\n\nfrom math import fabs,sqrt,sin,cos,pi\n\n'''\ndef vincenty(lo1,la1,lo"], [0.11360783772460223, 0.1320754716981132, 0.11932965809832423, "from copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon\nThe above code is a function to get a colon of a tuple.\n\ndef unique_sublists(list1):\n    result ={}\n    for l in list1: \n        result.setdefault(tuple(l), list()).append(1) \n    for a, b in result.items(): \n        result[a] = sum(b)\n    return result\nThe above code is a function to count the number of lists within a list. The function should return a dictionary, where every list is turned to a tuple, and the value of the tuple is the number of its occurrences.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count the number of swaps that was necessary using the two strings. Swapping is used in DNA which is used for atgc which should produce tacc for the same. The result of the function should be mid.\ndef min_max_arrays_exchange(data):\n    small = min(data)\n    index = data.index(small)\n    new_data = []\n    for i in data:\n        new_data."], [0.16956677044324184, 0.14545454545454545, 0.16598710824227486, "def convert_list_dictionary(l1, l2, l3):\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\n     return result\nThe above code is a function to convert more than one list to nested dictionary.\n\ndef divisible_by_digits(startnum, endnum):\n    return [n for n in range(startnum, endnum+1) \\\n                if not any(map(lambda x: int(x) == 0 or n%int(x) != 0, str(n)))]\nThe above code is a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/python-exercises/lambda/python-lambda-exercise-24.php\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps required to make two strings equal.\n\ndef remove_element(input, value):\n    return [input[i] for i in range(len(input)) if value != input[i]]\nRemove Element. Remove all the value in input list which are equal to a specific value and yiels the new list without that value present.\n\n\ndef selectionSort(alist):\n    for i in range(len("], [0.2985773531350658, 0.275, 0.23009622544947977, "import math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); \nThe above code is a function to determine if the sum of the divisors of two integers are the same.\n\ndef large_product(nums1, nums2, N):\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\n    return result\nThe above code is a function to find the specified number of largest products from two given lists, selecting one factor from each list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps required to convert one string to other.\ndef alternate(str1): \n  \n    dict = {} \n    str1 = sorted(str1) \n    print(str1)\n\n    for i in range(len(str1)): \n        for j in range(i+1,len(str1)): \n \n            if str1[i] == str1[j"], [0.20554579720852445, 0.17777777777777778, 0.22872885292230766, "def armstrong_number(number):\n sum = 0\n times = 0\n temp = number\n while temp > 0:\n           times = times + 1\n           temp = temp // 10\n temp = number\n while temp > 0:\n           reminder = temp % 10\n           sum = sum + (reminder ** times)\n           temp //= 10\n if number == sum:\n           return True\n else:\n           return False\nThe above code is a function to check whether the given number is armstrong or not.\n\nimport bisect\ndef right_insertion(a, x):\n    return bisect.bisect_right(a, x)\nThe above code is a function to locate the right insertion point for a specified value in sorted order.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to Find the minimum number of swaps required to sort the string.\n\ndef prime_number_in_given_range(lower_limit,upper_limit):\n    for i in range(lower_limit,upper_limit):\n        if i > 1:\n            for j in range(2,i):\n                if (i % j) == 0:\n                    break\n                else:\n                        print(i)\nThe above code is"], [0.11623182446731398, 0.09803921568627451, 0.13551623611277097, "def pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count \nThe above code is a python function to count the number of positive numbers in a list.\n\ndef is_Sub_Array(A,B): \n    n = len(A)\n    m = len(B)\n    i = 0; j = 0; \n    while (i < n and j < m):  \n        if (A[i] == B[j]): \n            i += 1; \n            j += 1; \n            if (j == m): \n                return True;  \n        else: \n            i = i - j + 1; \n            j = 0;       \n    return False; \nThe above code is a python function to check whether a list is sublist of another or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check whether the two strings can be interchanged or not.\ndef find_Max(list) :\n    max_num = list[0]\n    for i in list :\n        if i > max_num :\n            max_num = i\n    return max_num\nThe above code is a python function to find the biggest number in the given list.\ndef string_column_sort(list) : \n    if ("], [0.15833535029834037, 0.1568627450980392, 0.1883031384482309, "def sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos\nThe above code is a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\n\ndef max_sum_list(lists):\n return max(lists, key=sum)\nThe above code is a function that returns the list in a list of lists whose sum of elements is the highest.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in two strings and returns the min. number of swaps required to form an Anagram.\ndef cherrypick(file, search):\n  with open(file, 'r') as f:\n    text = f.read()\n    text = text.lower()\n    text = text.split('\\n')\n    print('Number of found line: ' + str(text.count(search)) + '\\n')\n    for"], [0.18166436872908567, 0.2222222222222222, 0.1880272627928832, "def max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max\nThe above code is a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\n\ndef min_Jumps(steps, d): \n    (a, b) = steps\n    temp = a \n    a = min(a, b) \n    b = max(temp, b) \n    if (d >= b): \n        return (d + b - 1) / b \n    if (d == 0): \n        return 0\n    if (d == a): \n        return 1\n    else:\n        return 2\nThe above code is a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps required to convert even string to odd string.\ndef swap_xyz(arr):\n    xyz=[]\n    for i in range(len(arr)):\n\tif arr[i][0]==\"#\":\n\t    for j in range(len(arr)):\n\t\t    if arr[i][2]==arr[j][1]:\n\t\t        xyz.append(arr["], [0.12846131323861235, 0.1276595744680851, 0.21346678136085204, "def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False\nThe above code is a python function to check whether the given number can be represented as the difference of two squares or not.\n\ndef set_middle_bits(n):  \n    n |= n >> 1; \n    n |= n >> 2; \n    n |= n >> 4; \n    n |= n >> 8; \n    n |= n >> 16;  \n    return (n >> 1) ^ 1\ndef toggle_middle_bits(n): \n    if (n == 1): \n        return 1\n    return n ^ set_middle_bits(n) \nThe above code is a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to calculate the minimum swap required.\ndef removeAll(string,target) : \n    string = list(string) \n    i = 0\n    while True : \n        if i == len(string) : \n            break \n        if string[i] == target : \n            del(string[i]) \n            continue \n        i += 1\n    return (0)\nThe above code is a python"], [0.10610552836551843, 0.14285714285714285, 0.17277350123779672, "import sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i\nThe above code is a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\ndef max_run_uppercase(test_str):\n  cnt = 0\n  res = 0\n  for idx in range(0, len(test_str)):\n    if test_str[idx].isupper():\n      cnt += 1\n    else:\n      res = cnt\n      cnt = 0\n  if test_str[len(test_str) - 1].isupper():\n    res = cnt\n  return (res)\nThe above code is a function to find maximum run of uppercase characters in the given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find minimum swaps required in string formation to close an anagram.\n\ndef give_first_index(input_given):\n    input_given = input_given.split()\n    subject = input('ENter a subject')\n    for word in range(len(input_given)):\n        if input_given[word] == subject:\n            return word\n            break\nThe above code is a function to identify the subject and its"], [0.10118958035540203, 0.14583333333333334, 0.17402776524345626, "def subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks\nThe above code is a function to sort a list of tuples using the second value of each tuple.\n\ndef list_to_float(test_list):\n  res = []\n  for tup in test_list:\n    temp = []\n    for ele in tup:\n      if ele.isalpha():\n        temp.append(ele)\n      else:\n        temp.append(float(ele))\n    res.append((temp[0],temp[1])) \n  return res\nThe above code is a function to convert all possible convertible elements in a list of lists to floats.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check for minimum swaps required for converging to str2 from str1.\n\n#if __name__ == \"__main__\"\n# imports\nfrom collections import OrderedDict \ndef dupli_in_list(list1):\n    a = {}\n    val = []\n    check = [] \n    for i in list1: \n        temp = []\n        count = 1\n        if i not in a:"], [0.13557908412276834, 0.17777777777777778, 0.34340438864078493, "def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums\nThe above code is a function to sort a list of elements.\n\ndef multiple_to_single(L):\n  x = int(\"\".join(map(str, L)))\n  return x\nThe above code is a function to join a list of multiple integers into a single integer.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find minimum swaps to change a string to another using a single traversal of given string.\nl=[]\nn=int(input(\"Enter number of elements:\"))\nfor i in range(0,n):\n    x=input(\"Enter the numbers into the array:\")\n    l.append(x)\nj=0\nk=' '\nm=[]\nsmall=min(l[0],l[len(l)-1"], [0.09065439253166695, 0.09523809523809523, 0.14255622426308817, "def count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res\nThe above code is a function to count bidirectional tuple pairs.\n\nimport math\ndef wind_chill(v,t):\n windchill = 13.12 + 0.6215*t -  11.37*math.pow(v, 0.16) + 0.3965*t*math.pow(v, 0.16)\n return int(round(windchill, 0))\nThe above code is a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes two strings and output the number of swaps needed or print \"Not Possible\", with exactly 0.5 number of swaps.\nInput(s)\nFirst line starts with 3 space separated integers: n, m and d.n is the maximum number of ice creams Match will eat, d is the maximum distance between two ice creams Match can eat, and m is the number of ice creams he's eating in the video at one time.\nn m"], [0.08191866197503324, 0.0625, 0.0421638359700451, "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x\nThe above code is a python function to find the number of divisors of a given integer.\n\ndef find_first_occurrence(A, x):\n    (left, right) = (0, len(A) - 1)\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if x == A[mid]:\n            result = mid\n            right = mid - 1\n        elif x < A[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return result\nThe above code is a function to find the index of the first occurrence of a given number in a sorted array.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes two strings and checks whether the strings can be rearranged to form a palindrome\ndef checkAnagrams(s1, s2): \n  \n    # the sorted strings are checked  \n    if(sorted(s1)== sorted(s2)): \n        print(\"The strings are anagrams.\")  \n    else: \n        print(\"The strings aren't anagrams.\")          \nThe above code"], [0.09275214784210448, 0.125, 0.22311934269715855, "def is_sublist(l, s):\n\tsub_set = False\n\tif s == []:\n\t\tsub_set = True\n\telif s == l:\n\t\tsub_set = True\n\telif len(s) > len(l):\n\t\tsub_set = False\n\telse:\n\t\tfor i in range(len(l)):\n\t\t\tif l[i] == s[0]:\n\t\t\t\tn = 1\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\n\t\t\t\t\tn += 1\t\t\t\t\n\t\t\t\tif n == len(s):\n\t\t\t\t\tsub_set = True\n\treturn sub_set\nThe above code is a function to check whether a list contains the given sublist or not.\n\ndef find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False\nThe above code is a function to check if a string is present as a substring in a given list of string values.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the total number of swap in make one of the given string as the other one. The strings are converted into two strings in order to check the change which is need to be applied on the string.\n\nOBSERVATIONS:     \n1) This function() is used to make a main function for sorting criteria for the input file. The function has one input(the infile), returns no output and has one parameter(the file type).\n\n"], [0.07918725283941637, 0.061224489795918366, 0.060854139414488535, "def list_to_float(test_list):\n  res = []\n  for tup in test_list:\n    temp = []\n    for ele in tup:\n      if ele.isalpha():\n        temp.append(ele)\n      else:\n        temp.append(float(ele))\n    res.append((temp[0],temp[1])) \n  return res\nThe above code is a function to convert all possible convertible elements in a list of lists to floats.\n\ndef group_tuples(Input): \n\tout = {} \n\tfor elem in Input: \n\t\ttry: \n\t\t\tout[elem[0]].extend(elem[1:]) \n\t\texcept KeyError: \n\t\t\tout[elem[0]] = list(elem) \n\treturn [tuple(values) for values in out.values()] \nThe above code is a function to find common first element in given list of tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " helps to find if 2 strings are one swap apart.\n\ndef abs_diff(array_of_strings,n): \n    for i in range( n ): \n        for j in range( n ): \n            if abs(i - j) == 1 : \n                array_of_strings[i].sendline(array_of_strings[j][0]) \n    return 'done' \nThe above code is a server for"], [0.13020421703421353, 0.19607843137254902, 0.25205968802521905, "def even_ele(test_tuple, even_fnc): \n\tres = tuple() \n\tfor ele in test_tuple: \n\t\tif isinstance(ele, tuple): \n\t\t\tres += (even_ele(ele, even_fnc), ) \n\t\telif even_fnc(ele): \n\t\t\tres += (ele, ) \n\treturn res \ndef extract_even(test_tuple):\n  res = even_ele(test_tuple, lambda x: x % 2 == 0)\n  return (res) \nThe above code is a function to remove uneven elements in the nested mixed tuple.\n\ndef catalan_number(num):\n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num\nThe above code is a function which returns nth catalan number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function which returns the minimum swaps required to convert the first style to second style. If we need even number of swap the string can be differend / else not.\n'''\n\n\ndef largestItemAssociation(itemAssociation):\n    items = []\n    max_tot = 0\n    items_packages = []\n    tot = 0\n    ma = 0\n    items = itemAssociation.split(',')\n    dict = {}\n   "], [0.19297846131400018, 0.1935483870967742, 0.2643089015501344, "def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s \nThe above code is a python function to remove first and last occurrence of a given character from the string.\n\ndef swap_List(newList): \n    size = len(newList) \n    temp = newList[0] \n    newList[0] = newList[size - 1] \n    newList[size - 1] = temp  \n    return newList \nThe above code is a python function to interchange the first and last elements in a list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check if a set of strings is a rotation of the other using only one call to isSubstring.\n\"\"\""], [0.0929243702560607, 0.09230769230769231, 0.26859961436511115, "def substract_elements(test_tup1, test_tup2):\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n  return (res) \nThe above code is a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n\nfrom itertools import combinations \ndef find_combinations(test_list):\n  res = [(b1 + a1, b2 + a2) for (a1, a2), (b1, b2) in combinations(test_list, 2)]\n  return (res) \nThe above code is a function to find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function allowing us to find the number of swaps we need to make to match the two strings of equal length. It is a code made to compare two strings for its characters and find out how many swaps would need to be done in order to match the two strings.\ndef unique(list):\n    \"\"\"\n    It is a way to check if 'list' has any duplicate elements.\n    \"\"\"\n    # Convert the list into a unique list\n    return list if"], [0.19509896792763368, 0.23809523809523808, 0.31123683732807855, "def find_First_Missing(array,start=0,end=None):\n    if end is None:\n      end = len(array) - 1   \n    if (start > end): \n        return end + 1\n    if (start != array[start]): \n        return start; \n    mid = int((start + end) / 2) \n    if (array[mid] == mid): \n        return find_First_Missing(array,mid+1,end) \n    return find_First_Missing(array,start,mid) \nThe above code is a python function to find the smallest missing number from a sorted list of natural numbers.\n\ndef Diff(li1,li2):\n    return list(set(li1)-set(li2)) + list(set(li2)-set(li1))\n \nThe above code is a python function to get the difference between two lists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to calculate a minimum of the number of swaps required to transform a string into another string.\ndef non_repeat(line) :      \n    i = 1\n    ans = -1  \n    while i < len(line) :  \n        if line[:i] == line[i+1:] : \n            ans = i \n        i += 1 \n    if ans == -1 : \n        return -1 "], [0.1936642084865379, 0.19047619047619047, 0.21989094358023342, "def snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))\nThe above code is a function to convert a snake case string to camel case string.\n\ndef re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\nThe above code is a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in 2 strings and that returns the minimum no of swaps required to convert str1 to str2.\n\ndef time_conversion(s): \n    if(s[-2:]=='PM' and int(s[:2])<12):\n        c=str( int(s[:2]) + 12 )\n        ans=c+s[2:-2]\n    elif (s[-2:]=="], [0.09657314401585683, 0.109375, 0.10551098903365241, "import math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN \nThe above code is a python function to find the next perfect square greater than a given number.\n\ndef validate(n): \n    for i in range(10): \n        temp = n;  \n        count = 0; \n        while (temp): \n            if (temp % 10 == i): \n                count+=1;  \n            if (count > i): \n                return False\n            temp //= 10; \n    return True\nThe above code is a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function that  takes in two strings, checks whether they are equal or not. If they are not equal, the code counts the missmatching characters in the String. Finally returns the number of missmatches either divided by 2 or the string Not Possible to show the two strings are not substitution of the each other.\ndef append_All_Elements(input): \n  ans = \"\"  \n  for i in input: \n    ans += str("], [0.17008416462255474, 0.15217391304347827, 0.21304426495230444, "def all_Characters_Same(s) :\n    n = len(s)\n    for i in range(1,n) :\n        if s[i] != s[0] :\n            return False\n    return True\nThe above code is a python function to check whether all the characters are same or not.\n\ndef unique_sublists(list1):\n    result ={}\n    for l in list1: \n        result.setdefault(tuple(l), list()).append(1) \n    for a, b in result.items(): \n        result[a] = sum(b)\n    return result\nThe above code is a function to count the number of lists within a list. The function should return a dictionary, where every list is turned to a tuple, and the value of the tuple is the number of its occurrences.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check whether number of swaps are odd or even.\n\ndef int2English_Words(n) :\n    Zero_Nine =[\"Zero\",  \"One\", \"Two\", \"Three\",  \"Four\", \"Five\",  \"Six\", \"Seven\", \"Eight\", \"Nine\"] \n    One_Nine0 =[\"Ten\",  \"Eleven\",  \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\","], [0.17049738477458415, 0.18518518518518517, 0.21386353690896634, "def re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\nThe above code is a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\nimport re\ndef change_date_format(dt):\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)\nThe above code is a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " a function that takes in strings of equal length, and returns the minimum number of swaps required to get the first string into the same order as the second string.\ndef is_prime(n): \n    flag = 0\n    for i in range(2, n//2+1, 1): \n        if n % i == 0 : \n          flag = 1\n          break \n    if(flag==0) : \n      print(\"n is"], [0.15948955448156307, 0.16393442622950818, 0.30430008615331794, "def bell_Number(n): \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1] \n    return bell[n][0] \nThe above code is a python function to find nth bell number.\n\ndef pair_wise(l1):\n    temp = []\n    for i in range(len(l1) - 1):\n        current_element, next_element = l1[i], l1[i + 1]\n        x = (current_element, next_element)\n        temp.append(x)\n    return temp\nThe above code is a function to return a list of all pairs of consecutive items in a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function which takes two strings and returns the minimum number of swaps required to make one string equal to the other.\ndef print_Eve(l, r) : \n    integer = l\n    while l <= r : \n        if l % 2 != 0 : \n            print(l, end = \" \") \n        l = l + 1\n  \nThe above function prints the odd numbers from given lower range to upper range.\n"], [0.1610996155376285, 0.1282051282051282, 0.21024171250137935, "def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num \nThe above code is a python function to find the largest number that can be formed with the given list of digits.\n\ndef find_min_diff(arr,n): \n    arr = sorted(arr) \n    diff = 10**20 \n    for i in range(n-1): \n        if arr[i+1] - arr[i] < diff: \n            diff = arr[i+1] - arr[i]  \n    return diff \nThe above code is a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum swap to make two strings. https://www.geeksforgeeks.org/find-minimum-no-of-swap-required-for-capitalizing-the-given-string/\n\n# <H1>Dynamic Programming</H1></h2>\ndef stepPerms(n):\n        if n<0:\n            return 0\n        if n==0:\n            return 1\n        M ="], [0.12024429225558983, 0.07692307692307693, 0.1041209082523207, "def find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] \nThe above code is a python function to find element at a given index after number of rotations.\n\ndef cube_Sum(n): \n    sum = 0\n    for i in range(1,n + 1): \n        sum += (2*i)*(2*i)*(2*i) \n    return sum\nThe above code is a python function to find the cube sum of first n even natural numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check if it is possible to obtain str2 by swapping two characters in str1.\n\ndef multiply(num1,num2) : \n    res = [0] * (len(num1) + len(num2)) \n                             \n    sign = -1 if (num1[0] < 0 and num2[0] > 0 or num1[0] > 0 and num2[0] < 0)"], [0.15420171551987108, 0.17073170731707318, 0.1129195664327639, "def multiply_elements(test_tup):\n  res = tuple(i * j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) \nThe above code is a function that takes as input a tuple of numbers (t_1,...,t_{N+1}) and returns a tuple of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\n\ndef get_pairs_count(arr, sum):\n    count = 0  \n    for i in range(len(arr)):\n        for j in range(i + 1,len(arr)):\n            if arr[i] + arr[j] == sum:\n                count += 1\n    return count\nThe above code is a python function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a list of numbers and the sum,\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to return minimum number of swaps \ndef find_minimum(str1,str2):\n    str1 = str(str1)\n    str2 = str(str2)\n    if str1.find(' ') != -1 or str2.find(' ') !=-1 : \n        return (\"-1\")\n    else : \n        return (abs(len(str1)-len(str2)))\nThe above"], [0.1343889368089722, 0.1276595744680851, 0.2852529072253758, "import re\ndef text_lowercase_underscore(text):\n        patterns = '^[a-z]+_[a-z]+$'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\nThe above code is a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n\ndef odd_length_sum(arr):\n    Sum = 0\n    l = len(arr)\n    for i in range(l):\n        Sum += ((((i + 1) *(l - i) + 1) // 2) * arr[i])\n    return Sum\nThe above code is a python function to find the sum of all odd length subarrays. https://www.geeksforgeeks.org/sum-of-all-odd-length-subarrays/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is used to find the minimum swaps required to convert first string str1 to second string str2. \n \ndef swap_case(s) : \n    Ans = \"\" \n    for i in range(len(s)) : \n        if s[i] >= 'a' and s[i] <= 'z' :  \n            Ans+=s[i]-32\n        elif s[i] >= 'A' and s[i"], [0.1013189972013108, 0.13636363636363635, 0.1626279305034563, "def bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \nThe above code is a function to find the number of ways to partition a set of Bell numbers.\n\ndef division_elements(test_tup1, test_tup2):\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) \nThe above code is a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the number of changes needed.\ndef smallestSubWithAtMostKDistinct(str1, K) : \n    n = len(str1)  \n    count = [0 for i in range(256)]  \n    cur_len = 0\n    max_len = 0\n    for i in range(n) : \n        if count[ord(str1[i])] == 0: \n            cur_"], [0.24280327655818285, 0.2631578947368421, 0.28490870992948325, "def last(arr,x):\n    n = len(arr)\n    low = 0\n    high = n - 1\n    res = -1  \n    while (low <= high):\n        mid = (low + high) // 2 \n        if arr[mid] > x:\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            res = mid\n            low = mid + 1\n    return res\nThe above code is a python function to find the last position of an element in a sorted array.\n\ndef check_smaller(test_tup1, test_tup2):\n  return all(x > y for x, y in zip(test_tup1, test_tup2))\nThe above code is a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python program to find the minimum number of swaps required to convert str1 string into str2 string.\ndef swap(a=list) :\n    first = a[0]\n    a[0] = a[len(a)-1]\n    a[len(a)-1] = first\n    return a\ndef rotate(a=list) : \n    a.insert(0, a.pop())\n    return a\ndef encryption"], [0.1468342232652735, 0.25925925925925924, 0.3407232838492009, "def find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0\nThe above code is a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\ndef count_samepair(list1,list2,list3):\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\n    return result\nThe above code is a function to count number items that are identical in the same position of three given lists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to convert a binary string to the closest possible string consisting of only 0s and 1s.\n"], [0.0784821644194941, 0.02702702702702703, 0.03443085853973724, "def min_Jumps(steps, d): \n    (a, b) = steps\n    temp = a \n    a = min(a, b) \n    b = max(temp, b) \n    if (d >= b): \n        return (d + b - 1) / b \n    if (d == 0): \n        return 0\n    if (d == a): \n        return 1\n    else:\n        return 2\nThe above code is a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\n\ndef sum_odd(n): \n    terms = (n + 1)//2\n    sum1 = terms * terms \n    return sum1  \ndef sum_in_range(l,r): \n    return sum_odd(r) - sum_odd(l - 1)\nThe above code is a python function to find the sum of all odd natural numbers within the range l and r.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is for the question \"Minimum Swaps\" on codechef.\ndef min_distance(coins,n):\n    k = 10\n    return coins[k]\nThe above is a code question on Codechef.\n"], [0.14419644488213176, 0.12, 0.13066929819256967, "def find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] \nThe above code is a python function to find element at a given index after number of rotations.\n\ndef max_of_nth(test_list, N):\n  res = max([sub[N] for sub in test_list])\n  return (res) \nThe above code is a function which given a matrix represented as a list of lists returns the max of the n'th column.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " checks whether the number of swaps required to make str1 and str2 anagram i.e. made equal using Counter method defined in counter_method() and min_Swaps() defined above.\ndef min_removestrings(s1,s2) :  \n    count = 0\n    for ch in s2 : \n        if ch  not in s1 :  \n            count += 1\n    for ch in s1 : \n        if"], [0.13849937738140583, 0.16981132075471697, 0.1517239160400834, "def count_Primes_nums(n):\n    ctr = 0\n    for num in range(n):\n        if num <= 1:\n            continue\n        for i in range(2,num):\n            if (num % i) == 0:\n                break\n        else:\n            ctr += 1\n    return ctr\nThe above code is a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\ndef concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) \nThe above code is a function to concatenate each element of tuple by the delimiter.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in two strings and returns count of swaps required to convert the first string into second string.\ndef get_Distinct_Nos(arr, n):\n    res = 0\n    for i in range(0, n):\n        res = res ^ arr[i]\n \n    return res\nThe above code is a function that takes in an array of non-zero  positive numbers and a positive integer n \nand returns the n"], [0.12808799660050077, 0.10638297872340426, 0.07463774970071828, "def max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    \nThe above code is a python function to find a pair with highest product from a given array of integers.\n\ndef largest_neg(list1): \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max\nThe above code is a python function to find the largest negative number from the given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the difference of odd integers from the given stringsstr1 & str2 .\ndef editdistance(str1, str2, leng, lenny) : \n    if (leng == 0) :  \n        return (lenny-leng)      \n    elif (lenny == 0) :  \n        return (leng-lenny)      \n    elif (str1[leng-1] == str"], [0.07728804900568534, 0.078125, 0.12388369516489331, "def adjac(ele, sub = []): \n  if not ele: \n     yield sub \n  else: \n     yield from [idx for j in range(ele[0] - 1, ele[0] + 2) \n                for idx in adjac(ele[1:], sub + [j])] \ndef get_coordinates(test_tup):\n  return list(adjac(test_tup))\nThe above code is a function to extract all the adjacent coordinates of the given coordinate tuple.\n\ndef pair_wise(l1):\n    temp = []\n    for i in range(len(l1) - 1):\n        current_element, next_element = l1[i], l1[i + 1]\n        x = (current_element, next_element)\n        temp.append(x)\n    return temp\nThe above code is a function to return a list of all pairs of consecutive items in a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is works only when the operators or operations count is even to succeed. Otherwise returns 'Not Possible'.\n\n# lambda expressions\n# The map() function in Python takes in a function and a list as argument. The function is called with a lambda function and a list and a new list is returned which contains all the lambda modified items returned by that function for each item.\n# ```\n# map(function, list)\n# ```\n#### Example here\n# Python program"], [0.13684777393422176, 0.16326530612244897, 0.1732307587670102, "import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\nThe above code is a function to merge three dictionaries into a single dictionary.\n\ndef unique_sublists(list1):\n    result ={}\n    for l in list1: \n        result.setdefault(tuple(l), list()).append(1) \n    for a, b in result.items(): \n        result[a] = sum(b)\n    return result\nThe above code is a function to count the number of lists within a list. The function should return a dictionary, where every list is turned to a tuple, and the value of the tuple is the number of its occurrences.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes two strings of same size and returns the minimum number of swaps users will have to make to get a true anagram meaning a string that contains the same characters.\nimport os \ndef rename_files():\n   #photopath = os.path.abspath('SauShe.jpg');\n    #photopath = os.path.abspath('Deluxe.jpg');\n   # photopath = os.path.abspath"], [0.10541280035618018, 0.14, 0.1947574458130103, "def sum_negativenum(nums):\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\n  return sum(sum_negativenum)\nThe above code is a function to calculate the sum of the negative numbers of a given list of numbers.\n\ndef get_ludic(n):\n\tludics = []\n\tfor i in range(1, n + 1):\n\t\tludics.append(i)\n\tindex = 1\n\twhile(index != len(ludics)):\n\t\tfirst_ludic = ludics[index]\n\t\tremove_index = index + first_ludic\n\t\twhile(remove_index < len(ludics)):\n\t\t\tludics.remove(ludics[remove_index])\n\t\t\tremove_index = remove_index + first_ludic - 1\n\t\tindex += 1\n\treturn ludics\nThe above code is a function to get all lucid numbers smaller than or equal to a given integer.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate the minimum swap required to make a string same.\n\ndef power(base,exp):\n  try:\n    return(base**exp)\n  except:\n    if isinstance(exp,str):  return(\"Not possible to powr\")   \n    else:  return(\"Type error\")\nThe above code is a function to calculate the power of an exponent.\nWe catch the type error if an exponent is entered of the wrong"], [0.16633711126176892, 0.19047619047619047, 0.20890650835973615, "def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums\nThe above code is a function to sort a list of elements.\n\ndef neg_nos(list1):\n  out = []\n  for num in list1: \n    if num < 0: \n      out.append(num)\n  return out \nThe above code is a python function to return the negative numbers in a list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum swaps required to make two string equal.\nimport math\n\ndef isSquare(x): \n    s = int(math.sqrt(x)) \n    return s*s == x \n      \ndef isFib(x): \n    return isSquare(5*x*x + 4) or isSquare(5*x*x - 4) \n      \nx  = int(input(\""], [0.09080911726054922, 0.06976744186046512, 0.07230162033082575, "def get_max_sum (n):\n\tres = list()\n\tres.append(0)\n\tres.append(1)\n\ti = 2\n\twhile i<n + 1:\n\t\tres.append(max(i, (res[int(i / 2)] \n\t\t\t\t\t\t+ res[int(i / 3)] +\n\t\t\t\t\t\t\tres[int(i / 4)]\n\t\t\t\t\t\t+ res[int(i / 5)])))\n\t\ti = i + 1\n\treturn res[n]\nThe above code is a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\ndef combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result\nThe above code is a function to find all possible combinations of the elements of a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to determine \n\nimport sys\n\nclass Solution:\n    def fx(self,str1):\n        res=[]\n        prev_C = ''\n        prev_Num = 0\n        repeat_count = 0\n        for i in 'abcdefghijklmnopqrstuvwxyz':\n            if i not in str1:\n                temp=[]\n                temp.append(i)\n                res."], [0.09944236841128248, 0.1076923076923077, 0.1344992415051489, "def split_two_parts(list1, L):\n    return list1[:L], list1[L:]\nThe above code is a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n\ndef filter_data(students,h,w):\n    result = {k: s for k, s in students.items() if s[0] >=h and s[1] >=w}\n    return result    \nThe above code is The input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. a function to filter students that have height and weight above the minimum.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is the function that counts how many swaps will be needed to convert one string to other. If there will be no integer proper multiple, it will return \"Not Possible\".\n\nUse the above functions in classes or methods. Create regular classes and objects including class attributes, static methods and instance methods.\n\nDon't apply any part of above functions in the print(). \n\nRefer the following link image \n'''"], [0.12247940631618741, 0.15517241379310345, 0.23711061627635927, "def get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)\nThe above code is a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.\n\ndef find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None\nThe above code is a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to calculate the minimum or required number that can be eliminated from the string str1 in order to make it an anagram of the string str2.\n\ndef solve(cakes, answer):\n    a = [-1 if p == '-' else 0 for p in cakes]\n    while a[-1]:\n        i = a.index(-1)\n        a[i:] = [n - 1 for n in a[i:]]\n"], [0.103422281294025, 0.14893617021276595, 0.18882995497488708, "import re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))\nThe above code is a function to convert the given snake case string to camel case string.\n\ndef get_median(arr1, arr2, n):\n  i = 0\n  j = 0\n  m1 = -1\n  m2 = -1\n  count = 0\n  while count < n + 1:\n    count += 1\n    if i == n:\n      m1 = m2\n      m2 = arr2[0]\n      break\n    elif j == n:\n      m1 = m2\n      m2 = arr1[0]\n      break\n    if arr1[i] <= arr2[j]:\n      m1 = m2\n      m2 = arr1[i]\n      i += 1\n    else:\n      m1 = m2\n      m2 = arr2[j]\n      j += 1\n  return (m1 + m2)/2\nThe above code is a function to find the median of two sorted lists of same size.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps required between two same length strings.\ndef strstr(A,B):\n    if B in A:\n        return A.index(B)\n    else:\n        return -1\nThe above code is a function to find the first occurrence of a substring in another string.\ndef intersection_lists(arr1, arr2):\n    return list(set(list1).intersection(list2))\nThe"], [0.11946531078566258, 0.13559322033898305, 0.2608783480871235, "def eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))\nThe above code is a function to find the Eulerian number a(n, m).\n\ndef max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    \nThe above code is a python function to find a pair with highest product from a given array of integers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", "  is a python function to find the minimum swaps to be done to convert a str1 to str2 of the same lengths and contains only 0s and 1s.\ndef printRP(arr) : \n    st = \"\"\n    for i in range(len(arr)) : \n        st = st + arr[i] \n    return st\nThe above code is a python function to rearrange a given array such that every element is replaced by its rank"], [0.0989932358457249, 0.1346153846153846, 0.11002570917669756, "def re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\nThe above code is a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\ndef power_base_sum(base, power):\n    return sum([int(i) for i in str(pow(base, power))])\nThe above code is a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes two strings as its arguments and returns the minimum number of perfect pairs which two strings can differ in whole.\ndef longestPrefix(s) : \n    n = len(s)  \n    i = 1\n    current = 0\n    ans = -1\n    while i <= len(s) :  \n        j = 1\n        count = 0\n        while j <= len(s) :  \n            if (s["], [0.1653523030145529, 0.16666666666666666, 0.1850956346800494, "def find_first_occurrence(A, x):\n    (left, right) = (0, len(A) - 1)\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if x == A[mid]:\n            result = mid\n            right = mid - 1\n        elif x < A[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return result\nThe above code is a function to find the index of the first occurrence of a given number in a sorted array.\n\ndef tuple_str_int(test_str):\n  res = tuple(int(num) for num in test_str.replace('(', '').replace(')', '').replace('...', '').split(', '))\n  return (res) \nThe above code is a function to convert tuple string to integer tuple.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps required for converting str1 to str2.\ndef IsRotation(str1,str2) : \n    n = len(str1)\n    if n==len(str2) and n>0:\n        str1 += str1     \n        return (1 if str2 in str1 else 0)\n    else:\n        return 0\nThe above code is a function to check if str1"], [0.17393590422952318, 0.2127659574468085, 0.25698049026972236, "def find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0\nThe above code is a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\ndef last_Digit_Factorial(n): \n    if (n == 0): return 1\n    elif (n <= 2): return n  \n    elif (n == 3): return 6\n    elif (n == 4): return 4 \n    else: \n      return 0\nThe above code is a python function to find the last digit in factorial of a given number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the min swaps required to convert a binary string to the string.\nTime Complexity:\n    O(n)O(n) time where nn is the length of string and nn is the length of str2.\ndef minChanges(str1,str2) : \n    count1 = count2 = 0\n    for i in range(len(str1)) : \n        if str1[i] != str"], [0.15585660352369105, 0.21875, 0.2611889568046292, "def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     \nThe above code is a function to find whether a given array of integers contains any duplicate element.\n\ndef sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos\nThe above code is a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in two string and returns the minnumber of swaps required in sequence to make string1 identical to string2.\n"], [0.12523526950638206, 0.09615384615384616, 0.15589081983388756, "def swap_List(newList): \n    size = len(newList) \n    temp = newList[0] \n    newList[0] = newList[size - 1] \n    newList[size - 1] = temp   \n    return newList \nThe above code is a python function to interchange the first and last element in a given list.\n\ndef set_middle_bits(n):  \n    n |= n >> 1; \n    n |= n >> 2; \n    n |= n >> 4; \n    n |= n >> 8; \n    n |= n >> 16;  \n    return (n >> 1) ^ 1\ndef toggle_middle_bits(n): \n    if (n == 1): \n        return 1\n    return n ^ set_middle_bits(n) \nThe above code is a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum swap between two strings.\n\ndef Power_Set(string ): \n    n = len(string)\n    pow_set_all = list()\n    for i in range(2**n):\n        subset = \"\"\n        for j in range(n):     \n            if (i & (1 << j)) > 0:\n                subset += string[j]   \n        pow_set_all.append"], [0.09730291163251488, 0.10204081632653061, 0.0761763059844878, "def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s \nThe above code is a python function to remove first and last occurrence of a given character from the string.\n\nfrom collections import defaultdict\ndef max_occurrences(nums):\n    dict = defaultdict(int)\n    for i in nums:\n        dict[i] += 1\n    result = max(dict.items(), key=lambda x: x[1]) \n    return result[0]\nThe above code is a function to find the item with maximum frequency in a given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check if no. of swaps needed is even or odd.\nfrom math import sqrt,pow\ndef min_sub_array(lst,s):\n  minlen = len(lst) + 1 #setting, checking for infinity by defualt\n  for i in range(0,len(lst)):\n    for j in range(i+1,len(lst)+1):\n      if sum(l"], [0.0900329605474223, 0.1346153846153846, 0.15503165392560753, "def max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    \nThe above code is a python function to find a pair with highest product from a given array of integers.\n\nimport re\ndef text_match_wordz(text):\n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\nThe above code is a function that matches a word containing 'z'.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " matches two strings and returns the count of minimum swaps required.\nimport re \nwith open('abc.txt', 'r') as fh:   \n    output = re.search('.*z.*y.*x.*', fh.read())\n    print(output) \nThis is a method combining to read a text file and searching for the given pattern. O/P is a tuple.\nS = \"python\"\nS = S[0:"], [0.09535660798117247, 0.11538461538461539, 0.22613775625787802, "def min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min\nThe above code is a function to find the minimum product from the pairs of tuples within a given list.\n\ndef find_kth(arr1, arr2, k):\n\tm = len(arr1)\n\tn = len(arr2)\n\tsorted1 = [0] * (m + n)\n\ti = 0\n\tj = 0\n\td = 0\n\twhile (i < m and j < n):\n\t\tif (arr1[i] < arr2[j]):\n\t\t\tsorted1[d] = arr1[i]\n\t\t\ti += 1\n\t\telse:\n\t\t\tsorted1[d] = arr2[j]\n\t\t\tj += 1\n\t\td += 1\n\twhile (i < m):\n\t\tsorted1[d] = arr1[i]\n\t\td += 1\n\t\ti += 1\n\twhile (j < n):\n\t\tsorted1[d] = arr2[j]\n\t\td += 1\n\t\tj += 1\n\treturn sorted1[k - 1]\nThe above code is a function to find kth element from the given two sorted arrays.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find minimum swaps needed between the two strings to match.\n\ndef isPerfectCube(x): \n    x = abs(x) \n    return int(round(x ** (1. / 3))) ** 3 == x \nThe above code is a function to find if the given number is a perfect cube or not.\n\ndef is_strong_numbers(num1):\n    total_value = 0\n    factorial ="], [0.10517120574935265, 0.10909090909090909, 0.19538380490965174, "def get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)\nThe above code is a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.\n\ndef min_k(test_list, K):\n  res = sorted(test_list, key = lambda x: x[1])[:K]\n  return (res) \nThe above code is a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is to find the minimum swaps required to make the strings equal. https://www.geeksforgeeks.org/minimum-swaps-required-bring-string-equal/ - in this case a verbatim copy of test cases\ndef minChange(arr, target) : \n    lookup = {} \n    return minChangeUtil(arr, 0, target, lookup) # Pass our list, an index of 0, our target and the empty dictionary  "], [0.1515465563659264, 0.2, 0.4107053191063, "def lps(str): \n\tn = len(str) \n\tL = [[0 for x in range(n)] for x in range(n)] \n\tfor i in range(n): \n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1): \n\t\tfor i in range(n-cl+1): \n\t\t\tj = i+cl-1\n\t\t\tif str[i] == str[j] and cl == 2: \n\t\t\t\tL[i][j] = 2\n\t\t\telif str[i] == str[j]: \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse: \n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\treturn L[0][n-1]\nThe above code is a function to find the length of the longest palindromic subsequence in the given string.\n\nimport re\ndef remove_parenthesis(items):\n for item in items:\n    return (re.sub(r\" ?\\([^)]+\\)\", \"\", item))\nThe above code is a function to remove the parenthesis and what is inbetween them from a string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to determine if the a string can be converted to another string using a limited number of swaps.\n'''"], [0.10482942926858664, 0.10869565217391304, 0.1935998101839458, "import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\nThe above code is a function to merge three dictionaries into a single dictionary.\n\ndef re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\nThe above code is a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to compute minimum characters to be swapped in a string such that it is converted to another string.\ndef find_keywise_minimum(Dict):\n    min_val = None\n    min_key = None\n    min_sum_val=sum(list(Dict.values()))\n    if min_sum_val==0:\n        return {k:0 for k in Dict.keys() if k not in str(0"], [0.03876913192850613, 0.034482758620689655, 0.09224901800816508, "def babylonian_squareroot(number):\n    if(number == 0):\n        return 0;\n    g = number/2.0;\n    g2 = g + 1;\n    while(g != g2):\n        n = number/ g;\n        g2 = g;\n        g = (g + n)/2;\n    return g;\nThe above code is a function for computing square roots using the babylonian method.\n\ndef max_sub_array_sum(a, size):\n  max_so_far = 0\n  max_ending_here = 0\n  for i in range(0, size):\n    max_ending_here = max_ending_here + a[i]\n    if max_ending_here < 0:\n      max_ending_here = 0\n    elif (max_so_far < max_ending_here):\n      max_so_far = max_ending_here\n  return max_so_far\nThe above code is a function to find the sum of the largest contiguous sublist in the given list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is to compare the weweyekly challenge that occured on 29 July 2020.\n"], [0.10285970019965297, 0.07575757575757576, 0.1421419403961496, "def get_ludic(n):\n\tludics = []\n\tfor i in range(1, n + 1):\n\t\tludics.append(i)\n\tindex = 1\n\twhile(index != len(ludics)):\n\t\tfirst_ludic = ludics[index]\n\t\tremove_index = index + first_ludic\n\t\twhile(remove_index < len(ludics)):\n\t\t\tludics.remove(ludics[remove_index])\n\t\t\tremove_index = remove_index + first_ludic - 1\n\t\tindex += 1\n\treturn ludics\nThe above code is a function to get all lucid numbers smaller than or equal to a given integer.\n\ndef is_decimal(num):\n    import re\n    dnumre = re.compile(r\"\"\"^[0-9]+(\\.[0-9]{1,2})?$\"\"\")\n    result = dnumre.search(num)\n    return bool(result)\nThe above code is a function to check whether a given string is a decimal number with a precision of 2.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to minimise the swaps required to make two strings similar.\n\ndivisors = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167"], [0.33543474857730043, 0.2894736842105263, 0.26575338139500615, "def search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)\nThe above code is a python function to find the element that appears only once in a sorted array.\n\ndef find_First_Missing(array,start=0,end=None):\n    if end is None:\n      end = len(array) - 1   \n    if (start > end): \n        return end + 1\n    if (start != array[start]): \n        return start; \n    mid = int((start + end) / 2) \n    if (array[mid] == mid): \n        return find_First_Missing(array,mid+1,end) \n    return find_First_Missing(array,start,mid) \nThe above code is a python function to find the smallest missing number from a sorted list of natural numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum number of swaps required to convert a string into another string.\n\ndef find_Pair_CyclicNonRepeating(arr):\n  temp = {} \n  num=temp[arr[0]]=[1] \n  for i in range(1,len(arr)): \n    if (arr[i] in temp.keys()): \n      num=temp[arr[i]] \n"], [0.19376775614181105, 0.25925925925925924, 0.32936083468494204, "def odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count \nThe above code is a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.\n\ndef find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0\nThe above code is a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum changes required in string to make it an anagram.\n"], [0.08413851445460446, 0.08163265306122448, 0.09427513839745308, "def insert_element(list,element):\n list = [v for elt in list for v in (element, elt)]\n return list\nThe above code is a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n\ndef get_ludic(n):\n\tludics = []\n\tfor i in range(1, n + 1):\n\t\tludics.append(i)\n\tindex = 1\n\twhile(index != len(ludics)):\n\t\tfirst_ludic = ludics[index]\n\t\tremove_index = index + first_ludic\n\t\twhile(remove_index < len(ludics)):\n\t\t\tludics.remove(ludics[remove_index])\n\t\t\tremove_index = remove_index + first_ludic - 1\n\t\tindex += 1\n\treturn ludics\nThe above code is a function to get all lucid numbers smaller than or equal to a given integer.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " will preform how many swaps are need to turn one string into the other.\n\t\t\t\t\t\ndef shortestSeq(bigger,smaller):\n\tseq_list, char_count_dict, longest_len, len_smaller = [],{}, 1, len(smaller)\n\tfor i in range(len(bigger) - len_smaller + 1):\n\t\tif bigger[i] not in char_count"], [0.08279158152963234, 0.078125, 0.1477276761922219, "def count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars \nThe above code is a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n\ndef sample_nam(sample_names):\n  sample_names=list(filter(lambda el:el[0].isupper() and el[1:].islower(),sample_names))\n  return len(''.join(sample_names))\nThe above code is a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to know that the strings can be converted to equivalent strings or not.\n    \n    \n    \n  \n\n\n# Problem :-\n# The required function takes an integer value and returns an integer value that represents the name score of the input.\n# Step 1:- First of all add up the value of all the letters of any name where A = 1, B = 2 and so on up to Z = 26.\n# For example, the name COLIN"], [0.12782612782773345, 0.16666666666666666, 0.21698316214319227, "def get_total_number_of_sequences(m,n): \n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \n\tfor i in range(m+1): \n\t\tfor j in range(n+1): \n\t\t\tif i==0 or j==0: \n\t\t\t\tT[i][j]=0\n\t\t\telif i<j: \n\t\t\t\tT[i][j]=0\n\t\t\telif j==1: \n\t\t\t\tT[i][j]=i \n\t\t\telse: \n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \n\treturn T[m][n]\nThe above code is a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\nimport math\ndef volume_cone(r,h):\n  volume = (1.0/3) * math.pi * r * r * h\n  return volume\nThe above code is a function to find the volume of a cone.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate minimum swaps required to xform a string into another.\n\ndef longest_increasing_subsequence(x) : \n    lis = [1] * len(x)   \n    for i in range(1, len(x)) : \n        for j in range(0, i) : \n            if ((x[i] > x[j]) and (lis[i] < lis[j] + 1"], [0.15807798680556046, 0.16279069767441862, 0.12208505863973736, "def check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) \nThe above code is a function to check if all the elements in tuple have same data type or not.\n\ndef max_sub_array_sum_repeated(a, n, k): \n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k): \n\t\tmax_ending_here = max_ending_here + a[i%n] \n\t\tif (max_so_far < max_ending_here): \n\t\t\tmax_so_far = max_ending_here \n\t\tif (max_ending_here < 0): \n\t\t\tmax_ending_here = 0\n\treturn max_so_far\nThe above code is a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps requried in converting a given str1 into str2.\ndef fun(bin_list,element):\n    if len(bin_list) > 1: \n        median = len(bin_list)//2\n        l = bin_list[:median]\n        r = bin_list[median:]\n        fun(l,element)\n        fun(r,element)\n       "], [0.20386583416482718, 0.28, 0.3567249004890028, "def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  \nThe above code is a python function to check if a given number is one less than twice its reverse.\n\ndef is_Sub_Array(A,B): \n    n = len(A)\n    m = len(B)\n    i = 0; j = 0; \n    while (i < n and j < m):  \n        if (A[i] == B[j]): \n            i += 1; \n            j += 1; \n            if (j == m): \n                return True;  \n        else: \n            i = i - j + 1; \n            j = 0;       \n    return False; \nThe above code is a python function to check whether a list is sublist of another or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to print minimum swaps required to get both the strings identical.\n"], [0.21243547721692102, 0.1956521739130435, 0.3149478904023957, "def armstrong_number(number):\n sum = 0\n times = 0\n temp = number\n while temp > 0:\n           times = times + 1\n           temp = temp // 10\n temp = number\n while temp > 0:\n           reminder = temp % 10\n           sum = sum + (reminder ** times)\n           temp //= 10\n if number == sum:\n           return True\n else:\n           return False\nThe above code is a function to check whether the given number is armstrong or not.\n\ndef min_k(test_list, K):\n  res = sorted(test_list, key = lambda x: x[1])[:K]\n  return (res) \nThe above code is a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a snippet to count the swapped characters between two strings of equal length. Convert the two strings to their corresponding character set {0, 1, 2}}, and the number of different characters will be the number of swaps required to convert one to the other.\nFrom the problem statement, given 'CCACACGGCGCGCCGAAATTTAACAAGCACATTGCTGAATGACTGTCCAAAATTCGGTTGTTTTGTGGGGAAAGAAGG"], [0.17152374007204377, 0.17391304347826086, 0.12639718628862232, "def max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    \nThe above code is a python function to find a pair with highest product from a given array of integers.\n\ndef cal_sum(n): \n\ta = 3\n\tb = 0\n\tc = 2\n\tif (n == 0): \n\t\treturn 3\n\tif (n == 1): \n\t\treturn 3\n\tif (n == 2): \n\t\treturn 5\n\tsum = 5\n\twhile (n > 2): \n\t\td = a + b \n\t\tsum = sum + d \n\t\ta = b \n\t\tb = c \n\t\tc = d \n\t\tn = n-1\n\treturn sum\nThe above code is a function to calculate the sum of perrin numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " returns the minimum amount of swaps required to convert a string into another string.\ndef Permutation(str): \n    if len(str) == 0: \n        return []  \n    if len(str) == 1: \n        return [str] \n    l = []\n    for i in range(len(str)): \n        m = str[i] \n        remstr = str[:i] + str[i"], [0.15750048782547443, 0.16666666666666666, 0.09833870062517146, "def pancake_sort(nums):\n    arr_len = len(nums)\n    while arr_len > 1:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums\nThe above code is a function to sort a list of elements.\n\ndef count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars \nThe above code is a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes two strings as input. It then gives the minimum number of swaps required for a reshuffling for both the strings such that there is a rearrangement.\ndef min_count(s):\n    l1=list(s)\n    l2=[]\n    index=[(i,ele) for i , ele in enumerate(l1)]\n    for i in index :\n        ele=i[1]\n        dgt"], [0.14155229425102625, 0.1702127659574468, 0.28840352600770225, "def find_Odd_Pair(A,N) : \n    oddPair = 0\n    for i in range(0,N) :  \n        for j in range(i+1,N) :  \n            if ((A[i] ^ A[j]) % 2 != 0):  \n                oddPair+=1  \n    return oddPair  \nThe above code is a python function to count the number of pairs whose xor value is odd.\n\ndef get_ludic(n):\n\tludics = []\n\tfor i in range(1, n + 1):\n\t\tludics.append(i)\n\tindex = 1\n\twhile(index != len(ludics)):\n\t\tfirst_ludic = ludics[index]\n\t\tremove_index = index + first_ludic\n\t\twhile(remove_index < len(ludics)):\n\t\t\tludics.remove(ludics[remove_index])\n\t\t\tremove_index = remove_index + first_ludic - 1\n\t\tindex += 1\n\treturn ludics\nThe above code is a function to get all lucid numbers smaller than or equal to a given integer.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to calculate the minimum number of swaps to transform one sting to another using only swaps.\ndef letterChanges(str) : \n    vowels = ['a', 'e', 'i', 'o', 'u']\n    final_alphabets = []\n    for alphabet in str :\n        if alphabet.isalpha() :\n            if alphabet.lower() in vowels :\n                final_alphabets.append(chr(ord"], [0.1417844253158187, 0.17307692307692307, 0.16885538849595938, "def check_integer(text):\n text = text.strip()\n if len(text) < 1:\n    return None\n else:\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\n          return True\n     elif (text[0] in \"+-\") and \\\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\n         return True\n     else:\n        return False\nThe above code is a function to check if a string represents an integer or not.\n\ndef set_left_most_unset_bit(n): \n    if not (n & (n + 1)): \n        return n \n    pos, temp, count = 0, n, 0 \n    while temp: \n        if not (temp & 1): \n            pos = count      \n        count += 1; temp>>=1\n    return (n | (1 << (pos))) \nThe above code is a python function to set the left most unset bit.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to know the minimum  swaps required to make\nthe string anagram.Anagram is a rearrangement of the characters in a particular \norder,a result of rearranging the letters of the word or phrase which yields the anagram.\n                    \ndef mergeLists(headA, headB):\n    dummy = head = ListNode(0)\n    while headA and headB:\n        if headA.val < headB."], [0.1386521772492474, 0.19148936170212766, 0.2527940316262415, "import re\ndef find_char_long(text):\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))\nThe above code is a function to find all words which are at least 4 characters long in a string.\n\ndef get_total_number_of_sequences(m,n): \n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \n\tfor i in range(m+1): \n\t\tfor j in range(n+1): \n\t\t\tif i==0 or j==0: \n\t\t\t\tT[i][j]=0\n\t\t\telif i<j: \n\t\t\t\tT[i][j]=0\n\t\t\telif j==1: \n\t\t\t\tT[i][j]=i \n\t\t\telse: \n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \n\treturn T[m][n]\nThe above code is a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in two strings of equal length and finds the minimum number of swaps needed to convert the first string into the second string.\nimport string \ndef get_shortest_unique_substring(letters,s): \n\tlowerCase = s.lower()  \n\tu,count=[],{} \n\tfor x in lowerCase : \n\t\tif x in letters:  \n\t\t\tcount[x]=0 \n"], [0.08364126121178567, 0.0847457627118644, 0.14862641260813825, "def extract_index_list(l1, l2, l3):\n    result = []\n    for m, n, o in zip(l1, l2, l3):\n        if (m == n == o):\n            result.append(m)\n    return result\nThe above code is We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. a function to find common elements from three lists. The function should return a list.\n\nfrom itertools import combinations \ndef find_combinations(test_list):\n  res = [(b1 + a1, b2 + a2) for (a1, a2), (b1, b2) in combinations(test_list, 2)]\n  return (res) \nThe above code is a function to find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " shows an Algorithm in which maximum deletions and change allowed are 1. This can be converted to minimum swaps by making the change of characters at a time take a gap of 2 instead of 1. to run a test :\n\n# example 1\n#Both strings are 'pnefix'\nprint(min_Swaps('pre' , 'post')) \n#Output\n2\n  \n#example 2\n#Both strings are 'geeksoverflow'"], [0.05741318835640279, 0.18181818181818182, 0.261164911420765, "def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True\nThe above code is a function to calculate whether the matrix is a magic square.\n\ndef is_lower(string):\n  return (string.lower())\nThe above code is a python function to convert the given string to lower case.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is the python function to calculate the minimum swaps.\n"], [0.1996656071537712, 0.18181818181818182, 0.18814775175820075, "def sample_nam(sample_names):\n  sample_names=list(filter(lambda el:el[0].isupper() and el[1:].islower(),sample_names))\n  return len(''.join(sample_names))\nThe above code is a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n\nimport math \ndef count_divisors(n) : \n    count = 0\n    for i in range(1, (int)(math.sqrt(n)) + 2) : \n        if (n % i == 0) : \n            if( n // i == i) : \n                count = count + 1\n            else : \n                count = count + 2\n    return count % 2 == 0\nThe above code is a python function to check whether the count of divisors is even. https://www.w3resource.com/python-exercises/basic/python-basic-1-exercise-24.php\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to count the number of swaps required.\nimport itertools \n  \ndef choose_best_sum(t, k, ls):\n    Max=0\n    if all(x>t for x in ls):\n        max=-1\n    else:\n        a = itertools.combinations(ls,k) \n        for i in list(a): \n            if sum(i) <= t and sum("], [0.13896829477902325, 0.1702127659574468, 0.14716519820352508, "def list_to_float(test_list):\n  res = []\n  for tup in test_list:\n    temp = []\n    for ele in tup:\n      if ele.isalpha():\n        temp.append(ele)\n      else:\n        temp.append(float(ele))\n    res.append((temp[0],temp[1])) \n  return res\nThe above code is a function to convert all possible convertible elements in a list of lists to floats.\n\ndef is_Sub_Array(A,B): \n    n = len(A)\n    m = len(B)\n    i = 0; j = 0; \n    while (i < n and j < m):  \n        if (A[i] == B[j]): \n            i += 1; \n            j += 1; \n            if (j == m): \n                return True;  \n        else: \n            i = i - j + 1; \n            j = 0;       \n    return False; \nThe above code is a python function to check whether a list is sublist of another or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum swaps required between two strings of equal length.\n\nPalindrome and anagram or not\ndef Pallin(n) :\n    res = n[len(n)::-1]\n    if res == n : \n        return \"Pallindrome\"    \n    else : \n        return \"Not Pallindrome\"\ndef Palin_or_anagram(a,b) :\n    if len"], [0.1969400633669834, 0.19148936170212766, 0.2788429362108055, "def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums\nThe above code is a function to sort a list of elements.\n\nfrom collections import defaultdict\ndef max_aggregate(stdata):\n    temp = defaultdict(int)\n    for name, marks in stdata:\n        temp[name] += marks\n    return max(temp.items(), key=lambda x: x[1])\nThe above code is a function to calculate the maximum aggregate from the list of tuples.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to return the minimum number of swaps required to make two strings equal.\n\ndef min_swaps(arr1,arr2):\n    size = len(arr1)\n    count = 0\n    for  i in range(0,size,1):\n        if arr1[i] != arr2[i]:\n            count += 1\n    if count % 2 == 0:\n        return count // 2\n    else:\n       "], [0.14980076196369907, 0.19298245614035087, 0.33432903885564424, "def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s \nThe above code is a python function to remove first and last occurrence of a given character from the string.\n\ndef largest_subset(a):\n\tn = len(a)\n\tdp = [0 for i in range(n)]\n\tdp[n - 1] = 1; \n\tfor i in range(n - 2, -1, -1):\n\t\tmxm = 0;\n\t\tfor j in range(i + 1, n):\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\n\t\t\t\tmxm = max(mxm, dp[j])\n\t\tdp[i] = 1 + mxm\n\treturn max(dp)\nThe above code is a function to find the size of the largest subset of a list of numbers so that every pair is divisible.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check if two strings are same when swapping two characters of the two strings. If they are not same, then it counts the number of swaps required to convert the first string to second string, and if the answer is even, then it returns the count as number of swaps required to convert first string to second string, if answer is odd, it return \"Not Possible\".\nThe above code has a time complexity of O(n) and space complexity of O(1)."], [0.08692695086292324, 0.09375, 0.2337406433534408, "from collections import Counter \ndef check_occurences(test_list):\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\n  return  (res) \nThe above code is a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > current_item:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n\n    return my_list\nThe above code is a function to sort the given array by using shell sort.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that is used to find the minimum Swaps that is needed in order to transform the given string to the second string. This function will return either an integer(1,2...) or a response of \"Not Possible\".\naaadedin\na\u00e9aoin \nThe above two strings have 9 letters from the second string that are missing to make the first string equal to the second string, so for this type of a problem it will return \"9\". \n\t"], [0.09937985198436611, 0.10344827586206896, 0.1771395106062658, "def square_nums(nums):\n square_nums = list(map(lambda x: x ** 2, nums))\n return square_nums\nThe above code is a function to find squares of individual elements in a list.\n\ndef magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True\nThe above code is a function to calculate whether the matrix is a magic square.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the shortest length of permutations\nWhich takes in two words from a fourtuple and gives the smallest number of backward movements of characters required to make str1 an anagram of str2.\ndef pairs_with_diff(arr, k):\n    pairs = []\n    for i in range(0, len(arr)):\n        for j in range(i + 1, len(arr)):\n            if abs(arr[i"], [0.14600197049518712, 0.28, 0.4745631959886595, "import heapq\ndef k_smallest_pairs(nums1, nums2, k):\n   queue = []\n   def push(i, j):\n       if i < len(nums1) and j < len(nums2):\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n   push(0, 0)\n   pairs = []\n   while queue and len(pairs) < k:\n       _, i, j = heapq.heappop(queue)\n       pairs.append([nums1[i], nums2[j]])\n       push(i, j + 1)\n       if j == 0:\n           push(i + 1, 0)\n   return pairs\nThe above code is a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\nfrom itertools import groupby\ndef pack_consecutive_duplicates(list1):\n    return [list(group) for key, group in groupby(list1)]\nThe above code is a function to pack consecutive duplicates of a given list elements into sublists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to minimum number of Swaps required to make two strings anagram.\n'''"], [0.09390473589832755, 0.1, 0.12579029786150892, "def bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \nThe above code is a function to find the number of ways to partition a set of Bell numbers.\n\ndef frequency_lists(list1):\n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        if num in dic_data.keys():\n            dic_data[num] += 1\n        else:\n            key = num\n            value = 1\n            dic_data[key] = value\n    return dic_data\n\nThe above code is a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimal swaps of string to make them equal. If it is not possible, \"Not Possible\" will be printed.\ndef isValid(s):\n    stack = []\n    lookup = {\"(\" : \")\", \"{\" : \"}\", \"[\" : \"]\"}\n    for character in s:\n        if character in lookup:\n            stack.append(character)\n        elif len(stack) == 0 or lookup[stack."], [0.1996233408733759, 0.16363636363636364, 0.282007325380532, "def find_first_occurrence(A, x):\n    (left, right) = (0, len(A) - 1)\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if x == A[mid]:\n            result = mid\n            right = mid - 1\n        elif x < A[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return result\nThe above code is a function to find the index of the first occurrence of a given number in a sorted array.\n\ndef find_min_diff(arr,n): \n    arr = sorted(arr) \n    diff = 10**20 \n    for i in range(n-1): \n        if arr[i+1] - arr[i] < diff: \n            diff = arr[i+1] - arr[i]  \n    return diff \nThe above code is a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is python function to find the minimum number of swaps required to convert str1 to str2. Assume Both str1 and str2 contains unique elements.\ndef int_to_str(n):\n    if n == 0 :\n        return \"0\"\n    res = []\n    while (n != 0):\n        res = res + [n % 10]\n        n = n // 10\n        if n < 0:\n            return None\n    res"], [0.14893666774701345, 0.15384615384615385, 0.3287248046844366, "import re \nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\ndef check_str(string): \n\treturn re.search(regex, string)\nThe above code is a function to check whether the given string is starting with a vowel or not using regex.\n\ndef check_min_heap_helper(arr, i):\n    if 2 * i + 2 > len(arr):\n        return True\n    left_child = (arr[i] <= arr[2 * i + 1]) and check_min_heap_helper(arr, 2 * i + 1)\n    right_child = (2 * i + 2 == len(arr)) or (arr[i] <= arr[2 * i + 2] \n                                      and check_min_heap_helper(arr, 2 * i + 2))\n    return left_child and right_child\n\ndef check_min_heap(arr):\n  return check_min_heap_helper(arr, 0)\nThe above code is a function to check if the given array represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the number of swaps required to make str1 & str2 equal. That is the number of swaps required to be done either by frontend developer to make strings symmetrical or rear-end developer to make strings symmetrical.\ndef move_Zeros(arr) : \n    count = 0\n    for i in range(len(arr)) : \n        if arr[i] != 0 : \n            arr[count] = arr["], [0.07558447959256481, 0.023255813953488372, 0.013321058694874339, "def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)\nThe above code is a function to sum all amicable numbers from 1 to a specified number.\n\ndef count_list(input_list): \n    return len(input_list)\nThe above code is a python function to count the number of lists in a given number of lists.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " basically checks the percentage of swapping between two strings.\n\t\ndef atomic_weight_molecule(s):\n\tdata = s.lower().replace('(','').replace(')','').split()\n\tind = 0\n\ttotal = 0\n\tif (len(data) % 2)==0:\n\t\tind=0\n\telse:\n\t\tind=1\n\twhile ind<len(data):\n\t\tif"], [0.14919747258416033, 0.23255813953488372, 0.2444154707531043, "def check_integer(text):\n text = text.strip()\n if len(text) < 1:\n    return None\n else:\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\n          return True\n     elif (text[0] in \"+-\") and \\\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\n         return True\n     else:\n        return False\nThe above code is a function to check if a string represents an integer or not.\n\ndef unique_sublists(list1):\n    result ={}\n    for l in  list1: \n        result.setdefault(tuple(l), list()).append(1) \n    for a, b in result.items(): \n        result[a] = sum(b)\n    return result\nThe above code is a function to count lists within a list. The function should return a dictionary where every list is converted to a tuple and the value of such tuple is the number of its occurencies in the original list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count the number of swaps that would be required to make one string a substring of the other.\n\n# Evaluate postfix expressions\ndef eval_post_exp(li):\n    stack=[]\n    for i in li:\n        if i in '1234567890':\n            stack.append(int(i))\n        else:\n            b=stack.pop()\n            a=stack.pop()\n\n            if i"], [0.08610865034627765, 0.061224489795918366, 0.09299514308417793, "def find_first_occurrence(A, x):\n    (left, right) = (0, len(A) - 1)\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if x == A[mid]:\n            result = mid\n            right = mid - 1\n        elif x < A[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return result\nThe above code is a function to find the index of the first occurrence of a given number in a sorted array.\n\ndef count_reverse_pairs(test_list):\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \n  return res\nThe above code is a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is the function to find the minimum swap to make the strings equal. \n\n\ndef three_sum(test_list):\n    test_list.sort()\n    res = set()\n    length = len(test_list)\n    for i in range(0, length - 2):\n        for j in range(i + 1, length - 1):\n            for k in range(j + 1, length):\n                if test_list[i"], [0.09453820380554658, 0.1111111111111111, 0.1826675155348062, "def is_Diff(n): \n    return (n % 11 == 0) \nThe above code is a python function to find whether a number is divisible by 11.\n\ndef is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1\nThe above code is a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that converts a given string into another in the minimum number of swap operations in any permutation. If there is any letter with one swap, it cannot be less than one so return Notpossible.\n\n# C++ Problems (5pts)\n# Only do the C++ problems if you feel comfortable with C++. Most of these answer will be readily available to you if you go through the C++ tutorial posted above. Feel free to look for for resources online"], [0.10993547388535156, 0.09259259259259259, 0.21538050907648987, "def is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1\nThe above code is a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\n\ndef split(word): \n    return [char for char in word] \nThe above code is a python function to split a string into characters.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " returns the minimum number of swaps that can be applied on str1 to minimize the mismatch of characters by performing two swaps and the two swaps can be to the left or two swaps can be to the right of the. \ndef ZAlgorithm(s) : \n    n = len(s) \n    Z = [0]  * n \n    Z[0] = n \n    i = 1\n    j = 0\n    while ( i <"], [0.12029993276645806, 0.15517241379310345, 0.3278794688927971, "def max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]\nThe above code is a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\n\ndef test_three_equal(x,y,z):\n  result = set([x,y,z])\n  if len(result)==3:\n    return 0\n  else:\n    return 4-len(result)\nThe above code is a python function to count the number of equal numbers from three given integers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to count the number of number of swaps to be made to change one string to another which has the same order of characters.\nFinding a Longest Bitonic Subsequence of size three in O(ND) time\nHere are the details of the algorithm to find the Longest Bitonic Subsequence.\n\nStarting with a given array arr[i],\nif arr[i] > arr[i+1],\n       Longest increasing subsequence is formed by putting"], [0.1192451550198637, 0.14285714285714285, 0.2264713424173909, "def max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]\nThe above code is a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\n\ndef second_smallest(numbers):\n  unique_numbers = list(set(numbers))\n  unique_numbers.sort()\n  if len(unique_numbers) < 2:\n    return None\n  else:\n    return unique_numbers[1]\nThe above code is a function to find the second smallest number in a list.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps to convert a string to another if the characters can be swapped only once.\ndef stringSimilarity(arr, s):\n    sLen = len(s) \n    result = 0\n    for ele in set(arr): \n          curLen = 0\n          fLen = 0\n          for i in range(0, sLen): \n              if (s[i] == ele): \n                    fLen"], [0.1684157229281207, 0.15517241379310345, 0.32875139628763994, "import re\ndef text_match_two_three(text):\n        patterns = 'ab{2,3}'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\nThe above code is a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n\nimport heapq\ndef k_smallest_pairs(nums1, nums2, k):\n   queue = []\n   def push(i, j):\n       if i < len(nums1) and j < len(nums2):\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n   push(0, 0)\n   pairs = []\n   while queue and len(pairs) < k:\n       _, i, j = heapq.heappop(queue)\n       pairs.append([nums1[i], nums2[j]])\n       push(i, j + 1)\n       if j == 0:\n           push(i + 1, 0)\n   return pairs\nThe above code is a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " returns the minimum number of swaps required to convert a string into another string.\nYou have been given a String S consisting of uppercase and lowercase English alphabets. You need to change the case of each alphabet in this String. That is, all the uppercase letters should be converted to lowercase and all the lowercase letters should be converted to uppercase. You need to then print the resultant String to output.\n\nSolve : print(S."], [0.08562222398442376, 0.09433962264150944, 0.15402491284332975, "def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True\nThe above code is a function to calculate whether the matrix is a magic square.\n\ndef min_k(test_list, K):\n  res = sorted(test_list, key = lambda x: x[1])[:K]\n  return (res) \nThe above code is a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is to find minimum swaps for switching the strings. There is no gurantee for minimum switch cases and hence a single method to solve this problem. Hence I modeled the code as closest possible stores.\n\n#https://www.geeksforgeeks.org/timeit-python-examples/  \nLIST_SIZE = 1000005\ndef random_lst_generate(list_size): \n    tempList = [] \n    for i in"], [0.13402105827906602, 0.15217391304347827, 0.24757831913615896, "def count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count \nThe above code is a python function to count the number of set bits (binary digits with value 1) in a given number.\n\ndef max_sum(arr): \n\tMSIBS = arr[:] \n\tfor i in range(len(arr)): \n\t\tfor j in range(0, i): \n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \n\tMSDBS = arr[:] \n\tfor i in range(1, len(arr) + 1): \n\t\tfor j in range(1, i): \n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \n\tmax_sum = float(\"-Inf\") \n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \n\t\tmax_sum = max(max_sum, i + j - k) \n\treturn max_sum\nThe above code is a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " counts the number of swaps necessary to make two strings the same. If word W = PQR is a string and word X = ABC if a string, then the optimal solution to this problem is that W = ACB, X = CBA, where the number of swaps required is 1.\n"], [0.07521571901291332, 0.14814814814814814, 0.15059015608288126, "def is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True\nThe above code is a function to check whether the given number is undulating or not.\n\nfrom collections import deque\ndef check_expression(exp):\n    if len(exp) & 1:\n        return False\n    stack = deque()\n    for ch in exp:\n        if ch == '(' or ch == '{' or ch == '[':\n            stack.append(ch)\n        if ch == ')' or ch == '}' or ch == ']':\n            if not stack:\n                return False\n            top = stack.pop()\n            if (top == '(' and ch != ')') or (top == '{' and ch != '}' or (top == '[' and ch != ']')):\n                return False\n    return not stack\nThe above code is a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to check whether is strings are rotations of each other.\n'''"], [0.2303754315054947, 0.3076923076923077, 0.3340170144152438, "def is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1\nThe above code is a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\n\nimport math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN \nThe above code is a python function to find the next perfect square greater than a given number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find the minimum swaps required to get the two strings of equal characters.\n"], [0.09666534927632968, 0.1, 0.08251851161451752, "def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)\nThe above code is a function to sum all amicable numbers from 1 to a specified number.\n\nimport re\ndef text_match_wordz(text):\n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\nThe above code is a function that matches a word containing 'z'.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to solve the difference of two strings.\nimport os\ndef file_list():\n    files = []\n    for entry in os.listdir(\"./\"):\n        if os.path.isfile(entry):\n            files.append(entry)\n    return files\nThe above code is a function list the files under a directory given as a paramter.\nimport re\nstr=input()\nstr2=re.split('\\s"], [0.10834014839633459, 0.14285714285714285, 0.08222777192155303, "def is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1\nThe above code is a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\n\ndef all_Characters_Same(s) :\n    n = len(s)\n    for i in range(1,n) :\n        if s[i] != s[0] :\n            return False\n    return True\nThe above code is a python function to check whether all the characters are same or not.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to check whether no.of swaps required in \"Monk and Welcome Problem\" on acm ICPC practice problems.\n\nTrue and True\nFalse and True\n1 == 1 and 2 == 1\n\"test\" == \"test\"\n1 == 1 or 2 != 1\nTrue and 1 == 1\nFalse and 0 != 0\nTrue or 1 == 1\n\"test\" == \"testing\"\n1 != 0 and 2 == 1\n\"test\""], [0.10280373255830105, 0.21739130434782608, 0.3278250704228367, "NO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) \nThe above code is a function to remove characters from the first string which are present in the second string.\n\nimport bisect\ndef right_insertion(a, x):\n    return bisect.bisect_right(a, x)\nThe above code is a function to locate the right insertion point for a specified value in sorted order.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to minimize the swaps required to adjust the string.\n"], [0.20646048051896934, 0.21621621621621623, 0.19724267174290447, "def lps(str): \n\tn = len(str) \n\tL = [[0 for x in range(n)] for x in range(n)] \n\tfor i in range(n): \n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1): \n\t\tfor i in range(n-cl+1): \n\t\t\tj = i+cl-1\n\t\t\tif str[i] == str[j] and cl == 2: \n\t\t\t\tL[i][j] = 2\n\t\t\telif str[i] == str[j]: \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse: \n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\treturn L[0][n-1]\nThe above code is a function to find the length of the longest palindromic subsequence in the given string.\n\ndef find_First_Missing(array,start=0,end=None):\n    if end is None:\n      end = len(array) - 1   \n    if (start > end): \n        return end + 1\n    if (start != array[start]): \n        return start; \n    mid = int((start + end) / 2) \n    if (array[mid] == mid): \n        return find_First_Missing(array,mid+1,end) \n    return find_First_Missing(array,start,mid) \nThe above code is a python function to find the smallest missing number from a sorted list of natural numbers.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a python function to find minimum swaps required to make two given strings anagram of each other.\ndef k_smallest(arr,s,e,k):\n  while(s<=e):\n    pos,i,j=s,s+1,e\n    while(i<=j):\n      while(i<=j and arr[pos]>=arr[i]):\n        i+=1\n      while(i<"], [0.08117726984729154, 0.07692307692307693, 0.164051657038879, "def check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) \nThe above code is a function to check if all the elements in tuple have same data type or not.\n\ndef is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1\nThe above code is a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes 2 strings as input and returns how many characters have to be swapped in these two strings to make them identical by changing the position of each character.\n\n\n'''''''''''''''''\ncv2.waitKey()\ncv2.destroyAllWindows() \n'''''''''''''''''\nThe above line of code is used to finish writing the code and to close all the windows once the user will hit the exit button in the IDE of Spyder.\n\n\n\n"], [0.18140497858329913, 0.16666666666666666, 0.1726059291202901, "def is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False   \n\n    for values in sdict.values():\n\n        for i in range(len(values) - 1):\n            if values[i] != values[i+1]:\n                return False\n\n    return True\nThe above code is a function to check whether it follows the sequence given in the patterns array.\n\ndef check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\nThe above code is a function that takes in a list and element and checks whether all items in the list are equal to the given element.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that takes in 2 strings and returns the minumum no. of swaps required to revert them, if they are not similar.  \n"], [0.1816299718899655, 0.1891891891891892, 0.3371822471143815, "def max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]\nThe above code is a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\n\ndef filter_data(students,h,w):\n    result = {k: s for k, s in students.items() if s[0] >=h and s[1] >=w}\n    return result    \nThe above code is The input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. a function to filter students that have height and weight above the minimum.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum number of swaps needed in converting str1 to str2.\n\nTEST\nc = 0+1-7\ndef f(x):\n    return x+1-7\nd = 0\nprint(\"0+1-7=\"+f(d)) \n"], [0.10206626353096489, 0.13636363636363635, 0.10893136298741998, "def binomial_Coeff(n,k): \n    C = [0] * (k + 1); \n    C[0] = 1; # nC0 is 1 \n    for i in range(1,n + 1):  \n        for j in range(min(i, k),0,-1): \n            C[j] = C[j] + C[j - 1]; \n    return C[k]; \ndef sum_Of_product(n): \n    return binomial_Coeff(2 * n,n - 1); \nThe above code is a python function to find the sum of the product of consecutive binomial co-efficients.\n\nfrom collections import deque\ndef check_expression(exp):\n    if len(exp) & 1:\n        return False\n    stack = deque()\n    for ch in exp:\n        if ch == '(' or ch == '{' or ch == '[':\n            stack.append(ch)\n        if ch == ')' or ch == '}' or ch == ']':\n            if not stack:\n                return False\n            top = stack.pop()\n            if (top == '(' and ch != ')') or (top == '{' and ch != '}' or (top == '[' and ch != ']')):\n                return False\n    return not stack\nThe above code is a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find minimum swaps between strings.\ndef add_2_binary_numbers(arr1,arr2):\n  \n    arr1.reverse()\n    arr2.reverse()\n    \n    for s in range(len(arr1)):\n        sum = arr1[s]+arr2[s]\n        print(sum,end = '')\nThe above function adds two binary numbers in a very efficient way.\ndef only"], [0.1636136980648942, 0.18604651162790697, 0.2530950186507853, "def largest_subset(a):\n\tn = len(a)\n\tdp = [0 for i in range(n)]\n\tdp[n - 1] = 1; \n\tfor i in range(n - 2, -1, -1):\n\t\tmxm = 0;\n\t\tfor j in range(i + 1, n):\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\n\t\t\t\tmxm = max(mxm, dp[j])\n\t\tdp[i] = 1 + mxm\n\treturn max(dp)\nThe above code is a function to find the size of the largest subset of a list of numbers so that every pair is divisible.\n\nfrom collections import deque\ndef check_expression(exp):\n    if len(exp) & 1:\n        return False\n    stack = deque()\n    for ch in exp:\n        if ch == '(' or ch == '{' or ch == '[':\n            stack.append(ch)\n        if ch == ')' or ch == '}' or ch == ']':\n            if not stack:\n                return False\n            top = stack.pop()\n            if (top == '(' and ch != ')') or (top == '{' and ch != '}' or (top == '[' and ch != ']')):\n                return False\n    return not stack\nThe above code is a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the number of swaps required to make two strings equal if one of the strings contains one special character.\nfor i in range(1,202):\n    \n        if i%3 == 0 and i%5 == 0:\n              \n                    print('FizzBuzz')\n                    continue\n\n        elif i%5 == 0:   \n            \n                    print('Buzz')\n                    continue\n                    \n        elif i%3 == 0:"], [0.07984733261465657, 0.08163265306122448, 0.12981187830832966, "def is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False   \n\n    for values in sdict.values():\n\n        for i in range(len(values) - 1):\n            if values[i] != values[i+1]:\n                return False\n\n    return True\nThe above code is a function to check whether it follows the sequence given in the patterns array.\n\ndef common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result\nThe above code is a function that takes two lists and returns true if they have at least one common element.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that calculates Minimum swaps needed tree to match two strings. \n\ndef sort_strings(s, num_strings) : \n    c = 0\n    v = 0\n    dict = {} \n    for i in range(len(s)) : \n        dict[\"string \" + str(i)] = 0\n    \n    for i in range(num_strings) : \n        l = [] \n        j = 0\n"], [0.10458660959916134, 0.16129032258064516, 0.13432865146259002, "NO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) \nThe above code is a function to remove characters from the first string which are present in the second string.\n\ndef lps(str): \n\tn = len(str) \n\tL = [[0 for x in range(n)] for x in range(n)] \n\tfor i in range(n): \n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1): \n\t\tfor i in range(n-cl+1): \n\t\t\tj = i+cl-1\n\t\t\tif str[i] == str[j] and cl == 2: \n\t\t\t\tL[i][j] = 2\n\t\t\telif str[i] == str[j]: \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse: \n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\treturn L[0][n-1]\nThe above code is a function to find the length of the longest palindromic subsequence in the given string.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to return the minimum no.of swaps required.\n\nfunctions_to_be_called = []\n            functions_to_be_called.append(deb_space_remover)\n            functions_to_be_called.append(remove_dirty_chars)\n            functions_to_be_called.append(lps)\n            functions_to_be_called.append(min_Swaps)\n            for function"], [0.0843546581808802, 0.08450704225352113, 0.16546938193467844, "def sum_range_list(list1, m, n):                                                                                                                                                                                                \n    sum_range = 0                                                                                                                                                                                                         \n    for i in range(m, n+1, 1):                                                                                                                                                                                        \n        sum_range += list1[i]                                                                                                                                                                                                  \n    return sum_range   \nThe above code is a function to find the sum of numbers in a list within a range specified by two indices.\n\nimport heapq\ndef expensive_items(items,n):\n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items\nThe above code is a function to find the n most expensive items in a given dataset.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function that solves the question \"Counter game\" in which you have Alice and Bob playing, where they take turns changing a 0 in a sequence of integers to either 1s or 2s, and whoever changes the integer to obtain the longest sequence of 1s or 2s in a row without having any 0s in the middle wins*. They have an even number of turns. The task here is to write a code that given the sequence of integers represented by str1, and str2"], [0.19279456605862186, 0.23255813953488372, 0.285418628036913, "def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)\nThe above code is a function to sum all amicable numbers from 1 to a specified number.\n\nfrom collections import deque\ndef check_expression(exp):\n    if len(exp) & 1:\n        return False\n    stack = deque()\n    for ch in exp:\n        if ch == '(' or ch == '{' or ch == '[':\n            stack.append(ch)\n        if ch == ')' or ch == '}' or ch == ']':\n            if not stack:\n                return False\n            top = stack.pop()\n            if (top == '(' and ch != ')') or (top == '{' and ch != '}' or (top == '[' and ch != ']')):\n                return False\n    return not stack\nThe above code is a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to tell minimum number of swaps required which turns one string sensible but not the other. https://www.geeksforgeeks.org/minimum-swaps-required-transform-string-sensible-string/\ndef check_availability(arr1, n, m) : \n    s = set() \n    for i in range(n) : \n        s.add(arr1[i])  \n        for j in range("], [0.09106804011272653, 0.09836065573770492, 0.18243465269656375, "def is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False   \n\n    for values in sdict.values():\n\n        for i in range(len(values) - 1):\n            if values[i] != values[i+1]:\n                return False\n\n    return True\nThe above code is a function to check whether it follows the sequence given in the patterns array.\n\ndef amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)\nThe above code is a function to sum all amicable numbers from 1 to a specified number.\ndef min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \nThe above code", " is a function to find the minimum swaps between 2 strings which differ by at most 1 character.\ndef PerfectNumber(num):\n    total = 0\n    for i in range(1, num):\n        if num % i == 0:\n            total += i\n    return(total == num) \nThe above code is a function to indicate whether a number is a perfect number or not.\ndef BFS(games, nodes):\n    result = []\n"]]}
